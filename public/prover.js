// Generated by js_of_ocaml 4.0.0
(function(Object)
   {typeof globalThis
    !==
    "object"
    &&
    (this
      ?get()
      :(Object.defineProperty
         (Object.prototype,"_T_",{configurable:true,get:get}),
        _T_));
    function get()
     {var global=this || self;
      global.globalThis = global;
      delete Object.prototype._T_}}
  (Object));
(function(globalThis)
   {"use strict";
    var
     jsoo_exports=
      typeof module === "object" && module.exports || globalThis;
    function caml_array_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_array_fill(array,ofs,len,v)
     {for(var i=0;i < len;i++)array[ofs + i + 1] = v;return 0}
    function caml_array_sub(a,i,len)
     {var a2=new Array(len + 1);
      a2[0] = 0;
      for(var i2=1,i1=i + 1;i2 <= len;i2++,i1++)a2[i2] = a[i1];
      return a2}
    function caml_subarray_to_jsbytes(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,a.slice(i,i + Math.min(len,1024)));
      return s}
    function caml_convert_bytes_to_array(s)
     {if(globalThis.Uint8Array)
       var a=new (globalThis.Uint8Array)(s.l);
      else
       var a=new Array(s.l);
      var b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_blit_bytes(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_jsbytes(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_jsbytes(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_bytes_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    function caml_bytes_of_string(s){return s}
    function caml_blit_string(a,b,c,d,e)
     {caml_blit_bytes(caml_bytes_of_string(a),b,c,d,e);return 0}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function caml_str_repeat(n,s)
     {if(n == 0)return "";
      if(s.repeat)return s.repeat(n);
      var r="",l=0;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_jsbytes(s.c,0,s.c.length);
      s.t = 0}
    function jsoo_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return ! /[^\x00-\x7f]/.test(s)}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 0x80)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 0xe0)
           {v = c - 0x3080;if(v < 0x80)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 0xf0)
               {v = c - 0xe2080;
                if(v < 0x800 || v >= 0xd7ff && v < 0xe000)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  0xf5)
                 {v = c2 - 0x3c82080 + (c << 6);
                  if(v < 0x10000 || v > 0x10ffff)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10),0xdc00 + (v & 0x3FF));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function MlBytes(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlBytes.prototype.toString
    =
    function()
     {switch(this.t)
       {case 9:return this.c;
        default:caml_convert_string_to_bytes(this);case 0:
         if(jsoo_is_ascii(this.c)){this.t = 9;return this.c}this.t = 8;
        case 8:return this.c
        }};
    MlBytes.prototype.toUtf16
    =
    function()
     {var r=this.toString();
      if(this.t == 9)return r;
      return caml_utf16_of_utf8(r)};
    MlBytes.prototype.slice
    =
    function()
     {var content=this.t == 4?this.c.slice():this.c;
      return new MlBytes(this.t,content,this.l)};
    function caml_bytes_of_jsbytes(s){return new MlBytes(0,s,s.length)}
    function caml_string_of_jsbytes(s){return caml_bytes_of_jsbytes(s)}
    function caml_raise_with_string(tag,msg)
     {caml_raise_with_arg(tag,caml_string_of_jsbytes(msg))}
    var caml_global_data=[0];
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_bytes_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 0xff;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_bytes_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      if(typeof f !== "function")return f;
      var n=f.length | 0;
      if(n === 0)return f.apply(null,args);
      var argsLen=args.length | 0,d=n - argsLen | 0;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen(f.apply(null,args.slice(0,n)),args.slice(n));
       else
        return function()
         {var
           extra_args=arguments.length == 0?1:arguments.length,
           nargs=new Array(args.length + extra_args);
          for(var i=0;i < args.length;i++)nargs[i] = args[i];
          for(var i=0;i < arguments.length;i++)
           nargs[args.length + i] = arguments[i];
          return caml_call_gen(f,nargs)}}
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.2250738585072014e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    function caml_jsbytes_of_string(s)
     {s.t & 6 && caml_convert_string_to_bytes(s);return s.c}
    var log2_ok=Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return - Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int32_bits_of_float(x)
     {var float32a=new (globalThis.Float32Array)(1);
      float32a[0] = x;
      var int32a=new (globalThis.Int32Array)(float32a.buffer);
      return int32a[0] | 0}
    var caml_int64_offset=Math.pow(2,- 24);
    function caml_raise_constant(tag){throw tag}
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function MlInt64(lo,mi,hi)
     {this.lo = lo & 0xffffff;this.mi = mi & 0xffffff;this.hi = hi & 0xffff}
    MlInt64.prototype.caml_custom = "_j";
    MlInt64.prototype.copy
    =
    function(){return new MlInt64(this.lo,this.mi,this.hi)};
    MlInt64.prototype.ucompare
    =
    function(x)
     {if(this.hi > x.hi)return 1;
      if(this.hi < x.hi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.compare
    =
    function(x)
     {var hi=this.hi << 16,xhi=x.hi << 16;
      if(hi > xhi)return 1;
      if(hi < xhi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.neg
    =
    function()
     {var lo=- this.lo,mi=- this.mi + (lo >> 24),hi=- this.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.add
    =
    function(x)
     {var
       lo=this.lo + x.lo,
       mi=this.mi + x.mi + (lo >> 24),
       hi=this.hi + x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.sub
    =
    function(x)
     {var
       lo=this.lo - x.lo,
       mi=this.mi - x.mi + (lo >> 24),
       hi=this.hi - x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.mul
    =
    function(x)
     {var
       lo=this.lo * x.lo,
       mi=(lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
       hi=
        (mi * caml_int64_offset | 0)
        +
        this.hi
        *
        x.lo
        +
        this.mi
        *
        x.mi
        +
        this.lo
        *
        x.hi;
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.isZero
    =
    function(){return (this.lo | this.mi | this.hi) == 0};
    MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0};
    MlInt64.prototype.and
    =
    function(x)
     {return new MlInt64(this.lo & x.lo,this.mi & x.mi,this.hi & x.hi)};
    MlInt64.prototype.or
    =
    function(x)
     {return new MlInt64(this.lo | x.lo,this.mi | x.mi,this.hi | x.hi)};
    MlInt64.prototype.xor
    =
    function(x)
     {return new MlInt64(this.lo ^ x.lo,this.mi ^ x.mi,this.hi ^ x.hi)};
    MlInt64.prototype.shift_left
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo << s,
                this.mi << s | this.lo >> 24 - s,
                this.hi << s | this.mi >> 24 - s);
      if(s < 48)
       return new
               MlInt64
               (0,this.lo << s - 24,this.mi << s - 24 | this.lo >> 48 - s);
      return new MlInt64(0,0,this.lo << s - 48)};
    MlInt64.prototype.shift_right_unsigned
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | this.hi << 24 - s,
                this.hi >> s);
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,this.hi >> s - 24,0);
      return new MlInt64(this.hi >> s - 48,0,0)};
    MlInt64.prototype.shift_right
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      var h=this.hi << 16 >> 16;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | h << 24 - s,
                this.hi << 16 >> s >>> 16);
      var sign=this.hi << 16 >> 31;
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,
                this.hi << 16 >> s - 24 >> 16,
                sign & 0xffff);
      return new MlInt64(this.hi << 16 >> s - 32,sign,sign)};
    MlInt64.prototype.lsl1
    =
    function()
     {this.hi = this.hi << 1 | this.mi >> 23;
      this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
      this.lo = this.lo << 1 & 0xffffff};
    MlInt64.prototype.lsr1
    =
    function()
     {this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
      this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
      this.hi = this.hi >>> 1};
    MlInt64.prototype.udivmod
    =
    function(x)
     {var
       offset=0,
       modulus=this.copy(),
       divisor=x.copy(),
       quotient=new MlInt64(0,0,0);
      while(modulus.ucompare(divisor) > 0){offset++;divisor.lsl1()}
      while(offset >= 0)
       {offset--;
        quotient.lsl1();
        if(modulus.ucompare(divisor) >= 0)
         {quotient.lo++;modulus = modulus.sub(divisor)}
        divisor.lsr1()}
      return {quotient:quotient,modulus:modulus}};
    MlInt64.prototype.div
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi ^ y.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var q=x.udivmod(y).quotient;
      if(sign & 0x8000)q = q.neg();
      return q};
    MlInt64.prototype.mod
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var r=x.udivmod(y).modulus;
      if(sign & 0x8000)r = r.neg();
      return r};
    MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24};
    MlInt64.prototype.toFloat
    =
    function()
     {return (this.hi << 16)
             *
             Math.pow(2,32)
             +
             this.mi
             *
             Math.pow(2,24)
             +
             this.lo};
    MlInt64.prototype.toArray
    =
    function()
     {return [this.hi >> 8,
              this.hi & 0xff,
              this.mi >> 16,
              this.mi >> 8 & 0xff,
              this.mi & 0xff,
              this.lo >> 16,
              this.lo >> 8 & 0xff,
              this.lo & 0xff]};
    MlInt64.prototype.lo32
    =
    function(){return this.lo | (this.mi & 0xff) << 24};
    MlInt64.prototype.hi32
    =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16};
    function caml_int64_create_lo_mi_hi(lo,mi,hi)
     {return new MlInt64(lo,mi,hi)}
    function caml_int64_bits_of_float(x)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_int64_create_lo_mi_hi(1,0,0x7ff0);
        return x > 0
                ?caml_int64_create_lo_mi_hi(0,0,0x7ff0)
                :caml_int64_create_lo_mi_hi(0,0,0xfff0)}
      var sign=x == 0 && 1 / x == - Infinity?0x8000:x >= 0?0:0x8000;
      if(sign)x = - x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,- 1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 0xf | sign | exp << 4;
      return caml_int64_create_lo_mi_hi(r1,r2,r3)}
    function caml_int64_to_bytes(x){return x.toArray()}
    function caml_ba_serialize(writer,ba,sz)
     {writer.write(32,ba.dims.length);
      writer.write(32,ba.kind | ba.layout << 8);
      if(ba.caml_custom == "_bigarr02")
       for(var i=0;i < ba.dims.length;i++)
        if(ba.dims[i] < 0xffff)
         writer.write(16,ba.dims[i]);
        else
         {writer.write(16,0xffff);
          writer.write(32,0);
          writer.write(32,ba.dims[i])}
      else
       for(var i=0;i < ba.dims.length;i++)writer.write(32,ba.dims[i]);
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         for(var i=0;i < ba.data.length;i++)writer.write(8,ba.data[i]);break;
        case 4:
        case 5:
         for(var i=0;i < ba.data.length;i++)writer.write(16,ba.data[i]);break;
        case 6:
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);break;
        case 8:
        case 9:
         writer.write(8,0);
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);
         break;
        case 7:
         for(var i=0;i < ba.data.length / 2;i++)
          {var b=caml_int64_to_bytes(ba.get(i));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 1:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 0:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int32_bits_of_float(ba.get(i));writer.write(32,b)}
         break;
        case 10:
         for(var i=0;i < ba.data.length / 2;i++)
          {var j=ba.get(i);
           writer.write(32,caml_int32_bits_of_float(j[1]));
           writer.write(32,caml_int32_bits_of_float(j[2]))}
         break;
        case 11:
         for(var i=0;i < ba.data.length / 2;i++)
          {var
            complex=ba.get(i),
            b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
           for(var j=0;j < 8;j++)writer.write(8,b[j]);
           var b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break
        }
      sz[0] = (4 + ba.dims.length) * 4;
      sz[1] = (4 + ba.dims.length) * 8}
    function caml_ba_get_size_per_element(kind)
     {switch(kind){case 7:case 10:case 11:return 2;default:return 1}}
    function caml_ba_create_buffer(kind,size)
     {var g=globalThis,view;
      switch(kind)
       {case 0:view = g.Float32Array;break;
        case 1:view = g.Float64Array;break;
        case 2:view = g.Int8Array;break;
        case 3:view = g.Uint8Array;break;
        case 4:view = g.Int16Array;break;
        case 5:view = g.Uint16Array;break;
        case 6:view = g.Int32Array;break;
        case 7:view = g.Int32Array;break;
        case 8:view = g.Int32Array;break;
        case 9:view = g.Int32Array;break;
        case 10:view = g.Float32Array;break;
        case 11:view = g.Float64Array;break;
        case 12:view = g.Uint8Array;break
        }
      if(! view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size * caml_ba_get_size_per_element(kind));
      return data}
    function caml_int32_float_of_bits(x)
     {var int32a=new (globalThis.Int32Array)(1);
      int32a[0] = x;
      var float32a=new (globalThis.Float32Array)(int32a.buffer);
      return float32a[0]}
    function caml_int64_of_bytes(a)
     {return new
              MlInt64
              (a[7] << 0 | a[6] << 8 | a[5] << 16,
               a[4] << 0 | a[3] << 8 | a[2] << 16,
               a[1] << 0 | a[0] << 8)}
    function caml_int64_float_of_bits(x)
     {var lo=x.lo,mi=x.mi,hi=x.hi,exp=(hi & 0x7fff) >> 4;
      if(exp == 2047)
       return (lo | mi | hi & 0xf) == 0?hi & 0x8000?- Infinity:Infinity:NaN;
      var k=Math.pow(2,- 24),res=(lo * k + mi) * k + (hi & 0xf);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,- 1026);
      if(hi & 0x8000)res = - res;
      return res}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    function caml_int64_create_lo_hi(lo,hi)
     {return new
              MlInt64
              (lo & 0xffffff,
               lo >>> 24 & 0xff | (hi & 0xffff) << 8,
               hi >>> 16 & 0xffff)}
    function caml_int64_hi32(v){return v.hi32()}
    function caml_int64_lo32(v){return v.lo32()}
    var caml_ba_custom_name="_bigarr02";
    function Ml_Bigarray(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
    Ml_Bigarray.prototype.offset
    =
    function(arg)
     {var ofs=0;
      if(typeof arg === "number")arg = [arg];
      if(! (arg instanceof Array))
       caml_invalid_argument("bigarray.js: invalid offset");
      if(this.dims.length != arg.length)
       caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
      if(this.layout == 0)
       for(var i=0;i < this.dims.length;i++)
        {if(arg[i] < 0 || arg[i] >= this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + arg[i]}
      else
       for(var i=this.dims.length - 1;i >= 0;i--)
        {if(arg[i] < 1 || arg[i] > this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + (arg[i] - 1)}
      return ofs};
    Ml_Bigarray.prototype.get
    =
    function(ofs)
     {switch(this.kind)
       {case 7:
         var l=this.data[ofs * 2 + 0],h=this.data[ofs * 2 + 1];
         return caml_int64_create_lo_hi(l,h);
        case 10:
        case 11:
         var r=this.data[ofs * 2 + 0],i=this.data[ofs * 2 + 1];
         return [254,r,i];
        default:return this.data[ofs]}};
    Ml_Bigarray.prototype.set
    =
    function(ofs,v)
     {switch(this.kind)
       {case 7:
         this.data[ofs * 2 + 0] = caml_int64_lo32(v);
         this.data[ofs * 2 + 1] = caml_int64_hi32(v);
         break;
        case 10:
        case 11:
         this.data[ofs * 2 + 0] = v[1];this.data[ofs * 2 + 1] = v[2];break;
        default:this.data[ofs] = v;break}
      return 0};
    Ml_Bigarray.prototype.fill
    =
    function(v)
     {switch(this.kind)
       {case 7:
         var a=caml_int64_lo32(v),b=caml_int64_hi32(v);
         if(a == b)
          this.data.fill(a);
         else
          for(var i=0;i < this.data.length;i++)this.data[i] = i % 2 == 0?a:b;
         break;
        case 10:
        case 11:
         var im=v[1],re=v[2];
         if(im == re)
          this.data.fill(im);
         else
          for(var i=0;i < this.data.length;i++)
           this.data[i] = i % 2 == 0?im:re;
         break;
        default:this.data.fill(v);break}};
    Ml_Bigarray.prototype.compare
    =
    function(b,total)
     {if(this.layout != b.layout || this.kind != b.kind)
       {var k1=this.kind | this.layout << 8,k2=b.kind | b.layout << 8;
        return k2 - k1}
      if(this.dims.length != b.dims.length)
       return b.dims.length - this.dims.length;
      for(var i=0;i < this.dims.length;i++)
       if(this.dims[i] != b.dims[i])return this.dims[i] < b.dims[i]?- 1:1;
      switch(this.kind)
       {case 0:
        case 1:
        case 10:
        case 11:
         var x,y;
         for(var i=0;i < this.data.length;i++)
          {x = this.data[i];
           y = b.data[i];
           if(x < y)return - 1;
           if(x > y)return 1;
           if(x != y)
            {if(! total)return NaN;if(x == x)return 1;if(y == y)return - 1}}
         break;
        case 7:
         for(var i=0;i < this.data.length;i += 2)
          {if(this.data[i + 1] < b.data[i + 1])return - 1;
           if(this.data[i + 1] > b.data[i + 1])return 1;
           if(this.data[i] >>> 0 < b.data[i] >>> 0)return - 1;
           if(this.data[i] >>> 0 > b.data[i] >>> 0)return 1}
         break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
         for(var i=0;i < this.data.length;i++)
          {if(this.data[i] < b.data[i])return - 1;
           if(this.data[i] > b.data[i])return 1}
         break
        }
      return 0};
    function Ml_Bigarray_c_1_1(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
    Ml_Bigarray_c_1_1.prototype.offset
    =
    function(arg)
     {if(typeof arg !== "number")
       if(arg instanceof Array && arg.length == 1)
        arg = arg[0];
       else
        caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
      if(arg < 0 || arg >= this.dims[0])caml_array_bound_error();
      return arg};
    Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs]};
    Ml_Bigarray_c_1_1.prototype.set
    =
    function(ofs,v){this.data[ofs] = v;return 0};
    Ml_Bigarray_c_1_1.prototype.fill
    =
    function(v){this.data.fill(v);return 0};
    function caml_ba_create_unsafe(kind,layout,dims,data)
     {var size_per_element=caml_ba_get_size_per_element(kind);
      if(caml_ba_get_size(dims) * size_per_element != data.length)
       caml_invalid_argument("length doesn't match dims");
      if(layout == 0 && dims.length == 1 && size_per_element == 1)
       return new Ml_Bigarray_c_1_1(kind,layout,dims,data);
      return new Ml_Bigarray(kind,layout,dims,data)}
    function caml_failwith(msg)
     {if(! caml_global_data.Failure)
       caml_global_data.Failure = [248,caml_string_of_jsbytes("Failure"),- 3];
      caml_raise_with_string(caml_global_data.Failure,msg)}
    function caml_ba_deserialize(reader,sz,name)
     {var num_dims=reader.read32s();
      if(num_dims < 0 || num_dims > 16)
       caml_failwith("input_value: wrong number of bigarray dimensions");
      var tag=reader.read32s(),kind=tag & 0xff,layout=tag >> 8 & 1,dims=[];
      if(name == "_bigarr02")
       for(var i=0;i < num_dims;i++)
        {var size_dim=reader.read16u();
         if(size_dim == 0xffff)
          {var size_dim_hi=reader.read32u(),size_dim_lo=reader.read32u();
           if(size_dim_hi != 0)
            caml_failwith("input_value: bigarray dimension overflow in 32bit");
           size_dim = size_dim_lo}
         dims.push(size_dim)}
      else
       for(var i=0;i < num_dims;i++)dims.push(reader.read32u());
      var
       size=caml_ba_get_size(dims),
       data=caml_ba_create_buffer(kind,size),
       ba=caml_ba_create_unsafe(kind,layout,dims,data);
      switch(kind)
       {case 2:for(var i=0;i < size;i++)data[i] = reader.read8s();break;
        case 3:
        case 12:for(var i=0;i < size;i++)data[i] = reader.read8u();break;
        case 4:for(var i=0;i < size;i++)data[i] = reader.read16s();break;
        case 5:for(var i=0;i < size;i++)data[i] = reader.read16u();break;
        case 6:for(var i=0;i < size;i++)data[i] = reader.read32s();break;
        case 8:
        case 9:
         var sixty=reader.read8u();
         if(sixty)
          caml_failwith
           ("input_value: cannot read bigarray with 64-bit OCaml ints");
         for(var i=0;i < size;i++)data[i] = reader.read32s();
         break;
        case 7:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var int64=caml_int64_of_bytes(t);
           ba.set(i,int64)}
         break;
        case 1:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var f=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,f)}
         break;
        case 0:
         for(var i=0;i < size;i++)
          {var f=caml_int32_float_of_bits(reader.read32s());ba.set(i,f)}
         break;
        case 10:
         for(var i=0;i < size;i++)
          {var
            re=caml_int32_float_of_bits(reader.read32s()),
            im=caml_int32_float_of_bits(reader.read32s());
           ba.set(i,[254,re,im])}
         break;
        case 11:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var re=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var im=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,[254,re,im])}
         break
        }
      sz[0] = (4 + num_dims) * 4;
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_ba_compare(a,b,total){return a.compare(b,total)}
    function caml_mul(a,b){return Math.imul(a,b)}
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,0xcc9e2d51 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,0x1b873593);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0}
    function caml_hash_mix_int64(h,v)
     {h = caml_hash_mix_int(h,caml_int64_lo32(v));
      h = caml_hash_mix_int(h,caml_int64_hi32(v));
      return h}
    function caml_hash_mix_float(h,v0)
     {return caml_hash_mix_int64(h,caml_int64_bits_of_float(v0))}
    function caml_ba_hash(ba)
     {var num_elts=caml_ba_get_size(ba.dims),h=0;
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         if(num_elts > 256)num_elts = 256;
         var w=0,i=0;
         for(i = 0;i + 4 <= ba.data.length;i += 4)
          {w
           =
           ba.data[i + 0]
           |
           ba.data[i + 1]
           <<
           8
           |
           ba.data[i + 2]
           <<
           16
           |
           ba.data[i + 3]
           <<
           24;
           h = caml_hash_mix_int(h,w)}
         w = 0;
         switch(num_elts & 3)
          {case 3:w = ba.data[i + 2] << 16;
           case 2:w |= ba.data[i + 1] << 8;
           case 1:w |= ba.data[i + 0];h = caml_hash_mix_int(h,w)
           }
         break;
        case 4:
        case 5:
         if(num_elts > 128)num_elts = 128;
         var w=0,i=0;
         for(i = 0;i + 2 <= ba.data.length;i += 2)
          {w = ba.data[i + 0] | ba.data[i + 1] << 16;
           h = caml_hash_mix_int(h,w)}
         if((num_elts & 1) != 0)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 6:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 8:
        case 9:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 7:
         if(num_elts > 32)num_elts = 32;
         num_elts *= 2;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 10:num_elts *= 2;
        case 0:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break;
        case 11:num_elts *= 2;
        case 1:
         if(num_elts > 32)num_elts = 32;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break
        }
      return h}
    function caml_int32_unmarshal(reader,size)
     {size[0] = 4;return reader.read32s()}
    function caml_nativeint_unmarshal(reader,size)
     {switch(reader.read8u())
       {case 1:size[0] = 4;return reader.read32s();
        case 2:caml_failwith("input_value: native integer value too large");
        default:caml_failwith("input_value: ill-formed native integer")}}
    function caml_int64_unmarshal(reader,size)
     {var t=new Array(8);
      for(var j=0;j < 8;j++)t[j] = reader.read8u();
      size[0] = 8;
      return caml_int64_of_bytes(t)}
    function caml_int64_marshal(writer,v,sizes)
     {var b=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)writer.write(8,b[i]);
      sizes[0] = 8;
      sizes[1] = 8}
    function caml_int64_compare(x,y,total){return x.compare(y)}
    function caml_int64_hash(v){return v.lo32() ^ v.hi32()}
    var
     caml_custom_ops=
      {"_j":
       {deserialize:caml_int64_unmarshal,
        serialize:caml_int64_marshal,
        fixed_length:8,
        compare:caml_int64_compare,
        hash:caml_int64_hash},
       "_i":{deserialize:caml_int32_unmarshal,fixed_length:4},
       "_n":{deserialize:caml_nativeint_unmarshal,fixed_length:4},
       "_bigarray":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarray")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash},
       "_bigarr02":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarr02")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash}};
    function caml_compare_val_get_custom(a)
     {return caml_custom_ops[a.caml_custom]
             &&
             caml_custom_ops[a.caml_custom].compare}
    function caml_compare_val_number_custom(num,custom,swap,total)
     {var comp=caml_compare_val_get_custom(custom);
      if(comp)
       {var x=swap > 0?comp(custom,num,total):comp(num,custom,total);
        if(total && x != x)return swap;
        if(+ x != + x)return + x;
        if((x | 0) != 0)return x | 0}
      return swap}
    function caml_is_ml_bytes(s){return s instanceof MlBytes}
    function caml_is_ml_string(s){return caml_is_ml_bytes(s)}
    function caml_compare_val_tag(a)
     {if(typeof a === "number")
       return 1000;
      else
       if(caml_is_ml_bytes(a))
        return 252;
       else
        if(caml_is_ml_string(a))
         return 1252;
        else
         if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255)
          {var tag=a[0] | 0;return tag == 254?0:tag}
         else
          if(a instanceof String)
           return 12520;
          else
           if(typeof a == "string")
            return 12520;
           else
            if(a instanceof Number)
             return 1000;
            else
             if(a && a.caml_custom)
              return 1255;
             else
              if(a && a.compare)
               return 1256;
              else
               if(typeof a == "function")
                return 1247;
               else
                if(typeof a == "symbol")return 1251;
      return 1001}
    function caml_int_compare(a,b)
     {if(a < b)return - 1;if(a == b)return 0;return 1}
    function caml_bytes_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_string_compare(s1,s2){return caml_bytes_compare(s1,s2)}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(! (total && a === b))
         {var tag_a=caml_compare_val_tag(a);
          if(tag_a == 250){a = a[1];continue}
          var tag_b=caml_compare_val_tag(b);
          if(tag_b == 250){b = b[1];continue}
          if(tag_a !== tag_b)
           {if(tag_a == 1000)
             {if(tag_b == 1255)
               return caml_compare_val_number_custom(a,b,- 1,total);
              return - 1}
            if(tag_b == 1000)
             {if(tag_a == 1255)
               return caml_compare_val_number_custom(b,a,1,total);
              return 1}
            return tag_a < tag_b?- 1:1}
          switch(tag_a)
           {case 247:caml_invalid_argument("compare: functional value");break;
            case 248:
             var x=caml_int_compare(a[2],b[2]);if(x != 0)return x | 0;break;
            case 249:caml_invalid_argument("compare: functional value");break;
            case 250:
             caml_invalid_argument
              ("equal: got Forward_tag, should not happen");
             break;
            case 251:caml_invalid_argument("equal: abstract value");break;
            case 252:
             if(a !== b){var x=caml_bytes_compare(a,b);if(x != 0)return x | 0}
             break;
            case 253:
             caml_invalid_argument("equal: got Double_tag, should not happen");
             break;
            case 254:
             caml_invalid_argument
              ("equal: got Double_array_tag, should not happen");
             break;
            case 255:
             caml_invalid_argument("equal: got Custom_tag, should not happen");
             break;
            case 1247:
             caml_invalid_argument("compare: functional value");break;
            case 1255:
             var comp=caml_compare_val_get_custom(a);
             if(comp != caml_compare_val_get_custom(b))
              return a.caml_custom < b.caml_custom?- 1:1;
             if(! comp)caml_invalid_argument("compare: abstract value");
             var x=comp(a,b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1256:
             var x=a.compare(b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1000:
             a = + a;
             b = + b;
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1001:
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1251:if(a !== b){if(! total)return NaN;return 1}break;
            case 1252:
             var a=caml_jsbytes_of_string(a),b=caml_jsbytes_of_string(b);
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 12520:
             var a=a.toString(),b=b.toString();
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 246:
            case 254:
            default:
             if(a.length != b.length)return a.length < b.length?- 1:1;
             if(a.length > 1)stack.push(a,b,1);
             break}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    function caml_convert_raw_backtrace(){return [0]}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_div(x,y)
     {if(y == 0)caml_raise_zero_divide();return x / y | 0}
    var caml_ephe_key_offset=3;
    function caml_weak_set(x,i,v)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.set");
      x[caml_ephe_key_offset + i] = v;
      return 0}
    function caml_ephe_set_key(x,i,v){return caml_weak_set(x,i,[0,v])}
    function caml_ephe_unset_key(x,i){return caml_weak_set(x,i,0)}
    function caml_equal(x,y){return + (caml_compare_val(x,y,false) == 0)}
    function caml_fill_bytes(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_bytes_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    function caml_final_register(){return 0}
    function caml_float_of_string(s)
     {var res;
      s = caml_jsbytes_of_string(s);
      res = + s;
      if(s.length > 0 && res === res)return res;
      s = s.replace(/_/g,"");
      res = + s;
      if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s))return res;
      var m=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)(p([+-]?[0-9]+))?/i.exec(s);
      if(m)
       {var
         m3=m[3].replace(/0+$/,""),
         mantissa=parseInt(m[1] + m[2] + m3,16),
         exponent=(m[5] | 0) - 4 * m3.length;
        res = mantissa * Math.pow(2,exponent);
        return res}
      if(/^\+?inf(inity)?$/i.test(s))return Infinity;
      if(/^-inf(inity)?$/i.test(s))return - Infinity;
      caml_failwith("float_of_string")}
    function caml_parse_format(fmt)
     {fmt = caml_jsbytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += "0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_string_of_jsbytes(buffer)}
    function caml_format_float(fmt,x)
     {function toFixed(x,dp)
       {if(Math.abs(x) < 1.0)
         return x.toFixed(dp);
        else
         {var e=parseInt(x.toString().split("+")[1]);
          if(e > 20)
           {e -= 20;
            x /= Math.pow(10,e);
            x += new Array(e + 1).join("0");
            if(dp > 0)x = x + "." + new Array(dp + 1).join("0");
            return x}
          else
           return x.toFixed(dp)}}
      var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1;x = - x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(! isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = toFixed(x,prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+ s.slice(j + 1);
           if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_format_int(fmt,i)
     {if(caml_jsbytes_of_string(fmt) == "%d")
       return caml_string_of_jsbytes("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = - 1;i = - i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    var caml_oo_last_id=0;
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_jsstring_of_string(s){return s.toUtf16()}
    function fs_node_supported()
     {return typeof globalThis.process
             !==
             "undefined"
             &&
             typeof globalThis.process.versions
             !==
             "undefined"
             &&
             typeof globalThis.process.versions.node
             !==
             "undefined"}
    function make_path_is_absolute()
     {function posix(path)
       {if(path.charAt(0) === "/")return ["",path.substring(1)];return}
      function win32(path)
       {var
         splitDeviceRe=
          /^([a-zA-Z]:|[\\/]{2}[^\\/]+[\\/]+[^\\/]+)?([\\/])?([\s\S]*?)$/,
         result=splitDeviceRe.exec(path),
         device=result[1] || "",
         isUnc=Boolean(device && device.charAt(1) !== ":");
        if(Boolean(result[2] || isUnc))
         {var root=result[1] || "",sep=result[2] || "";
          return [root,path.substring(root.length + sep.length)]}
        return}
      return fs_node_supported()
              &&
              globalThis.process
              &&
              globalThis.process.platform
              ?globalThis.process.platform === "win32"?win32:posix
              :posix}
    var path_is_absolute=make_path_is_absolute();
    function caml_trailing_slash(name)
     {return name.slice(- 1) !== "/"?name + "/":name}
    if(fs_node_supported() && globalThis.process && globalThis.process.cwd)
     var caml_current_dir=globalThis.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    caml_current_dir = caml_trailing_slash(caml_current_dir);
    function caml_make_path(name)
     {name = caml_jsstring_of_string(name);
      if(! path_is_absolute(name))name = caml_current_dir + name;
      var comp0=path_is_absolute(name),comp=comp0[1].split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         default:ncomp.push(comp[i]);break}
      ncomp.unshift(comp0[0]);
      ncomp.orig = name;
      return ncomp}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 0x80)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 0x800)
         {t += String.fromCharCode(0xc0 | c >> 6);
          t += String.fromCharCode(0x80 | c & 0x3f)}
        else
         if(c < 0xd800 || c >= 0xdfff)
          t
          +=
          String.fromCharCode
           (0xe0 | c >> 12,0x80 | c >> 6 & 0x3f,0x80 | c & 0x3f);
         else
          if
           (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 0x35fdc00;
            t
            +=
            String.fromCharCode
             (0xf0 | c >> 18,
              0x80 | c >> 12 & 0x3f,
              0x80 | c >> 6 & 0x3f,
              0x80 | c & 0x3f)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_bytes_of_utf16_jsstring(s)
     {var tag=9;
      if(! jsoo_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlBytes(tag,s,s.length)}
    function caml_string_of_jsstring(s)
     {return caml_bytes_of_utf16_jsstring(s)}
    var
     unix_error=
      ["E2BIG",
       "EACCES",
       "EAGAIN",
       "EBADF",
       "EBUSY",
       "ECHILD",
       "EDEADLK",
       "EDOM",
       "EEXIST",
       "EFAULT",
       "EFBIG",
       "EINTR",
       "EINVAL",
       "EIO",
       "EISDIR",
       "EMFILE",
       "EMLINK",
       "ENAMETOOLONG",
       "ENFILE",
       "ENODEV",
       "ENOENT",
       "ENOEXEC",
       "ENOLCK",
       "ENOMEM",
       "ENOSPC",
       "ENOSYS",
       "ENOTDIR",
       "ENOTEMPTY",
       "ENOTTY",
       "ENXIO",
       "EPERM",
       "EPIPE",
       "ERANGE",
       "EROFS",
       "ESPIPE",
       "ESRCH",
       "EXDEV",
       "EWOULDBLOCK",
       "EINPROGRESS",
       "EALREADY",
       "ENOTSOCK",
       "EDESTADDRREQ",
       "EMSGSIZE",
       "EPROTOTYPE",
       "ENOPROTOOPT",
       "EPROTONOSUPPORT",
       "ESOCKTNOSUPPORT",
       "EOPNOTSUPP",
       "EPFNOSUPPORT",
       "EAFNOSUPPORT",
       "EADDRINUSE",
       "EADDRNOTAVAIL",
       "ENETDOWN",
       "ENETUNREACH",
       "ENETRESET",
       "ECONNABORTED",
       "ECONNRESET",
       "ENOBUFS",
       "EISCONN",
       "ENOTCONN",
       "ESHUTDOWN",
       "ETOOMANYREFS",
       "ETIMEDOUT",
       "ECONNREFUSED",
       "EHOSTDOWN",
       "EHOSTUNREACH",
       "ELOOP",
       "EOVERFLOW"];
    function make_unix_err_args(code,syscall,path,errno)
     {var variant=unix_error.indexOf(code);
      if(variant < 0){if(errno == null)errno = - 9999;variant = [0,errno]}
      var
       args=
        [variant,
         caml_string_of_jsstring(syscall || ""),
         caml_string_of_jsstring(path || "")];
      return args}
    var caml_named_values={};
    function caml_named_value(nm){return caml_named_values[nm]}
    function caml_raise_with_args(tag,args){throw [0,tag].concat(args)}
    function caml_bytes_of_array(a){return new MlBytes(4,a,a.length)}
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_raise_no_such_file(name)
     {caml_raise_sys_error(name + ": No such file or directory")}
    function caml_ml_bytes_length(s){return s.l}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_bytes_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_bytes(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_bytes(old_data,0,this.data,0,clen)}
      caml_blit_string(buf,pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      caml_blit_bytes(this.data,offset,buf,pos,len);
      return 0};
    MlFakeFile.prototype.read_one
    =
    function(offset){return caml_bytes_get(this.data,offset)};
    MlFakeFile.prototype.close = function(){};
    MlFakeFile.prototype.constructor = MlFakeFile;
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.create_dir_if_needed
    =
    function(name)
     {var comp=name.split("/"),res="";
      for(var i=0;i < comp.length - 1;i++)
       {res += comp[i] + "/";
        if(this.content[res])continue;
        this.content[res] = Symbol("directory")}};
    MlFakeDevice.prototype.slash
    =
    function(name){return /\/$/.test(name)?name:name + "/"};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(! this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun
           (caml_string_of_jsbytes(this.root),caml_string_of_jsbytes(name));
        if(res !== 0)
         {this.create_dir_if_needed(name);
          this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]))}}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=this.slash(name);
      if(this.content[name_slash])return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.mkdir
    =
    function(name,mode,raise_unix)
     {var unix_error=raise_unix && caml_named_value("Unix.Unix_error");
      if(this.exists(name))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("EEXIST","mkdir",this.nm(name)));
       else
        caml_raise_sys_error(name + ": File exists");
      var parent=/^(.*)\/[^/]+/.exec(name);
      parent = parent && parent[1] || "";
      if(! this.exists(parent))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOENT","mkdir",this.nm(parent)));
       else
        caml_raise_sys_error(parent + ": No such file or directory");
      if(! this.is_dir(parent))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOTDIR","mkdir",this.nm(parent)));
       else
        caml_raise_sys_error(parent + ": Not a directory");
      this.create_dir_if_needed(this.slash(name))};
    MlFakeDevice.prototype.rmdir
    =
    function(name,raise_unix)
     {var
       unix_error=raise_unix && caml_named_value("Unix.Unix_error"),
       name_slash=name == ""?"":this.slash(name),
       r=new RegExp("^" + name_slash + "([^/]+)");
      if(! this.exists(name))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOENT","rmdir",this.nm(name)));
       else
        caml_raise_sys_error(name + ": No such file or directory");
      if(! this.is_dir(name))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOTDIR","rmdir",this.nm(name)));
       else
        caml_raise_sys_error(name + ": Not a directory");
      for(var n in this.content)
       if(n.match(r))
        if(unix_error)
         caml_raise_with_args
          (unix_error,make_unix_err_args("ENOTEMPTY","rmdir",this.nm(name)));
        else
         caml_raise_sys_error(this.nm(name) + ": Directory not empty");
      delete this.content[name_slash]};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var name_slash=name == ""?"":this.slash(name);
      if(! this.exists(name))
       caml_raise_sys_error(name + ": No such file or directory");
      if(! this.is_dir(name))caml_raise_sys_error(name + ": Not a directory");
      var r=new RegExp("^" + name_slash + "([^/]+)"),seen={},a=[];
      for(var n in this.content)
       {var m=n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {if(name == "")return true;
      var name_slash=this.slash(name);
      return this.content[name_slash]?1:0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        var file=this.content[name];
        if(f.truncate)file.truncate();
        return file}
      else
       if(f.create)
        {this.create_dir_if_needed(name);
         this.content[name] = new MlFakeFile(caml_create_bytes(0));
         return this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name))};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {var file;
      if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(caml_is_ml_bytes(content))file = new MlFakeFile(content);
      if(caml_is_ml_string(content))
       file = new MlFakeFile(caml_bytes_of_string(content));
      else
       if(content instanceof Array)
        file = new MlFakeFile(caml_bytes_of_array(content));
       else
        if(typeof content === "string")
         file = new MlFakeFile(caml_bytes_of_jsbytes(content));
        else
         if(content.toString)
          {var
            bytes=
             caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
           file = new MlFakeFile(bytes)}
      if(file)
       {this.create_dir_if_needed(name);this.content[name] = file}
      else
       caml_raise_sys_error
        (this.nm(name) + " : registering file with invalid content type")};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_ml_string_length(s){return caml_ml_bytes_length(s)}
    function caml_string_unsafe_get(s,i){return caml_bytes_unsafe_get(s,i)}
    function caml_array_of_string(s)
     {var l=caml_ml_string_length(s),a=new Array(l),i=0;
      for(;i < l;i++)a[i] = caml_string_unsafe_get(s,i);
      return a}
    function caml_array_of_bytes(s)
     {if(s.t != 4)caml_convert_bytes_to_array(s);return s.c}
    function MlNodeFile(fd){this.fs = require("fs");this.fd = fd}
    MlNodeFile.prototype = new MlFile();
    MlNodeFile.prototype.truncate
    =
    function(len)
     {try
       {this.fs.ftruncateSync(this.fd,len | 0)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.length
    =
    function()
     {try
       {return this.fs.fstatSync(this.fd).size}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof globalThis.Uint8Array))
       a = new (globalThis.Uint8Array)(a);
      var buffer=globalThis.Buffer.from(a);
      try
       {this.fs.writeSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return 0};
    MlNodeFile.prototype.read
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_bytes(buf);
      if(! (a instanceof globalThis.Uint8Array))
       a = new (globalThis.Uint8Array)(a);
      var buffer=globalThis.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      for(var i=0;i < len;i++)
       caml_bytes_set(buf,buf_offset + i,buffer[buf_offset + i]);
      return 0};
    MlNodeFile.prototype.read_one
    =
    function(offset)
     {var a=new (globalThis.Uint8Array)(1),buffer=globalThis.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,0,1,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return buffer[0]};
    MlNodeFile.prototype.close
    =
    function()
     {try
       {this.fs.closeSync(this.fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.constructor = MlNodeFile;
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name)
     {try {return this.fs.existsSync(this.nm(name))?1:0}catch(err){return 0}};
    MlNodeDevice.prototype.mkdir
    =
    function(name,mode,raise_unix)
     {try
       {this.fs.mkdirSync(this.nm(name),{mode:mode});return 0}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.rmdir
    =
    function(name,raise_unix)
     {try
       {this.fs.rmdirSync(this.nm(name));return 0}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.readdir
    =
    function(name,raise_unix)
     {try
       {return this.fs.readdirSync(this.nm(name))}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.is_dir
    =
    function(name)
     {try
       {return this.fs.statSync(this.nm(name)).isDirectory()?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.unlink
    =
    function(name,raise_unix)
     {try
       {var b=this.fs.existsSync(this.nm(name))?1:0;
        this.fs.unlinkSync(this.nm(name));
        return b}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.open
    =
    function(name,f,raise_unix)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      try
       {var fd=this.fs.openSync(this.nm(name),res);return new MlNodeFile(fd)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.rename
    =
    function(o,n,raise_unix)
     {try
       {this.fs.renameSync(this.nm(o),this.nm(n))}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.stat
    =
    function(name,raise_unix)
     {try
       {var js_stats=this.fs.statSync(this.nm(name));
        return this.stats_from_js(js_stats)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.lstat
    =
    function(name,raise_unix)
     {try
       {var js_stats=this.fs.lstatSync(this.nm(name));
        return this.stats_from_js(js_stats)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.symlink
    =
    function(to_dir,target,path,raise_unix)
     {try
       {this.fs.symlinkSync(this.nm(target),this.nm(path),to_dir?"dir":"file");
        return 0}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.readlink
    =
    function(name,raise_unix)
     {try
       {var link=this.fs.readlinkSync(this.nm(name),"utf8");
        return caml_string_of_jsstring(link)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.raise_nodejs_error
    =
    function(err,raise_unix)
     {var unix_error=caml_named_value("Unix.Unix_error");
      if(raise_unix && unix_error)
       {var args=make_unix_err_args(err.code,err.syscall,err.path,err.errno);
        caml_raise_with_args(unix_error,args)}
      else
       caml_raise_sys_error(err.toString())};
    MlNodeDevice.prototype.stats_from_js
    =
    function(js_stats)
     {var file_kind;
      if(js_stats.isFile())
       file_kind = 0;
      else
       if(js_stats.isDirectory())
        file_kind = 1;
       else
        if(js_stats.isCharacterDevice())
         file_kind = 2;
        else
         if(js_stats.isBlockDevice())
          file_kind = 3;
         else
          if(js_stats.isSymbolicLink())
           file_kind = 4;
          else
           if(js_stats.isFIFO())
            file_kind = 5;
           else
            if(js_stats.isSocket())file_kind = 6;
      return [0,
              js_stats.dev,
              js_stats.ino,
              file_kind,
              js_stats.mode,
              js_stats.nlink,
              js_stats.uid,
              js_stats.gid,
              js_stats.rdev,
              js_stats.size,
              js_stats.atimeMs,
              js_stats.mtimeMs,
              js_stats.ctimeMs]};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    function caml_get_root(path)
     {var x=path_is_absolute(path);if(! x)return;return x[0] + "/"}
    var
     caml_root=
      caml_get_root(caml_current_dir)
      ||
      caml_failwith("unable to compute caml_root"),
     jsoo_mount_point=[];
    if(fs_node_supported())
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:"/static/",device:new MlFakeDevice("/static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=caml_trailing_slash(name),
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      if(! res && fs_node_supported())
       {var root=caml_get_root(name);
        if(root && root.match(/^[a-zA-Z]:\/$/))
         {var m={path:root,device:new MlNodeDevice(root)};
          jsoo_mount_point.push(m);
          res
          =
          {path:m.path,
           device:m.device,
           rest:name.substring(m.path.length,name.length)}}}
      if(res)return res;
      caml_raise_sys_error("no device found for " + name_slash)}
    function caml_create_file(name,content)
     {var root=resolve_fs_device(name);
      if(! root.device.register)caml_failwith("cannot register file");
      root.device.register(root.rest,content);
      return 0}
    function jsoo_create_file(name,content)
     {var
       name=caml_string_of_jsbytes(name),
       content=caml_string_of_jsbytes(content);
      return caml_create_file(name,content)}
    function caml_fs_init()
     {var tmp=globalThis.caml_fs_tmp;
      if(tmp)
       for(var i=0;i < tmp.length;i++)
        jsoo_create_file(tmp[i].name,tmp[i].content);
      globalThis.jsoo_create_file = jsoo_create_file;
      globalThis.caml_fs_tmp = [];
      return 0}
    function caml_get_exception_raw_backtrace(){return [0]}
    var caml_method_cache=[];
    function caml_get_public_method(obj,tag,cacheid)
     {var meths=obj[1],ofs=caml_method_cache[cacheid];
      if(ofs === undefined)
       for(var i=caml_method_cache.length;i < cacheid;i++)
        caml_method_cache[i] = 0;
      else
       if(meths[ofs] === tag)return meths[ofs - 1];
      var li=3,hi=meths[1] * 2 + 1,mi;
      while(li < hi)
       {mi = li + hi >> 1 | 1;if(tag < meths[mi + 1])hi = mi - 2;else li = mi}
      caml_method_cache[cacheid] = li + 1;
      return tag == meths[li + 1]?meths[li]:0}
    function caml_greaterequal(x,y)
     {return + (caml_compare_val(x,y,false) >= 0)}
    function caml_hash_mix_jsbytes(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w
        =
        s.charCodeAt(i)
        |
        s.charCodeAt(i + 1)
        <<
        8
        |
        s.charCodeAt(i + 2)
        <<
        16
        |
        s.charCodeAt(i + 3)
        <<
        24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s.charCodeAt(i + 2) << 16;
        case 2:w |= s.charCodeAt(i + 1) << 8;
        case 1:w |= s.charCodeAt(i);h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_string(h,v)
     {return caml_hash_mix_jsbytes(h,caml_jsbytes_of_string(v))}
    function caml_hash_mix_bytes_arr(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_ml_bytes_content(s)
     {switch(s.t & 6)
       {default:caml_convert_string_to_bytes(s);case 0:return s.c;
        case 4:return s.c
        }}
    function caml_hash_mix_bytes(h,v)
     {var content=caml_ml_bytes_content(v);
      return typeof content === "string"
              ?caml_hash_mix_jsbytes(h,content)
              :caml_hash_mix_bytes_arr(h,content)}
    function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h = caml_mul(h,0x85ebca6b | 0);
      h ^= h >>> 13;
      h = caml_mul(h,0xc2b2ae35 | 0);
      h ^= h >>> 16;
      return h}
    function caml_hash(count,limit,seed,obj)
     {var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
      if(sz < 0 || sz > 256)sz = 256;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
      while(rd < wr && num > 0)
       {v = queue[rd++];
        if(v && v.caml_custom)
         {if
           (caml_custom_ops[v.caml_custom]
            &&
            caml_custom_ops[v.caml_custom].hash)
           {var hh=caml_custom_ops[v.caml_custom].hash(v);
            h = caml_hash_mix_int(h,hh);
            num--}}
        else
         if(v instanceof Array && v[0] === (v[0] | 0))
          switch(v[0])
           {case 248:h = caml_hash_mix_int(h,v[2]);num--;break;
            case 250:queue[--rd] = v[1];break;
            default:
             var tag=v.length - 1 << 10 | v[0];
             h = caml_hash_mix_int(h,tag);
             for(i = 1,len = v.length;i < len;i++)
              {if(wr >= sz)break;queue[wr++] = v[i]}
             break}
         else
          if(caml_is_ml_bytes(v))
           {h = caml_hash_mix_bytes(h,v);num--}
          else
           if(caml_is_ml_string(v))
            {h = caml_hash_mix_string(h,v);num--}
           else
            if(typeof v === "string")
             {h = caml_hash_mix_jsbytes(h,v);num--}
            else
             if(v === (v | 0))
              {h = caml_hash_mix_int(h,v + v + 1);num--}
             else
              if(v === + v){h = caml_hash_mix_float(h,v);num--}}
      h = caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function caml_hexstring_of_float(x,prec,style)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_string_of_jsstring("nan");
        return caml_string_of_jsstring(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
      if(sign)x = - x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > - 1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_string_of_jsstring
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    function caml_int64_add(x,y){return x.add(y)}
    function caml_int64_and(x,y){return x.and(y)}
    function caml_int64_div(x,y){return x.div(y)}
    function caml_int64_is_zero(x){return + x.isZero()}
    function caml_int64_of_int32(x)
     {return new MlInt64(x & 0xffffff,x >> 24 & 0xffffff,x >> 31 & 0xffff)}
    function caml_int64_to_int32(x){return x.toInt()}
    function caml_int64_is_negative(x){return + x.isNeg()}
    function caml_int64_neg(x){return x.neg()}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = - 1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=x.udivmod(wbase);
        x = p.quotient;
        buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer}
      while
       (! caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    function caml_int64_mod(x,y){return x.mod(y)}
    function caml_int64_mul(x,y){return x.mul(y)}
    function caml_int64_of_float(x)
     {if(x < 0)x = Math.ceil(x);
      return new
              MlInt64
              (x & 0xffffff,
               Math.floor(x * caml_int64_offset) & 0xffffff,
               Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff)}
    function caml_int64_ult(x,y){return x.ucompare(y) < 0}
    function caml_parse_sign_and_base(s)
     {var i=0,len=caml_ml_string_length(s),base=10,sign=1;
      if(len > 0)
       switch(caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1;break;case 43:i++;sign = 1;break}
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break;
         case 117:
         case 85:i += 2;break
         }
      return [i,sign,base]}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return - 1}
    function caml_int64_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       base64=caml_int64_of_int32(base),
       threshold=
        new MlInt64(0xffffff,0xfffffff,0xffff).udivmod(base64).quotient,
       c=caml_string_unsafe_get(s,i),
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=caml_int64_of_int32(d);
      for(;;)
       {i++;
        c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        if(caml_int64_ult(threshold,res))caml_failwith("int_of_string");
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(base64,res),d);
        if(caml_int64_ult(res,d))caml_failwith("int_of_string")}
      if(i != caml_ml_string_length(s))caml_failwith("int_of_string");
      if(base == 10 && caml_int64_ult(new MlInt64(0,0,0x8000),res))
       caml_failwith("int_of_string");
      if(sign < 0)res = caml_int64_neg(res);
      return res}
    function caml_int64_shift_right(x,s){return x.shift_right(s)}
    function caml_int64_sub(x,y){return x.sub(y)}
    function caml_int64_to_float(x){return x.toFloat()}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=- 1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    function caml_js_from_array(a){return a.slice(1)}
    function caml_js_get_console()
     {var
       c=globalThis.console?globalThis.console:{},
       m=
        ["log",
         "debug",
         "info",
         "warn",
         "error",
         "assert",
         "dir",
         "dirxml",
         "trace",
         "group",
         "groupCollapsed",
         "groupEnd",
         "time",
         "timeEnd"];
      function f(){}
      for(var i=0;i < m.length;i++)if(! c[m[i]])c[m[i]] = f;
      return c}
    function caml_js_object(a)
     {var o={};
      for(var i=1;i < a.length;i++)
       {var p=a[i];o[caml_jsstring_of_string(p[1])] = p[2]}
      return o}
    function caml_js_to_array(a)
     {var len=a.length,b=new Array(len + 1);
      b[0] = 0;
      for(var i=0;i < len;i++)b[i + 1] = a[i];
      return b}
    function caml_js_wrap_meth_callback(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_lessequal(x,y){return + (caml_compare_val(x,y,false) <= 0)}
    function caml_lessthan(x,y){return + (caml_compare_val(x,y,false) < 0)}
    function caml_lex_array(s)
     {s = caml_jsbytes_of_string(s);
      var l=s.length / 2,a=new Array(l);
      for(var i=0;i < l;i++)
       a[i]
       =
       (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8)
       <<
       16
       >>
       16;
      return a}
    function caml_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)return - base - 1;
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         if(c == 256)lexbuf[lex_eof_reached] = 0}}
    function caml_make_vect(len,init)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    function caml_string_of_array(a)
     {return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a,0,a.length))}
    var
     caml_md5_bytes=
      function()
        {function add(x,y){return x + y | 0}
         function xx(q,a,b,x,s,t)
          {a = add(add(a,q),add(x,t));return add(a << s | a >>> 32 - s,b)}
         function ff(a,b,c,d,x,s,t){return xx(b & c | ~ b & d,a,b,x,s,t)}
         function gg(a,b,c,d,x,s,t){return xx(b & d | c & ~ d,a,b,x,s,t)}
         function hh(a,b,c,d,x,s,t){return xx(b ^ c ^ d,a,b,x,s,t)}
         function ii(a,b,c,d,x,s,t){return xx(c ^ (b | ~ d),a,b,x,s,t)}
         function md5(buffer,length)
          {var i=length;
           buffer[i >> 2] |= 0x80 << 8 * (i & 3);
           for(i = (i & ~ 0x3) + 8;(i & 0x3F) < 60;i += 4)
            buffer[(i >> 2) - 1] = 0;
           buffer[(i >> 2) - 1] = length << 3;
           buffer[i >> 2] = length >> 29 & 0x1FFFFFFF;
           var w=[0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476];
           for(i = 0;i < buffer.length;i += 16)
            {var a=w[0],b=w[1],c=w[2],d=w[3];
             a = ff(a,b,c,d,buffer[i + 0],7,0xD76AA478);
             d = ff(d,a,b,c,buffer[i + 1],12,0xE8C7B756);
             c = ff(c,d,a,b,buffer[i + 2],17,0x242070DB);
             b = ff(b,c,d,a,buffer[i + 3],22,0xC1BDCEEE);
             a = ff(a,b,c,d,buffer[i + 4],7,0xF57C0FAF);
             d = ff(d,a,b,c,buffer[i + 5],12,0x4787C62A);
             c = ff(c,d,a,b,buffer[i + 6],17,0xA8304613);
             b = ff(b,c,d,a,buffer[i + 7],22,0xFD469501);
             a = ff(a,b,c,d,buffer[i + 8],7,0x698098D8);
             d = ff(d,a,b,c,buffer[i + 9],12,0x8B44F7AF);
             c = ff(c,d,a,b,buffer[i + 10],17,0xFFFF5BB1);
             b = ff(b,c,d,a,buffer[i + 11],22,0x895CD7BE);
             a = ff(a,b,c,d,buffer[i + 12],7,0x6B901122);
             d = ff(d,a,b,c,buffer[i + 13],12,0xFD987193);
             c = ff(c,d,a,b,buffer[i + 14],17,0xA679438E);
             b = ff(b,c,d,a,buffer[i + 15],22,0x49B40821);
             a = gg(a,b,c,d,buffer[i + 1],5,0xF61E2562);
             d = gg(d,a,b,c,buffer[i + 6],9,0xC040B340);
             c = gg(c,d,a,b,buffer[i + 11],14,0x265E5A51);
             b = gg(b,c,d,a,buffer[i + 0],20,0xE9B6C7AA);
             a = gg(a,b,c,d,buffer[i + 5],5,0xD62F105D);
             d = gg(d,a,b,c,buffer[i + 10],9,0x02441453);
             c = gg(c,d,a,b,buffer[i + 15],14,0xD8A1E681);
             b = gg(b,c,d,a,buffer[i + 4],20,0xE7D3FBC8);
             a = gg(a,b,c,d,buffer[i + 9],5,0x21E1CDE6);
             d = gg(d,a,b,c,buffer[i + 14],9,0xC33707D6);
             c = gg(c,d,a,b,buffer[i + 3],14,0xF4D50D87);
             b = gg(b,c,d,a,buffer[i + 8],20,0x455A14ED);
             a = gg(a,b,c,d,buffer[i + 13],5,0xA9E3E905);
             d = gg(d,a,b,c,buffer[i + 2],9,0xFCEFA3F8);
             c = gg(c,d,a,b,buffer[i + 7],14,0x676F02D9);
             b = gg(b,c,d,a,buffer[i + 12],20,0x8D2A4C8A);
             a = hh(a,b,c,d,buffer[i + 5],4,0xFFFA3942);
             d = hh(d,a,b,c,buffer[i + 8],11,0x8771F681);
             c = hh(c,d,a,b,buffer[i + 11],16,0x6D9D6122);
             b = hh(b,c,d,a,buffer[i + 14],23,0xFDE5380C);
             a = hh(a,b,c,d,buffer[i + 1],4,0xA4BEEA44);
             d = hh(d,a,b,c,buffer[i + 4],11,0x4BDECFA9);
             c = hh(c,d,a,b,buffer[i + 7],16,0xF6BB4B60);
             b = hh(b,c,d,a,buffer[i + 10],23,0xBEBFBC70);
             a = hh(a,b,c,d,buffer[i + 13],4,0x289B7EC6);
             d = hh(d,a,b,c,buffer[i + 0],11,0xEAA127FA);
             c = hh(c,d,a,b,buffer[i + 3],16,0xD4EF3085);
             b = hh(b,c,d,a,buffer[i + 6],23,0x04881D05);
             a = hh(a,b,c,d,buffer[i + 9],4,0xD9D4D039);
             d = hh(d,a,b,c,buffer[i + 12],11,0xE6DB99E5);
             c = hh(c,d,a,b,buffer[i + 15],16,0x1FA27CF8);
             b = hh(b,c,d,a,buffer[i + 2],23,0xC4AC5665);
             a = ii(a,b,c,d,buffer[i + 0],6,0xF4292244);
             d = ii(d,a,b,c,buffer[i + 7],10,0x432AFF97);
             c = ii(c,d,a,b,buffer[i + 14],15,0xAB9423A7);
             b = ii(b,c,d,a,buffer[i + 5],21,0xFC93A039);
             a = ii(a,b,c,d,buffer[i + 12],6,0x655B59C3);
             d = ii(d,a,b,c,buffer[i + 3],10,0x8F0CCC92);
             c = ii(c,d,a,b,buffer[i + 10],15,0xFFEFF47D);
             b = ii(b,c,d,a,buffer[i + 1],21,0x85845DD1);
             a = ii(a,b,c,d,buffer[i + 8],6,0x6FA87E4F);
             d = ii(d,a,b,c,buffer[i + 15],10,0xFE2CE6E0);
             c = ii(c,d,a,b,buffer[i + 6],15,0xA3014314);
             b = ii(b,c,d,a,buffer[i + 13],21,0x4E0811A1);
             a = ii(a,b,c,d,buffer[i + 4],6,0xF7537E82);
             d = ii(d,a,b,c,buffer[i + 11],10,0xBD3AF235);
             c = ii(c,d,a,b,buffer[i + 2],15,0x2AD7D2BB);
             b = ii(b,c,d,a,buffer[i + 9],21,0xEB86D391);
             w[0] = add(a,w[0]);
             w[1] = add(b,w[1]);
             w[2] = add(c,w[2]);
             w[3] = add(d,w[3])}
           var t=new Array(16);
           for(var i=0;i < 4;i++)
            for(var j=0;j < 4;j++)t[i * 4 + j] = w[i] >> 8 * j & 0xFF;
           return t}
         return function(s,ofs,len)
          {var buf=[],content=caml_ml_bytes_content(s);
           if(typeof content === "string")
            {var b=content;
             for(var i=0;i < len;i += 4)
              {var j=i + ofs;
               buf[i >> 2]
               =
               b.charCodeAt(j)
               |
               b.charCodeAt(j + 1)
               <<
               8
               |
               b.charCodeAt(j + 2)
               <<
               16
               |
               b.charCodeAt(j + 3)
               <<
               24}
             for(;i < len;i++)
              buf[i >> 2] |= b.charCodeAt(i + ofs) << 8 * (i & 3)}
           else
            {var a=content;
             for(var i=0;i < len;i += 4)
              {var j=i + ofs;
               buf[i >> 2]
               =
               a[j]
               |
               a[j + 1]
               <<
               8
               |
               a[j + 2]
               <<
               16
               |
               a[j + 3]
               <<
               24}
             for(;i < len;i++)buf[i >> 2] |= a[i + ofs] << 8 * (i & 3)}
           return caml_string_of_array(md5(buf,len))}}
       ();
    function caml_md5_string(s,ofs,len)
     {return caml_md5_bytes(caml_bytes_of_string(s),ofs,len)}
    function caml_sys_close(fd){delete caml_global_data.fds[fd];return 0}
    var caml_ml_channels=new Array();
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(! chan.buffer || chan.buffer == "")return 0;
      if
       (chan.fd
        &&
        caml_global_data.fds[chan.fd]
        &&
        caml_global_data.fds[chan.fd].output)
       {var output=caml_global_data.fds[chan.fd].output;
        switch(output.length)
         {case 2:output(chanid,chan.buffer);break;default:output(chan.buffer)}}
      chan.buffer = "";
      return 0}
    function caml_ml_close_channel(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_flush(chanid);
      chan.opened = false;
      chan.file.close();
      caml_sys_close(chan.fd);
      return 0}
    function caml_ml_debug_info_status(){return 0}
    function caml_ml_refill_input(chan)
     {var str=chan.refill(),str_len=caml_ml_string_length(str);
      if(str_len == 0)chan.refill = null;
      chan.file.write(chan.file.length(),str,0,str_len);
      return str_len}
    function caml_ml_input(chanid,s,i,l)
     {var chan=caml_ml_channels[chanid],l2=chan.file.length() - chan.offset;
      if(l2 == 0 && chan.refill != null)l2 = caml_ml_refill_input(chan);
      if(l2 < l)l = l2;
      chan.file.read(chan.offset,s,i,l);
      chan.offset += l;
      return l}
    function caml_ml_may_refill_input(chanid)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill == null)return;
      if(chan.file.length() != chan.offset)return;
      caml_ml_refill_input(chan)}
    function caml_raise_end_of_file()
     {caml_raise_constant(caml_global_data.End_of_file)}
    function caml_ml_input_char(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      if(chan.offset >= chan.file.length())caml_raise_end_of_file();
      var res=chan.file.read_one(chan.offset);
      chan.offset++;
      return res}
    function caml_std_output(chanid,s)
     {var
       chan=caml_ml_channels[chanid],
       str=caml_string_of_jsbytes(s),
       slen=caml_ml_string_length(str);
      chan.file.write(chan.offset,str,0,slen);
      chan.offset += slen;
      return 0}
    function js_print_stderr(s)
     {var s=caml_utf16_of_utf8(s),g=globalThis;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stderr.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.error && v.error(s)}}
    function js_print_stdout(s)
     {var s=caml_utf16_of_utf8(s),g=globalThis;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stdout.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.log && v.log(s)}}
    function caml_sys_open_internal(idx,output,file,flags)
     {if(caml_global_data.fds === undefined)
       caml_global_data.fds = new Array();
      flags = flags?flags:{};
      var info={};
      info.file = file;
      info.offset = flags.append?file.length():0;
      info.flags = flags;
      info.output = output;
      caml_global_data.fds[idx] = info;
      if(! caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)
       caml_global_data.fd_last_idx = idx;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      var
       root=resolve_fs_device(name),
       file=root.device.open(root.rest,f),
       idx=caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;
      return caml_sys_open_internal(idx + 1,caml_std_output,file,f)}
    caml_sys_open_internal
     (0,caml_std_output,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (1,js_print_stdout,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (2,js_print_stderr,new MlFakeFile(caml_create_bytes(0)));
    function caml_ml_open_descriptor_in(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var refill=null;
      if(fd == 0 && fs_node_supported())
       {var fs=require("fs");
        refill
        =
        function(){return caml_string_of_jsstring(fs.readFileSync(0,"utf8"))}}
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:false,
         refill:refill};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_ml_open_descriptor_out(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:true,
         buffer:""};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    function caml_string_of_bytes(s){return s}
    function caml_ml_output_bytes(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var bytes;
      if(offset == 0 && caml_ml_bytes_length(buffer) == len)
       bytes = buffer;
      else
       {bytes = caml_create_bytes(len);
        caml_blit_bytes(buffer,offset,bytes,0,len)}
      var
       string=caml_string_of_bytes(bytes),
       jsstring=caml_jsbytes_of_string(string),
       id=jsstring.lastIndexOf("\n");
      if(id < 0)
       chan.buffer += jsstring;
      else
       {chan.buffer += jsstring.substr(0,id + 1);
        caml_ml_flush(chanid);
        chan.buffer += jsstring.substr(id + 1)}
      return 0}
    function caml_ml_output(chanid,buffer,offset,len)
     {return caml_ml_output_bytes
              (chanid,caml_bytes_of_string(buffer),offset,len)}
    function caml_ml_output_char(chanid,c)
     {var s=caml_string_of_jsbytes(String.fromCharCode(c));
      caml_ml_output(chanid,s,0,1);
      return 0}
    function caml_mod(x,y){if(y == 0)caml_raise_zero_divide();return x % y}
    function caml_notequal(x,y){return + (caml_compare_val(x,y,false) != 0)}
    function caml_obj_block(tag,size)
     {var o=new Array(size + 1);
      o[0] = tag;
      for(var i=1;i <= size;i++)o[i] = 0;
      return o}
    function caml_obj_make_forward(b,v){b[0] = 250;b[1] = v;return 0}
    function caml_obj_tag(x)
     {if(x instanceof Array && x[0] == x[0] >>> 0)
       return x[0];
      else
       if(caml_is_ml_bytes(x))
        return 252;
       else
        if(caml_is_ml_string(x))
         return 252;
        else
         if(x instanceof Function || typeof x == "function")
          return 247;
         else
          if(x && x.caml_custom)return 255;else return 1000}
    function caml_register_global(n,v,name_opt)
     {if(name_opt && globalThis.toplevelReloc)
       n = globalThis.toplevelReloc(name_opt);
      caml_global_data[n + 1] = v;
      if(name_opt)caml_global_data[name_opt] = v}
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_jsbytes_of_string(nm)] = v;return 0}
    function caml_set_oo_id(b){b[2] = caml_oo_last_id++;return b}
    function caml_bytes_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_string_equal(s1,s2){return caml_bytes_equal(s1,s2)}
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_string_get(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s))caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    var
     caml_argv=
      function()
        {var g=globalThis,main="a.out",args=[];
         if(g.process && g.process.argv && g.process.argv.length > 1)
          {var argv=g.process.argv;main = argv[1];args = argv.slice(2)}
         var p=caml_string_of_jsstring(main),args2=[0,p];
         for(var i=0;i < args.length;i++)
          args2.push(caml_string_of_jsstring(args[i]));
         return args2}
       ();
    function caml_sys_argv(a){return caml_argv}
    function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0}
    function caml_sys_exit(code)
     {var g=globalThis;
      if(g.quit)g.quit(code);
      if(g.process && g.process.exit)g.process.exit(code);
      caml_invalid_argument("Function 'exit' not implemented")}
    var
     os_type=
      globalThis.process
       &&
       globalThis.process.platform
       &&
       globalThis.process.platform
       ==
       "win32"
       ?"Cygwin"
       :"Unix";
    function caml_sys_get_config()
     {return [0,caml_string_of_jsbytes(os_type),32,0]}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var g=globalThis,n=caml_jsstring_of_string(name);
      if(g.process && g.process.env && g.process.env[n] != undefined)
       return caml_string_of_jsstring(g.process.env[n]);
      if(globalThis.jsoo_static_env && globalThis.jsoo_static_env[n])
       return caml_string_of_jsstring(globalThis.jsoo_static_env[n]);
      caml_raise_not_found()}
    function caml_sys_random_seed()
     {if(globalThis.crypto)
       if(typeof globalThis.crypto.getRandomValues === "function")
        {var a=new (globalThis.Uint32Array)(1);
         globalThis.crypto.getRandomValues(a);
         return [0,a[0]]}
       else
        if(globalThis.crypto.randomBytes === "function")
         {var
           buff=globalThis.crypto.randomBytes(4),
           a=new (globalThis.Uint32Array)(buff);
          return [0,a[0]]}
      var now=new Date().getTime(),x=now ^ 0xffffffff * Math.random();
      return [0,x]}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function caml_update_dummy(x,y)
     {if(typeof y === "function"){x.fun = y;return 0}
      if(y.fun){x.fun = y.fun;return 0}
      var i=y.length;
      while(i--)x[i] = y[i];
      return 0}
    function caml_weak_blit(a1,i1,a2,i2,len)
     {caml_array_blit
       (a1,caml_ephe_key_offset + i1 - 1,a2,caml_ephe_key_offset + i2 - 1,len);
      return 0}
    function caml_weak_check(x,i)
     {return x[caml_ephe_key_offset + i]
              !==
              undefined
              &&
              x[caml_ephe_key_offset + i]
              !==
              0
              ?1
              :0}
    function caml_weak_create(n)
     {if(n < 0)caml_invalid_argument("Weak.create");
      var x=[251,"caml_ephe_list_head"];
      x.length = caml_ephe_key_offset + n;
      return x}
    function caml_weak_get(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_key");
      return x[caml_ephe_key_offset + i] === undefined
              ?0
              :x[caml_ephe_key_offset + i]}
    function caml_obj_dup(x)
     {var l=x.length,a=new Array(l);
      for(var i=0;i < l;i++)a[i] = x[i];
      return a}
    function caml_weak_get_copy(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_copy");
      var y=caml_weak_get(x,i);
      if(y === 0)return y;
      var z=y[1];
      if(z instanceof Array)return [0,caml_obj_dup(z)];
      return y}
    function caml_return_exn_constant(tag){return tag}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (globalThis.RangeError
        &&
        e instanceof globalThis.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (globalThis.InternalError
        &&
        e instanceof globalThis.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof globalThis.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_string_of_jsstring(String(e))]}
    function MlNat(x)
     {this.data = new (globalThis.Int32Array)(x);
      this.length = this.data.length + 2}
    MlNat.prototype.caml_custom = "_nat";
    function create_nat(size)
     {var arr=new MlNat(size);
      for(var i=0;i < size;i++)arr.data[i] = - 1;
      return arr}
    function incr_nat(nat,ofs,len,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) + carry;
        nat.data[ofs + i] = x | 0;
        if(x == x >>> 0){carry = 0;break}else carry = 1}
      return carry}
    function serialize_nat(writer,nat,sz)
     {var len=nat.data.length;
      writer.write(32,len);
      for(var i=0;i < len;i++)writer.write(32,nat.data[i]);
      sz[0] = len * 4;
      sz[1] = len * 8}
    function deserialize_nat(reader,sz)
     {var len=reader.read32s(),nat=new MlNat(len);
      for(var i=0;i < len;i++)nat.data[i] = reader.read32s();
      sz[0] = len * 4;
      return nat}
    function num_digits_nat(nat,ofs,len)
     {for(var i=len - 1;i >= 0;i--)if(nat.data[ofs + i] != 0)return i + 1;
      return 1}
    function caml_hash_nat(x)
     {var len=num_digits_nat(x,0,x.data.length),h=0;
      for(var i=0;i < len;i++)h = caml_hash_mix_int(h,x.data[i]);
      return h}
    function initialize_nat()
     {caml_custom_ops["_nat"]
      =
      {deserialize:deserialize_nat,serialize:serialize_nat,hash:caml_hash_nat}}
    function set_digit_nat(nat,ofs,digit){nat.data[ofs] = digit;return 0}
    function set_to_zero_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)nat.data[ofs + i] = 0;return 0}
    function unix_inet_addr_of_string(){return 0}
    function caml_is_special_exception(exn)
     {switch(exn[2]){case - 8:case - 11:case - 12:return 1;default:return 0}}
    function caml_format_exception(exn)
     {var r="";
      if(exn[0] == 0)
       {r += exn[1][1];
        if
         (exn.length
          ==
          3
          &&
          exn[2][0]
          ==
          0
          &&
          caml_is_special_exception(exn[1]))
         var bucket=exn[2],start=1;
        else
         var start=2,bucket=exn;
        r += "(";
        for(var i=start;i < bucket.length;i++)
         {if(i > start)r += ", ";
          var v=bucket[i];
          if(typeof v == "number")
           r += v.toString();
          else
           if(v instanceof MlBytes)
            r += '"' + v.toString() + '"';
           else
            if(typeof v == "string")
             r += '"' + v.toString() + '"';
            else
             r += "_"}
        r += ")"}
      else
       if(exn[0] == 248)r += exn[1];
      return r}
    function caml_fatal_uncaught_exception(err)
     {if(err instanceof Array && (err[0] == 0 || err[0] == 248))
       {var handler=caml_named_value("Printexc.handle_uncaught_exception");
        if(handler)
         handler(err,false);
        else
         {var
           msg=caml_format_exception(err),
           at_exit=caml_named_value("Pervasives.do_at_exit");
          if(at_exit)at_exit(0);
          globalThis.console.error("Fatal error: exception " + msg + "\n")}}
      else
       throw err}
    function caml_setup_uncaught_exception_handler()
     {var g=globalThis;
      if(g.process && g.process.on)
       g.process.on
        ("uncaughtException",
         function(err,origin)
          {caml_fatal_uncaught_exception(err);g.process.exit(2)});
      else
       if(g.addEventListener)
        g.addEventListener
         ("error",
          function(event)
           {if(event.error)caml_fatal_uncaught_exception(event.error)})}
    caml_setup_uncaught_exception_handler();
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4?f(a0,a1,a2,a3):caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5?f(a0,a1,a2,a3,a4):caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    function caml_call10(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)
     {return f.length == 10
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)
              :caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7,a8,a9])}
    caml_fs_init();
    var
     Out_of_memory=[248,caml_string_of_jsbytes("Out_of_memory"),-1],
     Sys_error=[248,caml_string_of_jsbytes("Sys_error"),-2],
     Failure=[248,caml_string_of_jsbytes("Failure"),-3],
     Invalid_argument=[248,caml_string_of_jsbytes("Invalid_argument"),-4],
     End_of_file=[248,caml_string_of_jsbytes("End_of_file"),-5],
     Division_by_zero=[248,caml_string_of_jsbytes("Division_by_zero"),-6],
     Not_found=[248,caml_string_of_jsbytes("Not_found"),-7],
     Match_failure=[248,caml_string_of_jsbytes("Match_failure"),-8],
     Stack_overflow=[248,caml_string_of_jsbytes("Stack_overflow"),-9],
     Sys_blocked_io=[248,caml_string_of_jsbytes("Sys_blocked_io"),-10],
     Assert_failure=[248,caml_string_of_jsbytes("Assert_failure"),-11],
     Undefined_recursive_module=
      [248,caml_string_of_jsbytes("Undefined_recursive_module"),-12],
     zero$0=caml_int64_create_lo_mi_hi(0,0,0),
     one$0=caml_int64_create_lo_mi_hi(1,0,0),
     dummy_pos=[0,caml_string_of_jsbytes(""),0,0,-1],
     zero_pos=[0,caml_string_of_jsbytes(""),1,0,0],
     sub_format=[0,0,caml_string_of_jsbytes("")],
     formatting_lit=[0,caml_string_of_jsbytes("@;"),1,0],
     partial=[4,0,0,0,[12,45,[4,0,0,0,0]]],
     locfmt=
      [0,
       [11,
        caml_string_of_jsbytes('File "'),
        [2,
         0,
         [11,
          caml_string_of_jsbytes('", line '),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", characters "),
            [4,
             0,
             0,
             0,
             [12,45,[4,0,0,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]]]]]]]]],
       caml_string_of_jsbytes('File "%s", line %d, characters %d-%d: %s')],
     shared=
      [0,
       caml_string_of_jsbytes("clone"),
       caml_string_of_jsbytes("next"),
       caml_string_of_jsbytes("count")],
     _hZ_=
      [0,
       caml_string_of_jsbytes("put"),
       caml_string_of_jsbytes("flush"),
       caml_string_of_jsbytes("close_out")],
     _h1_=[0,caml_string_of_jsbytes("get"),caml_string_of_jsbytes("close_in")],
     shared$0=
      [0,caml_string_of_jsbytes("close_in"),caml_string_of_jsbytes("input")],
     at_negative_index_msg=
      caml_string_of_jsbytes("List: Negative index not allowed"),
     at_after_end_msg=caml_string_of_jsbytes("List: Index past end of list"),
     cany=[0,[0,0,255],0],
     eps_expr=[0,0,0],
     partial$0=[12,62,0],
     dummy$3=[0,caml_string_of_jsbytes(""),[0,-1,-1],[0,-1,-1],-1,-1],
     nat=[0,[0,caml_string_of_jsbytes("nat"),0]],
     zero$3=[1,caml_string_of_jsbytes("Z"),0],
     v$0=[1,1],
     v=[1,0],
     default_reduction=
      [0,
       8,
       caml_string_of_jsbytes
        ("\0>\0\0\0<\x0e\0=\r\0\0-\0\0;\0\x0f\x01\0?\0@\x12\0\0\0\0\0\0\0\0\0\0\0\0\x0045\x003\0\x0027\0\0\0\0\0\0\x13\0\0\x009\0\0\x15\x10\0\0\0\0\0\0\x17\0\0\0\x1b\0\x11\0\x02\0A\0B\0\0\0\0\0\0\0\0) \x07\0\n\0\0\b\0\0\0\x03\"\0\0$'\0\0/\0\0\0\0C\0\0+\0D\0\0%\x04\0E\0F\x05\0G")],
     error=
      [0,
       30,
       caml_string_of_jsbytes
        ("\x80\b \0\0\0\0\0\0\x82\0\x03'pH\x04\b \0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0@\0\x02\0\x02\b\0\0\0\0\0\0\x80\0\0\x10\0\0\0\0\0\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0@\0\0\0\x02\x80(\xf0\0\0\0\0\0\0\0\0 \n<\0\x80(\xf0\0I\xdc2\x01\x02\b\0\x04\0\0\0\x12S\f\x80\0\x02\0\0\0\0\x02\x02\b \0\0\0\x80\0\0\0\b\0\x82\b\0\x06\b \0\0\0\0\0\0\0\0\x05\x10\0\0\0\0\0\0A\0\0\0 \x82\0\0\0\0\0\0\0\0\0\b \x80\x01\xcc\b\x1aG0 i\x10@\0\x80\0\0\x02\x02\0\xa3\xc0\0\0\0\0\0\0 \0\0\0\x02\x02\0\xa3\xc0\0\0\0\0\0\0\x02\0\0\0\x80\0\0\0\0\0\0\0\0\x04\x94\xc1 \x80(\xf0\0IL\x12\b\x02\x8f\0\x04\x94\xc1 \x80(\xf0\0\0\0\0\b\x02\x8f\0\x04\x94\xc1 \x12S\x04\x80\0\0\0\x01\x050\0\0\0\0\0\0S\0\0\0\0\0\0\x050@\0\0\0\x03\"\0\x80\0\0\0\0\0\0\b\0\b\x80\x000\b \x80\x01\x8c\0\x02\x02 \0\x1e\n\x88  c\x02\0\x90 \x82\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\0\0\0\0\0\x02\b\xa0\0c\x02\0\x90\0\0\0\0\0 \0\x02\b \0c\0\0\x80\0\0\0\0\0\0\0\b\x80\0\0\x82(\xf0\0\0\0\0\0\0\0\0\0\x94\xc0 \x80(\xf0\0\0\0\0\0 \0\0 \n<\0\0S\x04\0\0\0\x10\0\0\0\0\b\x80\0!\0\0\x80\0\0\0\0 \0\b\0\0\0\0\0\0\0\0@\0\x82\0\0\0\0\0\0\0\0\0\0\0\x04\0\0\0\0 \x82\b\0\0\0\0\0\0\0\0\x01\x04\0\x10\0\0\0\0")],
     action=
      [0,
       [0,
        16,
        caml_string_of_jsbytes
         ("\0\x06\0\0\0\x05\0\t\0\xe8\0\0\0\0\0\0\0\0\0\0\0\x1a\0\x05\0\0\0\b\0H\0\0\0d\0\0\0\0\0F\0\0\0\x8a\0\0\0\0\0\x8a\0\x8a\0\x18\0\xe8\0x\0f\0\x84\0r\0\x94\0\x96\0\x90\0\x94\0\x94\0\0\0\0\x01\x1e\0\0\0J\0\x94\0\0\0\0\0\x94\x008\0J\x01\x18\0\x94\0\x8a\0\0\0\x84\0\xa0\0\x8a\0\0\0\xc0\0\x05\0\0\0\0\0\xac\0\x8a\0\xc8\0\x8a\0\xe4\0\x8a\0\0\0\x8a\x01\0\x01\x1c\0\0\x01\x88\0\0\0v\0\0\x01\x96\0\0\0\xd4\0\0\0\xcc\x01\f\0\x94\x01\xac\0,\0\x94\x01\\\0\x94\0\0\0\0\0\0\0\x05\0\0\x01j\x01`\0\0\0\xe2\0\x94\x01\xba\0\0\0\0\0\x05\x016\0\0\0\0\x01d\0\x8a\0\0\0\xf8\0\x8a\x01\xb8\0\xe0\0\0\x01D\0\xd4\0\0\x01\xa4\0\0\x01\x02\0\x05\0\0\0\0\x01\x16\0\0\x01j\0\0\0\0\0\xb8\0\0")],
       [0,
        16,
        caml_string_of_jsbytes
         ('\0\xe5\0\xe5\x01\x96\0\x07\0\xe5\0"\0\x95\0\xe5\0\x12\0\xe5\0\n\x006\0\xe5\0\xe5\0:\0\n\0\x0e\0M\0\xad\0\xe5\0M\0\x0e\0\xe5\0M\0n\0M\0\x15\x006\0M\0M\0\x15\0\xaa\0\xd5\0\xd5\0\xe5\0M\0\xd5\0\xd5\0M\0.\0\xaa\0\xdd\0\xdd\0>\0\xd5\0\xdd\0\xb6\x01R\0\x15\x01j\x01r\0\xd5\0\xd5\0\xdd\0\xd5\0F\0U\0\xd5\0S\0U\0\xdd\0\xdd\0U\0\xdd\0U\0v\0\xdd\0U\0U\0[\0\xf6\0^\0\xfe\0\xf1\0U\x01\x0e\x01\x06\0U\0y\0\x96\0\x86\0b\0y\0f\0~\0\x82\0\x92\0j\0z\0\xce\0\xd2\0q\0\x9a\0\x8a\0q\0\xaa\0\x8e\0\xf6\0\xca\0\xfe\0y\0\xb6\x01\x0e\x01\x06\0\xda\0e\x01;\x01>\0e\0q\0\x81\0\xf6\0q\0\xfe\0\x81\x01\xff\x01\x0e\x01\x06\0\xe6\0]\x01B\0\x16\0]\0e\x01N\0]\0e\0]\0\n\x01\x82\0]\x01\x06\x01\xb2\0a\0\x0e\x01\xbf\0a\0]\0)\0\xf6\0]\0\xfe\0)\0\xaa\x01\x0e\x01\x06\0\xc5\0m\0\xa2\0\xb6\0m\0a\0\xc5\0\xf6\0a\0\xfe\x01\xda\0^\x01\x0e\x01\x06\0)\x01F\x01\xeb\0\x89\0\xc1\0m\0\xa5\0b\0m\0f\0\xa5\0\0\0\0\0j\0z\0\xce\0\xd2\0\xaa\0\x9d\0\xaa\0!\x01\xf3\0\x9d\0\xb6\0!\0\xb6\0\xb5\0\x86\x01\xc6\0\xf6\0\x9d\0\xfe\0\x9d\0\x92\x01\x0e\x01\x06\0\0\0y\0\0\0\x9a\0\x9d\x01"\0!\x01Z\x01\xa6\x01Z\0\0\0=\0\0\0=\x01\xd3\0\0\0=\0=\0\xf6\0\0\0\xfe\0\xaa\0-\x01\x0e\x01\x06\0\0\0-\0\xb6\0\xaa\0\xbd\x013\0\0\x01\xd6\0\xbd\0\xb6\0\xf6\0\0\0\xfe\0\0\0\0\x01\x0e\x01\x06\0\0\0\0\0-\0\0\0\0\0u\0\0\0\0\0\0\0\xbd')]],
     lhs=
      [0,
       8,
       caml_string_of_jsbytes
        ("\x04\x03\x02\x01\0\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1d\x1c\x1c\x1b\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x19\x18\x18\x17\x17\x16\x16\x15\x14\x14\x13\x13\x12\x12\x11\x11\x10\x10\x0f\x0e\r\f\f\f\f\f\f\x0b\n\n\n\n\t\t\b\b\x07\x07\x06\x06\x05\x05")],
     goto$0=
      [0,
       [0,
        8,
        caml_string_of_jsbytes
         ("2\0D\0:\0\0\0\0\0\0@\0\0\0\0\0\0\0\0\0\r\0\0PZ\0F\0\0\n\0\x02\0\0\xb8\xbe\0\0\0\0\0\xc2\0\0\xc8\0\0\0\0t\0Z\0~\0\0\xd0\0\0\0\x82\0\x86\0\x8a\0\x8e\0\0\0\0\0\0\0\0\0\0\0\0\0\xd0\0\0\xae\0\t\0\0\0\x18\0\x1c\0\0\0\xda\0\0\0Z\x15\0\0\0*\0\0\x98\0\0\0\0\f\0,\0\0\xb6\0\0\0\0\x05\0\0\0\0")],
       [0,
        8,
        caml_string_of_jsbytes
         ("89K~89gc,V,\x7fh,1X<id2<L\x07eso,^y_q89Y\x13\x07qk`\x07\n\\\x07z\x07\x07\b<i\r89\x1d\n\x1489\n\x0b6\n\x0b\x11\n\x0blHJ89\0<G8989898989\0<F89\0<=<?<A<C<E,V\x07<n,0Y(*,-Z,/8;,S\0\nx,b")]],
     lr0_incoming=
      [0,
       8,
       caml_string_of_jsbytes
        ("\0\x02\x1a&\x1a\f\x15#\f9;6# \x16\x109\f\x13;0\0\x02\x06\x1a\x1e&\x1a#\f(&:\x0e&2\x1a\f&\x19\f\x1b\b\x19\x1b\x14\x1b\x1b\x1b\x1d2*,\x1d2\x15\x17.\x1757\x187\x1c7\"7$7775\f7\x1170\0\x02\x04&8\x1b&4\x1b<''18;:\x1b\x1f1\"\x1b\x0f%/\n!-76!)\x12730=6%\0\x02&8;\r+0\0\x02\x0b\x1b0")],
     rhs=
      [0,
       [0,
        8,
        caml_string_of_jsbytes
         ("\x13\x11\x0f\r\x0b&&41&:\x1f&:\x1b&8;\x04&\x04&8\x1b9\x15\x1a9\f5\x1a5\f\x06*&\x17.\x17&\x1a#\f7$77\x1c77\"77\x187\x1e7(\x1d27,\x1d27/)\x127'%!&8;\n-\x1b\x1b<'==6%;;6#776!1\"\x1b&:\x1b\x19\x1a\x19\f\x1a\f&\x1b\x14\x1b\x1b\b\x1b\x0e&2\x1b\x15&& \x16\x10&\x1a\f&\x1a#\f\x02;0\x0270\x0230\x02+0\x02\x1b0")],
       [0,
        8,
        caml_string_of_jsbytes
         ("\0\x01\x02\x03\x04\x05\x06\t\f\x0f\x12\x14\x18\x19\x1a\x1d\x1e!\"#$'+.1479=AEEFFGGHKKMNQRUVYZ]`cdgijmptuvz}\x81\x82\x84\x85\x87\x88\x8a\x8b\x8d\x8e\x90")]],
     lr0_core=
      [0,
       8,
       caml_string_of_jsbytes
        ("\0\x01\x02\x03\x04\x05\x06\x07\b\t\n\x0b\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&'()*+,-./0123456789:;<=>?@CDABEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7f")],
     lr0_items=
      [0,
       [0,
        32,
        caml_string_of_jsbytes
         ("\0\0\0\0\0\0\xf4\x01\0\x008\x01\0\0\xf0\x01\0\0\xec\x01\0\0\xe8\x01\0\0\xe4\x01\0\0\xf0\x02\0\0\xec\x02\0\0\xec\x03\0\x004\x01\0\0\xf0\x03\0\0\xf0\x04\0\x000\x01\0\0\xb0\x01\0\0\xac\x01\0\0\xb0\x02\0\0\xb0\x03\0\0\xe8\x02\0\0\xe8\x03\0\0\xe8\x04\0\x008\x02\0\x008\x03\0\0\0\x01\0\0\xf8\x01\0\0\xf8\x02\0\0\x04\0\0\0\xfc\x01\0\0D\x01\0\0@\x01\0\0h\x01\0\0\xf0\x01\0\0\xec\x01\0\0\xe8\x01\0\0\xe4\x01\0\0T\x01\0\0L\x01\0\0\xf0\x02\0\0\xec\x02\0\0T\x02\0\0\xf0\x03\0\0T\x03\0\0\xf0\x04\0\0T\x04\0\0l\x01\0\0\xc0\x01\0\0\xc0\x02\0\0\xdc\x01\0\0\xdc\x02\0\0\xdc\x03\0\0\xcc\x01\0\0\xc8\x01\0\0\xcc\x02\0\0\xd0\x01\0\0\xc8\x02\0\0\xc4\x01\0\0\xc8\x03\0\0\xd8\x01\0\0\xd4\x01\0\0\xd8\x02\0\0\xc4\x01\0\0\xd8\x03\0\0\xd8\x01\0\0\xd4\x01\0\0\xd4\x02\0\0\xd8\x01\0\0\xd4\x03\0\0\xd4\x01\0\0\xdc\x04\0\0\xd8\x01\0\0\xd4\x01\0\0\xd8\x01\0\0\xd4\x01\0\0\xc0\x03\0\0l\x02\0\0l\x03\0\0H\x01\0\0p\x01\0\0p\x02\0\0p\x03\0\0\xe0\x01\0\0P\x01\0\0P\x02\0\0P\x03\0\0<\x01\0\0p\x04\0\0d\x01\0\0`\x01\0\0\\\x01\0\0X\x01\0\0d\x02\0\0d\x03\0\0d\x01\0\0`\x01\0\0\\\x01\0\0X\x01\0\0\\\x02\0\0d\x01\0\0`\x01\0\0\\\x03\0\0\\\x01\0\0X\x01\0\0`\x02\0\0d\x01\0\0`\x03\0\0`\x01\0\0\\\x01\0\0X\x01\0\0X\x02\0\0d\x01\0\0`\x01\0\0\\\x01\0\0X\x03\0\0X\x01\0\0l\x04\0\0d\x01\0\0`\x01\0\0\\\x01\0\0X\x01\0\0h\x02\0\0d\x01\0\0`\x01\0\0\\\x01\0\0X\x01\0\0@\x02\0\0<\x01\0\0@\x03\0\0d\x01\0\0`\x01\0\0\\\x01\0\0X\x01\0\0\x04\x01\0\x01\0\x01\0\0d\x01\0\0`\x01\0\0\\\x01\0\0X\x01\0\x01\0\x02\0\0\b\0\0\x01\x04\x01\0\0,\x01\0\0(\x01\0\0,\x02\0\0(\x02\0\0,\x03\0\0\xd8\x01\0\0\xd4\x01\0\0,\x04\0\0$\x01\0\0 \x01\0\0\x1c\x01\0\0\x18\x01\0\0\x14\x01\0\0\x18\x02\0\0\xd8\x01\0\0\xd4\x01\0\0\xa0\x01\0\0\x9c\x01\0\0\xa0\x02\0\0\xa0\x03\0\0|\x01\0\0\x18\x03\0\0$\x02\0\0$\x03\0\0 \x02\0\0\x1c\x02\0\0\xd8\x01\0\0\xd4\x01\0\0\xa0\x01\0\0\x9c\x01\0\0 \x03\0\0\x1c\x03\0\0\xbc\x01\0\0\xbc\x02\0\0\xd8\x01\0\0\xd4\x01\0\0\xbc\x03\0\0\b\x01\0\0\x84\x01\0\0t\x01\0\0\x98\x01\0\0\x8c\x01\0\0\x98\x02\0\0\xb8\x01\0\0\xb4\x01\0\0d\x01\0\0`\x01\0\0\\\x01\0\0X\x01\0\0\xb8\x02\0\0\xb8\x03\0\0t\x02\0\0t\x03\0\0t\x04\0\0d\x01\0\0`\x01\0\0\\\x01\0\0X\x01\0\x01\b\x01\0\x01\b\x02\0\0\xa8\x01\0\0\xa4\x01\0\0\xa8\x02\0\0\xa8\x03\0\0\f\0\0\x01\f\x01\0\0\x90\x01\0\0\x90\x02\0\0\x90\x03\0\0\f\x01\0\x01\x10\x01\0\x01\x10\x02\0\0\x10\0\0\x01\x14\x01\0\0\x10\x01\0\x01\x18\x01\0\0\xd8\x01\0\0\xd4\x01\0\x01\x18\x02")],
       [0,
        8,
        caml_string_of_jsbytes
         ("\0\x01\x02\x03\x07\t\n\x0b\f\r\x0e\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f%(*,-./01245689;<=@ADGJKLMNOPQRSTUZ[`afglmrw|~\x7f\x83\x84\x89\x8a\x8b\x8c\x8e\x90\x91\x94\x99\x9a\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa6\xab\xac\xad\xae\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xbd\xbe\xbf\xc0\xc1\xc6\xc7\xc8\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xda\xdb")]],
     nullable=caml_string_of_jsbytes("\0\0\x0b\x80"),
     first$0=
      [0,
       30,
       caml_string_of_jsbytes
        ('\x82\b \x02\0\0\x80\f\x88\x02\0(\x02\x8f\0\x80\b \x02\b \x80\b\0\x02\x002 \b\0\xa0\n<\x02\0 \x80\0\0\x02\0\0\0\b\0\x02\b \0\b \x80\0\0\x02\0\0\x82(\0 \n<\0\0 \x80\x04\0\x02\0\0\x82\b\0\b\0\0\0\0\0\x80\x02\0\xa3\xc0\x10\0\b\0\x02\b \x01"\0\x80\x02\0\xa3\xc0\b\x02\x8f\0\0\b \0\0 \x80\x04\0\x02\0\0')],
     keywords=
      [0,
       [0,caml_string_of_jsbytes("true"),1],
       [0,
        [0,caml_string_of_jsbytes("exists"),18],
        [0,
         [0,caml_string_of_jsbytes("false"),17],
         [0,
          [0,caml_string_of_jsbytes("forall"),16],
          [0,
           [0,caml_string_of_jsbytes("rec"),5],
           [0,[0,caml_string_of_jsbytes("type"),0],0]]]]]],
     ocaml_lex_tables=
      [0,
       caml_string_of_jsbytes
        ("\0\0\xe6\xff\xe7\xff\xe8\xff\xe9\xff\xec\xff!\0\xef\xff\xf0\xff\xf1\xff\x02\0\0\0\xf5\xff\x12\0\x01\0\xf8\xff\xf9\xff\xfa\xff\xfb\xffO\0b\0\x02\0\xff\xff\xf7\xff\xf2\xff\xf6\xff\xf4\xff\x02\0\xf3\xff\xeb\xff\xed\xff"),
       caml_string_of_jsbytes
        ("\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x11\0\xff\xff\xff\xff\xff\xff\x19\0\x19\0\xff\xff\x19\0\x15\0\xff\xff\xff\xff\xff\xff\xff\xff\x03\0\x02\0\x01\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"),
       caml_string_of_jsbytes
        ("\x01\0\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0"),
       caml_string_of_jsbytes
        ("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\0\x16\0\x15\0\0\0\x15\0\0\0\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\0\0\0\x15\0\0\0\0\0\0\0\x0e\0\x17\0\x12\0\x11\0\x03\0\x04\0\t\0\x0b\0\b\0\x1b\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x06\0\x07\0\n\0\x05\0\x1a\0\x18\0\x1c\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x1e\0\0\0\0\0\x1d\0\0\0\0\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x10\0\r\0\x0f\0\f\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x14\0\0\0\0\0\0\0\0\0\x19\0\0\0\0\0\0\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\0\0\0\0\0\0\0\0\x14\0\0\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
       caml_string_of_jsbytes
        ("\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\x15\0\xff\xff\0\0\xff\xff\x15\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\x15\0\xff\xff\xff\xff\xff\xff\0\0\x0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0b\0\r\0\x1b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\xff\xff\xff\xff\x06\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x14\0\xff\xff\xff\xff\xff\xff\xff\xff\r\0\xff\xff\xff\xff\xff\xff\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\xff\xff\xff\xff\xff\xff\xff\xff\x14\0\xff\xff\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes("")],
     _u7_=
      [0,
       caml_string_of_jsbytes("parseToUnicode"),
       caml_string_of_jsbytes("parse")],
     shared$1=
      [0,
       caml_string_of_jsbytes("form"),
       caml_string_of_jsbytes("html"),
       caml_string_of_jsbytes("proof"),
       caml_string_of_jsbytes("position"),
       caml_string_of_jsbytes("toascii"),
       caml_string_of_jsbytes("phandle"),
       caml_string_of_jsbytes("parent"),
       caml_string_of_jsbytes("tostring"),
       caml_string_of_jsbytes("fresh"),
       caml_string_of_jsbytes("setmeta"),
       caml_string_of_jsbytes("getmeta"),
       caml_string_of_jsbytes("handle"),
       caml_string_of_jsbytes("mathml")];
    caml_register_global
     (11,Undefined_recursive_module,"Undefined_recursive_module");
    caml_register_global(10,Assert_failure,"Assert_failure");
    caml_register_global(9,Sys_blocked_io,"Sys_blocked_io");
    caml_register_global(8,Stack_overflow,"Stack_overflow");
    caml_register_global(7,Match_failure,"Match_failure");
    caml_register_global(6,Not_found,"Not_found");
    caml_register_global(5,Division_by_zero,"Division_by_zero");
    caml_register_global(4,End_of_file,"End_of_file");
    caml_register_global(3,Invalid_argument,"Invalid_argument");
    caml_register_global(2,Failure,"Failure");
    caml_register_global(1,Sys_error,"Sys_error");
    caml_register_global(0,Out_of_memory,"Out_of_memory");
    var
     _k_=caml_string_of_jsbytes("input"),
     _j_=caml_string_of_jsbytes("output_substring"),
     _i_=caml_string_of_jsbytes("output"),
     _h_=caml_string_of_jsbytes("%.12g"),
     _g_=caml_string_of_jsbytes("."),
     _e_=caml_string_of_jsbytes("true"),
     _f_=caml_string_of_jsbytes("false"),
     _d_=caml_string_of_jsbytes("char_of_int"),
     _a_=caml_string_of_jsbytes("Stdlib.Exit"),
     _b_=caml_int64_create_lo_mi_hi(0,0,32752),
     _c_=caml_int64_create_lo_mi_hi(0,0,65520),
     _l_=caml_string_of_jsbytes("CamlinternalLazy.Undefined"),
     _n_=caml_string_of_jsbytes("\\\\"),
     _o_=caml_string_of_jsbytes("\\'"),
     _p_=caml_string_of_jsbytes("\\b"),
     _q_=caml_string_of_jsbytes("\\t"),
     _r_=caml_string_of_jsbytes("\\n"),
     _s_=caml_string_of_jsbytes("\\r"),
     _m_=caml_string_of_jsbytes("Char.chr"),
     _v_=caml_string_of_jsbytes("List.nth"),
     _u_=caml_string_of_jsbytes("tl"),
     _t_=caml_string_of_jsbytes("hd"),
     _y_=caml_string_of_jsbytes("String.blit / Bytes.blit_string"),
     _x_=caml_string_of_jsbytes("Bytes.blit"),
     _w_=caml_string_of_jsbytes("String.sub / Bytes.sub"),
     _C_=caml_string_of_jsbytes("String.contains_from / Bytes.contains_from"),
     _B_=caml_string_of_jsbytes("String.index_from / Bytes.index_from"),
     _A_=caml_string_of_jsbytes(""),
     _z_=caml_string_of_jsbytes("String.concat"),
     _I_=[0,caml_string_of_jsbytes("array.ml"),322,4],
     _G_=caml_string_of_jsbytes("Array.blit"),
     _F_=caml_string_of_jsbytes("Array.fill"),
     _E_=caml_string_of_jsbytes("Array.sub"),
     _D_=caml_string_of_jsbytes("Array.init"),
     _H_=caml_string_of_jsbytes("Stdlib.Array.Bottom"),
     _J_=caml_string_of_jsbytes("%d"),
     _N_=caml_string_of_jsbytes("%d"),
     _M_=caml_int64_create_lo_mi_hi(0,0,0),
     _L_=caml_int64_create_lo_mi_hi(1,0,0),
     _K_=caml_int64_create_lo_mi_hi(1,0,0),
     _O_=caml_string_of_jsbytes("%d"),
     _U_=caml_string_of_jsbytes("Set.remove_min_elt"),
     _V_=[0,0,0,0],
     _W_=[0,0,0],
     _X_=[0,caml_string_of_jsbytes("set.ml"),570,18],
     _P_=caml_string_of_jsbytes("Set.bal"),
     _Q_=caml_string_of_jsbytes("Set.bal"),
     _R_=caml_string_of_jsbytes("Set.bal"),
     _S_=caml_string_of_jsbytes("Set.bal"),
     _ab_=caml_string_of_jsbytes("Map.remove_min_elt"),
     _ac_=[0,0,0,0],
     _ad_=[0,caml_string_of_jsbytes("map.ml"),400,10],
     _ae_=[0,0,0],
     _Z_=caml_string_of_jsbytes("Map.bal"),
     ___=caml_string_of_jsbytes("Map.bal"),
     _$_=caml_string_of_jsbytes("Map.bal"),
     _aa_=caml_string_of_jsbytes("Map.bal"),
     _ag_=caml_string_of_jsbytes("Stdlib.Stack.Empty"),
     _ah_=caml_string_of_jsbytes("Stdlib.Queue.Empty"),
     _am_=caml_string_of_jsbytes("Buffer.add_substring/add_subbytes"),
     _al_=caml_string_of_jsbytes("Buffer.add: cannot grow buffer"),
     _ak_=[0,caml_string_of_jsbytes("buffer.ml"),93,2],
     _aj_=[0,caml_string_of_jsbytes("buffer.ml"),94,2],
     _ai_=caml_string_of_jsbytes("Buffer.sub"),
     _aw_=caml_string_of_jsbytes("%c"),
     _ax_=caml_string_of_jsbytes("%s"),
     _ay_=caml_string_of_jsbytes("%i"),
     _az_=caml_string_of_jsbytes("%li"),
     _aA_=caml_string_of_jsbytes("%ni"),
     _aB_=caml_string_of_jsbytes("%Li"),
     _aC_=caml_string_of_jsbytes("%f"),
     _aD_=caml_string_of_jsbytes("%B"),
     _aE_=caml_string_of_jsbytes("%{"),
     _aF_=caml_string_of_jsbytes("%}"),
     _aG_=caml_string_of_jsbytes("%("),
     _aH_=caml_string_of_jsbytes("%)"),
     _aI_=caml_string_of_jsbytes("%a"),
     _aJ_=caml_string_of_jsbytes("%t"),
     _aK_=caml_string_of_jsbytes("%?"),
     _aL_=caml_string_of_jsbytes("%r"),
     _aM_=caml_string_of_jsbytes("%_r"),
     _aN_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),850,23],
     _aY_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),814,21],
     _aQ_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),815,21],
     _aZ_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),818,21],
     _aR_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),819,21],
     _a0_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),822,19],
     _aS_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),823,19],
     _a1_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),826,22],
     _aT_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),827,22],
     _a2_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),831,30],
     _aU_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),832,30],
     _aW_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),836,26],
     _aO_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),837,26],
     _aX_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),846,28],
     _aP_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),847,28],
     _aV_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),851,23],
     _bZ_=caml_string_of_jsbytes("%u"),
     _bX_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1558,4],
     _bY_=caml_string_of_jsbytes("Printf: bad conversion %["),
     _b0_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1626,39],
     _b1_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1649,31],
     _b2_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1650,31],
     _b3_=caml_string_of_jsbytes("Printf: bad conversion %_"),
     _b4_=caml_string_of_jsbytes("@{"),
     _b5_=caml_string_of_jsbytes("@["),
     _b6_=caml_string_of_jsbytes("@{"),
     _b7_=caml_string_of_jsbytes("@["),
     _c7_=
      [0,
       [11,
        caml_string_of_jsbytes("bad input: format type mismatch between "),
        [3,0,[11,caml_string_of_jsbytes(" and "),[3,0,0]]]],
       caml_string_of_jsbytes
        ("bad input: format type mismatch between %S and %S")],
     _ck_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,0,0,0,[11,caml_string_of_jsbytes(", duplicate flag "),[1,0]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, duplicate flag %C")],
     _cn_=caml_string_of_jsbytes("0"),
     _cl_=caml_string_of_jsbytes("padding"),
     _cm_=[0,1,0],
     _co_=[0,0],
     _cp_=caml_string_of_jsbytes("precision"),
     _cq_=[1,0],
     _cr_=[1,1],
     _cB_=caml_string_of_jsbytes("'*'"),
     _cy_=caml_string_of_jsbytes("'-'"),
     _cz_=caml_string_of_jsbytes("'0'"),
     _cA_=caml_string_of_jsbytes("'*'"),
     _cv_=caml_string_of_jsbytes("0"),
     _cw_=[1,1],
     _cx_=caml_string_of_jsbytes("0"),
     _cs_=caml_string_of_jsbytes("precision"),
     _ct_=[1,1],
     _cu_=caml_string_of_jsbytes("precision"),
     _cM_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", flag "),
            [1,
             [11,
              caml_string_of_jsbytes(" is only allowed after the '"),
              [12,
               37,
               [11,
                caml_string_of_jsbytes("', before padding and precision"),
                0]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision")],
     _cC_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(', invalid conversion "'),
            [12,37,[0,[12,34,0]]]]]]]],
       caml_string_of_jsbytes
        ('invalid format %S: at character number %d, invalid conversion "%%%c"')],
     _cD_=caml_string_of_jsbytes("'+'"),
     _cE_=caml_string_of_jsbytes("'#'"),
     _cF_=caml_string_of_jsbytes("' '"),
     _cG_=[0,0],
     _cH_=caml_string_of_jsbytes("`padding'"),
     _cI_=[0,0],
     _cJ_=caml_string_of_jsbytes("`precision'"),
     _cK_=caml_string_of_jsbytes("'+'"),
     _cL_=caml_string_of_jsbytes("'_'"),
     _cN_=[0,[12,64,0]],
     _cO_=[0,caml_string_of_jsbytes("@ "),1,0],
     _cP_=[0,caml_string_of_jsbytes("@,"),0,0],
     _cQ_=[2,60],
     _cR_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": '"),
          [12,
           37,
           [11,
            caml_string_of_jsbytes
             ("' alone is not accepted in character sets, use "),
            [12,
             37,
             [12,
              37,
              [11,
               caml_string_of_jsbytes(" instead at position "),
               [4,0,0,0,[12,46,0]]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d.")],
     _cS_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": integer "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(" is greater than the limit "),
            [4,0,0,0,0]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: integer %d is greater than the limit %d")],
     _cU_=caml_string_of_jsbytes("digit"),
     _cT_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2837,11],
     _cV_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(': unclosed sub-format, expected "'),
          [12,
           37,
           [0,
            [11,caml_string_of_jsbytes('" at character number '),[4,0,0,0,0]]]]]]],
       caml_string_of_jsbytes
        ('invalid format %S: unclosed sub-format, expected "%%%c" at character number %d')],
     _cW_=caml_string_of_jsbytes("character ')'"),
     _cX_=caml_string_of_jsbytes("character '}'"),
     _cY_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2899,34],
     _c3_=caml_string_of_jsbytes("'#'"),
     _cZ_=caml_string_of_jsbytes("'+'"),
     _c0_=caml_string_of_jsbytes("'+'"),
     _c1_=caml_string_of_jsbytes("' '"),
     _c2_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2935,28],
     _c5_=caml_string_of_jsbytes("'+'"),
     _c4_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2957,11],
     _c6_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,
             0,
             [11,
              caml_string_of_jsbytes(" is incompatible with '"),
              [0,[11,caml_string_of_jsbytes("' in sub-format "),[3,0,0]]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S")],
     _cj_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(" expected, read "),[1,0]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, %s expected, read %C")],
     _ci_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", '"),
            [0,[11,caml_string_of_jsbytes("' without "),[2,0,0]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, '%c' without %s")],
     _ch_=
      caml_string_of_jsbytes
       ("non-zero widths are unsupported for %c conversions"),
     _cg_=caml_string_of_jsbytes("unexpected end of format"),
     _cf_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,0,0,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]]]],
       caml_string_of_jsbytes("invalid format %S: at character number %d, %s")],
     _b__=
      [0,
       [11,caml_string_of_jsbytes("invalid box description "),[3,0,0]],
       caml_string_of_jsbytes("invalid box description %S")],
     _b8_=caml_string_of_jsbytes(""),
     _b9_=[0,0,4],
     _b$_=caml_string_of_jsbytes(""),
     _ca_=caml_string_of_jsbytes("b"),
     _cb_=caml_string_of_jsbytes("h"),
     _cc_=caml_string_of_jsbytes("hov"),
     _cd_=caml_string_of_jsbytes("hv"),
     _ce_=caml_string_of_jsbytes("v"),
     _bW_=caml_string_of_jsbytes("nan"),
     _bU_=caml_string_of_jsbytes("neg_infinity"),
     _bV_=caml_string_of_jsbytes("infinity"),
     _bT_=caml_string_of_jsbytes("."),
     _bS_=[0,103],
     _bG_=caml_string_of_jsbytes("%+nd"),
     _bH_=caml_string_of_jsbytes("% nd"),
     _bJ_=caml_string_of_jsbytes("%+ni"),
     _bK_=caml_string_of_jsbytes("% ni"),
     _bL_=caml_string_of_jsbytes("%nx"),
     _bM_=caml_string_of_jsbytes("%#nx"),
     _bN_=caml_string_of_jsbytes("%nX"),
     _bO_=caml_string_of_jsbytes("%#nX"),
     _bP_=caml_string_of_jsbytes("%no"),
     _bQ_=caml_string_of_jsbytes("%#no"),
     _bF_=caml_string_of_jsbytes("%nd"),
     _bI_=caml_string_of_jsbytes("%ni"),
     _bR_=caml_string_of_jsbytes("%nu"),
     _bt_=caml_string_of_jsbytes("%+ld"),
     _bu_=caml_string_of_jsbytes("% ld"),
     _bw_=caml_string_of_jsbytes("%+li"),
     _bx_=caml_string_of_jsbytes("% li"),
     _by_=caml_string_of_jsbytes("%lx"),
     _bz_=caml_string_of_jsbytes("%#lx"),
     _bA_=caml_string_of_jsbytes("%lX"),
     _bB_=caml_string_of_jsbytes("%#lX"),
     _bC_=caml_string_of_jsbytes("%lo"),
     _bD_=caml_string_of_jsbytes("%#lo"),
     _bs_=caml_string_of_jsbytes("%ld"),
     _bv_=caml_string_of_jsbytes("%li"),
     _bE_=caml_string_of_jsbytes("%lu"),
     _bg_=caml_string_of_jsbytes("%+Ld"),
     _bh_=caml_string_of_jsbytes("% Ld"),
     _bj_=caml_string_of_jsbytes("%+Li"),
     _bk_=caml_string_of_jsbytes("% Li"),
     _bl_=caml_string_of_jsbytes("%Lx"),
     _bm_=caml_string_of_jsbytes("%#Lx"),
     _bn_=caml_string_of_jsbytes("%LX"),
     _bo_=caml_string_of_jsbytes("%#LX"),
     _bp_=caml_string_of_jsbytes("%Lo"),
     _bq_=caml_string_of_jsbytes("%#Lo"),
     _bf_=caml_string_of_jsbytes("%Ld"),
     _bi_=caml_string_of_jsbytes("%Li"),
     _br_=caml_string_of_jsbytes("%Lu"),
     _a5_=caml_string_of_jsbytes("%+d"),
     _a6_=caml_string_of_jsbytes("% d"),
     _a8_=caml_string_of_jsbytes("%+i"),
     _a9_=caml_string_of_jsbytes("% i"),
     _a__=caml_string_of_jsbytes("%x"),
     _a$_=caml_string_of_jsbytes("%#x"),
     _ba_=caml_string_of_jsbytes("%X"),
     _bb_=caml_string_of_jsbytes("%#X"),
     _bc_=caml_string_of_jsbytes("%o"),
     _bd_=caml_string_of_jsbytes("%#o"),
     _a4_=caml_string_of_jsbytes("%d"),
     _a7_=caml_string_of_jsbytes("%i"),
     _be_=caml_string_of_jsbytes("%u"),
     _ao_=caml_string_of_jsbytes("@]"),
     _ap_=caml_string_of_jsbytes("@}"),
     _aq_=caml_string_of_jsbytes("@?"),
     _ar_=caml_string_of_jsbytes("@\n"),
     _as_=caml_string_of_jsbytes("@."),
     _at_=caml_string_of_jsbytes("@@"),
     _au_=caml_string_of_jsbytes("@%"),
     _av_=caml_string_of_jsbytes("@"),
     _an_=[0,0,0],
     _a3_=caml_string_of_jsbytes("CamlinternalFormat.Type_mismatch"),
     _da_=caml_string_of_jsbytes(""),
     _db_=
      [0,
       [11,caml_string_of_jsbytes(", "),[2,0,[2,0,0]]],
       caml_string_of_jsbytes(", %s%s")],
     _dy_=
      [0,
       [11,caml_string_of_jsbytes("Fatal error: exception "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Fatal error: exception %s\n")],
     _dz_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Fatal error in uncaught exception handler: exception "),
        [2,0,[12,10,0]]],
       caml_string_of_jsbytes
        ("Fatal error in uncaught exception handler: exception %s\n")],
     _dx_=
      caml_string_of_jsbytes
       ("Fatal error: out of memory in uncaught exception handler"),
     _dw_=
      [0,
       [11,caml_string_of_jsbytes("Fatal error: exception "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Fatal error: exception %s\n")],
     _dt_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _du_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("(Program not linked with -g, cannot print stack backtrace)\n"),
        0],
       caml_string_of_jsbytes
        ("(Program not linked with -g, cannot print stack backtrace)\n")],
     _dl_=caml_string_of_jsbytes("Raised at"),
     _dm_=caml_string_of_jsbytes("Re-raised at"),
     _dn_=caml_string_of_jsbytes("Raised by primitive operation at"),
     _do_=caml_string_of_jsbytes("Called from"),
     _dp_=caml_string_of_jsbytes(" (inlined)"),
     _dr_=caml_string_of_jsbytes(""),
     _dq_=
      [0,
       [2,
        0,
        [12,
         32,
         [2,
          0,
          [11,
           caml_string_of_jsbytes(' in file "'),
           [2,
            0,
            [12,
             34,
             [2,
              0,
              [11,
               caml_string_of_jsbytes(", line "),
               [4,0,0,0,[11,caml_string_of_jsbytes(", characters "),partial]]]]]]]]]],
       caml_string_of_jsbytes
        ('%s %s in file "%s"%s, line %d, characters %d-%d')],
     _ds_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(" unknown location"),0]],
       caml_string_of_jsbytes("%s unknown location")],
     _dg_=caml_string_of_jsbytes("Out of memory"),
     _dh_=caml_string_of_jsbytes("Stack overflow"),
     _di_=caml_string_of_jsbytes("Pattern matching failed"),
     _dj_=caml_string_of_jsbytes("Assertion failed"),
     _dk_=caml_string_of_jsbytes("Undefined recursive module"),
     _dc_=[0,[12,40,[2,0,[2,0,[12,41,0]]]],caml_string_of_jsbytes("(%s%s)")],
     _dd_=caml_string_of_jsbytes(""),
     _de_=caml_string_of_jsbytes(""),
     _df_=[0,[12,40,[2,0,[12,41,0]]],caml_string_of_jsbytes("(%s)")],
     _c$_=[0,[4,0,0,0,0],caml_string_of_jsbytes("%d")],
     _c9_=[0,[3,0,0],caml_string_of_jsbytes("%S")],
     _c__=caml_string_of_jsbytes("_"),
     _dv_=
      [0,
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file not found)"),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file appears to be corrupt)"),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file has wrong magic number)"),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file cannot be opened;\n -- too many open files. Try running with OCAMLRUNPARAM=b=2)")],
     _dC_=caml_string_of_jsbytes("Fun.Finally_raised: "),
     _dA_=caml_string_of_jsbytes("Stdlib.Fun.Finally_raised"),
     _dE_=caml_string_of_jsbytes("x"),
     _dK_=caml_string_of_jsbytes("Hashtbl: unsupported hash table format"),
     _dJ_=[0,0],
     _dI_=[0,caml_string_of_jsbytes("hashtbl.ml"),102,23],
     _wK_=caml_string_of_jsbytes("OCAMLRUNPARAM"),
     _wI_=caml_string_of_jsbytes("CAMLRUNPARAM"),
     _dF_=caml_string_of_jsbytes(""),
     _dR_=caml_string_of_jsbytes("Weak.Make: hash bucket cannot grow more"),
     _dQ_=caml_string_of_jsbytes("Weak.blit"),
     _dP_=caml_string_of_jsbytes("Weak.check"),
     _dO_=caml_string_of_jsbytes("Weak.get_copy"),
     _dN_=caml_string_of_jsbytes("Weak.get"),
     _dM_=caml_string_of_jsbytes("Weak.set"),
     _dL_=caml_string_of_jsbytes("Weak.create"),
     _eb_=[3,0,3],
     _ec_=caml_string_of_jsbytes("."),
     _d__=caml_string_of_jsbytes(">"),
     _d$_=caml_string_of_jsbytes("<\/"),
     _ea_=caml_string_of_jsbytes(""),
     _d7_=caml_string_of_jsbytes(">"),
     _d8_=caml_string_of_jsbytes("<"),
     _d9_=caml_string_of_jsbytes(""),
     _d4_=caml_string_of_jsbytes("\n"),
     _d0_=caml_string_of_jsbytes(""),
     _d1_=caml_string_of_jsbytes(""),
     _d2_=caml_string_of_jsbytes(""),
     _d3_=caml_string_of_jsbytes(""),
     _dZ_=[0,caml_string_of_jsbytes("")],
     _dV_=caml_string_of_jsbytes(""),
     _dW_=caml_string_of_jsbytes(""),
     _dX_=caml_string_of_jsbytes(""),
     _dY_=caml_string_of_jsbytes(""),
     _dU_=[0,caml_string_of_jsbytes(""),0,caml_string_of_jsbytes("")],
     _dT_=caml_string_of_jsbytes(""),
     _dS_=caml_string_of_jsbytes("Stdlib.Format.String_tag"),
     _eN_=[0,91],
     _eM_=[0,123],
     _eO_=caml_string_of_jsbytes("end of input not found"),
     _eP_=caml_string_of_jsbytes('scanf: bad conversion "%a"'),
     _eQ_=caml_string_of_jsbytes('scanf: bad conversion "%t"'),
     _eR_=caml_string_of_jsbytes("scanf: missing reader"),
     _eS_=[0,caml_string_of_jsbytes("scanf.ml"),1453,13],
     _eT_=
      caml_string_of_jsbytes('scanf: bad conversion "%?" (custom converter)'),
     _eU_=caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     _eV_=caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     _eW_=caml_string_of_jsbytes('scanf: bad conversion "%-"'),
     _eX_=caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     _eY_=caml_string_of_jsbytes('"'),
     _eZ_=caml_string_of_jsbytes(' in format "'),
     _eL_=[0,37,caml_string_of_jsbytes("")],
     _eK_=
      [0,
       [11,
        caml_string_of_jsbytes("scanf: bad input at char number "),
        [4,3,0,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]]],
       caml_string_of_jsbytes("scanf: bad input at char number %i: %s")],
     _eJ_=
      [0,
       [11,
        caml_string_of_jsbytes("the character "),
        [1,[11,caml_string_of_jsbytes(" cannot start a boolean"),0]]],
       caml_string_of_jsbytes("the character %C cannot start a boolean")],
     _eG_=
      [0,
       [11,
        caml_string_of_jsbytes("bad character hexadecimal encoding \\"),
        [0,[0,0]]],
       caml_string_of_jsbytes("bad character hexadecimal encoding \\%c%c")],
     _eF_=
      [0,
       [11,
        caml_string_of_jsbytes("bad character decimal encoding \\"),
        [0,[0,[0,0]]]],
       caml_string_of_jsbytes("bad character decimal encoding \\%c%c%c")],
     _eC_=caml_string_of_jsbytes("an"),
     _eE_=caml_string_of_jsbytes("x"),
     _eD_=caml_string_of_jsbytes("nfinity"),
     _ex_=caml_string_of_jsbytes("digits"),
     _ey_=
      [0,
       [11,
        caml_string_of_jsbytes("character "),
        [1,
         [11,
          caml_string_of_jsbytes(" is not a valid "),
          [2,0,[11,caml_string_of_jsbytes(" digit"),0]]]]],
       caml_string_of_jsbytes("character %C is not a valid %s digit")],
     _ev_=caml_string_of_jsbytes("decimal digits"),
     _ew_=
      [0,
       [11,
        caml_string_of_jsbytes("character "),
        [1,[11,caml_string_of_jsbytes(" is not a decimal digit"),0]]],
       caml_string_of_jsbytes("character %C is not a decimal digit")],
     _er_=caml_string_of_jsbytes("0b"),
     _es_=caml_string_of_jsbytes("0o"),
     _et_=caml_string_of_jsbytes("0u"),
     _eu_=caml_string_of_jsbytes("0x"),
     _eq_=[0,caml_string_of_jsbytes("scanf.ml"),555,9],
     _en_=caml_string_of_jsbytes("false"),
     _eo_=caml_string_of_jsbytes("true"),
     _ep_=
      [0,
       [11,caml_string_of_jsbytes("invalid boolean '"),[2,0,[12,39,0]]],
       caml_string_of_jsbytes("invalid boolean '%s'")],
     _em_=
      [0,
       [11,
        caml_string_of_jsbytes("looking for "),
        [1,[11,caml_string_of_jsbytes(", found "),[1,0]]]],
       caml_string_of_jsbytes("looking for %C, found %C")],
     _el_=caml_string_of_jsbytes("not a valid float in hexadecimal notation"),
     _ek_=
      caml_string_of_jsbytes("no dot or exponent part found in float token"),
     _ej_=
      [0,
       [11,
        caml_string_of_jsbytes("scanning of "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes
           (" failed: premature end of file occurred before end of token"),
          0]]],
       caml_string_of_jsbytes
        ("scanning of %s failed: premature end of file occurred before end of token")],
     _ei_=
      [0,
       [11,
        caml_string_of_jsbytes("scanning of "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes
           (" failed: the specified length was too short for token"),
          0]]],
       caml_string_of_jsbytes
        ("scanning of %s failed: the specified length was too short for token")],
     _eh_=
      [0,
       [11,caml_string_of_jsbytes("illegal escape character "),[1,0]],
       caml_string_of_jsbytes("illegal escape character %C")],
     _ee_=caml_string_of_jsbytes("-"),
     _eg_=caml_string_of_jsbytes("Stdlib.Scanf.Scan_failure"),
     _ez_=caml_string_of_jsbytes("binary"),
     _eA_=caml_string_of_jsbytes("octal"),
     _eB_=caml_string_of_jsbytes("hexadecimal"),
     _eH_=caml_string_of_jsbytes("a Char"),
     _eI_=caml_string_of_jsbytes("a String"),
     _e0_=caml_string_of_jsbytes(""),
     _wH_=caml_string_of_jsbytes("TMPDIR"),
     _wG_=caml_string_of_jsbytes("TEMP"),
     _e1_=caml_string_of_jsbytes("Cygwin"),
     _e2_=caml_string_of_jsbytes("Win32"),
     _fp_=
      [0,
       [11,
        caml_string_of_jsbytes("Handling error in state "),
        [4,0,0,0,[12,10,[10,0]]]],
       caml_string_of_jsbytes("Handling error in state %d\n%!")],
     _fo_=
      [0,
       [11,caml_string_of_jsbytes("Resuming error handling\n"),[10,0]],
       caml_string_of_jsbytes("Resuming error handling\n%!")],
     _fn_=
      [0,
       [11,caml_string_of_jsbytes("Initiating error handling\n"),[10,0]],
       caml_string_of_jsbytes("Initiating error handling\n%!")],
     _fm_=
      [0,
       [11,
        caml_string_of_jsbytes("Lookahead token is now "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" ("),
          [4,
           0,
           0,
           0,
           [12,45,[4,0,0,0,[11,caml_string_of_jsbytes(")\n"),[10,0]]]]]]]],
       caml_string_of_jsbytes("Lookahead token is now %s (%d-%d)\n%!")],
     _fl_=[0,[2,0,[12,10,[10,0]]],caml_string_of_jsbytes("%s\n%!")],
     _fk_=
      [0,
       [11,
        caml_string_of_jsbytes("Shifting ("),
        [2,
         0,
         [11,caml_string_of_jsbytes(") to state "),[4,0,0,0,[12,10,[10,0]]]]]],
       caml_string_of_jsbytes("Shifting (%s) to state %d\n%!")],
     _fj_=
      [0,
       [11,
        caml_string_of_jsbytes("State "),
        [4,0,0,0,[11,caml_string_of_jsbytes(":\n"),[10,0]]]],
       caml_string_of_jsbytes("State %d:\n%!")],
     _fi_=[0,caml_string_of_jsbytes("lib/pack/menhirLib.ml"),3634,4],
     _fh_=[0,caml_string_of_jsbytes("lib/pack/menhirLib.ml"),3619,8],
     _fg_=[0,caml_string_of_jsbytes("lib/pack/menhirLib.ml"),3573,4],
     _ff_=caml_string_of_jsbytes("feed: outgoing transition does not exist"),
     _fe_=[0,caml_string_of_jsbytes("lib/pack/menhirLib.ml"),3385,4],
     _fd_=[0,caml_string_of_jsbytes("lib/pack/menhirLib.ml"),3298,4],
     _fc_=[0,caml_string_of_jsbytes("lib/pack/menhirLib.ml"),3292,4],
     _fb_=[0,caml_string_of_jsbytes("lib/pack/menhirLib.ml"),3273,4],
     _fa_=[0,caml_string_of_jsbytes("lib/pack/menhirLib.ml"),2638,6],
     _e4_=[0,caml_string_of_jsbytes("lib/pack/menhirLib.ml"),1456,4],
     _e5_=[0,caml_string_of_jsbytes("lib/pack/menhirLib.ml"),1471,4],
     _e9_=[0,caml_string_of_jsbytes("lib/pack/menhirLib.ml"),1813,8],
     _e$_=
      caml_string_of_jsbytes
       ("force_reduction: this reduction is not permitted in this state"),
     _e__=[0,caml_string_of_jsbytes("lib/pack/menhirLib.ml"),2001,6],
     _e8_=[0,caml_string_of_jsbytes("lib/pack/menhirLib.ml"),1786,4],
     _e7_=
      caml_string_of_jsbytes
       ("resume expects HandlingError | Shifting | AboutToReduce"),
     _e6_=caml_string_of_jsbytes("offer expects InputNeeded"),
     _e3_=caml_string_of_jsbytes(""),
     _fz_=caml_string_of_jsbytes("E2BIG"),
     _fB_=caml_string_of_jsbytes("EACCES"),
     _fC_=caml_string_of_jsbytes("EAGAIN"),
     _fD_=caml_string_of_jsbytes("EBADF"),
     _fE_=caml_string_of_jsbytes("EBUSY"),
     _fF_=caml_string_of_jsbytes("ECHILD"),
     _fG_=caml_string_of_jsbytes("EDEADLK"),
     _fH_=caml_string_of_jsbytes("EDOM"),
     _fI_=caml_string_of_jsbytes("EEXIST"),
     _fJ_=caml_string_of_jsbytes("EFAULT"),
     _fK_=caml_string_of_jsbytes("EFBIG"),
     _fL_=caml_string_of_jsbytes("EINTR"),
     _fM_=caml_string_of_jsbytes("EINVAL"),
     _fN_=caml_string_of_jsbytes("EIO"),
     _fO_=caml_string_of_jsbytes("EISDIR"),
     _fP_=caml_string_of_jsbytes("EMFILE"),
     _fQ_=caml_string_of_jsbytes("EMLINK"),
     _fR_=caml_string_of_jsbytes("ENAMETOOLONG"),
     _fS_=caml_string_of_jsbytes("ENFILE"),
     _fT_=caml_string_of_jsbytes("ENODEV"),
     _fU_=caml_string_of_jsbytes("ENOENT"),
     _fV_=caml_string_of_jsbytes("ENOEXEC"),
     _fW_=caml_string_of_jsbytes("ENOLCK"),
     _fX_=caml_string_of_jsbytes("ENOMEM"),
     _fY_=caml_string_of_jsbytes("ENOSPC"),
     _fZ_=caml_string_of_jsbytes("ENOSYS"),
     _f0_=caml_string_of_jsbytes("ENOTDIR"),
     _f1_=caml_string_of_jsbytes("ENOTEMPTY"),
     _f2_=caml_string_of_jsbytes("ENOTTY"),
     _f3_=caml_string_of_jsbytes("ENXIO"),
     _f4_=caml_string_of_jsbytes("EPERM"),
     _f5_=caml_string_of_jsbytes("EPIPE"),
     _f6_=caml_string_of_jsbytes("ERANGE"),
     _f7_=caml_string_of_jsbytes("EROFS"),
     _f8_=caml_string_of_jsbytes("ESPIPE"),
     _f9_=caml_string_of_jsbytes("ESRCH"),
     _f__=caml_string_of_jsbytes("EXDEV"),
     _f$_=caml_string_of_jsbytes("EWOULDBLOCK"),
     _ga_=caml_string_of_jsbytes("EINPROGRESS"),
     _gb_=caml_string_of_jsbytes("EALREADY"),
     _gc_=caml_string_of_jsbytes("ENOTSOCK"),
     _gd_=caml_string_of_jsbytes("EDESTADDRREQ"),
     _ge_=caml_string_of_jsbytes("EMSGSIZE"),
     _gf_=caml_string_of_jsbytes("EPROTOTYPE"),
     _gg_=caml_string_of_jsbytes("ENOPROTOOPT"),
     _gh_=caml_string_of_jsbytes("EPROTONOSUPPORT"),
     _gi_=caml_string_of_jsbytes("ESOCKTNOSUPPORT"),
     _gj_=caml_string_of_jsbytes("EOPNOTSUPP"),
     _gk_=caml_string_of_jsbytes("EPFNOSUPPORT"),
     _gl_=caml_string_of_jsbytes("EAFNOSUPPORT"),
     _gm_=caml_string_of_jsbytes("EADDRINUSE"),
     _gn_=caml_string_of_jsbytes("EADDRNOTAVAIL"),
     _go_=caml_string_of_jsbytes("ENETDOWN"),
     _gp_=caml_string_of_jsbytes("ENETUNREACH"),
     _gq_=caml_string_of_jsbytes("ENETRESET"),
     _gr_=caml_string_of_jsbytes("ECONNABORTED"),
     _gs_=caml_string_of_jsbytes("ECONNRESET"),
     _gt_=caml_string_of_jsbytes("ENOBUFS"),
     _gu_=caml_string_of_jsbytes("EISCONN"),
     _gv_=caml_string_of_jsbytes("ENOTCONN"),
     _gw_=caml_string_of_jsbytes("ESHUTDOWN"),
     _gx_=caml_string_of_jsbytes("ETOOMANYREFS"),
     _gy_=caml_string_of_jsbytes("ETIMEDOUT"),
     _gz_=caml_string_of_jsbytes("ECONNREFUSED"),
     _gA_=caml_string_of_jsbytes("EHOSTDOWN"),
     _gB_=caml_string_of_jsbytes("EHOSTUNREACH"),
     _gC_=caml_string_of_jsbytes("ELOOP"),
     _gD_=caml_string_of_jsbytes("EOVERFLOW"),
     _gE_=
      [0,
       [11,caml_string_of_jsbytes("EUNKNOWNERR "),[4,0,0,0,0]],
       caml_string_of_jsbytes("EUNKNOWNERR %d")],
     _fA_=
      [0,
       [11,
        caml_string_of_jsbytes("Unix.Unix_error(Unix."),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", "),
          [3,0,[11,caml_string_of_jsbytes(", "),[3,0,[12,41,0]]]]]]],
       caml_string_of_jsbytes("Unix.Unix_error(Unix.%s, %S, %S)")],
     _ft_=caml_string_of_jsbytes("Unix.Unix_error"),
     _fu_=caml_string_of_jsbytes(""),
     _fv_=caml_string_of_jsbytes(""),
     _fx_=caml_string_of_jsbytes("Unix.Unix_error"),
     _gF_=caml_string_of_jsbytes("0.0.0.0"),
     _gG_=caml_string_of_jsbytes("127.0.0.1"),
     _wF_=caml_string_of_jsbytes("::"),
     _wE_=caml_string_of_jsbytes("::1"),
     _gN_=caml_string_of_jsbytes("nat_of_int"),
     _gJ_=caml_string_of_jsbytes("make_nat"),
     _gX_=[0,caml_string_of_jsbytes("src/batInnerWeaktbl.mlv"),110,34],
     _gZ_=[0,caml_string_of_jsbytes("src/batInnerWeaktbl.mlv"),155,16],
     _gY_=[0,caml_string_of_jsbytes("src/batInnerWeaktbl.mlv"),154,16],
     _gW_=caml_string_of_jsbytes("Weaktbl.Stack.push: stack cannot grow"),
     _g7_=caml_string_of_jsbytes("BatIO.output"),
     _g6_=caml_string_of_jsbytes("BatIO.input"),
     _g2_=caml_string_of_jsbytes("BatInnerIO.No_more_input"),
     _g3_=caml_string_of_jsbytes("BatInnerIO.Input_closed"),
     _g4_=caml_string_of_jsbytes("BatInnerIO.Output_closed"),
     _hr_=caml_string_of_jsbytes(""),
     _hp_=caml_string_of_jsbytes(""),
     _ho_=caml_string_of_jsbytes(""),
     _hn_=caml_string_of_jsbytes(" "),
     _hm_=caml_string_of_jsbytes("..."),
     _hl_=[0,caml_string_of_jsbytes("src/batEnum.ml"),49,16],
     _hj_=
      [0,
       caml_string_of_jsbytes("next"),
       caml_string_of_jsbytes("count"),
       caml_string_of_jsbytes("clone")],
     _hk_=caml_string_of_jsbytes("BatEnum.No_more_elements"),
     _hv_=[0,caml_string_of_jsbytes("src/batString.mlv"),971,6],
     _hw_=caml_string_of_jsbytes(""),
     _hu_=caml_string_of_jsbytes(""),
     _hs_=caml_string_of_jsbytes(""),
     _ht_=[0,caml_string_of_jsbytes(""),0],
     _hH_=caml_string_of_jsbytes("%"),
     _hI_=caml_string_of_jsbytes(""),
     _hJ_=caml_string_of_jsbytes(""),
     _hM_=caml_string_of_jsbytes('"'),
     _hN_=caml_string_of_jsbytes('"'),
     _hK_=caml_string_of_jsbytes("'"),
     _hL_=caml_string_of_jsbytes("'"),
     _hG_=caml_string_of_jsbytes("%_"),
     _hF_=[0,caml_string_of_jsbytes("src/batPrintf.mlv"),127,8],
     _hD_=caml_string_of_jsbytes("''"),
     _hE_=caml_string_of_jsbytes("printf: premature end of format string ``"),
     _hz_=caml_string_of_jsbytes("''"),
     _hA_=caml_string_of_jsbytes(" in format string ``"),
     _hB_=caml_string_of_jsbytes(", at char number "),
     _hC_=caml_string_of_jsbytes("printf: bad conversion %"),
     _hx_=caml_string_of_jsbytes("index_of_int: negative argument "),
     _hO_=caml_string_of_jsbytes("Option.get"),
     _h5_=caml_string_of_jsbytes(""),
     _h4_=caml_string_of_jsbytes(""),
     _h3_=caml_string_of_jsbytes(""),
     _h2_=caml_string_of_jsbytes(""),
     _hX_=
      [0,
       caml_string_of_jsbytes("flush"),
       caml_string_of_jsbytes("output"),
       caml_string_of_jsbytes("close_out")],
     _hY_=
      [0,
       caml_string_of_jsbytes("output"),
       caml_string_of_jsbytes("flush"),
       caml_string_of_jsbytes("close_out")],
     _h0_=
      [0,caml_string_of_jsbytes("input"),caml_string_of_jsbytes("close_in")],
     _h6_=caml_string_of_jsbytes("pow"),
     _h7_=caml_string_of_jsbytes("BatNumber.Overflow"),
     _h8_=caml_string_of_jsbytes("BatNumber.NaN"),
     _wy_=caml_string_of_jsbytes("0x5555_5555_5555_5555"),
     _wz_=caml_string_of_jsbytes("0x3333_3333_3333_3333"),
     _wA_=caml_string_of_jsbytes("0x0f0f_0f0f_0f0f_0f0f"),
     _iT_=caml_string_of_jsbytes("Set.remove_min_elt"),
     _iX_=[0,0,0,0],
     _iY_=[0,0,0,0],
     _i3_=[0,0,0],
     _iZ_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _i2_=caml_string_of_jsbytes("{"),
     _i1_=caml_string_of_jsbytes("}"),
     _i0_=caml_string_of_jsbytes(","),
     _iV_=
      caml_string_of_jsbytes("Set.at_rank_exn: negative index not allowed"),
     _iW_=caml_string_of_jsbytes("Set.at_rank_exn i s: i >= (Set.cardinal s)"),
     _iP_=caml_string_of_jsbytes("Set.bal"),
     _iQ_=caml_string_of_jsbytes("Set.bal"),
     _iR_=caml_string_of_jsbytes("Set.bal"),
     _iS_=caml_string_of_jsbytes("Set.bal"),
     _iU_=caml_string_of_jsbytes("BatSet.Concrete.Found"),
     _i4_=caml_string_of_jsbytes("List.iter2: list lengths differ"),
     _i5_=caml_string_of_jsbytes("List.fold_left2: list lengths differ"),
     _ja_=[0,0,0],
     _i$_=caml_string_of_jsbytes("BatList.init"),
     _i9_=caml_string_of_jsbytes("List.combine: list lengths differ"),
     _i__=caml_string_of_jsbytes("List.combine: list lengths differ"),
     _i7_=caml_string_of_jsbytes("List.remove_at"),
     _i8_=caml_string_of_jsbytes("List.remove_at"),
     _i6_=caml_string_of_jsbytes("List.for_all2: list lengths differ"),
     _ji_=[0,0,0,0],
     _jo_=[0,caml_string_of_jsbytes("src/batMap.mlv"),739,8],
     _jj_=[0,[15,[2,0,[15,0]]],caml_string_of_jsbytes("%a%s%a")],
     _jn_=caml_string_of_jsbytes("{\n"),
     _jm_=caml_string_of_jsbytes("\n}"),
     _jl_=caml_string_of_jsbytes(",\n"),
     _jk_=caml_string_of_jsbytes(": "),
     _jg_=[0,caml_string_of_jsbytes("src/batMap.mlv"),143,18],
     _jf_=[0,caml_string_of_jsbytes("src/batMap.mlv"),123,17],
     _jb_=caml_string_of_jsbytes("Map.bal"),
     _jc_=caml_string_of_jsbytes("Map.bal"),
     _jd_=caml_string_of_jsbytes("Map.bal"),
     _je_=caml_string_of_jsbytes("Map.bal"),
     _jq_=caml_string_of_jsbytes("BatUChar.Out_of_range"),
     _ju_=[0,caml_string_of_jsbytes("lib/automata.ml"),360,21],
     _js_=[1,0],
     _jN_=[0,caml_string_of_jsbytes("lib/core.ml"),690,4],
     _kN_=caml_string_of_jsbytes("Re.replace"),
     _kO_=caml_string_of_jsbytes("Re.replace"),
     _jP_=caml_string_of_jsbytes("Re.repn"),
     _jQ_=caml_string_of_jsbytes("Re.repn"),
     _jO_=[0,caml_string_of_jsbytes("lib/core.ml"),723,13],
     _jM_=[0,caml_string_of_jsbytes("lib/core.ml"),493,35],
     _jv_=[0,0,0,0,0,0,0,0,0,0,0],
     _jI_=[0,170,[0,181,[0,186,[0,223,[0,255,0]]]]],
     _kb_=caml_string_of_jsbytes("\t "),
     _lK_=caml_string_of_jsbytes(" "),
     _lL_=caml_string_of_jsbytes(" />"),
     _lM_=caml_string_of_jsbytes("<"),
     _lN_=caml_string_of_jsbytes(">"),
     _lO_=caml_string_of_jsbytes("><\/"),
     _lP_=caml_string_of_jsbytes("<"),
     _lQ_=caml_string_of_jsbytes(">"),
     _lR_=caml_string_of_jsbytes("<\/"),
     _lS_=caml_string_of_jsbytes(">"),
     _lT_=caml_string_of_jsbytes("<"),
     _lU_=caml_string_of_jsbytes("-->"),
     _lV_=caml_string_of_jsbytes("<!--"),
     _lW_=caml_string_of_jsbytes(";"),
     _lX_=caml_string_of_jsbytes("&"),
     _lJ_=[0,[2,0,[12,61,[2,0,0]]],caml_string_of_jsbytes("%s=%s")],
     _lF_=[0,[12,34,[2,0,[12,34,0]]],caml_string_of_jsbytes('"%s"')],
     _lG_=[0,[12,34,[4,0,0,0,[12,34,0]]],caml_string_of_jsbytes('"%d"')],
     _lH_=[0,[12,34,[2,0,[12,34,0]]],caml_string_of_jsbytes('"%s"')],
     _lI_=[0,[12,34,[2,0,[12,34,0]]],caml_string_of_jsbytes('"%s"')],
     _lD_=caml_string_of_jsbytes(", "),
     _lE_=caml_string_of_jsbytes(" "),
     _lA_=
      [0,
       [12,
        60,
        [16,
         [15,
          [12,
           62,
           [16,
            [15,[16,[16,[11,caml_string_of_jsbytes("<\/"),[2,0,partial$0]]]]]]]]]],
       caml_string_of_jsbytes("<%t%a>%t%a%t%t<\/%s>")],
     _lB_=
      [0,
       [11,
        caml_string_of_jsbytes("<!--"),
        [2,0,[11,caml_string_of_jsbytes("-->"),0]]],
       caml_string_of_jsbytes("<!--%s-->")],
     _lC_=[0,[12,38,[2,0,[12,59,0]]],caml_string_of_jsbytes("&%s;")],
     _ly_=
      [0,
       [12,60,[15,[11,caml_string_of_jsbytes("/>"),0]]],
       caml_string_of_jsbytes("<%a/>")],
     _lz_=
      [0,
       [12,
        60,
        [15,[12,62,[16,[11,caml_string_of_jsbytes("<\/"),[2,0,[12,62,0]]]]]]],
       caml_string_of_jsbytes("<%a>%t<\/%s>")],
     _lx_=[0,[2,0,[15,[16,0]]],caml_string_of_jsbytes("%s%a%t")],
     _lw_=[0,[16,[2,0,[12,61,[15,0]]]],caml_string_of_jsbytes("%t%s=%a")],
     _ls_=[0,[12,34,[15,[12,34,0]]],caml_string_of_jsbytes('"%a"')],
     _lt_=[0,[12,34,[4,0,0,0,[12,34,0]]],caml_string_of_jsbytes('"%d"')],
     _lu_=[0,[12,34,[2,0,[12,34,0]]],caml_string_of_jsbytes('"%s"')],
     _lv_=[0,[12,34,[15,[12,34,0]]],caml_string_of_jsbytes('"%a"')],
     _lr_=[0,[12,44,[16,0]],caml_string_of_jsbytes(",%t")],
     _lq_=
      [0,
       [18,[1,[0,0,caml_string_of_jsbytes("")]],[15,[17,0,0]]],
       caml_string_of_jsbytes("@[%a@]")],
     _lp_=caml_string_of_jsbytes(" "),
     _lo_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _lk_=[0,[4,0,0,0,[12,101,[4,0,0,0,0]]],caml_string_of_jsbytes("%de%d")],
     _lh_=caml_string_of_jsbytes("Infinity"),
     _li_=caml_string_of_jsbytes("-Infinity"),
     _lj_=caml_string_of_jsbytes("NaN"),
     _ll_=[0,[8,[0,0,3],0,[0,12],0],caml_string_of_jsbytes("%.12g")],
     _lm_=[0,[8,[0,0,3],0,[0,15],0],caml_string_of_jsbytes("%.15g")],
     _ln_=[0,[8,[0,0,3],0,[0,18],0],caml_string_of_jsbytes("%.18g")],
     _k__=caml_string_of_jsbytes("--!>"),
     _k$_=caml_string_of_jsbytes("-->"),
     _la_=caml_string_of_jsbytes("->"),
     _lb_=caml_string_of_jsbytes(">"),
     _lc_=caml_string_of_jsbytes("&gt;"),
     _ld_=caml_string_of_jsbytes("-&gt;"),
     _le_=caml_string_of_jsbytes("--&gt;"),
     _lf_=caml_string_of_jsbytes("--!&gt;"),
     _lg_=[0,1],
     _kT_=caml_string_of_jsbytes("&lt;"),
     _kU_=caml_string_of_jsbytes("&gt;"),
     _kV_=caml_string_of_jsbytes("&amp;"),
     _kQ_=caml_string_of_jsbytes("&quot;"),
     _kR_=caml_string_of_jsbytes("&#"),
     _kS_=caml_string_of_jsbytes(";"),
     _kX_=caml_string_of_jsbytes("--!>"),
     _kZ_=caml_string_of_jsbytes("-->"),
     _k2_=caml_string_of_jsbytes("->"),
     _k6_=caml_string_of_jsbytes(">"),
     _l1_=caml_string_of_jsbytes(""),
     _l2_=[0,1],
     _l3_=
      [0,
       [12,10,[2,0,[12,10,[2,0,[12,10,[2,0,[12,10,0]]]]]]],
       caml_string_of_jsbytes("\n%s\n%s\n%s\n")],
     _lZ_=caml_string_of_jsbytes("]]>"),
     _l4_=caml_string_of_jsbytes("]]>"),
     _l5_=caml_string_of_jsbytes("<![CDATA["),
     _l6_=caml_string_of_jsbytes("//]]>"),
     _l7_=caml_string_of_jsbytes("//<![CDATA["),
     _l8_=caml_string_of_jsbytes("/* ]]> */"),
     _l9_=caml_string_of_jsbytes("/* <![CDATA[ */"),
     _mn_=[0,0],
     _mo_=[0,1],
     _ml_=[0,0],
     _mm_=[0,0],
     _md_=caml_string_of_jsbytes("Fatal error: exception "),
     _me_=caml_string_of_jsbytes("Lwt.Resolution_loop.Canceled"),
     _m__=caml_string_of_jsbytes("[ocamlgraph] fold_pred_e"),
     _m9_=caml_string_of_jsbytes("[ocamlgraph] iter_pred_e"),
     _m8_=caml_string_of_jsbytes("[ocamlgraph] in_degree"),
     _m7_=caml_string_of_jsbytes("[ocamlgraph] fold_pred"),
     _m6_=caml_string_of_jsbytes("[ocamlgraph] iter_pred"),
     _m5_=caml_string_of_jsbytes("[ocamlgraph] fold_succ_e"),
     _m4_=caml_string_of_jsbytes("[ocamlgraph] iter_succ_e"),
     _m3_=caml_string_of_jsbytes("[ocamlgraph] fold_succ"),
     _m2_=caml_string_of_jsbytes("[ocamlgraph] iter_succ"),
     _m0_=caml_string_of_jsbytes("[ocamlgraph] remove_edge_e"),
     _m1_=caml_string_of_jsbytes("[ocamlgraph] remove_edge_e"),
     _mY_=caml_string_of_jsbytes("[ocamlgraph] remove_edge"),
     _mZ_=caml_string_of_jsbytes("[ocamlgraph] remove_edge"),
     _mX_=
      caml_string_of_jsbytes
       ("Graph__Blocks.BidirectionalLabeled(V)(E)(HM).Found"),
     _mW_=caml_string_of_jsbytes("[ocamlgraph] in_degree"),
     _mV_=caml_string_of_jsbytes("[ocamlgraph] pred"),
     _mU_=caml_string_of_jsbytes("[ocamlgraph] fold_pred"),
     _mT_=caml_string_of_jsbytes("[ocamlgraph] iter_pred"),
     _mS_=caml_string_of_jsbytes("[ocamlgraph] succ"),
     _mR_=caml_string_of_jsbytes("[ocamlgraph] fold_succ"),
     _mQ_=caml_string_of_jsbytes("[ocamlgraph] iter_succ"),
     _mP_=caml_string_of_jsbytes("[ocamlgraph] remove_edge"),
     _mO_=caml_string_of_jsbytes("[ocamlgraph] out_degree"),
     _mN_=[0,caml_string_of_jsbytes("src/blocks.ml"),474,8],
     _mM_=caml_string_of_jsbytes("[ocamlgraph] fold_succ_e"),
     _mL_=caml_string_of_jsbytes("[ocamlgraph] iter_succ_e"),
     _mK_=caml_string_of_jsbytes("[ocamlgraph] fold_succ"),
     _mJ_=caml_string_of_jsbytes("[ocamlgraph] iter_succ"),
     _mH_=caml_string_of_jsbytes("[ocamlgraph] remove_edge_e"),
     _mI_=caml_string_of_jsbytes("[ocamlgraph] remove_edge_e"),
     _mF_=caml_string_of_jsbytes("[ocamlgraph] remove_edge"),
     _mG_=caml_string_of_jsbytes("[ocamlgraph] remove_edge"),
     _mE_=caml_string_of_jsbytes("Graph__Blocks.Labeled(V)(E)(HM).Found"),
     _mD_=caml_string_of_jsbytes("[ocamlgraph] succ"),
     _mC_=caml_string_of_jsbytes("[ocamlgraph] fold_succ"),
     _mB_=caml_string_of_jsbytes("[ocamlgraph] iter_succ"),
     _mz_=caml_string_of_jsbytes("[ocamlgraph] remove_edge"),
     _mA_=caml_string_of_jsbytes("[ocamlgraph] remove_edge"),
     _my_=caml_string_of_jsbytes("[ocamlgraph] fold_pred_e"),
     _mx_=caml_string_of_jsbytes("[ocamlgraph] iter_pred_e"),
     _mw_=caml_string_of_jsbytes("[ocamlgraph] in_degree"),
     _mv_=caml_string_of_jsbytes("[ocamlgraph] fold_pred"),
     _mu_=caml_string_of_jsbytes("[ocamlgraph] iter_pred"),
     _mt_=caml_string_of_jsbytes("[ocamlgraph] out_degree"),
     _ms_=[0,caml_string_of_jsbytes("src/blocks.ml"),110,16],
     _mr_=[0,caml_string_of_jsbytes("src/blocks.ml"),103,26],
     _na_=caml_string_of_jsbytes("Jsoo_runtime.Error.Exn"),
     _nc_=caml_string_of_jsbytes("jsError"),
     _nF_=caml_string_of_jsbytes(")"),
     _nG_=caml_string_of_jsbytes("("),
     _nE_=caml_string_of_jsbytes("mn"),
     _nD_=caml_string_of_jsbytes("mi"),
     _nC_=caml_string_of_jsbytes("mo"),
     _nB_=caml_string_of_jsbytes("mrow"),
     _nA_=caml_string_of_jsbytes("math"),
     _ny_=caml_string_of_jsbytes("("),
     _nz_=caml_string_of_jsbytes(")"),
     _nx_=caml_string_of_jsbytes("nbsp"),
     _nw_=caml_string_of_jsbytes("span"),
     _nr_=caml_string_of_jsbytes(" "),
     _nv_=caml_string_of_jsbytes(""),
     _ns_=caml_string_of_jsbytes(" "),
     _nu_=caml_string_of_jsbytes(""),
     _nt_=[0,[2,0,[2,0,[2,0,0]]],caml_string_of_jsbytes("%s%s%s")],
     _nq_=[0,[12,40,[2,0,[12,41,0]]],caml_string_of_jsbytes("(%s)")],
     _no_=caml_string_of_jsbytes("; "),
     _nn_=caml_string_of_jsbytes("["),
     _nm_=caml_string_of_jsbytes("]"),
     _nl_=caml_string_of_jsbytes("List.pivoti"),
     _np_=caml_string_of_jsbytes("Engine.Utils.Disposable.Disposed"),
     _nH_=caml_string_of_jsbytes("Engine.Syntax.ParseError"),
     _qA_=caml_string_of_jsbytes("_EQ"),
     _qB_=caml_string_of_jsbytes("_EQ"),
     _qC_=caml_string_of_jsbytes("_EQ"),
     _qG_=caml_string_of_jsbytes("Subst.add [1]"),
     _qF_=caml_string_of_jsbytes("Subst.add [2]"),
     _qH_=[0,caml_string_of_jsbytes("libs/engine/fo.ml"),1890,16],
     _qD_=[0,0],
     _qz_=caml_string_of_jsbytes("Wrong arity for new subexpressions"),
     _qy_=caml_string_of_jsbytes("Wrong arity for new subformulas"),
     _qv_=caml_string_of_jsbytes(""),
     _qu_=caml_string_of_jsbytes("?"),
     _qt_=caml_string_of_jsbytes("x"),
     _on_=caml_string_of_jsbytes("()"),
     _oo_=
      [0,[2,0,[12,123,[4,0,0,0,[12,125,0]]]],caml_string_of_jsbytes("%s{%d}")],
     _oq_=
      [0,
       [11,
        caml_string_of_jsbytes("rec "),
        [2,0,[11,caml_string_of_jsbytes(" . "),[2,0,0]]]],
       caml_string_of_jsbytes("rec %s . %s")],
     _op_=[0,caml_string_of_jsbytes("libs/engine/fo.ml"),411,25],
     _or_=
      [0,[2,0,[12,123,[4,0,0,0,[12,125,0]]]],caml_string_of_jsbytes("%s{%d}")],
     _os_=caml_string_of_jsbytes(", "),
     _ot_=caml_string_of_jsbytes("true"),
     _ou_=caml_string_of_jsbytes("false"),
     _ov_=caml_string_of_jsbytes("_EQ"),
     _ox_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(" = "),[2,0,0]]],
       caml_string_of_jsbytes("%s = %s")],
     _ow_=caml_string_of_jsbytes(", "),
     _oz_=[0,0],
     _oy_=[0,caml_string_of_jsbytes("libs/engine/fo.ml"),449,14],
     _oA_=caml_string_of_jsbytes("forall"),
     _oC_=caml_string_of_jsbytes("exists"),
     _oB_=
      [0,
       [2,
        0,
        [12,
         32,
         [2,
          0,
          [11,
           caml_string_of_jsbytes(" : "),
           [2,0,[11,caml_string_of_jsbytes(" . "),[2,0,0]]]]]]],
       caml_string_of_jsbytes("%s %s : %s . %s")],
     _oD_=caml_string_of_jsbytes("()"),
     _oE_=caml_string_of_jsbytes("nat"),
     _oG_=caml_string_of_jsbytes("\xe2\x84\x95"),
     _oF_=
      [0,[2,0,[12,123,[4,0,0,0,[12,125,0]]]],caml_string_of_jsbytes("%s{%d}")],
     _oI_=
      [0,
       [11,
        caml_string_of_jsbytes("rec "),
        [2,0,[11,caml_string_of_jsbytes(" . "),[2,0,0]]]],
       caml_string_of_jsbytes("rec %s . %s")],
     _oH_=[0,caml_string_of_jsbytes("libs/engine/fo.ml"),504,25],
     _oY_=caml_string_of_jsbytes("S"),
     _oZ_=caml_string_of_jsbytes("Z"),
     _oX_=caml_string_of_jsbytes("\xe2\x8a\x95"),
     _oJ_=
      [0,[2,0,[12,123,[4,0,0,0,[12,125,0]]]],caml_string_of_jsbytes("%s{%d}")],
     _oK_=caml_string_of_jsbytes("S"),
     _oL_=caml_string_of_jsbytes("Z"),
     _oM_=caml_string_of_jsbytes("add"),
     _oN_=caml_string_of_jsbytes("mult"),
     _oP_=caml_string_of_jsbytes("S"),
     _oQ_=caml_string_of_jsbytes("Z"),
     _oR_=caml_string_of_jsbytes("add"),
     _oS_=caml_string_of_jsbytes("mult"),
     _oU_=caml_string_of_jsbytes("\xe2\x8b\x85"),
     _oV_=caml_string_of_jsbytes("+"),
     _oW_=caml_string_of_jsbytes("0"),
     _oT_=[0,caml_string_of_jsbytes("libs/engine/fo.ml"),547,14],
     _oO_=caml_string_of_jsbytes(", "),
     _o0_=caml_string_of_jsbytes("_EQ"),
     _o2_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(" = "),[2,0,0]]],
       caml_string_of_jsbytes("%s = %s")],
     _o1_=caml_string_of_jsbytes(", "),
     _o5_=caml_string_of_jsbytes("_EQ"),
     _o4_=[0,0],
     _o3_=[0,caml_string_of_jsbytes("libs/engine/fo.ml"),580,14],
     _o6_=
      [0,
       [2,
        0,
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" : "),
          [2,0,[11,caml_string_of_jsbytes(" . "),[2,0,0]]]]]],
       caml_string_of_jsbytes("%s%s : %s . %s")],
     _o7_=caml_string_of_jsbytes("()"),
     _o8_=caml_string_of_jsbytes("nat"),
     _o__=caml_string_of_jsbytes("\xe2\x84\x95"),
     _o9_=
      [0,[2,0,[12,123,[4,0,0,0,[12,125,0]]]],caml_string_of_jsbytes("%s{%d}")],
     _pa_=caml_string_of_jsbytes("."),
     _pb_=caml_string_of_jsbytes("rec"),
     _pc_=caml_string_of_jsbytes("nbsp"),
     _o$_=[0,caml_string_of_jsbytes("libs/engine/fo.ml"),635,27],
     _px_=caml_string_of_jsbytes("S"),
     _py_=caml_string_of_jsbytes("Z"),
     _pw_=caml_string_of_jsbytes("\xe2\x8a\x95"),
     _pf_=caml_string_of_jsbytes("id"),
     _pe_=[0,[2,0,[12,58,[2,0,0]]],caml_string_of_jsbytes("%s:%s")],
     _pd_=caml_string_of_jsbytes("/"),
     _pg_=
      [0,[2,0,[12,123,[4,0,0,0,[12,125,0]]]],caml_string_of_jsbytes("%s{%d}")],
     _ph_=caml_string_of_jsbytes("S"),
     _pi_=caml_string_of_jsbytes("Z"),
     _pj_=caml_string_of_jsbytes("add"),
     _pk_=caml_string_of_jsbytes("mult"),
     _po_=caml_string_of_jsbytes("S"),
     _pp_=caml_string_of_jsbytes("Z"),
     _pq_=caml_string_of_jsbytes("add"),
     _pr_=caml_string_of_jsbytes("mult"),
     _pt_=caml_string_of_jsbytes("\xe2\x8b\x85"),
     _pu_=caml_string_of_jsbytes("+"),
     _pv_=caml_string_of_jsbytes("0"),
     _ps_=[0,caml_string_of_jsbytes("libs/engine/fo.ml"),704,16],
     _pl_=caml_string_of_jsbytes("nbsp"),
     _pm_=caml_string_of_jsbytes(","),
     _pn_=caml_string_of_jsbytes("nbsp"),
     _pB_=caml_string_of_jsbytes("id"),
     _pA_=[0,[2,0,[12,58,[2,0,0]]],caml_string_of_jsbytes("%s:%s")],
     _pz_=caml_string_of_jsbytes("/"),
     _pC_=caml_string_of_jsbytes("#x22A4"),
     _pD_=caml_string_of_jsbytes("#x22A5"),
     _pE_=caml_string_of_jsbytes("_EQ"),
     _pI_=caml_string_of_jsbytes("nbsp"),
     _pJ_=caml_string_of_jsbytes("="),
     _pK_=caml_string_of_jsbytes("nbsp"),
     _pF_=caml_string_of_jsbytes("nbsp"),
     _pG_=caml_string_of_jsbytes(","),
     _pH_=caml_string_of_jsbytes("nbsp"),
     _pO_=caml_string_of_jsbytes("_EQ"),
     _pP_=caml_string_of_jsbytes("nbsp"),
     _pQ_=caml_string_of_jsbytes("#x2260"),
     _pR_=caml_string_of_jsbytes("nbsp"),
     _pL_=
      [0,
       [11,caml_string_of_jsbytes("#x"),[4,6,0,0,0]],
       caml_string_of_jsbytes("#x%x")],
     _pN_=[0,0],
     _pM_=[0,caml_string_of_jsbytes("libs/engine/fo.ml"),761,16],
     _pS_=caml_string_of_jsbytes("."),
     _pT_=caml_string_of_jsbytes(":"),
     _pU_=caml_string_of_jsbytes("nbsp"),
     _pV_=caml_string_of_jsbytes("nat"),
     _pX_=caml_string_of_jsbytes("\xe2\x84\x95"),
     _pW_=
      [0,[2,0,[12,123,[4,0,0,0,[12,125,0]]]],caml_string_of_jsbytes("%s{%d}")],
     _pZ_=caml_string_of_jsbytes("."),
     _pY_=[0,caml_string_of_jsbytes("libs/engine/fo.ml"),833,27],
     _p1_=[0,[2,0,[12,58,[2,0,0]]],caml_string_of_jsbytes("%s:%s")],
     _p0_=caml_string_of_jsbytes("/"),
     _qh_=caml_string_of_jsbytes("S"),
     _qi_=caml_string_of_jsbytes("Z"),
     _qg_=caml_string_of_jsbytes("\xe2\x8a\x95"),
     _p3_=
      [0,[2,0,[12,123,[4,0,0,0,[12,125,0]]]],caml_string_of_jsbytes("%s{%d}")],
     _p4_=caml_string_of_jsbytes("S"),
     _p5_=caml_string_of_jsbytes("Z"),
     _p6_=caml_string_of_jsbytes("add"),
     _p7_=caml_string_of_jsbytes("mult"),
     _p9_=caml_string_of_jsbytes("S"),
     _p__=caml_string_of_jsbytes("Z"),
     _p$_=caml_string_of_jsbytes("add"),
     _qa_=caml_string_of_jsbytes("mult"),
     _qc_=caml_string_of_jsbytes("\xc3\x97"),
     _qd_=caml_string_of_jsbytes("+"),
     _qe_=caml_string_of_jsbytes("0"),
     _qf_=[0,caml_string_of_jsbytes("libs/engine/fo.ml"),882,20],
     _qb_=[0,caml_string_of_jsbytes("libs/engine/fo.ml"),889,16],
     _p8_=caml_string_of_jsbytes(","),
     _p2_=caml_string_of_jsbytes("id"),
     _ql_=caml_string_of_jsbytes("id"),
     _qk_=[0,[2,0,[12,58,[2,0,0]]],caml_string_of_jsbytes("%s:%s")],
     _qj_=caml_string_of_jsbytes("/"),
     _qm_=caml_string_of_jsbytes("_EQ"),
     _qo_=caml_string_of_jsbytes("="),
     _qn_=caml_string_of_jsbytes(","),
     _qq_=caml_string_of_jsbytes("_EQ"),
     _qp_=[0,caml_string_of_jsbytes("libs/engine/fo.ml"),950,16],
     _qr_=caml_string_of_jsbytes("."),
     _qs_=caml_string_of_jsbytes(":"),
     _oj_=caml_string_of_jsbytes("<->"),
     _ok_=caml_string_of_jsbytes("~"),
     _ol_=caml_string_of_jsbytes("->"),
     _om_=caml_string_of_jsbytes("||"),
     _oi_=caml_string_of_jsbytes("&&"),
     _od_=caml_string_of_jsbytes("S"),
     _oe_=caml_string_of_jsbytes("Z"),
     _of_=caml_string_of_jsbytes("add"),
     _og_=caml_string_of_jsbytes("mult"),
     _oh_=[0,caml_string_of_jsbytes("libs/engine/fo.ml"),374,16],
     _n5_=caml_string_of_jsbytes("S"),
     _n6_=caml_string_of_jsbytes("Z"),
     _n7_=caml_string_of_jsbytes("add"),
     _n8_=caml_string_of_jsbytes("mult"),
     _nK_=caml_string_of_jsbytes("S"),
     _nJ_=caml_string_of_jsbytes("Expected a formula"),
     _nI_=caml_string_of_jsbytes("Expected an expression"),
     _nL_=[0,0,0],
     _nM_=caml_string_of_jsbytes("nat"),
     _nQ_=caml_string_of_jsbytes("Z"),
     _nU_=caml_string_of_jsbytes("S"),
     _nY_=caml_string_of_jsbytes("add"),
     _n2_=caml_string_of_jsbytes("mult"),
     _n4_=caml_string_of_jsbytes("Engine.Fo.DuplicatedEntry"),
     _qw_=caml_string_of_jsbytes("Engine.Fo.RecheckFailure"),
     _qx_=caml_string_of_jsbytes("Engine.Fo.TypingError"),
     _qE_=caml_string_of_jsbytes("Engine.Fo.Form.Subst.UnboundVariable"),
     _qI_=caml_string_of_jsbytes("Engine.Fo.Form.Invalid_constant"),
     _sg_=[0,caml_string_of_jsbytes("libs/engine/parser.ml"),3268,12],
     _sh_=[0,[1,0]],
     _si_=[0,[1,1]],
     _sj_=[0,[1,2]],
     _sk_=[0,[1,3]],
     _sl_=[0,[1,4]],
     _sm_=[0,[1,5]],
     _sn_=[0,[1,6]],
     _so_=[0,[1,7]],
     _sp_=[0,[1,8]],
     _sq_=[0,[1,9]],
     _sr_=[0,[1,10]],
     _ss_=[0,[1,11]],
     _st_=[0,[1,12]],
     _su_=[0,[1,13]],
     _sv_=[0,[1,14]],
     _sw_=[0,[1,15]],
     _sx_=[0,[1,16]],
     _sy_=[0,[1,17]],
     _sz_=[0,[1,18]],
     _sA_=[0,[1,19]],
     _sB_=[0,[1,20]],
     _sC_=[0,[1,21]],
     _sD_=[0,[1,22]],
     _sE_=[0,[1,23]],
     _sF_=[0,[1,24]],
     _sG_=[0,[1,25]],
     _rN_=[0,caml_string_of_jsbytes("libs/engine/parser.ml"),3210,12],
     _rO_=[0,[0,0]],
     _rP_=[0,[0,1]],
     _rQ_=[0,[0,2]],
     _rR_=[0,[0,3]],
     _rS_=[0,[0,4]],
     _rT_=[0,[0,5]],
     _rU_=[0,[0,6]],
     _rV_=[0,[0,7]],
     _rW_=[0,[0,8]],
     _rX_=[0,[0,9]],
     _rY_=[0,[0,10]],
     _rZ_=[0,[0,11]],
     _r0_=[0,[0,12]],
     _r1_=[0,[0,13]],
     _r2_=[0,[0,14]],
     _r3_=[0,[0,15]],
     _r4_=[0,[0,16]],
     _r5_=[0,[0,17]],
     _r6_=[0,[0,18]],
     _r7_=[0,[0,19]],
     _r8_=[0,[0,20]],
     _r9_=[0,[0,21]],
     _r__=[0,[0,22]],
     _r$_=[0,[0,23]],
     _sa_=[0,[0,24]],
     _sb_=[0,[0,25]],
     _sc_=[0,[0,26]],
     _sd_=[0,[0,27]],
     _se_=[0,[0,28]],
     _sf_=[0,[0,29]],
     _rx_=caml_string_of_jsbytes("_EQ"),
     _qJ_=caml_string_of_jsbytes("Engine.Parser.MenhirBasics.Error"),
     _sP_=
      [0,
       [11,caml_string_of_jsbytes("illegal character: "),[0,0]],
       caml_string_of_jsbytes("illegal character: %c")],
     _sQ_=caml_string_of_jsbytes("Engine.LemmaDB.LemmaNotFound"),
     _u0_=[0,1],
     _u2_=[0,1],
     _u1_=caml_string_of_jsbytes("Cannot handle multiple link actions yet"),
     _uU_=[0,4298439,803493184],
     _uV_=[0,4298439,737453762],
     _uW_=caml_string_of_jsbytes("Fold"),
     _uX_=caml_string_of_jsbytes("Unfold"),
     _uY_=[0,4298439,803493184],
     _uZ_=caml_string_of_jsbytes("Induction"),
     _uT_=caml_string_of_jsbytes("Elim"),
     _uS_=caml_string_of_jsbytes("Hyperlink"),
     _uR_=[0,1],
     _uQ_=[0,1],
     _uP_=[0,4298439,803493184],
     _uO_=[0,4298439,803493184],
     _uN_=caml_string_of_jsbytes("_EQ"),
     _uM_=caml_string_of_jsbytes("_EQ"),
     _uK_=caml_string_of_jsbytes("Expected a formula item"),
     _uL_=[0,481346541,0],
     _uJ_=caml_string_of_jsbytes("_EQ"),
     _uF_=[0,481346541,0],
     _uD_=[0,0,0],
     _uC_=[0,caml_string_of_jsbytes("libs/engine/proof.ml"),2176,19],
     _t9_=[0,1],
     _uu_=caml_string_of_jsbytes("_EQ"),
     _ut_=caml_string_of_jsbytes("_EQ"),
     _uj_=
      caml_string_of_jsbytes
       ("DnD on positive equivalence currently unsupported"),
     _uk_=[0,1,0],
     _ul_=[0,[0,3903731,0,0]],
     _un_=[0,1,0],
     _um_=[0,1,0],
     _up_=[0,1,0],
     _uo_=caml_string_of_jsbytes("empty disjunction"),
     _ui_=[0,1,0],
     _uh_=caml_string_of_jsbytes("empty conjunction"),
     _uq_=[0,1,0],
     _ur_=[0,1,0],
     _us_=[0,caml_string_of_jsbytes("libs/engine/proof.ml"),1918,22],
     _t$_=[0,0,0],
     _t__=[0,0,0],
     _t8_=[0,0,0],
     _ud_=[0,0,0],
     _uc_=caml_string_of_jsbytes("empty conjunction"),
     _ub_=[0,0,0],
     _ua_=caml_string_of_jsbytes("empty disjunction"),
     _ue_=[0,0,0],
     _uf_=[0,caml_string_of_jsbytes("libs/engine/proof.ml"),1985,22],
     _ug_=[0,0,0],
     _uz_=caml_string_of_jsbytes("_EQ"),
     _uw_=[0,[0,3903731,0,0]],
     _ux_=caml_string_of_jsbytes("empty disjunction"),
     _uv_=caml_string_of_jsbytes("empty conjunction"),
     _uy_=[0,caml_string_of_jsbytes("libs/engine/proof.ml"),2112,22],
     _uA_=
      [0,
       [11,caml_string_of_jsbytes("itrace: "),[2,0,0]],
       caml_string_of_jsbytes("itrace: %s")],
     _uB_=[0,0],
     _t5_=caml_string_of_jsbytes("\xe2\x88\x97"),
     _t7_=caml_string_of_jsbytes("\xe2\x8a\xa2"),
     _t6_=
      [0,
       [2,0,[12,32,[2,0,[12,32,[2,0,0]]]]],
       caml_string_of_jsbytes("%s %s %s")],
     _tY_=[0,[12,123,[2,0,[12,125,0]]],caml_string_of_jsbytes("{%s}")],
     _tW_=caml_string_of_jsbytes("\xe2\x86\x90"),
     _t0_=caml_string_of_jsbytes("\xe2\x86\x92"),
     _tX_=caml_string_of_jsbytes(""),
     _tZ_=[0,[2,0,[2,0,0]],caml_string_of_jsbytes("%s%s")],
     _tV_=[0,0],
     _tT_=caml_string_of_jsbytes("Cannot rewrite variable names"),
     _tU_=caml_string_of_jsbytes("Cannot rewrite variable names"),
     _tS_=[0,caml_string_of_jsbytes("libs/engine/proof.ml"),1213,15],
     _tR_=[0,1],
     _tO_=caml_string_of_jsbytes("Cannot modify an abstract definition"),
     _tP_=caml_string_of_jsbytes("Cannot modify an abstract definition"),
     _tN_=[0,caml_string_of_jsbytes("libs/engine/proof.ml"),1170,15],
     _tM_=[0,1],
     _tJ_=[0,4298439,803493184],
     _tK_=[0,4298439,737453762],
     _tH_=
      [0,
       [4,0,0,0,[12,47,[2,0,[17,[2,35],[4,0,0,0,[12,58,[2,0,0]]]]]]],
       caml_string_of_jsbytes("%d/%s@#%d:%s")],
     _tI_=caml_string_of_jsbytes(""),
     _tF_=[0,[12,47,0],caml_string_of_jsbytes("/")],
     _tG_=
      [0,
       [4,0,0,0,[12,47,[2,0,[12,35,[4,0,0,0,[12,58,[15,0]]]]]]],
       caml_string_of_jsbytes("%d/%s#%d:%a")],
     _tA_=[0,4298439,737453762],
     _tB_=[0,4298439,803493184],
     _tw_=[0,-578069685,0],
     _tu_=[0,1,0],
     _tv_=[0,1,0],
     _tq_=caml_string_of_jsbytes("Expected an expression or formula item"),
     _tp_=caml_string_of_jsbytes("Expected a local variable with a body"),
     _to_=caml_string_of_jsbytes("Expected an expression item"),
     _tn_=caml_string_of_jsbytes("Expected a formula item"),
     _th_=caml_string_of_jsbytes("cannot build forward"),
     _td_=caml_string_of_jsbytes("Or-intro-"),
     _s8_=[0,caml_string_of_jsbytes("True-intro"),0],
     _s9_=caml_string_of_jsbytes("_EQ"),
     _s__=[0,caml_string_of_jsbytes("EQ-intro"),0],
     _ta_=[0,caml_string_of_jsbytes("Equiv-intro"),0],
     _tb_=[0,caml_string_of_jsbytes("Not-intro"),0],
     _tc_=[0,caml_string_of_jsbytes("Imp-intro"),0],
     _s$_=[0,caml_string_of_jsbytes("And-intro"),0],
     _te_=[0,caml_string_of_jsbytes("FA-intro"),0],
     _tf_=[0,caml_string_of_jsbytes("Ex-intro"),0],
     _s5_=[0,83,0],
     _s6_=[0,83,0],
     _s3_=[0,[0,0,0],0],
     _s0_=[0,0,0],
     _sZ_=caml_string_of_jsbytes("_EQ"),
     _sU_=[0,caml_string_of_jsbytes("libs/engine/proof.ml"),133,6],
     _sR_=caml_string_of_jsbytes("Engine.Proof.InvalidGoalId"),
     _sS_=caml_string_of_jsbytes("Engine.Proof.InvalidHyphId"),
     _sT_=caml_string_of_jsbytes("Engine.Proof.SubgoalNotOpened"),
     _sV_=caml_string_of_jsbytes("Engine.Proof.TacticNotApplicable"),
     _sW_=caml_string_of_jsbytes("Engine.Proof.CoreLogic.TId"),
     _sX_=caml_string_of_jsbytes("Engine.Proof.CoreLogic.TDef"),
     _sY_=caml_string_of_jsbytes("Engine.Proof.CoreLogic.TIntro"),
     _s1_=caml_string_of_jsbytes("Engine.Proof.CoreLogic.OrDrop"),
     _s2_=caml_string_of_jsbytes("Engine.Proof.CoreLogic.AndDrop"),
     _s4_=caml_string_of_jsbytes("Engine.Proof.CoreLogic.TElim"),
     _s7_=caml_string_of_jsbytes("Engine.Proof.CoreLogic.TInd"),
     _tg_=caml_string_of_jsbytes("Engine.Proof.CoreLogic.TForward"),
     _ti_=caml_string_of_jsbytes("Engine.Proof.CoreLogic.TCut"),
     _tj_=caml_string_of_jsbytes("Engine.Proof.CoreLogic.TAssume"),
     _tk_=caml_string_of_jsbytes("Engine.Proof.CoreLogic.TGeneralize"),
     _tl_=caml_string_of_jsbytes("Engine.Proof.CoreLogic.TMove"),
     _tm_=caml_string_of_jsbytes("Engine.Proof.CoreLogic.TDuplicate"),
     _tr_=caml_string_of_jsbytes("Engine.Proof.CoreLogic.InvalidPath"),
     _ts_=caml_string_of_jsbytes("Engine.Proof.CoreLogic.InvalidSubFormPath"),
     _tt_=caml_string_of_jsbytes("Engine.Proof.CoreLogic.InvalidSubExprPath"),
     _tC_=
      [0,
       [0,3607583,caml_string_of_jsbytes("H")],
       [0,
        [0,-578069685,caml_string_of_jsbytes("C")],
        [0,
         [0,[0,4298439,803493184],caml_string_of_jsbytes("Vh")],
         [0,[0,[0,4298439,737453762],caml_string_of_jsbytes("Vb")],0]]]],
     _tL_=caml_string_of_jsbytes("Engine.Proof.CoreLogic.TRewriteAt"),
     _tQ_=caml_string_of_jsbytes("Engine.Proof.CoreLogic.TRewrite"),
     _t1_=[0,caml_string_of_jsbytes("")],
     _t2_=[0,caml_string_of_jsbytes("")],
     _t3_=[0,caml_string_of_jsbytes(" ")],
     _t4_=caml_string_of_jsbytes("Engine.Proof.CoreLogic.TLink"),
     _wu_=caml_string_of_jsbytes(""),
     _wt_=caml_string_of_jsbytes(""),
     _wq_=[0,caml_string_of_jsbytes(" ")],
     _wr_=[0,caml_string_of_jsbytes("")],
     _ws_=[0,caml_string_of_jsbytes(", ")],
     _wv_=
      [0,
       [2,0,[11,caml_string_of_jsbytes("\xe2\x8a\xa2 "),[2,0,0]]],
       caml_string_of_jsbytes("%s\xe2\x8a\xa2 %s")],
     _wp_=caml_string_of_jsbytes(""),
     _wn_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _wm_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _wl_=caml_string_of_jsbytes(""),
     _wj_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _wi_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _wh_=caml_string_of_jsbytes(""),
     _wd_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _wc_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _wb_=caml_string_of_jsbytes(""),
     _we_=
      [0,
       [4,0,0,0,[11,caml_string_of_jsbytes("/C#0"),0]],
       caml_string_of_jsbytes("%d/C#0")],
     _wf_=
      [0,
       [4,0,0,0,[11,caml_string_of_jsbytes("/H#"),[4,0,0,0,0]]],
       caml_string_of_jsbytes("%d/H#%d")],
     _v7_=caml_string_of_jsbytes(""),
     _v$_=caml_string_of_jsbytes(":"),
     _v8_=caml_string_of_jsbytes("b"),
     _v__=caml_string_of_jsbytes("h"),
     _v9_=
      [0,
       [4,
        0,
        0,
        0,
        [11,caml_string_of_jsbytes("/V"),[2,0,[12,35,[4,0,0,0,[2,0,0]]]]]],
       caml_string_of_jsbytes("%d/V%s#%d%s")],
     _v3_=caml_string_of_jsbytes(":="),
     _v4_=caml_string_of_jsbytes(":"),
     _v5_=caml_string_of_jsbytes("id"),
     _v6_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _vZ_=caml_string_of_jsbytes(":="),
     _v0_=caml_string_of_jsbytes(":"),
     _v1_=caml_string_of_jsbytes("id"),
     _v2_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _vX_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(" : "),
         [2,0,[11,caml_string_of_jsbytes(" := "),[2,0,0]]]]],
       caml_string_of_jsbytes("%s : %s := %s")],
     _vY_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(" : "),[2,0,0]]],
       caml_string_of_jsbytes("%s : %s")],
     _vV_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(" := "),[2,0,0]]],
       caml_string_of_jsbytes("%s := %s")],
     _vW_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(" : "),[2,0,0]]],
       caml_string_of_jsbytes("%s : %s")],
     _vU_=caml_string_of_jsbytes(""),
     _vS_=caml_string_of_jsbytes(""),
     _vN_=[0,caml_string_of_jsbytes("")],
     _vO_=[0,caml_string_of_jsbytes("")],
     _vP_=[0,caml_string_of_jsbytes(" & ")],
     _vQ_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(" : "),
         [2,0,[11,caml_string_of_jsbytes(" -> "),[2,0,0]]]]],
       caml_string_of_jsbytes("%s : %s -> %s")],
     _vK_=caml_string_of_jsbytes(""),
     _vL_=caml_string_of_jsbytes(", "),
     _vG_=[0,caml_string_of_jsbytes("")],
     _vH_=[0,caml_string_of_jsbytes("")],
     _vI_=[0,caml_string_of_jsbytes(", ")],
     _vJ_=caml_string_of_jsbytes(""),
     _vM_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("; "),
         [2,0,[11,caml_string_of_jsbytes(" |- "),[2,0,0]]]]],
       caml_string_of_jsbytes("%s; %s |- %s")],
     _vC_=[0,caml_string_of_jsbytes("")],
     _vD_=[0,caml_string_of_jsbytes("")],
     _vE_=[0,caml_string_of_jsbytes(", ")],
     _vF_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(" \xe2\x8a\xa2 "),[2,0,0]]],
       caml_string_of_jsbytes("%s \xe2\x8a\xa2 %s")],
     _vB_=caml_string_of_jsbytes(""),
     _vv_=caml_string_of_jsbytes("object"),
     _vw_=caml_string_of_jsbytes("string"),
     _vx_=caml_string_of_jsbytes("any"),
     _vy_=caml_string_of_jsbytes("click"),
     _vz_=caml_string_of_jsbytes("dnd"),
     _vu_=caml_string_of_jsbytes("object"),
     _vt_=caml_string_of_jsbytes(""),
     _vr_=
      [0,
       [11,caml_string_of_jsbytes("internal error: "),[2,0,0]],
       caml_string_of_jsbytes("internal error: %s")],
     _vk_=[0,caml_string_of_jsbytes("invalid goal (parse error)")],
     _vl_=caml_string_of_jsbytes('" in goal'),
     _vm_=caml_string_of_jsbytes('duplicated entry "'),
     _vn_=caml_string_of_jsbytes('" does not exist'),
     _vo_=caml_string_of_jsbytes('lemma "'),
     _vq_=[0,caml_string_of_jsbytes("tactic not applicable")],
     _vp_=[0,caml_string_of_jsbytes("invalid goal (type error)")],
     _vi_=caml_string_of_jsbytes("string"),
     _vh_=caml_string_of_jsbytes("Found"),
     _u3_=
      [0,
       caml_string_of_jsbytes("type_"),
       caml_string_of_jsbytes("tostring"),
       caml_string_of_jsbytes("toascii"),
       caml_string_of_jsbytes("setmeta"),
       caml_string_of_jsbytes("proof"),
       caml_string_of_jsbytes("prefix"),
       caml_string_of_jsbytes("position"),
       caml_string_of_jsbytes("parent"),
       caml_string_of_jsbytes("name"),
       caml_string_of_jsbytes("mathml"),
       caml_string_of_jsbytes("idhead"),
       caml_string_of_jsbytes("idbody"),
       caml_string_of_jsbytes("html"),
       caml_string_of_jsbytes("handle"),
       caml_string_of_jsbytes("getmeta"),
       caml_string_of_jsbytes("body")],
     _u4_=
      [0,
       caml_string_of_jsbytes("tostring"),
       caml_string_of_jsbytes("toascii"),
       caml_string_of_jsbytes("prefix"),
       caml_string_of_jsbytes("mathmltag"),
       caml_string_of_jsbytes("mathml"),
       caml_string_of_jsbytes("htmltag"),
       caml_string_of_jsbytes("html")],
     _u5_=
      [0,
       caml_string_of_jsbytes("tvars"),
       caml_string_of_jsbytes("tostring"),
       caml_string_of_jsbytes("toascii"),
       caml_string_of_jsbytes("setmeta"),
       caml_string_of_jsbytes("pvars"),
       caml_string_of_jsbytes("parent"),
       caml_string_of_jsbytes("move_hyp"),
       caml_string_of_jsbytes("ivariants"),
       caml_string_of_jsbytes("intro"),
       caml_string_of_jsbytes("handle"),
       caml_string_of_jsbytes("getmeta"),
       caml_string_of_jsbytes("generalize"),
       caml_string_of_jsbytes("fvars"),
       caml_string_of_jsbytes("elim"),
       caml_string_of_jsbytes("cut"),
       caml_string_of_jsbytes("context"),
       caml_string_of_jsbytes("conclusion"),
       caml_string_of_jsbytes("addlocal"),
       caml_string_of_jsbytes("addlemma"),
       caml_string_of_jsbytes("addalias")],
     _u6_=
      [0,
       caml_string_of_jsbytes("tostring"),
       caml_string_of_jsbytes("rawstring"),
       caml_string_of_jsbytes("rawmathml"),
       caml_string_of_jsbytes("rawhtml"),
       caml_string_of_jsbytes("mathml"),
       caml_string_of_jsbytes("html")],
     _u8_=
      [0,
       caml_string_of_jsbytes("subgoals"),
       caml_string_of_jsbytes("setmeta"),
       caml_string_of_jsbytes("proof"),
       caml_string_of_jsbytes("pactions"),
       caml_string_of_jsbytes("loaddb"),
       caml_string_of_jsbytes("handle"),
       caml_string_of_jsbytes("getmeta"),
       caml_string_of_jsbytes("getdb"),
       caml_string_of_jsbytes("closed"),
       caml_string_of_jsbytes("apply"),
       caml_string_of_jsbytes("actions")],
     _u9_=
      [0,
       caml_string_of_jsbytes("proof"),
       caml_string_of_jsbytes("loaddb"),
       caml_string_of_jsbytes("actions"),
       caml_string_of_jsbytes("pactions"),
       caml_string_of_jsbytes("subgoals"),
       caml_string_of_jsbytes("closed"),
       caml_string_of_jsbytes("getdb"),
       caml_string_of_jsbytes("setmeta"),
       caml_string_of_jsbytes("apply"),
       caml_string_of_jsbytes("getmeta"),
       caml_string_of_jsbytes("handle")],
     _u__=
      [0,
       caml_string_of_jsbytes("html"),
       caml_string_of_jsbytes("htmltag"),
       caml_string_of_jsbytes("toascii"),
       caml_string_of_jsbytes("mathmltag"),
       caml_string_of_jsbytes("tostring"),
       caml_string_of_jsbytes("prefix"),
       caml_string_of_jsbytes("mathml")],
     _u$_=
      [0,
       caml_string_of_jsbytes("tostring"),
       caml_string_of_jsbytes("toascii"),
       caml_string_of_jsbytes("setmeta"),
       caml_string_of_jsbytes("proof"),
       caml_string_of_jsbytes("position"),
       caml_string_of_jsbytes("phandle"),
       caml_string_of_jsbytes("parent"),
       caml_string_of_jsbytes("mathml"),
       caml_string_of_jsbytes("html"),
       caml_string_of_jsbytes("handle"),
       caml_string_of_jsbytes("getmeta"),
       caml_string_of_jsbytes("fresh"),
       caml_string_of_jsbytes("form")],
     _va_=
      [0,
       caml_string_of_jsbytes("body"),
       caml_string_of_jsbytes("html"),
       caml_string_of_jsbytes("proof"),
       caml_string_of_jsbytes("name"),
       caml_string_of_jsbytes("position"),
       caml_string_of_jsbytes("idbody"),
       caml_string_of_jsbytes("idhead"),
       caml_string_of_jsbytes("toascii"),
       caml_string_of_jsbytes("parent"),
       caml_string_of_jsbytes("tostring"),
       caml_string_of_jsbytes("type_"),
       caml_string_of_jsbytes("setmeta"),
       caml_string_of_jsbytes("prefix"),
       caml_string_of_jsbytes("getmeta"),
       caml_string_of_jsbytes("handle"),
       caml_string_of_jsbytes("mathml")],
     _vb_=
      [0,
       caml_string_of_jsbytes("tostring"),
       caml_string_of_jsbytes("mathmltag"),
       caml_string_of_jsbytes("mathml"),
       caml_string_of_jsbytes("htmltag"),
       caml_string_of_jsbytes("html")],
     _vc_=
      [0,
       caml_string_of_jsbytes("html"),
       caml_string_of_jsbytes("htmltag"),
       caml_string_of_jsbytes("mathmltag"),
       caml_string_of_jsbytes("tostring"),
       caml_string_of_jsbytes("mathml")],
     _vd_=
      [0,
       caml_string_of_jsbytes("elim"),
       caml_string_of_jsbytes("generalize"),
       caml_string_of_jsbytes("pvars"),
       caml_string_of_jsbytes("conclusion"),
       caml_string_of_jsbytes("addlemma"),
       caml_string_of_jsbytes("addlocal"),
       caml_string_of_jsbytes("toascii"),
       caml_string_of_jsbytes("parent"),
       caml_string_of_jsbytes("ivariants"),
       caml_string_of_jsbytes("move_hyp"),
       caml_string_of_jsbytes("cut"),
       caml_string_of_jsbytes("tostring"),
       caml_string_of_jsbytes("addalias"),
       caml_string_of_jsbytes("fvars"),
       caml_string_of_jsbytes("tvars"),
       caml_string_of_jsbytes("context"),
       caml_string_of_jsbytes("setmeta"),
       caml_string_of_jsbytes("getmeta"),
       caml_string_of_jsbytes("handle"),
       caml_string_of_jsbytes("intro")],
     _ve_=
      [0,
       caml_string_of_jsbytes("html"),
       caml_string_of_jsbytes("rawstring"),
       caml_string_of_jsbytes("tostring"),
       caml_string_of_jsbytes("rawhtml"),
       caml_string_of_jsbytes("rawmathml"),
       caml_string_of_jsbytes("mathml")],
     _vf_=caml_string_of_jsbytes("Engine.Jsapi.InvalidASource"),
     _vg_=caml_string_of_jsbytes("Engine.Jsapi.InvalidLemmaDB"),
     _ww_=caml_string_of_jsbytes("engine");
    function erase_rel(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,erase_rel(rest)];
         case 1:var rest$0=param[1];return [1,erase_rel(rest$0)];
         case 2:var rest$1=param[1];return [2,erase_rel(rest$1)];
         case 3:var rest$2=param[1];return [3,erase_rel(rest$2)];
         case 4:var rest$3=param[1];return [4,erase_rel(rest$3)];
         case 5:var rest$4=param[1];return [5,erase_rel(rest$4)];
         case 6:var rest$5=param[1];return [6,erase_rel(rest$5)];
         case 7:var rest$6=param[1];return [7,erase_rel(rest$6)];
         case 8:
          var rest$7=param[2],ty=param[1];return [8,ty,erase_rel(rest$7)];
         case 9:
          var rest$8=param[3],ty1=param[1];
          return [9,ty1,ty1,erase_rel(rest$8)];
         case 10:var rest$9=param[1];return [10,erase_rel(rest$9)];
         case 11:var rest$10=param[1];return [11,erase_rel(rest$10)];
         case 12:var rest$11=param[1];return [12,erase_rel(rest$11)];
         case 13:var rest$12=param[1];return [13,erase_rel(rest$12)];
         default:var rest$13=param[1];return [14,erase_rel(rest$13)]}}
    function concat_fmtty(fmtty1,fmtty2)
     {if(typeof fmtty1 === "number")
       return fmtty2;
      else
       switch(fmtty1[0])
        {case 0:var rest=fmtty1[1];return [0,concat_fmtty(rest,fmtty2)];
         case 1:var rest$0=fmtty1[1];return [1,concat_fmtty(rest$0,fmtty2)];
         case 2:var rest$1=fmtty1[1];return [2,concat_fmtty(rest$1,fmtty2)];
         case 3:var rest$2=fmtty1[1];return [3,concat_fmtty(rest$2,fmtty2)];
         case 4:var rest$3=fmtty1[1];return [4,concat_fmtty(rest$3,fmtty2)];
         case 5:var rest$4=fmtty1[1];return [5,concat_fmtty(rest$4,fmtty2)];
         case 6:var rest$5=fmtty1[1];return [6,concat_fmtty(rest$5,fmtty2)];
         case 7:var rest$6=fmtty1[1];return [7,concat_fmtty(rest$6,fmtty2)];
         case 8:
          var rest$7=fmtty1[2],ty=fmtty1[1];
          return [8,ty,concat_fmtty(rest$7,fmtty2)];
         case 9:
          var rest$8=fmtty1[3],ty2=fmtty1[2],ty1=fmtty1[1];
          return [9,ty1,ty2,concat_fmtty(rest$8,fmtty2)];
         case 10:var rest$9=fmtty1[1];return [10,concat_fmtty(rest$9,fmtty2)];
         case 11:
          var rest$10=fmtty1[1];return [11,concat_fmtty(rest$10,fmtty2)];
         case 12:
          var rest$11=fmtty1[1];return [12,concat_fmtty(rest$11,fmtty2)];
         case 13:
          var rest$12=fmtty1[1];return [13,concat_fmtty(rest$12,fmtty2)];
         default:
          var rest$13=fmtty1[1];return [14,concat_fmtty(rest$13,fmtty2)]}}
    function concat_fmt(fmt1,fmt2)
     {if(typeof fmt1 === "number")
       return fmt2;
      else
       switch(fmt1[0])
        {case 0:var rest=fmt1[1];return [0,concat_fmt(rest,fmt2)];
         case 1:var rest$0=fmt1[1];return [1,concat_fmt(rest$0,fmt2)];
         case 2:
          var rest$1=fmt1[2],pad=fmt1[1];
          return [2,pad,concat_fmt(rest$1,fmt2)];
         case 3:
          var rest$2=fmt1[2],pad$0=fmt1[1];
          return [3,pad$0,concat_fmt(rest$2,fmt2)];
         case 4:
          var rest$3=fmt1[4],prec=fmt1[3],pad$1=fmt1[2],iconv=fmt1[1];
          return [4,iconv,pad$1,prec,concat_fmt(rest$3,fmt2)];
         case 5:
          var rest$4=fmt1[4],prec$0=fmt1[3],pad$2=fmt1[2],iconv$0=fmt1[1];
          return [5,iconv$0,pad$2,prec$0,concat_fmt(rest$4,fmt2)];
         case 6:
          var rest$5=fmt1[4],prec$1=fmt1[3],pad$3=fmt1[2],iconv$1=fmt1[1];
          return [6,iconv$1,pad$3,prec$1,concat_fmt(rest$5,fmt2)];
         case 7:
          var rest$6=fmt1[4],prec$2=fmt1[3],pad$4=fmt1[2],iconv$2=fmt1[1];
          return [7,iconv$2,pad$4,prec$2,concat_fmt(rest$6,fmt2)];
         case 8:
          var rest$7=fmt1[4],prec$3=fmt1[3],pad$5=fmt1[2],fconv=fmt1[1];
          return [8,fconv,pad$5,prec$3,concat_fmt(rest$7,fmt2)];
         case 9:
          var rest$8=fmt1[2],pad$6=fmt1[1];
          return [9,pad$6,concat_fmt(rest$8,fmt2)];
         case 10:var rest$9=fmt1[1];return [10,concat_fmt(rest$9,fmt2)];
         case 11:
          var rest$10=fmt1[2],str=fmt1[1];
          return [11,str,concat_fmt(rest$10,fmt2)];
         case 12:
          var rest$11=fmt1[2],chr=fmt1[1];
          return [12,chr,concat_fmt(rest$11,fmt2)];
         case 13:
          var rest$12=fmt1[3],fmtty=fmt1[2],pad$7=fmt1[1];
          return [13,pad$7,fmtty,concat_fmt(rest$12,fmt2)];
         case 14:
          var rest$13=fmt1[3],fmtty$0=fmt1[2],pad$8=fmt1[1];
          return [14,pad$8,fmtty$0,concat_fmt(rest$13,fmt2)];
         case 15:var rest$14=fmt1[1];return [15,concat_fmt(rest$14,fmt2)];
         case 16:var rest$15=fmt1[1];return [16,concat_fmt(rest$15,fmt2)];
         case 17:
          var rest$16=fmt1[2],fmting_lit=fmt1[1];
          return [17,fmting_lit,concat_fmt(rest$16,fmt2)];
         case 18:
          var rest$17=fmt1[2],fmting_gen=fmt1[1];
          return [18,fmting_gen,concat_fmt(rest$17,fmt2)];
         case 19:var rest$18=fmt1[1];return [19,concat_fmt(rest$18,fmt2)];
         case 20:
          var rest$19=fmt1[3],char_set=fmt1[2],width_opt=fmt1[1];
          return [20,width_opt,char_set,concat_fmt(rest$19,fmt2)];
         case 21:
          var rest$20=fmt1[2],counter=fmt1[1];
          return [21,counter,concat_fmt(rest$20,fmt2)];
         case 22:var rest$21=fmt1[1];return [22,concat_fmt(rest$21,fmt2)];
         case 23:
          var rest$22=fmt1[2],ign=fmt1[1];
          return [23,ign,concat_fmt(rest$22,fmt2)];
         default:
          var rest$23=fmt1[3],f=fmt1[2],arity=fmt1[1];
          return [24,arity,f,concat_fmt(rest$23,fmt2)]}}
    function make(v){return [0,v]}
    function get(r){return r[1]}
    function compare_and_set(r,seen,v)
     {var cur=r[1];return cur === seen?(r[1] = v,1):0}
    function failwith(s){throw [0,Failure,s]}
    function invalid_arg(s){throw [0,Invalid_argument,s]}
    var Exit=[248,_a_,caml_fresh_oo_id(0)];
    function min(x,y){return caml_lessequal(x,y)?x:y}
    function max(x,y){return caml_greaterequal(x,y)?x:y}
    function abs(x){return 0 <= x?x:- x | 0}
    function lnot(x){return x ^ -1}
    var
     max_num=2147483647,
     min_num=-2147483648,
     infinity=caml_int64_float_of_bits(_b_),
     neg_infinity=caml_int64_float_of_bits(_c_);
    function cat(s1,s2)
     {var
       l1=caml_ml_string_length(s1),
       l2=caml_ml_string_length(s2),
       _bol_=l1 + l2 | 0,
       s=caml_create_bytes(_bol_);
      caml_blit_string(s1,0,s,0,l1);
      caml_blit_string(s2,0,s,l1,l2);
      return caml_string_of_bytes(s)}
    function char_of_int(n)
     {if(0 <= n && ! (255 < n))return n;return invalid_arg(_d_)}
    function string_of_bool(b){return b?_e_:_f_}
    function to_string(n){return caml_string_of_jsbytes("" + n)}
    function valid_float_lexem(s)
     {var l=caml_ml_string_length(s);
      function loop(i)
       {var i$0=i;
        for(;;)
         {if(l <= i$0)return cat(s,_g_);
          var match=caml_string_get(s,i$0),switch$0=0;
          if(48 <= match)
           {if(! (58 <= match))switch$0 = 1}
          else
           if(45 === match)switch$0 = 1;
          if(switch$0){var i$1=i$0 + 1 | 0,i$0=i$1;continue}
          return s}}
      return loop(0)}
    function to_string$0(f)
     {return valid_float_lexem(caml_format_float(_h_,f))}
    function append(l1,l2)
     {if(l1){var tl=l1[2],hd=l1[1];return [0,hd,append(tl,l2)]}return l2}
    var
     stdin=caml_ml_open_descriptor_in(0),
     stdout=caml_ml_open_descriptor_out(1),
     stderr=caml_ml_open_descriptor_out(2);
    function flush_all(param)
     {function iter(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var l=param$0[2],a=param$0[1];
            try
             {caml_ml_flush(a)}
            catch(_bok_)
             {_bok_ = caml_wrap_exception(_bok_);
              if(_bok_[1] !== Sys_error)throw _bok_;
              var _boj_=_bok_}
            var param$0=l;
            continue}
          return 0}}
      return iter(caml_ml_out_channels_list(0))}
    function output_string(oc,s)
     {var _boi_=caml_ml_string_length(s);return caml_ml_output(oc,s,0,_boi_)}
    function output(oc,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_ml_output_bytes(oc,s,ofs,len);
      return invalid_arg(_i_)}
    function output_substring(oc,s,ofs,len)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_string_length(s) - len | 0) < ofs))
       return caml_ml_output(oc,s,ofs,len);
      return invalid_arg(_j_)}
    function close_out(oc){caml_ml_flush(oc);return caml_ml_close_channel(oc)}
    function input(ic,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_ml_input(ic,s,ofs,len);
      return invalid_arg(_k_)}
    function prerr_char(c){return caml_ml_output_char(stderr,c)}
    function prerr_string(s){return output_string(stderr,s)}
    function prerr_endline(s)
     {output_string(stderr,s);
      caml_ml_output_char(stderr,10);
      return caml_ml_flush(stderr)}
    function unsafe_to_string(param){var str=param[2];return str}
    var exit_function=make(flush_all);
    function at_exit(f)
     {for(;;)
       {var
         _bod_=1,
         f_yet_to_run=make(_bod_),
         old_exit=get(exit_function),
         new_exit$0=
          function(f_yet_to_run,old_exit)
           {function new_exit(param)
             {var _bof_=0,_bog_=1;
              if(compare_and_set(f_yet_to_run,_bog_,_bof_))
               {var _boh_=0;caml_call1(f,_boh_)}
              return caml_call1(old_exit,0)}
            return new_exit},
         new_exit=new_exit$0(f_yet_to_run,old_exit),
         success=compare_and_set(exit_function,old_exit,new_exit),
         _boe_=1 - success;
        if(_boe_)continue;
        return _boe_}}
    function do_at_exit(param)
     {var _boc_=0;return caml_call1(get(exit_function),_boc_)}
    function exit(retcode)
     {var _bob_=0;do_at_exit(_bob_);return caml_sys_exit(retcode)}
    caml_register_named_value
     (caml_string_of_jsbytes("Pervasives.do_at_exit"),do_at_exit);
    function close_in(_boa_){return caml_ml_close_channel(_boa_)}
    function input_char(_bn$_){return caml_ml_input_char(_bn$_)}
    function output_char(_bn__,_bn9_){return caml_ml_output_char(_bn__,_bn9_)}
    function flush(_bn8_){return caml_ml_flush(_bn8_)}
    var
     match=caml_sys_get_config(0),
     os_type$0=match[1],
     max_array_length=caml_sys_const_max_wosize(0),
     max_string_length=(4 * max_array_length | 0) - 1 | 0,
     match$0=32;
    function is_block(a){return 1 - (typeof a === "number"?1:0)}
    var
     max_ephe_length=max_array_length - 2 | 0,
     Undefined=[248,_l_,caml_fresh_oo_id(0)];
    function raise_undefined(param){throw Undefined}
    function force_lazy_block(blk)
     {var _bn3_=0,closure=blk[1 + _bn3_],_bn4_=0;
      blk[1 + _bn4_] = raise_undefined;
      try
       {var _bn7_=0,result=caml_call1(closure,_bn7_);
        caml_obj_make_forward(blk,result);
        return result}
      catch(e)
       {e = caml_wrap_exception(e);
        var _bn5_=function(param){throw e},_bn6_=0;
        blk[1 + _bn6_] = _bn5_;
        throw e}}
    function map(f,seq,param)
     {var _bn0_=0,match=caml_call1(seq,_bn0_);
      if(match)
       {var
         next=match[2],
         x=match[1],
         _bn1_=function(_bn2_){return map(f,next,_bn2_)};
        return [0,caml_call1(f,x),_bn1_]}
      return 0}
    function fold_left(f,acc,seq)
     {var acc$0=acc,seq$0=seq;
      for(;;)
       {var _bnZ_=0,match=caml_call1(seq$0,_bnZ_);
        if(match)
         {var
           next=match[2],
           x=match[1],
           acc$1=caml_call2(f,acc$0,x),
           acc$0=acc$1,
           seq$0=next;
          continue}
        return acc$0}}
    function iter(f,seq)
     {var seq$0=seq;
      for(;;)
       {var _bnY_=0,match=caml_call1(seq$0,_bnY_);
        if(match)
         {var next=match[2],x=match[1];
          caml_call1(f,x);
          var seq$0=next;
          continue}
        return 0}}
    function chr(n){if(0 <= n && ! (255 < n))return n;return invalid_arg(_m_)}
    function escaped(c)
     {var switch$0=0;
      if(40 <= c)
       {if(92 === c)return _n_;if(! (127 <= c))switch$0 = 1}
      else
       if(32 <= c)
        {if(39 <= c)return _o_;switch$0 = 1}
       else
        if(! (14 <= c))
         switch(c)
          {case 8:return _p_;
           case 9:return _q_;
           case 10:return _r_;
           case 13:return _s_
           }
      if(switch$0)
       {var s$0=caml_create_bytes(1);
        caml_bytes_unsafe_set(s$0,0,c);
        return caml_string_of_bytes(s$0)}
      var s=caml_create_bytes(4);
      caml_bytes_unsafe_set(s,0,92);
      caml_bytes_unsafe_set(s,1,48 + (c / 100 | 0) | 0);
      caml_bytes_unsafe_set(s,2,48 + ((c / 10 | 0) % 10 | 0) | 0);
      caml_bytes_unsafe_set(s,3,48 + (c % 10 | 0) | 0);
      return caml_string_of_bytes(s)}
    function lowercase(c)
     {var _bnX_=c - 192 | 0,switch$0=0;
      if(30 < _bnX_ >>> 0)
       {if(! (25 < _bnX_ + 127 >>> 0))switch$0 = 1}
      else
       if(23 !== _bnX_)switch$0 = 1;
      return switch$0?c + 32 | 0:c}
    function uppercase_ascii(c){return 25 < c - 97 >>> 0?c:c - 32 | 0}
    function compare(c1,c2){return c1 - c2 | 0}
    function length_aux(len,param)
     {var len$0=len,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[2],
           len$1=len$0 + 1 | 0,
           len$0=len$1,
           param$0=param$1;
          continue}
        return len$0}}
    function length(l){return length_aux(0,l)}
    function hd(param){if(param){var a=param[1];return a}return failwith(_t_)}
    function tl(param){if(param){var l=param[2];return l}return failwith(_u_)}
    function nth_opt(l,n)
     {if(0 <= n)
       {var
         nth_aux=
          function(l,n)
           {var l$0=l,n$0=n;
            for(;;)
             {if(l$0)
               {var l$1=l$0[2],a=l$0[1];
                if(0 === n$0)return [0,a];
                var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
                continue}
              return 0}};
        return nth_aux(l,n)}
      return invalid_arg(_v_)}
    function rev_append(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var l1$1=l1$0[2],a=l1$0[1],l2$1=[0,a,l2$0],l1$0=l1$1,l2$0=l2$1;
          continue}
        return l2$0}}
    function rev(l){return rev_append(l,0)}
    function flatten(param)
     {if(param){var r=param[2],l=param[1];return append(l,flatten(r))}
      return 0}
    function map$0(f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call1(f,a);return [0,r,map$0(f,l)]}
      return 0}
    function rev_map(f,l)
     {function rmap_f(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var
             l=param$0[2],
             a=param$0[1],
             accu$1=[0,caml_call1(f,a),accu$0],
             accu$0=accu$1,
             param$0=l;
            continue}
          return accu$0}}
      return rmap_f(0,l)}
    function iter$0(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1];
          caml_call1(f,a);
          var param$0=l;
          continue}
        return 0}}
    function fold(f,accu,l)
     {var accu$0=accu,l$0=l;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           a=l$0[1],
           accu$1=caml_call2(f,accu$0,a),
           accu$0=accu$1,
           l$0=l$1;
          continue}
        return accu$0}}
    function fold_right(f,l,accu)
     {if(l){var l$0=l[2],a=l[1];return caml_call2(f,a,fold_right(f,l$0,accu))}
      return accu}
    function for_all(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_bnW_=caml_call1(p,a);
          if(_bnW_){var param$0=l;continue}
          return _bnW_}
        return 1}}
    function exists(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_bnV_=caml_call1(p,a);
          if(_bnV_)return _bnV_;
          var param$0=l;
          continue}
        return 0}}
    function mem(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_bnU_=0 === caml_compare(a,x)?1:0;
          if(_bnU_)return _bnU_;
          var param$0=l;
          continue}
        return 0}}
    function memq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_bnT_=a === x?1:0;
          if(_bnT_)return _bnT_;
          var param$0=l;
          continue}
        return 0}}
    function assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assoc_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function remove_assq(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return a === x?l:[0,pair,remove_assq(x,l)]}
      return 0}
    function find_all(p)
     {function find(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var l=param$0[2],x=param$0[1];
            if(caml_call1(p,x))
             {var accu$1=[0,x,accu$0],accu$0=accu$1,param$0=l;continue}
            var param$0=l;
            continue}
          return rev(accu$0)}}
      var _bnR_=0;
      return function(_bnS_){return find(_bnR_,_bnS_)}}
    function concat_map(f,l)
     {function aux(f,acc,param)
       {var acc$0=acc,param$0=param;
        for(;;)
         {if(param$0)
           {var
             l=param$0[2],
             x=param$0[1],
             xs=caml_call1(f,x),
             acc$1=rev_append(xs,acc$0),
             acc$0=acc$1,
             param$0=l;
            continue}
          return rev(acc$0)}}
      return aux(f,0,l)}
    function sort_uniq(cmp,l)
     {function rev_merge(l1,l2,accu)
       {var l1$0=l1,l2$0=l2,accu$0=accu;
        for(;;)
         {if(l1$0)
           {if(l2$0)
             {var
               t2=l2$0[2],
               h2=l2$0[1],
               t1=l1$0[2],
               h1=l1$0[1],
               c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$1=[0,h1,accu$0],l1$0=t1,l2$0=t2,accu$0=accu$1;
                continue}
              if(0 <= c)
               {var accu$2=[0,h2,accu$0],l2$0=t2,accu$0=accu$2;continue}
              var accu$3=[0,h1,accu$0],l1$0=t1,accu$0=accu$3;
              continue}
            return rev_append(l1$0,accu$0)}
          return rev_append(l2$0,accu$0)}}
      function rev_merge_rev(l1,l2,accu)
       {var l1$0=l1,l2$0=l2,accu$0=accu;
        for(;;)
         {if(l1$0)
           {if(l2$0)
             {var
               t2=l2$0[2],
               h2=l2$0[1],
               t1=l1$0[2],
               h1=l1$0[1],
               c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$1=[0,h1,accu$0],l1$0=t1,l2$0=t2,accu$0=accu$1;
                continue}
              if(0 < c)
               {var accu$2=[0,h1,accu$0],l1$0=t1,accu$0=accu$2;continue}
              var accu$3=[0,h2,accu$0],l2$0=t2,accu$0=accu$3;
              continue}
            return rev_append(l1$0,accu$0)}
          return rev_append(l2$0,accu$0)}}
      function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _bnI_=l[2];
            if(_bnI_)
             {var
               tl=_bnI_[2],
               x2=_bnI_[1],
               x1=l[1],
               c=caml_call2(cmp,x1,x2),
               s=0 === c?[0,x1,0]:0 < c?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _bnK_=l[2];
           if(_bnK_)
            {var _bnL_=_bnK_[2];
             if(_bnL_)
              {var
                tl$1=_bnL_[2],
                x3=_bnL_[1],
                x2$0=_bnK_[1],
                x1$0=l[1],
                c$0=caml_call2(cmp,x1$0,x2$0);
               if(0 === c$0)
                var
                 c$1=caml_call2(cmp,x2$0,x3),
                 _bnM_=
                  0 === c$1
                   ?[0,x2$0,0]
                   :0 < c$1?[0,x2$0,[0,x3,0]]:[0,x3,[0,x2$0,0]],
                 s$0=_bnM_;
               else
                if(0 < c$0)
                 {var c$2=caml_call2(cmp,x2$0,x3);
                  if(0 === c$2)
                   var _bnN_=[0,x1$0,[0,x2$0,0]];
                  else
                   if(0 < c$2)
                    var _bnN_=[0,x1$0,[0,x2$0,[0,x3,0]]];
                   else
                    var
                     c$3=caml_call2(cmp,x1$0,x3),
                     _bnO_=
                      0 === c$3
                       ?[0,x1$0,[0,x2$0,0]]
                       :0 < c$3
                         ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                         :[0,x3,[0,x1$0,[0,x2$0,0]]],
                     _bnN_=_bnO_;
                  var s$0=_bnN_}
                else
                 {var c$4=caml_call2(cmp,x1$0,x3);
                  if(0 === c$4)
                   var _bnP_=[0,x2$0,[0,x1$0,0]];
                  else
                   if(0 < c$4)
                    var _bnP_=[0,x2$0,[0,x1$0,[0,x3,0]]];
                   else
                    var
                     c$5=caml_call2(cmp,x2$0,x3),
                     _bnQ_=
                      0 === c$5
                       ?[0,x2$0,[0,x1$0,0]]
                       :0 < c$5
                         ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                         :[0,x3,[0,x2$0,[0,x1$0,0]]],
                     _bnP_=_bnQ_;
                  var s$0=_bnP_}
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=sort(n1,l),
         l2=match[2],
         s1=match[1],
         match$0=sort(n2,l2),
         tl$0=match$0[2],
         s2=match$0[1],
         _bnJ_=0;
        return [0,rev_merge(s1,s2,_bnJ_),tl$0]}
      function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _bnz_=l[2];
            if(_bnz_)
             {var
               tl=_bnz_[2],
               x2=_bnz_[1],
               x1=l[1],
               c=caml_call2(cmp,x1,x2),
               s=0 === c?[0,x1,0]:0 <= c?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _bnB_=l[2];
           if(_bnB_)
            {var _bnC_=_bnB_[2];
             if(_bnC_)
              {var
                tl$1=_bnC_[2],
                x3=_bnC_[1],
                x2$0=_bnB_[1],
                x1$0=l[1],
                c$0=caml_call2(cmp,x1$0,x2$0);
               if(0 === c$0)
                var
                 c$1=caml_call2(cmp,x2$0,x3),
                 _bnD_=
                  0 === c$1
                   ?[0,x2$0,0]
                   :0 <= c$1?[0,x3,[0,x2$0,0]]:[0,x2$0,[0,x3,0]],
                 s$0=_bnD_;
               else
                if(0 <= c$0)
                 {var c$2=caml_call2(cmp,x1$0,x3);
                  if(0 === c$2)
                   var _bnE_=[0,x2$0,[0,x1$0,0]];
                  else
                   if(0 <= c$2)
                    var
                     c$3=caml_call2(cmp,x2$0,x3),
                     _bnF_=
                      0 === c$3
                       ?[0,x2$0,[0,x1$0,0]]
                       :0 <= c$3
                         ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                         :[0,x2$0,[0,x3,[0,x1$0,0]]],
                     _bnE_=_bnF_;
                   else
                    var _bnE_=[0,x2$0,[0,x1$0,[0,x3,0]]];
                  var s$0=_bnE_}
                else
                 {var c$4=caml_call2(cmp,x2$0,x3);
                  if(0 === c$4)
                   var _bnG_=[0,x1$0,[0,x2$0,0]];
                  else
                   if(0 <= c$4)
                    var
                     c$5=caml_call2(cmp,x1$0,x3),
                     _bnH_=
                      0 === c$5
                       ?[0,x1$0,[0,x2$0,0]]
                       :0 <= c$5
                         ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                         :[0,x1$0,[0,x3,[0,x2$0,0]]],
                     _bnG_=_bnH_;
                   else
                    var _bnG_=[0,x1$0,[0,x2$0,[0,x3,0]]];
                  var s$0=_bnG_}
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=rev_sort(n1,l),
         l2=match[2],
         s1=match[1],
         match$0=rev_sort(n2,l2),
         tl$0=match$0[2],
         s2=match$0[1],
         _bnA_=0;
        return [0,rev_merge_rev(s1,s2,_bnA_),tl$0]}
      var len=length(l);
      return 2 <= len?sort(len,l)[1]:l}
    function min$0(x,y){return x <= y?x:y}
    function max$0(x,y){return y <= x?x:y}
    function to_string$1(x){return caml_string_of_jsbytes("" + x)}
    function make$0(n,c)
     {var s=caml_create_bytes(n);caml_fill_bytes(s,0,n,c);return s}
    function copy(s)
     {var len=caml_ml_bytes_length(s),r=caml_create_bytes(len);
      caml_blit_bytes(s,0,r,0,len);
      return r}
    function of_bytes(b){return caml_string_of_bytes(copy(b))}
    function to_bytes(s){return copy(caml_bytes_of_string(s))}
    function sub(s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       {var r=caml_create_bytes(len);caml_blit_bytes(s,ofs,r,0,len);return r}
      return invalid_arg(_w_)}
    function sub_string(b,ofs,len)
     {return caml_string_of_bytes(sub(b,ofs,len))}
    function blit(s1,ofs1,s2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((caml_ml_bytes_length(s1) - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
       return caml_blit_bytes(s1,ofs1,s2,ofs2,len);
      return invalid_arg(_x_)}
    function blit$0(s1,ofs1,s2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((caml_ml_string_length(s1) - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
       return caml_blit_string(s1,ofs1,s2,ofs2,len);
      return invalid_arg(_y_)}
    function escaped$0(s)
     {var n=[0,0],_bnr_=caml_ml_bytes_length(s) - 1 | 0,_bnq_=0;
      if(! (_bnr_ < 0))
       {var i$0=_bnq_;
        for(;;)
         {var match=caml_bytes_unsafe_get(s,i$0),switch$0=0;
          if(32 <= match)
           {var _bnw_=match - 34 | 0,switch$1=0;
            if(58 < _bnw_ >>> 0)
             {if(93 <= _bnw_)switch$1 = 1}
            else
             if(56 < _bnw_ - 1 >>> 0){switch$0 = 1;switch$1 = 1}
            if(! switch$1){var _bnx_=1;switch$0 = 2}}
          else
           if(11 <= match)
            {if(13 === match)switch$0 = 1}
           else
            if(8 <= match)switch$0 = 1;
          switch(switch$0){case 0:var _bnx_=4;break;case 1:var _bnx_=2;break}
          n[1] = n[1] + _bnx_ | 0;
          var _bny_=i$0 + 1 | 0;
          if(_bnr_ !== i$0){var i$0=_bny_;continue}
          break}}
      if(n[1] === caml_ml_bytes_length(s))return copy(s);
      var _bns_=n[1],s$0=caml_create_bytes(_bns_);
      n[1] = 0;
      var _bnu_=caml_ml_bytes_length(s) - 1 | 0,_bnt_=0;
      if(! (_bnu_ < 0))
       {var i=_bnt_;
        for(;;)
         {var c=caml_bytes_unsafe_get(s,i),switch$2=0;
          if(35 <= c)
           if(92 === c)
            switch$2 = 2;
           else
            if(127 <= c)switch$2 = 1;else switch$2 = 3;
          else
           if(32 <= c)
            if(34 <= c)switch$2 = 2;else switch$2 = 3;
           else
            if(14 <= c)
             switch$2 = 1;
            else
             switch(c)
              {case 8:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],98);
                break;
               case 9:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],116);
                break;
               case 10:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],110);
                break;
               case 13:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],114);
                break;
               default:switch$2 = 1}
          switch(switch$2)
           {case 1:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c / 100 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + ((c / 10 | 0) % 10 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c % 10 | 0) | 0);
             break;
            case 2:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],c);
             break;
            case 3:caml_bytes_unsafe_set(s$0,n[1],c);break
            }
          n[1]++;
          var _bnv_=i + 1 | 0;
          if(_bnu_ !== i){var i=_bnv_;continue}
          break}}
      return s$0}
    function map$1(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_bnn_=l - 1 | 0,_bnm_=0;
      if(! (_bnn_ < 0))
       {var i=_bnm_;
        for(;;)
         {var _bno_=caml_bytes_unsafe_get(s,i);
          caml_bytes_unsafe_set(r,i,caml_call1(f,_bno_));
          var _bnp_=i + 1 | 0;
          if(_bnn_ !== i){var i=_bnp_;continue}
          break}}
      return r}
    function uppercase_ascii$0(s){return map$1(uppercase_ascii,s)}
    function ubos(_bnl_){return caml_bytes_of_string(_bnl_)}
    function usob(_bnk_){return caml_string_of_bytes(_bnk_)}
    function make$1(n,c){return usob(make$0(n,c))}
    function sub$0(s,ofs,len)
     {var _bnj_=ubos(s);return usob(sub(_bnj_,ofs,len))}
    function ensure_ge(x,y){return y <= x?x:invalid_arg(_z_)}
    function sum_lengths(acc,seplen,param)
     {var acc$0=acc,param$0=param;
      for(;;)
       {if(param$0)
         {var _bnh_=param$0[1];
          if(param$0[2])
           {var
             tl=param$0[2],
             _bni_=(caml_ml_string_length(_bnh_) + seplen | 0) + acc$0 | 0,
             acc$1=ensure_ge(_bni_,acc$0),
             acc$0=acc$1,
             param$0=tl;
            continue}
          return caml_ml_string_length(_bnh_) + acc$0 | 0}
        return acc$0}}
    function unsafe_blits(dst,pos,sep,seplen,param)
     {var pos$0=pos,param$0=param;
      for(;;)
       {if(param$0)
         {var _bnd_=param$0[1];
          if(param$0[2])
           {var tl=param$0[2],_bne_=caml_ml_string_length(_bnd_);
            caml_blit_string(_bnd_,0,dst,pos$0,_bne_);
            var _bnf_=pos$0 + caml_ml_string_length(_bnd_) | 0;
            caml_blit_string(sep,0,dst,_bnf_,seplen);
            var
             pos$1=(pos$0 + caml_ml_string_length(_bnd_) | 0) + seplen | 0,
             pos$0=pos$1,
             param$0=tl;
            continue}
          var _bng_=caml_ml_string_length(_bnd_);
          caml_blit_string(_bnd_,0,dst,pos$0,_bng_);
          return dst}
        return dst}}
    function join(sep,l)
     {if(l)
       {var
         seplen=caml_ml_string_length(sep),
         _bm$_=0,
         _bna_=0,
         _bnb_=sum_lengths(_bna_,seplen,l),
         _bnc_=caml_create_bytes(_bnb_);
        return usob(unsafe_blits(_bnc_,_bm$_,sep,seplen,l))}
      return _A_}
    function iter$1(f,s)
     {var _bm8_=caml_ml_string_length(s) - 1 | 0,_bm7_=0;
      if(! (_bm8_ < 0))
       {var i=_bm7_;
        for(;;)
         {var _bm9_=caml_string_unsafe_get(s,i);
          caml_call1(f,_bm9_);
          var _bm__=i + 1 | 0;
          if(_bm8_ !== i){var i=_bm__;continue}
          break}}
      return 0}
    function escaped$1(s)
     {function escape_if_needed(s,n,i)
       {var i$0=i;
        for(;;)
         {if(n <= i$0)return s;
          var
           match=caml_string_unsafe_get(s,i$0),
           _bm5_=match - 32 | 0,
           switch$0=0;
          if(59 < _bm5_ >>> 0)
           {if(33 < _bm5_ - 61 >>> 0)switch$0 = 1}
          else
           if(2 === _bm5_)switch$0 = 1;
          if(switch$0){var _bm6_=ubos(s);return usob(escaped$0(_bm6_))}
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      return escape_if_needed(s,caml_ml_string_length(s),0)}
    function index_rec(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_string_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_from(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))return index_rec(s,l,i,c);
      return invalid_arg(_B_)}
    function contains_from(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))
       try
        {index_rec(s,l,i,c);var _bm3_=1;return _bm3_}
       catch(_bm4_)
        {_bm4_ = caml_wrap_exception(_bm4_);
         if(_bm4_ === Not_found)return 0;
         throw _bm4_}
      return invalid_arg(_C_)}
    function contains(s,c){return contains_from(s,0,c)}
    function uppercase_ascii$1(s)
     {var _bm2_=ubos(s);return usob(uppercase_ascii$0(_bm2_))}
    function compare$0(x,y){return caml_string_compare(x,y)}
    function init(l,f)
     {if(0 === l)return [0];
      if(0 <= l)
       {var
         _bmW_=0,
         _bmX_=caml_call1(f,_bmW_),
         res=caml_make_vect(l,_bmX_),
         _bmZ_=l - 1 | 0,
         _bmY_=1;
        if(! (_bmZ_ < 1))
         {var i=_bmY_;
          for(;;)
           {var _bm0_=caml_call1(f,i);
            res[1 + i] = _bm0_;
            var _bm1_=i + 1 | 0;
            if(_bmZ_ !== i){var i=_bm1_;continue}
            break}}
        return res}
      return invalid_arg(_D_)}
    function sub$1(a,ofs,len)
     {if(0 <= ofs && 0 <= len && ! ((a.length - 1 - len | 0) < ofs))
       return caml_array_sub(a,ofs,len);
      return invalid_arg(_E_)}
    function fill(a,ofs,len,v)
     {if(0 <= ofs && 0 <= len && ! ((a.length - 1 - len | 0) < ofs))
       return caml_array_fill(a,ofs,len,v);
      return invalid_arg(_F_)}
    function blit$1(a1,ofs1,a2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((a1.length - 1 - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((a2.length - 1 - len | 0) < ofs2))
       return caml_array_blit(a1,ofs1,a2,ofs2,len);
      return invalid_arg(_G_)}
    function iter$2(f,a)
     {var _bmT_=a.length - 1 - 1 | 0,_bmS_=0;
      if(! (_bmT_ < 0))
       {var i=_bmS_;
        for(;;)
         {var _bmU_=a[1 + i];
          caml_call1(f,_bmU_);
          var _bmV_=i + 1 | 0;
          if(_bmT_ !== i){var i=_bmV_;continue}
          break}}
      return 0}
    function map$2(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var
       _bmK_=0,
       _bmL_=a[1 + _bmK_],
       _bmM_=caml_call1(f,_bmL_),
       r=caml_make_vect(l,_bmM_),
       _bmO_=l - 1 | 0,
       _bmN_=1;
      if(! (_bmO_ < 1))
       {var i=_bmN_;
        for(;;)
         {var _bmP_=a[1 + i],_bmQ_=caml_call1(f,_bmP_);
          r[1 + i] = _bmQ_;
          var _bmR_=i + 1 | 0;
          if(_bmO_ !== i){var i=_bmR_;continue}
          break}}
      return r}
    function iteri(f,a)
     {var _bmH_=a.length - 1 - 1 | 0,_bmG_=0;
      if(! (_bmH_ < 0))
       {var i=_bmG_;
        for(;;)
         {var _bmI_=a[1 + i];
          caml_call2(f,i,_bmI_);
          var _bmJ_=i + 1 | 0;
          if(_bmH_ !== i){var i=_bmJ_;continue}
          break}}
      return 0}
    function to_list(a)
     {function tolist(i,res)
       {var i$0=i,res$0=res;
        for(;;)
         {if(0 <= i$0)
           {var
             res$1=[0,a[1 + i$0],res$0],
             i$1=i$0 - 1 | 0,
             i$0=i$1,
             res$0=res$1;
            continue}
          return res$0}}
      return tolist(a.length - 1 - 1 | 0,0)}
    function list_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[2],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function of_list(l)
     {if(l)
       {var
         tl=l[2],
         hd=l[1],
         _bmE_=0,
         _bmF_=list_length(_bmE_,l),
         a=caml_make_vect(_bmF_,hd),
         fill=
          function(i,param)
           {var i$0=i,param$0=param;
            for(;;)
             {if(param$0)
               {var tl=param$0[2],hd=param$0[1];
                a[1 + i$0] = hd;
                var i$1=i$0 + 1 | 0,i$0=i$1,param$0=tl;
                continue}
              return a}};
        return fill(1,tl)}
      return [0]}
    function fold_left$0(f,x,a)
     {var r=[0,x],_bmA_=a.length - 1 - 1 | 0,_bmz_=0;
      if(! (_bmA_ < 0))
       {var i=_bmz_;
        for(;;)
         {var _bmB_=a[1 + i],_bmC_=r[1];
          r[1] = caml_call2(f,_bmC_,_bmB_);
          var _bmD_=i + 1 | 0;
          if(_bmA_ !== i){var i=_bmD_;continue}
          break}}
      return r[1]}
    function fold_right$0(f,a,x)
     {var r=[0,x],_bmv_=a.length - 1 - 1 | 0;
      if(! (_bmv_ < 0))
       {var i=_bmv_;
        for(;;)
         {var _bmw_=r[1],_bmx_=a[1 + i];
          r[1] = caml_call2(f,_bmx_,_bmw_);
          var _bmy_=i - 1 | 0;
          if(0 !== i){var i=_bmy_;continue}
          break}}
      return r[1]}
    var Bottom=[248,_H_,caml_fresh_oo_id(0)];
    function sort(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {var
           _bml_=i31 + 1 | 0,
           _bmm_=caml_check_bound(a,_bml_)[1 + _bml_],
           _bmn_=caml_check_bound(a,i31)[1 + i31];
          if(caml_call2(cmp,_bmn_,_bmm_) < 0)x[1] = i31 + 1 | 0;
          var
           _bmo_=i31 + 2 | 0,
           _bmp_=caml_check_bound(a,_bmo_)[1 + _bmo_],
           _bmq_=x[1],
           _bmr_=caml_check_bound(a,_bmq_)[1 + _bmq_];
          if(caml_call2(cmp,_bmr_,_bmp_) < 0)x[1] = i31 + 2 | 0;
          return x[1]}
        if((i31 + 1 | 0) < l)
         {var
           _bms_=i31 + 1 | 0,
           _bmt_=caml_check_bound(a,_bms_)[1 + _bms_],
           _bmu_=caml_check_bound(a,i31)[1 + i31];
          if(! (0 <= caml_call2(cmp,_bmu_,_bmt_)))return i31 + 1 | 0}
        if(i31 < l)return i31;
        throw [0,Bottom,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0),_bmj_=caml_check_bound(a,j)[1 + j];
          if(0 < caml_call2(cmp,_bmj_,e))
           {var _bmk_=caml_check_bound(a,j)[1 + j];
            caml_check_bound(a,i$0)[1 + i$0] = _bmk_;
            var i$0=j;
            continue}
          caml_check_bound(a,i$0)[1 + i$0] = e;
          return 0}}
      function trickle(l,i,e)
       {try
         {var _bmi_=trickledown(l,i,e);return _bmi_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom)
           {var i$0=exn[2];caml_check_bound(a,i$0)[1 + i$0] = e;return 0}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0),_bmh_=caml_check_bound(a,i$1)[1 + i$1];
          caml_check_bound(a,i$0)[1 + i$0] = _bmh_;
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _bmg_=bubbledown(l,i);return _bmg_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom){var i$0=exn[2];return i$0}
          throw exn}}
      function trickleup(i,e)
       {var i$0=i;
        for(;;)
         {var father=(i$0 - 1 | 0) / 3 | 0;
          if(i$0 !== father)
           {var _bmd_=caml_check_bound(a,father)[1 + father];
            if(0 <= caml_call2(cmp,_bmd_,e))
             {caml_check_bound(a,i$0)[1 + i$0] = e;return 0}
            var _bme_=caml_check_bound(a,father)[1 + father];
            caml_check_bound(a,i$0)[1 + i$0] = _bme_;
            if(0 < father){var i$0=father;continue}
            var _bmf_=0;
            caml_check_bound(a,0)[1 + _bmf_] = e;
            return 0}
          throw [0,Assert_failure,_I_]}}
      var l=a.length - 1,_blZ_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_blZ_ < 0))
       {var i$0=_blZ_;
        for(;;)
         {var _bmb_=caml_check_bound(a,i$0)[1 + i$0];
          trickle(l,i$0,_bmb_);
          var _bmc_=i$0 - 1 | 0;
          if(0 !== i$0){var i$0=_bmc_;continue}
          break}}
      var _bl0_=l - 1 | 0;
      if(! (_bl0_ < 2))
       {var i=_bl0_;
        for(;;)
         {var
           e$0=caml_check_bound(a,i)[1 + i],
           _bl8_=0,
           _bl9_=caml_check_bound(a,0)[1 + _bl8_];
          caml_check_bound(a,i)[1 + i] = _bl9_;
          var _bl__=0,_bl$_=bubble(i,_bl__);
          trickleup(_bl$_,e$0);
          var _bma_=i - 1 | 0;
          if(2 !== i){var i=_bma_;continue}
          break}}
      var _bl1_=1 < l?1:0;
      if(_bl1_)
       {var
         _bl2_=1,
         e=caml_check_bound(a,1)[1 + _bl2_],
         _bl3_=0,
         _bl4_=caml_check_bound(a,0)[1 + _bl3_],
         _bl5_=1;
        caml_check_bound(a,1)[1 + _bl5_] = _bl4_;
        var _bl6_=0;
        caml_check_bound(a,0)[1 + _bl6_] = e;
        var _bl7_=0}
      else
       var _bl7_=_bl1_;
      return _bl7_}
    var zero=0,one=1;
    function succ(n){return n + 1 | 0}
    function pred(n){return n - 1 | 0}
    function abs$0(n){return caml_greaterequal(n,0)?n:- n | 0}
    function to_string$2(n){return caml_format_int(_J_,n)}
    function compare$1(x,y){return caml_int_compare(x,y)}
    function succ$0(n){return caml_int64_add(n,_K_)}
    function pred$0(n){return caml_int64_sub(n,_L_)}
    function abs$1(n){return caml_greaterequal(n,_M_)?n:caml_int64_neg(n)}
    function to_string$3(n){return caml_int64_format(_N_,n)}
    function compare$2(x,y){return caml_int64_compare(x,y)}
    var zero$1=0,one$1=1;
    function succ$1(n){return n + 1 | 0}
    function pred$1(n){return n - 1 | 0}
    function abs$2(n){return caml_greaterequal(n,0)?n:- n | 0}
    function to_string$4(n){return caml_format_int(_O_,n)}
    function compare$3(x,y){return caml_int_compare(x,y)}
    function engine(tbl,state,buf)
     {var
       result=caml_lex_engine(tbl,state,buf),
       _blW_=0 <= result?1:0,
       _blX_=_blW_?buf[12] !== dummy_pos?1:0:_blW_;
      if(_blX_)
       {buf[11] = buf[12];
        var _blY_=buf[12];
        buf[12] = [0,_blY_[1],_blY_[2],_blY_[3],buf[4] + buf[6] | 0]}
      return result}
    function from_string(opt,s)
     {if(opt)var sth=opt[1],with_positions=sth;else var with_positions=1;
      var
       _blL_=with_positions?zero_pos:dummy_pos,
       _blM_=with_positions?zero_pos:dummy_pos,
       _blN_=[0],
       _blO_=1,
       _blP_=0,
       _blQ_=0,
       _blR_=0,
       _blS_=0,
       _blT_=0,
       _blU_=caml_ml_string_length(s),
       _blV_=to_bytes(s);
      return [0,
              function(lexbuf){lexbuf[9] = 1;return 0},
              _blV_,
              _blU_,
              _blT_,
              _blS_,
              _blR_,
              _blQ_,
              _blP_,
              _blO_,
              _blN_,
              _blM_,
              _blL_]}
    function sub_lexeme(lexbuf,i1,i2)
     {var len=i2 - i1 | 0;return sub_string(lexbuf[2],i1,len)}
    function sub_lexeme_char(lexbuf,i)
     {var _blK_=lexbuf[2];return caml_bytes_get(_blK_,i)}
    function lexeme_start_p(lexbuf){return lexbuf[11]}
    function lexeme_end_p(lexbuf){return lexbuf[12]}
    function new_line(lexbuf)
     {var
       lcp=lexbuf[12],
       _blI_=lcp !== dummy_pos?1:0,
       _blJ_=
        _blI_?(lexbuf[12] = [0,lcp[1],lcp[2] + 1 | 0,lcp[4],lcp[4]],0):_blI_;
      return _blJ_}
    function Make(Ord)
     {function height(param){if(param){var h=param[4];return h}return 0}
      function create(l,v,r)
       {if(l)var h=l[4],hl=h;else var hl=0;
        if(r)var h$0=r[4],hr=h$0;else var hr=0;
        var _blH_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
        return [0,l,v,r,_blH_]}
      function bal(l,v,r)
       {if(l)var h=l[4],hl=h;else var hl=0;
        if(r)var h$0=r[4],hr=h$0;else var hr=0;
        if((hr + 2 | 0) < hl)
         {if(l)
           {var lr=l[3],lv=l[2],ll=l[1],_blC_=height(lr);
            if(_blC_ <= height(ll))return create(ll,lv,create(lr,v,r));
            if(lr)
             {var lrr=lr[3],lrv=lr[2],lrl=lr[1],_blD_=create(lrr,v,r);
              return create(create(ll,lv,lrl),lrv,_blD_)}
            return invalid_arg(_P_)}
          return invalid_arg(_Q_)}
        if((hl + 2 | 0) < hr)
         {if(r)
           {var rr=r[3],rv=r[2],rl=r[1],_blE_=height(rl);
            if(_blE_ <= height(rr))return create(create(l,v,rl),rv,rr);
            if(rl)
             {var rlr=rl[3],rlv=rl[2],rll=rl[1],_blF_=create(rlr,rv,rr);
              return create(create(l,v,rll),rlv,_blF_)}
            return invalid_arg(_R_)}
          return invalid_arg(_S_)}
        var _blG_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
        return [0,l,v,r,_blG_]}
      function add(x,t)
       {if(t)
         {var r=t[3],v=t[2],l=t[1],_blB_=Ord[1],c=caml_call2(_blB_,x,v);
          if(0 === c)return t;
          if(0 <= c){var rr=add(x,r);return r === rr?t:bal(l,v,rr)}
          var ll=add(x,l);
          return l === ll?t:bal(ll,v,r)}
        return [0,0,x,0,1]}
      function singleton(x){return [0,0,x,0,1]}
      function add_min_element(x,param)
       {if(param)
         {var r=param[3],v=param[2],l=param[1];
          return bal(add_min_element(x,l),v,r)}
        return singleton(x)}
      function add_max_element(x,param)
       {if(param)
         {var r=param[3],v=param[2],l=param[1];
          return bal(l,v,add_max_element(x,r))}
        return singleton(x)}
      function join(l,v,r)
       {if(l)
         {if(r)
           {var
             rh=r[4],
             rr=r[3],
             rv=r[2],
             rl=r[1],
             lh=l[4],
             lr=l[3],
             lv=l[2],
             ll=l[1];
            return (rh + 2 | 0) < lh
                    ?bal(ll,lv,join(lr,v,r))
                    :(lh + 2 | 0) < rh?bal(join(l,v,rl),rv,rr):create(l,v,r)}
          return add_max_element(v,l)}
        return add_min_element(v,r)}
      function min_elt(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var _blA_=param$0[1];
            if(_blA_){var param$0=_blA_;continue}
            var v=param$0[2];
            return v}
          throw Not_found}}
      function min_elt_opt(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var _blz_=param$0[1];
            if(_blz_){var param$0=_blz_;continue}
            var v=param$0[2];
            return [0,v]}
          return 0}}
      function max_elt(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {if(param$0[3]){var param$1=param$0[3],param$0=param$1;continue}
            var v=param$0[2];
            return v}
          throw Not_found}}
      function max_elt_opt(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {if(param$0[3]){var param$1=param$0[3],param$0=param$1;continue}
            var v=param$0[2];
            return [0,v]}
          return 0}}
      function remove_min_elt(param)
       {if(param)
         {var _bly_=param[1];
          if(_bly_)
           {var r=param[3],v=param[2];return bal(remove_min_elt(_bly_),v,r)}
          var r$0=param[3];
          return r$0}
        return invalid_arg(_U_)}
      function merge(t1,t2)
       {if(t1)
         {if(t2)
           {var _blx_=remove_min_elt(t2);return bal(t1,min_elt(t2),_blx_)}
          return t1}
        return t2}
      function concat(t1,t2)
       {if(t1)
         {if(t2)
           {var _blw_=remove_min_elt(t2);return join(t1,min_elt(t2),_blw_)}
          return t1}
        return t2}
      function split(x,param)
       {if(param)
         {var
           r=param[3],
           v=param[2],
           l=param[1],
           _blv_=Ord[1],
           c=caml_call2(_blv_,x,v);
          if(0 === c)return [0,l,1,r];
          if(0 <= c)
           {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
            return [0,join(l,v,lr),pres,rr]}
          var
           match$0=split(x,l),
           rl=match$0[3],
           pres$0=match$0[2],
           ll=match$0[1];
          return [0,ll,pres$0,join(rl,v,r)]}
        return _V_}
      var empty=0;
      function is_empty(param){return param?0:1}
      function mem(x,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var
             r=param$0[3],
             v=param$0[2],
             l=param$0[1],
             _blt_=Ord[1],
             c=caml_call2(_blt_,x,v),
             _blu_=0 === c?1:0;
            if(_blu_)return _blu_;
            var param$1=0 <= c?r:l,param$0=param$1;
            continue}
          return 0}}
      function remove(x,t)
       {if(t)
         {var r=t[3],v=t[2],l=t[1],_bls_=Ord[1],c=caml_call2(_bls_,x,v);
          if(0 === c)return merge(l,r);
          if(0 <= c){var rr=remove(x,r);return r === rr?t:bal(l,v,rr)}
          var ll=remove(x,l);
          return l === ll?t:bal(ll,v,r)}
        return 0}
      function union(s1,s2)
       {if(s1)
         {if(s2)
           {var
             h2=s2[4],
             r2=s2[3],
             v2=s2[2],
             l2=s2[1],
             h1=s1[4],
             r1=s1[3],
             v1=s1[2],
             l1=s1[1];
            if(h2 <= h1)
             {if(1 === h2)return add(v2,s1);
              var
               match=split(v1,s2),
               r2$0=match[3],
               l2$0=match[1],
               _blq_=union(r1,r2$0);
              return join(union(l1,l2$0),v1,_blq_)}
            if(1 === h1)return add(v1,s2);
            var
             match$0=split(v2,s1),
             r1$0=match$0[3],
             l1$0=match$0[1],
             _blr_=union(r1$0,r2);
            return join(union(l1$0,l2),v2,_blr_)}
          return s1}
        return s2}
      function inter(s1,s2)
       {if(s1)
         {if(s2)
           {var r1=s1[3],v1=s1[2],l1=s1[1],_blm_=split(v1,s2),_bln_=_blm_[1];
            if(_blm_[2])
             {var r2=_blm_[3],_blo_=inter(r1,r2);
              return join(inter(l1,_bln_),v1,_blo_)}
            var r2$0=_blm_[3],_blp_=inter(r1,r2$0);
            return concat(inter(l1,_bln_),_blp_)}
          return 0}
        return 0}
      function split_bis(x,param)
       {if(param)
         {var
           r=param[3],
           v=param[2],
           l=param[1],
           _blk_=Ord[1],
           c=caml_call2(_blk_,x,v);
          if(0 === c)return 0;
          if(0 <= c)
           {var match=split_bis(x,r);
            if(match){var rr=match[2],lr=match[1];return [0,join(l,v,lr),rr]}
            return 0}
          var match$0=split_bis(x,l);
          if(match$0)
           {var rl=match$0[2],ll=match$0[1];
            return [0,
                    ll,
                    function(param)
                     {var _bll_=0;return join(caml_call1(rl,_bll_),v,r)}]}
          return 0}
        return [0,0,function(param){return 0}]}
      function disjoint(s1,s2)
       {var s1$0=s1,s2$0=s2;
        for(;;)
         {if(s1$0 && s2$0)
           {var r1=s1$0[3],v1=s1$0[2],l1=s1$0[1];
            if(s1$0 === s2$0)return 0;
            var match=split_bis(v1,s2$0);
            if(match)
             {var r2=match[2],l2=match[1],_bli_=disjoint(l1,l2);
              if(_bli_)
               {var _blj_=0,s2$1=caml_call1(r2,_blj_),s1$0=r1,s2$0=s2$1;
                continue}
              return _bli_}
            return 0}
          return 1}}
      function diff(s1,s2)
       {if(s1)
         {if(s2)
           {var r1=s1[3],v1=s1[2],l1=s1[1],_ble_=split(v1,s2),_blf_=_ble_[1];
            if(_ble_[2])
             {var r2=_ble_[3],_blg_=diff(r1,r2);
              return concat(diff(l1,_blf_),_blg_)}
            var r2$0=_ble_[3],_blh_=diff(r1,r2$0);
            return join(diff(l1,_blf_),v1,_blh_)}
          return s1}
        return 0}
      function cons_enum(s,e)
       {var s$0=s,e$0=e;
        for(;;)
         {if(s$0)
           {var r=s$0[3],v=s$0[2],s$1=s$0[1],e$1=[0,v,r,e$0],s$0=s$1,e$0=e$1;
            continue}
          return e$0}}
      function compare_aux(e1,e2)
       {var e1$0=e1,e2$0=e2;
        for(;;)
         {if(e1$0)
           {if(e2$0)
             {var
               e2$1=e2$0[3],
               r2=e2$0[2],
               v2=e2$0[1],
               e1$1=e1$0[3],
               r1=e1$0[2],
               v1=e1$0[1],
               _bld_=Ord[1],
               c=caml_call2(_bld_,v1,v2);
              if(0 === c)
               {var
                 e2$2=cons_enum(r2,e2$1),
                 e1$2=cons_enum(r1,e1$1),
                 e1$0=e1$2,
                 e2$0=e2$2;
                continue}
              return c}
            return 1}
          return e2$0?-1:0}}
      function compare(s1,s2)
       {var _bla_=0,_blb_=cons_enum(s2,_bla_),_blc_=0;
        return compare_aux(cons_enum(s1,_blc_),_blb_)}
      function equal(s1,s2){return 0 === compare(s1,s2)?1:0}
      function subset(s1,s2)
       {var s1$0=s1,s2$0=s2;
        for(;;)
         {if(s1$0)
           {if(s2$0)
             {var
               r2=s2$0[3],
               v2=s2$0[2],
               l2=s2$0[1],
               r1=s1$0[3],
               v1=s1$0[2],
               l1=s1$0[1],
               _bk6_=Ord[1],
               c=caml_call2(_bk6_,v1,v2);
              if(0 === c)
               {var _bk7_=subset(l1,l2);
                if(_bk7_){var s1$0=r1,s2$0=r2;continue}
                return _bk7_}
              if(0 <= c)
               {var _bk8_=[0,0,v1,r1,0],_bk9_=subset(_bk8_,r2);
                if(_bk9_){var s1$0=l1;continue}
                return _bk9_}
              var _bk__=[0,l1,v1,0,0],_bk$_=subset(_bk__,l2);
              if(_bk$_){var s1$0=r1;continue}
              return _bk$_}
            return 0}
          return 1}}
      function iter(f,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var r=param$0[3],v=param$0[2],l=param$0[1];
            iter(f,l);
            caml_call1(f,v);
            var param$0=r;
            continue}
          return 0}}
      function fold(f,s,accu)
       {var s$0=s,accu$0=accu;
        for(;;)
         {if(s$0)
           {var
             r=s$0[3],
             v=s$0[2],
             l=s$0[1],
             _bk5_=fold(f,l,accu$0),
             accu$1=caml_call2(f,v,_bk5_),
             s$0=r,
             accu$0=accu$1;
            continue}
          return accu$0}}
      function for_all(p,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var r=param$0[3],v=param$0[2],l=param$0[1],_bk2_=caml_call1(p,v);
            if(_bk2_)
             {var _bk3_=for_all(p,l);
              if(_bk3_){var param$0=r;continue}
              var _bk4_=_bk3_}
            else
             var _bk4_=_bk2_;
            return _bk4_}
          return 1}}
      function exists(p,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var r=param$0[3],v=param$0[2],l=param$0[1],_bkZ_=caml_call1(p,v);
            if(_bkZ_)
             var _bk0_=_bkZ_;
            else
             {var _bk1_=exists(p,l);
              if(! _bk1_){var param$0=r;continue}
              var _bk0_=_bk1_}
            return _bk0_}
          return 0}}
      function filter(p,t)
       {if(t)
         {var
           r=t[3],
           v=t[2],
           l=t[1],
           l$0=filter(p,l),
           pv=caml_call1(p,v),
           r$0=filter(p,r);
          if(pv){if(l === l$0 && r === r$0)return t;return join(l$0,v,r$0)}
          return concat(l$0,r$0)}
        return 0}
      function partition(p,param)
       {if(param)
         {var
           r=param[3],
           v=param[2],
           l=param[1],
           match=partition(p,l),
           lf=match[2],
           lt=match[1],
           pv=caml_call1(p,v),
           match$0=partition(p,r),
           rf=match$0[2],
           rt=match$0[1];
          if(pv){var _bkX_=concat(lf,rf);return [0,join(lt,v,rt),_bkX_]}
          var _bkY_=join(lf,v,rf);
          return [0,concat(lt,rt),_bkY_]}
        return _W_}
      function cardinal(param)
       {if(param)
         {var r=param[3],l=param[1],_bkW_=cardinal(r);
          return (cardinal(l) + 1 | 0) + _bkW_ | 0}
        return 0}
      function elements_aux(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var
             r=param$0[3],
             v=param$0[2],
             l=param$0[1],
             accu$1=[0,v,elements_aux(accu$0,r)],
             accu$0=accu$1,
             param$0=l;
            continue}
          return accu$0}}
      function elements(s){return elements_aux(0,s)}
      function find(x,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var
             r=param$0[3],
             v=param$0[2],
             l=param$0[1],
             _bkV_=Ord[1],
             c=caml_call2(_bkV_,x,v);
            if(0 === c)return v;
            var param$1=0 <= c?r:l,param$0=param$1;
            continue}
          throw Not_found}}
      function find_first_aux(v0,f,param)
       {var v0$0=v0,param$0=param;
        for(;;)
         {if(param$0)
           {var r=param$0[3],v=param$0[2],l=param$0[1];
            if(caml_call1(f,v)){var v0$0=v,param$0=l;continue}
            var param$0=r;
            continue}
          return v0$0}}
      function find_first(f,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var r=param$0[3],v=param$0[2],l=param$0[1];
            if(caml_call1(f,v))return find_first_aux(v,f,l);
            var param$0=r;
            continue}
          throw Not_found}}
      function find_first_opt_aux(v0,f,param)
       {var v0$0=v0,param$0=param;
        for(;;)
         {if(param$0)
           {var r=param$0[3],v=param$0[2],l=param$0[1];
            if(caml_call1(f,v)){var v0$0=v,param$0=l;continue}
            var param$0=r;
            continue}
          return [0,v0$0]}}
      function find_first_opt(f,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var r=param$0[3],v=param$0[2],l=param$0[1];
            if(caml_call1(f,v))return find_first_opt_aux(v,f,l);
            var param$0=r;
            continue}
          return 0}}
      function find_last_aux(v0,f,param)
       {var v0$0=v0,param$0=param;
        for(;;)
         {if(param$0)
           {var r=param$0[3],v=param$0[2],l=param$0[1];
            if(caml_call1(f,v)){var v0$0=v,param$0=r;continue}
            var param$0=l;
            continue}
          return v0$0}}
      function find_last(f,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var r=param$0[3],v=param$0[2],l=param$0[1];
            if(caml_call1(f,v))return find_last_aux(v,f,r);
            var param$0=l;
            continue}
          throw Not_found}}
      function find_last_opt_aux(v0,f,param)
       {var v0$0=v0,param$0=param;
        for(;;)
         {if(param$0)
           {var r=param$0[3],v=param$0[2],l=param$0[1];
            if(caml_call1(f,v)){var v0$0=v,param$0=r;continue}
            var param$0=l;
            continue}
          return [0,v0$0]}}
      function find_last_opt(f,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var r=param$0[3],v=param$0[2],l=param$0[1];
            if(caml_call1(f,v))return find_last_opt_aux(v,f,r);
            var param$0=l;
            continue}
          return 0}}
      function find_opt(x,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var
             r=param$0[3],
             v=param$0[2],
             l=param$0[1],
             _bkU_=Ord[1],
             c=caml_call2(_bkU_,x,v);
            if(0 === c)return [0,v];
            var param$1=0 <= c?r:l,param$0=param$1;
            continue}
          return 0}}
      function try_join(l,v,r)
       {var switch$0=0;
        if(0 !== l)
         {var _bkS_=max_elt(l),_bkT_=Ord[1];
          if(0 <= caml_call2(_bkT_,_bkS_,v))switch$0 = 1}
        if(! switch$0)
         {var switch$1=0;
          if(0 !== r)
           {var _bkQ_=min_elt(r),_bkR_=Ord[1];
            if(0 <= caml_call2(_bkR_,v,_bkQ_))switch$1 = 1}
          if(! switch$1)return join(l,v,r)}
        return union(l,add(v,r))}
      function map(f,t)
       {if(t)
         {var
           r=t[3],
           v=t[2],
           l=t[1],
           l$0=map(f,l),
           v$0=caml_call1(f,v),
           r$0=map(f,r);
          if(l === l$0 && v === v$0 && r === r$0)return t;
          return try_join(l$0,v$0,r$0)}
        return 0}
      function try_concat(t1,t2)
       {if(t1)
         {if(t2)
           {var _bkP_=remove_min_elt(t2);
            return try_join(t1,min_elt(t2),_bkP_)}
          return t1}
        return t2}
      function filter_map(f,t)
       {if(t)
         {var
           r=t[3],
           v=t[2],
           l=t[1],
           l$0=filter_map(f,l),
           v$0=caml_call1(f,v),
           r$0=filter_map(f,r);
          if(v$0)
           {var v$1=v$0[1];
            if(l === l$0 && v === v$1 && r === r$0)return t;
            return try_join(l$0,v$1,r$0)}
          return try_concat(l$0,r$0)}
        return 0}
      function of_sorted_list(l)
       {function sub(n,l)
         {if(! (3 < n >>> 0))
           switch(n)
            {case 0:return [0,0,l];
             case 1:
              if(l){var l$3=l[2],x0=l[1];return [0,[0,0,x0,0,1],l$3]}break;
             case 2:
              if(l)
               {var _bkM_=l[2];
                if(_bkM_)
                 {var l$4=_bkM_[2],x1=_bkM_[1],x0$0=l[1];
                  return [0,[0,[0,0,x0$0,0,1],x1,0,2],l$4]}}
              break;
             default:
              if(l)
               {var _bkN_=l[2];
                if(_bkN_)
                 {var _bkO_=_bkN_[2];
                  if(_bkO_)
                   {var l$5=_bkO_[2],x2=_bkO_[1],x1$0=_bkN_[1],x0$1=l[1];
                    return [0,[0,[0,0,x0$1,0,1],x1$0,[0,0,x2,0,1],2],l$5]}}}}
          var nl=n / 2 | 0,match=sub(nl,l),l$0=match[2],left=match[1];
          if(l$0)
           {var
             l$1=l$0[2],
             mid=l$0[1],
             _bkL_=(n - nl | 0) - 1 | 0,
             match$0=sub(_bkL_,l$1),
             l$2=match$0[2],
             right=match$0[1];
            return [0,create(left,mid,right),l$2]}
          throw [0,Assert_failure,_X_]}
        var _bkK_=length(l);
        return sub(_bkK_,l)[1]}
      function of_list(l)
       {if(l)
         {var _bkv_=l[2],_bkw_=l[1];
          if(_bkv_)
           {var _bkx_=_bkv_[2],_bky_=_bkv_[1];
            if(_bkx_)
             {var _bkz_=_bkx_[2],_bkA_=_bkx_[1];
              if(_bkz_)
               {var _bkB_=_bkz_[2],_bkC_=_bkz_[1];
                if(_bkB_)
                 {if(_bkB_[2])
                   {var _bkD_=Ord[1];return of_sorted_list(sort_uniq(_bkD_,l))}
                  var
                   x4=_bkB_[1],
                   _bkE_=singleton(_bkw_),
                   _bkF_=add(_bky_,_bkE_),
                   _bkG_=add(_bkA_,_bkF_);
                  return add(x4,add(_bkC_,_bkG_))}
                var _bkH_=singleton(_bkw_),_bkI_=add(_bky_,_bkH_);
                return add(_bkC_,add(_bkA_,_bkI_))}
              var _bkJ_=singleton(_bkw_);
              return add(_bkA_,add(_bky_,_bkJ_))}
            return add(_bky_,singleton(_bkw_))}
          return singleton(_bkw_)}
        return empty}
      function add_seq(i,m)
       {return fold_left(function(s,x){return add(x,s)},m,i)}
      function of_seq(i){return add_seq(i,empty)}
      function seq_of_enum(c,param)
       {if(c)
         {var rest=c[3],t=c[2],x=c[1],_bkt_=cons_enum(t,rest);
          return [0,x,function(_bku_){return seq_of_enum(_bkt_,_bku_)}]}
        return 0}
      function to_seq(c)
       {var _bkq_=0,_bkr_=cons_enum(c,_bkq_);
        return function(_bks_){return seq_of_enum(_bkr_,_bks_)}}
      function snoc_enum(s,e)
       {var s$0=s,e$0=e;
        for(;;)
         {if(s$0)
           {var s$1=s$0[3],v=s$0[2],l=s$0[1],e$1=[0,v,l,e$0],s$0=s$1,e$0=e$1;
            continue}
          return e$0}}
      function rev_seq_of_enum(c,param)
       {if(c)
         {var rest=c[3],t=c[2],x=c[1],_bko_=snoc_enum(t,rest);
          return [0,x,function(_bkp_){return rev_seq_of_enum(_bko_,_bkp_)}]}
        return 0}
      function to_rev_seq(c)
       {var _bkl_=0,_bkm_=snoc_enum(c,_bkl_);
        return function(_bkn_){return rev_seq_of_enum(_bkm_,_bkn_)}}
      function to_seq_from(low,s)
       {function aux(low,s,c)
         {var s$0=s,c$0=c;
          for(;;)
           {if(s$0)
             {var
               r=s$0[3],
               v=s$0[2],
               l=s$0[1],
               _bkk_=Ord[1],
               n=caml_call2(_bkk_,v,low);
              if(0 === n)return [0,v,r,c$0];
              if(0 <= n){var c$1=[0,v,r,c$0],s$0=l,c$0=c$1;continue}
              var s$0=r;
              continue}
            return c$0}}
        var _bkh_=0,_bki_=aux(low,s,_bkh_);
        return function(_bkj_){return seq_of_enum(_bki_,_bkj_)}}
      return [0,
              height,
              create,
              bal,
              add,
              singleton,
              add_min_element,
              add_max_element,
              join,
              min_elt,
              min_elt_opt,
              max_elt,
              max_elt_opt,
              remove_min_elt,
              merge,
              concat,
              split,
              empty,
              is_empty,
              mem,
              remove,
              union,
              inter,
              split_bis,
              disjoint,
              diff,
              cons_enum,
              compare_aux,
              compare,
              equal,
              subset,
              iter,
              fold,
              for_all,
              exists,
              filter,
              partition,
              cardinal,
              elements_aux,
              elements,
              min_elt,
              min_elt_opt,
              find,
              find_first_aux,
              find_first,
              find_first_opt_aux,
              find_first_opt,
              find_last_aux,
              find_last,
              find_last_opt_aux,
              find_last_opt,
              find_opt,
              try_join,
              map,
              try_concat,
              filter_map,
              of_sorted_list,
              of_list,
              add_seq,
              of_seq,
              seq_of_enum,
              to_seq,
              snoc_enum,
              rev_seq_of_enum,
              to_rev_seq,
              to_seq_from]}
    function _Y_(_bkf_)
     {var _bkg_=Make(_bkf_);
      return [0,
              _bkg_[17],
              _bkg_[18],
              _bkg_[19],
              _bkg_[4],
              _bkg_[5],
              _bkg_[20],
              _bkg_[21],
              _bkg_[22],
              _bkg_[24],
              _bkg_[25],
              _bkg_[28],
              _bkg_[29],
              _bkg_[30],
              _bkg_[31],
              _bkg_[53],
              _bkg_[32],
              _bkg_[33],
              _bkg_[34],
              _bkg_[35],
              _bkg_[55],
              _bkg_[36],
              _bkg_[37],
              _bkg_[39],
              _bkg_[9],
              _bkg_[10],
              _bkg_[11],
              _bkg_[12],
              _bkg_[40],
              _bkg_[41],
              _bkg_[16],
              _bkg_[42],
              _bkg_[51],
              _bkg_[44],
              _bkg_[46],
              _bkg_[48],
              _bkg_[50],
              _bkg_[57],
              _bkg_[65],
              _bkg_[61],
              _bkg_[64],
              _bkg_[58],
              _bkg_[59]]}
    function Make$0(Ord)
     {function height(param){if(param){var h=param[5];return h}return 0}
      function create(l,x,d,r)
       {var hl=height(l),hr=height(r),_bke_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
        return [0,l,x,d,r,_bke_]}
      function singleton(x,d){return [0,0,x,d,0,1]}
      function bal(l,x,d,r)
       {if(l)var h=l[5],hl=h;else var hl=0;
        if(r)var h$0=r[5],hr=h$0;else var hr=0;
        if((hr + 2 | 0) < hl)
         {if(l)
           {var lr=l[4],ld=l[3],lv=l[2],ll=l[1],_bj$_=height(lr);
            if(_bj$_ <= height(ll))return create(ll,lv,ld,create(lr,x,d,r));
            if(lr)
             {var
               lrr=lr[4],
               lrd=lr[3],
               lrv=lr[2],
               lrl=lr[1],
               _bka_=create(lrr,x,d,r);
              return create(create(ll,lv,ld,lrl),lrv,lrd,_bka_)}
            return invalid_arg(_Z_)}
          return invalid_arg(___)}
        if((hl + 2 | 0) < hr)
         {if(r)
           {var rr=r[4],rd=r[3],rv=r[2],rl=r[1],_bkb_=height(rl);
            if(_bkb_ <= height(rr))return create(create(l,x,d,rl),rv,rd,rr);
            if(rl)
             {var
               rlr=rl[4],
               rld=rl[3],
               rlv=rl[2],
               rll=rl[1],
               _bkc_=create(rlr,rv,rd,rr);
              return create(create(l,x,d,rll),rlv,rld,_bkc_)}
            return invalid_arg(_$_)}
          return invalid_arg(_aa_)}
        var _bkd_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
        return [0,l,x,d,r,_bkd_]}
      var empty=0;
      function is_empty(param){return param?0:1}
      function add(x,data,m)
       {if(m)
         {var
           h=m[5],
           r=m[4],
           d=m[3],
           v=m[2],
           l=m[1],
           _bj__=Ord[1],
           c=caml_call2(_bj__,x,v);
          if(0 === c)return d === data?m:[0,l,x,data,r,h];
          if(0 <= c){var rr=add(x,data,r);return r === rr?m:bal(l,v,d,rr)}
          var ll=add(x,data,l);
          return l === ll?m:bal(ll,v,d,r)}
        return [0,0,x,data,0,1]}
      function find(x,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var
             r=param$0[4],
             d=param$0[3],
             v=param$0[2],
             l=param$0[1],
             _bj9_=Ord[1],
             c=caml_call2(_bj9_,x,v);
            if(0 === c)return d;
            var param$1=0 <= c?r:l,param$0=param$1;
            continue}
          throw Not_found}}
      function find_first_aux(v0,d0,f,param)
       {var v0$0=v0,d0$0=d0,param$0=param;
        for(;;)
         {if(param$0)
           {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
            if(caml_call1(f,v)){var v0$0=v,d0$0=d,param$0=l;continue}
            var param$0=r;
            continue}
          return [0,v0$0,d0$0]}}
      function find_first(f,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
            if(caml_call1(f,v))return find_first_aux(v,d,f,l);
            var param$0=r;
            continue}
          throw Not_found}}
      function find_first_opt_aux(v0,d0,f,param)
       {var v0$0=v0,d0$0=d0,param$0=param;
        for(;;)
         {if(param$0)
           {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
            if(caml_call1(f,v)){var v0$0=v,d0$0=d,param$0=l;continue}
            var param$0=r;
            continue}
          return [0,[0,v0$0,d0$0]]}}
      function find_first_opt(f,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
            if(caml_call1(f,v))return find_first_opt_aux(v,d,f,l);
            var param$0=r;
            continue}
          return 0}}
      function find_last_aux(v0,d0,f,param)
       {var v0$0=v0,d0$0=d0,param$0=param;
        for(;;)
         {if(param$0)
           {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
            if(caml_call1(f,v)){var v0$0=v,d0$0=d,param$0=r;continue}
            var param$0=l;
            continue}
          return [0,v0$0,d0$0]}}
      function find_last(f,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
            if(caml_call1(f,v))return find_last_aux(v,d,f,r);
            var param$0=l;
            continue}
          throw Not_found}}
      function find_last_opt_aux(v0,d0,f,param)
       {var v0$0=v0,d0$0=d0,param$0=param;
        for(;;)
         {if(param$0)
           {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
            if(caml_call1(f,v)){var v0$0=v,d0$0=d,param$0=r;continue}
            var param$0=l;
            continue}
          return [0,[0,v0$0,d0$0]]}}
      function find_last_opt(f,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
            if(caml_call1(f,v))return find_last_opt_aux(v,d,f,r);
            var param$0=l;
            continue}
          return 0}}
      function find_opt(x,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var
             r=param$0[4],
             d=param$0[3],
             v=param$0[2],
             l=param$0[1],
             _bj8_=Ord[1],
             c=caml_call2(_bj8_,x,v);
            if(0 === c)return [0,d];
            var param$1=0 <= c?r:l,param$0=param$1;
            continue}
          return 0}}
      function mem(x,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var
             r=param$0[4],
             v=param$0[2],
             l=param$0[1],
             _bj6_=Ord[1],
             c=caml_call2(_bj6_,x,v),
             _bj7_=0 === c?1:0;
            if(_bj7_)return _bj7_;
            var param$1=0 <= c?r:l,param$0=param$1;
            continue}
          return 0}}
      function min_binding(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var _bj5_=param$0[1];
            if(_bj5_){var param$0=_bj5_;continue}
            var d=param$0[3],v=param$0[2];
            return [0,v,d]}
          throw Not_found}}
      function min_binding_opt(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var _bj4_=param$0[1];
            if(_bj4_){var param$0=_bj4_;continue}
            var d=param$0[3],v=param$0[2];
            return [0,[0,v,d]]}
          return 0}}
      function max_binding(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {if(param$0[4]){var param$1=param$0[4],param$0=param$1;continue}
            var d=param$0[3],v=param$0[2];
            return [0,v,d]}
          throw Not_found}}
      function max_binding_opt(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {if(param$0[4]){var param$1=param$0[4],param$0=param$1;continue}
            var d=param$0[3],v=param$0[2];
            return [0,[0,v,d]]}
          return 0}}
      function remove_min_binding(param)
       {if(param)
         {var _bj3_=param[1];
          if(_bj3_)
           {var r=param[4],d=param[3],v=param[2];
            return bal(remove_min_binding(_bj3_),v,d,r)}
          var r$0=param[4];
          return r$0}
        return invalid_arg(_ab_)}
      function _bji_(t1,t2)
       {if(t1)
         {if(t2)
           {var match=min_binding(t2),d=match[2],x=match[1];
            return bal(t1,x,d,remove_min_binding(t2))}
          return t1}
        return t2}
      function remove(x,m)
       {if(m)
         {var
           r=m[4],
           d=m[3],
           v=m[2],
           l=m[1],
           _bj2_=Ord[1],
           c=caml_call2(_bj2_,x,v);
          if(0 === c)return _bji_(l,r);
          if(0 <= c){var rr=remove(x,r);return r === rr?m:bal(l,v,d,rr)}
          var ll=remove(x,l);
          return l === ll?m:bal(ll,v,d,r)}
        return 0}
      function update(x,f,m)
       {if(m)
         {var
           h=m[5],
           r=m[4],
           d=m[3],
           v=m[2],
           l=m[1],
           _bjZ_=Ord[1],
           c=caml_call2(_bjZ_,x,v);
          if(0 === c)
           {var _bj0_=[0,d],match=caml_call1(f,_bj0_);
            if(match){var data=match[1];return d === data?m:[0,l,x,data,r,h]}
            return _bji_(l,r)}
          if(0 <= c){var rr=update(x,f,r);return r === rr?m:bal(l,v,d,rr)}
          var ll=update(x,f,l);
          return l === ll?m:bal(ll,v,d,r)}
        var _bj1_=0,match$0=caml_call1(f,_bj1_);
        if(match$0){var data$0=match$0[1];return [0,0,x,data$0,0,1]}
        return 0}
      function iter(f,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
            iter(f,l);
            caml_call2(f,v,d);
            var param$0=r;
            continue}
          return 0}}
      function map(f,param)
       {if(param)
         {var
           h=param[5],
           r=param[4],
           d=param[3],
           v=param[2],
           l=param[1],
           l$0=map(f,l),
           d$0=caml_call1(f,d),
           r$0=map(f,r);
          return [0,l$0,v,d$0,r$0,h]}
        return 0}
      function mapi(f,param)
       {if(param)
         {var
           h=param[5],
           r=param[4],
           d=param[3],
           v=param[2],
           l=param[1],
           l$0=mapi(f,l),
           d$0=caml_call2(f,v,d),
           r$0=mapi(f,r);
          return [0,l$0,v,d$0,r$0,h]}
        return 0}
      function fold(f,m,accu)
       {var m$0=m,accu$0=accu;
        for(;;)
         {if(m$0)
           {var
             r=m$0[4],
             d=m$0[3],
             v=m$0[2],
             l=m$0[1],
             _bjY_=fold(f,l,accu$0),
             accu$1=caml_call3(f,v,d,_bjY_),
             m$0=r,
             accu$0=accu$1;
            continue}
          return accu$0}}
      function for_all(p,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var
             r=param$0[4],
             d=param$0[3],
             v=param$0[2],
             l=param$0[1],
             _bjV_=caml_call2(p,v,d);
            if(_bjV_)
             {var _bjW_=for_all(p,l);
              if(_bjW_){var param$0=r;continue}
              var _bjX_=_bjW_}
            else
             var _bjX_=_bjV_;
            return _bjX_}
          return 1}}
      function exists(p,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var
             r=param$0[4],
             d=param$0[3],
             v=param$0[2],
             l=param$0[1],
             _bjS_=caml_call2(p,v,d);
            if(_bjS_)
             var _bjT_=_bjS_;
            else
             {var _bjU_=exists(p,l);
              if(! _bjU_){var param$0=r;continue}
              var _bjT_=_bjU_}
            return _bjT_}
          return 0}}
      function add_min_binding(k,x,param)
       {if(param)
         {var r=param[4],d=param[3],v=param[2],l=param[1];
          return bal(add_min_binding(k,x,l),v,d,r)}
        return singleton(k,x)}
      function add_max_binding(k,x,param)
       {if(param)
         {var r=param[4],d=param[3],v=param[2],l=param[1];
          return bal(l,v,d,add_max_binding(k,x,r))}
        return singleton(k,x)}
      function join(l,v,d,r)
       {if(l)
         {if(r)
           {var
             rh=r[5],
             rr=r[4],
             rd=r[3],
             rv=r[2],
             rl=r[1],
             lh=l[5],
             lr=l[4],
             ld=l[3],
             lv=l[2],
             ll=l[1];
            return (rh + 2 | 0) < lh
                    ?bal(ll,lv,ld,join(lr,v,d,r))
                    :(lh + 2 | 0) < rh
                      ?bal(join(l,v,d,rl),rv,rd,rr)
                      :create(l,v,d,r)}
          return add_max_binding(v,d,l)}
        return add_min_binding(v,d,r)}
      function concat(t1,t2)
       {if(t1)
         {if(t2)
           {var match=min_binding(t2),d=match[2],x=match[1];
            return join(t1,x,d,remove_min_binding(t2))}
          return t1}
        return t2}
      function concat_or_join(t1,v,d,t2)
       {if(d){var d$0=d[1];return join(t1,v,d$0,t2)}return concat(t1,t2)}
      function split(x,param)
       {if(param)
         {var
           r=param[4],
           d=param[3],
           v=param[2],
           l=param[1],
           _bjR_=Ord[1],
           c=caml_call2(_bjR_,x,v);
          if(0 === c)return [0,l,[0,d],r];
          if(0 <= c)
           {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
            return [0,join(l,v,d,lr),pres,rr]}
          var
           match$0=split(x,l),
           rl=match$0[3],
           pres$0=match$0[2],
           ll=match$0[1];
          return [0,ll,pres$0,join(rl,v,d,r)]}
        return _ac_}
      function merge(f,s1,s2)
       {if(s1)
         {var h1=s1[5],r1=s1[4],d1=s1[3],v1=s1[2],l1=s1[1];
          if(height(s2) <= h1)
           {var
             match=split(v1,s2),
             r2=match[3],
             d2=match[2],
             l2=match[1],
             _bjL_=merge(f,r1,r2),
             _bjM_=[0,d1],
             _bjN_=caml_call3(f,v1,_bjM_,d2);
            return concat_or_join(merge(f,l1,l2),v1,_bjN_,_bjL_)}}
        else
         if(! s2)return 0;
        if(s2)
         {var
           r2$0=s2[4],
           d2$0=s2[3],
           v2=s2[2],
           l2$0=s2[1],
           match$0=split(v2,s1),
           r1$0=match$0[3],
           d1$0=match$0[2],
           l1$0=match$0[1],
           _bjO_=merge(f,r1$0,r2$0),
           _bjP_=[0,d2$0],
           _bjQ_=caml_call3(f,v2,d1$0,_bjP_);
          return concat_or_join(merge(f,l1$0,l2$0),v2,_bjQ_,_bjO_)}
        throw [0,Assert_failure,_ad_]}
      function union(f,s1,s2)
       {if(s1)
         {if(s2)
           {var
             h2=s2[5],
             r2=s2[4],
             d2=s2[3],
             v2=s2[2],
             l2=s2[1],
             h1=s1[5],
             r1=s1[4],
             d1=s1[3],
             v1=s1[2],
             l1=s1[1];
            if(h2 <= h1)
             {var
               match=split(v1,s2),
               r2$0=match[3],
               d2$0=match[2],
               l2$0=match[1],
               l=union(f,l1,l2$0),
               r=union(f,r1,r2$0);
              if(d2$0)
               {var d2$1=d2$0[1];
                return concat_or_join(l,v1,caml_call3(f,v1,d1,d2$1),r)}
              return join(l,v1,d1,r)}
            var
             match$0=split(v2,s1),
             r1$0=match$0[3],
             d1$0=match$0[2],
             l1$0=match$0[1],
             l$0=union(f,l1$0,l2),
             r$0=union(f,r1$0,r2);
            if(d1$0)
             {var d1$1=d1$0[1];
              return concat_or_join(l$0,v2,caml_call3(f,v2,d1$1,d2),r$0)}
            return join(l$0,v2,d2,r$0)}
          var s=s1}
        else
         var s=s2;
        return s}
      function filter(p,m)
       {if(m)
         {var
           r=m[4],
           d=m[3],
           v=m[2],
           l=m[1],
           l$0=filter(p,l),
           pvd=caml_call2(p,v,d),
           r$0=filter(p,r);
          if(pvd){if(l === l$0 && r === r$0)return m;return join(l$0,v,d,r$0)}
          return concat(l$0,r$0)}
        return 0}
      function filter_map(f,param)
       {if(param)
         {var
           r=param[4],
           d=param[3],
           v=param[2],
           l=param[1],
           l$0=filter_map(f,l),
           fvd=caml_call2(f,v,d),
           r$0=filter_map(f,r);
          if(fvd){var d$0=fvd[1];return join(l$0,v,d$0,r$0)}
          return concat(l$0,r$0)}
        return 0}
      function partition(p,param)
       {if(param)
         {var
           r=param[4],
           d=param[3],
           v=param[2],
           l=param[1],
           match=partition(p,l),
           lf=match[2],
           lt=match[1],
           pvd=caml_call2(p,v,d),
           match$0=partition(p,r),
           rf=match$0[2],
           rt=match$0[1];
          if(pvd){var _bjJ_=concat(lf,rf);return [0,join(lt,v,d,rt),_bjJ_]}
          var _bjK_=join(lf,v,d,rf);
          return [0,concat(lt,rt),_bjK_]}
        return _ae_}
      function cons_enum(m,e)
       {var m$0=m,e$0=e;
        for(;;)
         {if(m$0)
           {var
             r=m$0[4],
             d=m$0[3],
             v=m$0[2],
             m$1=m$0[1],
             e$1=[0,v,d,r,e$0],
             m$0=m$1,
             e$0=e$1;
            continue}
          return e$0}}
      function compare(cmp,m1,m2)
       {function compare_aux(e1,e2)
         {var e1$0=e1,e2$0=e2;
          for(;;)
           {if(e1$0)
             {if(e2$0)
               {var
                 e2$1=e2$0[4],
                 r2=e2$0[3],
                 d2=e2$0[2],
                 v2=e2$0[1],
                 e1$1=e1$0[4],
                 r1=e1$0[3],
                 d1=e1$0[2],
                 v1=e1$0[1],
                 _bjI_=Ord[1],
                 c=caml_call2(_bjI_,v1,v2);
                if(0 === c)
                 {var c$0=caml_call2(cmp,d1,d2);
                  if(0 === c$0)
                   {var
                     e2$2=cons_enum(r2,e2$1),
                     e1$2=cons_enum(r1,e1$1),
                     e1$0=e1$2,
                     e2$0=e2$2;
                    continue}
                  return c$0}
                return c}
              return 1}
            return e2$0?-1:0}}
        var _bjF_=0,_bjG_=cons_enum(m2,_bjF_),_bjH_=0;
        return compare_aux(cons_enum(m1,_bjH_),_bjG_)}
      function equal(cmp,m1,m2)
       {function equal_aux(e1,e2)
         {var e1$0=e1,e2$0=e2;
          for(;;)
           {if(e1$0)
             {if(e2$0)
               {var
                 e2$1=e2$0[4],
                 r2=e2$0[3],
                 d2=e2$0[2],
                 v2=e2$0[1],
                 e1$1=e1$0[4],
                 r1=e1$0[3],
                 d1=e1$0[2],
                 v1=e1$0[1],
                 _bjB_=Ord[1],
                 _bjC_=0 === caml_call2(_bjB_,v1,v2)?1:0;
                if(_bjC_)
                 {var _bjD_=caml_call2(cmp,d1,d2);
                  if(_bjD_)
                   {var
                     e2$2=cons_enum(r2,e2$1),
                     e1$2=cons_enum(r1,e1$1),
                     e1$0=e1$2,
                     e2$0=e2$2;
                    continue}
                  var _bjE_=_bjD_}
                else
                 var _bjE_=_bjC_;
                return _bjE_}
              return 0}
            return e2$0?0:1}}
        var _bjy_=0,_bjz_=cons_enum(m2,_bjy_),_bjA_=0;
        return equal_aux(cons_enum(m1,_bjA_),_bjz_)}
      function cardinal(param)
       {if(param)
         {var r=param[4],l=param[1],_bjx_=cardinal(r);
          return (cardinal(l) + 1 | 0) + _bjx_ | 0}
        return 0}
      function bindings_aux(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var
             r=param$0[4],
             d=param$0[3],
             v=param$0[2],
             l=param$0[1],
             accu$1=[0,[0,v,d],bindings_aux(accu$0,r)],
             accu$0=accu$1,
             param$0=l;
            continue}
          return accu$0}}
      function bindings(s){return bindings_aux(0,s)}
      function add_seq(i,m)
       {return fold_left
                (function(m,param)
                  {var v=param[2],k=param[1];return add(k,v,m)},
                 m,
                 i)}
      function of_seq(i){return add_seq(i,empty)}
      function seq_of_enum(c,param)
       {if(c)
         {var rest=c[4],t=c[3],v=c[2],k=c[1],_bjv_=cons_enum(t,rest);
          return [0,[0,k,v],function(_bjw_){return seq_of_enum(_bjv_,_bjw_)}]}
        return 0}
      function to_seq(m)
       {var _bjs_=0,_bjt_=cons_enum(m,_bjs_);
        return function(_bju_){return seq_of_enum(_bjt_,_bju_)}}
      function snoc_enum(s,e)
       {var s$0=s,e$0=e;
        for(;;)
         {if(s$0)
           {var
             s$1=s$0[4],
             d=s$0[3],
             v=s$0[2],
             l=s$0[1],
             e$1=[0,v,d,l,e$0],
             s$0=s$1,
             e$0=e$1;
            continue}
          return e$0}}
      function rev_seq_of_enum(c,param)
       {if(c)
         {var rest=c[4],t=c[3],v=c[2],k=c[1],_bjq_=snoc_enum(t,rest);
          return [0,
                  [0,k,v],
                  function(_bjr_){return rev_seq_of_enum(_bjq_,_bjr_)}]}
        return 0}
      function to_rev_seq(c)
       {var _bjn_=0,_bjo_=snoc_enum(c,_bjn_);
        return function(_bjp_){return rev_seq_of_enum(_bjo_,_bjp_)}}
      function to_seq_from(low,m)
       {function aux(low,m,c)
         {var m$0=m,c$0=c;
          for(;;)
           {if(m$0)
             {var
               r=m$0[4],
               d=m$0[3],
               v=m$0[2],
               l=m$0[1],
               _bjm_=Ord[1],
               n=caml_call2(_bjm_,v,low);
              if(0 === n)return [0,v,d,r,c$0];
              if(0 <= n){var c$1=[0,v,d,r,c$0],m$0=l,c$0=c$1;continue}
              var m$0=r;
              continue}
            return c$0}}
        var _bjj_=0,_bjk_=aux(low,m,_bjj_);
        return function(_bjl_){return seq_of_enum(_bjk_,_bjl_)}}
      return [0,
              height,
              create,
              singleton,
              bal,
              empty,
              is_empty,
              add,
              find,
              find_first_aux,
              find_first,
              find_first_opt_aux,
              find_first_opt,
              find_last_aux,
              find_last,
              find_last_opt_aux,
              find_last_opt,
              find_opt,
              mem,
              min_binding,
              min_binding_opt,
              max_binding,
              max_binding_opt,
              remove_min_binding,
              remove,
              update,
              iter,
              map,
              mapi,
              fold,
              for_all,
              exists,
              add_min_binding,
              add_max_binding,
              join,
              concat,
              concat_or_join,
              split,
              merge,
              union,
              filter,
              filter_map,
              partition,
              cons_enum,
              compare,
              equal,
              cardinal,
              bindings_aux,
              bindings,
              min_binding,
              min_binding_opt,
              add_seq,
              of_seq,
              seq_of_enum,
              to_seq,
              snoc_enum,
              rev_seq_of_enum,
              to_rev_seq,
              to_seq_from]}
    function _af_(_bjg_)
     {var _bjh_=Make$0(_bjg_);
      return [0,
              _bjh_[5],
              _bjh_[6],
              _bjh_[18],
              _bjh_[7],
              _bjh_[25],
              _bjh_[3],
              _bjh_[24],
              _bjh_[38],
              _bjh_[39],
              _bjh_[44],
              _bjh_[45],
              _bjh_[26],
              _bjh_[29],
              _bjh_[30],
              _bjh_[31],
              _bjh_[40],
              _bjh_[41],
              _bjh_[42],
              _bjh_[46],
              _bjh_[48],
              _bjh_[19],
              _bjh_[20],
              _bjh_[21],
              _bjh_[22],
              _bjh_[49],
              _bjh_[50],
              _bjh_[37],
              _bjh_[8],
              _bjh_[17],
              _bjh_[10],
              _bjh_[12],
              _bjh_[14],
              _bjh_[16],
              _bjh_[27],
              _bjh_[28],
              _bjh_[54],
              _bjh_[57],
              _bjh_[58],
              _bjh_[51],
              _bjh_[52]]}
    var Empty=[248,_ag_,caml_fresh_oo_id(0)];
    function create(param){return [0,0,0]}
    function clear(s){s[1] = 0;s[2] = 0;return 0}
    function push(x,s){s[1] = [0,x,s[1]];s[2] = s[2] + 1 | 0;return 0}
    function pop(s)
     {var _bjf_=s[1];
      if(_bjf_)
       {var tl=_bjf_[2],hd=_bjf_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return hd}
      throw Empty}
    function pop_opt(s)
     {var _bje_=s[1];
      if(_bje_)
       {var tl=_bje_[2],hd=_bje_[1];
        s[1] = tl;
        s[2] = s[2] - 1 | 0;
        return [0,hd]}
      return 0}
    function top(s)
     {var _bjd_=s[1];if(_bjd_){var hd=_bjd_[1];return hd}throw Empty}
    function top_opt(s)
     {var _bjc_=s[1];if(_bjc_){var hd=_bjc_[1];return [0,hd]}return 0}
    function is_empty(s){return 0 === s[1]?1:0}
    function iter$3(f,s){return iter$0(f,s[1])}
    var Empty$0=[248,_ah_,caml_fresh_oo_id(0)];
    function create$0(param){return [0,0,0,0]}
    function clear$0(q){q[1] = 0;q[2] = 0;q[3] = 0;return 0}
    function add(x,q)
     {var cell=[0,x,0],_bjb_=q[3];
      return _bjb_
              ?(q[1] = q[1] + 1 | 0,_bjb_[2] = cell,q[3] = cell,0)
              :(q[1] = 1,q[2] = cell,q[3] = cell,0)}
    function peek_opt(q)
     {var _bja_=q[2];
      if(_bja_){var content=_bja_[1];return [0,content]}
      return 0}
    function take(q)
     {var _bi__=q[2];
      if(_bi__)
       {var _bi$_=_bi__[1];
        if(_bi__[2])
         {var next=_bi__[2];q[1] = q[1] - 1 | 0;q[2] = next;return _bi$_}
        clear$0(q);
        return _bi$_}
      throw Empty$0}
    function take_opt(q)
     {var _bi8_=q[2];
      if(_bi8_)
       {var _bi9_=_bi8_[1];
        if(_bi8_[2])
         {var next=_bi8_[2];q[1] = q[1] - 1 | 0;q[2] = next;return [0,_bi9_]}
        clear$0(q);
        return [0,_bi9_]}
      return 0}
    function is_empty$0(q){return 0 === q[1]?1:0}
    function create$1(n)
     {var
       n$0=1 <= n?n:1,
       n$1=max_string_length < n$0?max_string_length:n$0,
       s=caml_create_bytes(n$1);
      return [0,s,0,n$1,s]}
    function contents(b){return sub_string(b[1],0,b[2])}
    function sub$2(b,ofs,len)
     {if(0 <= ofs && 0 <= len && ! ((b[2] - len | 0) < ofs))
       return sub_string(b[1],ofs,len);
      return invalid_arg(_ai_)}
    function length$0(b){return b[2]}
    function clear$1(b){b[2] = 0;return 0}
    function reset(b)
     {b[2] = 0;b[1] = b[4];b[3] = caml_ml_bytes_length(b[1]);return 0}
    function resize(b,more)
     {var old_pos=b[2],old_len=b[3],new_len=[0,old_len];
      for(;;)
       {if(new_len[1] < (old_pos + more | 0))
         {new_len[1] = 2 * new_len[1] | 0;continue}
        if(max_string_length < new_len[1])
         if((old_pos + more | 0) <= max_string_length)
          new_len[1] = max_string_length;
         else
          failwith(_al_);
        var
         _bi3_=new_len[1],
         new_buffer=caml_create_bytes(_bi3_),
         _bi4_=b[2],
         _bi5_=0,
         _bi6_=0,
         _bi7_=b[1];
        blit(_bi7_,_bi6_,new_buffer,_bi5_,_bi4_);
        b[1] = new_buffer;
        b[3] = new_len[1];
        if((b[2] + more | 0) <= b[3])
         {if((old_pos + more | 0) <= b[3])return 0;
          throw [0,Assert_failure,_aj_]}
        throw [0,Assert_failure,_ak_]}}
    function add_char(b,c)
     {var pos=b[2];
      if(b[3] <= pos){var _bi2_=1;resize(b,_bi2_)}
      caml_bytes_unsafe_set(b[1],pos,c);
      b[2] = pos + 1 | 0;
      return 0}
    function add_substring(b,s,offset,len)
     {var _biX_=offset < 0?1:0;
      if(_biX_)
       var _biY_=_biX_;
      else
       var
        _bi1_=len < 0?1:0,
        _biY_=_bi1_ || ((caml_ml_string_length(s) - len | 0) < offset?1:0);
      if(_biY_)invalid_arg(_am_);
      var new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      var _biZ_=b[2],_bi0_=b[1];
      caml_blit_string(s,offset,_bi0_,_biZ_,len);
      b[2] = new_position;
      return 0}
    function add_string(b,s)
     {var len=caml_ml_string_length(s),new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      var _biV_=b[2],_biW_=b[1];
      caml_blit_string(s,0,_biW_,_biV_,len);
      b[2] = new_position;
      return 0}
    function create_char_set(param){return make$0(32,0)}
    function add_in_char_set(char_set,c)
     {var
       str_ind=c >>> 3 | 0,
       mask=1 << (c & 7),
       _biT_=caml_bytes_get(char_set,str_ind) | mask,
       _biU_=char_of_int(_biT_);
      return caml_bytes_set(char_set,str_ind,_biU_)}
    function freeze_char_set(char_set){return of_bytes(char_set)}
    function rev_char_set(char_set)
     {var _biP_=0,char_set$0=create_char_set(_biP_),i=0;
      for(;;)
       {var _biQ_=caml_string_get(char_set,i) ^ 255,_biR_=char_of_int(_biQ_);
        caml_bytes_set(char_set$0,i,_biR_);
        var _biS_=i + 1 | 0;
        if(31 !== i){var i=_biS_;continue}
        return usob(char_set$0)}}
    function is_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return 0 !== (caml_string_get(char_set,str_ind) & mask)?1:0}
    function pad_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return [0,1,width]}return 0}
    function prec_of_prec_opt(prec_opt)
     {if(prec_opt){var ndec=prec_opt[1];return [0,ndec]}return 0}
    function param_format_of_ignored_format(ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:return [0,[0,fmt]];
         case 1:return [0,[1,fmt]];
         case 2:return [0,[19,fmt]];
         default:return [0,[22,fmt]]}
      else
       switch(ign[0])
        {case 0:var pad_opt=ign[1];return [0,[2,pad_of_pad_opt(pad_opt),fmt]];
         case 1:
          var pad_opt$0=ign[1];return [0,[3,pad_of_pad_opt(pad_opt$0),fmt]];
         case 2:
          var pad_opt$1=ign[2],iconv=ign[1],_biK_=0;
          return [0,[4,iconv,pad_of_pad_opt(pad_opt$1),_biK_,fmt]];
         case 3:
          var pad_opt$2=ign[2],iconv$0=ign[1],_biL_=0;
          return [0,[5,iconv$0,pad_of_pad_opt(pad_opt$2),_biL_,fmt]];
         case 4:
          var pad_opt$3=ign[2],iconv$1=ign[1],_biM_=0;
          return [0,[6,iconv$1,pad_of_pad_opt(pad_opt$3),_biM_,fmt]];
         case 5:
          var pad_opt$4=ign[2],iconv$2=ign[1],_biN_=0;
          return [0,[7,iconv$2,pad_of_pad_opt(pad_opt$4),_biN_,fmt]];
         case 6:
          var
           prec_opt=ign[2],
           pad_opt$5=ign[1],
           _biO_=prec_of_prec_opt(prec_opt);
          return [0,[8,_an_,pad_of_pad_opt(pad_opt$5),_biO_,fmt]];
         case 7:
          var pad_opt$6=ign[1];return [0,[9,pad_of_pad_opt(pad_opt$6),fmt]];
         case 8:
          var fmtty=ign[2],pad_opt$7=ign[1];
          return [0,[13,pad_opt$7,fmtty,fmt]];
         case 9:
          var fmtty$0=ign[2],pad_opt$8=ign[1];
          return [0,[14,pad_opt$8,fmtty$0,fmt]];
         case 10:
          var char_set=ign[2],width_opt=ign[1];
          return [0,[20,width_opt,char_set,fmt]];
         default:var counter=ign[1];return [0,[21,counter,fmt]]}}
    function default_float_precision(fconv){return 5 === fconv[2]?12:-6}
    function buffer_create(init_size)
     {return [0,0,caml_create_bytes(init_size)]}
    function buffer_check_size(buf,overhead)
     {var
       len=caml_ml_bytes_length(buf[2]),
       min_len=buf[1] + overhead | 0,
       _biE_=len < min_len?1:0;
      if(_biE_)
       {var
         _biF_=len * 2 | 0,
         new_len=max$0(_biF_,min_len),
         new_str=caml_create_bytes(new_len),
         _biG_=0,
         _biH_=0,
         _biI_=buf[2];
        blit(_biI_,_biH_,new_str,_biG_,len);
        buf[2] = new_str;
        var _biJ_=0}
      else
       var _biJ_=_biE_;
      return _biJ_}
    function buffer_add_char(buf,c)
     {var _biB_=1;
      buffer_check_size(buf,_biB_);
      var _biC_=buf[1],_biD_=buf[2];
      caml_bytes_set(_biD_,_biC_,c);
      buf[1] = buf[1] + 1 | 0;
      return 0}
    function buffer_add_string(buf,s)
     {var str_len=caml_ml_string_length(s);
      buffer_check_size(buf,str_len);
      var _biy_=buf[1],_biz_=buf[2],_biA_=0;
      blit$0(s,_biA_,_biz_,_biy_,str_len);
      buf[1] = buf[1] + str_len | 0;
      return 0}
    function buffer_contents(buf){return sub_string(buf[2],0,buf[1])}
    function char_of_iconv(iconv)
     {switch(iconv)
       {case 6:
        case 7:return 120;
        case 8:
        case 9:return 88;
        case 10:
        case 11:return 111;
        case 12:
        case 15:return 117;
        case 0:
        case 1:
        case 2:
        case 13:return 100;
        default:return 105}}
    function char_of_fconv(opt,fconv)
     {if(opt)var sth=opt[1],cF=sth;else var cF=70;
      switch(fconv[2])
       {case 0:return 102;
        case 1:return 101;
        case 2:return 69;
        case 3:return 103;
        case 4:return 71;
        case 5:return cF;
        case 6:return 104;
        case 7:return 72;
        default:return 70}}
    function bprint_fconv_flag(buf,fconv)
     {switch(fconv[1])
       {case 0:break;
        case 1:var _biw_=43;buffer_add_char(buf,_biw_);break;
        default:var _bix_=32;buffer_add_char(buf,_bix_)}
      return 8 <= fconv[2]?buffer_add_char(buf,35):0}
    function string_of_formatting_lit(formatting_lit)
     {if(typeof formatting_lit === "number")
       switch(formatting_lit)
        {case 0:return _ao_;
         case 1:return _ap_;
         case 2:return _aq_;
         case 3:return _ar_;
         case 4:return _as_;
         case 5:return _at_;
         default:return _au_}
      else
       switch(formatting_lit[0])
        {case 0:var str=formatting_lit[1];return str;
         case 1:var str$0=formatting_lit[1];return str$0;
         default:
          var c=formatting_lit[1],_biv_=1;return cat(_av_,make$1(_biv_,c))}}
    function bprint_fmtty(buf,fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:
           var rest=fmtty$0[1];
           buffer_add_string(buf,_aw_);
           var fmtty$0=rest;
           continue;
          case 1:
           var rest$0=fmtty$0[1];
           buffer_add_string(buf,_ax_);
           var fmtty$0=rest$0;
           continue;
          case 2:
           var rest$1=fmtty$0[1];
           buffer_add_string(buf,_ay_);
           var fmtty$0=rest$1;
           continue;
          case 3:
           var rest$2=fmtty$0[1];
           buffer_add_string(buf,_az_);
           var fmtty$0=rest$2;
           continue;
          case 4:
           var rest$3=fmtty$0[1];
           buffer_add_string(buf,_aA_);
           var fmtty$0=rest$3;
           continue;
          case 5:
           var rest$4=fmtty$0[1];
           buffer_add_string(buf,_aB_);
           var fmtty$0=rest$4;
           continue;
          case 6:
           var rest$5=fmtty$0[1];
           buffer_add_string(buf,_aC_);
           var fmtty$0=rest$5;
           continue;
          case 7:
           var rest$6=fmtty$0[1];
           buffer_add_string(buf,_aD_);
           var fmtty$0=rest$6;
           continue;
          case 8:
           var rest$7=fmtty$0[2],sub_fmtty=fmtty$0[1];
           buffer_add_string(buf,_aE_);
           bprint_fmtty(buf,sub_fmtty);
           buffer_add_string(buf,_aF_);
           var fmtty$0=rest$7;
           continue;
          case 9:
           var rest$8=fmtty$0[3],sub_fmtty$0=fmtty$0[1];
           buffer_add_string(buf,_aG_);
           bprint_fmtty(buf,sub_fmtty$0);
           buffer_add_string(buf,_aH_);
           var fmtty$0=rest$8;
           continue;
          case 10:
           var rest$9=fmtty$0[1];
           buffer_add_string(buf,_aI_);
           var fmtty$0=rest$9;
           continue;
          case 11:
           var rest$10=fmtty$0[1];
           buffer_add_string(buf,_aJ_);
           var fmtty$0=rest$10;
           continue;
          case 12:
           var rest$11=fmtty$0[1];
           buffer_add_string(buf,_aK_);
           var fmtty$0=rest$11;
           continue;
          case 13:
           var rest$12=fmtty$0[1];
           buffer_add_string(buf,_aL_);
           var fmtty$0=rest$12;
           continue;
          default:
           var rest$13=fmtty$0[1];
           buffer_add_string(buf,_aM_);
           var fmtty$0=rest$13;
           continue}}
    function symm(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,symm(rest)];
         case 1:var rest$0=param[1];return [1,symm(rest$0)];
         case 2:var rest$1=param[1];return [2,symm(rest$1)];
         case 3:var rest$2=param[1];return [3,symm(rest$2)];
         case 4:var rest$3=param[1];return [4,symm(rest$3)];
         case 5:var rest$4=param[1];return [5,symm(rest$4)];
         case 6:var rest$5=param[1];return [6,symm(rest$5)];
         case 7:var rest$6=param[1];return [7,symm(rest$6)];
         case 8:var rest$7=param[2],ty=param[1];return [8,ty,symm(rest$7)];
         case 9:
          var rest$8=param[3],ty2=param[2],ty1=param[1];
          return [9,ty2,ty1,symm(rest$8)];
         case 10:var rest$9=param[1];return [10,symm(rest$9)];
         case 11:var rest$10=param[1];return [11,symm(rest$10)];
         case 12:var rest$11=param[1];return [12,symm(rest$11)];
         case 13:var rest$12=param[1];return [13,symm(rest$12)];
         default:var rest$13=param[1];return [14,symm(rest$13)]}}
    function trans(ty1,ty2)
     {var switch$0=0;
      if(typeof ty1 === "number")
       if(typeof ty2 === "number")
        return 0;
       else
        switch(ty2[0])
         {case 10:break;
          case 11:switch$0 = 1;break;
          case 12:switch$0 = 2;break;
          case 13:switch$0 = 3;break;
          case 14:switch$0 = 4;break;
          case 8:switch$0 = 5;break;
          case 9:switch$0 = 6;break;
          default:throw [0,Assert_failure,_aN_]}
      else
       switch(ty1[0])
        {case 0:
          var switch$1=0,_bh$_=ty1[1];
          if(typeof ty2 !== "number")
           switch(ty2[0])
            {case 0:var rest2=ty2[1];return [0,trans(_bh$_,rest2)];
             case 8:switch$0 = 5;switch$1 = 1;break;
             case 9:switch$0 = 6;switch$1 = 1;break;
             case 10:switch$1 = 1;break;
             case 11:switch$0 = 1;switch$1 = 1;break;
             case 12:switch$0 = 2;switch$1 = 1;break;
             case 13:switch$0 = 3;switch$1 = 1;break;
             case 14:switch$0 = 4;switch$1 = 1;break
             }
          if(! switch$1)switch$0 = 7;
          break;
         case 1:
          var switch$2=0,_bia_=ty1[1];
          if(typeof ty2 !== "number")
           switch(ty2[0])
            {case 1:var rest2$0=ty2[1];return [1,trans(_bia_,rest2$0)];
             case 8:switch$0 = 5;switch$2 = 1;break;
             case 9:switch$0 = 6;switch$2 = 1;break;
             case 10:switch$2 = 1;break;
             case 11:switch$0 = 1;switch$2 = 1;break;
             case 12:switch$0 = 2;switch$2 = 1;break;
             case 13:switch$0 = 3;switch$2 = 1;break;
             case 14:switch$0 = 4;switch$2 = 1;break
             }
          if(! switch$2)switch$0 = 7;
          break;
         case 2:
          var switch$3=0,_bib_=ty1[1];
          if(typeof ty2 === "number")
           switch$3 = 1;
          else
           switch(ty2[0])
            {case 2:var rest2$1=ty2[1];return [2,trans(_bib_,rest2$1)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$3 = 1}
          if(switch$3)switch$0 = 7;
          break;
         case 3:
          var switch$4=0,_bic_=ty1[1];
          if(typeof ty2 === "number")
           switch$4 = 1;
          else
           switch(ty2[0])
            {case 3:var rest2$2=ty2[1];return [3,trans(_bic_,rest2$2)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$4 = 1}
          if(switch$4)switch$0 = 7;
          break;
         case 4:
          var switch$5=0,_bid_=ty1[1];
          if(typeof ty2 === "number")
           switch$5 = 1;
          else
           switch(ty2[0])
            {case 4:var rest2$3=ty2[1];return [4,trans(_bid_,rest2$3)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$5 = 1}
          if(switch$5)switch$0 = 7;
          break;
         case 5:
          var switch$6=0,_bie_=ty1[1];
          if(typeof ty2 === "number")
           switch$6 = 1;
          else
           switch(ty2[0])
            {case 5:var rest2$4=ty2[1];return [5,trans(_bie_,rest2$4)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$6 = 1}
          if(switch$6)switch$0 = 7;
          break;
         case 6:
          var switch$7=0,_bif_=ty1[1];
          if(typeof ty2 === "number")
           switch$7 = 1;
          else
           switch(ty2[0])
            {case 6:var rest2$5=ty2[1];return [6,trans(_bif_,rest2$5)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$7 = 1}
          if(switch$7)switch$0 = 7;
          break;
         case 7:
          var switch$8=0,_big_=ty1[1];
          if(typeof ty2 === "number")
           switch$8 = 1;
          else
           switch(ty2[0])
            {case 7:var rest2$6=ty2[1];return [7,trans(_big_,rest2$6)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$8 = 1}
          if(switch$8)switch$0 = 7;
          break;
         case 8:
          var switch$9=0,_bih_=ty1[2],_bii_=ty1[1];
          if(typeof ty2 === "number")
           switch$9 = 1;
          else
           switch(ty2[0])
            {case 8:
              var rest2$7=ty2[2],ty2$0=ty2[1],_bij_=trans(_bih_,rest2$7);
              return [8,trans(_bii_,ty2$0),_bij_];
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$9 = 1}
          if(switch$9)throw [0,Assert_failure,_aW_];
          break;
         case 9:
          var switch$10=0,_bik_=ty1[3],_bil_=ty1[2],_bim_=ty1[1];
          if(typeof ty2 === "number")
           switch$10 = 1;
          else
           switch(ty2[0])
            {case 8:switch$0 = 5;break;
             case 9:
              var
               rest2$8=ty2[3],
               ty22=ty2[2],
               ty21=ty2[1],
               _bin_=symm(_bil_),
               ty=trans(_bin_,ty21),
               match=fmtty_rel_det(ty),
               f4=match[4],
               f2=match[2],
               _bio_=0;
              caml_call1(f2,_bio_);
              var _bip_=0;
              caml_call1(f4,_bip_);
              return [9,_bim_,ty22,trans(_bik_,rest2$8)];
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$10 = 1}
          if(switch$10)throw [0,Assert_failure,_aX_];
          break;
         case 10:
          var _biq_=ty1[1];
          if(typeof ty2 !== "number" && 10 === ty2[0])
           {var rest2$9=ty2[1];return [10,trans(_biq_,rest2$9)]}
          throw [0,Assert_failure,_aY_];
         case 11:
          var switch$11=0,_bir_=ty1[1];
          if(typeof ty2 === "number")
           switch$11 = 1;
          else
           switch(ty2[0])
            {case 10:break;
             case 11:var rest2$10=ty2[1];return [11,trans(_bir_,rest2$10)];
             default:switch$11 = 1}
          if(switch$11)throw [0,Assert_failure,_aZ_];
          break;
         case 12:
          var switch$12=0,_bis_=ty1[1];
          if(typeof ty2 === "number")
           switch$12 = 1;
          else
           switch(ty2[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:var rest2$11=ty2[1];return [12,trans(_bis_,rest2$11)];
             default:switch$12 = 1}
          if(switch$12)throw [0,Assert_failure,_a0_];
          break;
         case 13:
          var switch$13=0,_bit_=ty1[1];
          if(typeof ty2 === "number")
           switch$13 = 1;
          else
           switch(ty2[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:var rest2$12=ty2[1];return [13,trans(_bit_,rest2$12)];
             default:switch$13 = 1}
          if(switch$13)throw [0,Assert_failure,_a1_];
          break;
         default:
          var switch$14=0,_biu_=ty1[1];
          if(typeof ty2 === "number")
           switch$14 = 1;
          else
           switch(ty2[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:var rest2$13=ty2[1];return [14,trans(_biu_,rest2$13)];
             default:switch$14 = 1}
          if(switch$14)throw [0,Assert_failure,_a2_]}
      switch(switch$0)
       {case 0:throw [0,Assert_failure,_aQ_];
        case 1:throw [0,Assert_failure,_aR_];
        case 2:throw [0,Assert_failure,_aS_];
        case 3:throw [0,Assert_failure,_aT_];
        case 4:throw [0,Assert_failure,_aU_];
        case 5:throw [0,Assert_failure,_aO_];
        case 6:throw [0,Assert_failure,_aP_];
        default:throw [0,Assert_failure,_aV_]}}
    function fmtty_rel_det(param)
     {if(typeof param === "number")
       {var
         _bg__=function(param){return 0},
         _bg$_=function(param){return 0},
         _bha_=function(param){return 0};
        return [0,function(param){return 0},_bha_,_bg$_,_bg__]}
      else
       switch(param[0])
        {case 0:
          var
           rest=param[1],
           match=fmtty_rel_det(rest),
           de=match[4],
           ed=match[3],
           af=match[2],
           fa=match[1],
           _bhb_=function(param){var _bh6_=0;caml_call1(af,_bh6_);return 0};
          return [0,
                  function(param){var _bh5_=0;caml_call1(fa,_bh5_);return 0},
                  _bhb_,
                  ed,
                  de];
         case 1:
          var
           rest$0=param[1],
           match$0=fmtty_rel_det(rest$0),
           de$0=match$0[4],
           ed$0=match$0[3],
           af$0=match$0[2],
           fa$0=match$0[1],
           _bhc_=function(param){var _bh4_=0;caml_call1(af$0,_bh4_);return 0};
          return [0,
                  function(param){var _bh3_=0;caml_call1(fa$0,_bh3_);return 0},
                  _bhc_,
                  ed$0,
                  de$0];
         case 2:
          var
           rest$1=param[1],
           match$1=fmtty_rel_det(rest$1),
           de$1=match$1[4],
           ed$1=match$1[3],
           af$1=match$1[2],
           fa$1=match$1[1],
           _bhd_=function(param){var _bh2_=0;caml_call1(af$1,_bh2_);return 0};
          return [0,
                  function(param){var _bh1_=0;caml_call1(fa$1,_bh1_);return 0},
                  _bhd_,
                  ed$1,
                  de$1];
         case 3:
          var
           rest$2=param[1],
           match$2=fmtty_rel_det(rest$2),
           de$2=match$2[4],
           ed$2=match$2[3],
           af$2=match$2[2],
           fa$2=match$2[1],
           _bhe_=function(param){var _bh0_=0;caml_call1(af$2,_bh0_);return 0};
          return [0,
                  function(param){var _bhZ_=0;caml_call1(fa$2,_bhZ_);return 0},
                  _bhe_,
                  ed$2,
                  de$2];
         case 4:
          var
           rest$3=param[1],
           match$3=fmtty_rel_det(rest$3),
           de$3=match$3[4],
           ed$3=match$3[3],
           af$3=match$3[2],
           fa$3=match$3[1],
           _bhf_=function(param){var _bhY_=0;caml_call1(af$3,_bhY_);return 0};
          return [0,
                  function(param){var _bhX_=0;caml_call1(fa$3,_bhX_);return 0},
                  _bhf_,
                  ed$3,
                  de$3];
         case 5:
          var
           rest$4=param[1],
           match$4=fmtty_rel_det(rest$4),
           de$4=match$4[4],
           ed$4=match$4[3],
           af$4=match$4[2],
           fa$4=match$4[1],
           _bhg_=function(param){var _bhW_=0;caml_call1(af$4,_bhW_);return 0};
          return [0,
                  function(param){var _bhV_=0;caml_call1(fa$4,_bhV_);return 0},
                  _bhg_,
                  ed$4,
                  de$4];
         case 6:
          var
           rest$5=param[1],
           match$5=fmtty_rel_det(rest$5),
           de$5=match$5[4],
           ed$5=match$5[3],
           af$5=match$5[2],
           fa$5=match$5[1],
           _bhh_=function(param){var _bhU_=0;caml_call1(af$5,_bhU_);return 0};
          return [0,
                  function(param){var _bhT_=0;caml_call1(fa$5,_bhT_);return 0},
                  _bhh_,
                  ed$5,
                  de$5];
         case 7:
          var
           rest$6=param[1],
           match$6=fmtty_rel_det(rest$6),
           de$6=match$6[4],
           ed$6=match$6[3],
           af$6=match$6[2],
           fa$6=match$6[1],
           _bhi_=function(param){var _bhS_=0;caml_call1(af$6,_bhS_);return 0};
          return [0,
                  function(param){var _bhR_=0;caml_call1(fa$6,_bhR_);return 0},
                  _bhi_,
                  ed$6,
                  de$6];
         case 8:
          var
           rest$7=param[2],
           match$7=fmtty_rel_det(rest$7),
           de$7=match$7[4],
           ed$7=match$7[3],
           af$7=match$7[2],
           fa$7=match$7[1],
           _bhj_=function(param){var _bhQ_=0;caml_call1(af$7,_bhQ_);return 0};
          return [0,
                  function(param){var _bhP_=0;caml_call1(fa$7,_bhP_);return 0},
                  _bhj_,
                  ed$7,
                  de$7];
         case 9:
          var
           rest$8=param[3],
           ty2=param[2],
           ty1=param[1],
           match$8=fmtty_rel_det(rest$8),
           de$8=match$8[4],
           ed$8=match$8[3],
           af$8=match$8[2],
           fa$8=match$8[1],
           _bhk_=symm(ty1),
           ty=trans(_bhk_,ty2),
           match$9=fmtty_rel_det(ty),
           jd=match$9[4],
           dj=match$9[3],
           ga=match$9[2],
           ag=match$9[1],
           _bhl_=
            function(param)
             {var _bhN_=0;
              caml_call1(jd,_bhN_);
              var _bhO_=0;
              caml_call1(de$8,_bhO_);
              return 0},
           _bhm_=
            function(param)
             {var _bhL_=0;
              caml_call1(ed$8,_bhL_);
              var _bhM_=0;
              caml_call1(dj,_bhM_);
              return 0},
           _bhn_=
            function(param)
             {var _bhJ_=0;
              caml_call1(ga,_bhJ_);
              var _bhK_=0;
              caml_call1(af$8,_bhK_);
              return 0};
          return [0,
                  function(param)
                   {var _bhH_=0;
                    caml_call1(fa$8,_bhH_);
                    var _bhI_=0;
                    caml_call1(ag,_bhI_);
                    return 0},
                  _bhn_,
                  _bhm_,
                  _bhl_];
         case 10:
          var
           rest$9=param[1],
           match$10=fmtty_rel_det(rest$9),
           de$9=match$10[4],
           ed$9=match$10[3],
           af$9=match$10[2],
           fa$9=match$10[1],
           _bho_=function(param){var _bhG_=0;caml_call1(af$9,_bhG_);return 0};
          return [0,
                  function(param){var _bhF_=0;caml_call1(fa$9,_bhF_);return 0},
                  _bho_,
                  ed$9,
                  de$9];
         case 11:
          var
           rest$10=param[1],
           match$11=fmtty_rel_det(rest$10),
           de$10=match$11[4],
           ed$10=match$11[3],
           af$10=match$11[2],
           fa$10=match$11[1],
           _bhp_=function(param){var _bhE_=0;caml_call1(af$10,_bhE_);return 0};
          return [0,
                  function(param)
                   {var _bhD_=0;caml_call1(fa$10,_bhD_);return 0},
                  _bhp_,
                  ed$10,
                  de$10];
         case 12:
          var
           rest$11=param[1],
           match$12=fmtty_rel_det(rest$11),
           de$11=match$12[4],
           ed$11=match$12[3],
           af$11=match$12[2],
           fa$11=match$12[1],
           _bhq_=function(param){var _bhC_=0;caml_call1(af$11,_bhC_);return 0};
          return [0,
                  function(param)
                   {var _bhB_=0;caml_call1(fa$11,_bhB_);return 0},
                  _bhq_,
                  ed$11,
                  de$11];
         case 13:
          var
           rest$12=param[1],
           match$13=fmtty_rel_det(rest$12),
           de$12=match$13[4],
           ed$12=match$13[3],
           af$12=match$13[2],
           fa$12=match$13[1],
           _bhr_=function(param){var _bhA_=0;caml_call1(de$12,_bhA_);return 0},
           _bhs_=function(param){var _bhz_=0;caml_call1(ed$12,_bhz_);return 0},
           _bht_=function(param){var _bhy_=0;caml_call1(af$12,_bhy_);return 0};
          return [0,
                  function(param)
                   {var _bhx_=0;caml_call1(fa$12,_bhx_);return 0},
                  _bht_,
                  _bhs_,
                  _bhr_];
         default:
          var
           rest$13=param[1],
           match$14=fmtty_rel_det(rest$13),
           de$13=match$14[4],
           ed$13=match$14[3],
           af$13=match$14[2],
           fa$13=match$14[1],
           _bhu_=function(param){var _bh__=0;caml_call1(de$13,_bh__);return 0},
           _bhv_=function(param){var _bh9_=0;caml_call1(ed$13,_bh9_);return 0},
           _bhw_=function(param){var _bh8_=0;caml_call1(af$13,_bh8_);return 0};
          return [0,
                  function(param)
                   {var _bh7_=0;caml_call1(fa$13,_bh7_);return 0},
                  _bhw_,
                  _bhv_,
                  _bhu_]}}
    function fmtty_of_precision_fmtty(prec,fmtty)
     {return typeof prec === "number"?prec?[2,fmtty]:fmtty:fmtty}
    function fmtty_of_padding_fmtty(pad,fmtty)
     {return typeof pad === "number"?fmtty:0 === pad[0]?fmtty:[2,fmtty]}
    function fmtty_of_custom(arity,fmtty)
     {if(arity)
       {var arity$0=arity[1];return [12,fmtty_of_custom(arity$0,fmtty)]}
      return fmtty}
    function fmtty_of_fmt$0(counter,fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:var rest=fmtty$0[1];return [0,fmtty_of_fmt(rest)];
          case 1:var rest$0=fmtty$0[1];return [0,fmtty_of_fmt(rest$0)];
          case 2:
           var rest$1=fmtty$0[2],pad=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad,[1,fmtty_of_fmt(rest$1)]);
          case 3:
           var rest$2=fmtty$0[2],pad$0=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$0,[1,fmtty_of_fmt(rest$2)]);
          case 4:
           var
            rest$3=fmtty$0[4],
            prec=fmtty$0[3],
            pad$1=fmtty$0[2],
            ty_rest=fmtty_of_fmt(rest$3),
            _bg4_=[2,ty_rest],
            prec_ty=fmtty_of_precision_fmtty(prec,_bg4_);
           return fmtty_of_padding_fmtty(pad$1,prec_ty);
          case 5:
           var
            rest$4=fmtty$0[4],
            prec$0=fmtty$0[3],
            pad$2=fmtty$0[2],
            ty_rest$0=fmtty_of_fmt(rest$4),
            _bg5_=[3,ty_rest$0],
            prec_ty$0=fmtty_of_precision_fmtty(prec$0,_bg5_);
           return fmtty_of_padding_fmtty(pad$2,prec_ty$0);
          case 6:
           var
            rest$5=fmtty$0[4],
            prec$1=fmtty$0[3],
            pad$3=fmtty$0[2],
            ty_rest$1=fmtty_of_fmt(rest$5),
            _bg6_=[4,ty_rest$1],
            prec_ty$1=fmtty_of_precision_fmtty(prec$1,_bg6_);
           return fmtty_of_padding_fmtty(pad$3,prec_ty$1);
          case 7:
           var
            rest$6=fmtty$0[4],
            prec$2=fmtty$0[3],
            pad$4=fmtty$0[2],
            ty_rest$2=fmtty_of_fmt(rest$6),
            _bg7_=[5,ty_rest$2],
            prec_ty$2=fmtty_of_precision_fmtty(prec$2,_bg7_);
           return fmtty_of_padding_fmtty(pad$4,prec_ty$2);
          case 8:
           var
            rest$7=fmtty$0[4],
            prec$3=fmtty$0[3],
            pad$5=fmtty$0[2],
            ty_rest$3=fmtty_of_fmt(rest$7),
            _bg8_=[6,ty_rest$3],
            prec_ty$3=fmtty_of_precision_fmtty(prec$3,_bg8_);
           return fmtty_of_padding_fmtty(pad$5,prec_ty$3);
          case 9:
           var rest$8=fmtty$0[2],pad$6=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$6,[7,fmtty_of_fmt(rest$8)]);
          case 10:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 11:var fmtty$2=fmtty$0[2],fmtty$0=fmtty$2;continue;
          case 12:var fmtty$3=fmtty$0[2],fmtty$0=fmtty$3;continue;
          case 13:
           var rest$9=fmtty$0[3],ty=fmtty$0[2];
           return [8,ty,fmtty_of_fmt(rest$9)];
          case 14:
           var rest$10=fmtty$0[3],ty$0=fmtty$0[2];
           return [9,ty$0,ty$0,fmtty_of_fmt(rest$10)];
          case 15:var rest$11=fmtty$0[1];return [10,fmtty_of_fmt(rest$11)];
          case 16:var rest$12=fmtty$0[1];return [11,fmtty_of_fmt(rest$12)];
          case 17:var fmtty$4=fmtty$0[2],fmtty$0=fmtty$4;continue;
          case 18:
           var
            rest$13=fmtty$0[2],
            fmting_gen=fmtty$0[1],
            _bg9_=fmtty_of_fmt(rest$13);
           return concat_fmtty(fmtty_of_formatting_gen(fmting_gen),_bg9_);
          case 19:var rest$14=fmtty$0[1];return [13,fmtty_of_fmt(rest$14)];
          case 20:var rest$15=fmtty$0[3];return [1,fmtty_of_fmt(rest$15)];
          case 21:var rest$16=fmtty$0[2];return [2,fmtty_of_fmt(rest$16)];
          case 22:var rest$17=fmtty$0[1];return [0,fmtty_of_fmt(rest$17)];
          case 23:
           var rest$18=fmtty$0[2],ign=fmtty$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return fmtty_of_ignored_format(counter$0,ign,rest$18)}
           return caml_trampoline_return
                   (fmtty_of_ignored_format,[0,ign,rest$18]);
          default:
           var rest$19=fmtty$0[3],arity=fmtty$0[1];
           return fmtty_of_custom(arity,fmtty_of_fmt(rest$19))}}
    function fmtty_of_ignored_format(counter,ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return fmtty_of_fmt$0(counter$0,fmt)}
          return caml_trampoline_return(fmtty_of_fmt$0,[0,fmt]);
         case 1:
          if(counter < 50)
           {var counter$1=counter + 1 | 0;
            return fmtty_of_fmt$0(counter$1,fmt)}
          return caml_trampoline_return(fmtty_of_fmt$0,[0,fmt]);
         case 2:return [14,fmtty_of_fmt(fmt)];
         default:
          if(counter < 50)
           {var counter$2=counter + 1 | 0;
            return fmtty_of_fmt$0(counter$2,fmt)}
          return caml_trampoline_return(fmtty_of_fmt$0,[0,fmt])}
      else
       switch(ign[0])
        {case 0:
          if(counter < 50)
           {var counter$3=counter + 1 | 0;
            return fmtty_of_fmt$0(counter$3,fmt)}
          return caml_trampoline_return(fmtty_of_fmt$0,[0,fmt]);
         case 1:
          if(counter < 50)
           {var counter$4=counter + 1 | 0;
            return fmtty_of_fmt$0(counter$4,fmt)}
          return caml_trampoline_return(fmtty_of_fmt$0,[0,fmt]);
         case 2:
          if(counter < 50)
           {var counter$5=counter + 1 | 0;
            return fmtty_of_fmt$0(counter$5,fmt)}
          return caml_trampoline_return(fmtty_of_fmt$0,[0,fmt]);
         case 3:
          if(counter < 50)
           {var counter$6=counter + 1 | 0;
            return fmtty_of_fmt$0(counter$6,fmt)}
          return caml_trampoline_return(fmtty_of_fmt$0,[0,fmt]);
         case 4:
          if(counter < 50)
           {var counter$7=counter + 1 | 0;
            return fmtty_of_fmt$0(counter$7,fmt)}
          return caml_trampoline_return(fmtty_of_fmt$0,[0,fmt]);
         case 5:
          if(counter < 50)
           {var counter$8=counter + 1 | 0;
            return fmtty_of_fmt$0(counter$8,fmt)}
          return caml_trampoline_return(fmtty_of_fmt$0,[0,fmt]);
         case 6:
          if(counter < 50)
           {var counter$9=counter + 1 | 0;
            return fmtty_of_fmt$0(counter$9,fmt)}
          return caml_trampoline_return(fmtty_of_fmt$0,[0,fmt]);
         case 7:
          if(counter < 50)
           {var counter$10=counter + 1 | 0;
            return fmtty_of_fmt$0(counter$10,fmt)}
          return caml_trampoline_return(fmtty_of_fmt$0,[0,fmt]);
         case 8:
          if(counter < 50)
           {var counter$11=counter + 1 | 0;
            return fmtty_of_fmt$0(counter$11,fmt)}
          return caml_trampoline_return(fmtty_of_fmt$0,[0,fmt]);
         case 9:var fmtty=ign[2];return concat_fmtty(fmtty,fmtty_of_fmt(fmt));
         case 10:
          if(counter < 50)
           {var counter$12=counter + 1 | 0;
            return fmtty_of_fmt$0(counter$12,fmt)}
          return caml_trampoline_return(fmtty_of_fmt$0,[0,fmt]);
         default:
          if(counter < 50)
           {var counter$13=counter + 1 | 0;
            return fmtty_of_fmt$0(counter$13,fmt)}
          return caml_trampoline_return(fmtty_of_fmt$0,[0,fmt])}}
    function fmtty_of_formatting_gen(formatting_gen)
     {if(0 === formatting_gen[0])
       {var match=formatting_gen[1],fmt=match[1];return fmtty_of_fmt(fmt)}
      var match$0=formatting_gen[1],fmt$0=match$0[1];
      return fmtty_of_fmt(fmt$0)}
    function fmtty_of_fmt(fmtty)
     {return caml_trampoline(fmtty_of_fmt$0(0,fmtty))}
    var Type_mismatch=[248,_a3_,caml_fresh_oo_id(0)];
    function type_padding(pad,fmtty)
     {if(typeof pad === "number")
       return [0,0,fmtty];
      else
       {if(0 === pad[0])
         {var w=pad[2],padty=pad[1];return [0,[0,padty,w],fmtty]}
        if(typeof fmtty !== "number" && 2 === fmtty[0])
         {var rest=fmtty[1],padty$0=pad[1];return [0,[1,padty$0],rest]}
        throw Type_mismatch}}
    function type_padprec(pad,prec,fmtty)
     {var match=type_padding(pad,fmtty);
      if(typeof prec === "number")
       {if(prec)
         {var _bg3_=match[2];
          if(typeof _bg3_ !== "number" && 2 === _bg3_[0])
           {var rest=_bg3_[1],pad$0=match[1];return [0,pad$0,1,rest]}
          throw Type_mismatch}
        var rest$0=match[2],pad$1=match[1];
        return [0,pad$1,0,rest$0]}
      var rest$1=match[2],pad$2=match[1],p=prec[1];
      return [0,pad$2,[0,p],rest$1]}
    function type_ignored_format_substituti(sub_fmtty,fmt,fmtty)
     {if(typeof sub_fmtty === "number")
       return [0,0,type_format_gen(fmt,fmtty)];
      else
       switch(sub_fmtty[0])
        {case 0:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest=fmtty[1],
             sub_fmtty_rest=sub_fmtty[1],
             match=
              type_ignored_format_substituti(sub_fmtty_rest,fmt,fmtty_rest),
             fmt$0=match[2],
             sub_fmtty_rest$0=match[1];
            return [0,[0,sub_fmtty_rest$0],fmt$0]}
          break;
         case 1:
          if(typeof fmtty !== "number" && 1 === fmtty[0])
           {var
             fmtty_rest$0=fmtty[1],
             sub_fmtty_rest$1=sub_fmtty[1],
             match$0=
              type_ignored_format_substituti
               (sub_fmtty_rest$1,fmt,fmtty_rest$0),
             fmt$1=match$0[2],
             sub_fmtty_rest$2=match$0[1];
            return [0,[1,sub_fmtty_rest$2],fmt$1]}
          break;
         case 2:
          if(typeof fmtty !== "number" && 2 === fmtty[0])
           {var
             fmtty_rest$1=fmtty[1],
             sub_fmtty_rest$3=sub_fmtty[1],
             match$1=
              type_ignored_format_substituti
               (sub_fmtty_rest$3,fmt,fmtty_rest$1),
             fmt$2=match$1[2],
             sub_fmtty_rest$4=match$1[1];
            return [0,[2,sub_fmtty_rest$4],fmt$2]}
          break;
         case 3:
          if(typeof fmtty !== "number" && 3 === fmtty[0])
           {var
             fmtty_rest$2=fmtty[1],
             sub_fmtty_rest$5=sub_fmtty[1],
             match$2=
              type_ignored_format_substituti
               (sub_fmtty_rest$5,fmt,fmtty_rest$2),
             fmt$3=match$2[2],
             sub_fmtty_rest$6=match$2[1];
            return [0,[3,sub_fmtty_rest$6],fmt$3]}
          break;
         case 4:
          if(typeof fmtty !== "number" && 4 === fmtty[0])
           {var
             fmtty_rest$3=fmtty[1],
             sub_fmtty_rest$7=sub_fmtty[1],
             match$3=
              type_ignored_format_substituti
               (sub_fmtty_rest$7,fmt,fmtty_rest$3),
             fmt$4=match$3[2],
             sub_fmtty_rest$8=match$3[1];
            return [0,[4,sub_fmtty_rest$8],fmt$4]}
          break;
         case 5:
          if(typeof fmtty !== "number" && 5 === fmtty[0])
           {var
             fmtty_rest$4=fmtty[1],
             sub_fmtty_rest$9=sub_fmtty[1],
             match$4=
              type_ignored_format_substituti
               (sub_fmtty_rest$9,fmt,fmtty_rest$4),
             fmt$5=match$4[2],
             sub_fmtty_rest$10=match$4[1];
            return [0,[5,sub_fmtty_rest$10],fmt$5]}
          break;
         case 6:
          if(typeof fmtty !== "number" && 6 === fmtty[0])
           {var
             fmtty_rest$5=fmtty[1],
             sub_fmtty_rest$11=sub_fmtty[1],
             match$5=
              type_ignored_format_substituti
               (sub_fmtty_rest$11,fmt,fmtty_rest$5),
             fmt$6=match$5[2],
             sub_fmtty_rest$12=match$5[1];
            return [0,[6,sub_fmtty_rest$12],fmt$6]}
          break;
         case 7:
          if(typeof fmtty !== "number" && 7 === fmtty[0])
           {var
             fmtty_rest$6=fmtty[1],
             sub_fmtty_rest$13=sub_fmtty[1],
             match$6=
              type_ignored_format_substituti
               (sub_fmtty_rest$13,fmt,fmtty_rest$6),
             fmt$7=match$6[2],
             sub_fmtty_rest$14=match$6[1];
            return [0,[7,sub_fmtty_rest$14],fmt$7]}
          break;
         case 8:
          if(typeof fmtty !== "number" && 8 === fmtty[0])
           {var
             fmtty_rest$7=fmtty[2],
             sub2_fmtty=fmtty[1],
             sub_fmtty_rest$15=sub_fmtty[2],
             sub2_fmtty$0=sub_fmtty[1],
             _bgT_=[0,sub2_fmtty],
             _bgU_=[0,sub2_fmtty$0];
            if(caml_notequal(_bgU_,_bgT_))throw Type_mismatch;
            var
             match$7=
              type_ignored_format_substituti
               (sub_fmtty_rest$15,fmt,fmtty_rest$7),
             fmt$8=match$7[2],
             sub_fmtty_rest$16=match$7[1];
            return [0,[8,sub2_fmtty,sub_fmtty_rest$16],fmt$8]}
          break;
         case 9:
          if(typeof fmtty !== "number" && 9 === fmtty[0])
           {var
             fmtty_rest$8=fmtty[3],
             sub2_fmtty$1=fmtty[2],
             sub1_fmtty=fmtty[1],
             sub_fmtty_rest$17=sub_fmtty[3],
             sub2_fmtty$2=sub_fmtty[2],
             sub1_fmtty$0=sub_fmtty[1],
             _bgV_=[0,erase_rel(sub1_fmtty)],
             _bgW_=[0,erase_rel(sub1_fmtty$0)];
            if(caml_notequal(_bgW_,_bgV_))throw Type_mismatch;
            var
             _bgX_=[0,erase_rel(sub2_fmtty$1)],
             _bgY_=[0,erase_rel(sub2_fmtty$2)];
            if(caml_notequal(_bgY_,_bgX_))throw Type_mismatch;
            var
             _bgZ_=symm(sub1_fmtty),
             sub_fmtty$0=trans(_bgZ_,sub2_fmtty$1),
             match$8=fmtty_rel_det(sub_fmtty$0),
             f4=match$8[4],
             f2=match$8[2],
             _bg0_=0;
            caml_call1(f2,_bg0_);
            var _bg1_=0;
            caml_call1(f4,_bg1_);
            var
             _bg2_=erase_rel(sub_fmtty_rest$17),
             match$9=type_ignored_format_substituti(_bg2_,fmt,fmtty_rest$8),
             fmt$9=match$9[2],
             sub_fmtty_rest$18=match$9[1];
            return [0,
                    [9,sub1_fmtty,sub2_fmtty$1,symm(sub_fmtty_rest$18)],
                    fmt$9]}
          break;
         case 10:
          if(typeof fmtty !== "number" && 10 === fmtty[0])
           {var
             fmtty_rest$9=fmtty[1],
             sub_fmtty_rest$19=sub_fmtty[1],
             match$10=
              type_ignored_format_substituti
               (sub_fmtty_rest$19,fmt,fmtty_rest$9),
             fmt$10=match$10[2],
             sub_fmtty_rest$20=match$10[1];
            return [0,[10,sub_fmtty_rest$20],fmt$10]}
          break;
         case 11:
          if(typeof fmtty !== "number" && 11 === fmtty[0])
           {var
             fmtty_rest$10=fmtty[1],
             sub_fmtty_rest$21=sub_fmtty[1],
             match$11=
              type_ignored_format_substituti
               (sub_fmtty_rest$21,fmt,fmtty_rest$10),
             fmt$11=match$11[2],
             sub_fmtty_rest$22=match$11[1];
            return [0,[11,sub_fmtty_rest$22],fmt$11]}
          break;
         case 13:
          if(typeof fmtty !== "number" && 13 === fmtty[0])
           {var
             fmtty_rest$11=fmtty[1],
             sub_fmtty_rest$23=sub_fmtty[1],
             match$12=
              type_ignored_format_substituti
               (sub_fmtty_rest$23,fmt,fmtty_rest$11),
             fmt$12=match$12[2],
             sub_fmtty_rest$24=match$12[1];
            return [0,[13,sub_fmtty_rest$24],fmt$12]}
          break;
         case 14:
          if(typeof fmtty !== "number" && 14 === fmtty[0])
           {var
             fmtty_rest$12=fmtty[1],
             sub_fmtty_rest$25=sub_fmtty[1],
             match$13=
              type_ignored_format_substituti
               (sub_fmtty_rest$25,fmt,fmtty_rest$12),
             fmt$13=match$13[2],
             sub_fmtty_rest$26=match$13[1];
            return [0,[14,sub_fmtty_rest$26],fmt$13]}
          break
         }
      throw Type_mismatch}
    function type_format_gen(fmt,fmtty)
     {if(typeof fmt === "number")
       return [0,0,fmtty];
      else
       switch(fmt[0])
        {case 0:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest=fmtty[1],
             fmt_rest=fmt[1],
             match=type_format_gen(fmt_rest,fmtty_rest),
             fmtty$0=match[2],
             fmt$0=match[1];
            return [0,[0,fmt$0],fmtty$0]}
          break;
         case 1:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest$0=fmtty[1],
             fmt_rest$0=fmt[1],
             match$0=type_format_gen(fmt_rest$0,fmtty_rest$0),
             fmtty$1=match$0[2],
             fmt$1=match$0[1];
            return [0,[1,fmt$1],fmtty$1]}
          break;
         case 2:
          var
           fmt_rest$1=fmt[2],
           pad=fmt[1],
           match$1=type_padding(pad,fmtty),
           _bgz_=match$1[2],
           _bgy_=match$1[1];
          if(typeof _bgz_ !== "number" && 1 === _bgz_[0])
           {var
             fmtty_rest$1=_bgz_[1],
             match$2=type_format_gen(fmt_rest$1,fmtty_rest$1),
             fmtty$2=match$2[2],
             fmt$2=match$2[1];
            return [0,[2,_bgy_,fmt$2],fmtty$2]}
          throw Type_mismatch;
         case 3:
          var
           fmt_rest$2=fmt[2],
           pad$0=fmt[1],
           match$3=type_padding(pad$0,fmtty),
           _bgB_=match$3[2],
           _bgA_=match$3[1];
          if(typeof _bgB_ !== "number" && 1 === _bgB_[0])
           {var
             fmtty_rest$2=_bgB_[1],
             match$4=type_format_gen(fmt_rest$2,fmtty_rest$2),
             fmtty$3=match$4[2],
             fmt$3=match$4[1];
            return [0,[3,_bgA_,fmt$3],fmtty$3]}
          throw Type_mismatch;
         case 4:
          var
           fmt_rest$3=fmt[4],
           prec=fmt[3],
           pad$1=fmt[2],
           iconv=fmt[1],
           match$5=type_padprec(pad$1,prec,fmtty),
           _bgD_=match$5[3],
           _bgC_=match$5[1];
          if(typeof _bgD_ !== "number" && 2 === _bgD_[0])
           {var
             fmtty_rest$3=_bgD_[1],
             prec$0=match$5[2],
             match$6=type_format_gen(fmt_rest$3,fmtty_rest$3),
             fmtty$4=match$6[2],
             fmt$4=match$6[1];
            return [0,[4,iconv,_bgC_,prec$0,fmt$4],fmtty$4]}
          throw Type_mismatch;
         case 5:
          var
           fmt_rest$4=fmt[4],
           prec$1=fmt[3],
           pad$2=fmt[2],
           iconv$0=fmt[1],
           match$7=type_padprec(pad$2,prec$1,fmtty),
           _bgF_=match$7[3],
           _bgE_=match$7[1];
          if(typeof _bgF_ !== "number" && 3 === _bgF_[0])
           {var
             fmtty_rest$4=_bgF_[1],
             prec$2=match$7[2],
             match$8=type_format_gen(fmt_rest$4,fmtty_rest$4),
             fmtty$5=match$8[2],
             fmt$5=match$8[1];
            return [0,[5,iconv$0,_bgE_,prec$2,fmt$5],fmtty$5]}
          throw Type_mismatch;
         case 6:
          var
           fmt_rest$5=fmt[4],
           prec$3=fmt[3],
           pad$3=fmt[2],
           iconv$1=fmt[1],
           match$9=type_padprec(pad$3,prec$3,fmtty),
           _bgH_=match$9[3],
           _bgG_=match$9[1];
          if(typeof _bgH_ !== "number" && 4 === _bgH_[0])
           {var
             fmtty_rest$5=_bgH_[1],
             prec$4=match$9[2],
             match$10=type_format_gen(fmt_rest$5,fmtty_rest$5),
             fmtty$6=match$10[2],
             fmt$6=match$10[1];
            return [0,[6,iconv$1,_bgG_,prec$4,fmt$6],fmtty$6]}
          throw Type_mismatch;
         case 7:
          var
           fmt_rest$6=fmt[4],
           prec$5=fmt[3],
           pad$4=fmt[2],
           iconv$2=fmt[1],
           match$11=type_padprec(pad$4,prec$5,fmtty),
           _bgJ_=match$11[3],
           _bgI_=match$11[1];
          if(typeof _bgJ_ !== "number" && 5 === _bgJ_[0])
           {var
             fmtty_rest$6=_bgJ_[1],
             prec$6=match$11[2],
             match$12=type_format_gen(fmt_rest$6,fmtty_rest$6),
             fmtty$7=match$12[2],
             fmt$7=match$12[1];
            return [0,[7,iconv$2,_bgI_,prec$6,fmt$7],fmtty$7]}
          throw Type_mismatch;
         case 8:
          var
           fmt_rest$7=fmt[4],
           prec$7=fmt[3],
           pad$5=fmt[2],
           fconv=fmt[1],
           match$13=type_padprec(pad$5,prec$7,fmtty),
           _bgL_=match$13[3],
           _bgK_=match$13[1];
          if(typeof _bgL_ !== "number" && 6 === _bgL_[0])
           {var
             fmtty_rest$7=_bgL_[1],
             prec$8=match$13[2],
             match$14=type_format_gen(fmt_rest$7,fmtty_rest$7),
             fmtty$8=match$14[2],
             fmt$8=match$14[1];
            return [0,[8,fconv,_bgK_,prec$8,fmt$8],fmtty$8]}
          throw Type_mismatch;
         case 9:
          var
           fmt_rest$8=fmt[2],
           pad$6=fmt[1],
           match$15=type_padding(pad$6,fmtty),
           _bgN_=match$15[2],
           _bgM_=match$15[1];
          if(typeof _bgN_ !== "number" && 7 === _bgN_[0])
           {var
             fmtty_rest$8=_bgN_[1],
             match$16=type_format_gen(fmt_rest$8,fmtty_rest$8),
             fmtty$9=match$16[2],
             fmt$9=match$16[1];
            return [0,[9,_bgM_,fmt$9],fmtty$9]}
          throw Type_mismatch;
         case 10:
          var
           fmt_rest$9=fmt[1],
           match$17=type_format_gen(fmt_rest$9,fmtty),
           fmtty$10=match$17[2],
           fmt$10=match$17[1];
          return [0,[10,fmt$10],fmtty$10];
         case 11:
          var
           fmt_rest$10=fmt[2],
           str=fmt[1],
           match$18=type_format_gen(fmt_rest$10,fmtty),
           fmtty$11=match$18[2],
           fmt$11=match$18[1];
          return [0,[11,str,fmt$11],fmtty$11];
         case 12:
          var
           fmt_rest$11=fmt[2],
           chr=fmt[1],
           match$19=type_format_gen(fmt_rest$11,fmtty),
           fmtty$12=match$19[2],
           fmt$12=match$19[1];
          return [0,[12,chr,fmt$12],fmtty$12];
         case 13:
          if(typeof fmtty !== "number" && 8 === fmtty[0])
           {var
             fmtty_rest$9=fmtty[2],
             sub_fmtty=fmtty[1],
             fmt_rest$12=fmt[3],
             sub_fmtty$0=fmt[2],
             pad_opt=fmt[1],
             _bgO_=[0,sub_fmtty],
             _bgP_=[0,sub_fmtty$0];
            if(caml_notequal(_bgP_,_bgO_))throw Type_mismatch;
            var
             match$20=type_format_gen(fmt_rest$12,fmtty_rest$9),
             fmtty$13=match$20[2],
             fmt$13=match$20[1];
            return [0,[13,pad_opt,sub_fmtty,fmt$13],fmtty$13]}
          break;
         case 14:
          if(typeof fmtty !== "number" && 9 === fmtty[0])
           {var
             fmtty_rest$10=fmtty[3],
             sub_fmtty1=fmtty[1],
             fmt_rest$13=fmt[3],
             sub_fmtty$1=fmt[2],
             pad_opt$0=fmt[1],
             _bgQ_=[0,erase_rel(sub_fmtty1)],
             _bgR_=[0,erase_rel(sub_fmtty$1)];
            if(caml_notequal(_bgR_,_bgQ_))throw Type_mismatch;
            var
             _bgS_=erase_rel(fmtty_rest$10),
             match$21=type_format_gen(fmt_rest$13,_bgS_),
             fmtty$14=match$21[2],
             fmt$14=match$21[1];
            return [0,[14,pad_opt$0,sub_fmtty1,fmt$14],fmtty$14]}
          break;
         case 15:
          if(typeof fmtty !== "number" && 10 === fmtty[0])
           {var
             fmtty_rest$11=fmtty[1],
             fmt_rest$14=fmt[1],
             match$22=type_format_gen(fmt_rest$14,fmtty_rest$11),
             fmtty$15=match$22[2],
             fmt$15=match$22[1];
            return [0,[15,fmt$15],fmtty$15]}
          break;
         case 16:
          if(typeof fmtty !== "number" && 11 === fmtty[0])
           {var
             fmtty_rest$12=fmtty[1],
             fmt_rest$15=fmt[1],
             match$23=type_format_gen(fmt_rest$15,fmtty_rest$12),
             fmtty$16=match$23[2],
             fmt$16=match$23[1];
            return [0,[16,fmt$16],fmtty$16]}
          break;
         case 17:
          var
           fmt_rest$16=fmt[2],
           formatting_lit=fmt[1],
           match$24=type_format_gen(fmt_rest$16,fmtty),
           fmtty$17=match$24[2],
           fmt$17=match$24[1];
          return [0,[17,formatting_lit,fmt$17],fmtty$17];
         case 18:
          var fmt_rest$17=fmt[2],formatting_gen=fmt[1];
          return type_formatting_gen(formatting_gen,fmt_rest$17,fmtty);
         case 19:
          if(typeof fmtty !== "number" && 13 === fmtty[0])
           {var
             fmtty_rest$13=fmtty[1],
             fmt_rest$18=fmt[1],
             match$25=type_format_gen(fmt_rest$18,fmtty_rest$13),
             fmtty$18=match$25[2],
             fmt$18=match$25[1];
            return [0,[19,fmt$18],fmtty$18]}
          break;
         case 20:
          if(typeof fmtty !== "number" && 1 === fmtty[0])
           {var
             fmtty_rest$14=fmtty[1],
             fmt_rest$19=fmt[3],
             char_set=fmt[2],
             width_opt=fmt[1],
             match$26=type_format_gen(fmt_rest$19,fmtty_rest$14),
             fmtty$19=match$26[2],
             fmt$19=match$26[1];
            return [0,[20,width_opt,char_set,fmt$19],fmtty$19]}
          break;
         case 21:
          if(typeof fmtty !== "number" && 2 === fmtty[0])
           {var
             fmtty_rest$15=fmtty[1],
             fmt_rest$20=fmt[2],
             counter=fmt[1],
             match$27=type_format_gen(fmt_rest$20,fmtty_rest$15),
             fmtty$20=match$27[2],
             fmt$20=match$27[1];
            return [0,[21,counter,fmt$20],fmtty$20]}
          break;
         case 23:
          var rest=fmt[2],ign=fmt[1];return type_ignored_param(ign,rest,fmtty)
         }
      throw Type_mismatch}
    function type_formatting_gen(formatting_gen,fmt0,fmtty0)
     {if(0 === formatting_gen[0])
       {var
         match=formatting_gen[1],
         str=match[2],
         fmt1=match[1],
         match$0=type_format_gen(fmt1,fmtty0),
         fmtty2=match$0[2],
         fmt2=match$0[1],
         match$1=type_format_gen(fmt0,fmtty2),
         fmtty3=match$1[2],
         fmt3=match$1[1];
        return [0,[18,[0,[0,fmt2,str]],fmt3],fmtty3]}
      var
       match$2=formatting_gen[1],
       str$0=match$2[2],
       fmt1$0=match$2[1],
       match$3=type_format_gen(fmt1$0,fmtty0),
       fmtty2$0=match$3[2],
       fmt2$0=match$3[1],
       match$4=type_format_gen(fmt0,fmtty2$0),
       fmtty3$0=match$4[2],
       fmt3$0=match$4[1];
      return [0,[18,[1,[0,fmt2$0,str$0]],fmt3$0],fmtty3$0]}
    function type_ignored_param(ign,fmt,fmtty)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:return type_ignored_param_one(ign,fmt,fmtty);
         case 1:return type_ignored_param_one(ign,fmt,fmtty);
         case 2:
          if(typeof fmtty !== "number" && 14 === fmtty[0])
           {var
             fmtty_rest=fmtty[1],
             match=type_format_gen(fmt,fmtty_rest),
             fmtty$0=match[2],
             fmt$0=match[1];
            return [0,[23,2,fmt$0],fmtty$0]}
          throw Type_mismatch;
         default:return type_ignored_param_one(ign,fmt,fmtty)}
      else
       switch(ign[0])
        {case 0:return type_ignored_param_one(ign,fmt,fmtty);
         case 1:return type_ignored_param_one(ign,fmt,fmtty);
         case 2:return type_ignored_param_one(ign,fmt,fmtty);
         case 3:return type_ignored_param_one(ign,fmt,fmtty);
         case 4:return type_ignored_param_one(ign,fmt,fmtty);
         case 5:return type_ignored_param_one(ign,fmt,fmtty);
         case 6:return type_ignored_param_one(ign,fmt,fmtty);
         case 7:return type_ignored_param_one(ign,fmt,fmtty);
         case 8:
          var sub_fmtty=ign[2],pad_opt=ign[1];
          return type_ignored_param_one([8,pad_opt,sub_fmtty],fmt,fmtty);
         case 9:
          var
           sub_fmtty$0=ign[2],
           pad_opt$0=ign[1],
           _bgx_=type_ignored_format_substituti(sub_fmtty$0,fmt,fmtty),
           match$0=_bgx_[2],
           fmtty$1=match$0[2],
           fmt$1=match$0[1],
           sub_fmtty$1=_bgx_[1];
          return [0,[23,[9,pad_opt$0,sub_fmtty$1],fmt$1],fmtty$1];
         case 10:return type_ignored_param_one(ign,fmt,fmtty);
         default:return type_ignored_param_one(ign,fmt,fmtty)}}
    function type_ignored_param_one(ign,fmt,fmtty)
     {var match=type_format_gen(fmt,fmtty),fmtty$0=match[2],fmt$0=match[1];
      return [0,[23,ign,fmt$0],fmtty$0]}
    function type_format(fmt,fmtty)
     {var _bgw_=type_format_gen(fmt,fmtty);
      if(typeof _bgw_[2] === "number"){var fmt$0=_bgw_[1];return fmt$0}
      throw Type_mismatch}
    function recast(fmt,fmtty)
     {var _bgv_=symm(fmtty);return type_format(fmt,erase_rel(_bgv_))}
    function fix_padding(padty,width,str)
     {var
       len=caml_ml_string_length(str),
       padty$0=0 <= width?padty:0,
       width$0=abs(width);
      if(width$0 <= len)return str;
      var _bgg_=2 === padty$0?48:32,res=make$0(width$0,_bgg_);
      switch(padty$0)
       {case 0:var _bgh_=0,_bgi_=0;blit$0(str,_bgi_,res,_bgh_,len);break;
        case 1:
         var _bgj_=width$0 - len | 0,_bgk_=0;
         blit$0(str,_bgk_,res,_bgj_,len);
         break;
        default:
         var switch$0=0;
         if(0 < len)
          {var switch$1=0;
           if
            (43
             !==
             caml_string_get(str,0)
             &&
             45
             !==
             caml_string_get(str,0)
             &&
             32
             !==
             caml_string_get(str,0))
            {switch$0 = 1;switch$1 = 1}
           if(! switch$1)
            {var _bgl_=caml_string_get(str,0);
             caml_bytes_set(res,0,_bgl_);
             var _bgm_=len - 1 | 0,_bgn_=(width$0 - len | 0) + 1 | 0,_bgo_=1;
             blit$0(str,_bgo_,res,_bgn_,_bgm_)}}
         else
          switch$0 = 1;
         if(switch$0)
          {var switch$2=0;
           if(1 < len && 48 === caml_string_get(str,0))
            {var switch$3=0;
             if
              (120
               !==
               caml_string_get(str,1)
               &&
               88
               !==
               caml_string_get(str,1))
              {switch$2 = 1;switch$3 = 1}
             if(! switch$3)
              {var _bgp_=caml_string_get(str,1);
               caml_bytes_set(res,1,_bgp_);
               var
                _bgq_=len - 2 | 0,
                _bgr_=(width$0 - len | 0) + 2 | 0,
                _bgs_=2;
               blit$0(str,_bgs_,res,_bgr_,_bgq_)}}
           else
            switch$2 = 1;
           if(switch$2)
            {var _bgt_=width$0 - len | 0,_bgu_=0;
             blit$0(str,_bgu_,res,_bgt_,len)}}}
      return usob(res)}
    function fix_int_precision(prec,str)
     {var
       prec$0=abs(prec),
       len=caml_ml_string_length(str),
       c=caml_string_get(str,0),
       switch$0=0;
      if(58 <= c)
       {if(71 <= c)
         {if(! (5 < c - 97 >>> 0))switch$0 = 1}
        else
         if(65 <= c)switch$0 = 1}
      else
       {var switch$1=0;
        if(32 !== c)
         if(43 <= c)
          switch(c - 43 | 0)
           {case 5:
             if(len < (prec$0 + 2 | 0) && 1 < len)
              {var switch$2=0;
               if
                (120
                 ===
                 caml_string_get(str,1)
                 ||
                 88
                 ===
                 caml_string_get(str,1))
                switch$2 = 1;
               if(switch$2)
                {var
                  _bga_=48,
                  _bgb_=prec$0 + 2 | 0,
                  res$1=make$0(_bgb_,_bga_),
                  _bgc_=caml_string_get(str,1);
                 caml_bytes_set(res$1,1,_bgc_);
                 var
                  _bgd_=len - 2 | 0,
                  _bge_=(prec$0 - len | 0) + 4 | 0,
                  _bgf_=2;
                 blit$0(str,_bgf_,res$1,_bge_,_bgd_);
                 return usob(res$1)}}
             switch$0 = 1;
             switch$1 = 1;
             break;
            case 0:
            case 2:break;
            case 1:
            case 3:
            case 4:switch$1 = 1;break;
            default:switch$0 = 1;switch$1 = 1}
         else
          switch$1 = 1;
        if(! switch$1 && len < (prec$0 + 1 | 0))
         {var _bf7_=48,_bf8_=prec$0 + 1 | 0,res$0=make$0(_bf8_,_bf7_);
          caml_bytes_set(res$0,0,c);
          var _bf9_=len - 1 | 0,_bf__=(prec$0 - len | 0) + 2 | 0,_bf$_=1;
          blit$0(str,_bf$_,res$0,_bf__,_bf9_);
          return usob(res$0)}}
      if(switch$0 && len < prec$0)
       {var _bf4_=48,res=make$0(prec$0,_bf4_),_bf5_=prec$0 - len | 0,_bf6_=0;
        blit$0(str,_bf6_,res,_bf5_,len);
        return usob(res)}
      return str}
    function string_to_caml_string(str)
     {var
       str$0=escaped$1(str),
       l=caml_ml_string_length(str$0),
       _bf2_=34,
       _bf3_=l + 2 | 0,
       res=make$0(_bf3_,_bf2_);
      caml_blit_string(str$0,0,res,1,l);
      return usob(res)}
    function format_of_iconv(param)
     {switch(param)
       {case 1:return _a5_;
        case 2:return _a6_;
        case 4:return _a8_;
        case 5:return _a9_;
        case 6:return _a__;
        case 7:return _a$_;
        case 8:return _ba_;
        case 9:return _bb_;
        case 10:return _bc_;
        case 11:return _bd_;
        case 0:
        case 13:return _a4_;
        case 3:
        case 14:return _a7_;
        default:return _be_}}
    function format_of_iconvL(param)
     {switch(param)
       {case 1:return _bg_;
        case 2:return _bh_;
        case 4:return _bj_;
        case 5:return _bk_;
        case 6:return _bl_;
        case 7:return _bm_;
        case 8:return _bn_;
        case 9:return _bo_;
        case 10:return _bp_;
        case 11:return _bq_;
        case 0:
        case 13:return _bf_;
        case 3:
        case 14:return _bi_;
        default:return _br_}}
    function format_of_iconvl(param)
     {switch(param)
       {case 1:return _bt_;
        case 2:return _bu_;
        case 4:return _bw_;
        case 5:return _bx_;
        case 6:return _by_;
        case 7:return _bz_;
        case 8:return _bA_;
        case 9:return _bB_;
        case 10:return _bC_;
        case 11:return _bD_;
        case 0:
        case 13:return _bs_;
        case 3:
        case 14:return _bv_;
        default:return _bE_}}
    function format_of_iconvn(param)
     {switch(param)
       {case 1:return _bG_;
        case 2:return _bH_;
        case 4:return _bJ_;
        case 5:return _bK_;
        case 6:return _bL_;
        case 7:return _bM_;
        case 8:return _bN_;
        case 9:return _bO_;
        case 10:return _bP_;
        case 11:return _bQ_;
        case 0:
        case 13:return _bF_;
        case 3:
        case 14:return _bI_;
        default:return _bR_}}
    function format_of_fconv(fconv,prec)
     {var
       prec$0=abs(prec),
       symb=char_of_fconv(_bS_,fconv),
       _bfY_=16,
       buf=buffer_create(_bfY_),
       _bfZ_=37;
      buffer_add_char(buf,_bfZ_);
      bprint_fconv_flag(buf,fconv);
      var _bf0_=46;
      buffer_add_char(buf,_bf0_);
      var _bf1_=to_string$1(prec$0);
      buffer_add_string(buf,_bf1_);
      buffer_add_char(buf,symb);
      return buffer_contents(buf)}
    function transform_int_alt(iconv,s)
     {if(13 <= iconv)
       {var n=[0,0],_bfQ_=caml_ml_string_length(s) - 1 | 0,_bfP_=0;
        if(! (_bfQ_ < 0))
         {var i$0=_bfP_;
          for(;;)
           {var match=caml_string_unsafe_get(s,i$0);
            if(! (9 < match - 48 >>> 0))n[1]++;
            var _bfW_=i$0 + 1 | 0;
            if(_bfQ_ !== i$0){var i$0=_bfW_;continue}
            break}}
        var
         digits=n[1],
         _bfR_=caml_ml_string_length(s) + ((digits - 1 | 0) / 3 | 0) | 0,
         buf=caml_create_bytes(_bfR_),
         pos=[0,0],
         put=
          function(c)
           {var _bfX_=pos[1];caml_bytes_set(buf,_bfX_,c);pos[1]++;return 0},
         left=[0,((digits - 1 | 0) % 3 | 0) + 1 | 0],
         _bfT_=caml_ml_string_length(s) - 1 | 0,
         _bfS_=0;
        if(! (_bfT_ < 0))
         {var i=_bfS_;
          for(;;)
           {var c=caml_string_unsafe_get(s,i);
            if(9 < c - 48 >>> 0)
             put(c);
            else
             {if(0 === left[1]){var _bfV_=95;put(_bfV_);left[1] = 3}
              left[1] += -1;
              put(c)}
            var _bfU_=i + 1 | 0;
            if(_bfT_ !== i){var i=_bfU_;continue}
            break}}
        return usob(buf)}
      return s}
    function convert_int(iconv,n)
     {var _bfO_=format_of_iconv(iconv);
      return transform_int_alt(iconv,caml_format_int(_bfO_,n))}
    function convert_int32(iconv,n)
     {var _bfN_=format_of_iconvl(iconv);
      return transform_int_alt(iconv,caml_format_int(_bfN_,n))}
    function convert_nativeint(iconv,n)
     {var _bfM_=format_of_iconvn(iconv);
      return transform_int_alt(iconv,caml_format_int(_bfM_,n))}
    function convert_int64(iconv,n)
     {var _bfL_=format_of_iconvL(iconv);
      return transform_int_alt(iconv,caml_int64_format(_bfL_,n))}
    function convert_float(fconv,prec,x)
     {function hex(param)
       {switch(fconv[1])
         {case 0:var sign=45;break;
          case 1:var sign=43;break;
          default:var sign=32}
        return caml_hexstring_of_float(x,prec,sign)}
      function add_dot_if_needed(str)
       {var len=caml_ml_string_length(str);
        function is_valid(i)
         {var i$0=i;
          for(;;)
           {if(i$0 === len)return 0;
            var
             match=caml_string_get(str,i$0),
             _bfK_=match - 46 | 0,
             switch$0=0;
            if(23 < _bfK_ >>> 0)
             {if(55 === _bfK_)switch$0 = 1}
            else
             if(21 < _bfK_ - 1 >>> 0)switch$0 = 1;
            if(switch$0)return 1;
            var i$1=i$0 + 1 | 0,i$0=i$1;
            continue}}
        var _bfJ_=0;
        return is_valid(_bfJ_)?str:cat(str,_bT_)}
      function caml_special_val(str)
       {var match=caml_classify_float(x);
        return 3 === match?x < 0.?_bU_:_bV_:4 <= match?_bW_:str}
      switch(fconv[2])
       {case 5:
         var _bfG_=format_of_fconv(fconv,prec),str=caml_format_float(_bfG_,x);
         return caml_special_val(add_dot_if_needed(str));
        case 6:return hex(0);
        case 7:var _bfH_=0;return uppercase_ascii$1(hex(_bfH_));
        case 8:var _bfI_=0;return caml_special_val(hex(_bfI_));
        default:
         var _bfF_=format_of_fconv(fconv,prec);
         return caml_format_float(_bfF_,x)}}
    function format_caml_char(c)
     {var
       str=escaped(c),
       l=caml_ml_string_length(str),
       _bfD_=39,
       _bfE_=l + 2 | 0,
       res=make$0(_bfE_,_bfD_);
      caml_blit_string(str,0,res,1,l);
      return usob(res)}
    function string_of_fmtty(fmtty)
     {var _bfC_=16,buf=buffer_create(_bfC_);
      bprint_fmtty(buf,fmtty);
      return buffer_contents(buf)}
    function make_printf$0(counter,k,acc,fmt)
     {var k$0=k,acc$0=acc,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,acc$0);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,new_acc,rest)};
          case 1:
           var rest$0=fmt$0[1];
           return function(c)
            {var new_acc=[4,acc$0,format_caml_char(c)];
             return make_printf(k$0,new_acc,rest$0)};
          case 2:
           var rest$1=fmt$0[2],pad=fmt$0[1];
           return make_padding(k$0,acc$0,rest$1,pad,function(str){return str});
          case 3:
           var rest$2=fmt$0[2],pad$0=fmt$0[1];
           return make_padding(k$0,acc$0,rest$2,pad$0,string_to_caml_string);
          case 4:
           var rest$3=fmt$0[4],prec=fmt$0[3],pad$1=fmt$0[2],iconv=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$3,pad$1,prec,convert_int,iconv);
          case 5:
           var
            rest$4=fmt$0[4],
            prec$0=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$0=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$4,pad$2,prec$0,convert_int32,iconv$0);
          case 6:
           var
            rest$5=fmt$0[4],
            prec$1=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$1=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$5,pad$3,prec$1,convert_nativeint,iconv$1);
          case 7:
           var
            rest$6=fmt$0[4],
            prec$2=fmt$0[3],
            pad$4=fmt$0[2],
            iconv$2=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$6,pad$4,prec$2,convert_int64,iconv$2);
          case 8:
           var rest$7=fmt$0[4],prec$3=fmt$0[3],pad$5=fmt$0[2],fconv=fmt$0[1];
           return make_float_padding_precision
                   (k$0,acc$0,rest$7,pad$5,prec$3,fconv);
          case 9:
           var rest$8=fmt$0[2],pad$6=fmt$0[1];
           return make_padding(k$0,acc$0,rest$8,pad$6,string_of_bool);
          case 10:
           var fmt$1=fmt$0[1],acc$1=[7,acc$0],acc$0=acc$1,fmt$0=fmt$1;
           continue;
          case 11:
           var
            fmt$2=fmt$0[2],
            str=fmt$0[1],
            acc$2=[2,acc$0,str],
            acc$0=acc$2,
            fmt$0=fmt$2;
           continue;
          case 12:
           var
            fmt$3=fmt$0[2],
            chr=fmt$0[1],
            acc$3=[3,acc$0,chr],
            acc$0=acc$3,
            fmt$0=fmt$3;
           continue;
          case 13:
           var
            rest$9=fmt$0[3],
            sub_fmtty=fmt$0[2],
            ty=string_of_fmtty(sub_fmtty);
           return function(str){return make_printf(k$0,[4,acc$0,ty],rest$9)};
          case 14:
           var rest$10=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1],_bfB_=recast(fmt,fmtty);
             return make_printf(k$0,acc$0,concat_fmt(_bfB_,rest$10))};
          case 15:
           var rest$11=fmt$0[1];
           return function(f,x)
            {return make_printf
                     (k$0,
                      [6,acc$0,function(o){return caml_call2(f,o,x)}],
                      rest$11)};
          case 16:
           var rest$12=fmt$0[1];
           return function(f){return make_printf(k$0,[6,acc$0,f],rest$12)};
          case 17:
           var
            fmt$4=fmt$0[2],
            fmting_lit=fmt$0[1],
            acc$4=[0,acc$0,fmting_lit],
            acc$0=acc$4,
            fmt$0=fmt$4;
           continue;
          case 18:
           var _bfy_=fmt$0[1];
           if(0 === _bfy_[0])
            {var
              rest$13=fmt$0[2],
              match=_bfy_[1],
              fmt$5=match[1],
              k$3=
               function(acc,k,rest)
                {function k$0(kacc)
                  {return make_printf(k,[1,acc,[0,kacc]],rest)}
                 return k$0},
              k$1=k$3(acc$0,k$0,rest$13),
              k$0=k$1,
              acc$0=0,
              fmt$0=fmt$5;
             continue}
           var
            rest$14=fmt$0[2],
            match$0=_bfy_[1],
            fmt$6=match$0[1],
            k$4=
             function(acc,k,rest)
              {function k$0(kacc){return make_printf(k,[1,acc,[1,kacc]],rest)}
               return k$0},
            k$2=k$4(acc$0,k$0,rest$14),
            k$0=k$2,
            acc$0=0,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_bX_];
          case 20:
           var rest$15=fmt$0[3],new_acc=[8,acc$0,_bY_];
           return function(param){return make_printf(k$0,new_acc,rest$15)};
          case 21:
           var rest$16=fmt$0[2];
           return function(n)
            {var new_acc=[4,acc$0,caml_format_int(_bZ_,n)];
             return make_printf(k$0,new_acc,rest$16)};
          case 22:
           var rest$17=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,new_acc,rest$17)};
          case 23:
           var rest$18=fmt$0[2],ign=fmt$0[1];
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return make_ignored_param(counter$1,k$0,acc$0,ign,rest$18)}
           return caml_trampoline_return
                   (make_ignored_param,[0,k$0,acc$0,ign,rest$18]);
          default:
           var
            rest$19=fmt$0[3],
            f=fmt$0[2],
            arity=fmt$0[1],
            _bfz_=0,
            _bfA_=caml_call1(f,_bfz_);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return make_custom$0(counter$0,k$0,acc$0,rest$19,arity,_bfA_)}
           return caml_trampoline_return
                   (make_custom$0,[0,k$0,acc$0,rest$19,arity,_bfA_])}}
    function make_ignored_param(counter,k,acc,ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return make_invalid_arg(counter$0,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$1=counter + 1 | 0;
            return make_invalid_arg(counter$1,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 2:throw [0,Assert_failure,_b0_];
         default:
          if(counter < 50)
           {var counter$2=counter + 1 | 0;
            return make_invalid_arg(counter$2,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}
      else
       switch(ign[0])
        {case 0:
          if(counter < 50)
           {var counter$3=counter + 1 | 0;
            return make_invalid_arg(counter$3,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$4=counter + 1 | 0;
            return make_invalid_arg(counter$4,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 2:
          if(counter < 50)
           {var counter$5=counter + 1 | 0;
            return make_invalid_arg(counter$5,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 3:
          if(counter < 50)
           {var counter$6=counter + 1 | 0;
            return make_invalid_arg(counter$6,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 4:
          if(counter < 50)
           {var counter$7=counter + 1 | 0;
            return make_invalid_arg(counter$7,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 5:
          if(counter < 50)
           {var counter$8=counter + 1 | 0;
            return make_invalid_arg(counter$8,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 6:
          if(counter < 50)
           {var counter$9=counter + 1 | 0;
            return make_invalid_arg(counter$9,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 7:
          if(counter < 50)
           {var counter$10=counter + 1 | 0;
            return make_invalid_arg(counter$10,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 8:
          if(counter < 50)
           {var counter$11=counter + 1 | 0;
            return make_invalid_arg(counter$11,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 9:
          var fmtty=ign[2];
          if(counter < 50)
           {var counter$14=counter + 1 | 0;
            return make_from_fmtty$0(counter$14,k,acc,fmtty,fmt)}
          return caml_trampoline_return(make_from_fmtty$0,[0,k,acc,fmtty,fmt]);
         case 10:
          if(counter < 50)
           {var counter$12=counter + 1 | 0;
            return make_invalid_arg(counter$12,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         default:
          if(counter < 50)
           {var counter$13=counter + 1 | 0;
            return make_invalid_arg(counter$13,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}}
    function make_from_fmtty$0(counter,k,acc,fmtty,fmt)
     {if(typeof fmtty === "number")
       {if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return make_invalid_arg(counter$0,k,acc,fmt)}
        return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}
      else
       switch(fmtty[0])
        {case 0:
          var rest=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest,fmt)};
         case 1:
          var rest$0=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$0,fmt)};
         case 2:
          var rest$1=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$1,fmt)};
         case 3:
          var rest$2=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$2,fmt)};
         case 4:
          var rest$3=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$3,fmt)};
         case 5:
          var rest$4=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$4,fmt)};
         case 6:
          var rest$5=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$5,fmt)};
         case 7:
          var rest$6=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$6,fmt)};
         case 8:
          var rest$7=fmtty[2];
          return function(param){return make_from_fmtty(k,acc,rest$7,fmt)};
         case 9:
          var
           rest$8=fmtty[3],
           ty2=fmtty[2],
           ty1=fmtty[1],
           _bfw_=symm(ty1),
           ty=trans(_bfw_,ty2);
          return function(param)
           {return make_from_fmtty(k,acc,concat_fmtty(ty,rest$8),fmt)};
         case 10:
          var rest$9=fmtty[1];
          return function(param,_bfx_)
           {return make_from_fmtty(k,acc,rest$9,fmt)};
         case 11:
          var rest$10=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$10,fmt)};
         case 12:
          var rest$11=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$11,fmt)};
         case 13:throw [0,Assert_failure,_b1_];
         default:throw [0,Assert_failure,_b2_]}}
    function make_invalid_arg(counter,k,acc,fmt)
     {var _bfv_=[8,acc,_b3_];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,_bfv_,fmt)}
      return caml_trampoline_return(make_printf$0,[0,k,_bfv_,fmt])}
    function make_custom$0(counter,k,acc,rest,arity,f)
     {if(arity)
       {var arity$0=arity[1];
        return function(x)
         {return make_custom(k,acc,rest,arity$0,caml_call1(f,x))}}
      var _bfu_=[4,acc,f];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,_bfu_,rest)}
      return caml_trampoline_return(make_printf$0,[0,k,_bfu_,rest])}
    function make_printf(k,acc,fmt)
     {return caml_trampoline(make_printf$0(0,k,acc,fmt))}
    function make_from_fmtty(k,acc,fmtty,fmt)
     {return caml_trampoline(make_from_fmtty$0(0,k,acc,fmtty,fmt))}
    function make_custom(k,acc,rest,arity,f)
     {return caml_trampoline(make_custom$0(0,k,acc,rest,arity,f))}
    function make_padding(k,acc,fmt,pad,trans)
     {if(typeof pad === "number")
       return function(x)
        {var new_acc=[4,acc,caml_call1(trans,x)];
         return make_printf(k,new_acc,fmt)};
      else
       {if(0 === pad[0])
         {var width=pad[2],padty=pad[1];
          return function(x)
           {var
             _bft_=caml_call1(trans,x),
             new_acc=[4,acc,fix_padding(padty,width,_bft_)];
            return make_printf(k,new_acc,fmt)}}
        var padty$0=pad[1];
        return function(w,x)
         {var
           _bfs_=caml_call1(trans,x),
           new_acc=[4,acc,fix_padding(padty$0,w,_bfs_)];
          return make_printf(k,new_acc,fmt)}}}
    function make_int_padding_precision(k,acc,fmt,pad,prec,trans,iconv)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         return prec
                 ?function(p,x)
                   {var
                     _bfh_=caml_call2(trans,iconv,x),
                     str=fix_int_precision(p,_bfh_);
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(x)
                   {var str=caml_call2(trans,iconv,x);
                    return make_printf(k,[4,acc,str],fmt)};
        var p=prec[1];
        return function(x)
         {var _bfg_=caml_call2(trans,iconv,x),str=fix_int_precision(p,_bfg_);
          return make_printf(k,[4,acc,str],fmt)}}
      else
       {if(0 === pad[0])
         {var _bfd_=pad[2],_bfe_=pad[1];
          if(typeof prec === "number")
           return prec
                   ?function(p,x)
                     {var
                       _bfp_=caml_call2(trans,iconv,x),
                       _bfq_=fix_int_precision(p,_bfp_),
                       str=fix_padding(_bfe_,_bfd_,_bfq_);
                      return make_printf(k,[4,acc,str],fmt)}
                   :function(x)
                     {var
                       _bfr_=caml_call2(trans,iconv,x),
                       str=fix_padding(_bfe_,_bfd_,_bfr_);
                      return make_printf(k,[4,acc,str],fmt)};
          var p$0=prec[1];
          return function(x)
           {var
             _bfn_=caml_call2(trans,iconv,x),
             _bfo_=fix_int_precision(p$0,_bfn_),
             str=fix_padding(_bfe_,_bfd_,_bfo_);
            return make_printf(k,[4,acc,str],fmt)}}
        var _bff_=pad[1];
        if(typeof prec === "number")
         return prec
                 ?function(w,p,x)
                   {var
                     _bfk_=caml_call2(trans,iconv,x),
                     _bfl_=fix_int_precision(p,_bfk_),
                     str=fix_padding(_bff_,w,_bfl_);
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(w,x)
                   {var
                     _bfm_=caml_call2(trans,iconv,x),
                     str=fix_padding(_bff_,w,_bfm_);
                    return make_printf(k,[4,acc,str],fmt)};
        var p$1=prec[1];
        return function(w,x)
         {var
           _bfi_=caml_call2(trans,iconv,x),
           _bfj_=fix_int_precision(p$1,_bfi_),
           str=fix_padding(_bff_,w,_bfj_);
          return make_printf(k,[4,acc,str],fmt)}}}
    function make_float_padding_precision(k,acc,fmt,pad,prec,fconv)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         return prec
                 ?function(p,x)
                   {var str=convert_float(fconv,p,x);
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(x)
                   {var
                     _be8_=default_float_precision(fconv),
                     str=convert_float(fconv,_be8_,x);
                    return make_printf(k,[4,acc,str],fmt)};
        var p=prec[1];
        return function(x)
         {var str=convert_float(fconv,p,x);
          return make_printf(k,[4,acc,str],fmt)}}
      else
       {if(0 === pad[0])
         {var _be5_=pad[2],_be6_=pad[1];
          if(typeof prec === "number")
           return prec
                   ?function(p,x)
                     {var
                       _bfb_=convert_float(fconv,p,x),
                       str=fix_padding(_be6_,_be5_,_bfb_);
                      return make_printf(k,[4,acc,str],fmt)}
                   :function(x)
                     {var
                       _bfc_=default_float_precision(fconv),
                       str=convert_float(fconv,_bfc_,x),
                       str$0=fix_padding(_be6_,_be5_,str);
                      return make_printf(k,[4,acc,str$0],fmt)};
          var p$0=prec[1];
          return function(x)
           {var
             _bfa_=convert_float(fconv,p$0,x),
             str=fix_padding(_be6_,_be5_,_bfa_);
            return make_printf(k,[4,acc,str],fmt)}}
        var _be7_=pad[1];
        if(typeof prec === "number")
         return prec
                 ?function(w,p,x)
                   {var
                     _be__=convert_float(fconv,p,x),
                     str=fix_padding(_be7_,w,_be__);
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(w,x)
                   {var
                     _be$_=default_float_precision(fconv),
                     str=convert_float(fconv,_be$_,x),
                     str$0=fix_padding(_be7_,w,str);
                    return make_printf(k,[4,acc,str$0],fmt)};
        var p$1=prec[1];
        return function(w,x)
         {var _be9_=convert_float(fconv,p$1,x),str=fix_padding(_be7_,w,_be9_);
          return make_printf(k,[4,acc,str],fmt)}}}
    function output_acc(o,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           output_acc(o,p);
           return output_string(o,s);
          case 1:
           var _be3_=acc$0[2],_be4_=acc$0[1];
           if(0 === _be3_[0])
            {var acc$1=_be3_[1];
             output_acc(o,_be4_);
             output_string(o,_b4_);
             var acc$0=acc$1;
             continue}
           var acc$2=_be3_[1];
           output_acc(o,_be4_);
           output_string(o,_b5_);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           output_acc(o,p$2);
           return caml_call1(f,o);
          case 7:var p$3=acc$0[1];output_acc(o,p$3);return flush(o);
          case 8:
           var msg=acc$0[2],p$4=acc$0[1];
           output_acc(o,p$4);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           output_acc(o,p$0);
           return output_string(o,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];
           output_acc(o,p$1);
           return output_char(o,c)}}
    function strput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           strput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _be0_=acc$0[2],_be1_=acc$0[1];
           if(0 === _be0_[0])
            {var acc$1=_be0_[1];
             strput_acc(b,_be1_);
             add_string(b,_b6_);
             var acc$0=acc$1;
             continue}
           var acc$2=_be0_[1];
           strput_acc(b,_be1_);
           add_string(b,_b7_);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           strput_acc(b,p$2);
           var _be2_=0;
           return add_string(b,caml_call1(f,_be2_));
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           strput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           strput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];strput_acc(b,p$1);return add_char(b,c)}}
    function failwith_message(param)
     {var fmt=param[1],_beZ_=256,buf=create$1(_beZ_);
      function k(acc){strput_acc(buf,acc);return failwith(contents(buf))}
      return make_printf(k,0,fmt)}
    function open_box_of_string(str)
     {if(caml_string_equal(str,_b8_))return _b9_;
      var len=caml_ml_string_length(str);
      function invalid_box(param)
       {return caml_call1(failwith_message(_b__),str)}
      function parse_spaces(i)
       {var i$0=i;
        for(;;)
         {if(i$0 === len)return i$0;
          var match=caml_string_get(str,i$0);
          if(9 !== match && 32 !== match)return i$0;
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function parse_lword(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0);
          if(25 < match - 97 >>> 0)return j$0;
          var j$1=j$0 + 1 | 0,j$0=j$1;
          continue}}
      function parse_int(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switch$0=0;
          if(48 <= match)
           {if(! (58 <= match))switch$0 = 1}
          else
           if(45 === match)switch$0 = 1;
          if(switch$0){var j$1=j$0 + 1 | 0,j$0=j$1;continue}
          return j$0}}
      var
       _beP_=0,
       wstart=parse_spaces(_beP_),
       wend=parse_lword(wstart,wstart),
       _beQ_=wend - wstart | 0,
       box_name=sub$0(str,wstart,_beQ_),
       nstart=parse_spaces(wend),
       nend=parse_int(nstart,nstart);
      if(nstart === nend)
       var indent=0;
      else
       try
        {var
          _beV_=nend - nstart | 0,
          _beW_=sub$0(str,nstart,_beV_),
          _beX_=caml_int_of_string(_beW_),
          indent=_beX_}
       catch(_beY_)
        {_beY_ = caml_wrap_exception(_beY_);
         if(_beY_[1] !== Failure)throw _beY_;
         var _beT_=0,_beU_=invalid_box(_beT_),indent=_beU_}
      var exp_end=parse_spaces(nend);
      if(exp_end !== len){var _beR_=0;invalid_box(_beR_)}
      var switch$0=0;
      if
       (caml_string_notequal(box_name,_b$_)
        &&
        caml_string_notequal(box_name,_ca_))
       if(caml_string_notequal(box_name,_cb_))
        if(caml_string_notequal(box_name,_cc_))
         if(caml_string_notequal(box_name,_cd_))
          if(caml_string_notequal(box_name,_ce_))
           var _beS_=0,box_type=invalid_box(_beS_);
          else
           var box_type=1;
         else
          var box_type=2;
        else
         var box_type=3;
       else
        var box_type=0;
      else
       switch$0 = 1;
      if(switch$0)var box_type=4;
      return [0,indent,box_type]}
    function make_padding_fmt_ebb(pad,fmt)
     {if(typeof pad === "number")
       return [0,0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],fmt]}}
    function make_precision_fmt_ebb(prec,fmt)
     {if(typeof prec === "number")return prec?[0,1,fmt]:[0,0,fmt];
      var p=prec[1];
      return [0,[0,p],fmt]}
    function make_padprec_fmt_ebb(pad,prec,fmt)
     {var
       match=make_precision_fmt_ebb(prec,fmt),
       fmt$0=match[2],
       prec$0=match[1];
      if(typeof pad === "number")
       return [0,0,prec$0,fmt$0];
      else
       {if(0 === pad[0])
         {var w=pad[2],s=pad[1];return [0,[0,s,w],prec$0,fmt$0]}
        var s$0=pad[1];
        return [0,[1,s$0],prec$0,fmt$0]}}
    function fmt_ebb_of_string(legacy_behavior,str)
     {if(legacy_behavior)
       var flag=legacy_behavior[1],legacy_behavior$0=flag;
      else
       var legacy_behavior$0=1;
      function invalid_format_message(str_ind,msg)
       {return caml_call3(failwith_message(_cf_),str,str_ind,msg)}
      function unexpected_end_of_format(end_ind)
       {return invalid_format_message(end_ind,_cg_)}
      function invalid_nonnull_char_width(str_ind)
       {return invalid_format_message(str_ind,_ch_)}
      function invalid_format_without(str_ind,c,s)
       {return caml_call4(failwith_message(_ci_),str,str_ind,c,s)}
      function expected_character(str_ind,expected,read)
       {return caml_call4(failwith_message(_cj_),str,str_ind,expected,read)}
      function add_literal(lit_start,str_ind,fmt)
       {var size=str_ind - lit_start | 0;
        return 0 === size
                ?[0,fmt]
                :1 === size
                  ?[0,[12,caml_string_get(str,lit_start),fmt]]
                  :[0,[11,sub$0(str,lit_start,size),fmt]]}
      function parse_positive(str_ind,end_ind,acc)
       {var str_ind$0=str_ind,acc$0=acc;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var c=caml_string_get(str,str_ind$0);
          if(9 < c - 48 >>> 0)return [0,str_ind$0,acc$0];
          var acc$1=(acc$0 * 10 | 0) + (c - 48 | 0) | 0;
          if(max_string_length < acc$1)
           return caml_call3
                   (failwith_message(_cS_),str,acc$1,max_string_length);
          var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,acc$0=acc$1;
          continue}}
      function parse_integer(str_ind,end_ind)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var match=caml_string_get(str,str_ind);
        if(48 <= match)
         {if(! (58 <= match))return parse_positive(str_ind,end_ind,0)}
        else
         if(45 === match)
          {if((str_ind + 1 | 0) === end_ind)unexpected_end_of_format(end_ind);
           var _beM_=str_ind + 1 | 0,c=caml_string_get(str,_beM_);
           if(9 < c - 48 >>> 0)
            return expected_character(str_ind + 1 | 0,_cU_,c);
           var
            _beN_=0,
            _beO_=str_ind + 1 | 0,
            match$0=parse_positive(_beO_,end_ind,_beN_),
            n=match$0[2],
            next_ind=match$0[1];
           return [0,next_ind,- n | 0]}
        throw [0,Assert_failure,_cT_]}
      function parse_spaces(str_ind,end_ind)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          if(32 === caml_string_get(str,str_ind$0))
           {var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;continue}
          return str_ind$0}}
      function incompatible_flag(pct_ind,str_ind,symb,option)
       {var _beL_=str_ind - pct_ind | 0,subfmt=sub$0(str,pct_ind,_beL_);
        return caml_call5
                (failwith_message(_c6_),str,pct_ind,option,symb,subfmt)}
      function compute_float_conv(pct_ind,str_ind,plus,hash,space,symb)
       {if(plus)
         if(space && ! legacy_behavior$0)
          var _beK_=32,flag=incompatible_flag(pct_ind,str_ind,_beK_,_c5_);
         else
          var flag=1;
        else
         var flag=space?2:0;
        var switch$0=0;
        if(73 <= symb)
         {var switcher=symb - 101 | 0;
          if(3 < switcher >>> 0)
           switch$0 = 1;
          else
           {switch(switcher)
             {case 0:var _beI_=1;break;
              case 1:var _beI_=0;break;
              case 2:var _beI_=3;break;
              default:var _beI_=6}
            var kind=_beI_}}
        else
         if(69 <= symb)
          {var switch$1=0;
           switch(symb - 69 | 0)
            {case 0:var _beJ_=2;break;
             case 1:switch$0 = 1;switch$1 = 1;break;
             case 2:var _beJ_=4;break;
             default:var _beJ_=7}
           if(! switch$1)var kind=_beJ_}
         else
          switch$0 = 1;
        if(switch$0)
         {var switch$2=0;
          if(hash)
           if(70 === symb)var kind=8;else switch$2 = 1;
          else
           if(70 === symb)var kind=5;else switch$2 = 1;
          if(switch$2)throw [0,Assert_failure,_c4_]}
        return [0,flag,kind]}
      function compute_int_conv(pct_ind,str_ind,plus,hash,space,symb)
       {var plus$0=plus,hash$0=hash,space$0=space;
        for(;;)
         {var switch$0=0;
          if(plus$0)
           {if(hash$0)
             switch$0 = 1;
            else
             if(! space$0){if(100 === symb)return 1;if(105 === symb)return 4}}
          else
           if(hash$0)
            if(space$0)
             switch$0 = 1;
            else
             {var switcher$0=symb - 88 | 0;
              if(32 < switcher$0 >>> 0)
               switch$0 = 1;
              else
               switch(switcher$0)
                {case 0:return 9;
                 case 12:return 13;
                 case 17:return 14;
                 case 23:return 11;
                 case 29:return 15;
                 case 32:return 7;
                 default:switch$0 = 1}}
           else
            if(space$0)
             {if(100 === symb)return 2;if(105 === symb)return 5}
            else
             {var switcher$1=symb - 88 | 0;
              if(! (32 < switcher$1 >>> 0))
               switch(switcher$1)
                {case 0:return 8;
                 case 12:return 0;
                 case 17:return 3;
                 case 23:return 10;
                 case 29:return 12;
                 case 32:return 6
                 }}
          if(switch$0)
           {var switcher=symb - 88 | 0;
            if(! (32 < switcher >>> 0))
             switch(switcher)
              {case 0:if(legacy_behavior$0)return 9;break;
               case 23:if(legacy_behavior$0)return 11;break;
               case 32:if(legacy_behavior$0)return 7;break;
               case 12:
               case 17:
               case 29:
                if(legacy_behavior$0){var hash$0=0;continue}
                return incompatible_flag(pct_ind,str_ind,symb,_c3_)
               }}
          if(plus$0)
           {if(space$0)
             {if(legacy_behavior$0){var space$0=0;continue}
              return incompatible_flag(pct_ind,str_ind,32,_cZ_)}
            if(legacy_behavior$0){var plus$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,_c0_)}
          if(space$0)
           {if(legacy_behavior$0){var space$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,_c1_)}
          throw [0,Assert_failure,_c2_]}}
      function counter_of_char(symb)
       {if(108 <= symb)
         {if(! (111 <= symb))
           switch(symb - 108 | 0)
            {case 0:return 0;case 1:break;default:return 1}}
        else
         if(76 === symb)return 2;
        throw [0,Assert_failure,_cY_]}
      function is_int_base(symb)
       {var _beH_=symb - 88 | 0;
        if(! (32 < _beH_ >>> 0))
         switch(_beH_)
          {case 0:case 12:case 17:case 23:case 29:case 32:return 1}
        return 0}
      function search_subformat_end(str_ind,end_ind,c)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)
           caml_call3(failwith_message(_cV_),str,c,end_ind);
          var match=caml_string_get(str,str_ind$0);
          if(37 === match)
           {if((str_ind$0 + 1 | 0) === end_ind)
             unexpected_end_of_format(end_ind);
            var _bew_=str_ind$0 + 1 | 0;
            if(caml_string_get(str,_bew_) === c)return str_ind$0;
            var _bex_=str_ind$0 + 1 | 0,match$0=caml_string_get(str,_bex_);
            if(95 <= match$0)
             {if(123 <= match$0)
               {if(! (126 <= match$0))
                 switch(match$0 - 123 | 0)
                  {case 0:
                    var
                     _bey_=125,
                     _bez_=str_ind$0 + 2 | 0,
                     sub_end=search_subformat_end(_bez_,end_ind,_bey_),
                     str_ind$2=sub_end + 2 | 0,
                     str_ind$0=str_ind$2;
                    continue;
                   case 1:break;
                   default:
                    return expected_character(str_ind$0 + 1 | 0,_cW_,125)}}
              else
               if(! (96 <= match$0))
                {if((str_ind$0 + 2 | 0) === end_ind)
                  unexpected_end_of_format(end_ind);
                 var
                  _beA_=str_ind$0 + 2 | 0,
                  match$1=caml_string_get(str,_beA_);
                 if(40 === match$1)
                  {var
                    _beB_=41,
                    _beC_=str_ind$0 + 3 | 0,
                    sub_end$0=search_subformat_end(_beC_,end_ind,_beB_),
                    str_ind$3=sub_end$0 + 2 | 0,
                    str_ind$0=str_ind$3;
                   continue}
                 if(123 === match$1)
                  {var
                    _beD_=125,
                    _beE_=str_ind$0 + 3 | 0,
                    sub_end$1=search_subformat_end(_beE_,end_ind,_beD_),
                    str_ind$4=sub_end$1 + 2 | 0,
                    str_ind$0=str_ind$4;
                   continue}
                 var str_ind$5=str_ind$0 + 3 | 0,str_ind$0=str_ind$5;
                 continue}}
            else
             {if(40 === match$0)
               {var
                 _beF_=41,
                 _beG_=str_ind$0 + 2 | 0,
                 sub_end$2=search_subformat_end(_beG_,end_ind,_beF_),
                 str_ind$6=sub_end$2 + 2 | 0,
                 str_ind$0=str_ind$6;
                continue}
              if(41 === match$0)
               return expected_character(str_ind$0 + 1 | 0,_cX_,41)}
            var str_ind$1=str_ind$0 + 2 | 0,str_ind$0=str_ind$1;
            continue}
          var str_ind$7=str_ind$0 + 1 | 0,str_ind$0=str_ind$7;
          continue}}
      function parse_char_set(str_ind,end_ind)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var _bej_=0,char_set=create_char_set(_bej_);
        function add_char(c){return add_in_char_set(char_set,c)}
        function add_range(c$0,c)
         {if(! (c < c$0))
           {var i=c$0;
            for(;;)
             {var _beu_=char_of_int(i);
              add_in_char_set(char_set,_beu_);
              var _bev_=i + 1 | 0;
              if(c !== i){var i=_bev_;continue}
              break}}
          return 0}
        function fail_single_percent(str_ind)
         {return caml_call2(failwith_message(_cR_),str,str_ind)}
        function parse_char_set_content(counter,str_ind,end_ind)
         {var str_ind$0=str_ind;
          for(;;)
           {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
            var c=caml_string_get(str,str_ind$0);
            if(45 === c)
             {var _bes_=45;
              add_char(_bes_);
              var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
              continue}
            if(93 === c)return str_ind$0 + 1 | 0;
            var _bet_=str_ind$0 + 1 | 0;
            if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return parse_char_set_after_char$0(counter$0,_bet_,end_ind,c)}
            return caml_trampoline_return
                    (parse_char_set_after_char$0,[0,_bet_,end_ind,c])}}
        function parse_char_set_after_char$0(counter,str_ind,end_ind,c)
         {var str_ind$0=str_ind,c$0=c;
          for(;;)
           {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
            var c$1=caml_string_get(str,str_ind$0),switch$0=0;
            if(46 <= c$1)
             {if(64 === c$1)
               switch$0 = 1;
              else
               if(93 === c$1){add_char(c$0);return str_ind$0 + 1 | 0}}
            else
             if(37 === c$1)
              switch$0 = 1;
             else
              if(45 <= c$1)
               {var _ber_=str_ind$0 + 1 | 0;
                if(counter < 50)
                 {var counter$0=counter + 1 | 0;
                  return parse_char_set_after_minus
                          (counter$0,_ber_,end_ind,c$0)}
                return caml_trampoline_return
                        (parse_char_set_after_minus,[0,_ber_,end_ind,c$0])}
            if(switch$0 && 37 === c$0)
             {add_char(c$1);
              var _beq_=str_ind$0 + 1 | 0;
              if(counter < 50)
               {var counter$1=counter + 1 | 0;
                return parse_char_set_content(counter$1,_beq_,end_ind)}
              return caml_trampoline_return
                      (parse_char_set_content,[0,_beq_,end_ind])}
            if(37 === c$0)fail_single_percent(str_ind$0);
            add_char(c$0);
            var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,c$0=c$1;
            continue}}
        function parse_char_set_after_minus(counter,str_ind,end_ind,c)
         {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
          var c$0=caml_string_get(str,str_ind);
          if(37 === c$0)
           {if((str_ind + 1 | 0) === end_ind)
             unexpected_end_of_format(end_ind);
            var _bem_=str_ind + 1 | 0,c$1=caml_string_get(str,_bem_);
            if(37 !== c$1 && 64 !== c$1)return fail_single_percent(str_ind);
            add_range(c,c$1);
            var _ben_=str_ind + 2 | 0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;
              return parse_char_set_content(counter$1,_ben_,end_ind)}
            return caml_trampoline_return
                    (parse_char_set_content,[0,_ben_,end_ind])}
          if(93 === c$0)
           {add_char(c);var _beo_=45;add_char(_beo_);return str_ind + 1 | 0}
          add_range(c,c$0);
          var _bep_=str_ind + 1 | 0;
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return parse_char_set_content(counter$0,_bep_,end_ind)}
          return caml_trampoline_return
                  (parse_char_set_content,[0,_bep_,end_ind])}
        function parse_char_set_after_char(str_ind,end_ind,c)
         {return caml_trampoline
                  (parse_char_set_after_char$0(0,str_ind,end_ind,c))}
        function parse_char_set_start(str_ind,end_ind)
         {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
          var c=caml_string_get(str,str_ind);
          return parse_char_set_after_char(str_ind + 1 | 0,end_ind,c)}
        if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var match=caml_string_get(str,str_ind);
        if(94 === match)
         var
          str_ind$0=str_ind + 1 | 0,
          reverse=1,
          reverse$0=reverse,
          str_ind$1=str_ind$0;
        else
         var _bel_=0,reverse$0=_bel_,str_ind$1=str_ind;
        var
         next_ind=parse_char_set_start(str_ind$1,end_ind),
         char_set$0=freeze_char_set(char_set),
         _bek_=reverse$0?rev_char_set(char_set$0):char_set$0;
        return [0,next_ind,_bek_]}
      function parse_after_at(str_ind,end_ind)
       {if(str_ind === end_ind)return _cN_;
        var c=caml_string_get(str,str_ind);
        if(65 <= c)
         {if(94 <= c)
           {var switcher=c - 123 | 0;
            if(! (2 < switcher >>> 0))
             switch(switcher)
              {case 0:return parse_tag(1,str_ind + 1 | 0,end_ind);
               case 1:break;
               default:
                var
                 _bd$_=str_ind + 1 | 0,
                 match$0=parse(_bd$_,end_ind),
                 fmt_rest$0=match$0[1];
                return [0,[17,1,fmt_rest$0]]}}
          else
           if(91 <= c)
            switch(c - 91 | 0)
             {case 0:return parse_tag(0,str_ind + 1 | 0,end_ind);
              case 1:break;
              default:
               var
                _bea_=str_ind + 1 | 0,
                match$1=parse(_bea_,end_ind),
                fmt_rest$1=match$1[1];
               return [0,[17,0,fmt_rest$1]]}}
        else
         {if(10 === c)
           {var
             _beb_=str_ind + 1 | 0,
             match$2=parse(_beb_,end_ind),
             fmt_rest$2=match$2[1];
            return [0,[17,3,fmt_rest$2]]}
          if(32 <= c)
           switch(c - 32 | 0)
            {case 0:
              var
               _bec_=str_ind + 1 | 0,
               match$3=parse(_bec_,end_ind),
               fmt_rest$3=match$3[1];
              return [0,[17,_cO_,fmt_rest$3]];
             case 5:
              if((str_ind + 1 | 0) < end_ind)
               {var _bed_=str_ind + 1 | 0;
                if(37 === caml_string_get(str,_bed_))
                 {var
                   _bee_=str_ind + 2 | 0,
                   match$4=parse(_bee_,end_ind),
                   fmt_rest$4=match$4[1];
                  return [0,[17,6,fmt_rest$4]]}}
              var match$5=parse(str_ind,end_ind),fmt_rest$5=match$5[1];
              return [0,[12,64,fmt_rest$5]];
             case 12:
              var
               _bef_=str_ind + 1 | 0,
               match$6=parse(_bef_,end_ind),
               fmt_rest$6=match$6[1];
              return [0,[17,_cP_,fmt_rest$6]];
             case 14:
              var
               _beg_=str_ind + 1 | 0,
               match$7=parse(_beg_,end_ind),
               fmt_rest$7=match$7[1];
              return [0,[17,4,fmt_rest$7]];
             case 27:return parse_good_break(str_ind + 1 | 0,end_ind);
             case 28:return parse_magic_size(str_ind + 1 | 0,end_ind);
             case 31:
              var
               _beh_=str_ind + 1 | 0,
               match$8=parse(_beh_,end_ind),
               fmt_rest$8=match$8[1];
              return [0,[17,2,fmt_rest$8]];
             case 32:
              var
               _bei_=str_ind + 1 | 0,
               match$9=parse(_bei_,end_ind),
               fmt_rest$9=match$9[1];
              return [0,[17,5,fmt_rest$9]]
             }}
        var
         _bd__=str_ind + 1 | 0,
         match=parse(_bd__,end_ind),
         fmt_rest=match[1];
        return [0,[17,[2,c],fmt_rest]]}
      function parse_tag(is_open_tag,str_ind,end_ind)
       {try
         {if(str_ind === end_ind)throw Not_found;
          var match$0=caml_string_get(str,str_ind);
          if(60 === match$0)
           {var
             _bd3_=62,
             _bd4_=str_ind + 1 | 0,
             ind=index_from(str,_bd4_,_bd3_);
            if(end_ind <= ind)throw Not_found;
            var
             _bd5_=(ind - str_ind | 0) + 1 | 0,
             sub_str=sub$0(str,str_ind,_bd5_),
             _bd6_=ind + 1 | 0,
             match$1=parse(_bd6_,end_ind),
             fmt_rest$0=match$1[1],
             _bd7_=ind + 1 | 0,
             match$2=parse(str_ind,_bd7_),
             sub_fmt=match$2[1],
             sub_format$0=[0,sub_fmt,sub_str],
             formatting$0=is_open_tag?[0,sub_format$0]:[1,sub_format$0],
             _bd8_=[0,[18,formatting$0,fmt_rest$0]];
            return _bd8_}
          throw Not_found}
        catch(_bd9_)
         {_bd9_ = caml_wrap_exception(_bd9_);
          if(_bd9_ === Not_found)
           {var
             match=parse(str_ind,end_ind),
             fmt_rest=match[1],
             formatting=is_open_tag?[0,sub_format]:[1,sub_format];
            return [0,[18,formatting,fmt_rest]]}
          throw _bd9_}}
      function parse_good_break(str_ind,end_ind)
       {try
         {var
           _bdR_=str_ind === end_ind?1:0,
           _bdS_=_bdR_ || (60 !== caml_string_get(str,str_ind)?1:0);
          if(_bdS_)throw Not_found;
          var
           _bdT_=str_ind + 1 | 0,
           str_ind_1=parse_spaces(_bdT_,end_ind),
           match$0=caml_string_get(str,str_ind_1),
           switch$0=0;
          if(48 <= match$0)
           {if(! (58 <= match$0))switch$0 = 1}
          else
           if(45 === match$0)switch$0 = 1;
          if(! switch$0)throw Not_found;
          var
           match$1=parse_integer(str_ind_1,end_ind),
           width=match$1[2],
           str_ind_2=match$1[1],
           str_ind_3=parse_spaces(str_ind_2,end_ind),
           match$2=caml_string_get(str,str_ind_3),
           switcher=match$2 - 45 | 0,
           switch$1=0;
          if(12 < switcher >>> 0)
           if(17 === switcher)
            var
             _bdU_=(str_ind_3 - str_ind | 0) + 3 | 0,
             _bdV_=str_ind - 2 | 0,
             s=sub$0(str,_bdV_,_bdU_),
             _bdW_=[0,s,width,0],
             _bdX_=str_ind_3 + 1 | 0,
             formatting_lit$0=_bdW_,
             next_ind=_bdX_;
           else
            switch$1 = 1;
          else
           if(1 < switcher - 1 >>> 0)
            {var
              match$3=parse_integer(str_ind_3,end_ind),
              offset=match$3[2],
              str_ind_4=match$3[1],
              str_ind_5=parse_spaces(str_ind_4,end_ind);
             if(62 !== caml_string_get(str,str_ind_5))throw Not_found;
             var
              _bdY_=(str_ind_5 - str_ind | 0) + 3 | 0,
              _bdZ_=str_ind - 2 | 0,
              s$0=sub$0(str,_bdZ_,_bdY_),
              _bd0_=[0,s$0,width,offset],
              _bd1_=str_ind_5 + 1 | 0,
              formatting_lit$0=_bd0_,
              next_ind=_bd1_}
           else
            switch$1 = 1;
          if(switch$1)throw Not_found}
        catch(_bd2_)
         {_bd2_ = caml_wrap_exception(_bd2_);
          if(_bd2_ !== Not_found && _bd2_[1] !== Failure)throw _bd2_;
          var formatting_lit$0=formatting_lit,next_ind=str_ind}
        var match=parse(next_ind,end_ind),fmt_rest=match[1];
        return [0,[17,formatting_lit$0,fmt_rest]]}
      function parse_magic_size(str_ind,end_ind)
       {try
         {var
           str_ind_1=parse_spaces(str_ind,end_ind),
           match$2=caml_string_get(str,str_ind_1),
           switch$0=0;
          if(48 <= match$2)
           {if(! (58 <= match$2))switch$0 = 1}
          else
           if(45 === match$2)switch$0 = 1;
          if(switch$0)
           {var
             match$3=parse_integer(str_ind_1,end_ind),
             size=match$3[2],
             str_ind_2=match$3[1],
             str_ind_3=parse_spaces(str_ind_2,end_ind);
            if(62 !== caml_string_get(str,str_ind_3))throw Not_found;
            var
             _bdO_=(str_ind_3 - str_ind | 0) + 3 | 0,
             _bdP_=str_ind - 2 | 0,
             s=sub$0(str,_bdP_,_bdO_),
             _bdN_=[0,[0,str_ind_3 + 1 | 0,[1,s,size]]]}
          else
           var _bdN_=0;
          var _bdM_=_bdN_}
        catch(_bdQ_)
         {_bdQ_ = caml_wrap_exception(_bdQ_);
          if(_bdQ_ !== Not_found && _bdQ_[1] !== Failure)throw _bdQ_;
          var _bdL_=0,_bdM_=_bdL_}
        if(_bdM_)
         {var
           match=_bdM_[1],
           formatting_lit=match[2],
           next_ind=match[1],
           match$0=parse(next_ind,end_ind),
           fmt_rest=match$0[1];
          return [0,[17,formatting_lit,fmt_rest]]}
        var match$1=parse(str_ind,end_ind),fmt_rest$0=match$1[1];
        return [0,[17,_cQ_,fmt_rest$0]]}
      function parse_padding
       (pct_ind,str_ind,end_ind,zero,minus,plus,hash,space,ign)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        if(zero)
         if(minus)
          if(legacy_behavior$0)
           var padty=0;
          else
           var _bdK_=45,padty=incompatible_flag(pct_ind,str_ind,_bdK_,_cn_);
         else
          var padty=2;
        else
         var padty=minus?0:1;
        var match=caml_string_get(str,str_ind);
        if(48 <= match)
         {if(! (58 <= match))
           {var
             _bdJ_=0,
             match$0=parse_positive(str_ind,end_ind,_bdJ_),
             width=match$0[2],
             new_ind=match$0[1];
            return parse_after_padding
                    (pct_ind,
                     new_ind,
                     end_ind,
                     minus,
                     plus,
                     hash,
                     space,
                     ign,
                     [0,padty,width])}}
        else
         if(42 === match)
          return parse_after_padding
                  (pct_ind,
                   str_ind + 1 | 0,
                   end_ind,
                   minus,
                   plus,
                   hash,
                   space,
                   ign,
                   [1,padty]);
        switch(padty)
         {case 0:
           if(1 - legacy_behavior$0)
            {var _bdH_=45,_bdI_=str_ind - 1 | 0;
             invalid_format_without(_bdI_,_bdH_,_cl_)}
           return parse_after_padding
                   (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,0);
          case 1:
           return parse_after_padding
                   (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,0);
          default:
           return parse_after_padding
                   (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,_cm_)}}
      function parse_after_padding
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var symb=caml_string_get(str,str_ind);
        return 46 === symb
                ?parse_precision
                  (pct_ind,
                   str_ind + 1 | 0,
                   end_ind,
                   minus,
                   plus,
                   hash,
                   space,
                   ign,
                   pad)
                :parse_conversion
                  (pct_ind,
                   str_ind + 1 | 0,
                   end_ind,
                   plus,
                   hash,
                   space,
                   ign,
                   pad,
                   0,
                   pad,
                   symb)}
      function parse_precision
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        function parse_literal(minus,str_ind)
         {var
           _bdG_=0,
           match=parse_positive(str_ind,end_ind,_bdG_),
           prec=match[2],
           new_ind=match[1];
          return parse_after_precision
                  (pct_ind,
                   new_ind,
                   end_ind,
                   minus,
                   plus,
                   hash,
                   space,
                   ign,
                   pad,
                   [0,prec])}
        var symb=caml_string_get(str,str_ind);
        if(48 <= symb)
         {if(! (58 <= symb))return parse_literal(minus,str_ind)}
        else
         if(42 <= symb)
          switch(symb - 42 | 0)
           {case 0:
             return parse_after_precision
                     (pct_ind,
                      str_ind + 1 | 0,
                      end_ind,
                      minus,
                      plus,
                      hash,
                      space,
                      ign,
                      pad,
                      1);
            case 1:
            case 3:
             if(legacy_behavior$0)
              {var _bdF_=str_ind + 1 | 0,minus$0=minus || (45 === symb?1:0);
               return parse_literal(minus$0,_bdF_)}
             break
            }
        return legacy_behavior$0
                ?parse_after_precision
                  (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad,_co_)
                :invalid_format_without(str_ind - 1 | 0,46,_cp_)}
      function parse_after_precision
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad,prec)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        function parse_conv(padprec)
         {return parse_conversion
                  (pct_ind,
                   str_ind + 1 | 0,
                   end_ind,
                   plus,
                   hash,
                   space,
                   ign,
                   pad,
                   prec,
                   padprec,
                   caml_string_get(str,str_ind))}
        if(typeof pad === "number")
         {if(typeof prec === "number" && ! prec)return parse_conv(0);
          if(minus)
           {if(typeof prec === "number")return parse_conv(_cq_);
            var n=prec[1];
            return parse_conv([0,0,n])}
          if(typeof prec === "number")return parse_conv(_cr_);
          var n$0=prec[1];
          return parse_conv([0,1,n$0])}
        return parse_conv(pad)}
      function parse_conversion
       (pct_ind,str_ind,end_ind,plus,hash,space,ign,pad,prec,padprec,symb)
       {var
         plus_used=[0,0],
         hash_used=[0,0],
         space_used=[0,0],
         ign_used=[0,0],
         pad_used=[0,0],
         prec_used=[0,0];
        function get_plus(param){plus_used[1] = 1;return plus}
        function get_hash(param){hash_used[1] = 1;return hash}
        function get_space(param){space_used[1] = 1;return space}
        function get_ign(param){ign_used[1] = 1;return ign}
        function get_pad(param){pad_used[1] = 1;return pad}
        function get_prec(param){prec_used[1] = 1;return prec}
        function get_padprec(param){pad_used[1] = 1;return padprec}
        function get_int_pad(param)
         {var _bdD_=0,pad=get_pad(_bdD_),_bdE_=0,match=get_prec(_bdE_);
          if(typeof match === "number" && ! match)return pad;
          if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var n=pad[2];
                return legacy_behavior$0
                        ?[0,1,n]
                        :incompatible_flag(pct_ind,str_ind,48,_cs_)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_ct_
                      :incompatible_flag(pct_ind,str_ind,48,_cu_)
                    :pad}}
        function check_no_0(symb,pad)
         {if(typeof pad === "number")
           return pad;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var width=pad[2];
                return legacy_behavior$0
                        ?[0,1,width]
                        :incompatible_flag(pct_ind,str_ind,symb,_cv_)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_cw_
                      :incompatible_flag(pct_ind,str_ind,symb,_cx_)
                    :pad}}
        function opt_of_pad(c,pad)
         {if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             switch(pad[1])
              {case 0:
                var width=pad[2];
                return legacy_behavior$0
                        ?[0,width]
                        :incompatible_flag(pct_ind,str_ind,c,_cy_);
               case 1:var width$0=pad[2];return [0,width$0];
               default:
                var width$1=pad[2];
                return legacy_behavior$0
                        ?[0,width$1]
                        :incompatible_flag(pct_ind,str_ind,c,_cz_)}
            return incompatible_flag(pct_ind,str_ind,c,_cA_)}}
        function get_pad_opt(c)
         {var _bdC_=0;return opt_of_pad(c,get_pad(_bdC_))}
        function get_padprec_opt(c)
         {var _bdB_=0;return opt_of_pad(c,get_padprec(_bdB_))}
        function get_prec_opt(param)
         {var _bdA_=0,match=get_prec(_bdA_);
          if(typeof match === "number")
           return match?incompatible_flag(pct_ind,str_ind,95,_cB_):0;
          var ndec=match[1];
          return [0,ndec]}
        var switch$0=0;
        if(124 <= symb)
         switch$0 = 1;
        else
         switch(symb)
          {case 33:
            var
             match$5=parse(str_ind,end_ind),
             fmt_rest$5=match$5[1],
             fmt_result=[0,[10,fmt_rest$5]];
            break;
           case 40:
            var
             _bcr_=41,
             sub_end=search_subformat_end(str_ind,end_ind,_bcr_),
             _bcs_=sub_end + 2 | 0,
             match$7=parse(_bcs_,end_ind),
             fmt_rest$7=match$7[1],
             match$8=parse(str_ind,sub_end),
             sub_fmt=match$8[1],
             sub_fmtty=fmtty_of_fmt(sub_fmt),
             _bct_=0;
            if(get_ign(_bct_))
             var
              _bcu_=95,
              ignored$2=[9,get_pad_opt(_bcu_),sub_fmtty],
              _bcv_=[0,[23,ignored$2,fmt_rest$7]];
            else
             var
              _bcw_=40,
              _bcv_=[0,[14,get_pad_opt(_bcw_),sub_fmtty,fmt_rest$7]];
            var fmt_result=_bcv_;
            break;
           case 44:var fmt_result=parse(str_ind,end_ind);break;
           case 67:
            var
             match$11=parse(str_ind,end_ind),
             fmt_rest$10=match$11[1],
             _bcC_=0,
             _bcD_=get_ign(_bcC_)?[0,[23,1,fmt_rest$10]]:[0,[1,fmt_rest$10]],
             fmt_result=_bcD_;
            break;
           case 78:
            var
             match$15=parse(str_ind,end_ind),
             fmt_rest$14=match$15[1],
             counter$0=2,
             _bcW_=0;
            if(get_ign(_bcW_))
             var
              ignored$6=[11,counter$0],
              _bcX_=[0,[23,ignored$6,fmt_rest$14]];
            else
             var _bcX_=[0,[21,counter$0,fmt_rest$14]];
            var fmt_result=_bcX_;
            break;
           case 83:
            var
             _bcY_=0,
             _bcZ_=get_padprec(_bcY_),
             pad$6=check_no_0(symb,_bcZ_),
             match$16=parse(str_ind,end_ind),
             fmt_rest$15=match$16[1],
             _bc0_=0;
            if(get_ign(_bc0_))
             var
              _bc1_=95,
              ignored$7=[1,get_padprec_opt(_bc1_)],
              _bc2_=[0,[23,ignored$7,fmt_rest$15]];
            else
             var
              match$17=make_padding_fmt_ebb(pad$6,fmt_rest$15),
              fmt_rest$16=match$17[2],
              pad$7=match$17[1],
              _bc2_=[0,[3,pad$7,fmt_rest$16]];
            var fmt_result=_bc2_;
            break;
           case 91:
            var
             match$20=parse_char_set(str_ind,end_ind),
             char_set=match$20[2],
             next_ind=match$20[1],
             match$21=parse(next_ind,end_ind),
             fmt_rest$19=match$21[1],
             _bde_=0;
            if(get_ign(_bde_))
             var
              _bdf_=95,
              ignored$9=[10,get_pad_opt(_bdf_),char_set],
              _bdg_=[0,[23,ignored$9,fmt_rest$19]];
            else
             var
              _bdh_=91,
              _bdg_=[0,[20,get_pad_opt(_bdh_),char_set,fmt_rest$19]];
            var fmt_result=_bdg_;
            break;
           case 97:
            var
             match$22=parse(str_ind,end_ind),
             fmt_rest$20=match$22[1],
             fmt_result=[0,[15,fmt_rest$20]];
            break;
           case 99:
            var
             char_format=
              function(fmt_rest)
               {var _bdz_=0;
                return get_ign(_bdz_)?[0,[23,0,fmt_rest]]:[0,[0,fmt_rest]]},
             scan_format=
              function(fmt_rest)
               {var _bdy_=0;
                return get_ign(_bdy_)?[0,[23,3,fmt_rest]]:[0,[22,fmt_rest]]},
             match$23=parse(str_ind,end_ind),
             fmt_rest$21=match$23[1],
             _bdi_=99,
             match$24=get_pad_opt(_bdi_);
            if(match$24)
             var
              _bdj_=
               0 === match$24[1]
                ?scan_format(fmt_rest$21)
                :legacy_behavior$0
                  ?char_format(fmt_rest$21)
                  :invalid_nonnull_char_width(str_ind),
              _bdk_=_bdj_;
            else
             var _bdk_=char_format(fmt_rest$21);
            var fmt_result=_bdk_;
            break;
           case 114:
            var
             match$25=parse(str_ind,end_ind),
             fmt_rest$22=match$25[1],
             _bdl_=0,
             _bdm_=get_ign(_bdl_)?[0,[23,2,fmt_rest$22]]:[0,[19,fmt_rest$22]],
             fmt_result=_bdm_;
            break;
           case 115:
            var
             _bdn_=0,
             _bdo_=get_padprec(_bdn_),
             pad$9=check_no_0(symb,_bdo_),
             match$26=parse(str_ind,end_ind),
             fmt_rest$23=match$26[1],
             _bdp_=0;
            if(get_ign(_bdp_))
             var
              _bdq_=95,
              ignored$10=[0,get_padprec_opt(_bdq_)],
              _bdr_=[0,[23,ignored$10,fmt_rest$23]];
            else
             var
              match$27=make_padding_fmt_ebb(pad$9,fmt_rest$23),
              fmt_rest$24=match$27[2],
              pad$10=match$27[1],
              _bdr_=[0,[2,pad$10,fmt_rest$24]];
            var fmt_result=_bdr_;
            break;
           case 116:
            var
             match$28=parse(str_ind,end_ind),
             fmt_rest$25=match$28[1],
             fmt_result=[0,[16,fmt_rest$25]];
            break;
           case 123:
            var
             _bds_=125,
             sub_end$0=search_subformat_end(str_ind,end_ind,_bds_),
             match$29=parse(str_ind,sub_end$0),
             sub_fmt$0=match$29[1],
             _bdt_=sub_end$0 + 2 | 0,
             match$30=parse(_bdt_,end_ind),
             fmt_rest$26=match$30[1],
             sub_fmtty$0=fmtty_of_fmt(sub_fmt$0),
             _bdu_=0;
            if(get_ign(_bdu_))
             var
              _bdv_=95,
              ignored$11=[8,get_pad_opt(_bdv_),sub_fmtty$0],
              _bdw_=[0,[23,ignored$11,fmt_rest$26]];
            else
             var
              _bdx_=123,
              _bdw_=[0,[13,get_pad_opt(_bdx_),sub_fmtty$0,fmt_rest$26]];
            var fmt_result=_bdw_;
            break;
           case 66:
           case 98:
            var
             _bcx_=0,
             _bcy_=get_padprec(_bcx_),
             pad$3=check_no_0(symb,_bcy_),
             match$9=parse(str_ind,end_ind),
             fmt_rest$8=match$9[1],
             _bcz_=0;
            if(get_ign(_bcz_))
             var
              _bcA_=95,
              ignored$3=[7,get_padprec_opt(_bcA_)],
              _bcB_=[0,[23,ignored$3,fmt_rest$8]];
            else
             var
              match$10=make_padding_fmt_ebb(pad$3,fmt_rest$8),
              fmt_rest$9=match$10[2],
              pad$4=match$10[1],
              _bcB_=[0,[9,pad$4,fmt_rest$9]];
            var fmt_result=_bcB_;
            break;
           case 37:
           case 64:
            var
             match$6=parse(str_ind,end_ind),
             fmt_rest$6=match$6[1],
             fmt_result=[0,[12,symb,fmt_rest$6]];
            break;
           case 76:
           case 108:
           case 110:
            var switch$1=0;
            if(str_ind !== end_ind)
             {var _bcV_=caml_string_get(str,str_ind);
              if(is_int_base(_bcV_)){switch$0 = 1;switch$1 = 1}}
            if(! switch$1)
             {var
               match$14=parse(str_ind,end_ind),
               fmt_rest$13=match$14[1],
               counter=counter_of_char(symb),
               _bcT_=0;
              if(get_ign(_bcT_))
               var
                ignored$5=[11,counter],
                _bcU_=[0,[23,ignored$5,fmt_rest$13]];
              else
               var _bcU_=[0,[21,counter,fmt_rest$13]];
              var fmt_result=_bcU_}
            break;
           case 32:
           case 35:
           case 43:
           case 45:
           case 95:
            var
             fmt_result=
              caml_call3(failwith_message(_cM_),str,pct_ind,symb);
            break;
           case 88:
           case 100:
           case 105:
           case 111:
           case 117:
           case 120:
            var
             _bc3_=0,
             _bc4_=get_space(_bc3_),
             _bc5_=0,
             _bc6_=get_hash(_bc5_),
             _bc7_=0,
             _bc8_=get_plus(_bc7_),
             iconv$2=compute_int_conv(pct_ind,str_ind,_bc8_,_bc6_,_bc4_,symb),
             match$18=parse(str_ind,end_ind),
             fmt_rest$17=match$18[1],
             _bc9_=0;
            if(get_ign(_bc9_))
             var
              _bc__=95,
              ignored$8=[2,iconv$2,get_pad_opt(_bc__)],
              _bc$_=[0,[23,ignored$8,fmt_rest$17]];
            else
             var
              _bda_=0,
              _bdb_=get_prec(_bda_),
              _bdc_=0,
              _bdd_=get_int_pad(_bdc_),
              match$19=make_padprec_fmt_ebb(_bdd_,_bdb_,fmt_rest$17),
              fmt_rest$18=match$19[3],
              prec$4=match$19[2],
              pad$8=match$19[1],
              _bc$_=[0,[4,iconv$2,pad$8,prec$4,fmt_rest$18]];
            var fmt_result=_bc$_;
            break;
           case 69:
           case 70:
           case 71:
           case 72:
           case 101:
           case 102:
           case 103:
           case 104:
            var
             _bcE_=0,
             _bcF_=get_space(_bcE_),
             _bcG_=0,
             _bcH_=get_hash(_bcG_),
             _bcI_=0,
             _bcJ_=get_plus(_bcI_),
             fconv=compute_float_conv(pct_ind,str_ind,_bcJ_,_bcH_,_bcF_,symb),
             match$12=parse(str_ind,end_ind),
             fmt_rest$11=match$12[1],
             _bcK_=0;
            if(get_ign(_bcK_))
             var
              _bcL_=0,
              _bcM_=get_prec_opt(_bcL_),
              _bcN_=95,
              ignored$4=[6,get_pad_opt(_bcN_),_bcM_],
              _bcO_=[0,[23,ignored$4,fmt_rest$11]];
            else
             var
              _bcP_=0,
              _bcQ_=get_prec(_bcP_),
              _bcR_=0,
              _bcS_=get_pad(_bcR_),
              match$13=make_padprec_fmt_ebb(_bcS_,_bcQ_,fmt_rest$11),
              fmt_rest$12=match$13[3],
              prec$3=match$13[2],
              pad$5=match$13[1],
              _bcO_=[0,[8,fconv,pad$5,prec$3,fmt_rest$12]];
            var fmt_result=_bcO_;
            break;
           default:switch$0 = 1}
        if(switch$0)
         {var switch$2=0;
          if(108 <= symb)
           if(111 <= symb)
            switch$2 = 1;
           else
            {var switch$3=0;
             switch(symb - 108 | 0)
              {case 0:
                var
                 _bbG_=caml_string_get(str,str_ind),
                 _bbH_=0,
                 _bbI_=get_space(_bbH_),
                 _bbJ_=0,
                 _bbK_=get_hash(_bbJ_),
                 _bbL_=0,
                 _bbM_=get_plus(_bbL_),
                 _bbN_=str_ind + 1 | 0,
                 iconv=compute_int_conv(pct_ind,_bbN_,_bbM_,_bbK_,_bbI_,_bbG_),
                 _bbO_=str_ind + 1 | 0,
                 match=parse(_bbO_,end_ind),
                 fmt_rest=match[1],
                 _bbP_=0;
                if(get_ign(_bbP_))
                 var
                  _bbQ_=95,
                  ignored=[3,iconv,get_pad_opt(_bbQ_)],
                  _bbR_=[0,[23,ignored,fmt_rest]];
                else
                 var
                  _bbT_=0,
                  _bbU_=get_prec(_bbT_),
                  _bbV_=0,
                  _bbW_=get_int_pad(_bbV_),
                  match$0=make_padprec_fmt_ebb(_bbW_,_bbU_,fmt_rest),
                  fmt_rest$0=match$0[3],
                  prec$0=match$0[2],
                  pad$0=match$0[1],
                  _bbR_=[0,[5,iconv,pad$0,prec$0,fmt_rest$0]];
                var _bbS_=_bbR_;
                break;
               case 1:switch$2 = 1;switch$3 = 1;break;
               default:
                var
                 _bbX_=caml_string_get(str,str_ind),
                 _bbY_=0,
                 _bbZ_=get_space(_bbY_),
                 _bb0_=0,
                 _bb1_=get_hash(_bb0_),
                 _bb2_=0,
                 _bb3_=get_plus(_bb2_),
                 _bb4_=str_ind + 1 | 0,
                 iconv$0=
                  compute_int_conv(pct_ind,_bb4_,_bb3_,_bb1_,_bbZ_,_bbX_),
                 _bb5_=str_ind + 1 | 0,
                 match$1=parse(_bb5_,end_ind),
                 fmt_rest$1=match$1[1],
                 _bb6_=0;
                if(get_ign(_bb6_))
                 var
                  _bb7_=95,
                  ignored$0=[4,iconv$0,get_pad_opt(_bb7_)],
                  _bb8_=[0,[23,ignored$0,fmt_rest$1]];
                else
                 var
                  _bb9_=0,
                  _bb__=get_prec(_bb9_),
                  _bb$_=0,
                  _bca_=get_int_pad(_bb$_),
                  match$2=make_padprec_fmt_ebb(_bca_,_bb__,fmt_rest$1),
                  fmt_rest$2=match$2[3],
                  prec$1=match$2[2],
                  pad$1=match$2[1],
                  _bb8_=[0,[6,iconv$0,pad$1,prec$1,fmt_rest$2]];
                var _bbS_=_bb8_}
             if(! switch$3)var fmt_result=_bbS_}
          else
           if(76 === symb)
            {var
              _bcb_=caml_string_get(str,str_ind),
              _bcc_=0,
              _bcd_=get_space(_bcc_),
              _bce_=0,
              _bcf_=get_hash(_bce_),
              _bcg_=0,
              _bch_=get_plus(_bcg_),
              _bci_=str_ind + 1 | 0,
              iconv$1=compute_int_conv(pct_ind,_bci_,_bch_,_bcf_,_bcd_,_bcb_),
              _bcj_=str_ind + 1 | 0,
              match$3=parse(_bcj_,end_ind),
              fmt_rest$3=match$3[1],
              _bck_=0;
             if(get_ign(_bck_))
              var
               _bcl_=95,
               ignored$1=[5,iconv$1,get_pad_opt(_bcl_)],
               _bcm_=[0,[23,ignored$1,fmt_rest$3]];
             else
              var
               _bcn_=0,
               _bco_=get_prec(_bcn_),
               _bcp_=0,
               _bcq_=get_int_pad(_bcp_),
               match$4=make_padprec_fmt_ebb(_bcq_,_bco_,fmt_rest$3),
               fmt_rest$4=match$4[3],
               prec$2=match$4[2],
               pad$2=match$4[1],
               _bcm_=[0,[7,iconv$1,pad$2,prec$2,fmt_rest$4]];
             var fmt_result=_bcm_}
           else
            switch$2 = 1;
          if(switch$2)
           var
            _bbt_=str_ind - 1 | 0,
            fmt_result=caml_call3(failwith_message(_cC_),str,_bbt_,symb)}
        if(1 - legacy_behavior$0)
         {var _bbu_=1 - plus_used[1],plus$0=_bbu_?plus:_bbu_;
          if(plus$0)incompatible_flag(pct_ind,str_ind,symb,_cD_);
          var _bbv_=1 - hash_used[1],hash$0=_bbv_?hash:_bbv_;
          if(hash$0)incompatible_flag(pct_ind,str_ind,symb,_cE_);
          var _bbw_=1 - space_used[1],space$0=_bbw_?space:_bbw_;
          if(space$0)incompatible_flag(pct_ind,str_ind,symb,_cF_);
          var _bbx_=1 - pad_used[1];
          if(_bbx_)
           var _bby_=[0,pad],_bbz_=caml_notequal(_bby_,_cG_);
          else
           var _bbz_=_bbx_;
          if(_bbz_)incompatible_flag(pct_ind,str_ind,symb,_cH_);
          var _bbA_=1 - prec_used[1];
          if(_bbA_)
           var _bbB_=[0,prec],_bbC_=caml_notequal(_bbB_,_cI_);
          else
           var _bbC_=_bbA_;
          if(_bbC_)
           {var _bbD_=ign?95:symb;
            incompatible_flag(pct_ind,str_ind,_bbD_,_cJ_)}
          var plus$1=ign?plus:ign;
          if(plus$1)
           {var _bbE_=95;incompatible_flag(pct_ind,str_ind,_bbE_,_cK_)}}
        var _bbF_=1 - ign_used[1],ign$0=_bbF_?ign:_bbF_;
        if(ign$0)
         {var switch$4=0;
          if(38 <= symb)
           {if(44 !== symb && 64 !== symb)switch$4 = 1}
          else
           if(33 !== symb && ! (37 <= symb))switch$4 = 1;
          var switch$5=0;
          if(switch$4 || ! legacy_behavior$0)switch$5 = 1;
          if(switch$5)incompatible_flag(pct_ind,str_ind,symb,_cL_)}
        return fmt_result}
      function parse_format(pct_ind,end_ind)
       {return parse_ign(pct_ind,pct_ind + 1 | 0,end_ind)}
      function parse_ign(pct_ind,str_ind,end_ind)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var match=caml_string_get(str,str_ind);
        return 95 === match
                ?parse_flags(pct_ind,str_ind + 1 | 0,end_ind,1)
                :parse_flags(pct_ind,str_ind,end_ind,0)}
      function parse_flags(pct_ind,str_ind,end_ind,ign)
       {var zero=[0,0],minus=[0,0],plus=[0,0],space=[0,0],hash=[0,0];
        function set_flag(str_ind,flag)
         {var _bbq_=flag[1],_bbr_=_bbq_?1 - legacy_behavior$0:_bbq_;
          if(_bbr_)
           {var _bbs_=caml_string_get(str,str_ind);
            caml_call3(failwith_message(_ck_),str,str_ind,_bbs_)}
          flag[1] = 1;
          return 0}
        function read_flags(str_ind)
         {var str_ind$0=str_ind;
          for(;;)
           {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
            var match=caml_string_get(str,str_ind$0),switcher=match - 32 | 0;
            if(! (16 < switcher >>> 0))
             switch(switcher)
              {case 0:
                set_flag(str_ind$0,space);
                var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
                continue;
               case 3:
                set_flag(str_ind$0,hash);
                var str_ind$2=str_ind$0 + 1 | 0,str_ind$0=str_ind$2;
                continue;
               case 11:
                set_flag(str_ind$0,plus);
                var str_ind$3=str_ind$0 + 1 | 0,str_ind$0=str_ind$3;
                continue;
               case 13:
                set_flag(str_ind$0,minus);
                var str_ind$4=str_ind$0 + 1 | 0,str_ind$0=str_ind$4;
                continue;
               case 16:
                set_flag(str_ind$0,zero);
                var str_ind$5=str_ind$0 + 1 | 0,str_ind$0=str_ind$5;
                continue
               }
            return parse_padding
                    (pct_ind,
                     str_ind$0,
                     end_ind,
                     zero[1],
                     minus[1],
                     plus[1],
                     hash[1],
                     space[1],
                     ign)}}
        return read_flags(str_ind)}
      function parse(beg_ind,end_ind)
       {return parse_literal(beg_ind,beg_ind,end_ind)}
      function parse_literal(lit_start,str_ind,end_ind)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)return add_literal(lit_start,str_ind$0,0);
          var match=caml_string_get(str,str_ind$0);
          if(37 === match)
           {var match$0=parse_format(str_ind$0,end_ind),fmt_rest=match$0[1];
            return add_literal(lit_start,str_ind$0,fmt_rest)}
          if(64 === match)
           {var
             _bbp_=str_ind$0 + 1 | 0,
             match$1=parse_after_at(_bbp_,end_ind),
             fmt_rest$0=match$1[1];
            return add_literal(lit_start,str_ind$0,fmt_rest$0)}
          var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
          continue}}
      return parse(0,caml_ml_string_length(str))}
    function format_of_string_fmtty(str,fmtty)
     {var _bbl_=0,match=fmt_ebb_of_string(_bbl_,str),fmt=match[1];
      try
       {var _bbn_=[0,type_format(fmt,fmtty),str];return _bbn_}
      catch(_bbo_)
       {_bbo_ = caml_wrap_exception(_bbo_);
        if(_bbo_ === Type_mismatch)
         {var _bbm_=string_of_fmtty(fmtty);
          return caml_call2(failwith_message(_c7_),str,_bbm_)}
        throw _bbo_}}
    function kfprintf(k,o,param)
     {var fmt=param[1],_bbk_=0;
      return make_printf
              (function(acc){output_acc(o,acc);return caml_call1(k,o)},
               _bbk_,
               fmt)}
    function fprintf(oc,fmt)
     {return kfprintf(function(_bbj_){return 0},oc,fmt)}
    function eprintf(fmt){return fprintf(stderr,fmt)}
    function kprintf(k,param)
     {var fmt=param[1];
      function k$0(acc)
       {var _bbi_=64,buf=create$1(_bbi_);
        strput_acc(buf,acc);
        return caml_call1(k,contents(buf))}
      return make_printf(k$0,0,fmt)}
    function sprintf(fmt){return kprintf(function(s){return s},fmt)}
    var _c8_=0,printers=make(_c8_);
    function field(x,i)
     {var f=x[1 + i];
      return is_block(f)
              ?caml_obj_tag(f) === 252
                ?caml_call1(sprintf(_c9_),f)
                :caml_obj_tag(f) === 253?to_string$0(f):_c__
              :caml_call1(sprintf(_c$_),f)}
    function other_fields(x,i)
     {if(x.length - 1 <= i)return _da_;
      var _bbf_=i + 1 | 0,_bbg_=other_fields(x,_bbf_),_bbh_=field(x,i);
      return caml_call2(sprintf(_db_),_bbh_,_bbg_)}
    function fields(x)
     {var match=x.length - 1;
      if(2 < match >>> 0)
       {var _ba$_=2,_bba_=other_fields(x,_ba$_),_bbb_=1,_bbc_=field(x,_bbb_);
        return caml_call2(sprintf(_dc_),_bbc_,_bba_)}
      switch(match)
       {case 0:return _dd_;
        case 1:return _de_;
        default:
         var _bbd_=1,_bbe_=field(x,_bbd_);
         return caml_call1(sprintf(_df_),_bbe_)}}
    function use_printers(x)
     {function conv(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1];
            try
             {var switch$0=0,val=caml_call1(hd,x);switch$0 = 1}
            catch(_ba__){}
            if(switch$0 && val){var s=val[1];return [0,s]}
            var param$0=tl;
            continue}
          return 0}}
      return conv(get(printers))}
    function to_string_default(x)
     {if(x === Out_of_memory)return _dg_;
      if(x === Stack_overflow)return _dh_;
      if(x[1] === Match_failure)
       {var match=x[2],char$0=match[3],line=match[2],file=match[1];
        return caml_call5
                (sprintf(locfmt),file,line,char$0,char$0 + 5 | 0,_di_)}
      if(x[1] === Assert_failure)
       {var
         match$0=x[2],
         char$1=match$0[3],
         line$0=match$0[2],
         file$0=match$0[1];
        return caml_call5
                (sprintf(locfmt),file$0,line$0,char$1,char$1 + 6 | 0,_dj_)}
      if(x[1] === Undefined_recursive_module)
       {var
         match$1=x[2],
         char$2=match$1[3],
         line$1=match$1[2],
         file$1=match$1[1];
        return caml_call5
                (sprintf(locfmt),file$1,line$1,char$2,char$2 + 6 | 0,_dk_)}
      if(0 === caml_obj_tag(x))
       {var _ba6_=0,_ba7_=0,_ba8_=x[1 + _ba7_],constructor=_ba8_[1 + _ba6_];
        return cat(constructor,fields(x))}
      var _ba9_=0;
      return x[1 + _ba9_]}
    function to_string$5(e)
     {var match=use_printers(e);
      if(match){var s=match[1];return s}
      return to_string_default(e)}
    function convert_raw_backtrace(bt)
     {var _ba5_=[0,caml_convert_raw_backtrace(bt)];return _ba5_}
    function format_backtrace_slot(pos,slot)
     {function info(is_raise)
       {return is_raise?0 === pos?_dl_:_dm_:0 === pos?_dn_:_do_}
      if(0 === slot[0])
       {var
         _baV_=slot[5],
         _baW_=slot[4],
         _baX_=slot[3],
         _baY_=slot[6]?_dp_:_dr_,
         _baZ_=slot[2],
         _ba0_=slot[7],
         _ba1_=slot[1],
         _ba2_=info(_ba1_);
        return [0,
                caml_call7
                 (sprintf(_dq_),_ba2_,_ba0_,_baZ_,_baY_,_baX_,_baW_,_baV_)]}
      if(slot[1])return 0;
      var _ba3_=0,_ba4_=info(_ba3_);
      return [0,caml_call1(sprintf(_ds_),_ba4_)]}
    function print_exception_backtrace(outchan,backtrace)
     {if(backtrace)
       {var a=backtrace[1],_baS_=a.length - 1 - 1 | 0,_baR_=0;
        if(! (_baS_ < 0))
         {var i=_baR_;
          for(;;)
           {var
             _baT_=caml_check_bound(a,i)[1 + i],
             match=format_backtrace_slot(i,_baT_);
            if(match){var str=match[1];caml_call1(fprintf(outchan,_dt_),str)}
            var _baU_=i + 1 | 0;
            if(_baS_ !== i){var i=_baU_;continue}
            break}}
        return 0}
      return fprintf(outchan,_du_)}
    function print_raw_backtrace(outchan,raw_backtrace)
     {return print_exception_backtrace
              (outchan,convert_raw_backtrace(raw_backtrace))}
    function print_backtrace(outchan)
     {return print_raw_backtrace(outchan,caml_get_exception_raw_backtrace(0))}
    function register_printer(fn)
     {for(;;)
       {var
         old_printers=get(printers),
         new_printers=[0,fn,old_printers],
         success=compare_and_set(printers,old_printers,new_printers),
         _baQ_=1 - success;
        if(_baQ_)continue;
        return _baQ_}}
    var errors=_dv_.slice();
    function default_uncaught_exception_han(exn,raw_backtrace)
     {var _baN_=to_string$5(exn);
      caml_call1(eprintf(_dw_),_baN_);
      print_raw_backtrace(stderr,raw_backtrace);
      var status=caml_ml_debug_info_status(0);
      if(status < 0)
       {var _baO_=abs(status),_baP_=caml_check_bound(errors,_baO_)[1 + _baO_];
        prerr_endline(_baP_)}
      return flush(stderr)}
    var empty_backtrace=[0];
    function try_get_raw_backtrace(param)
     {var _baM_=caml_get_exception_raw_backtrace(0);return _baM_}
    function handle_uncaught_exception(exn,debugger_in_use)
     {try
       {if(debugger_in_use)
         var raw_backtrace=empty_backtrace;
        else
         var _baJ_=0,raw_backtrace=try_get_raw_backtrace(_baJ_);
        try {var _baI_=0;do_at_exit(_baI_)}catch(_baL_){}
        try
         {var
           _baH_=default_uncaught_exception_han(exn,raw_backtrace),
           _baG_=_baH_}
        catch(exn$0)
         {exn$0 = caml_wrap_exception(exn$0);
          var
           _baD_=0,
           raw_backtrace$0=try_get_raw_backtrace(_baD_),
           _baE_=to_string$5(exn);
          caml_call1(eprintf(_dy_),_baE_);
          print_raw_backtrace(stderr,raw_backtrace);
          var _baF_=to_string$5(exn$0);
          caml_call1(eprintf(_dz_),_baF_);
          print_raw_backtrace(stderr,raw_backtrace$0);
          var _baG_=flush(stderr)}
        return _baG_}
      catch(_baK_)
       {_baK_ = caml_wrap_exception(_baK_);
        if(_baK_ === Out_of_memory)return prerr_endline(_dx_);
        throw _baK_}}
    function handle_uncaught_exception$0(exn,debugger_in_use)
     {try
       {var _baB_=handle_uncaught_exception(exn,debugger_in_use);return _baB_}
      catch(_baC_){return 0}}
    caml_register_named_value
     (caml_string_of_jsbytes("Printexc.handle_uncaught_exception"),
      handle_uncaught_exception$0);
    var Finally_raised=[248,_dA_,caml_fresh_oo_id(0)];
    function _dB_(param)
     {if(param[1] === Finally_raised)
       {var exn=param[2],_baA_=to_string$5(exn);return [0,cat(_dC_,_baA_)]}
      return 0}
    register_printer(_dB_);
    function _dD_(_baz_,_bay_){return caml_final_register(_baz_,_bay_)}
    function string(str)
     {var _bax_=caml_ml_string_length(str);
      return caml_md5_string(str,0,_bax_)}
    function new_state(param)
     {var _baw_=0;return [0,caml_make_vect(55,0),_baw_]}
    function full_init(s,seed)
     {function combine(accu,x)
       {var _bav_=to_string$1(x);return string(cat(accu,_bav_))}
      function extract(d)
       {var
         _bas_=caml_string_get(d,3) << 24,
         _bat_=caml_string_get(d,2) << 16,
         _bau_=caml_string_get(d,1) << 8;
        return ((caml_string_get(d,0) + _bau_ | 0) + _bat_ | 0) + _bas_ | 0}
      var seed$0=0 === seed.length - 1?[0,0]:seed,l=seed$0.length - 1,i$0=0;
      for(;;)
       {var _baq_=s[1];
        caml_check_bound(_baq_,i$0)[1 + i$0] = i$0;
        var _bar_=i$0 + 1 | 0;
        if(54 !== i$0){var i$0=_bar_;continue}
        var accu=[0,_dE_],_baf_=0,_bag_=55,_bah_=54 + max$0(_bag_,l) | 0;
        if(! (_bah_ < 0))
         {var i=_baf_;
          for(;;)
           {var
             j=i % 55 | 0,
             k=caml_mod(i,l),
             _bai_=caml_check_bound(seed$0,k)[1 + k],
             _baj_=accu[1];
            accu[1] = combine(_baj_,_bai_);
            var
             _bak_=accu[1],
             _bal_=extract(_bak_),
             _bam_=s[1],
             _ban_=(caml_check_bound(_bam_,j)[1 + j] ^ _bal_) & 1073741823,
             _bao_=s[1];
            caml_check_bound(_bao_,j)[1 + j] = _ban_;
            var _bap_=i + 1 | 0;
            if(_bah_ !== i){var i=_bap_;continue}
            break}}
        s[2] = 0;
        return 0}}
    function make$2(seed)
     {var _bae_=0,result=new_state(_bae_);
      full_init(result,seed);
      return result}
    function make_self_init(param){return make$2(caml_sys_random_seed(0))}
    function bits(s)
     {s[2] = (s[2] + 1 | 0) % 55 | 0;
      var
       _a$9_=s[2],
       _a$__=s[1],
       curval=caml_check_bound(_a$__,_a$9_)[1 + _a$9_],
       _baa_=(s[2] + 24 | 0) % 55 | 0,
       _a$$_=curval ^ (curval >>> 25 | 0) & 31,
       _bab_=s[1],
       newval=caml_check_bound(_bab_,_baa_)[1 + _baa_] + _a$$_ | 0,
       newval30=newval & 1073741823,
       _bac_=s[2],
       _bad_=s[1];
      caml_check_bound(_bad_,_bac_)[1 + _bac_] = newval30;
      return newval30}
    function ongoing_traversal(h)
     {var _a$7_=h.length - 1 < 4?1:0,_a$8_=_a$7_ || (h[4] < 0?1:0);
      return _a$8_}
    function flip_ongoing_traversal(h){h[4] = - h[4] | 0;return 0}
    try
     {var _wL_=caml_sys_getenv(_wK_),params=_wL_}
    catch(_a$5_)
     {_a$5_ = caml_wrap_exception(_a$5_);
      if(_a$5_ !== Not_found)throw _a$5_;
      try
       {var _wJ_=caml_sys_getenv(_wI_),_dG_=_wJ_}
      catch(_a$6_)
       {_a$6_ = caml_wrap_exception(_a$6_);
        if(_a$6_ !== Not_found)throw _a$6_;
        var _dG_=_dF_}
      var params=_dG_}
    var
     _dH_=82,
     randomized_default=contains(params,_dH_),
     prng=[246,function(_a$4_){return make_self_init(0)}];
    function power_2_above(x,n)
     {var x$0=x;
      for(;;)
       {if(n <= x$0)return x$0;
        if(max_array_length < (x$0 * 2 | 0))return x$0;
        var x$1=x$0 * 2 | 0,x$0=x$1;
        continue}}
    function create$2(opt,initial_size)
     {if(opt)var sth=opt[1],random=sth;else var random=randomized_default;
      var _a$1_=16,s=power_2_above(_a$1_,initial_size);
      if(random)
       var
        _a$2_=caml_obj_tag(prng),
        _a$3_=250 === _a$2_?prng[1]:246 === _a$2_?force_lazy_block(prng):prng,
        seed=bits(_a$3_);
      else
       var seed=0;
      return [0,0,caml_make_vect(s,0),seed,s]}
    function clear$2(h)
     {var _a$0_=0 < h[1]?1:0;
      return _a$0_?(h[1] = 0,fill(h[2],0,h[2].length - 1,0)):_a$0_}
    function reset$0(h)
     {var len=h[2].length - 1;
      if(4 <= h.length - 1)
       {var _a$X_=h[4];
        if(len !== abs(_a$X_))
         {h[1] = 0;
          var _a$Y_=h[4],_a$Z_=abs(_a$Y_);
          h[2] = caml_make_vect(_a$Z_,0);
          return 0}}
      return clear$2(h)}
    function copy_bucketlist(param)
     {if(param)
       {var
         key=param[1],
         data=param[2],
         next=param[3],
         loop=
          function(prec,param)
           {var prec$0=prec,param$0=param;
            for(;;)
             {if(param$0)
               {var
                 key=param$0[1],
                 data=param$0[2],
                 next=param$0[3],
                 r=[0,key,data,next];
                if(prec$0){prec$0[3] = r;var prec$0=r,param$0=next;continue}
                throw [0,Assert_failure,_dI_]}
              return 0}},
         r=[0,key,data,next];
        loop(r,next);
        return r}
      return 0}
    function copy$0(init)
     {var
       _a$T_=init[4],
       _a$U_=init[3],
       _a$V_=init[2],
       _a$W_=map$2(copy_bucketlist,_a$V_);
      return [0,init[1],_a$W_,_a$U_,_a$T_]}
    function length$1(h){return h[1]}
    function insert_all_buckets(indexfun,inplace,odata,ndata)
     {var nsize=ndata.length - 1,ndata_tail=caml_make_vect(nsize,0);
      function insert_bucket(cell)
       {var cell$0=cell;
        for(;;)
         {if(cell$0)
           {var
             key=cell$0[1],
             data=cell$0[2],
             next=cell$0[3],
             cell$1=inplace?cell$0:[0,key,data,0],
             nidx=caml_call1(indexfun,key),
             match=caml_check_bound(ndata_tail,nidx)[1 + nidx];
            if(match)
             match[3] = cell$1;
            else
             caml_check_bound(ndata,nidx)[1 + nidx] = cell$1;
            caml_check_bound(ndata_tail,nidx)[1 + nidx] = cell$1;
            var cell$0=next;
            continue}
          return 0}}
      var _a$M_=odata.length - 1 - 1 | 0,_a$L_=0;
      if(! (_a$M_ < 0))
       {var i$0=_a$L_;
        for(;;)
         {var _a$R_=caml_check_bound(odata,i$0)[1 + i$0];
          insert_bucket(_a$R_);
          var _a$S_=i$0 + 1 | 0;
          if(_a$M_ !== i$0){var i$0=_a$S_;continue}
          break}}
      if(inplace)
       {var _a$O_=nsize - 1 | 0,_a$N_=0;
        if(! (_a$O_ < 0))
         {var i=_a$N_;
          for(;;)
           {var match=caml_check_bound(ndata_tail,i)[1 + i];
            if(match)match[3] = 0;
            var _a$Q_=i + 1 | 0;
            if(_a$O_ !== i){var i=_a$Q_;continue}
            break}}
        var _a$P_=0}
      else
       var _a$P_=inplace;
      return _a$P_}
    function resize$0(indexfun,h)
     {var
       odata=h[2],
       osize=odata.length - 1,
       nsize=osize * 2 | 0,
       _a$K_=nsize < max_array_length?1:0;
      if(_a$K_)
       {var ndata=caml_make_vect(nsize,0),inplace=1 - ongoing_traversal(h);
        h[2] = ndata;
        return insert_all_buckets(caml_call1(indexfun,h),inplace,odata,ndata)}
      return _a$K_}
    function iter$4(f,h)
     {function do_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var key=param$0[1],data=param$0[2],next=param$0[3];
            caml_call2(f,key,data);
            var param$0=next;
            continue}
          return 0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],_a$F_=d.length - 1 - 1 | 0,_a$E_=0;
        if(! (_a$F_ < 0))
         {var i=_a$E_;
          for(;;)
           {var _a$I_=caml_check_bound(d,i)[1 + i];
            do_bucket(_a$I_);
            var _a$J_=i + 1 | 0;
            if(_a$F_ !== i){var i=_a$J_;continue}
            break}}
        var _a$G_=1 - old_trav,_a$H_=_a$G_?flip_ongoing_traversal(h):_a$G_;
        return _a$H_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function filter_map_inplace_bucket(f,h,i,prec,slot)
     {var prec$0=prec,slot$0=slot;
      for(;;)
       {if(slot$0)
         {var
           key=slot$0[1],
           data=slot$0[2],
           next=slot$0[3],
           match=caml_call2(f,key,data);
          if(match)
           {var data$0=match[1];
            if(prec$0)
             prec$0[3] = slot$0;
            else
             {var _a$B_=h[2];caml_check_bound(_a$B_,i)[1 + i] = slot$0}
            slot$0[2] = data$0;
            var prec$0=slot$0,slot$0=next;
            continue}
          h[1] = h[1] - 1 | 0;
          var slot$0=next;
          continue}
        if(prec$0){prec$0[3] = 0;return 0}
        var _a$C_=0,_a$D_=h[2];
        caml_check_bound(_a$D_,i)[1 + i] = _a$C_;
        return 0}}
    function filter_map_inplace(f,h)
     {var d=h[2],old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var _a$u_=d.length - 1 - 1 | 0,_a$t_=0;
        if(! (_a$u_ < 0))
         {var i=_a$t_;
          for(;;)
           {var _a$x_=h[2],_a$y_=caml_check_bound(_a$x_,i)[1 + i],_a$z_=0;
            filter_map_inplace_bucket(f,h,i,_a$z_,_a$y_);
            var _a$A_=i + 1 | 0;
            if(_a$u_ !== i){var i=_a$A_;continue}
            break}}
        var _a$v_=1 - old_trav,_a$w_=_a$v_?flip_ongoing_traversal(h):_a$v_;
        return _a$w_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function fold$0(f,h,init)
     {function do_bucket(b,accu)
       {var b$0=b,accu$0=accu;
        for(;;)
         {if(b$0)
           {var
             key=b$0[1],
             data=b$0[2],
             next=b$0[3],
             accu$1=caml_call3(f,key,data,accu$0),
             b$0=next,
             accu$0=accu$1;
            continue}
          return accu$0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],accu=[0,init],_a$o_=d.length - 1 - 1 | 0,_a$n_=0;
        if(! (_a$o_ < 0))
         {var i=_a$n_;
          for(;;)
           {var _a$q_=accu[1],_a$r_=caml_check_bound(d,i)[1 + i];
            accu[1] = do_bucket(_a$r_,_a$q_);
            var _a$s_=i + 1 | 0;
            if(_a$o_ !== i){var i=_a$s_;continue}
            break}}
        if(1 - old_trav)flip_ongoing_traversal(h);
        var _a$p_=accu[1];
        return _a$p_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function bucket_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[3],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function stats(h)
     {var _a$e_=h[2],_a$f_=0;
      function _a$g_(m,b){var _a$m_=0;return max$0(m,bucket_length(_a$m_,b))}
      var
       mbl=fold_left$0(_a$g_,_a$f_,_a$e_),
       _a$h_=mbl + 1 | 0,
       histo=caml_make_vect(_a$h_,0),
       _a$i_=h[2];
      function _a$j_(b)
       {var
         _a$k_=0,
         l=bucket_length(_a$k_,b),
         _a$l_=caml_check_bound(histo,l)[1 + l] + 1 | 0;
        caml_check_bound(histo,l)[1 + l] = _a$l_;
        return 0}
      iter$2(_a$j_,_a$i_);
      return [0,h[1],h[2].length - 1,mbl,histo]}
    function to_seq(tbl)
     {var tbl_data=tbl[2];
      function aux(i,buck,param)
       {var i$0=i,buck$0=buck;
        for(;;)
         {if(buck$0)
           {var key=buck$0[1],data=buck$0[2],next=buck$0[3];
            return [0,
                    [0,key,data],
                    function(_a$d_){return aux(i$0,next,_a$d_)}]}
          if(i$0 === tbl_data.length - 1)return 0;
          var
           buck$1=caml_check_bound(tbl_data,i$0)[1 + i$0],
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           buck$0=buck$1;
          continue}}
      var _a$a_=0,_a$b_=0;
      return function(_a$c_){return aux(_a$b_,_a$a_,_a$c_)}}
    function to_seq_keys(m)
     {var _a_8_=to_seq(m);
      function _a_9_(_a_$_){return _a_$_[1]}
      return function(_a___){return map(_a_9_,_a_8_,_a___)}}
    function to_seq_values(m)
     {var _a_4_=to_seq(m);
      function _a_5_(_a_7_){return _a_7_[2]}
      return function(_a_6_){return map(_a_5_,_a_4_,_a_6_)}}
    function MakeSeeded(H)
     {function key_index(h,key)
       {var _a_1_=h[2].length - 1 - 1 | 0,_a_2_=h[3],_a_3_=H[2];
        return caml_call2(_a_3_,_a_2_,key) & _a_1_}
      function add(h,key,data)
       {var
         i=key_index(h,key),
         _a_Y_=h[2],
         bucket=[0,key,data,caml_check_bound(_a_Y_,i)[1 + i]],
         _a_Z_=h[2];
        caml_check_bound(_a_Z_,i)[1 + i] = bucket;
        h[1] = h[1] + 1 | 0;
        var _a_0_=h[2].length - 1 << 1 < h[1]?1:0;
        return _a_0_?resize$0(key_index,h):_a_0_}
      function remove_bucket(h,i,key,prec,c)
       {var prec$0=prec,c$0=c;
        for(;;)
         {if(c$0)
           {var k=c$0[1],next=c$0[3],_a_W_=H[1];
            if(caml_call2(_a_W_,k,key))
             {h[1] = h[1] - 1 | 0;
              if(prec$0){prec$0[3] = next;return 0}
              var _a_X_=h[2];
              caml_check_bound(_a_X_,i)[1 + i] = next;
              return 0}
            var prec$0=c$0,c$0=next;
            continue}
          return 0}}
      function remove(h,key)
       {var i=key_index(h,key),_a_V_=h[2];
        return remove_bucket(h,i,key,0,caml_check_bound(_a_V_,i)[1 + i])}
      function find_rec(key,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var k=param$0[1],data=param$0[2],next=param$0[3],_a_U_=H[1];
            if(caml_call2(_a_U_,key,k))return data;
            var param$0=next;
            continue}
          throw Not_found}}
      function find(h,key)
       {var
         _a_P_=key_index(h,key),
         _a_Q_=h[2],
         match=caml_check_bound(_a_Q_,_a_P_)[1 + _a_P_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3],_a_R_=H[1];
          if(caml_call2(_a_R_,key,k1))return d1;
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3],_a_S_=H[1];
            if(caml_call2(_a_S_,key,k2))return d2;
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3],_a_T_=H[1];
              return caml_call2(_a_T_,key,k3)?d3:find_rec(key,next3)}
            throw Not_found}
          throw Not_found}
        throw Not_found}
      function find_rec_opt(key,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var k=param$0[1],data=param$0[2],next=param$0[3],_a_O_=H[1];
            if(caml_call2(_a_O_,key,k))return [0,data];
            var param$0=next;
            continue}
          return 0}}
      function find_opt(h,key)
       {var
         _a_J_=key_index(h,key),
         _a_K_=h[2],
         match=caml_check_bound(_a_K_,_a_J_)[1 + _a_J_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3],_a_L_=H[1];
          if(caml_call2(_a_L_,key,k1))return [0,d1];
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3],_a_M_=H[1];
            if(caml_call2(_a_M_,key,k2))return [0,d2];
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3],_a_N_=H[1];
              return caml_call2(_a_N_,key,k3)?[0,d3]:find_rec_opt(key,next3)}
            return 0}
          return 0}
        return 0}
      function find_all(h,key)
       {function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var k=param$0[1],d=param$0[2],next=param$0[3],_a_I_=H[1];
              if(caml_call2(_a_I_,k,key))return [0,d,find_in_bucket(next)];
              var param$0=next;
              continue}
            return 0}}
        var _a_G_=key_index(h,key),_a_H_=h[2];
        return find_in_bucket(caml_check_bound(_a_H_,_a_G_)[1 + _a_G_])}
      function replace_bucket(key,data,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var k=param$0[1],next=param$0[3],_a_F_=H[1];
            if(caml_call2(_a_F_,k,key))
             {param$0[1] = key;param$0[2] = data;return 0}
            var param$0=next;
            continue}
          return 1}}
      function replace(h,key,data)
       {var
         i=key_index(h,key),
         _a_z_=h[2],
         l=caml_check_bound(_a_z_,i)[1 + i],
         _a_A_=replace_bucket(key,data,l);
        if(_a_A_)
         {var _a_B_=[0,key,data,l],_a_C_=h[2];
          caml_check_bound(_a_C_,i)[1 + i] = _a_B_;
          h[1] = h[1] + 1 | 0;
          var _a_D_=h[2].length - 1 << 1 < h[1]?1:0;
          if(_a_D_)return resize$0(key_index,h);
          var _a_E_=_a_D_}
        else
         var _a_E_=_a_A_;
        return _a_E_}
      function mem(h,key)
       {function mem_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var
               k=param$0[1],
               next=param$0[3],
               _a_x_=H[1],
               _a_y_=caml_call2(_a_x_,k,key);
              if(_a_y_)return _a_y_;
              var param$0=next;
              continue}
            return 0}}
        var _a_v_=key_index(h,key),_a_w_=h[2];
        return mem_in_bucket(caml_check_bound(_a_w_,_a_v_)[1 + _a_v_])}
      function add_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return add(tbl,k,v)},
                 i)}
      function replace_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return replace(tbl,k,v)},
                 i)}
      function of_seq(i)
       {var _a_t_=16,_a_u_=0,tbl=create$2(_a_u_,_a_t_);
        replace_seq(tbl,i);
        return tbl}
      return [0,
              create$2,
              clear$2,
              reset$0,
              copy$0,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$4,
              filter_map_inplace,
              fold$0,
              length$1,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    function Make$1(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       _a_r_=include[1];
      function create(sz){return caml_call2(_a_r_,_dJ_,sz)}
      function of_seq(i)
       {var _a_s_=16,tbl=create(_a_s_);
        caml_call2(replace_seq,tbl,i);
        return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    function hash(x){return caml_hash(10,100,0,x)}
    function key_index(h,key)
     {if(4 <= h.length - 1)
       {var _a_p_=h[2].length - 1 - 1 | 0,_a_q_=h[3];
        return caml_hash(10,100,_a_q_,key) & _a_p_}
      return invalid_arg(_dK_)}
    function add$0(h,key,data)
     {var
       i=key_index(h,key),
       _a_m_=h[2],
       bucket=[0,key,data,caml_check_bound(_a_m_,i)[1 + i]],
       _a_n_=h[2];
      caml_check_bound(_a_n_,i)[1 + i] = bucket;
      h[1] = h[1] + 1 | 0;
      var _a_o_=h[2].length - 1 << 1 < h[1]?1:0;
      return _a_o_?resize$0(key_index,h):_a_o_}
    function find_rec(key,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var k=param$0[1],data=param$0[2],next=param$0[3];
          if(0 === caml_compare(key,k))return data;
          var param$0=next;
          continue}
        throw Not_found}}
    function find(h,key)
     {var
       _a_k_=key_index(h,key),
       _a_l_=h[2],
       match=caml_check_bound(_a_l_,_a_k_)[1 + _a_k_];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return d1;
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return d2;
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            return 0 === caml_compare(key,k3)?d3:find_rec(key,next3)}
          throw Not_found}
        throw Not_found}
      throw Not_found}
    function weak_create(l)
     {var _a_i_=0 <= l?1:0,_a_j_=_a_i_?l <= max_ephe_length?1:0:_a_i_;
      if(1 - _a_j_)invalid_arg(_dL_);
      return caml_weak_create(l)}
    function length$2(x){return x.length - 1 - 2 | 0}
    function raise_if_invalid_offset(e,o,msg)
     {var
       _a_f_=0 <= o?1:0,
       _a_g_=_a_f_?o < length$2(e)?1:0:_a_f_,
       _a_h_=1 - _a_g_;
      return _a_h_?invalid_arg(msg):_a_h_}
    function set(e,o,x)
     {raise_if_invalid_offset(e,o,_dM_);
      if(x){var x$0=x[1];return caml_ephe_set_key(e,o,x$0)}
      return caml_ephe_unset_key(e,o)}
    function get$0(e,o)
     {raise_if_invalid_offset(e,o,_dN_);return caml_weak_get(e,o)}
    function get_copy(e,o)
     {raise_if_invalid_offset(e,o,_dO_);return caml_weak_get_copy(e,o)}
    function check(e,o)
     {raise_if_invalid_offset(e,o,_dP_);return caml_weak_check(e,o)}
    function blit$2(e1,o1,e2,o2,l)
     {if
       (0
        <=
        l
        &&
        0
        <=
        o1
        &&
        !
        ((length$2(e1) - l | 0) < o1)
        &&
        0
        <=
        o2
        &&
        !
        ((length$2(e2) - l | 0) < o2))
       {var _a_d_=0 !== l?1:0,_a_e_=_a_d_?caml_weak_blit(e1,o1,e2,o2,l):_a_d_;
        return _a_e_}
      return invalid_arg(_dQ_)}
    function Make$2(H)
     {var _a8B_=0,emptybucket=weak_create(_a8B_);
      function get_index(t,h){return caml_mod(h & 2147483647,t[1].length - 1)}
      var limit=7;
      function create(sz)
       {var
         sz$0=7 <= sz?sz:7,
         sz$1=max_array_length < sz$0?max_array_length:sz$0,
         _a9$_=0,
         _a_a_=0,
         _a_b_=[0],
         _a_c_=caml_make_vect(sz$1,_a_b_);
        return [0,caml_make_vect(sz$1,emptybucket),_a_c_,limit,_a_a_,_a9$_]}
      function clear(t)
       {var _a96_=t[1].length - 1 - 1 | 0,_a95_=0;
        if(! (_a96_ < 0))
         {var i=_a95_;
          for(;;)
           {var _a97_=t[1];
            caml_check_bound(_a97_,i)[1 + i] = emptybucket;
            var _a98_=[0],_a99_=t[2];
            caml_check_bound(_a99_,i)[1 + i] = _a98_;
            var _a9__=i + 1 | 0;
            if(_a96_ !== i){var i=_a9__;continue}
            break}}
        t[3] = limit;
        t[4] = 0;
        return 0}
      function fold(f,t,init)
       {function fold_bucket(i,b,accu)
         {var i$0=i,accu$0=accu;
          for(;;)
           {if(length$2(b) <= i$0)return accu$0;
            var match=get$0(b,i$0);
            if(match)
             {var
               v=match[1],
               accu$1=caml_call2(f,v,accu$0),
               i$1=i$0 + 1 | 0,
               i$0=i$1,
               accu$0=accu$1;
              continue}
            var i$2=i$0 + 1 | 0,i$0=i$2;
            continue}}
        var _a91_=t[1],_a92_=0;
        return fold_right$0
                (function(_a93_,_a94_){return fold_bucket(_a92_,_a93_,_a94_)},
                 _a91_,
                 init)}
      function iter(f,t)
       {function iter_bucket(i,b)
         {var i$0=i;
          for(;;)
           {if(length$2(b) <= i$0)return 0;
            var match=get$0(b,i$0);
            if(match)
             {var v=match[1];
              caml_call1(f,v);
              var i$1=i$0 + 1 | 0,i$0=i$1;
              continue}
            var i$2=i$0 + 1 | 0,i$0=i$2;
            continue}}
        var _a9Y_=t[1],_a9Z_=0;
        return iter$2(function(_a90_){return iter_bucket(_a9Z_,_a90_)},_a9Y_)}
      function iter_weak(f,t)
       {function iter_bucket(i,j,b)
         {var i$0=i;
          for(;;)
           {if(length$2(b) <= i$0)return 0;
            var match=check(b,i$0);
            if(match)
             {var _a9W_=t[2],_a9X_=caml_check_bound(_a9W_,j)[1 + j];
              caml_call3(f,b,_a9X_,i$0);
              var i$1=i$0 + 1 | 0,i$0=i$1;
              continue}
            var i$2=i$0 + 1 | 0,i$0=i$2;
            continue}}
        var _a9S_=t[1],_a9T_=0;
        return iteri
                (function(_a9U_,_a9V_){return iter_bucket(_a9T_,_a9U_,_a9V_)},
                 _a9S_)}
      function count_bucket(i,b,accu)
       {var i$0=i,accu$0=accu;
        for(;;)
         {if(length$2(b) <= i$0)return accu$0;
          var
           _a9R_=check(b,i$0)?1:0,
           accu$1=accu$0 + _a9R_ | 0,
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           accu$0=accu$1;
          continue}}
      function count(t)
       {var _a9M_=0,_a9N_=t[1],_a9O_=0;
        return fold_right$0
                (function(_a9P_,_a9Q_){return count_bucket(_a9O_,_a9P_,_a9Q_)},
                 _a9N_,
                 _a9M_)}
      function next_sz(n)
       {return min$0(((3 * n | 0) / 2 | 0) + 3 | 0,max_array_length)}
      function prev_sz(n){return (((n - 3 | 0) * 2 | 0) + 2 | 0) / 3 | 0}
      function test_shrink_bucket(t)
       {var
         _a9m_=t[5],
         _a9n_=t[1],
         bucket=caml_check_bound(_a9n_,_a9m_)[1 + _a9m_],
         _a9o_=t[5],
         _a9p_=t[2],
         hbucket=caml_check_bound(_a9p_,_a9o_)[1 + _a9o_],
         len=length$2(bucket),
         prev_len=prev_sz(len),
         _a9q_=0,
         _a9r_=0,
         live=count_bucket(_a9r_,bucket,_a9q_);
        if(live <= prev_len)
         {var
           loop=
            function(i,j)
             {var i$0=i,j$0=j;
              for(;;)
               {var _a9J_=prev_len <= j$0?1:0;
                if(_a9J_)
                 {if(check(bucket,i$0)){var i$1=i$0 + 1 | 0,i$0=i$1;continue}
                  if(check(bucket,j$0))
                   {var _a9K_=1;
                    blit$2(bucket,j$0,bucket,i$0,_a9K_);
                    var _a9L_=caml_check_bound(hbucket,j$0)[1 + j$0];
                    caml_check_bound(hbucket,i$0)[1 + i$0] = _a9L_;
                    var j$1=j$0 - 1 | 0,i$2=i$0 + 1 | 0,i$0=i$2,j$0=j$1;
                    continue}
                  var j$2=j$0 - 1 | 0,j$0=j$2;
                  continue}
                return _a9J_}},
           _a9s_=length$2(bucket) - 1 | 0,
           _a9t_=0;
          loop(_a9t_,_a9s_);
          if(0 === prev_len)
           {var _a9u_=t[5],_a9v_=t[1];
            caml_check_bound(_a9v_,_a9u_)[1 + _a9u_] = emptybucket;
            var _a9x_=t[5],_a9w_=[0],_a9y_=t[2];
            caml_check_bound(_a9y_,_a9x_)[1 + _a9x_] = _a9w_}
          else
           {var newbucket=weak_create(prev_len),_a9B_=0,_a9C_=0;
            blit$2(bucket,_a9C_,newbucket,_a9B_,prev_len);
            var _a9D_=t[5],_a9E_=t[1];
            caml_check_bound(_a9E_,_a9D_)[1 + _a9D_] = newbucket;
            var
             _a9F_=0,
             _a9G_=sub$1(hbucket,_a9F_,prev_len),
             _a9H_=t[5],
             _a9I_=t[2];
            caml_check_bound(_a9I_,_a9H_)[1 + _a9H_] = _a9G_}
          var _a9z_=t[3] < len?1:0,_a9A_=_a9z_?prev_len <= t[3]?1:0:_a9z_;
          if(_a9A_)t[4] = t[4] - 1 | 0}
        t[5] = caml_mod(t[5] + 1 | 0,t[1].length - 1);
        return 0}
      function add_aux(t,setter,d,h,index)
       {var
         _a8__=t[1],
         bucket=caml_check_bound(_a8__,index)[1 + index],
         _a8$_=t[2],
         hashes=caml_check_bound(_a8$_,index)[1 + index],
         sz=length$2(bucket);
        function loop(i)
         {var i$0=i;
          for(;;)
           {if(sz <= i$0)
             {var
               _a9a_=max_array_length - 2 | 0,
               _a9b_=((3 * sz | 0) / 2 | 0) + 3 | 0,
               newsz=min$0(_a9b_,_a9a_);
              if(newsz <= sz)failwith(_dR_);
              var
               newbucket=weak_create(newsz),
               newhashes=caml_make_vect(newsz,0),
               _a9c_=0,
               _a9d_=0;
              blit$2(bucket,_a9d_,newbucket,_a9c_,sz);
              var _a9e_=0,_a9f_=0;
              blit$1(hashes,_a9f_,newhashes,_a9e_,sz);
              caml_call3(setter,newbucket,sz,d);
              caml_check_bound(newhashes,sz)[1 + sz] = h;
              var _a9g_=t[1];
              caml_check_bound(_a9g_,index)[1 + index] = newbucket;
              var _a9h_=t[2];
              caml_check_bound(_a9h_,index)[1 + index] = newhashes;
              var _a9i_=sz <= t[3]?1:0,_a9j_=_a9i_?t[3] < newsz?1:0:_a9i_;
              if(_a9j_)
               {t[4] = t[4] + 1 | 0;
                var i$1=0;
                for(;;)
                 {test_shrink_bucket(t);
                  var _a9l_=i$1 + 1 | 0;
                  if(2 !== i$1){var i$1=_a9l_;continue}
                  break}}
              var _a9k_=((t[1].length - 1) / 2 | 0) < t[4]?1:0;
              return _a9k_?resize(t):_a9k_}
            if(check(bucket,i$0)){var i$2=i$0 + 1 | 0,i$0=i$2;continue}
            caml_call3(setter,bucket,i$0,d);
            caml_check_bound(hashes,i$0)[1 + i$0] = h;
            return 0}}
        return loop(0)}
      function resize(t)
       {var oldlen=t[1].length - 1,newlen=next_sz(oldlen);
        if(oldlen < newlen)
         {var
           newt=create(newlen),
           add_weak=
            function(ob,oh,oi)
             {function setter(nb,ni,param){return blit$2(ob,oi,nb,ni,1)}
              var h=caml_check_bound(oh,oi)[1 + oi];
              return add_aux(newt,setter,0,h,get_index(newt,h))};
          iter_weak(add_weak,t);
          t[1] = newt[1];
          t[2] = newt[2];
          t[3] = newt[3];
          t[4] = newt[4];
          t[5] = caml_mod(t[5],newt[1].length - 1);
          return 0}
        t[3] = max_num;
        t[4] = 0;
        return 0}
      function add(t,d)
       {var _a89_=H[2],h=caml_call1(_a89_,d);
        return add_aux(t,set,[0,d],h,get_index(t,h))}
      function find_or(t,d,ifnotfound)
       {var
         _a85_=H[2],
         h=caml_call1(_a85_,d),
         index=get_index(t,h),
         _a86_=t[1],
         bucket=caml_check_bound(_a86_,index)[1 + index],
         _a87_=t[2],
         hashes=caml_check_bound(_a87_,index)[1 + index],
         sz=length$2(bucket);
        function loop(i)
         {var i$0=i;
          for(;;)
           {if(sz <= i$0)return caml_call2(ifnotfound,h,index);
            if(h === caml_check_bound(hashes,i$0)[1 + i$0])
             {var match=get_copy(bucket,i$0);
              if(match)
               {var v=match[1],_a88_=H[1];
                if(caml_call2(_a88_,v,d))
                 {var match$0=get$0(bucket,i$0);
                  if(match$0){var v$0=match$0[1];return v$0}
                  var i$1=i$0 + 1 | 0,i$0=i$1;
                  continue}}
              var i$2=i$0 + 1 | 0,i$0=i$2;
              continue}
            var i$3=i$0 + 1 | 0,i$0=i$3;
            continue}}
        return loop(0)}
      function merge(t,d)
       {return find_or
                (t,
                 d,
                 function(h,index)
                  {var _a84_=[0,d];add_aux(t,set,_a84_,h,index);return d})}
      function find(t,d)
       {return find_or(t,d,function(h,index){throw Not_found})}
      function find_opt(t,d)
       {var
         _a80_=H[2],
         h=caml_call1(_a80_,d),
         index=get_index(t,h),
         _a81_=t[1],
         bucket=caml_check_bound(_a81_,index)[1 + index],
         _a82_=t[2],
         hashes=caml_check_bound(_a82_,index)[1 + index],
         sz=length$2(bucket);
        function loop(i)
         {var i$0=i;
          for(;;)
           {if(sz <= i$0)return 0;
            if(h === caml_check_bound(hashes,i$0)[1 + i$0])
             {var match=get_copy(bucket,i$0);
              if(match)
               {var v=match[1],_a83_=H[1];
                if(caml_call2(_a83_,v,d))
                 {var v$0=get$0(bucket,i$0);
                  if(v$0)return v$0;
                  var i$1=i$0 + 1 | 0,i$0=i$1;
                  continue}}
              var i$2=i$0 + 1 | 0,i$0=i$2;
              continue}
            var i$3=i$0 + 1 | 0,i$0=i$3;
            continue}}
        return loop(0)}
      function find_shadow(t,d,iffound,ifnotfound)
       {var
         _a8W_=H[2],
         h=caml_call1(_a8W_,d),
         index=get_index(t,h),
         _a8X_=t[1],
         bucket=caml_check_bound(_a8X_,index)[1 + index],
         _a8Y_=t[2],
         hashes=caml_check_bound(_a8Y_,index)[1 + index],
         sz=length$2(bucket);
        function loop(i)
         {var i$0=i;
          for(;;)
           {if(sz <= i$0)return ifnotfound;
            if(h === caml_check_bound(hashes,i$0)[1 + i$0])
             {var match=get_copy(bucket,i$0);
              if(match)
               {var v=match[1],_a8Z_=H[1];
                if(caml_call2(_a8Z_,v,d))return caml_call2(iffound,bucket,i$0)}
              var i$1=i$0 + 1 | 0,i$0=i$1;
              continue}
            var i$2=i$0 + 1 | 0,i$0=i$2;
            continue}}
        return loop(0)}
      function remove(t,d)
       {var _a8V_=0;
        return find_shadow(t,d,function(w,i){return set(w,i,0)},_a8V_)}
      function mem(t,d)
       {var _a8U_=0;return find_shadow(t,d,function(w,i){return 1},_a8U_)}
      function find_all(t,d)
       {var
         _a8Q_=H[2],
         h=caml_call1(_a8Q_,d),
         index=get_index(t,h),
         _a8R_=t[1],
         bucket=caml_check_bound(_a8R_,index)[1 + index],
         _a8S_=t[2],
         hashes=caml_check_bound(_a8S_,index)[1 + index],
         sz=length$2(bucket);
        function loop(i,accu)
         {var i$0=i,accu$0=accu;
          for(;;)
           {if(sz <= i$0)return accu$0;
            if(h === caml_check_bound(hashes,i$0)[1 + i$0])
             {var match=get_copy(bucket,i$0);
              if(match)
               {var v=match[1],_a8T_=H[1];
                if(caml_call2(_a8T_,v,d))
                 {var match$0=get$0(bucket,i$0);
                  if(match$0)
                   {var
                     v$0=match$0[1],
                     accu$1=[0,v$0,accu$0],
                     i$1=i$0 + 1 | 0,
                     i$0=i$1,
                     accu$0=accu$1;
                    continue}
                  var i$2=i$0 + 1 | 0,i$0=i$2;
                  continue}}
              var i$3=i$0 + 1 | 0,i$0=i$3;
              continue}
            var i$4=i$0 + 1 | 0,i$0=i$4;
            continue}}
        return loop(0,0)}
      function stats(t)
       {var len=t[1].length - 1,_a8C_=t[1],lens=map$2(length$2,_a8C_);
        function _a8D_(_a8P_,_a8O_){return caml_int_compare(_a8P_,_a8O_)}
        sort(_a8D_,lens);
        var _a8E_=0;
        function _a8F_(_a8N_,_a8M_){return _a8N_ + _a8M_ | 0}
        var
         totlen=fold_left$0(_a8F_,_a8E_,lens),
         _a8G_=len - 1 | 0,
         _a8I_=len / 2 | 0,
         _a8H_=caml_check_bound(lens,_a8G_)[1 + _a8G_],
         _a8J_=caml_check_bound(lens,_a8I_)[1 + _a8I_],
         _a8K_=0,
         _a8L_=caml_check_bound(lens,0)[1 + _a8K_];
        return [0,len,count(t),totlen,_a8L_,_a8J_,_a8H_]}
      return [0,
              create,
              clear,
              merge,
              add,
              remove,
              find,
              find_opt,
              find_all,
              mem,
              iter,
              fold,
              count,
              stats]}
    function id(x){return x}
    var size=0,unknown=-1;
    function is_known(n){return 0 <= n?1:0}
    var String_tag=[248,_dS_,caml_fresh_oo_id(0)];
    function pp_enqueue(state,token)
     {state[13] = state[13] + token[3] | 0;return add(token,state[28])}
    function pp_clear_queue(state)
     {state[12] = 1;state[13] = 1;return clear$0(state[28])}
    var pp_infinity=1000000010;
    function pp_output_string(state,s)
     {return caml_call3(state[17],s,0,caml_ml_string_length(s))}
    function pp_output_newline(state){return caml_call1(state[19],0)}
    function pp_output_spaces(state,n){return caml_call1(state[20],n)}
    function pp_output_indent(state,n){return caml_call1(state[21],n)}
    function format_pp_text(state,size,text)
     {state[9] = state[9] - size | 0;
      pp_output_string(state,text);
      state[11] = 0;
      return 0}
    function format_string(state,s)
     {var _a8A_=caml_string_notequal(s,_dT_);
      return _a8A_?format_pp_text(state,caml_ml_string_length(s),s):_a8A_}
    function break_new_line(state,param,width)
     {var after=param[3],offset=param[2],before=param[1];
      format_string(state,before);
      pp_output_newline(state);
      state[11] = 1;
      var
       indent=(state[6] - width | 0) + offset | 0,
       _a8y_=state[8],
       real_indent=min$0(_a8y_,indent);
      state[10] = real_indent;
      state[9] = state[6] - state[10] | 0;
      var _a8z_=state[10];
      pp_output_indent(state,_a8z_);
      return format_string(state,after)}
    function break_line(state,width){return break_new_line(state,_dU_,width)}
    function break_same_line(state,param)
     {var after=param[3],width=param[2],before=param[1];
      format_string(state,before);
      state[9] = state[9] - width | 0;
      pp_output_spaces(state,width);
      return format_string(state,after)}
    function pp_force_break_line(state)
     {var _a8w_=state[2],match=top_opt(_a8w_);
      if(match)
       {var
         match$0=match[1],
         width=match$0[2],
         box_type=match$0[1],
         _a8x_=state[9] < width?1:0;
        return _a8x_?3 < box_type - 1 >>> 0?0:break_line(state,width):_a8x_}
      return pp_output_newline(state)}
    function pp_skip_token(state)
     {var _a8u_=state[28],match=take_opt(_a8u_);
      if(match)
       {var match$0=match[1],size=match$0[1],length=match$0[3];
        state[12] = state[12] - length | 0;
        var _a8v_=id(size);
        state[9] = state[9] + _a8v_ | 0;
        return 0}
      return 0}
    function format_pp_token(state,size,param)
     {if(typeof param === "number")
       switch(param)
        {case 0:
          var _a8g_=state[3],match=top_opt(_a8g_);
          if(match)
           {var
             match$0=match[1],
             tabs=match$0[1],
             add_tab=
              function(n,ls)
               {if(ls)
                 {var l=ls[2],x=ls[1];
                  return caml_lessthan(n,x)?[0,n,ls]:[0,x,add_tab(n,l)]}
                return [0,n,0]},
             _a8h_=tabs[1],
             _a8i_=state[6] - state[9] | 0;
            tabs[1] = add_tab(_a8i_,_a8h_);
            return 0}
          return 0;
         case 1:var _a8j_=state[2];pop_opt(_a8j_);return 0;
         case 2:var _a8k_=state[3];pop_opt(_a8k_);return 0;
         case 3:
          var _a8l_=state[2],match$1=top_opt(_a8l_);
          if(match$1)
           {var match$2=match$1[1],width=match$2[2];
            return break_line(state,width)}
          return pp_output_newline(state);
         case 4:
          var _a8m_=state[10] !== (state[6] - state[9] | 0)?1:0;
          return _a8m_?pp_skip_token(state):_a8m_;
         default:
          var _a8n_=state[5],match$3=pop_opt(_a8n_);
          if(match$3)
           {var
             tag_name=match$3[1],
             _a8o_=state[25],
             marker=caml_call1(_a8o_,tag_name);
            return pp_output_string(state,marker)}
          return 0}
      else
       switch(param[0])
        {case 0:var s=param[1];return format_pp_text(state,size,s);
         case 1:
          var
           breaks=param[2],
           fits=param[1],
           off=breaks[2],
           before=breaks[1],
           _a8p_=state[2],
           match$4=top_opt(_a8p_);
          if(match$4)
           {var match$5=match$4[1],width$0=match$5[2],box_type=match$5[1];
            switch(box_type)
             {case 0:return break_same_line(state,fits);
              case 1:return break_new_line(state,breaks,width$0);
              case 2:return break_new_line(state,breaks,width$0);
              case 3:
               return state[9] < (size + caml_ml_string_length(before) | 0)
                       ?break_new_line(state,breaks,width$0)
                       :break_same_line(state,fits);
              case 4:
               return state[11]
                       ?break_same_line(state,fits)
                       :state[9] < (size + caml_ml_string_length(before) | 0)
                         ?break_new_line(state,breaks,width$0)
                         :((state[6] - width$0 | 0) + off | 0) < state[10]
                           ?break_new_line(state,breaks,width$0)
                           :break_same_line(state,fits);
              default:return break_same_line(state,fits)}}
          return 0;
         case 2:
          var
           off$0=param[2],
           n=param[1],
           insertion_point=state[6] - state[9] | 0,
           _a8q_=state[3],
           match$6=top_opt(_a8q_);
          if(match$6)
           {var match$7=match$6[1],tabs$0=match$7[1],_a8r_=tabs$0[1];
            if(_a8r_)
             var
              first=_a8r_[1],
              find=
               function(param)
                {var param$0=param;
                 for(;;)
                  {if(param$0)
                    {var tail=param$0[2],head=param$0[1];
                     if(insertion_point <= head)return head;
                     var param$0=tail;
                     continue}
                   return first}},
              _a8s_=tabs$0[1],
              tab=find(_a8s_);
            else
             var tab=insertion_point;
            var offset=tab - insertion_point | 0;
            return 0 <= offset
                    ?break_same_line(state,[0,_dW_,offset + n | 0,_dV_])
                    :break_new_line
                      (state,[0,_dY_,tab + off$0 | 0,_dX_],state[6])}
          return 0;
         case 3:
          var
           ty=param[2],
           off$1=param[1],
           insertion_point$0=state[6] - state[9] | 0;
          if(state[8] < insertion_point$0)pp_force_break_line(state);
          var
           width$1=state[9] - off$1 | 0,
           box_type$0=1 === ty?1:state[9] < size?ty:5;
          return push([0,box_type$0,width$1],state[2]);
         case 4:var tbox=param[1];return push(tbox,state[3]);
         default:
          var
           tag_name$0=param[1],
           _a8t_=state[24],
           marker$0=caml_call1(_a8t_,tag_name$0);
          pp_output_string(state,marker$0);
          return push(tag_name$0,state[5])}}
    function advance_left(state)
     {for(;;)
       {var _a8c_=state[28],match=peek_opt(_a8c_);
        if(match)
         {var
           match$0=match[1],
           size=match$0[1],
           length=match$0[3],
           token=match$0[2],
           pending_count=state[13] - state[12] | 0,
           _a8d_=is_known(size),
           _a8e_=_a8d_ || (state[9] <= pending_count?1:0);
          if(_a8e_)
           {var _a8f_=state[28];
            take(_a8f_);
            var size$0=is_known(size)?id(size):pp_infinity;
            format_pp_token(state,size$0,token);
            state[12] = length + state[12] | 0;
            continue}
          return _a8e_}
        return 0}}
    function enqueue_advance(state,tok)
     {pp_enqueue(state,tok);return advance_left(state)}
    function enqueue_string_as(state,size,s)
     {return enqueue_advance(state,[0,size,[0,s],id(size)])}
    function enqueue_string(state,s)
     {var _a8b_=caml_ml_string_length(s);
      return enqueue_string_as(state,id(_a8b_),s)}
    function initialize_scan_stack(stack)
     {clear(stack);
      var queue_elem=[0,unknown,_dZ_,0];
      return push([0,-1,queue_elem],stack)}
    function set_size(state,ty)
     {var _a73_=state[1],match=top_opt(_a73_);
      if(match)
       {var
         match$0=match[1],
         queue_elem=match$0[2],
         left_total=match$0[1],
         _a74_=queue_elem[1],
         size=id(_a74_);
        if(left_total < state[12])return initialize_scan_stack(state[1]);
        var _a75_=queue_elem[2];
        if(typeof _a75_ !== "number")
         switch(_a75_[0])
          {case 3:
            var _a79_=1 - ty;
            if(_a79_)
             {var _a7__=state[13] + size | 0;
              queue_elem[1] = id(_a7__);
              var _a7$_=state[1];
              pop_opt(_a7$_);
              var _a8a_=0}
            else
             var _a8a_=_a79_;
            return _a8a_;
           case 1:
           case 2:
            if(ty)
             {var _a76_=state[13] + size | 0;
              queue_elem[1] = id(_a76_);
              var _a77_=state[1];
              pop_opt(_a77_);
              var _a78_=0}
            else
             var _a78_=ty;
            return _a78_
           }
        return 0}
      return 0}
    function scan_push(state,b,token)
     {pp_enqueue(state,token);
      if(b){var _a72_=1;set_size(state,_a72_)}
      var elem=[0,state[13],token];
      return push(elem,state[1])}
    function pp_open_box_gen(state,indent,br_ty)
     {state[14] = state[14] + 1 | 0;
      if(state[14] < state[15])
       {var
         _a70_=- state[13] | 0,
         size=id(_a70_),
         elem=[0,size,[3,indent,br_ty],0];
        return scan_push(state,0,elem)}
      var _a71_=state[14] === state[15]?1:0;
      return _a71_?enqueue_string(state,state[16]):_a71_}
    function pp_open_sys_box(state){return pp_open_box_gen(state,0,3)}
    function pp_close_box(state,param)
     {var _a7V_=1 < state[14]?1:0;
      if(_a7V_)
       {if(state[14] < state[15])
         {var _a7W_=[0,size,1,0];
          pp_enqueue(state,_a7W_);
          var _a7X_=1;
          set_size(state,_a7X_);
          var _a7Y_=0;
          set_size(state,_a7Y_)}
        state[14] = state[14] - 1 | 0;
        var _a7Z_=0}
      else
       var _a7Z_=_a7V_;
      return _a7Z_}
    function pp_open_stag(state,tag_name)
     {if(state[22])
       {var _a7S_=state[4];
        push(tag_name,_a7S_);
        var _a7T_=state[26];
        caml_call1(_a7T_,tag_name)}
      var _a7U_=state[23];
      if(_a7U_)
       {var token=[5,tag_name];return pp_enqueue(state,[0,size,token,0])}
      return _a7U_}
    function pp_close_stag(state,param)
     {if(state[23]){var _a7O_=[0,size,5,0];pp_enqueue(state,_a7O_)}
      var _a7P_=state[22];
      if(_a7P_)
       {var _a7Q_=state[4],match=pop_opt(_a7Q_);
        if(match){var tag_name=match[1];return caml_call1(state[27],tag_name)}
        var _a7R_=0}
      else
       var _a7R_=_a7P_;
      return _a7R_}
    function pp_close_tag(state,param){return pp_close_stag(state,0)}
    function pp_rinit(state)
     {pp_clear_queue(state);
      var _a7J_=state[1];
      initialize_scan_stack(_a7J_);
      var _a7K_=state[2];
      clear(_a7K_);
      var _a7L_=state[3];
      clear(_a7L_);
      var _a7M_=state[4];
      clear(_a7M_);
      var _a7N_=state[5];
      clear(_a7N_);
      state[10] = 0;
      state[14] = 0;
      state[9] = state[6];
      return pp_open_sys_box(state)}
    function clear_tag_stack(state)
     {var _a7I_=state[4];
      return iter$3(function(param){return pp_close_tag(state,0)},_a7I_)}
    function pp_flush_queue(state,b)
     {clear_tag_stack(state);
      for(;;)
       {if(1 < state[14]){var _a7H_=0;pp_close_box(state,_a7H_);continue}
        state[13] = pp_infinity;
        advance_left(state);
        if(b)pp_output_newline(state);
        return pp_rinit(state)}}
    function pp_print_as_size(state,size,s)
     {var _a7G_=state[14] < state[15]?1:0;
      return _a7G_?enqueue_string_as(state,size,s):_a7G_}
    function pp_print_as(state,isize,s)
     {return pp_print_as_size(state,id(isize),s)}
    function str(state,s)
     {return pp_print_as(state,caml_ml_string_length(s),s)}
    function pp(state,i){return str(state,to_string$1(i))}
    function pp_print_char(state,c)
     {var _a7F_=1;return pp_print_as(state,1,make$1(_a7F_,c))}
    function pp_open_box(state,indent){return pp_open_box_gen(state,indent,4)}
    function pp_print_newline(state,param)
     {var _a7E_=1;pp_flush_queue(state,_a7E_);return caml_call1(state[18],0)}
    function pp_print_flush(state,param)
     {var _a7D_=0;pp_flush_queue(state,_a7D_);return caml_call1(state[18],0)}
    function pp_force_newline(state,param)
     {var _a7C_=state[14] < state[15]?1:0;
      return _a7C_?enqueue_advance(state,[0,size,3,0]):_a7C_}
    function pp_print_custom_break(state,fits,breaks)
     {var
       after=fits[3],
       width=fits[2],
       before=fits[1],
       _a7A_=state[14] < state[15]?1:0;
      if(_a7A_)
       {var
         _a7B_=- state[13] | 0,
         size=id(_a7B_),
         token=[1,fits,breaks],
         length=
          (caml_ml_string_length(before) + width | 0)
          +
          caml_ml_string_length(after)
          |
          0,
         elem=[0,size,token,length];
        return scan_push(state,1,elem)}
      return _a7A_}
    function pp_print_break(state,width,offset)
     {return pp_print_custom_break
              (state,[0,_d3_,width,_d2_],[0,_d1_,offset,_d0_])}
    function pp_print_space(state,param){return pp_print_break(state,1,0)}
    function pp_print_cut(state,param){return pp_print_break(state,0,0)}
    function display_newline(state,param)
     {return caml_call3(state[17],_d4_,0,1)}
    var _d5_=32,_d6_=80,blank_line=make$1(_d6_,_d5_);
    function display_indent(state,n)
     {var n$0=n;
      for(;;)
       {var _a7w_=0 < n$0?1:0;
        if(_a7w_)
         {if(80 < n$0)
           {var _a7x_=80,_a7y_=0,_a7z_=state[17];
            caml_call3(_a7z_,blank_line,_a7y_,_a7x_);
            var n$1=n$0 - 80 | 0,n$0=n$1;
            continue}
          return caml_call3(state[17],blank_line,0,n$0)}
        return _a7w_}}
    function default_pp_mark_open_tag(param)
     {if(param[1] === String_tag){var s=param[2];return cat(_d8_,cat(s,_d7_))}
      return _d9_}
    function default_pp_mark_close_tag(param)
     {if(param[1] === String_tag){var s=param[2];return cat(_d$_,cat(s,_d__))}
      return _ea_}
    function default_pp_print_open_tag(_a7v_){return 0}
    function default_pp_print_close_tag(_a7u_){return 0}
    function pp_make_formatter(f,g,h,i,j)
     {var _a7c_=0,pp_queue=create$0(_a7c_),sys_tok=[0,unknown,_eb_,0];
      add(sys_tok,pp_queue);
      var _a7d_=0,scan_stack=create(_a7d_);
      initialize_scan_stack(scan_stack);
      var _a7e_=[0,1,sys_tok];
      push(_a7e_,scan_stack);
      var
       pp_margin=78,
       pp_min_space_left=10,
       _a7f_=0,
       _a7g_=0,
       _a7h_=1,
       _a7i_=1,
       _a7j_=1,
       _a7k_=1,
       _a7l_=0,
       _a7m_=68,
       _a7n_=0,
       _a7o_=create(_a7n_),
       _a7p_=0,
       _a7q_=create(_a7p_),
       _a7r_=0,
       _a7s_=create(_a7r_),
       _a7t_=0;
      return [0,
              scan_stack,
              create(_a7t_),
              _a7s_,
              _a7q_,
              _a7o_,
              pp_margin,
              pp_min_space_left,
              _a7m_,
              pp_margin,
              _a7l_,
              _a7k_,
              _a7j_,
              _a7i_,
              _a7h_,
              max_num,
              _ec_,
              f,
              g,
              h,
              i,
              j,
              _a7g_,
              _a7f_,
              default_pp_mark_open_tag,
              default_pp_mark_close_tag,
              default_pp_print_open_tag,
              default_pp_print_close_tag,
              pp_queue]}
    function make_formatter(output,flush)
     {function _a65_(_a7b_){return 0}
      function _a66_(_a7a_){return 0}
      function _a67_(_a6$_){return 0}
      var ppf=pp_make_formatter(output,flush,_a67_,_a66_,_a65_);
      ppf[19] = function(_a6__){return display_newline(ppf,_a6__)};
      ppf[20] = function(_a69_){return display_indent(ppf,_a69_)};
      ppf[21] = function(_a68_){return display_indent(ppf,_a68_)};
      return ppf}
    function formatter_of_out_channel(oc)
     {function _a61_(param){return flush(oc)}
      return make_formatter
              (function(_a62_,_a63_,_a64_)
                {return output_substring(oc,_a62_,_a63_,_a64_)},
               _a61_)}
    function formatter_of_buffer(b)
     {function _a6W_(_a60_){return 0}
      return make_formatter
              (function(_a6X_,_a6Y_,_a6Z_)
                {return add_substring(b,_a6X_,_a6Y_,_a6Z_)},
               _a6W_)}
    var pp_buffer_size=512;
    function pp_make_buffer(param){return create$1(pp_buffer_size)}
    var
     _ed_=0,
     stdbuf=pp_make_buffer(_ed_),
     std_formatter=formatter_of_out_channel(stdout),
     err_formatter=formatter_of_out_channel(stderr);
    formatter_of_buffer(stdbuf);
    function flush_buffer_formatter(buf,ppf)
     {var _a6V_=0;
      pp_flush_queue(ppf,_a6V_);
      var s=contents(buf);
      reset(buf);
      return s}
    function list(opt,pp_v,ppf,param)
     {var opt$0=opt,param$0=param;
      for(;;)
       {if(opt$0)var sth=opt$0[1],pp_sep=sth;else var pp_sep=pp_print_cut;
        if(param$0)
         {var _a6T_=param$0[1];
          if(param$0[2])
           {var vs=param$0[2];
            caml_call2(pp_v,ppf,_a6T_);
            var _a6U_=0;
            caml_call2(pp_sep,ppf,_a6U_);
            var opt$1=[0,pp_sep],opt$0=opt$1,param$0=vs;
            continue}
          return caml_call2(pp_v,ppf,_a6T_)}
        return 0}}
    function pp_print_text(ppf,s)
     {var len=caml_ml_string_length(s),left=[0,0],right=[0,0];
      function flush(param)
       {var
         _a6Q_=right[1] - left[1] | 0,
         _a6R_=left[1],
         _a6S_=sub$0(s,_a6R_,_a6Q_);
        str(ppf,_a6S_);
        right[1]++;
        left[1] = right[1];
        return 0}
      for(;;)
       {if(right[1] !== len)
         {var _a6K_=right[1],match=caml_string_get(s,_a6K_);
          if(10 === match)
           {var _a6L_=0;flush(_a6L_);var _a6M_=0;pp_force_newline(ppf,_a6M_)}
          else
           if(32 === match)
            {var _a6N_=0;flush(_a6N_);var _a6O_=0;pp_print_space(ppf,_a6O_)}
           else
            right[1]++;
          continue}
        var _a6P_=left[1] !== len?1:0;
        return _a6P_?flush(0):_a6P_}}
    function compute_tag(output,tag_acc)
     {var _a6I_=16,buf=create$1(_a6I_),ppf=formatter_of_buffer(buf);
      caml_call2(output,ppf,tag_acc);
      var _a6J_=0;
      pp_print_flush(ppf,_a6J_);
      var len=length$0(buf);
      return 2 <= len?sub$2(buf,1,len - 2 | 0):contents(buf)}
    function output_formatting_lit(ppf,fmting_lit)
     {if(typeof fmting_lit === "number")
       switch(fmting_lit)
        {case 0:return pp_close_box(ppf,0);
         case 1:return pp_close_tag(ppf,0);
         case 2:return pp_print_flush(ppf,0);
         case 3:return pp_force_newline(ppf,0);
         case 4:return pp_print_newline(ppf,0);
         case 5:return pp_print_char(ppf,64);
         default:return pp_print_char(ppf,37)}
      else
       switch(fmting_lit[0])
        {case 0:
          var offset=fmting_lit[3],width=fmting_lit[2];
          return pp_print_break(ppf,width,offset);
         case 1:return 0;
         default:
          var c=fmting_lit[1],_a6H_=64;
          pp_print_char(ppf,_a6H_);
          return pp_print_char(ppf,c)}}
    function output_acc$0(ppf,acc)
     {var switch$0=0;
      if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          output_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _a6e_=acc[2],_a6f_=acc[1];
          if(0 === _a6e_[0])
           {var acc$0=_a6e_[1];
            output_acc$0(ppf,_a6f_);
            return pp_open_stag
                    (ppf,[0,String_tag,compute_tag(output_acc$0,acc$0)])}
          var acc$1=_a6e_[1];
          output_acc$0(ppf,_a6f_);
          var
           _a6g_=compute_tag(output_acc$0,acc$1),
           match=open_box_of_string(_a6g_),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _a6h_=acc[1],switch$1=0;
          if(typeof _a6h_ !== "number" && 0 === _a6h_[0])
           {var _a6j_=_a6h_[2],switch$2=0;
            if(typeof _a6j_ !== "number" && 1 === _a6j_[0])
             {var
               _a6k_=acc[2],
               _a6l_=_a6j_[2],
               _a6m_=_a6h_[1],
               s$0=_a6k_,
               size=_a6l_,
               p$1=_a6m_;
              switch$1 = 1;
              switch$2 = 1}}
          if(! switch$1){var _a6i_=acc[2],s=_a6i_,p$0=_a6h_;switch$0 = 2}
          break;
         case 3:
          var _a6n_=acc[1],switch$3=0;
          if(typeof _a6n_ !== "number" && 0 === _a6n_[0])
           {var _a6p_=_a6n_[2],switch$4=0;
            if(typeof _a6p_ !== "number" && 1 === _a6p_[0])
             {var
               _a6q_=acc[2],
               _a6r_=_a6p_[2],
               _a6s_=_a6n_[1],
               c$0=_a6q_,
               size$0=_a6r_,
               p$3=_a6s_;
              switch$0 = 1;
              switch$3 = 1;
              switch$4 = 1}}
          if(! switch$3){var _a6o_=acc[2],c=_a6o_,p$2=_a6n_;switch$0 = 3}
          break;
         case 4:
          var _a6v_=acc[1],switch$5=0;
          if(typeof _a6v_ !== "number" && 0 === _a6v_[0])
           {var _a6x_=_a6v_[2],switch$6=0;
            if(typeof _a6x_ !== "number" && 1 === _a6x_[0])
             {var
               _a6y_=acc[2],
               _a6z_=_a6x_[2],
               _a6A_=_a6v_[1],
               s$0=_a6y_,
               size=_a6z_,
               p$1=_a6A_;
              switch$5 = 1;
              switch$6 = 1}}
          if(! switch$5){var _a6w_=acc[2],s=_a6w_,p$0=_a6v_;switch$0 = 2}
          break;
         case 5:
          var _a6B_=acc[1],switch$7=0;
          if(typeof _a6B_ === "number" || ! (0 === _a6B_[0]))
           switch$7 = 1;
          else
           {var _a6D_=_a6B_[2],switch$8=0;
            if(typeof _a6D_ !== "number" && 1 === _a6D_[0])
             {var
               _a6E_=acc[2],
               _a6F_=_a6D_[2],
               _a6G_=_a6B_[1],
               c$0=_a6E_,
               size$0=_a6F_,
               p$3=_a6G_;
              switch$0 = 1;
              switch$8 = 1}
            if(! switch$8)switch$7 = 1}
          if(switch$7){var _a6C_=acc[2],c=_a6C_,p$2=_a6B_;switch$0 = 3}
          break;
         case 6:
          var f$0=acc[2],p$4=acc[1];
          output_acc$0(ppf,p$4);
          return caml_call1(f$0,ppf);
         case 7:
          var p$5=acc[1];output_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          output_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:
         output_acc$0(ppf,p$1);return pp_print_as_size(ppf,id(size),s$0);
        case 1:
         output_acc$0(ppf,p$3);
         var _a6t_=1,_a6u_=make$1(_a6t_,c$0);
         return pp_print_as_size(ppf,id(size$0),_a6u_);
        case 2:output_acc$0(ppf,p$0);return str(ppf,s);
        default:output_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function strput_acc$0(ppf,acc)
     {var switch$0=0;
      if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          strput_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _a5I_=acc[2],_a5J_=acc[1];
          if(0 === _a5I_[0])
           {var acc$0=_a5I_[1];
            strput_acc$0(ppf,_a5J_);
            return pp_open_stag
                    (ppf,[0,String_tag,compute_tag(strput_acc$0,acc$0)])}
          var acc$1=_a5I_[1];
          strput_acc$0(ppf,_a5J_);
          var
           _a5K_=compute_tag(strput_acc$0,acc$1),
           match=open_box_of_string(_a5K_),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _a5L_=acc[1],switch$1=0;
          if(typeof _a5L_ !== "number" && 0 === _a5L_[0])
           {var _a5N_=_a5L_[2],switch$2=0;
            if(typeof _a5N_ !== "number" && 1 === _a5N_[0])
             {var
               _a5O_=acc[2],
               _a5P_=_a5N_[2],
               _a5Q_=_a5L_[1],
               s$0=_a5O_,
               size=_a5P_,
               p$1=_a5Q_;
              switch$1 = 1;
              switch$2 = 1}}
          if(! switch$1){var _a5M_=acc[2],s=_a5M_,p$0=_a5L_;switch$0 = 2}
          break;
         case 3:
          var _a5R_=acc[1],switch$3=0;
          if(typeof _a5R_ !== "number" && 0 === _a5R_[0])
           {var _a5T_=_a5R_[2],switch$4=0;
            if(typeof _a5T_ !== "number" && 1 === _a5T_[0])
             {var
               _a5U_=acc[2],
               _a5V_=_a5T_[2],
               _a5W_=_a5R_[1],
               c$0=_a5U_,
               size$0=_a5V_,
               p$3=_a5W_;
              switch$0 = 1;
              switch$3 = 1;
              switch$4 = 1}}
          if(! switch$3){var _a5S_=acc[2],c=_a5S_,p$2=_a5R_;switch$0 = 3}
          break;
         case 4:
          var _a5Z_=acc[1],switch$5=0;
          if(typeof _a5Z_ !== "number" && 0 === _a5Z_[0])
           {var _a51_=_a5Z_[2],switch$6=0;
            if(typeof _a51_ !== "number" && 1 === _a51_[0])
             {var
               _a52_=acc[2],
               _a53_=_a51_[2],
               _a54_=_a5Z_[1],
               s$0=_a52_,
               size=_a53_,
               p$1=_a54_;
              switch$5 = 1;
              switch$6 = 1}}
          if(! switch$5){var _a50_=acc[2],s=_a50_,p$0=_a5Z_;switch$0 = 2}
          break;
         case 5:
          var _a55_=acc[1],switch$7=0;
          if(typeof _a55_ === "number" || ! (0 === _a55_[0]))
           switch$7 = 1;
          else
           {var _a57_=_a55_[2],switch$8=0;
            if(typeof _a57_ !== "number" && 1 === _a57_[0])
             {var
               _a58_=acc[2],
               _a59_=_a57_[2],
               _a5__=_a55_[1],
               c$0=_a58_,
               size$0=_a59_,
               p$3=_a5__;
              switch$0 = 1;
              switch$8 = 1}
            if(! switch$8)switch$7 = 1}
          if(switch$7){var _a56_=acc[2],c=_a56_,p$2=_a55_;switch$0 = 3}
          break;
         case 6:
          var _a5$_=acc[1];
          if(typeof _a5$_ !== "number" && 0 === _a5$_[0])
           {var _a6b_=_a5$_[2];
            if(typeof _a6b_ !== "number" && 1 === _a6b_[0])
             {var f$1=acc[2],size$1=_a6b_[2],p$4=_a5$_[1];
              strput_acc$0(ppf,p$4);
              var _a6c_=0,_a6d_=caml_call1(f$1,_a6c_);
              return pp_print_as_size(ppf,id(size$1),_a6d_)}}
          var f$0=acc[2];
          strput_acc$0(ppf,_a5$_);
          var _a6a_=0;
          return str(ppf,caml_call1(f$0,_a6a_));
         case 7:
          var p$5=acc[1];strput_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          strput_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:
         strput_acc$0(ppf,p$1);return pp_print_as_size(ppf,id(size),s$0);
        case 1:
         strput_acc$0(ppf,p$3);
         var _a5X_=1,_a5Y_=make$1(_a5X_,c$0);
         return pp_print_as_size(ppf,id(size$0),_a5Y_);
        case 2:strput_acc$0(ppf,p$0);return str(ppf,s);
        default:strput_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function kfprintf$0(k,ppf,param)
     {var fmt=param[1],_a5H_=0;
      return make_printf
              (function(acc){output_acc$0(ppf,acc);return caml_call1(k,ppf)},
               _a5H_,
               fmt)}
    function pp$0(ppf)
     {function _a5E_(_a5G_){return 0}
      return function(_a5F_){return kfprintf$0(_a5E_,ppf,_a5F_)}}
    function kprintf$0(k,param)
     {var
       fmt=param[1],
       _a5D_=0,
       b=pp_make_buffer(_a5D_),
       ppf=formatter_of_buffer(b);
      function k$0(acc)
       {strput_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,fmt)}
    function sprintf$0(fmt){return kprintf$0(id,fmt)}
    function kasprintf(k,param)
     {var
       fmt=param[1],
       _a5C_=0,
       b=pp_make_buffer(_a5C_),
       ppf=formatter_of_buffer(b);
      function k$0(acc)
       {output_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,fmt)}
    function asprintf(fmt){return kasprintf(id,fmt)}
    function flush_standard_formatters(param)
     {var _a5B_=0;
      pp_print_flush(std_formatter,_a5B_);
      return pp_print_flush(err_formatter,0)}
    at_exit(flush_standard_formatters);
    var null_char=0;
    function next_char(ib)
     {try
       {var _a5y_=0,_a5z_=ib[7],c=caml_call1(_a5z_,_a5y_);
        ib[2] = c;
        ib[3] = 1;
        ib[4] = ib[4] + 1 | 0;
        if(10 === c)ib[5] = ib[5] + 1 | 0;
        return c}
      catch(_a5A_)
       {_a5A_ = caml_wrap_exception(_a5A_);
        if(_a5A_ === End_of_file)
         {ib[2] = null_char;ib[3] = 0;ib[1] = 1;return null_char}
        throw _a5A_}}
    function peek_char(ib){return ib[3]?ib[2]:next_char(ib)}
    function checked_peek_char(ib)
     {var c=peek_char(ib);if(ib[1])throw End_of_file;return c}
    function end_of_input(ib){peek_char(ib);return ib[1]}
    function eof(ib){return ib[1]}
    function char_count(ib){return ib[3]?ib[4] - 1 | 0:ib[4]}
    function line_count(ib){return ib[5]}
    function reset_token(ib){return reset(ib[8])}
    function invalidate_current_char(ib){ib[3] = 0;return 0}
    function token_string(ib)
     {var token_buffer=ib[8],tok=contents(token_buffer);
      clear$1(token_buffer);
      ib[6] = ib[6] + 1 | 0;
      return tok}
    function token_count(ib){return ib[6]}
    function skip_char(width,ib){invalidate_current_char(ib);return width}
    function ignore_char(width,ib){return skip_char(width - 1 | 0,ib)}
    function store_char(width,ib,c)
     {var _a5x_=ib[8];add_char(_a5x_,c);return ignore_char(width,ib)}
    var default_token_buffer_size=1024;
    function create$3(iname,next)
     {return [0,
              0,
              null_char,
              0,
              0,
              0,
              0,
              next,
              create$1(default_token_buffer_size),
              iname]}
    function from_string$0(s)
     {var i=[0,0],len=caml_ml_string_length(s);
      function next(param)
       {if(len <= i[1])throw End_of_file;
        var _a5w_=i[1],c=caml_string_get(s,_a5w_);
        i[1]++;
        return c}
      return create$3(1,next)}
    var len=1024;
    function scan_raise_at_end(ic){throw End_of_file}
    function from_ic(scan_close_ic,iname,ic)
     {var buf=caml_create_bytes(1024),i=[0,0],lim=[0,0],eof=[0,0];
      function next(param)
       {if(i[1] < lim[1])
         {var _a5u_=i[1],c=caml_bytes_get(buf,_a5u_);i[1]++;return c}
        if(eof[1])throw End_of_file;
        var _a5v_=0;
        lim[1] = input(ic,buf,_a5v_,len);
        return 0 === lim[1]
                ?(eof[1] = 1,caml_call1(scan_close_ic,ic))
                :(i[1] = 1,caml_bytes_get(buf,0))}
      return create$3(iname,next)}
    var _ef_=[1,_ee_,stdin];
    from_ic(scan_raise_at_end,_ef_,stdin);
    var Scan_failure=[248,_eg_,caml_fresh_oo_id(0)];
    function bad_input(s){throw [0,Scan_failure,s]}
    function bad_input_escape(c)
     {return bad_input(caml_call1(sprintf(_eh_),c))}
    function bad_token_length(message)
     {return bad_input(caml_call1(sprintf(_ei_),message))}
    function bad_end_of_input(message)
     {return bad_input(caml_call1(sprintf(_ej_),message))}
    function bad_float(param){return bad_input(_ek_)}
    function bad_hex_float(param){return bad_input(_el_)}
    function character_mismatch_err(c,ci)
     {return caml_call2(sprintf(_em_),c,ci)}
    function character_mismatch(c,ci)
     {return bad_input(character_mismatch_err(c,ci))}
    function skip_whites(ib)
     {for(;;)
       {var c=peek_char(ib),_a5s_=1 - eof(ib);
        if(_a5s_)
         {var _a5t_=c - 9 | 0,switch$0=0;
          if(4 < _a5t_ >>> 0)
           {if(23 === _a5t_)switch$0 = 1}
          else
           if(1 < _a5t_ - 2 >>> 0)switch$0 = 1;
          if(switch$0){invalidate_current_char(ib);continue}
          return 0}
        return _a5s_}}
    function check_this_char(ib,c)
     {var ci=checked_peek_char(ib);
      return ci === c?invalidate_current_char(ib):character_mismatch(c,ci)}
    function check_newline(ib)
     {var ci=checked_peek_char(ib);
      return 10 === ci
              ?invalidate_current_char(ib)
              :13 === ci
                ?(invalidate_current_char(ib),check_this_char(ib,10))
                :character_mismatch(10,ci)}
    function check_char(ib,c)
     {return 10 === c
              ?check_newline(ib)
              :32 === c?skip_whites(ib):check_this_char(ib,c)}
    function token_char(ib)
     {var _a5r_=token_string(ib);return caml_string_get(_a5r_,0)}
    function token_bool(ib)
     {var s=token_string(ib);
      return caml_string_notequal(s,_en_)
              ?caml_string_notequal(s,_eo_)
                ?bad_input(caml_call1(sprintf(_ep_),s))
                :1
              :0}
    function integer_conversion_of_char(param)
     {var switcher=param - 88 | 0;
      if(! (32 < switcher >>> 0))
       switch(switcher)
        {case 10:return 0;
         case 12:return 1;
         case 17:return 2;
         case 23:return 3;
         case 29:return 4;
         case 0:
         case 32:return 5
         }
      throw [0,Assert_failure,_eq_]}
    function token_int_literal(conv,ib)
     {switch(conv)
       {case 0:var _a5n_=token_string(ib),tok=cat(_er_,_a5n_);break;
        case 3:var _a5o_=token_string(ib),tok=cat(_es_,_a5o_);break;
        case 4:var _a5p_=token_string(ib),tok=cat(_et_,_a5p_);break;
        case 5:var _a5q_=token_string(ib),tok=cat(_eu_,_a5q_);break;
        default:var tok=token_string(ib)}
      var l=caml_ml_string_length(tok);
      if(0 !== l && 43 === caml_string_get(tok,0))
       return sub$0(tok,1,l - 1 | 0);
      return tok}
    function token_int(conv,ib)
     {var _a5m_=token_int_literal(conv,ib);return caml_int_of_string(_a5m_)}
    function token_float(ib)
     {var _a5l_=token_string(ib);return caml_float_of_string(_a5l_)}
    function token_nativeint(conv,ib)
     {var _a5k_=token_int_literal(conv,ib);return caml_int_of_string(_a5k_)}
    function token_int32(conv,ib)
     {var _a5j_=token_int_literal(conv,ib);return caml_int_of_string(_a5j_)}
    function token_int64(conv,ib)
     {var _a5i_=token_int_literal(conv,ib);return caml_int64_of_string(_a5i_)}
    function scan_decimal_digit_star(width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(eof(ib))return width$0;
        if(58 <= c)
         {if(95 === c)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}}
        else
         if(48 <= c)
          {var width$2=store_char(width$0,ib,c),width$0=width$2;continue}
        return width$0}}
    function scan_unsigned_decimal_int(width,ib)
     {if(0 === width)return bad_token_length(_ev_);
      var c=checked_peek_char(ib);
      if(9 < c - 48 >>> 0)return bad_input(caml_call1(sprintf(_ew_),c));
      var width$0=store_char(width,ib,c);
      return scan_decimal_digit_star(width$0,ib)}
    function scan_digit_star(digitp,width,ib)
     {function scan_digits(width,ib)
       {var width$0=width;
        for(;;)
         {if(0 === width$0)return width$0;
          var c=peek_char(ib);
          if(eof(ib))return width$0;
          if(caml_call1(digitp,c))
           {var width$1=store_char(width$0,ib,c),width$0=width$1;continue}
          if(95 === c)
           {var width$2=ignore_char(width$0,ib),width$0=width$2;continue}
          return width$0}}
      return scan_digits(width,ib)}
    function scan_digit_plus(basis,digitp,width,ib)
     {if(0 === width)return bad_token_length(_ex_);
      var c=checked_peek_char(ib);
      if(caml_call1(digitp,c))
       {var width$0=store_char(width,ib,c);
        return scan_digit_star(digitp,width$0,ib)}
      return bad_input(caml_call2(sprintf(_ey_),c,basis))}
    function is_binary_digit(param){return 1 < param - 48 >>> 0?0:1}
    function scan_binary_int(_a5g_,_a5h_)
     {return scan_digit_plus(_ez_,is_binary_digit,_a5g_,_a5h_)}
    function is_octal_digit(param){return 7 < param - 48 >>> 0?0:1}
    function scan_octal_int(_a5e_,_a5f_)
     {return scan_digit_plus(_eA_,is_octal_digit,_a5e_,_a5f_)}
    function is_hexa_digit(param)
     {var _a5d_=param - 48 | 0,switch$0=0;
      if(22 < _a5d_ >>> 0)
       {if(! (5 < _a5d_ - 49 >>> 0))switch$0 = 1}
      else
       if(6 < _a5d_ - 10 >>> 0)switch$0 = 1;
      return switch$0?1:0}
    function scan_hexadecimal_int(_a5b_,_a5c_)
     {return scan_digit_plus(_eB_,is_hexa_digit,_a5b_,_a5c_)}
    function scan_sign(width,ib)
     {var c=checked_peek_char(ib),switcher=c - 43 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher)
        {case 0:return store_char(width,ib,c);
         case 1:break;
         default:return store_char(width,ib,c)}
      return width}
    function scan_optionally_signed_decimal(width,ib)
     {var width$0=scan_sign(width,ib);
      return scan_unsigned_decimal_int(width$0,ib)}
    function scan_unsigned_int(width,ib)
     {var c=checked_peek_char(ib);
      if(48 === c)
       {var width$0=store_char(width,ib,c);
        if(0 === width$0)return width$0;
        var c$0=peek_char(ib);
        if(eof(ib))return width$0;
        var switch$0=0;
        if(99 <= c$0)
         {if(111 === c$0)return scan_octal_int(store_char(width$0,ib,c$0),ib);
          if(120 === c$0)switch$0 = 1}
        else
         if(88 === c$0)
          switch$0 = 1;
         else
          if(98 <= c$0)return scan_binary_int(store_char(width$0,ib,c$0),ib);
        return switch$0
                ?scan_hexadecimal_int(store_char(width$0,ib,c$0),ib)
                :scan_decimal_digit_star(width$0,ib)}
      return scan_unsigned_decimal_int(width,ib)}
    function scan_optionally_signed_int(width,ib)
     {var width$0=scan_sign(width,ib);return scan_unsigned_int(width$0,ib)}
    function scan_int_conversion(conv,width,ib)
     {switch(conv)
       {case 0:return scan_binary_int(width,ib);
        case 1:return scan_optionally_signed_decimal(width,ib);
        case 2:return scan_optionally_signed_int(width,ib);
        case 3:return scan_octal_int(width,ib);
        case 4:return scan_unsigned_decimal_int(width,ib);
        default:return scan_hexadecimal_int(width,ib)}}
    function scan_fractional_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      return eof(ib)
              ?width
              :9 < c - 48 >>> 0
                ?width
                :scan_decimal_digit_star(store_char(width,ib,c),ib)}
    function scan_exponent_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(eof(ib))return width;
      if(69 !== c && 101 !== c)return width;
      return scan_optionally_signed_decimal(store_char(width,ib,c),ib)}
    function scan_integer_part(width,ib)
     {var width$0=scan_sign(width,ib);
      return scan_decimal_digit_star(width$0,ib)}
    function scan_float(width,precision,ib)
     {var width$0=scan_integer_part(width,ib);
      if(0 === width$0)return [0,width$0,precision];
      var c=peek_char(ib);
      if(eof(ib))return [0,width$0,precision];
      if(46 === c)
       {var
         width$1=store_char(width$0,ib,c),
         precision$0=min$0(width$1,precision),
         width$2=
          width$1
          -
          (precision$0 - scan_fractional_part(precision$0,ib) | 0)
          |
          0;
        return [0,scan_exponent_part(width$2,ib),precision$0]}
      return [0,scan_exponent_part(width$0,ib),precision]}
    function check_case_insensitive_string(width,ib,error,str)
     {function lowercase(c)
       {return 25 < c - 65 >>> 0?c:char_of_int((c - 65 | 0) + 97 | 0)}
      var
       len=caml_ml_string_length(str),
       width$0=[0,width],
       _a46_=len - 1 | 0,
       _a45_=0;
      if(! (_a46_ < 0))
       {var i=_a45_;
        for(;;)
         {var
           c=peek_char(ib),
           _a47_=caml_string_get(str,i),
           _a48_=lowercase(_a47_);
          if(lowercase(c) !== _a48_){var _a49_=0;caml_call1(error,_a49_)}
          if(0 === width$0[1]){var _a4__=0;caml_call1(error,_a4__)}
          var _a4$_=width$0[1];
          width$0[1] = store_char(_a4$_,ib,c);
          var _a5a_=i + 1 | 0;
          if(_a46_ !== i){var i=_a5a_;continue}
          break}}
      return width$0[1]}
    function scan_hex_float(width,precision,ib)
     {var _a4M_=0 === width?1:0,_a4N_=_a4M_ || end_of_input(ib);
      if(_a4N_){var _a4O_=0;bad_hex_float(_a4O_)}
      var
       width$0=scan_sign(width,ib),
       _a4P_=0 === width$0?1:0,
       _a4Q_=_a4P_ || end_of_input(ib);
      if(_a4Q_){var _a4R_=0;bad_hex_float(_a4R_)}
      var c=peek_char(ib),switch$0=0;
      if(78 <= c)
       {var switcher=c - 79 | 0;
        if(30 < switcher >>> 0)
         {if(! (32 <= switcher))
           {var
             width$1=store_char(width$0,ib,c),
             _a4S_=0 === width$1?1:0,
             _a4T_=_a4S_ || end_of_input(ib);
            if(_a4T_){var _a4U_=0;bad_hex_float(_a4U_)}
            return check_case_insensitive_string
                    (width$1,ib,bad_hex_float,_eC_)}}
        else
         if(26 === switcher)switch$0 = 1}
      else
       {if(48 === c)
         {var
           width$3=store_char(width$0,ib,c),
           _a4Y_=0 === width$3?1:0,
           _a4Z_=_a4Y_ || end_of_input(ib);
          if(_a4Z_){var _a40_=0;bad_hex_float(_a40_)}
          var
           width$4=
            check_case_insensitive_string(width$3,ib,bad_hex_float,_eE_);
          if(0 !== width$4 && ! end_of_input(ib))
           {var match=peek_char(ib),_a41_=match - 46 | 0,switch$1=0;
            if(34 < _a41_ >>> 0)
             {if(66 === _a41_)switch$1 = 1}
            else
             if(32 < _a41_ - 1 >>> 0)switch$1 = 1;
            var width$5=switch$1?width$4:scan_hexadecimal_int(width$4,ib);
            if(0 !== width$5 && ! end_of_input(ib))
             {var c$0=peek_char(ib);
              if(46 === c$0)
               {var width$6=store_char(width$5,ib,c$0),switch$2=0;
                if(0 !== width$6 && ! end_of_input(ib))
                 {var match$0=peek_char(ib),switch$3=0;
                  if(80 !== match$0 && 112 !== match$0)
                   {var
                     precision$0=min$0(width$6,precision),
                     width$10=
                      width$6
                      -
                      (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                      |
                      0;
                    switch$3 = 1}
                  if(! switch$3)var width$10=width$6;
                  var width$7=width$10;
                  switch$2 = 1}
                if(! switch$2)var width$7=width$6;
                var width$8=width$7}
              else
               var width$8=width$5;
              if(0 !== width$8 && ! end_of_input(ib))
               {var c$1=peek_char(ib);
                if(80 !== c$1 && 112 !== c$1)return width$8;
                var
                 width$9=store_char(width$8,ib,c$1),
                 _a42_=0 === width$9?1:0,
                 _a43_=_a42_ || end_of_input(ib);
                if(_a43_){var _a44_=0;bad_hex_float(_a44_)}
                return scan_optionally_signed_decimal(width$9,ib)}
              return width$8}
            return width$5}
          return width$4}
        if(73 === c)switch$0 = 1}
      if(switch$0)
       {var
         width$2=store_char(width$0,ib,c),
         _a4V_=0 === width$2?1:0,
         _a4W_=_a4V_ || end_of_input(ib);
        if(_a4W_){var _a4X_=0;bad_hex_float(_a4X_)}
        return check_case_insensitive_string(width$2,ib,bad_hex_float,_eD_)}
      return bad_hex_float(0)}
    function scan_caml_float_rest(width,precision,ib)
     {var _a4G_=0 === width?1:0,_a4H_=_a4G_ || end_of_input(ib);
      if(_a4H_){var _a4I_=0;bad_float(_a4I_)}
      var
       width$0=scan_decimal_digit_star(width,ib),
       _a4J_=0 === width$0?1:0,
       _a4K_=_a4J_ || end_of_input(ib);
      if(_a4K_){var _a4L_=0;bad_float(_a4L_)}
      var c=peek_char(ib),switcher=c - 69 | 0;
      if(32 < switcher >>> 0)
       {if(-23 === switcher)
         {var
           width$1=store_char(width$0,ib,c),
           precision$0=min$0(width$1,precision),
           width_precision=scan_fractional_part(precision$0,ib),
           frac_width=precision$0 - width_precision | 0,
           width$2=width$1 - frac_width | 0;
          return scan_exponent_part(width$2,ib)}}
      else
       if(30 < switcher - 1 >>> 0)return scan_exponent_part(width$0,ib);
      return bad_float(0)}
    function scan_caml_float(width,precision,ib)
     {var _a4k_=0 === width?1:0,_a4l_=_a4k_ || end_of_input(ib);
      if(_a4l_){var _a4m_=0;bad_float(_a4m_)}
      var
       width$0=scan_sign(width,ib),
       _a4n_=0 === width$0?1:0,
       _a4o_=_a4n_ || end_of_input(ib);
      if(_a4o_){var _a4p_=0;bad_float(_a4p_)}
      var c=peek_char(ib);
      if(49 <= c)
       {if(! (58 <= c))
         {var
           width$1=store_char(width$0,ib,c),
           _a4q_=0 === width$1?1:0,
           _a4r_=_a4q_ || end_of_input(ib);
          if(_a4r_){var _a4s_=0;bad_float(_a4s_)}
          return scan_caml_float_rest(width$1,precision,ib)}}
      else
       if(48 <= c)
        {var
          width$2=store_char(width$0,ib,c),
          _a4t_=0 === width$2?1:0,
          _a4u_=_a4t_ || end_of_input(ib);
         if(_a4u_){var _a4v_=0;bad_float(_a4v_)}
         var c$0=peek_char(ib);
         if(88 !== c$0 && 120 !== c$0)
          return scan_caml_float_rest(width$2,precision,ib);
         var
          width$3=store_char(width$2,ib,c$0),
          _a4w_=0 === width$3?1:0,
          _a4x_=_a4w_ || end_of_input(ib);
         if(_a4x_){var _a4y_=0;bad_float(_a4y_)}
         var
          width$4=scan_hexadecimal_int(width$3,ib),
          _a4z_=0 === width$4?1:0,
          _a4A_=_a4z_ || end_of_input(ib);
         if(_a4A_){var _a4B_=0;bad_float(_a4B_)}
         var c$1=peek_char(ib),switcher=c$1 - 80 | 0,switch$0=0;
         if(32 < switcher >>> 0)
          if(-34 === switcher)
           {var width$5=store_char(width$4,ib,c$1),switch$1=0;
            if(0 !== width$5 && ! end_of_input(ib))
             {var match=peek_char(ib),switch$2=0;
              if(80 !== match && 112 !== match)
               {var
                 precision$0=min$0(width$5,precision),
                 width$10=
                  width$5
                  -
                  (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                  |
                  0;
                switch$2 = 1}
              if(! switch$2)var width$10=width$5;
              var width$6=width$10;
              switch$1 = 1}
            if(! switch$1)var width$6=width$5;
            var width$7=width$6}
          else
           switch$0 = 1;
         else
          if(30 < switcher - 1 >>> 0)var width$7=width$4;else switch$0 = 1;
         if(switch$0)
          var _a4F_=0,width$8=bad_float(_a4F_);
         else
          var width$8=width$7;
         if(0 !== width$8 && ! end_of_input(ib))
          {var c$2=peek_char(ib);
           if(80 !== c$2 && 112 !== c$2)return width$8;
           var
            width$9=store_char(width$8,ib,c$2),
            _a4C_=0 === width$9?1:0,
            _a4D_=_a4C_ || end_of_input(ib);
           if(_a4D_){var _a4E_=0;bad_hex_float(_a4E_)}
           return scan_optionally_signed_decimal(width$9,ib)}
         return width$8}
      return bad_float(0)}
    function scan_string(stp,width,ib)
     {function loop(width)
       {var width$0=width;
        for(;;)
         {if(0 === width$0)return width$0;
          var c=peek_char(ib);
          if(eof(ib))return width$0;
          if(stp)
           {var c$0=stp[1];
            if(c === c$0)return skip_char(width$0,ib);
            var width$1=store_char(width$0,ib,c),width$0=width$1;
            continue}
          var _a4j_=c - 9 | 0,switch$0=0;
          if(4 < _a4j_ >>> 0)
           {if(23 === _a4j_)switch$0 = 1}
          else
           if(1 < _a4j_ - 2 >>> 0)switch$0 = 1;
          if(switch$0)return width$0;
          var width$2=store_char(width$0,ib,c),width$0=width$2;
          continue}}
      return loop(width)}
    function scan_char(width,ib)
     {return store_char(width,ib,checked_peek_char(ib))}
    function char_for_backslash(c)
     {if(110 <= c)
       {if(! (117 <= c))
         switch(c - 110 | 0)
          {case 0:return 10;case 4:return 13;case 6:return 9}}
      else
       if(98 === c)return 8;
      return c}
    function decimal_value_of_char(c){return c - 48 | 0}
    function char_for_decimal_code(c0,c1,c2)
     {var
       _a4h_=decimal_value_of_char(c2),
       _a4i_=10 * decimal_value_of_char(c1) | 0,
       c=((100 * decimal_value_of_char(c0) | 0) + _a4i_ | 0) + _a4h_ | 0;
      if(0 <= c && ! (255 < c))return char_of_int(c);
      return bad_input(caml_call3(sprintf(_eF_),c0,c1,c2))}
    function hexadecimal_value_of_char(d)
     {return 97 <= d?d - 87 | 0:65 <= d?d - 55 | 0:d - 48 | 0}
    function char_for_hexadecimal_code(c1,c2)
     {var
       _a4g_=hexadecimal_value_of_char(c2),
       c=(16 * hexadecimal_value_of_char(c1) | 0) + _a4g_ | 0;
      if(0 <= c && ! (255 < c))return char_of_int(c);
      return bad_input(caml_call2(sprintf(_eG_),c1,c2))}
    function check_next_char(message,width,ib)
     {if(0 === width)return bad_token_length(message);
      var c=peek_char(ib);
      return eof(ib)?bad_end_of_input(message):c}
    function check_next_char_for_char(_a4e_,_a4f_)
     {return check_next_char(_eH_,_a4e_,_a4f_)}
    function check_next_char_for_string(_a4c_,_a4d_)
     {return check_next_char(_eI_,_a4c_,_a4d_)}
    function scan_backslash_char(width,ib)
     {var c0=check_next_char_for_char(width,ib),switch$0=0;
      if(40 <= c0)
       {if(58 <= c0)
         {var switcher=c0 - 92 | 0;
          if(! (28 < switcher >>> 0))
           switch(switcher)
            {case 28:
              var
               get_digit=
                function(param)
                 {var c=next_char(ib),_a4b_=c - 48 | 0,switch$0=0;
                  if(22 < _a4b_ >>> 0)
                   {if(! (5 < _a4b_ - 49 >>> 0))switch$0 = 1}
                  else
                   if(6 < _a4b_ - 10 >>> 0)switch$0 = 1;
                  return switch$0?c:bad_input_escape(c)},
               _a39_=0,
               c1=get_digit(_a39_),
               _a3__=0,
               c2=get_digit(_a3__);
              return store_char
                      (width - 2 | 0,ib,char_for_hexadecimal_code(c1,c2));
             case 0:
             case 6:
             case 18:
             case 22:
             case 24:switch$0 = 1;break
             }}
        else
         if(48 <= c0)
          {var
            get_digit$0=
             function(param)
              {var c=next_char(ib);
               return 9 < c - 48 >>> 0?bad_input_escape(c):c},
            _a3$_=0,
            c1$0=get_digit$0(_a3$_),
            _a4a_=0,
            c2$0=get_digit$0(_a4a_);
           return store_char
                   (width - 2 | 0,ib,char_for_decimal_code(c0,c1$0,c2$0))}}
      else
       if(34 === c0 || 39 <= c0)switch$0 = 1;
      return switch$0
              ?store_char(width,ib,char_for_backslash(c0))
              :bad_input_escape(c0)}
    function scan_caml_char(width,ib)
     {function find_stop(width)
       {var c=check_next_char_for_char(width,ib);
        return 39 === c?ignore_char(width,ib):character_mismatch(39,c)}
      function find_char(width)
       {var c=check_next_char_for_char(width,ib);
        if(92 === c)
         {var _a38_=ignore_char(width,ib);
          return find_stop(scan_backslash_char(_a38_,ib))}
        return find_stop(store_char(width,ib,c))}
      function find_start(width)
       {var c=checked_peek_char(ib);
        return 39 === c
                ?find_char(ignore_char(width,ib))
                :character_mismatch(39,c)}
      return find_start(width)}
    function scan_caml_string(width,ib)
     {function find_stop$0(counter,width)
       {var width$0=width;
        for(;;)
         {var c=check_next_char_for_string(width$0,ib);
          if(34 === c)return ignore_char(width$0,ib);
          if(92 === c)
           {var _a37_=ignore_char(width$0,ib);
            if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return scan_backslash(counter$0,_a37_)}
            return caml_trampoline_return(scan_backslash,[0,_a37_])}
          var width$1=store_char(width$0,ib,c),width$0=width$1;
          continue}}
      function scan_backslash(counter,width)
       {var match=check_next_char_for_string(width,ib);
        if(10 === match)
         {var _a34_=ignore_char(width,ib);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return skip_spaces(counter$0,_a34_)}
          return caml_trampoline_return(skip_spaces,[0,_a34_])}
        if(13 === match)
         {var _a35_=ignore_char(width,ib);
          if(counter < 50)
           {var counter$1=counter + 1 | 0;
            return skip_newline(counter$1,_a35_)}
          return caml_trampoline_return(skip_newline,[0,_a35_])}
        var _a36_=scan_backslash_char(width,ib);
        if(counter < 50)
         {var counter$2=counter + 1 | 0;return find_stop$0(counter$2,_a36_)}
        return caml_trampoline_return(find_stop$0,[0,_a36_])}
      function skip_newline(counter,width)
       {var match=check_next_char_for_string(width,ib);
        if(10 === match)
         {var _a31_=ignore_char(width,ib);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return skip_spaces(counter$0,_a31_)}
          return caml_trampoline_return(skip_spaces,[0,_a31_])}
        var _a32_=13,_a33_=store_char(width,ib,_a32_);
        if(counter < 50)
         {var counter$1=counter + 1 | 0;return find_stop$0(counter$1,_a33_)}
        return caml_trampoline_return(find_stop$0,[0,_a33_])}
      function skip_spaces(counter,width)
       {var width$0=width;
        for(;;)
         {var match=check_next_char_for_string(width$0,ib);
          if(32 === match)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return find_stop$0(counter$0,width$0)}
          return caml_trampoline_return(find_stop$0,[0,width$0])}}
      function find_stop(width){return caml_trampoline(find_stop$0(0,width))}
      function find_start(width)
       {var c=checked_peek_char(ib);
        return 34 === c
                ?find_stop(ignore_char(width,ib))
                :character_mismatch(34,c)}
      return find_start(width)}
    function scan_bool(ib)
     {var c=checked_peek_char(ib);
      if(102 === c)
       var m=5;
      else
       if(116 === c)
        var m=4;
       else
        var _a30_=caml_call1(sprintf(_eJ_),c),m=bad_input(_a30_);
      return scan_string(0,m,ib)}
    function scan_chars_in_char_set(char_set,scan_indic,width,ib)
     {function scan_chars(i,stp)
       {var i$0=i;
        for(;;)
         {var c=peek_char(ib),_a3W_=0 < i$0?1:0;
          if(_a3W_)
           {var _a3X_=1 - eof(ib);
            if(_a3X_)
             var
              _a3Y_=is_in_char_set(char_set,c),
              _a3Z_=_a3Y_?c !== stp?1:0:_a3Y_;
            else
             var _a3Z_=_a3X_}
          else
           var _a3Z_=_a3W_;
          if(_a3Z_)
           {store_char(max_num,ib,c);var i$1=i$0 - 1 | 0,i$0=i$1;continue}
          return _a3Z_}}
      if(scan_indic)
       {var c=scan_indic[1];
        scan_chars(width,c);
        var _a3V_=1 - eof(ib);
        if(_a3V_)
         {var ci=peek_char(ib);
          return c === ci?invalidate_current_char(ib):character_mismatch(c,ci)}
        return _a3V_}
      return scan_chars(width,-1)}
    function scanf_bad_input(ib,x)
     {if(x[1] === Scan_failure)
       var s=x[2];
      else
       {if(x[1] !== Failure)throw x;var s=x[2]}
      var i=char_count(ib);
      return bad_input(caml_call2(sprintf(_eK_),i,s))}
    function get_counter(ib,counter)
     {switch(counter)
       {case 0:return line_count(ib);
        case 1:return char_count(ib);
        default:return token_count(ib)}}
    function width_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return width}return max_num}
    function stopper_of_formatting_lit(fmting)
     {if(6 === fmting)return _eL_;
      var
       str=string_of_formatting_lit(fmting),
       stp=caml_string_get(str,1),
       _a3T_=caml_ml_string_length(str) - 2 | 0,
       _a3U_=2,
       sub_str=sub$0(str,_a3U_,_a3T_);
      return [0,stp,sub_str]}
    function take_format_readers$0(counter,k,fmt)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k,0);
       else
        switch(fmt$0[0])
         {case 0:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 1:var fmt$2=fmt$0[1],fmt$0=fmt$2;continue;
          case 2:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 3:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 4:var fmt$5=fmt$0[4],fmt$0=fmt$5;continue;
          case 5:var fmt$6=fmt$0[4],fmt$0=fmt$6;continue;
          case 6:var fmt$7=fmt$0[4],fmt$0=fmt$7;continue;
          case 7:var fmt$8=fmt$0[4],fmt$0=fmt$8;continue;
          case 8:var fmt$9=fmt$0[4],fmt$0=fmt$9;continue;
          case 9:var fmt$10=fmt$0[2],fmt$0=fmt$10;continue;
          case 10:var fmt$11=fmt$0[1],fmt$0=fmt$11;continue;
          case 11:var fmt$12=fmt$0[2],fmt$0=fmt$12;continue;
          case 12:var fmt$13=fmt$0[2],fmt$0=fmt$13;continue;
          case 13:var fmt$14=fmt$0[3],fmt$0=fmt$14;continue;
          case 14:
           var
            rest=fmt$0[3],
            fmtty=fmt$0[2],
            _a3Q_=symm(fmtty),
            _a3R_=erase_rel(_a3Q_);
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return take_fmtty_format_readers$0(counter$1,k,_a3R_,rest)}
           return caml_trampoline_return
                   (take_fmtty_format_readers$0,[0,k,_a3R_,rest]);
          case 15:var fmt$15=fmt$0[1],fmt$0=fmt$15;continue;
          case 16:var fmt$16=fmt$0[1],fmt$0=fmt$16;continue;
          case 17:var fmt$17=fmt$0[2],fmt$0=fmt$17;continue;
          case 18:
           var _a3S_=fmt$0[1];
           if(0 === _a3S_[0])
            {var
              rest$0=fmt$0[2],
              match=_a3S_[1],
              fmt$18=match[1],
              fmt$19=concat_fmt(fmt$18,rest$0),
              fmt$0=fmt$19;
             continue}
           var
            rest$1=fmt$0[2],
            match$0=_a3S_[1],
            fmt$20=match$0[1],
            fmt$21=concat_fmt(fmt$20,rest$1),
            fmt$0=fmt$21;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_format_readers(new_k,fmt_rest)};
          case 20:var fmt$22=fmt$0[3],fmt$0=fmt$22;continue;
          case 21:var fmt$23=fmt$0[2],fmt$0=fmt$23;continue;
          case 22:var fmt$24=fmt$0[1],fmt$0=fmt$24;continue;
          case 23:
           var rest$2=fmt$0[2],ign=fmt$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return take_ignored_format_readers(counter$0,k,ign,rest$2)}
           return caml_trampoline_return
                   (take_ignored_format_readers,[0,k,ign,rest$2]);
          default:var fmt$25=fmt$0[3],fmt$0=fmt$25;continue}}
    function take_fmtty_format_readers$0(counter,k,fmtty,fmt)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        {if(counter < 50)
          {var counter$0=counter + 1 | 0;
           return take_format_readers$0(counter$0,k,fmt)}
         return caml_trampoline_return(take_format_readers$0,[0,k,fmt])}
       else
        switch(fmtty$0[0])
         {case 0:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 1:var fmtty$2=fmtty$0[1],fmtty$0=fmtty$2;continue;
          case 2:var fmtty$3=fmtty$0[1],fmtty$0=fmtty$3;continue;
          case 3:var fmtty$4=fmtty$0[1],fmtty$0=fmtty$4;continue;
          case 4:var fmtty$5=fmtty$0[1],fmtty$0=fmtty$5;continue;
          case 5:var fmtty$6=fmtty$0[1],fmtty$0=fmtty$6;continue;
          case 6:var fmtty$7=fmtty$0[1],fmtty$0=fmtty$7;continue;
          case 7:var fmtty$8=fmtty$0[1],fmtty$0=fmtty$8;continue;
          case 8:var fmtty$9=fmtty$0[2],fmtty$0=fmtty$9;continue;
          case 9:
           var
            rest=fmtty$0[3],
            ty2=fmtty$0[2],
            ty1=fmtty$0[1],
            _a3P_=symm(ty1),
            ty=trans(_a3P_,ty2),
            fmtty$10=concat_fmtty(ty,rest),
            fmtty$0=fmtty$10;
           continue;
          case 10:var fmtty$11=fmtty$0[1],fmtty$0=fmtty$11;continue;
          case 11:var fmtty$12=fmtty$0[1],fmtty$0=fmtty$12;continue;
          case 12:var fmtty$13=fmtty$0[1],fmtty$0=fmtty$13;continue;
          case 13:
           var fmt_rest=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest,fmt)};
          default:
           var fmt_rest$0=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest$0,fmt)}}}
    function take_ignored_format_readers(counter,k,ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:
          if(counter < 50)
           {var counter$1=counter + 1 | 0;
            return take_format_readers$0(counter$1,k,fmt)}
          return caml_trampoline_return(take_format_readers$0,[0,k,fmt]);
         case 1:
          if(counter < 50)
           {var counter$2=counter + 1 | 0;
            return take_format_readers$0(counter$2,k,fmt)}
          return caml_trampoline_return(take_format_readers$0,[0,k,fmt]);
         case 2:
          return function(reader)
           {function new_k(readers_rest)
             {return caml_call1(k,[0,reader,readers_rest])}
            return take_format_readers(new_k,fmt)};
         default:
          if(counter < 50)
           {var counter$3=counter + 1 | 0;
            return take_format_readers$0(counter$3,k,fmt)}
          return caml_trampoline_return(take_format_readers$0,[0,k,fmt])}
      else
       switch(ign[0])
        {case 0:
          if(counter < 50)
           {var counter$4=counter + 1 | 0;
            return take_format_readers$0(counter$4,k,fmt)}
          return caml_trampoline_return(take_format_readers$0,[0,k,fmt]);
         case 1:
          if(counter < 50)
           {var counter$5=counter + 1 | 0;
            return take_format_readers$0(counter$5,k,fmt)}
          return caml_trampoline_return(take_format_readers$0,[0,k,fmt]);
         case 2:
          if(counter < 50)
           {var counter$6=counter + 1 | 0;
            return take_format_readers$0(counter$6,k,fmt)}
          return caml_trampoline_return(take_format_readers$0,[0,k,fmt]);
         case 3:
          if(counter < 50)
           {var counter$7=counter + 1 | 0;
            return take_format_readers$0(counter$7,k,fmt)}
          return caml_trampoline_return(take_format_readers$0,[0,k,fmt]);
         case 4:
          if(counter < 50)
           {var counter$8=counter + 1 | 0;
            return take_format_readers$0(counter$8,k,fmt)}
          return caml_trampoline_return(take_format_readers$0,[0,k,fmt]);
         case 5:
          if(counter < 50)
           {var counter$9=counter + 1 | 0;
            return take_format_readers$0(counter$9,k,fmt)}
          return caml_trampoline_return(take_format_readers$0,[0,k,fmt]);
         case 6:
          if(counter < 50)
           {var counter$10=counter + 1 | 0;
            return take_format_readers$0(counter$10,k,fmt)}
          return caml_trampoline_return(take_format_readers$0,[0,k,fmt]);
         case 7:
          if(counter < 50)
           {var counter$11=counter + 1 | 0;
            return take_format_readers$0(counter$11,k,fmt)}
          return caml_trampoline_return(take_format_readers$0,[0,k,fmt]);
         case 8:
          if(counter < 50)
           {var counter$12=counter + 1 | 0;
            return take_format_readers$0(counter$12,k,fmt)}
          return caml_trampoline_return(take_format_readers$0,[0,k,fmt]);
         case 9:
          var fmtty=ign[2];
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return take_fmtty_format_readers$0(counter$0,k,fmtty,fmt)}
          return caml_trampoline_return
                  (take_fmtty_format_readers$0,[0,k,fmtty,fmt]);
         case 10:
          if(counter < 50)
           {var counter$13=counter + 1 | 0;
            return take_format_readers$0(counter$13,k,fmt)}
          return caml_trampoline_return(take_format_readers$0,[0,k,fmt]);
         default:
          if(counter < 50)
           {var counter$14=counter + 1 | 0;
            return take_format_readers$0(counter$14,k,fmt)}
          return caml_trampoline_return(take_format_readers$0,[0,k,fmt])}}
    function take_format_readers(k,fmt)
     {return caml_trampoline(take_format_readers$0(0,k,fmt))}
    function take_fmtty_format_readers(k,fmtty,fmt)
     {return caml_trampoline(take_fmtty_format_readers$0(0,k,fmtty,fmt))}
    function make_scanf(ib,fmt,readers)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return 0;
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1],_a29_=0;
           scan_char(_a29_,ib);
           var c=token_char(ib);
           return [0,c,make_scanf(ib,rest,readers)];
          case 1:
           var rest$0=fmt$0[1],_a2__=0;
           scan_caml_char(_a2__,ib);
           var c$0=token_char(ib);
           return [0,c$0,make_scanf(ib,rest$0,readers)];
          case 2:
           var _a2$_=fmt$0[1],_a3a_=fmt$0[2];
           if(typeof _a3a_ !== "number")
            switch(_a3a_[0])
             {case 17:
               var
                rest$2=_a3a_[2],
                fmting_lit=_a3a_[1],
                match=stopper_of_formatting_lit(fmting_lit),
                str=match[2],
                stp=match[1],
                scan$0=
                 function(width,param,ib)
                  {return scan_string([0,stp],width,ib)},
                str_rest=[11,str,rest$2];
               return pad_prec_scanf
                       (ib,str_rest,readers,_a2$_,0,scan$0,token_string);
              case 18:
               var _a3b_=_a3a_[1];
               if(0 === _a3b_[0])
                {var
                  rest$3=_a3a_[2],
                  match$0=_a3b_[1],
                  fmt$1=match$0[1],
                  scan$1=
                   function(width,param,ib){return scan_string(_eM_,width,ib)},
                  _a3c_=0;
                 return pad_prec_scanf
                         (ib,
                          concat_fmt(fmt$1,rest$3),
                          readers,
                          _a2$_,
                          _a3c_,
                          scan$1,
                          token_string)}
               var
                rest$4=_a3a_[2],
                match$1=_a3b_[1],
                fmt$2=match$1[1],
                scan$2=
                 function(width,param,ib){return scan_string(_eN_,width,ib)},
                _a3d_=0;
               return pad_prec_scanf
                       (ib,
                        concat_fmt(fmt$2,rest$4),
                        readers,
                        _a2$_,
                        _a3d_,
                        scan$2,
                        token_string)
              }
           var
            rest$1=fmt$0[2],
            scan=function(width,param,ib){return scan_string(0,width,ib)};
           return pad_prec_scanf(ib,rest$1,readers,_a2$_,0,scan,token_string);
          case 3:
           var
            rest$5=fmt$0[2],
            pad=fmt$0[1],
            scan$3=function(width,param,ib){return scan_caml_string(width,ib)};
           return pad_prec_scanf(ib,rest$5,readers,pad,0,scan$3,token_string);
          case 4:
           var
            rest$6=fmt$0[4],
            prec=fmt$0[3],
            pad$0=fmt$0[2],
            iconv=fmt$0[1],
            _a3e_=char_of_iconv(iconv),
            c$1=integer_conversion_of_char(_a3e_),
            scan$4=
             function(width,param,ib)
              {return scan_int_conversion(c$1,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$6,
                    readers,
                    pad$0,
                    prec,
                    scan$4,
                    function(_a3O_){return token_int(c$1,_a3O_)});
          case 5:
           var
            rest$7=fmt$0[4],
            prec$0=fmt$0[3],
            pad$1=fmt$0[2],
            iconv$0=fmt$0[1],
            _a3f_=char_of_iconv(iconv$0),
            c$2=integer_conversion_of_char(_a3f_),
            scan$5=
             function(width,param,ib)
              {return scan_int_conversion(c$2,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$7,
                    readers,
                    pad$1,
                    prec$0,
                    scan$5,
                    function(_a3N_){return token_int32(c$2,_a3N_)});
          case 6:
           var
            rest$8=fmt$0[4],
            prec$1=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$1=fmt$0[1],
            _a3g_=char_of_iconv(iconv$1),
            c$3=integer_conversion_of_char(_a3g_),
            scan$6=
             function(width,param,ib)
              {return scan_int_conversion(c$3,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$8,
                    readers,
                    pad$2,
                    prec$1,
                    scan$6,
                    function(_a3M_){return token_nativeint(c$3,_a3M_)});
          case 7:
           var
            rest$9=fmt$0[4],
            prec$2=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$2=fmt$0[1],
            _a3h_=char_of_iconv(iconv$2),
            c$4=integer_conversion_of_char(_a3h_),
            scan$7=
             function(width,param,ib)
              {return scan_int_conversion(c$4,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$9,
                    readers,
                    pad$3,
                    prec$2,
                    scan$7,
                    function(_a3L_){return token_int64(c$4,_a3L_)});
          case 8:
           switch(fmt$0[1][2])
            {case 5:
             case 8:
              var rest$11=fmt$0[4],prec$4=fmt$0[3],pad$5=fmt$0[2];
              return pad_prec_scanf
                      (ib,
                       rest$11,
                       readers,
                       pad$5,
                       prec$4,
                       scan_caml_float,
                       token_float);
             case 6:
             case 7:
              var rest$12=fmt$0[4],prec$5=fmt$0[3],pad$6=fmt$0[2];
              return pad_prec_scanf
                      (ib,rest$12,readers,pad$6,prec$5,scan_hex_float,token_float);
             default:
              var rest$10=fmt$0[4],prec$3=fmt$0[3],pad$4=fmt$0[2];
              return pad_prec_scanf
                      (ib,rest$10,readers,pad$4,prec$3,scan_float,token_float)}
          case 9:
           var
            rest$13=fmt$0[2],
            pad$7=fmt$0[1],
            scan$8=function(param,_a3K_,ib){return scan_bool(ib)};
           return pad_prec_scanf(ib,rest$13,readers,pad$7,0,scan$8,token_bool);
          case 10:
           var rest$14=fmt$0[1];
           if(end_of_input(ib)){var fmt$0=rest$14;continue}
           return bad_input(_eO_);
          case 11:
           var
            rest$15=fmt$0[2],
            str$0=fmt$0[1],
            _a3i_=function(_a3J_){return check_char(ib,_a3J_)};
           iter$1(_a3i_,str$0);
           var fmt$0=rest$15;
           continue;
          case 12:
           var rest$16=fmt$0[2],chr=fmt$0[1];
           check_char(ib,chr);
           var fmt$0=rest$16;
           continue;
          case 13:
           var
            rest$17=fmt$0[3],
            fmtty=fmt$0[2],
            pad_opt=fmt$0[1],
            _a3j_=width_of_pad_opt(pad_opt);
           scan_caml_string(_a3j_,ib);
           var s=token_string(ib);
           try
            {var _a3l_=format_of_string_fmtty(s,fmtty),fmt$3=_a3l_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var msg=exn[2],_a3k_=bad_input(msg),fmt$3=_a3k_}
           return [0,fmt$3,make_scanf(ib,rest$17,readers)];
          case 14:
           var
            rest$18=fmt$0[3],
            fmtty$0=fmt$0[2],
            pad_opt$0=fmt$0[1],
            _a3m_=width_of_pad_opt(pad_opt$0);
           scan_caml_string(_a3m_,ib);
           var s$0=token_string(ib);
           try
            {var
              _a3r_=0,
              match$2=fmt_ebb_of_string(_a3r_,s$0),
              fmt$6=match$2[1],
              _a3s_=0,
              match$3=fmt_ebb_of_string(_a3s_,s$0),
              fmt$7=match$3[1],
              _a3t_=symm(fmtty$0),
              _a3u_=erase_rel(_a3t_),
              fmt$8=type_format(fmt$7,_a3u_),
              _a3v_=erase_rel(fmtty$0),
              _a3w_=type_format(fmt$6,_a3v_),
              fmt$5=fmt$8,
              fmt$4=_a3w_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var
              msg$0=exn[2],
              _a3n_=bad_input(msg$0),
              _a3o_=_a3n_[2],
              _a3p_=_a3n_[1],
              fmt$5=_a3o_,
              fmt$4=_a3p_}
           var _a3q_=concat_fmt(fmt$5,rest$18);
           return [0,[0,fmt$4,s$0],make_scanf(ib,_a3q_,readers)];
          case 15:return invalid_arg(_eP_);
          case 16:return invalid_arg(_eQ_);
          case 17:
           var
            rest$19=fmt$0[2],
            formatting_lit=fmt$0[1],
            _a3x_=string_of_formatting_lit(formatting_lit),
            _a3y_=function(_a3I_){return check_char(ib,_a3I_)};
           iter$1(_a3y_,_a3x_);
           var fmt$0=rest$19;
           continue;
          case 18:
           var _a3z_=fmt$0[1];
           if(0 === _a3z_[0])
            {var rest$20=fmt$0[2],match$4=_a3z_[1],fmt$9=match$4[1],_a3A_=64;
             check_char(ib,_a3A_);
             var _a3B_=123;
             check_char(ib,_a3B_);
             var fmt$10=concat_fmt(fmt$9,rest$20),fmt$0=fmt$10;
             continue}
           var rest$21=fmt$0[2],match$5=_a3z_[1],fmt$11=match$5[1],_a3C_=64;
           check_char(ib,_a3C_);
           var _a3D_=91;
           check_char(ib,_a3D_);
           var fmt$12=concat_fmt(fmt$11,rest$21),fmt$0=fmt$12;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           if(readers)
            {var
              readers_rest=readers[2],
              reader=readers[1],
              x=caml_call1(reader,ib);
             return [0,x,make_scanf(ib,fmt_rest,readers_rest)]}
           return invalid_arg(_eR_);
          case 20:
           var _a3E_=fmt$0[1],_a3F_=fmt$0[3];
           if(typeof _a3F_ !== "number" && 17 === _a3F_[0])
            {var
              rest$23=_a3F_[2],
              fmting_lit$0=_a3F_[1],
              char_set$0=fmt$0[2],
              match$6=stopper_of_formatting_lit(fmting_lit$0),
              str$1=match$6[2],
              stp$0=match$6[1],
              width$0=width_of_pad_opt(_a3E_),
              _a3H_=[0,stp$0];
             scan_chars_in_char_set(char_set$0,_a3H_,width$0,ib);
             var s$2=token_string(ib),str_rest$0=[11,str$1,rest$23];
             return [0,s$2,make_scanf(ib,str_rest$0,readers)]}
           var
            rest$22=fmt$0[3],
            char_set=fmt$0[2],
            width=width_of_pad_opt(_a3E_),
            _a3G_=0;
           scan_chars_in_char_set(char_set,_a3G_,width,ib);
           var s$1=token_string(ib);
           return [0,s$1,make_scanf(ib,rest$22,readers)];
          case 21:
           var
            rest$24=fmt$0[2],
            counter=fmt$0[1],
            count=get_counter(ib,counter);
           return [0,count,make_scanf(ib,rest$24,readers)];
          case 22:
           var rest$25=fmt$0[1],c$5=checked_peek_char(ib);
           return [0,c$5,make_scanf(ib,rest$25,readers)];
          case 23:
           var
            rest$26=fmt$0[2],
            ign=fmt$0[1],
            match$7=param_format_of_ignored_format(ign,rest$26),
            fmt$13=match$7[1],
            match$8=make_scanf(ib,fmt$13,readers);
           if(match$8){var arg_rest=match$8[2];return arg_rest}
           throw [0,Assert_failure,_eS_];
          default:return invalid_arg(_eT_)}}
    function pad_prec_scanf(ib,fmt,readers,pad,prec,scan,token)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(prec)return invalid_arg(_eU_);
          caml_call3(scan,max_num,max_num,ib);
          var x=caml_call1(token,ib);
          return [0,x,make_scanf(ib,fmt,readers)]}
        var p=prec[1];
        caml_call3(scan,max_num,p,ib);
        var x$0=caml_call1(token,ib);
        return [0,x$0,make_scanf(ib,fmt,readers)]}
      else
       {if(0 === pad[0])
         {if(pad[1])
           {var _a28_=pad[2];
            if(typeof prec === "number")
             {if(prec)return invalid_arg(_eV_);
              caml_call3(scan,_a28_,max_num,ib);
              var x$1=caml_call1(token,ib);
              return [0,x$1,make_scanf(ib,fmt,readers)]}
            var p$0=prec[1];
            caml_call3(scan,_a28_,p$0,ib);
            var x$2=caml_call1(token,ib);
            return [0,x$2,make_scanf(ib,fmt,readers)]}
          return invalid_arg(_eW_)}
        return invalid_arg(_eX_)}}
    function kscanf(ib,ef,param)
     {var str=param[2],fmt=param[1];
      function apply(f,args)
       {var f$0=f,args$0=args;
        for(;;)
         {if(args$0)
           {var
             r=args$0[2],
             x=args$0[1],
             f$1=caml_call1(f$0,x),
             f$0=f$1,
             args$0=r;
            continue}
          return f$0}}
      function k(readers,f)
       {reset_token(ib);
        try
         {var _a27_=[0,make_scanf(ib,fmt,readers)],_a21_=_a27_}
        catch(exc)
         {exc = caml_wrap_exception(exc);
          var switch$0=0;
          if
           (exc[1]
            !==
            Scan_failure
            &&
            exc[1]
            !==
            Failure
            &&
            exc
            !==
            End_of_file)
           {if(exc[1] !== Invalid_argument)throw exc;
            var
             msg=exc[2],
             _a22_=escaped$1(str),
             _a23_=cat(_a22_,_eY_),
             _a24_=cat(_eZ_,_a23_),
             _a25_=cat(msg,_a24_),
             _a26_=invalid_arg(_a25_),
             _a20_=_a26_;
            switch$0 = 1}
          if(! switch$0)var _a20_=[1,exc];
          var _a21_=_a20_}
        if(0 === _a21_[0]){var args=_a21_[1];return apply(f,args)}
        var exc=_a21_[1];
        return caml_call2(ef,ib,exc)}
      return take_format_readers(k,fmt)}
    function sscanf(s,fmt)
     {return kscanf(from_string$0(s),scanf_bad_input,fmt)}
    function register_exception(name,exn)
     {if(caml_obj_tag(exn) === 248)
       var slot=exn;
      else
       var _a2Z_=0,slot=exn[1 + _a2Z_];
      return caml_register_named_value(name,slot)}
    var initial_object_size=2;
    function public_method_label(s)
     {var accu=[0,0],_a2W_=caml_ml_string_length(s) - 1 | 0,_a2V_=0;
      if(! (_a2W_ < 0))
       {var i=_a2V_;
        for(;;)
         {var _a2X_=caml_string_get(s,i);
          accu[1] = (223 * accu[1] | 0) + _a2X_ | 0;
          var _a2Y_=i + 1 | 0;
          if(_a2W_ !== i){var i=_a2Y_;continue}
          break}}
      accu[1] = accu[1] & 2147483647;
      var tag=1073741823 < accu[1]?accu[1] + 2147483648 | 0:accu[1];
      return tag}
    function compare$4(x,y){return caml_string_compare(x,y)}
    var Vars=_af_([0,compare$4]);
    function compare$5(x,y){return caml_string_compare(x,y)}
    var Meths=_af_([0,compare$5]);
    function compare$6(x,y){return caml_int_compare(x,y)}
    var
     Labs=_af_([0,compare$6]),
     table_count=[0,0],
     dummy_met=caml_obj_block(0,0);
    function fit_size(n)
     {if(2 < n){var _a2U_=(n + 1 | 0) / 2 | 0;return fit_size(_a2U_) * 2 | 0}
      return n}
    function new_table(pub_labels)
     {table_count[1]++;
      var
       len=pub_labels.length - 1,
       _a2L_=(len * 2 | 0) + 2 | 0,
       methods=caml_make_vect(_a2L_,dummy_met),
       _a2M_=0;
      caml_check_bound(methods,0)[1 + _a2M_] = len;
      var _a2N_=((fit_size(len) * 32 | 0) / 8 | 0) - 1 | 0,_a2O_=1;
      caml_check_bound(methods,1)[1 + _a2O_] = _a2N_;
      var _a2Q_=len - 1 | 0,_a2P_=0;
      if(! (_a2Q_ < 0))
       {var i=_a2P_;
        for(;;)
         {var
           _a2S_=(i * 2 | 0) + 3 | 0,
           _a2R_=caml_check_bound(pub_labels,i)[1 + i];
          caml_check_bound(methods,_a2S_)[1 + _a2S_] = _a2R_;
          var _a2T_=i + 1 | 0;
          if(_a2Q_ !== i){var i=_a2T_;continue}
          break}}
      return [0,initial_object_size,methods,Meths[1],Labs[1],0,0,Vars[1],0]}
    function resize$1(array,new_size)
     {var old_size=array[2].length - 1,_a2G_=old_size < new_size?1:0;
      if(_a2G_)
       {var
         new_buck=caml_make_vect(new_size,dummy_met),
         _a2H_=0,
         _a2I_=0,
         _a2J_=array[2];
        blit$1(_a2J_,_a2I_,new_buck,_a2H_,old_size);
        array[2] = new_buck;
        var _a2K_=0}
      else
       var _a2K_=_a2G_;
      return _a2K_}
    function put(array,label,element)
     {var _a2E_=label + 1 | 0;
      resize$1(array,_a2E_);
      var _a2F_=array[2];
      caml_check_bound(_a2F_,label)[1 + label] = element;
      return 0}
    var method_count=[0,0],inst_var_count=[0,0];
    function new_method(table)
     {var index=table[2].length - 1,_a2D_=index + 1 | 0;
      resize$1(table,_a2D_);
      return index}
    function get_method_label(table,name)
     {try
       {var _a2z_=table[3],_a2A_=Meths[28],_a2B_=caml_call2(_a2A_,name,_a2z_);
        return _a2B_}
      catch(_a2C_)
       {_a2C_ = caml_wrap_exception(_a2C_);
        if(_a2C_ === Not_found)
         {var label=new_method(table),_a2u_=table[3],_a2v_=Meths[4];
          table[3] = caml_call3(_a2v_,name,label,_a2u_);
          var _a2w_=table[4],_a2x_=1,_a2y_=Labs[4];
          table[4] = caml_call3(_a2y_,label,_a2x_,_a2w_);
          return label}
        throw _a2C_}}
    function get_method_labels(table,names)
     {return map$2
              (function(_a2t_){return get_method_label(table,_a2t_)},names)}
    function set_method(table,label,element)
     {method_count[1]++;
      var _a2r_=table[4],_a2s_=Labs[28];
      return caml_call2(_a2s_,label,_a2r_)
              ?put(table,label,element)
              :(table[6] = [0,[0,label,element],table[6]],0)}
    function new_slot(table)
     {var index=table[1];table[1] = index + 1 | 0;return index}
    function new_variable(table,name)
     {try
       {var _a2n_=table[7],_a2o_=Vars[28],_a2p_=caml_call2(_a2o_,name,_a2n_);
        return _a2p_}
      catch(_a2q_)
       {_a2q_ = caml_wrap_exception(_a2q_);
        if(_a2q_ === Not_found)
         {var index=new_slot(table);
          if(caml_string_notequal(name,_e0_))
           {var _a2l_=table[7],_a2m_=Vars[4];
            table[7] = caml_call3(_a2m_,name,index,_a2l_)}
          return index}
        throw _a2q_}}
    function create_table(public_methods)
     {if(0 === public_methods)return new_table([0]);
      var
       tags=map$2(public_method_label,public_methods),
       table=new_table(tags);
      function _a2f_(i,met)
       {var lab=(i * 2 | 0) + 2 | 0,_a2g_=table[3],_a2h_=Meths[4];
        table[3] = caml_call3(_a2h_,met,lab,_a2g_);
        var _a2i_=table[4],_a2j_=1,_a2k_=Labs[4];
        table[4] = caml_call3(_a2k_,lab,_a2j_,_a2i_);
        return 0}
      iteri(_a2f_,public_methods);
      return table}
    function init_class(table)
     {inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
      var _a2c_=table[8];
      table[8] = rev(_a2c_);
      var _a2d_=1,_a2e_=table[2];
      return resize$1
              (table,
               3
               +
               ((caml_check_bound(_a2e_,1)[1 + _a2d_] * 16 | 0) / 32 | 0)
               |
               0)}
    function make_class(pub_meths,class_init)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      var _a2a_=0,_a2b_=0;
      return [0,caml_call1(env_init,_a2b_),class_init,env_init,_a2a_]}
    function create_object_opt(obj_0,table)
     {if(obj_0)return obj_0;
      var _a19_=table[1],obj=caml_obj_block(248,_a19_),_a1__=table[2],_a1$_=0;
      obj[1 + _a1$_] = _a1__;
      return caml_set_oo_id(obj)}
    function get_const(x){return function(obj){return x}}
    function get_var(n){return function(obj){return obj[1 + n]}}
    function get_env(e,n){return function(obj){return obj[1 + e][1 + n]}}
    function get_meth(n)
     {return function(obj){return caml_call1(obj[1][1 + n],obj)}}
    function set_var(n){return function(obj,x){obj[1 + n] = x;return 0}}
    function app_const(f,x){return function(obj){return caml_call1(f,x)}}
    function app_var(f,n)
     {return function(obj){return caml_call1(f,obj[1 + n])}}
    function app_env(f,e,n)
     {return function(obj){return caml_call1(f,obj[1 + e][1 + n])}}
    function app_meth(f,n)
     {return function(obj)
       {var _a18_=obj[1][1 + n];return caml_call1(f,caml_call1(_a18_,obj))}}
    function app_const_const(f,x,y)
     {return function(obj){return caml_call2(f,x,y)}}
    function app_const_var(f,x,n)
     {return function(obj){return caml_call2(f,x,obj[1 + n])}}
    function app_const_meth(f,x,n)
     {return function(obj)
       {var _a17_=obj[1][1 + n];return caml_call2(f,x,caml_call1(_a17_,obj))}}
    function app_var_const(f,n,x)
     {return function(obj){return caml_call2(f,obj[1 + n],x)}}
    function app_meth_const(f,n,x)
     {return function(obj)
       {var _a16_=obj[1][1 + n];return caml_call2(f,caml_call1(_a16_,obj),x)}}
    function app_const_env(f,x,e,n)
     {return function(obj){return caml_call2(f,x,obj[1 + e][1 + n])}}
    function app_env_const(f,e,n,x)
     {return function(obj){return caml_call2(f,obj[1 + e][1 + n],x)}}
    function meth_app_const(n,x)
     {return function(obj){return caml_call2(obj[1][1 + n],obj,x)}}
    function meth_app_var(n,m)
     {return function(obj){return caml_call2(obj[1][1 + n],obj,obj[1 + m])}}
    function meth_app_env(n,e,m)
     {return function(obj)
       {return caml_call2(obj[1][1 + n],obj,obj[1 + e][1 + m])}}
    function meth_app_meth(n,m)
     {return function(obj)
       {var _a14_=obj[1][1 + m],_a15_=caml_call1(_a14_,obj);
        return caml_call2(obj[1][1 + n],obj,_a15_)}}
    function send_const(m,x,c)
     {return function(obj){return caml_call1(caml_get_public_method(x,m,0),x)}}
    function send_var(m,n,c)
     {return function(obj)
       {var _a13_=obj[1 + n];
        return caml_call1(caml_get_public_method(_a13_,m,0),_a13_)}}
    function send_env(m,e,n,c)
     {return function(obj)
       {var _a12_=obj[1 + e][1 + n];
        return caml_call1(caml_get_public_method(_a12_,m,0),_a12_)}}
    function send_meth(m,n,c)
     {return function(obj)
       {var _a10_=obj[1][1 + n],_a11_=caml_call1(_a10_,obj);
        return caml_call1(caml_get_public_method(_a11_,m,0),_a11_)}}
    function new_cache(table)
     {var n=new_method(table),switch$0=0;
      if(0 !== (n % 2 | 0))
       {var _a1Y_=1,_a1Z_=table[2];
        if
         (!
          ((2
            +
            ((caml_check_bound(_a1Z_,1)[1 + _a1Y_] * 16 | 0) / 32 | 0)
            |
            0)
           <
           n))
         {var n$0=new_method(table);switch$0 = 1}}
      if(! switch$0)var n$0=n;
      var _a1W_=0,_a1X_=table[2];
      caml_check_bound(_a1X_,n$0)[1 + n$0] = _a1W_;
      return n$0}
    function method_impl(table,i,arr)
     {function next(param)
       {i[1]++;var _a1V_=i[1];return caml_check_bound(arr,_a1V_)[1 + _a1V_]}
      var _a02_=0,clo=next(_a02_);
      if(typeof clo === "number")
       switch(clo)
        {case 0:var _a03_=0,x=next(_a03_);return get_const(x);
         case 1:var _a04_=0,n=next(_a04_);return get_var(n);
         case 2:
          var _a05_=0,e=next(_a05_),_a06_=0,n$0=next(_a06_);
          return get_env(e,n$0);
         case 3:var _a07_=0,n$1=next(_a07_);return get_meth(n$1);
         case 4:var _a08_=0,n$2=next(_a08_);return set_var(n$2);
         case 5:
          var _a09_=0,f=next(_a09_),_a0__=0,x$0=next(_a0__);
          return app_const(f,x$0);
         case 6:
          var _a0$_=0,f$0=next(_a0$_),_a1a_=0,n$3=next(_a1a_);
          return app_var(f$0,n$3);
         case 7:
          var
           _a1b_=0,
           f$1=next(_a1b_),
           _a1c_=0,
           e$0=next(_a1c_),
           _a1d_=0,
           n$4=next(_a1d_);
          return app_env(f$1,e$0,n$4);
         case 8:
          var _a1e_=0,f$2=next(_a1e_),_a1f_=0,n$5=next(_a1f_);
          return app_meth(f$2,n$5);
         case 9:
          var
           _a1g_=0,
           f$3=next(_a1g_),
           _a1h_=0,
           x$1=next(_a1h_),
           _a1i_=0,
           y=next(_a1i_);
          return app_const_const(f$3,x$1,y);
         case 10:
          var
           _a1j_=0,
           f$4=next(_a1j_),
           _a1k_=0,
           x$2=next(_a1k_),
           _a1l_=0,
           n$6=next(_a1l_);
          return app_const_var(f$4,x$2,n$6);
         case 11:
          var
           _a1m_=0,
           f$5=next(_a1m_),
           _a1n_=0,
           x$3=next(_a1n_),
           _a1o_=0,
           e$1=next(_a1o_),
           _a1p_=0,
           n$7=next(_a1p_);
          return app_const_env(f$5,x$3,e$1,n$7);
         case 12:
          var
           _a1q_=0,
           f$6=next(_a1q_),
           _a1r_=0,
           x$4=next(_a1r_),
           _a1s_=0,
           n$8=next(_a1s_);
          return app_const_meth(f$6,x$4,n$8);
         case 13:
          var
           _a1t_=0,
           f$7=next(_a1t_),
           _a1u_=0,
           n$9=next(_a1u_),
           _a1v_=0,
           x$5=next(_a1v_);
          return app_var_const(f$7,n$9,x$5);
         case 14:
          var
           _a1w_=0,
           f$8=next(_a1w_),
           _a1x_=0,
           e$2=next(_a1x_),
           _a1y_=0,
           n$10=next(_a1y_),
           _a1z_=0,
           x$6=next(_a1z_);
          return app_env_const(f$8,e$2,n$10,x$6);
         case 15:
          var
           _a1A_=0,
           f$9=next(_a1A_),
           _a1B_=0,
           n$11=next(_a1B_),
           _a1C_=0,
           x$7=next(_a1C_);
          return app_meth_const(f$9,n$11,x$7);
         case 16:
          var _a1D_=0,n$12=next(_a1D_),_a1E_=0,x$8=next(_a1E_);
          return meth_app_const(n$12,x$8);
         case 17:
          var _a1F_=0,n$13=next(_a1F_),_a1G_=0,m=next(_a1G_);
          return meth_app_var(n$13,m);
         case 18:
          var
           _a1H_=0,
           n$14=next(_a1H_),
           _a1I_=0,
           e$3=next(_a1I_),
           _a1J_=0,
           m$0=next(_a1J_);
          return meth_app_env(n$14,e$3,m$0);
         case 19:
          var _a1K_=0,n$15=next(_a1K_),_a1L_=0,m$1=next(_a1L_);
          return meth_app_meth(n$15,m$1);
         case 20:
          var _a1M_=0,m$2=next(_a1M_),_a1N_=0,x$9=next(_a1N_);
          return send_const(m$2,x$9,new_cache(table));
         case 21:
          var _a1O_=0,m$3=next(_a1O_),_a1P_=0,n$16=next(_a1P_);
          return send_var(m$3,n$16,new_cache(table));
         case 22:
          var
           _a1Q_=0,
           m$4=next(_a1Q_),
           _a1R_=0,
           e$4=next(_a1R_),
           _a1S_=0,
           n$17=next(_a1S_);
          return send_env(m$4,e$4,n$17,new_cache(table));
         default:
          var _a1T_=0,m$5=next(_a1T_),_a1U_=0,n$18=next(_a1U_);
          return send_meth(m$5,n$18,new_cache(table))}
      return clo}
    function set_methods(table,methods)
     {var len=methods.length - 1,i=[0,0];
      for(;;)
       {if(i[1] < len)
         {var
           _a01_=i[1],
           label=caml_check_bound(methods,_a01_)[1 + _a01_],
           clo=method_impl(table,i,methods);
          set_method(table,label,clo);
          i[1]++;
          continue}
        return 0}}
    try
     {caml_sys_getenv(_wH_)}
    catch(_a00_)
     {_a00_ = caml_wrap_exception(_a00_);if(_a00_ !== Not_found)throw _a00_}
    try
     {caml_sys_getenv(_wG_)}
    catch(_a0Z_)
     {_a0Z_ = caml_wrap_exception(_a0Z_);if(_a0Z_ !== Not_found)throw _a0Z_}
    if(caml_string_notequal(os_type$0,_e1_))
     caml_string_notequal(os_type$0,_e2_);
    function traditional2revised
     (get_raw_token,get_startp,get_endp,parser,lexer)
     {var _a0X_=0,lexbuf=from_string(_a0X_,_e3_);
      function lexer$0(lexbuf)
       {var _a0Y_=0,token=caml_call1(lexer,_a0Y_);
        lexbuf[11] = caml_call1(get_startp,token);
        lexbuf[12] = caml_call1(get_endp,token);
        return caml_call1(get_raw_token,token)}
      return caml_call2(parser,lexer$0,lexbuf)}
    function traditional2revised$0(parser)
     {function _a0T_(param){var endp=param[3];return endp}
      function _a0U_(param){var startp=param[2];return startp}
      function _a0V_(param){var token=param[1];return token}
      return function(_a0W_)
       {return traditional2revised(_a0V_,_a0U_,_a0T_,parser,_a0W_)}}
    function Make$3(T)
     {var
       number=T[1],
       token2terminal=T[2],
       token2value=T[3],
       error_terminal=T[4],
       error_value=T[5],
       foreach_terminal=T[6],
       production_index=T[7],
       find_production=T[8],
       default_reduction=T[9],
       action=T[10],
       goto_nt=T[11],
       goto_prod=T[12],
       maybe_goto_nt=T[13],
       is_start=T[14],
       Error=T[15],
       semantic_action=T[16],
       may_reduce=T[17],
       log=T[18],
       Log=T[19];
      function check_for_default_reduction(env)
       {return caml_call4
                (T[9],env[4],announce_reduce,check_for_error_token,env)}
      function run(env,please_discard)
       {if(log){var _a0R_=env[4],_a0S_=Log[1];caml_call1(_a0S_,_a0R_)}
        return please_discard?[0,env]:check_for_default_reduction(env)}
      function discard(env,triple)
       {if(log)
         {var
           endp=triple[3],
           startp=triple[2],
           token=triple[1],
           _a0O_=T[2],
           _a0P_=caml_call1(_a0O_,token),
           _a0Q_=Log[4];
          caml_call3(_a0Q_,_a0P_,startp,endp)}
        var env$0=[0,0,triple,env[3],env[4]];
        return check_for_default_reduction(env$0)}
      function check_for_error_token(env)
       {if(env[1])
         {if(log){var _a0I_=0,_a0J_=Log[6];caml_call1(_a0J_,_a0I_)}
          return [3,env]}
        var
         match=env[2],
         token=match[1],
         _a0K_=T[3],
         _a0L_=caml_call1(_a0K_,token),
         _a0M_=T[2],
         _a0N_=caml_call1(_a0M_,token);
        return caml_call7
                (T[10],env[4],_a0N_,_a0L_,shift,announce_reduce,initiate,env)}
      function shift(env,please_discard,terminal,value,s)
       {if(log){var _a0H_=Log[2];caml_call2(_a0H_,terminal,s)}
        var
         match=env[2],
         endp=match[3],
         startp=match[2],
         stack=[0,env[4],value,startp,endp,env[3]],
         new_env=[0,env[1],env[2],stack,s];
        return [1,env,new_env,please_discard]}
      function accept(env,prod)
       {if(log){var _a0G_=Log[3];caml_call1(_a0G_,prod)}
        var v=env[3][2];
        return [4,v]}
      function announce_reduce(env,prod)
       {var _a0F_=T[14];
        return caml_call1(_a0F_,prod)?accept(env,prod):[2,env,prod]}
      function reduce(env,prod)
       {if(log){var _a0B_=Log[3];caml_call1(_a0B_,prod)}
        var
         _a0C_=T[16],
         stack=caml_call2(_a0C_,prod,env),
         _a0D_=stack[1],
         _a0E_=T[12],
         current=caml_call2(_a0E_,_a0D_,prod),
         env$0=[0,env[1],env[2],stack,current];
        return run(env$0,0)}
      function initiate(env)
       {if(log){var _a0z_=0,_a0A_=Log[5];caml_call1(_a0A_,_a0z_)}
        var env$0=[0,1,env[2],env[3],env[4]];
        return [3,env$0]}
      function error_fail(strategy,env)
       {if(-798940232 <= strategy)return 0;
        var cell=env[3],next=cell[5];
        if(next === cell)return 0;
        var env$0=[0,env[1],env[2],next,cell[1]];
        return [3,env$0]}
      function error_reduce(strategy,env,prod)
       {if(log){var _a0x_=env[4],_a0y_=Log[7];caml_call1(_a0y_,_a0x_)}
        return -798940232 <= strategy
                ?announce_reduce(env,prod)
                :reduce(env,prod)}
      function error_shift(strategy,env,please_discard,terminal,value,s)
       {var _a0t_=T[4];
        if(caml_equal(terminal,_a0t_))
         {var _a0u_=T[5];
          if(caml_equal(value,_a0u_))
           {if(log){var _a0v_=env[4],_a0w_=Log[7];caml_call1(_a0w_,_a0v_)}
            var please_discard$0=-798940232 <= strategy?0:please_discard;
            return shift(env,please_discard$0,terminal,value,s)}}
        throw [0,Assert_failure,_e5_]}
      function error(strategy,env)
       {if(env[1])
         {var
           _a0i_=function(_a0s_){return error_fail(strategy,_a0s_)},
           _a0j_=
            function(_a0q_,_a0r_){return error_reduce(strategy,_a0q_,_a0r_)},
           _a0k_=
            function(_a0l_,_a0m_,_a0n_,_a0o_,_a0p_)
             {return error_shift(strategy,_a0l_,_a0m_,_a0n_,_a0o_,_a0p_)};
          return caml_call7(T[10],env[4],T[4],T[5],_a0k_,_a0j_,_a0i_,env)}
        throw [0,Assert_failure,_e4_]}
      function start(s,initial)
       {var empty=[],_a0h_=[0,s,T[5],initial,initial,empty];
        caml_update_dummy(empty,_a0h_);
        var env=[0,0,[0,0,initial,initial],empty,s];
        return run(env,1)}
      function offer(param)
       {if(typeof param !== "number" && 0 === param[0])
         {var env=param[1];return function(_a0g_){return discard(env,_a0g_)}}
        return invalid_arg(_e6_)}
      function resume(opt,checkpoint)
       {if(opt)var sth=opt[1],strategy=sth;else var strategy=-822677911;
        if(typeof checkpoint !== "number")
         switch(checkpoint[0])
          {case 1:
            var please_discard=checkpoint[3],env=checkpoint[2];
            return run(env,please_discard);
           case 2:
            var prod=checkpoint[2],env$0=checkpoint[1];
            return reduce(env$0,prod);
           case 3:var env$1=checkpoint[1];return error(strategy,env$1)
           }
        return invalid_arg(_e7_)}
      function lexer_lexbuf_to_supplier(lexer,lexbuf,param)
       {var token=caml_call1(lexer,lexbuf),startp=lexbuf[11],endp=lexbuf[12];
        return [0,token,startp,endp]}
      function loop(opt,read,checkpoint)
       {var opt$0=opt,checkpoint$0=checkpoint;
        for(;;)
         {if(opt$0)var sth=opt$0[1],strategy=sth;else var strategy=-822677911;
          if(typeof checkpoint$0 === "number")
           throw Error;
          else
           switch(checkpoint$0[0])
            {case 0:
              var
               _a0e_=0,
               triple=caml_call1(read,_a0e_),
               checkpoint$1=caml_call1(offer(checkpoint$0),triple),
               opt$1=[0,strategy],
               opt$0=opt$1,
               checkpoint$0=checkpoint$1;
              continue;
             case 4:var v=checkpoint$0[1];return v;
             default:
              var
               _a0f_=[0,strategy],
               checkpoint$2=resume(_a0f_,checkpoint$0),
               opt$2=[0,strategy],
               opt$0=opt$2,
               checkpoint$0=checkpoint$2;
              continue}}}
      function entry(strategy,s,lexer,lexbuf)
       {var initial=lexbuf[12],_a0c_=start(s,initial);
        return loop
                ([0,strategy],
                 function(_a0d_)
                  {return lexer_lexbuf_to_supplier(lexer,lexbuf,_a0d_)},
                 _a0c_)}
      function loop_handle(succeed,fail,read,checkpoint)
       {var checkpoint$0=checkpoint;
        for(;;)
         {if(typeof checkpoint$0 !== "number")
           switch(checkpoint$0[0])
            {case 0:
              var
               _a0a_=0,
               triple=caml_call1(read,_a0a_),
               checkpoint$1=caml_call1(offer(checkpoint$0),triple),
               checkpoint$0=checkpoint$1;
              continue;
             case 4:var v=checkpoint$0[1];return caml_call1(succeed,v);
             case 3:break;
             default:
              var
               _a0b_=0,
               checkpoint$2=resume(_a0b_,checkpoint$0),
               checkpoint$0=checkpoint$2;
              continue}
          return caml_call1(fail,checkpoint$0)}}
      function _aZR_(succeed,fail,read,param)
       {var param$0=param;
        for(;;)
         {var checkpoint=param$0[2],inputneeded=param$0[1];
          if(typeof checkpoint !== "number")
           switch(checkpoint[0])
            {case 0:
              var
               _aZ__=0,
               triple=caml_call1(read,_aZ__),
               checkpoint$0=caml_call1(offer(checkpoint),triple),
               param$1=[0,checkpoint,checkpoint$0],
               param$0=param$1;
              continue;
             case 4:var v=checkpoint[1];return caml_call1(succeed,v);
             case 3:break;
             default:
              var
               _aZ$_=0,
               checkpoint$1=resume(_aZ$_,checkpoint),
               param$2=[0,inputneeded,checkpoint$1],
               param$0=param$2;
              continue}
          return caml_call2(fail,inputneeded,checkpoint)}}
      function loop_handle_undo(succeed,fail,read,checkpoint)
       {var switch$0=0;
        if(typeof checkpoint !== "number" && 0 === checkpoint[0])
         {var _aZ9_=1;switch$0 = 1}
        if(! switch$0)var _aZ9_=0;
        if(_aZ9_)return _aZR_(succeed,fail,read,[0,checkpoint,checkpoint]);
        throw [0,Assert_failure,_e8_]}
      function shifts(checkpoint)
       {var checkpoint$0=checkpoint;
        for(;;)
         {if(typeof checkpoint$0 !== "number")
           switch(checkpoint$0[0])
            {case 1:var env=checkpoint$0[1];return [0,env];
             case 2:
              var
               _aZ8_=0,
               checkpoint$1=resume(_aZ8_,checkpoint$0),
               checkpoint$0=checkpoint$1;
              continue;
             case 3:return 0
             }
          throw [0,Assert_failure,_e9_]}}
      function acceptable(checkpoint,token,pos)
       {var
         triple=[0,token,pos,pos],
         checkpoint$0=caml_call1(offer(checkpoint),triple),
         match=shifts(checkpoint$0);
        return match?1:0}
      function _aZS_(cell,current)
       {return [246,
                function(param)
                 {var next=cell[5];
                  if(next === cell)return 0;
                  var
                   element=[0,current,cell[2],cell[3],cell[4]],
                   _aZ7_=cell[1];
                  return [0,element,_aZS_(next,_aZ7_)]}]}
      function stack(env){return _aZS_(env[3],env[4])}
      function top(env)
       {var cell=env[3],next=cell[5];
        return next === cell?0:[0,[0,env[4],cell[2],cell[3],cell[4]]]}
      function equal(env1,env2)
       {var _aZ2_=env1[3] === env2[3]?1:0;
        if(_aZ2_)
         var
          _aZ3_=env2[4],
          _aZ4_=caml_call1(number,_aZ3_),
          _aZ5_=env1[4],
          _aZ6_=caml_call1(number,_aZ5_) === _aZ4_?1:0;
        else
         var _aZ6_=_aZ2_;
        return _aZ6_}
      function current_state_number(env){return caml_call1(number,env[4])}
      function positions(param)
       {var match=param[2],endp=match[3],startp=match[2];
        return [0,startp,endp]}
      function state_has_default_reduction(state)
       {var _aZZ_=0;
        function _aZ0_(env){return 0}
        function _aZ1_(env,prod){return 1}
        return caml_call4(T[9],state,_aZ1_,_aZ0_,_aZZ_)}
      function env_has_default_reduction(env)
       {return state_has_default_reduction(env[4])}
      function pop(env)
       {var cell=env[3],next=cell[5];
        return next === cell?0:[0,[0,env[1],env[2],next,cell[1]]]}
      function force_reduction(prod,env)
       {var _aZT_=env[4],_aZU_=T[17];
        if(caml_call2(_aZU_,_aZT_,prod))
         {var _aZV_=T[14];
          if(caml_call1(_aZV_,prod))throw [0,Assert_failure,_e__];
          var
           _aZW_=T[16],
           stack=caml_call2(_aZW_,prod,env),
           _aZX_=stack[1],
           _aZY_=T[12],
           current=caml_call2(_aZY_,_aZX_,prod);
          return [0,env[1],env[2],stack,current]}
        return invalid_arg(_e$_)}
      function input_needed(env){return [0,env]}
      function pop_many(i,env)
       {var i$0=i,env$0=env;
        for(;;)
         {if(0 === i$0)return [0,env$0];
          var match=pop(env$0);
          if(match)
           {var env$1=match[1],i$1=i$0 - 1 | 0,i$0=i$1,env$0=env$1;continue}
          return 0}}
      function get(i,env)
       {var match=pop_many(i,env);
        if(match){var env$0=match[1];return top(env$0)}
        return 0}
      return [0,
              number,
              token2terminal,
              token2value,
              error_terminal,
              error_value,
              foreach_terminal,
              production_index,
              find_production,
              default_reduction,
              action,
              goto_nt,
              goto_prod,
              maybe_goto_nt,
              is_start,
              Error,
              semantic_action,
              may_reduce,
              log,
              Log,
              run,
              discard,
              check_for_default_reduction,
              check_for_error_token,
              shift,
              announce_reduce,
              reduce,
              accept,
              initiate,
              error,
              error_shift,
              error_reduce,
              error_fail,
              start,
              offer,
              resume,
              lexer_lexbuf_to_supplier,
              loop,
              entry,
              loop_handle,
              loop_handle_undo,
              shifts,
              acceptable,
              stack,
              top,
              equal,
              current_state_number,
              positions,
              state_has_default_reduction,
              env_has_default_reduction,
              pop,
              force_reduction,
              input_needed,
              pop_many,
              get]}
    function read(s,i){return caml_string_unsafe_get(s,i)}
    function get1(s,i)
     {var
       _aZQ_=i >>> 3 | 0,
       c=read(s,_aZQ_),
       c$0=c >>> (lnot(i) & 7) | 0,
       c$1=c$0 & 1;
      return c$1}
    function get$1(param,i)
     {var s=param[2],k=param[1],switcher=k - 1 | 0;
      if(! (15 < switcher >>> 0))
       switch(switcher)
        {case 0:return get1(s,i);
         case 1:
          var
           _aZM_=i >>> 2 | 0,
           c=read(s,_aZM_),
           c$0=c >>> (2 * (lnot(i) & 3) | 0) | 0,
           c$1=c$0 & 3;
          return c$1;
         case 3:
          var
           _aZN_=i >>> 1 | 0,
           c$2=read(s,_aZN_),
           c$3=c$2 >>> (4 * (lnot(i) & 1) | 0) | 0,
           c$4=c$3 & 15;
          return c$4;
         case 7:return read(s,i);
         case 15:
          var j$0=2 * i | 0,_aZO_=j$0 + 1 | 0,_aZP_=read(s,_aZO_);
          return (read(s,j$0) << 8) + _aZP_ | 0
         }
      if(32 === k)
       {var
         j=4 * i | 0,
         _aZG_=j + 3 | 0,
         _aZH_=read(s,_aZG_),
         _aZI_=j + 2 | 0,
         _aZJ_=read(s,_aZI_),
         _aZK_=j + 1 | 0,
         _aZL_=read(s,_aZK_);
        return (((((read(s,j) << 8) + _aZL_ | 0) << 8) + _aZJ_ | 0) << 8)
               +
               _aZH_
               |
               0}
      throw [0,Assert_failure,_fa_]}
    function unflatten1(param,i,j)
     {var data=param[2],n=param[1];return get1(data,caml_mul(n,i) + j | 0)}
    function decode(displacement)
     {return 0 === (displacement & 1)
              ?displacement >>> 1 | 0
              :- (displacement >>> 1 | 0) | 0}
    function getget(get_displacement,get_data,param,i,j)
     {var
       data=param[2],
       displacement=param[1],
       _aZF_=caml_call2(get_displacement,displacement,i),
       k=decode(_aZF_);
      return caml_call2(get_data,data,k + j | 0)}
    function read_interval_via(get_data,i,j)
     {if(i === j)return 0;
      var _aZD_=i + 1 | 0,_aZE_=read_interval_via(get_data,_aZD_,j);
      return [0,caml_call1(get_data,i),_aZE_]}
    function read_row_via(get_data,get_entry,i)
     {var _aZB_=i + 1 | 0,_aZC_=caml_call1(get_entry,_aZB_);
      return read_interval_via(get_data,caml_call1(get_entry,i),_aZC_)}
    function Make$4(TT,IT,ET,E)
     {var
       terminal=IT[1],
       nonterminal=IT[2],
       lr0_core=IT[4],
       lr0_items=IT[5],
       lr0_incoming=IT[6];
      function read_packed_linearized(param,i)
       {var entry=param[2],data=param[1];
        function _aZy_(_aZA_){return get$1(entry,_aZA_)}
        return read_row_via(function(_aZz_){return get$1(data,_aZz_)},_aZy_,i)}
      function decode_symbol(symbol)
       {if(0 < symbol)
         {var kind=symbol & 1,symbol$0=symbol >>> 1 | 0;
          return 0 === kind
                  ?caml_call1(IT[1],symbol$0 - 1 | 0)
                  :caml_call1(IT[2],symbol$0)}
        throw [0,Assert_failure,_fb_]}
      function n2i(nt)
       {var
         answer=TT[9] + nt | 0,
         _aZv_=[0,[1,nt]],
         _aZw_=IT[2],
         _aZx_=caml_call1(_aZw_,answer);
        if(caml_equal(_aZx_,_aZv_))return answer;
        throw [0,Assert_failure,_fc_]}
      function t2i(answer)
       {var _aZs_=[0,[0,answer]],_aZt_=IT[1],_aZu_=caml_call1(_aZt_,answer);
        if(caml_equal(_aZu_,_aZs_))return answer;
        throw [0,Assert_failure,_fd_]}
      function compare_terminals(t1,t2)
       {var _aZr_=t2i(t2);return t2i(t1) - _aZr_ | 0}
      function compare_nonterminals(nt1,nt2)
       {var _aZq_=n2i(nt2);return n2i(nt1) - _aZq_ | 0}
      function compare_symbols(symbol1,symbol2)
       {var _aZl_=symbol1[1];
        if(0 === _aZl_[0])
         {var _aZm_=symbol2[1],_aZn_=_aZl_[1];
          if(0 === _aZm_[0])
           {var t2=_aZm_[1];return compare_terminals(_aZn_,t2)}
          return -1}
        var _aZo_=symbol2[1],_aZp_=_aZl_[1];
        if(0 === _aZo_[0])return 1;
        var nt2=_aZo_[1];
        return compare_nonterminals(_aZp_,nt2)}
      function compare_productions(prod1,prod2){return prod1 - prod2 | 0}
      function compare_items(param,_aZk_)
       {var
         index2=_aZk_[2],
         prod2=_aZk_[1],
         index1=param[2],
         prod1=param[1],
         c=compare_productions(prod1,prod2);
        return 0 === c?index1 - index2 | 0:c}
      function incoming_symbol(s)
       {var
         _aZh_=IT[4],
         core=get$1(_aZh_,s),
         _aZi_=IT[6],
         _aZj_=get$1(_aZi_,core),
         symbol=decode_symbol(_aZj_),
         symbol$0=symbol[1];
        return symbol$0}
      function lhs(prod)
       {var _aZf_=TT[7],_aZg_=get$1(_aZf_,prod);
        return caml_call1(IT[2],_aZg_)}
      function rhs(prod)
       {var _aZe_=IT[3];
        return map$0(decode_symbol,read_packed_linearized(_aZe_,prod))}
      var low_bits=10,low_limit=1024;
      function export$0(t){return [0,t >>> 10 | 0,t % 1024 | 0]}
      function items(s)
       {var _aZc_=IT[4],core=get$1(_aZc_,s),_aZd_=IT[5];
        return map$0(export$0,read_packed_linearized(_aZd_,core))}
      function decode_bool(i)
       {if(0 !== i && 1 !== i)throw [0,Assert_failure,_fe_];
        return 1 === i?1:0}
      function nullable(nt)
       {var _aZa_=n2i(nt),_aZb_=IT[7];return decode_bool(get1(_aZb_,_aZa_))}
      function first(nt,t)
       {var _aY9_=t2i(t),_aY__=n2i(nt),_aY$_=IT[8];
        return decode_bool(unflatten1(_aY$_,_aY__,_aY9_))}
      function xfirst(symbol,t)
       {var _aY8_=symbol[1];
        if(0 === _aY8_[0])
         {var t$0=_aY8_[1];return 0 === compare_terminals(t,t$0)?1:0}
        var nt=_aY8_[1];
        return first(nt,t)}
      function foldij(i,j,f,accu)
       {var i$0=i,accu$0=accu;
        for(;;)
         {if(i$0 === j)return accu$0;
          var
           accu$1=caml_call2(f,i$0,accu$0),
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           accu$0=accu$1;
          continue}}
      function foreach_terminal(f,accu)
       {var match=TT[5],n=match[1];
        return foldij
                (0,
                 n,
                 function(i,accu)
                  {var _aY7_=IT[1];
                   return caml_call2(f,caml_call1(_aY7_,i),accu)},
                 accu)}
      function foreach_terminal_but_error(f,accu)
       {var match=TT[5],n=match[1];
        return foldij
                (0,
                 n,
                 function(i,accu)
                  {if(i === TT[2])return accu;
                   var _aY6_=IT[1];
                   return caml_call2(f,caml_call1(_aY6_,i),accu)},
                 accu)}
      function feed_failure(param){return invalid_arg(_ff_)}
      function feed_nonterminal(nt,startp,semv,endp,env)
       {var source=env[4],_aY5_=ET[13],match=caml_call2(_aY5_,source,nt);
        if(match)
         {var target=match[1],stack=[0,source,semv,startp,endp,env[3]];
          return [0,env[1],env[2],stack,target]}
        return feed_failure(0)}
      function reduce(env,prod){return feed_failure(0)}
      function initiate(env){return feed_failure(0)}
      function feed_terminal(terminal,startp,semv,endp,env)
       {var source=env[4];
        function _aY4_(env,please_discard,terminal,semv,target)
         {var stack=[0,source,semv,startp,endp,env[3]];
          return [0,env[1],env[2],stack,target]}
        return caml_call7
                (ET[10],source,terminal,semv,_aY4_,reduce,initiate,env)}
      function feed(symbol,startp,semv,endp,env)
       {if(0 === symbol[0])
         {var terminal=symbol[1];
          return feed_terminal(t2i(terminal),startp,semv,endp,env)}
        var nt=symbol[1];
        return feed_nonterminal(n2i(nt),startp,semv,endp,env)}
      return [0,
              terminal,
              nonterminal,
              lr0_core,
              lr0_items,
              lr0_incoming,
              read_packed_linearized,
              decode_symbol,
              n2i,
              t2i,
              compare_terminals,
              compare_nonterminals,
              compare_symbols,
              compare_productions,
              compare_items,
              incoming_symbol,
              lhs,
              rhs,
              low_bits,
              low_limit,
              export$0,
              items,
              decode_bool,
              nullable,
              first,
              xfirst,
              foldij,
              foreach_terminal,
              foreach_terminal_but_error,
              feed_failure,
              feed_nonterminal,
              reduce,
              initiate,
              feed_terminal,
              feed]}
    function MakeEngineTable(T)
     {function number(s){return s}
      var _aYA_=T[1],_aYB_=T[3],_aYC_=T[2],error_value=0;
      function foldij(i,j,f,accu)
       {var i$0=i,accu$0=accu;
        for(;;)
         {if(i$0 === j)return accu$0;
          var
           accu$1=caml_call2(f,i$0,accu$0),
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           accu$0=accu$1;
          continue}}
      function foreach_terminal(f,accu)
       {var match=T[5],n=match[1];
        return foldij(0,n,function(i,accu){return caml_call2(f,i,accu)},accu)}
      function non_start_production(i)
       {if(T[9] <= i && (i - T[9] | 0) < T[10].length - 1)return 0;
        throw [0,Assert_failure,_fg_]}
      function production_index(i){non_start_production(i);return i}
      function find_production(i){non_start_production(i);return i}
      function default_reduction(state,defred,nodefred,env)
       {var _aY3_=T[4],code=get$1(_aY3_,state);
        return 0 === code
                ?caml_call1(nodefred,env)
                :caml_call2(defred,env,code - 1 | 0)}
      function is_start(prod){return prod < T[9]?1:0}
      function unmarshal2(table,i,j){return getget(get$1,get$1,table,i,j)}
      function action(state,terminal,value,shift,reduce,fail,env)
       {var _aY1_=T[5],c=unflatten1(_aY1_,state,terminal);
        if(1 === c)
         {var
           _aY2_=T[6],
           action=unmarshal2(_aY2_,state,terminal),
           opcode=action & 3,
           param=action >>> 2 | 0;
          if(2 <= opcode)
           {var please_discard=2 === opcode?1:0;
            return caml_call5(shift,env,please_discard,terminal,value,param)}
          return caml_call2(reduce,env,param)}
        if(0 === c)return caml_call1(fail,env);
        throw [0,Assert_failure,_fh_]}
      function goto_nt(state,nt)
       {var _aY0_=T[8],code=unmarshal2(_aY0_,state,nt);return code - 1 | 0}
      function goto_prod(state,prod)
       {var _aYZ_=T[7];return goto_nt(state,get$1(_aYZ_,prod))}
      function maybe_goto_nt(state,nt)
       {var _aYY_=T[8],code=unmarshal2(_aYY_,state,nt);
        if(0 <= code)return 0 === code?0:[0,code - 1 | 0];
        throw [0,Assert_failure,_fi_]}
      var _aYD_=T[11];
      function semantic_action(prod)
       {var _aYW_=prod - T[9] | 0,_aYX_=T[10];
        return caml_check_bound(_aYX_,_aYW_)[1 + _aYW_]}
      function may_reduce(state,prod)
       {var _aYM_=0;
        function _aYN_(param)
         {var _aYO_=0;
          return foreach_terminal
                  (function(t,accu)
                    {if(accu)return accu;
                     var _aYP_=0;
                     function _aYQ_(param){return 0}
                     function _aYR_(param,prod$0){return prod === prod$0?1:0}
                     return action
                             (state,
                              t,
                              0,
                              function(param,_aYV_,_aYU_,_aYT_,_aYS_){return 0},
                              _aYR_,
                              _aYQ_,
                              _aYP_)},
                   _aYO_)}
        return default_reduction
                (state,
                 function(param,prod$0){return prod === prod$0?1:0},
                 _aYN_,
                 _aYM_)}
      var log=T[12]?1:0;
      function state(state)
       {return T[12]?caml_call1(fprintf(stderr,_fj_),state):0}
      function shift(terminal,state)
       {var _aYK_=T[12];
        if(_aYK_)
         {var
           match=_aYK_[1],
           terminals=match[1],
           _aYL_=caml_check_bound(terminals,terminal)[1 + terminal];
          return caml_call2(fprintf(stderr,_fk_),_aYL_,state)}
        return 0}
      function reduce_or_accept(prod)
       {var _aYI_=T[12];
        if(_aYI_)
         {var
           match=_aYI_[1],
           productions=match[2],
           _aYJ_=caml_check_bound(productions,prod)[1 + prod];
          return caml_call1(fprintf(stderr,_fl_),_aYJ_)}
        return 0}
      function lookahead_token(token,startp,endp)
       {var _aYE_=T[12];
        if(_aYE_)
         {var
           match=_aYE_[1],
           terminals=match[1],
           _aYF_=endp[4],
           _aYG_=startp[4],
           _aYH_=caml_check_bound(terminals,token)[1 + token];
          return caml_call3(fprintf(stderr,_fm_),_aYH_,_aYG_,_aYF_)}
        return 0}
      function initiating_error_handling(param)
       {return T[12]?fprintf(stderr,_fn_):0}
      function resuming_error_handling(param)
       {return T[12]?fprintf(stderr,_fo_):0}
      function handling_error(state)
       {return T[12]?caml_call1(fprintf(stderr,_fp_),state):0}
      var
       Log=
        [0,
         state,
         shift,
         reduce_or_accept,
         lookahead_token,
         initiating_error_handling,
         resuming_error_handling,
         handling_error];
      return [0,
              number,
              _aYA_,
              _aYB_,
              _aYC_,
              error_value,
              foldij,
              foreach_terminal,
              non_start_production,
              production_index,
              find_production,
              default_reduction,
              is_start,
              unmarshal2,
              action,
              goto_nt,
              goto_prod,
              maybe_goto_nt,
              _aYD_,
              semantic_action,
              may_reduce,
              log,
              Log]}
    function _fq_(_aYy_)
     {var _aYz_=MakeEngineTable(_aYy_);
      return [0,
              _aYz_[1],
              _aYz_[2],
              _aYz_[3],
              _aYz_[4],
              _aYz_[5],
              _aYz_[7],
              _aYz_[9],
              _aYz_[10],
              _aYz_[11],
              _aYz_[14],
              _aYz_[15],
              _aYz_[16],
              _aYz_[17],
              _aYz_[12],
              _aYz_[18],
              _aYz_[19],
              _aYz_[20],
              _aYz_[21],
              _aYz_[22]]}
    function _fr_(_aYw_,_aYv_,_aYu_,_aYt_)
     {var _aYx_=Make$4(_aYw_,_aYv_,_aYu_,_aYt_);
      return [0,
              _aYx_[10],
              _aYx_[11],
              _aYx_[12],
              _aYx_[13],
              _aYx_[14],
              _aYx_[15],
              _aYx_[21],
              _aYx_[16],
              _aYx_[17],
              _aYx_[23],
              _aYx_[24],
              _aYx_[25],
              _aYx_[27],
              _aYx_[28],
              _aYx_[34]]}
    function _fs_(_aYr_)
     {var _aYs_=Make$3(_aYr_);
      return [0,
              _aYs_[15],
              _aYs_[38],
              _aYs_[34],
              _aYs_[35],
              _aYs_[36],
              _aYs_[37],
              _aYs_[39],
              _aYs_[40],
              _aYs_[41],
              _aYs_[42],
              _aYs_[1],
              _aYs_[7],
              _aYs_[8],
              _aYs_[43],
              _aYs_[44],
              _aYs_[53],
              _aYs_[54],
              _aYs_[46],
              _aYs_[45],
              _aYs_[47],
              _aYs_[49],
              _aYs_[48],
              _aYs_[50],
              _aYs_[51],
              _aYs_[52],
              _aYs_[33]]}
    var
     Unix_error=[248,_ft_,caml_fresh_oo_id(0)],
     _fw_=[0,Unix_error,0,_fv_,_fu_];
    register_exception(_fx_,_fw_);
    function _fy_(param)
     {if(param[1] === Unix_error)
       {var s=param[4],s$0=param[3],e=param[2];
        if(typeof e === "number")
         {var _aYq_=e;
          if(34 <= _aYq_)
           switch(_aYq_)
            {case 34:var msg=_f8_;break;
             case 35:var msg=_f9_;break;
             case 36:var msg=_f__;break;
             case 37:var msg=_f$_;break;
             case 38:var msg=_ga_;break;
             case 39:var msg=_gb_;break;
             case 40:var msg=_gc_;break;
             case 41:var msg=_gd_;break;
             case 42:var msg=_ge_;break;
             case 43:var msg=_gf_;break;
             case 44:var msg=_gg_;break;
             case 45:var msg=_gh_;break;
             case 46:var msg=_gi_;break;
             case 47:var msg=_gj_;break;
             case 48:var msg=_gk_;break;
             case 49:var msg=_gl_;break;
             case 50:var msg=_gm_;break;
             case 51:var msg=_gn_;break;
             case 52:var msg=_go_;break;
             case 53:var msg=_gp_;break;
             case 54:var msg=_gq_;break;
             case 55:var msg=_gr_;break;
             case 56:var msg=_gs_;break;
             case 57:var msg=_gt_;break;
             case 58:var msg=_gu_;break;
             case 59:var msg=_gv_;break;
             case 60:var msg=_gw_;break;
             case 61:var msg=_gx_;break;
             case 62:var msg=_gy_;break;
             case 63:var msg=_gz_;break;
             case 64:var msg=_gA_;break;
             case 65:var msg=_gB_;break;
             case 66:var msg=_gC_;break;
             default:var msg=_gD_}
          else
           switch(_aYq_)
            {case 0:var msg=_fz_;break;
             case 1:var msg=_fB_;break;
             case 2:var msg=_fC_;break;
             case 3:var msg=_fD_;break;
             case 4:var msg=_fE_;break;
             case 5:var msg=_fF_;break;
             case 6:var msg=_fG_;break;
             case 7:var msg=_fH_;break;
             case 8:var msg=_fI_;break;
             case 9:var msg=_fJ_;break;
             case 10:var msg=_fK_;break;
             case 11:var msg=_fL_;break;
             case 12:var msg=_fM_;break;
             case 13:var msg=_fN_;break;
             case 14:var msg=_fO_;break;
             case 15:var msg=_fP_;break;
             case 16:var msg=_fQ_;break;
             case 17:var msg=_fR_;break;
             case 18:var msg=_fS_;break;
             case 19:var msg=_fT_;break;
             case 20:var msg=_fU_;break;
             case 21:var msg=_fV_;break;
             case 22:var msg=_fW_;break;
             case 23:var msg=_fX_;break;
             case 24:var msg=_fY_;break;
             case 25:var msg=_fZ_;break;
             case 26:var msg=_f0_;break;
             case 27:var msg=_f1_;break;
             case 28:var msg=_f2_;break;
             case 29:var msg=_f3_;break;
             case 30:var msg=_f4_;break;
             case 31:var msg=_f5_;break;
             case 32:var msg=_f6_;break;
             default:var msg=_f7_}}
        else
         var x=e[1],msg=caml_call1(sprintf(_gE_),x);
        return [0,caml_call3(sprintf(_fA_),msg,s$0,s)]}
      return 0}
    register_printer(_fy_);
    unix_inet_addr_of_string(_gF_);
    unix_inet_addr_of_string(_gG_);
    try
     {unix_inet_addr_of_string(_wF_)}
    catch(_aYp_)
     {_aYp_ = caml_wrap_exception(_aYp_);if(_aYp_[1] !== Failure)throw _aYp_}
    try
     {unix_inet_addr_of_string(_wE_)}
    catch(_aYo_)
     {_aYo_ = caml_wrap_exception(_aYo_);if(_aYo_[1] !== Failure)throw _aYo_}
    var _gH_=7,_gI_=0;
    create$2(_gI_,_gH_);
    function sign_int(i){return 0 === i?0:0 < i?1:-1}
    var monster_int=-2147483648,biggest_int=2147483647,least_int=-2147483647;
    initialize_nat(0);
    function make_nat(len)
     {if(0 <= len)
       {var res=create_nat(len);set_to_zero_nat(res,0,len);return res}
      return invalid_arg(_gJ_)}
    var _gK_=2;
    make_nat(_gK_);
    var _gL_=1;
    make_nat(_gL_);
    var _gM_=2;
    make_nat(_gM_);
    function nat_of_int(i)
     {if(0 <= i)
       {var _aYn_=1,res=make_nat(_aYn_);
        return 0 === i?res:(set_digit_nat(res,0,i),res)}
      return invalid_arg(_gN_)}
    var _gO_=2,power_base_max=make_nat(_gO_);
    set_digit_nat(power_base_max,0,1000000000);
    var _gP_=1000000000;
    nat_of_int(_gP_);
    var _gQ_=1;
    make_nat(_gQ_);
    var _gR_=1;
    nat_of_int(_gR_);
    function big_int_of_int(i)
     {var res=create_nat(1);
      if(i === -2147483648)
       {set_digit_nat(res,0,2147483647);incr_nat(res,0,1,1)}
      else
       {var _aYm_=abs(i);set_digit_nat(res,0,_aYm_)}
      return [0,sign_int(i),res]}
    big_int_of_int(monster_int);
    big_int_of_int(biggest_int);
    big_int_of_int(least_int);
    var _gS_=255,_gT_=32;
    make$0(_gT_,_gS_);
    function make_empty(param){return make$0(32,0)}
    function add$1(s,i)
     {var
       _aYh_=1 << (i & 7),
       _aYi_=i >>> 3 | 0,
       _aYj_=caml_bytes_get(s,_aYi_) | _aYh_,
       _aYk_=chr(_aYj_),
       _aYl_=i >>> 3 | 0;
      return caml_bytes_set(s,_aYl_,_aYk_)}
    function singleton(c){var _aYg_=0,s=make_empty(_aYg_);add$1(s,c);return s}
    function complement(s)
     {var r=caml_create_bytes(32),i=0;
      for(;;)
       {var _aYd_=caml_bytes_get(s,i) ^ 255,_aYe_=chr(_aYd_);
        caml_bytes_set(r,i,_aYe_);
        var _aYf_=i + 1 | 0;
        if(31 !== i){var i=_aYf_;continue}
        return r}}
    var t=caml_create_bytes(256),i=0;
    for(;;)
     {var _wB_=chr(i),_wC_=lowercase(_wB_);
      caml_bytes_set(t,i,_wC_);
      var _wD_=i + 1 | 0;
      if(255 !== i){var i=_wD_;continue}
      of_bytes(t);
      var _gU_=10,_gV_=singleton(_gU_);
      complement(_gV_);
      var
       nolock=[0,function(f,x){return caml_call1(f,x)}],
       sync=function(lock){return lock[1]},
       create$4=
        function(n)
         {var _aYb_=max_array_length - 1 | 0,len=min(n,_aYb_),_aYc_=0;
          return [0,weak_create(len),len,_aYc_]},
       iter$5=
        function(f,s)
         {var _aX__=s[3] - 1 | 0;
          if(! (_aX__ < 0))
           {var i=_aX__;
            for(;;)
             {var _aX$_=s[1],match=get$0(_aX$_,i);
              if(match){var x=match[1];caml_call1(f,x)}
              var _aYa_=i - 1 | 0;
              if(0 !== i){var i=_aYa_;continue}
              break}}
          return 0},
       length$3=
        function(s)
         {var flag=[0,0],pt=[0,0],_aX5_=s[3] - 1 | 0,_aX4_=0;
          if(! (_aX5_ < 0))
           {var i=_aX4_;
            for(;;)
             {var _aX6_=s[1],d=get$0(_aX6_,i);
              if(d)
               {if(flag[1]){var _aX7_=pt[1],_aX8_=s[1];set(_aX8_,_aX7_,d)}
                pt[1]++}
              else
               flag[1] = 1;
              var _aX9_=i + 1 | 0;
              if(_aX5_ !== i){var i=_aX9_;continue}
              break}}
          s[3] = pt[1];
          return s[3]},
       copy$1=
        function(s)
         {var
           _aXY_=s[2],
           s$0=create$4(_aXY_),
           _aXZ_=s[3],
           _aX0_=0,
           _aX1_=s$0[1],
           _aX2_=0,
           _aX3_=s[1];
          blit$2(_aX3_,_aX2_,_aX1_,_aX0_,_aXZ_);
          s$0[3] = s[3];
          return s$0},
       push$0=
        function(x,s)
         {for(;;)
           {if(s[3] < s[2])
             {var _aXP_=[0,x],_aXQ_=s[3],_aXR_=s[1];
              set(_aXR_,_aXQ_,_aXP_);
              s[3] = s[3] + 1 | 0;
              return 0}
            var len=length$3(s);
            if((s[2] / 3 | 0) <= len && len < ((s[2] * 2 | 0) / 3 | 0))
             continue;
            var
             _aXS_=max_array_length - 1 | 0,
             _aXT_=((len * 3 | 0) / 2 | 0) + 2 | 0,
             len$0=min(_aXT_,_aXS_);
            if(len$0 === len)return failwith(_gW_);
            var data=weak_create(len$0),_aXU_=s[3],_aXV_=0,_aXW_=0,_aXX_=s[1];
            blit$2(_aXX_,_aXW_,data,_aXV_,_aXU_);
            s[1] = data;
            s[2] = len$0;
            continue}},
       pop$0=
        function(s)
         {for(;;)
           {if(s[3] <= 0)throw Not_found;
            s[3] = s[3] - 1 | 0;
            var _aXN_=s[3],_aXO_=s[1],match=get$0(_aXO_,_aXN_);
            if(match){var x=match[1];return x}
            continue}},
       top$0=
        function(s)
         {for(;;)
           {if(s[3] <= 0)throw Not_found;
            var _aXL_=s[3] - 1 | 0,_aXM_=s[1],match=get$0(_aXM_,_aXL_);
            if(match){var x=match[1];return x}
            s[3] = s[3] - 1 | 0;
            continue}},
       Make$5=
        function(H)
         {function enbox(k)
           {var _aXI_=1,w=weak_create(_aXI_),_aXJ_=[0,k],_aXK_=0;
            set(w,_aXK_,_aXJ_);
            return w}
          function unbox(bk){return get$0(bk,0)}
          function bind_new(k,v){return [0,enbox(k),v]}
          function cls_new(bd)
           {var _aXH_=1,cls=create$4(_aXH_);push$0(bd,cls);return cls}
          function dummy(k){var _aXG_=0;return cls_new(bind_new(k,_aXG_))}
          function top_bind(cls)
           {for(;;)
             {var bind=top$0(cls),v=bind[2],bk=bind[1],match=unbox(bk);
              if(match){var k=match[1];return [0,k,v]}
              if(bind === pop$0(cls))continue;
              throw [0,Assert_failure,_gX_]}}
          function top_key(cls){return top_bind(cls)[1]}
          function top_value(cls){return top_bind(cls)[2]}
          function all_bind(cls)
           {var l=[0,0];
            function f(param)
             {var v=param[2],bk=param[1],match=unbox(bk);
              if(match){var k=match[1];l[1] = [0,[0,k,v],l[1]];return 0}
              return 0}
            iter$5(f,cls);
            return rev(l[1])}
          function all_value(cls)
           {var _aXE_=all_bind(cls);
            return map$0(function(_aXF_){return _aXF_[2]},_aXE_)}
          function hash(x)
           {try
             {var _aXA_=top_key(x),_aXB_=H[2],_aXC_=caml_call1(_aXB_,_aXA_);
              return _aXC_}
            catch(_aXD_)
             {_aXD_ = caml_wrap_exception(_aXD_);
              if(_aXD_ === Not_found)return 0;
              throw _aXD_}}
          function equal(x,y)
           {try
             {var
               _aXv_=top_key(y),
               _aXw_=top_key(x),
               _aXx_=H[1],
               _aXy_=caml_call2(_aXx_,_aXw_,_aXv_);
              return _aXy_}
            catch(_aXz_)
             {_aXz_ = caml_wrap_exception(_aXz_);
              if(_aXz_ === Not_found)return 0;
              throw _aXz_}}
          var W=Make$2([0,equal,hash]),create=W[1],clear=W[2];
          function find_all(tbl,key)
           {try
             {var
               _aXq_=dummy(key),
               _aXr_=W[6],
               _aXs_=caml_call2(_aXr_,tbl,_aXq_),
               _aXt_=all_value(_aXs_);
              return _aXt_}
            catch(_aXu_)
             {_aXu_ = caml_wrap_exception(_aXu_);
              if(_aXu_ === Not_found)return 0;
              throw _aXu_}}
          function find(tbl,key)
           {var _aXo_=dummy(key),_aXp_=W[6];
            return top_value(caml_call2(_aXp_,tbl,_aXo_))}
          function find_opt(tbl,key)
           {try
             {var _aXm_=[0,find(tbl,key)];return _aXm_}
            catch(_aXn_)
             {_aXn_ = caml_wrap_exception(_aXn_);
              if(_aXn_ === Not_found)return 0;
              throw _aXn_}}
          function add(tbl,key,data)
           {var bd=bind_new(key,data);
            try
             {var _aXi_=dummy(key),_aXj_=W[6],c$0=caml_call2(_aXj_,tbl,_aXi_);
              push$0(bd,c$0);
              var cls=c$0}
            catch(_aXl_)
             {_aXl_ = caml_wrap_exception(_aXl_);
              if(_aXl_ !== Not_found)throw _aXl_;
              var c=cls_new(bd),_aXg_=W[4];
              caml_call2(_aXg_,tbl,c);
              var cls=c}
            function final$0(param){return 0}
            try
             {var _aXh_=_dD_(final$0,key);return _aXh_}
            catch(_aXk_)
             {_aXk_ = caml_wrap_exception(_aXk_);
              if(_aXk_[1] === Invalid_argument)return _dD_(final$0,cls);
              throw _aXk_}}
          function remove(tbl,key)
           {try
             {var
               _aXb_=dummy(key),
               _aXc_=W[6],
               _aXd_=caml_call2(_aXc_,tbl,_aXb_);
              pop$0(_aXd_);
              var _aXe_=0;
              return _aXe_}
            catch(_aXf_)
             {_aXf_ = caml_wrap_exception(_aXf_);
              if(_aXf_ === Not_found)return 0;
              throw _aXf_}}
          function replace(tbl,key,data)
           {remove(tbl,key);return add(tbl,key,data)}
          function mem(tbl,key)
           {try
             {find(tbl,key);var _aW$_=1;return _aW$_}
            catch(_aXa_)
             {_aXa_ = caml_wrap_exception(_aXa_);
              if(_aXa_ === Not_found)return 0;
              throw _aXa_}}
          function iter(f,tbl)
           {function f$0(param)
             {var v=param[2],bk=param[1],match=unbox(bk);
              if(match){var k=match[1];return caml_call2(f,k,v)}
              return 0}
            function _aW9_(_aW__){return iter$5(f$0,_aW__)}
            return caml_call2(W[10],_aW9_,tbl)}
          function fold(f,tbl,accu)
           {var r=[0,accu];
            function f$0(k,v)
             {var _aW8_=r[1];r[1] = caml_call3(f,k,v,_aW8_);return 0}
            iter(f$0,tbl);
            return r[1]}
          function length(tbl)
           {var _aW1_=0;
            function _aW2_(cls)
             {var _aW3_=length$3(cls);
              function _aW4_(_aW7_,_aW6_){return _aW7_ + _aW6_ | 0}
              return function(_aW5_){return _aW4_(_aW3_,_aW5_)}}
            return caml_call3(W[11],_aW2_,tbl,_aW1_)}
          function copy(tbl)
           {var
             _aWV_=W[12],
             _aWW_=((caml_call1(_aWV_,tbl) * 3 | 0) / 2 | 0) + 2 | 0,
             _aWX_=W[1],
             tbl$0=caml_call1(_aWX_,_aWW_);
            function _aWY_(cls)
             {var _aW0_=copy$1(cls);return caml_call2(W[4],tbl$0,_aW0_)}
            var _aWZ_=W[10];
            caml_call2(_aWZ_,_aWY_,tbl);
            return tbl$0}
          function stats(param){throw [0,Assert_failure,_gY_]}
          function reset(param){throw [0,Assert_failure,_gZ_]}
          function filter_map_inplace(f,tbl)
           {var delta=[0,0];
            function _aWS_(k,v)
             {var other=caml_call2(f,k,v);
              if(other){var v$0=other[1];if(v$0 === v)return 0}
              delta[1] = [0,[0,k,other],delta[1]];
              return 0}
            iter(_aWS_,tbl);
            function handle_delta(param)
             {var _aWT_=param[2],_aWU_=param[1];
              if(_aWT_)
               {var v=_aWT_[1];remove(tbl,_aWU_);return add(tbl,_aWU_,v)}
              return remove(tbl,_aWU_)}
            return iter$0(handle_delta,delta[1])}
          return [0,
                  create,
                  clear,
                  reset,
                  copy,
                  add,
                  remove,
                  find,
                  find_opt,
                  find_all,
                  replace,
                  mem,
                  iter,
                  filter_map_inplace,
                  fold,
                  length,
                  stats]},
       equal=function(x,y){return 0 === caml_compare(x,y)?1:0},
       StdHash=Make$5([0,equal,hash]),
       create$5=StdHash[1],
       add$2=function(tbl,k){return caml_call2(StdHash[5],tbl,k)},
       iter$6=
        function(f)
         {function _aWR_(k,d){return caml_call2(f,k,d)}
          return caml_call1(StdHash[12],_aWR_)},
       weak_create$0=function(size){return caml_call1(create$5,size)},
       weak_add=function(set,element){return caml_call1(add$2(set,element),0)},
       weak_iter=
        function(f,s)
         {return caml_call1
                  (iter$6(function(x,param){return caml_call1(f,x)}),s)},
       hash$0=function(x){return x[4]},
       equal$0=function(x,y){return x[4] === y[4]?1:0},
       hash$1=function(x){return x[5]},
       equal$1=function(x,y){return x[5] === y[5]?1:0},
       Outputs=Make$2([0,equal$1,hash$1]),
       _g0_=32,
       _g1_=Outputs[1],
       outputs=caml_call1(_g1_,_g0_),
       outputs_add=
        function(out)
         {var _aWP_=Outputs[4],_aWQ_=caml_call1(_aWP_,outputs);
          return caml_call2(sync(nolock),_aWQ_,out)},
       outputs_remove=
        function(out)
         {var _aWN_=Outputs[5],_aWO_=caml_call1(_aWN_,outputs);
          return caml_call2(sync(nolock),_aWO_,out)},
       No_more_input=[248,_g2_,caml_fresh_oo_id(0)],
       Input_closed=[248,_g3_,caml_fresh_oo_id(0)],
       Output_closed=[248,_g4_,caml_fresh_oo_id(0)],
       post_incr=function(r){var result=r[1];r[1]++;return result},
       _g5_=[0,0],
       uid=function(param){return post_incr(_g5_)},
       close_in$0=
        function(i)
         {function f(param){throw Input_closed}
          var _aWK_=0,_aWL_=i[3];
          caml_call1(_aWL_,_aWK_);
          i[1] = f;
          i[2] = f;
          i[3] = function(_aWM_){return 0};
          return 0},
       wrap_in=
        function(read,input,close,underlying)
         {var
           _aWE_=2,
           _aWF_=weak_create$0(_aWE_),
           _aWG_=0,
           result=[0,read,input,close,uid(_aWG_),_aWF_];
          function _aWH_(x){return weak_add(x[5],result)}
          function _aWI_(_aWJ_){return iter$0(_aWH_,_aWJ_)}
          caml_call2(sync(nolock),_aWI_,underlying);
          return result},
       create_in=
        function(read,input,close){return wrap_in(read,input,close,0)},
       close_unit=
        function(o)
         {function forbidden(param){throw Output_closed}
          var _aWy_=0,_aWz_=o[4];
          caml_call1(_aWz_,_aWy_);
          var _aWA_=o[6];
          weak_iter(close_unit,_aWA_);
          var _aWB_=0,_aWC_=o[3],r=caml_call1(_aWC_,_aWB_);
          o[1] = forbidden;
          o[2] = forbidden;
          o[3] = function(param){return r};
          o[4] = function(_aWD_){return 0};
          return 0},
       close_out$0=function(o){close_unit(o);return caml_call1(o[3],0)},
       wrap_out=
        function(write,output,flush,close,underlying)
         {var
           out=[],
           _aWq_=2,
           _aWr_=weak_create$0(_aWq_),
           _aWs_=0,
           _aWt_=uid(_aWs_),
           _aWu_=
            [0,
             write,
             output,
             function(param){outputs_remove(out);return caml_call1(close,0)},
             flush,
             _aWt_,
             _aWr_];
          caml_update_dummy(out,_aWu_);
          function _aWv_(x){return weak_add(x[6],out)}
          function _aWw_(_aWx_){return iter$0(_aWv_,_aWx_)}
          caml_call2(sync(nolock),_aWw_,underlying);
          outputs_add(out);
          return out},
       create_out=
        function(write,output,flush,close)
         {return wrap_out(write,output,flush,close,0)},
       read$0=function(i){return caml_call1(i[1],0)},
       input$0=
        function(i,s,p,l)
         {var sl=caml_ml_bytes_length(s),_aWn_=sl < (p + l | 0)?1:0;
          if(_aWn_)
           var _aWo_=_aWn_;
          else
           var _aWp_=p < 0?1:0,_aWo_=_aWp_ || (l < 0?1:0);
          if(_aWo_)invalid_arg(_g6_);
          return 0 === l?0:caml_call3(i[2],s,p,l)},
       write=function(o,x){return caml_call1(o[1],x)},
       nwrite_bytes=
        function(o,s)
         {var p=[0,0],l=[0,caml_ml_bytes_length(s)];
          for(;;)
           {if(0 < l[1])
             {var
               _aWk_=l[1],
               _aWl_=p[1],
               _aWm_=o[2],
               w=caml_call3(_aWm_,s,_aWl_,_aWk_);
              if(0 === w)throw Sys_blocked_io;
              p[1] = p[1] + w | 0;
              l[1] = l[1] - w | 0;
              continue}
            return 0}},
       output_string$0=function(o,s){return nwrite_bytes(o,ubos(s))},
       output$0=
        function(o,s,p,l)
         {var sl=caml_ml_bytes_length(s),_aWh_=sl < (p + l | 0)?1:0;
          if(_aWh_)
           var _aWi_=_aWh_;
          else
           var _aWj_=p < 0?1:0,_aWi_=_aWj_ || (l < 0?1:0);
          if(_aWi_)invalid_arg(_g7_);
          return caml_call3(o[2],s,p,l)},
       flush$0=function(o){return caml_call1(o[4],0)},
       flush_all$0=
        function(param)
         {function _aWc_(o)
           {try {var _aWf_=flush$0(o);return _aWf_}catch(_aWg_){return 0}}
          var _aWd_=Outputs[10],_aWe_=caml_call1(_aWd_,_aWc_);
          return caml_call2(sync(nolock),_aWe_,outputs)},
       close_all=
        function(param)
         {var _aV8_=0;
          function _aV9_(o,os){return [0,o,os]}
          var
           _aV__=Outputs[11],
           _aV$_=caml_call2(_aV__,_aV9_,outputs),
           outs=caml_call2(sync(nolock),_aV$_,_aV8_);
          return iter$0
                  (function(o)
                    {try
                      {var _aWa_=close_out$0(o);return _aWa_}
                     catch(_aWb_){return 0}},
                   outs)},
       _g8_=0,
       _g9_=weak_create$0(_g8_),
       _g__=-1,
       _g$_=function(_aV7_){return 0},
       _ha_=function(param,_aV6_,_aV5_){return 0},
       placeholder_in=[0,function(param){return 32},_ha_,_g$_,_g__,_g9_],
       input_channel=
        function(opt,_aVW_,ch)
         {if(opt)var sth=opt[1],autoclose=sth;else var autoclose=1;
          if(_aVW_)var sth$0=_aVW_[1],cleanup=sth$0;else var cleanup=1;
          var
           me=[0,placeholder_in],
           _aVX_=
            cleanup
             ?function(param){return close_in(ch)}
             :function(_aV4_){return 0};
          function _aVY_(s,p,l)
           {var n=input(ch,s,p,l);
            if(0 === n)
             {if(autoclose){var _aV3_=me[1];close_in$0(_aV3_)}
              throw No_more_input}
            return n}
          function _aVZ_(param)
           {try
             {var _aV1_=input_char(ch);return _aV1_}
            catch(_aV2_)
             {_aV2_ = caml_wrap_exception(_aV2_);
              if(_aV2_ === End_of_file)
               {if(autoclose){var _aV0_=me[1];close_in$0(_aV0_)}
                throw No_more_input}
              throw _aV2_}}
          var result=create_in(_aVZ_,_aVY_,_aVX_);
          me[1] = result;
          return result},
       output_channel=
        function(opt,ch)
         {if(opt)var sth=opt[1],cleanup=sth;else var cleanup=0;
          var
           _aVT_=
            cleanup
             ?function(param){return close_out(ch)}
             :function(param){return flush(ch)};
          function _aVU_(param){return flush(ch)}
          function _aVV_(s,p,l){output(ch,s,p,l);return l}
          return create_out
                  (function(c){return output_char(ch,c)},_aVV_,_aVU_,_aVT_)},
       _hb_=0,
       _hc_=0,
       stdin$0=input_channel(_hc_,_hb_,stdin),
       _hd_=0,
       stdout$0=output_channel(_hd_,stdout),
       _he_=0,
       stderr$0=output_channel(_he_,stderr),
       _hf_=function(_aVS_){return 0},
       _hg_=function(_aVR_){return 0},
       _hh_=function(param,_aVQ_,l){return l},
       _hi_=function(_aVP_){return 0};
      create_out(_hi_,_hh_,_hg_,_hf_);
      var
       ord0=function(n){return 0 <= n?0 < n?2:1:0},
       No_more_elements=[248,_hk_,caml_fresh_oo_id(0)],
       make$3=function(next,count,clone){return [0,count,next,clone,1]},
       dummy=function(param){throw [0,Assert_failure,_hl_]},
       return_no_more_elements=function(param){throw No_more_elements},
       return_no_more_count=function(param){return 0},
       empty=
        function(param)
         {return [0,return_no_more_count,return_no_more_elements,empty,1]},
       close=
        function(e)
         {e[2] = return_no_more_elements;
          e[1] = return_no_more_count;
          e[3] = empty;
          return 0},
       force=
        function(t)
         {function clone(enum$0,count)
           {var enum$1=[0,enum$0[1]],count$0=[0,count[1]],_aVL_=1;
            function _aVM_(param)
             {var enum$0=[0,enum$1[1]],count=[0,count$0[1]];
              return clone(enum$0,count)}
            function _aVN_(param)
             {var _aVO_=enum$1[1];
              if(_aVO_)
               {var t=_aVO_[2],h=_aVO_[1];
                count$0[1] += -1;
                enum$1[1] = t;
                return h}
              throw No_more_elements}
            return [0,function(param){return count$0[1]},_aVN_,_aVM_,_aVL_]}
          var count=[0,0],empty=0;
          function loop(dst)
           {var dst$0=dst;
            for(;;)
             {var _aVJ_=0,_aVK_=t[2],dst$1=[0,caml_call1(_aVK_,_aVJ_),empty];
              count[1]++;
              dst$0[2] = dst$1;
              var dst$0=dst$1;
              continue}}
          var enum$0=[0,empty];
          try
           {var _aVF_=0,_aVG_=t[2];
            enum$0[1] = [0,caml_call1(_aVG_,_aVF_),empty];
            count[1]++;
            var _aVH_=enum$0[1];
            loop(_aVH_)}
          catch(_aVI_)
           {_aVI_ = caml_wrap_exception(_aVI_);
            if(_aVI_ !== No_more_elements)throw _aVI_}
          var tc=clone(enum$0,count);
          t[3] = tc[3];
          t[2] = tc[2];
          t[1] = tc[1];
          t[4] = 1;
          return 0},
       enum$0=
        function(l)
         {function aux(l)
           {var reference=[0,l];
            function _aVA_(param){return aux(reference[1])}
            function _aVB_(param)
             {var
               _aVC_=reference[1],
               _aVD_=caml_obj_tag(_aVC_),
               _aVE_=
                250 === _aVD_
                 ?_aVC_[1]
                 :246 === _aVD_?force_lazy_block(_aVC_):_aVC_;
              if(_aVE_){var t=_aVE_[2],x=_aVE_[1];reference[1] = t;return x}
              throw No_more_elements}
            var e=make$3(_aVB_,dummy,_aVA_);
            e[1] = function(param){force(e);return caml_call1(e[1],0)};
            e[4] = 0;
            return e}
          return aux(l)},
       from=
        function(f)
         {function aux(param)
           {return [246,
                    function(_aVu_)
                     {try
                       {var _aVx_=0,_aVy_=[0,caml_call1(f,_aVx_)],item=_aVy_}
                      catch(_aVz_)
                       {_aVz_ = caml_wrap_exception(_aVz_);
                        if(_aVz_ !== No_more_elements)throw _aVz_;
                        var _aVv_=0,item=_aVv_}
                      if(item){var x=item[1],_aVw_=0;return [0,x,aux(_aVw_)]}
                      return 0}]}
          return aux(0)},
       from$0=
        function(f)
         {var e=[0,dummy,dummy,dummy,0];
          e[2]
          =
          function(param)
           {try
             {var _aVr_=0,_aVs_=caml_call1(f,_aVr_);return _aVs_}
            catch(_aVt_)
             {_aVt_ = caml_wrap_exception(_aVt_);
              if(_aVt_ === No_more_elements){close(e);throw No_more_elements}
              throw _aVt_}};
          e[1] = function(param){force(e);return caml_call1(e[1],0)};
          e[3]
          =
          function(param)
           {var _aVq_=from(f),e$0=enum$0(_aVq_);
            e[2] = e$0[2];
            e[3] = e$0[3];
            e[1] = function(param){force(e);return caml_call1(e[1],0)};
            e[4] = e$0[4];
            return caml_call1(e[3],0)};
          return e},
       of_enum=
        function(t)
         {try
           {var _aVm_=0,_aVn_=t[2],_aVo_=[0,caml_call1(_aVn_,_aVm_)];
            return _aVo_}
          catch(_aVp_)
           {_aVp_ = caml_wrap_exception(_aVp_);
            if(_aVp_ === No_more_elements)return 0;
            throw _aVp_}},
       count=function(t){return caml_call1(t[1],0)},
       clone=function(t){return caml_call1(t[3],0)},
       fold$1=
        function(f,init,t)
         {var acc=[0,init];
          function loop(param)
           {for(;;)
             {var
               _aVi_=0,
               _aVj_=t[2],
               _aVk_=caml_call1(_aVj_,_aVi_),
               _aVl_=acc[1];
              acc[1] = caml_call2(f,_aVl_,_aVk_);
              continue}}
          try
           {var _aVf_=0,_aVg_=loop(_aVf_);return _aVg_}
          catch(_aVh_)
           {_aVh_ = caml_wrap_exception(_aVh_);
            if(_aVh_ === No_more_elements)return acc[1];
            throw _aVh_}},
       symbol=
        function(f,t)
         {var _aU__=t[4];
          function _aU$_(param)
           {var _aVd_=0,_aVe_=t[3];return symbol(f,caml_call1(_aVe_,_aVd_))}
          function _aVa_(param)
           {var _aVb_=0,_aVc_=t[2];
            return caml_call1(f,caml_call1(_aVc_,_aVb_))}
          return [0,t[1],_aVa_,_aU$_,_aU__]},
       seq=
        function(init,f,cond)
         {var acc=[0,init];
          function aux(param)
           {var _aU8_=acc[1];
            if(caml_call1(cond,_aU8_))
             {var result=acc[1],_aU9_=acc[1];
              acc[1] = caml_call1(f,_aU9_);
              return result}
            throw No_more_elements}
          return from$0(aux)},
       print_common=
        function(first,last,sep,limit,print_a,out,e)
         {output_string$0(out,first);
          var match=of_enum(e);
          if(match)
           {var x=match[1];
            caml_call2(print_a,out,x);
            var
             aux=
              function(limit)
               {var limit$0=limit;
                for(;;)
                 {var match=of_enum(e);
                  if(match)
                   {var _aU7_=match[1];
                    if(0 === limit$0)
                     {output_string$0(out,_hm_);return output_string$0(out,last)}
                    output_string$0(out,sep);
                    caml_call2(print_a,out,_aU7_);
                    var limit$1=limit$0 - 1 | 0,limit$0=limit$1;
                    continue}
                  return output_string$0(out,last)}};
            return aux(limit - 1 | 0)}
          return output_string$0(out,last)},
       print=
        function(opt,_aU6_,_aU5_,print_a,out,e)
         {if(opt)var sth=opt[1],first=sth;else var first=_hp_;
          if(_aU6_)var sth$0=_aU6_[1],last=sth$0;else var last=_ho_;
          if(_aU5_)var sth$1=_aU5_[1],sep=sth$1;else var sep=_hn_;
          return print_common(first,last,sep,max_num,print_a,out,e)},
       to_object=function _aU4_(_aU3_){return _aU4_.fun(_aU3_)},
       _hq_=[0,0,0,0];
      caml_update_dummy
       (to_object,
        function(t)
         {if(! _hq_[1])
           {var
             _aUR_=create_table(shared),
             _aUS_=new_variable(_aUR_,_hr_),
             _aUT_=get_method_labels(_aUR_,_hj_),
             _aUU_=_aUT_[1],
             _aUV_=_aUT_[2],
             _aUW_=_aUT_[3],
             _aUX_=
              function(self_1)
               {var env=self_1[1 + _aUS_],_aU2_=env[1];
                return caml_call1(to_object,clone(_aU2_))},
             _aUY_=
              function(self_1){var env=self_1[1 + _aUS_];return count(env[1])};
            set_methods
             (_aUR_,
              [0,
               _aUU_,
               function(self_1)
                {var env=self_1[1 + _aUS_];return caml_call1(env[1][2],0)},
               _aUV_,
               _aUY_,
               _aUW_,
               _aUX_]);
            var
             _aUZ_=
              function(_aU0_)
               {var _aU1_=create_object_opt(0,_aUR_);
                _aU1_[1 + _aUS_] = _aU0_;
                return _aU1_};
            init_class(_aUR_);
            _hq_[1] = _aUZ_}
          return caml_call1(_hq_[1],[0,t])});
      var
       is_whitespace=
        function(param)
         {var switch$0=0;
          if(14 <= param)
           {if(26 === param || 32 === param)switch$0 = 1}
          else
           if(11 !== param && 9 <= param)switch$0 = 1;
          return switch$0?1:0},
       equal$2=function(a,b){return 0 === compare$0(a,b)?1:0},
       split_on_char=
        function(sep,str)
         {if(caml_string_equal(str,_hs_))return _ht_;
          function loop(acc,ofs,limit)
           {var acc$0=acc,ofs$0=ofs,limit$0=limit;
            for(;;)
             {if(0 <= ofs$0)
               {if(caml_string_unsafe_get(str,ofs$0) !== sep)
                 {var ofs$1=ofs$0 - 1 | 0,ofs$0=ofs$1;continue}
                var
                 ofs$2=ofs$0 - 1 | 0,
                 _aUO_=(limit$0 - ofs$0 | 0) - 1 | 0,
                 _aUP_=ofs$0 + 1 | 0,
                 acc$1=[0,sub$0(str,_aUP_,_aUO_),acc$0],
                 acc$0=acc$1,
                 limit$0=ofs$0,
                 ofs$0=ofs$2;
                continue}
              var _aUQ_=0;
              return [0,sub$0(str,_aUQ_,limit$0),acc$0]}}
          var len=caml_ml_string_length(str);
          return loop(0,len - 1 | 0,len)},
       unsafe_slice=
        function(i,j,s)
         {if(! (j <= i) && i !== caml_ml_string_length(s))
           return sub$0(s,i,j - i | 0);
          return _hu_},
       trim=
        function(s)
         {var len=caml_ml_string_length(s);
          function aux_1(i)
           {var i$0=i;
            for(;;)
             {if(i$0 === len)return 0;
              var _aUN_=caml_string_unsafe_get(s,i$0);
              if(is_whitespace(_aUN_)){var i$1=i$0 + 1 | 0,i$0=i$1;continue}
              return [0,i$0]}}
          var _aUK_=0,match=aux_1(_aUK_);
          if(match)
           {var
             last_leading_whitespace=match[1],
             aux_2=
              function(i)
               {var i$0=i;
                for(;;)
                 {if(0 <= i$0)
                   {var _aUM_=caml_string_unsafe_get(s,i$0);
                    if(is_whitespace(_aUM_))
                     {var i$1=i$0 - 1 | 0,i$0=i$1;continue}
                    return i$0}
                  throw [0,Assert_failure,_hv_]}},
             _aUL_=len - 1 | 0,
             first_trailing_whitespace=aux_2(_aUL_);
            return unsafe_slice
                    (last_leading_whitespace,
                     first_trailing_whitespace + 1 | 0,
                     s)}
          return _hw_},
       is_empty$1=function(s){return 0 === caml_ml_string_length(s)?1:0},
       index_of_int=
        function(i)
         {if(0 <= i)return i;
          var _aUJ_=to_string(i);
          return failwith(cat(_hx_,_aUJ_))},
       add_int_index=function(i,idx){return index_of_int(i + idx | 0)},
       _hy_=1,
       succ_index=function(_aUI_){return add_int_index(_hy_,_aUI_)},
       length$4=
        function(fmt){return caml_ml_string_length(unsafe_to_string(fmt))},
       get$2=
        function(fmt,i)
         {var _aUH_=unsafe_to_string(fmt);return caml_string_get(_aUH_,i)},
       unsafe_get=
        function(fmt,i)
         {return caml_string_unsafe_get(unsafe_to_string(fmt),i)},
       sub$3=
        function(fmt,idx,len){return sub$0(unsafe_to_string(fmt),idx,len)},
       to_string$6=function(fmt){return sub$3(fmt,0,length$4(fmt))},
       bad_conversion=
        function(sfmt,i,c)
         {var
           _aUz_=cat(sfmt,_hz_),
           _aUA_=cat(_hA_,_aUz_),
           _aUB_=to_string(i),
           _aUC_=cat(_aUB_,_aUA_),
           _aUD_=cat(_hB_,_aUC_),
           _aUE_=1,
           _aUF_=make$1(_aUE_,c),
           _aUG_=cat(_aUF_,_aUD_);
          return invalid_arg(cat(_hC_,_aUG_))},
       bad_conversion_format=
        function(fmt,i,c){return bad_conversion(to_string$6(fmt),i,c)},
       incomplete_format=
        function(fmt)
         {var _aUx_=to_string$6(fmt),_aUy_=cat(_aUx_,_hD_);
          return invalid_arg(cat(_hE_,_aUy_))},
       parse_string_conversion=
        function(sfmt)
         {function parse(neg,i)
           {var neg$0=neg,i$0=i;
            for(;;)
             {if(caml_ml_string_length(sfmt) <= i$0)return [0,0,neg$0];
              var match=caml_string_unsafe_get(sfmt,i$0);
              if(49 <= match)
               {if(! (58 <= match))
                 {var
                   _aUv_=(caml_ml_string_length(sfmt) - i$0 | 0) - 1 | 0,
                   _aUw_=sub$0(sfmt,i$0,_aUv_);
                  return [0,caml_int_of_string(_aUw_),neg$0]}}
              else
               if(45 === match){var i$2=i$0 + 1 | 0,neg$0=1,i$0=i$2;continue}
              var i$1=i$0 + 1 | 0,i$0=i$1;
              continue}}
          try
           {var _aUr_=1,_aUs_=0,_aUt_=parse(_aUs_,_aUr_);return _aUt_}
          catch(_aUu_)
           {_aUu_ = caml_wrap_exception(_aUu_);
            if(_aUu_[1] === Failure)return bad_conversion(sfmt,0,115);
            throw _aUu_}},
       pad_string=
        function(pad_char,p,neg,s,i,len)
         {if(p === len && 0 === i)return s;
          if(p <= len)return sub$0(s,i,len);
          var res=make$0(p,pad_char);
          if(neg)
           {var _aUp_=0;blit$0(s,i,res,_aUp_,len)}
          else
           {var _aUq_=p - len | 0;blit$0(s,i,res,_aUq_,len)}
          return usob(res)},
       format_string$0=
        function(sfmt,s)
         {var match=parse_string_conversion(sfmt),neg=match[2],p=match[1];
          return pad_string(32,p,neg,s,0,caml_ml_string_length(s))},
       extract_format=
        function(fmt,start,stop,widths)
         {var
           start$0=start + 1 | 0,
           _aUk_=(stop - start$0 | 0) + 10 | 0,
           b=create$1(_aUk_),
           _aUl_=37;
          add_char(b,_aUl_);
          function fill_format(i,widths)
           {var i$0=i,widths$0=widths;
            for(;;)
             {var _aUn_=i$0 <= stop?1:0;
              if(_aUn_)
               {var match=unsafe_get(fmt,i$0);
                if(42 === match)
                 {if(widths$0)
                   {var t=widths$0[2],h=widths$0[1],_aUo_=to_string(h);
                    add_string(b,_aUo_);
                    var i$1=i$0 + 1 | 0,i$0=i$1,widths$0=t;
                    continue}
                  throw [0,Assert_failure,_hF_]}
                add_char(b,match);
                var i$2=i$0 + 1 | 0,i$0=i$2;
                continue}
              return _aUn_}}
          var _aUm_=rev(widths);
          fill_format(start$0,_aUm_);
          return contents(b)},
       extract_format_int=
        function(conv,fmt,start,stop,widths)
         {var sfmt=extract_format(fmt,start,stop,widths);
          if(78 !== conv && 110 !== conv)return sfmt;
          var
           sfmt$0=to_bytes(sfmt),
           _aUj_=caml_ml_bytes_length(sfmt$0) - 1 | 0;
          caml_bytes_set(sfmt$0,_aUj_,117);
          return usob(sfmt$0)},
       sub_format$0=
        function(incomplete_format,bad_conversion_format,conv,fmt,i)
         {var len=length$4(fmt);
          function sub_fmt(c,i)
           {var close=40 === c?41:125;
            function sub$0(counter,j)
             {var j$0=j;
              for(;;)
               {if(len <= j$0)return caml_call1(incomplete_format,fmt);
                var match=get$2(fmt,j$0);
                if(37 === match)
                 {var _aUi_=j$0 + 1 | 0;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return sub_sub(counter$0,_aUi_)}
                  return caml_trampoline_return(sub_sub,[0,_aUi_])}
                var j$1=j$0 + 1 | 0,j$0=j$1;
                continue}}
            function sub_sub(counter,j)
             {if(len <= j)return caml_call1(incomplete_format,fmt);
              var c=get$2(fmt,j),_aUd_=c - 40 | 0,switch$0=0;
              if(1 < _aUd_ >>> 0)
               {var _aUe_=_aUd_ - 83 | 0,switch$1=0;
                if(! (2 < _aUe_ >>> 0))
                 switch(_aUe_)
                  {case 0:switch$1 = 1;break;
                   case 1:break;
                   default:switch$0 = 1;switch$1 = 1}
                if(! switch$1)
                 {var _aUf_=j + 1 | 0;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return sub$0(counter$0,_aUf_)}
                  return caml_trampoline_return(sub$0,[0,_aUf_])}}
              else
               if(_aUd_)switch$0 = 1;
              if(switch$0)
               return c === close
                       ?j + 1 | 0
                       :caml_call3(bad_conversion_format,fmt,i,c);
              var _aUg_=j + 1 | 0,j$0=sub_fmt(c,_aUg_),_aUh_=j$0 + 1 | 0;
              if(counter < 50)
               {var counter$1=counter + 1 | 0;return sub$0(counter$1,_aUh_)}
              return caml_trampoline_return(sub$0,[0,_aUh_])}
            function sub(j){return caml_trampoline(sub$0(0,j))}
            return sub(i)}
          return sub_fmt(conv,i)},
       sub_format_for_printf=
        function(conv)
         {return function(_aUb_,_aUc_)
           {return sub_format$0
                    (incomplete_format,bad_conversion_format,conv,_aUb_,_aUc_)}},
       iter_on_format_args=
        function(fmt,add_conv,add_char)
         {var lim=length$4(fmt) - 1 | 0;
          function scan_flags(skip,i)
           {var skip$0=skip,i$0=i;
            for(;;)
             {if(lim < i$0)return incomplete_format(fmt);
              var match=unsafe_get(fmt,i$0);
              if(58 <= match)
               {if(95 === match)
                 {var i$1=i$0 + 1 | 0,skip$0=1,i$0=i$1;continue}}
              else
               if(32 <= match)
                switch(match - 32 | 0)
                 {case 10:
                   var
                    _aUa_=105,
                    i$3=caml_call3(add_conv,skip$0,i$0,_aUa_),
                    i$0=i$3;
                   continue;
                  case 0:
                  case 3:
                  case 11:
                  case 13:var i$2=i$0 + 1 | 0,i$0=i$2;continue;
                  case 1:
                  case 2:
                  case 4:
                  case 5:
                  case 6:
                  case 7:
                  case 8:
                  case 9:
                  case 12:
                  case 15:break;
                  default:var i$4=i$0 + 1 | 0,i$0=i$4;continue}
              return scan_conv(skip$0,i$0)}}
          function scan_conv(skip,i)
           {var i$0=i;
            for(;;)
             {if(lim < i$0)return incomplete_format(fmt);
              var conv=unsafe_get(fmt,i$0);
              if(! (126 <= conv))
               switch(conv)
                {case 40:return scan_fmt(caml_call3(add_conv,skip,i$0,conv));
                 case 123:
                  var
                   i$1=caml_call3(add_conv,skip,i$0,conv),
                   j$0=caml_call2(sub_format_for_printf(conv),fmt,i$1),
                   loop$0=
                    function(j)
                     {function loop(i)
                       {var i$0=i;
                        for(;;)
                         {var _aT__=i$0 < (j - 2 | 0)?1:0;
                          if(_aT__)
                           {var
                             _aT$_=get$2(fmt,i$0),
                             i$1=caml_call2(add_char,i$0,_aT$_),
                             i$0=i$1;
                            continue}
                          return _aT__}}
                      return loop},
                   loop=loop$0(j$0);
                  loop(i$1);
                  var i$2=j$0 - 1 | 0,i$0=i$2;
                  continue;
                 case 67:
                 case 99:return caml_call3(add_conv,skip,i$0,99);
                 case 66:
                 case 98:return caml_call3(add_conv,skip,i$0,66);
                 case 41:
                 case 125:return caml_call3(add_conv,skip,i$0,conv);
                 case 33:
                 case 37:
                 case 44:return i$0 + 1 | 0;
                 case 83:
                 case 91:
                 case 115:return caml_call3(add_conv,skip,i$0,115);
                 case 97:
                 case 114:
                 case 116:return caml_call3(add_conv,skip,i$0,conv);
                 case 76:
                 case 108:
                 case 110:
                  var j=i$0 + 1 | 0;
                  if(lim < j)return caml_call3(add_conv,skip,i$0,105);
                  var c=get$2(fmt,j),_aT8_=c - 88 | 0;
                  if(! (32 < _aT8_ >>> 0))
                   switch(_aT8_)
                    {case 0:
                     case 12:
                     case 17:
                     case 23:
                     case 29:
                     case 32:
                      var _aT9_=105;
                      return caml_call2
                              (add_char,caml_call3(add_conv,skip,i$0,conv),_aT9_)
                     }
                  return caml_call3(add_conv,skip,i$0,105);
                 case 69:
                 case 70:
                 case 71:
                 case 101:
                 case 102:
                 case 103:return caml_call3(add_conv,skip,i$0,102);
                 case 78:
                 case 88:
                 case 100:
                 case 105:
                 case 111:
                 case 117:
                 case 120:return caml_call3(add_conv,skip,i$0,105)
                 }
              return bad_conversion_format(fmt,i$0,conv)}}
          function scan_fmt(i)
           {var i$0=i;
            for(;;)
             {if(i$0 < lim)
               {if(37 === get$2(fmt,i$0))
                 {var
                   _aT6_=i$0 + 1 | 0,
                   _aT7_=0,
                   i$1=scan_flags(_aT7_,_aT6_),
                   i$0=i$1;
                  continue}
                var i$2=i$0 + 1 | 0,i$0=i$2;
                continue}
              return i$0}}
          var _aT5_=0;
          scan_fmt(_aT5_);
          return 0},
       summarize_format_type=
        function(fmt)
         {var len=length$4(fmt),b=create$1(len);
          function add_char$0(i,c){add_char(b,c);return i + 1 | 0}
          function add_conv(skip,i,c)
           {if(skip)add_string(b,_hG_);else{var _aT4_=37;add_char(b,_aT4_)}
            return add_char$0(i,c)}
          iter_on_format_args(fmt,add_conv,add_char$0);
          return contents(b)},
       ac_of_format=
        function(fmt)
         {var ac=[0,0,0,0];
          function incr_ac(skip,c)
           {var inc=97 === c?2:1;
            if(114 === c)ac[3] = ac[3] + 1 | 0;
            return skip
                    ?(ac[2] = ac[2] + inc | 0,0)
                    :(ac[1] = ac[1] + inc | 0,0)}
          function add_conv(skip,i,c)
           {var _aT2_=41 !== c?1:0,_aT3_=_aT2_?125 !== c?1:0:_aT2_;
            if(_aT3_)incr_ac(skip,c);
            return i + 1 | 0}
          function add_char(i,c){return i + 1 | 0}
          iter_on_format_args(fmt,add_conv,add_char);
          return ac},
       count_arguments_of_format=
        function(fmt)
         {var ac=ac_of_format(fmt);return (ac[1] + ac[2] | 0) + ac[3] | 0},
       list_iter_i=
        function(f,l)
         {function loop(i,param)
           {var i$0=i,param$0=param;
            for(;;)
             {if(param$0)
               {var _aT1_=param$0[1];
                if(param$0[2])
                 {var xs=param$0[2];
                  caml_call2(f,i$0,_aT1_);
                  var i$1=i$0 + 1 | 0,i$0=i$1,param$0=xs;
                  continue}
                return caml_call2(f,i$0,_aT1_)}
              return 0}}
          return loop(0,l)},
       kapr=
        function(kpr,fmt)
         {var nargs=count_arguments_of_format(fmt);
          if(6 < nargs >>> 0)
           {var
             loop=
              function(i,args)
               {if(nargs <= i)
                 {var
                   a=caml_make_vect(nargs,0),
                   _aTZ_=
                    function(i,arg)
                     {var _aT0_=(nargs - i | 0) - 1 | 0;
                      caml_check_bound(a,_aT0_)[1 + _aT0_] = arg;
                      return 0};
                  list_iter_i(_aTZ_,args);
                  return caml_call2(kpr,fmt,a)}
                return function(x){return loop(i + 1 | 0,[0,x,args])}};
            return loop(0,0)}
          switch(nargs)
           {case 0:return caml_call2(kpr,fmt,[0]);
            case 1:
             return function(x)
              {var a=caml_make_vect(1,0),_aTS_=0;
               caml_check_bound(a,0)[1 + _aTS_] = x;
               return caml_call2(kpr,fmt,a)};
            case 2:
             return function(x,y)
              {var a=caml_make_vect(2,0),_aTQ_=0;
               caml_check_bound(a,0)[1 + _aTQ_] = x;
               var _aTR_=1;
               caml_check_bound(a,1)[1 + _aTR_] = y;
               return caml_call2(kpr,fmt,a)};
            case 3:
             return function(x,y,z)
              {var a=caml_make_vect(3,0),_aTN_=0;
               caml_check_bound(a,0)[1 + _aTN_] = x;
               var _aTO_=1;
               caml_check_bound(a,1)[1 + _aTO_] = y;
               var _aTP_=2;
               caml_check_bound(a,2)[1 + _aTP_] = z;
               return caml_call2(kpr,fmt,a)};
            case 4:
             return function(x,y,z,t)
              {var a=caml_make_vect(4,0),_aTJ_=0;
               caml_check_bound(a,0)[1 + _aTJ_] = x;
               var _aTK_=1;
               caml_check_bound(a,1)[1 + _aTK_] = y;
               var _aTL_=2;
               caml_check_bound(a,2)[1 + _aTL_] = z;
               var _aTM_=3;
               caml_check_bound(a,3)[1 + _aTM_] = t;
               return caml_call2(kpr,fmt,a)};
            case 5:
             return function(x,y,z,t,u)
              {var a=caml_make_vect(5,0),_aTE_=0;
               caml_check_bound(a,0)[1 + _aTE_] = x;
               var _aTF_=1;
               caml_check_bound(a,1)[1 + _aTF_] = y;
               var _aTG_=2;
               caml_check_bound(a,2)[1 + _aTG_] = z;
               var _aTH_=3;
               caml_check_bound(a,3)[1 + _aTH_] = t;
               var _aTI_=4;
               caml_check_bound(a,4)[1 + _aTI_] = u;
               return caml_call2(kpr,fmt,a)};
            default:
             return function(x,y,z,t,u,v)
              {var a=caml_make_vect(6,0),_aTT_=0;
               caml_check_bound(a,0)[1 + _aTT_] = x;
               var _aTU_=1;
               caml_check_bound(a,1)[1 + _aTU_] = y;
               var _aTV_=2;
               caml_check_bound(a,2)[1 + _aTV_] = z;
               var _aTW_=3;
               caml_check_bound(a,3)[1 + _aTW_] = t;
               var _aTX_=4;
               caml_check_bound(a,4)[1 + _aTX_] = u;
               var _aTY_=5;
               caml_check_bound(a,5)[1 + _aTY_] = v;
               return caml_call2(kpr,fmt,a)}}},
       next_index=function(n){return succ_index(n)},
       scan_format=
        function(fmt,args,n,pos,cont_s,cont_a,cont_t,cont_f,cont_m)
         {function get_arg(n){return caml_check_bound(args,n)[1 + n]}
          function scan_conv(n,widths,i)
           {var conv=unsafe_get(fmt,i);
            if(! (124 <= conv))
             switch(conv)
              {case 33:return caml_call2(cont_f,n,i + 1 | 0);
               case 37:return caml_call3(cont_s,n,_hH_,i + 1 | 0);
               case 41:return caml_call3(cont_s,n,_hI_,i + 1 | 0);
               case 44:return caml_call3(cont_s,n,_hJ_,i + 1 | 0);
               case 70:
                var x$2=get_arg(n),_aTk_=i + 1 | 0,_aTl_=to_string$0(x$2);
                return caml_call3(cont_s,next_index(n),_aTl_,_aTk_);
               case 97:
                var
                 printer=get_arg(n),
                 n$0=succ_index(n),
                 arg=get_arg(n$0),
                 _aTC_=i + 1 | 0;
                return caml_call4(cont_a,next_index(n$0),printer,arg,_aTC_);
               case 116:
                var printer$0=get_arg(n),_aTD_=i + 1 | 0;
                return caml_call3(cont_t,next_index(n),printer$0,_aTD_);
               case 83:
               case 115:
                var x$8=get_arg(n);
                if(115 === conv)
                 var x$9=x$8;
                else
                 var
                  _aTA_=escaped$1(x$8),
                  _aTB_=cat(_aTA_,_hM_),
                  x$9=cat(_hN_,_aTB_);
                if(i === (pos + 1 | 0))
                 var s$4=x$9;
                else
                 var
                  _aTz_=extract_format(fmt,pos,i,widths),
                  s$4=format_string$0(_aTz_,x$9);
                var _aTy_=i + 1 | 0;
                return caml_call3(cont_s,next_index(n),s$4,_aTy_);
               case 67:
               case 99:
                var x$0=get_arg(n);
                if(99 === conv)
                 var _aTe_=1,s=make$1(_aTe_,x$0);
                else
                 var
                  _aTg_=escaped(x$0),
                  _aTh_=cat(_aTg_,_hK_),
                  s=cat(_hL_,_aTh_);
                var _aTf_=i + 1 | 0;
                return caml_call3(cont_s,next_index(n),s,_aTf_);
               case 66:
               case 98:
                var x=get_arg(n),_aTc_=i + 1 | 0,_aTd_=string_of_bool(x);
                return caml_call3(cont_s,next_index(n),_aTd_,_aTc_);
               case 40:
               case 123:
                var
                 xf=get_arg(n),
                 i$0=i + 1 | 0,
                 j=caml_call2(sub_format_for_printf(conv),fmt,i$0);
                if(123 === conv)
                 {var _aTb_=summarize_format_type(xf);
                  return caml_call3(cont_s,next_index(n),_aTb_,j)}
                return caml_call3(cont_m,next_index(n),xf,j);
               case 76:
               case 108:
               case 110:
                var
                 _aTm_=i + 1 | 0,
                 match=unsafe_get(fmt,_aTm_),
                 _aTn_=match - 88 | 0;
                if(! (32 < _aTn_ >>> 0))
                 switch(_aTn_)
                  {case 0:
                   case 12:
                   case 17:
                   case 23:
                   case 29:
                   case 32:
                    var i$1=i + 1 | 0,switcher=conv - 108 | 0,switch$0=0;
                    if(! (2 < switcher >>> 0))
                     {var switch$1=0;
                      switch(switcher)
                       {case 0:
                         var
                          x$5=get_arg(n),
                          _aTt_=extract_format(fmt,pos,i$1,widths),
                          _aTu_=caml_format_int(_aTt_,x$5);
                         break;
                        case 1:switch$1 = 1;break;
                        default:
                         var
                          x$6=get_arg(n),
                          _aTv_=extract_format(fmt,pos,i$1,widths),
                          _aTu_=caml_format_int(_aTv_,x$6)}
                      if(! switch$1){var s$2=_aTu_;switch$0 = 1}}
                    if(! switch$0)
                     var
                      x$4=get_arg(n),
                      _aTr_=extract_format(fmt,pos,i$1,widths),
                      s$2=caml_int64_format(_aTr_,x$4);
                    var _aTs_=i$1 + 1 | 0;
                    return caml_call3(cont_s,next_index(n),s$2,_aTs_)
                   }
                var
                 x$3=get_arg(n),
                 _aTo_=110,
                 _aTp_=extract_format_int(_aTo_,fmt,pos,i,widths),
                 s$1=caml_format_int(_aTp_,x$3),
                 _aTq_=i + 1 | 0;
                return caml_call3(cont_s,next_index(n),s$1,_aTq_);
               case 69:
               case 71:
               case 101:
               case 102:
               case 103:
                var
                 x$1=get_arg(n),
                 _aTi_=extract_format(fmt,pos,i,widths),
                 s$0=caml_format_float(_aTi_,x$1),
                 _aTj_=i + 1 | 0;
                return caml_call3(cont_s,next_index(n),s$0,_aTj_);
               case 78:
               case 88:
               case 100:
               case 105:
               case 111:
               case 117:
               case 120:
                var
                 x$7=get_arg(n),
                 _aTw_=extract_format_int(conv,fmt,pos,i,widths),
                 s$3=caml_format_int(_aTw_,x$7),
                 _aTx_=i + 1 | 0;
                return caml_call3(cont_s,next_index(n),s$3,_aTx_)
               }
            return bad_conversion_format(fmt,i,conv)}
          function scan_flags(n,widths,i)
           {var n$0=n,widths$0=widths,i$0=i;
            for(;;)
             {var match=unsafe_get(fmt,i$0),switcher=match - 32 | 0;
              if(! (25 < switcher >>> 0))
               switch(switcher)
                {case 10:
                  var
                   width=get_arg(n$0),
                   i$2=i$0 + 1 | 0,
                   widths$1=[0,width,widths$0],
                   n$1=next_index(n$0),
                   n$0=n$1,
                   widths$0=widths$1,
                   i$0=i$2;
                  continue;
                 case 1:
                 case 2:
                 case 4:
                 case 5:
                 case 6:
                 case 7:
                 case 8:
                 case 9:
                 case 12:
                 case 15:break;
                 default:var i$1=i$0 + 1 | 0,i$0=i$1;continue}
              return scan_conv(n$0,widths$0,i$0)}}
          return scan_flags(n,0,pos + 1 | 0)},
       mkprintf=
        function(k,out,fmt)
         {function pr(k,n,fmt,v)
           {var len=length$4(fmt);
            function doprn(n,i)
             {var i$0=i;
              for(;;)
               {if(len <= i$0)return caml_call1(k,out);
                var c=unsafe_get(fmt,i$0);
                if(37 === c)
                 return scan_format
                         (fmt,v,n,i$0,cont_s,cont_a,cont_t,cont_f,cont_m);
                write(out,c);
                var i$1=i$0 + 1 | 0,i$0=i$1;
                continue}}
            function cont_s(n,s,i){output_string$0(out,s);return doprn(n,i)}
            function cont_a(n,printer,arg,i)
             {caml_call2(printer,out,arg);return doprn(n,i)}
            function cont_t(n,printer,i)
             {caml_call1(printer,out);return doprn(n,i)}
            function cont_f(n,i){flush$0(out);return doprn(n,i)}
            function cont_m(n,xf,i)
             {var
               _aTa_=count_arguments_of_format(xf),
               m=add_int_index(_aTa_,n);
              return pr(function(param){return doprn(m,i)},n,xf,v)}
            return doprn(n,0)}
          var _aS8_=0,_aS9_=index_of_int(_aS8_);
          function kpr(_aS__,_aS$_){return pr(k,_aS9_,_aS__,_aS$_)}
          return kapr(kpr,fmt)},
       fprintf$0=
        function(out,fmt){return mkprintf(function(_aS7_){return 0},out,fmt)},
       may=
        function(f,param)
         {if(param){var v=param[1];return caml_call1(f,v)}return 0},
       map$3=
        function(f,param)
         {if(param){var v=param[1];return [0,caml_call1(f,v)]}return 0},
       default$0=
        function(v,param){if(param){var v$0=param[1];return v$0}return v},
       default_delayed=
        function(l,param)
         {if(param){var v=param[1];return v}return caml_call1(l,0)},
       is_some=function(param){return param?1:0},
       is_none=function(param){return param?0:1},
       get_exn=function(s,e){if(s){var v=s[1];return v}throw e},
       get$3=function(s){return get_exn(s,[0,Invalid_argument,_hO_])},
       map_default=
        function(f,v,param)
         {if(param){var v2=param[1];return caml_call1(f,v2)}return v},
       _hP_=8,
       buf=create$1(_hP_),
       print_bchar=
        function(c)
         {var rc=[0,c];
          clear$1(buf);
          var i=1;
          for(;;)
           {var _aS5_=1 === (rc[1] & 1)?49:48;
            add_char(buf,_aS5_);
            rc[1] = rc[1] >>> 1 | 0;
            var _aS6_=i + 1 | 0;
            if(8 !== i){var i=_aS6_;continue}
            return contents(buf)}},
       _hQ_=256;
      init(_hQ_,print_bchar);
      var
       count_bits=
        function(i)
         {if(0 === i)return 0;
          var _aS3_=i % 2 | 0,_aS4_=i / 2 | 0;
          return count_bits(_aS4_) + _aS3_ | 0},
       _hR_=256;
      init(_hR_,count_bits);
      var
       mk=
        function(c)
         {var arr=caml_make_vect(8,-1);
          function mk(last_set_bit,i,v)
           {var last_set_bit$0=last_set_bit,i$0=i,v$0=v;
            for(;;)
             {var _aS2_=0 <= i$0?1:0;
              if(_aS2_)
               {var last_set_bit$1=0 === (v$0 & 128)?last_set_bit$0:i$0;
                caml_check_bound(arr,i$0)[1 + i$0] = last_set_bit$1;
                var
                 v$1=v$0 << 1,
                 i$1=i$0 - 1 | 0,
                 last_set_bit$0=last_set_bit$1,
                 i$0=i$1,
                 v$0=v$1;
                continue}
              return _aS2_}}
          var _aS0_=7,_aS1_=-1;
          mk(_aS1_,_aS0_,c);
          return arr},
       _hS_=256;
      init(_hS_,mk);
      var
       Wrapped_in=Make$5([0,equal$0,hash$0]),
       Wrapped_out=Make$5([0,equal$1,hash$1]),
       _hT_=16,
       _hU_=Wrapped_in[1],
       wrapped_in=caml_call1(_hU_,_hT_),
       _hV_=16,
       _hW_=Wrapped_out[1],
       wrapped_out=caml_call1(_hW_,_hV_),
       input_add=
        function(k,v)
         {var _aSY_=Wrapped_in[5],_aSZ_=caml_call2(_aSY_,wrapped_in,k);
          return caml_call2(sync(nolock),_aSZ_,v)},
       output_add=
        function(k,v)
         {var _aSW_=Wrapped_out[5],_aSX_=caml_call2(_aSW_,wrapped_out,k);
          return caml_call2(sync(nolock),_aSX_,v)};
      input_add(stdin$0,stdin);
      output_add(stdout$0,stdout);
      output_add(stderr$0,stderr);
      make_class
       (shared$0,
        function(_aSM_)
         {var
           _aSN_=new_variable(_aSM_,_h2_),
           _aSO_=get_method_labels(_aSM_,_h0_),
           _aSP_=_aSO_[1],
           _aSQ_=_aSO_[2];
          function _aSR_(self_1,param){return close_in$0(self_1[1 + _aSN_])}
          set_methods
           (_aSM_,
            [0,
             _aSP_,
             function(self_1,s,pos,len)
              {return input$0(self_1[1 + _aSN_],s,pos,len)},
             _aSQ_,
             _aSR_]);
          return function(_aSU_,_aST_,_aSS_)
           {var _aSV_=create_object_opt(_aST_,_aSM_);
            _aSV_[1 + _aSN_] = _aSS_;
            return _aSV_}});
      make_class
       (_hX_,
        function(_aSz_)
         {var
           _aSA_=new_variable(_aSz_,_h3_),
           _aSB_=get_method_labels(_aSz_,_hY_),
           _aSC_=_aSB_[1],
           _aSD_=_aSB_[2],
           _aSE_=_aSB_[3];
          function _aSF_(self_2,param)
           {var _aSL_=self_2[1 + _aSA_];close_out$0(_aSL_);return 0}
          function _aSG_(self_2,param){return flush$0(self_2[1 + _aSA_])}
          set_methods
           (_aSz_,
            [0,
             _aSC_,
             function(self_2,s,pos,len)
              {return output$0(self_2[1 + _aSA_],s,pos,len)},
             _aSD_,
             _aSG_,
             _aSE_,
             _aSF_]);
          return function(_aSJ_,_aSI_,_aSH_)
           {var _aSK_=create_object_opt(_aSI_,_aSz_);
            _aSK_[1 + _aSA_] = _aSH_;
            return _aSK_}});
      make_class
       (_h1_,
        function(_aSm_)
         {var
           _aSn_=new_variable(_aSm_,_h4_),
           _aSo_=get_method_labels(_aSm_,_h1_),
           _aSp_=_aSo_[1],
           _aSq_=_aSo_[2];
          function _aSr_(self_3,param){return close_in$0(self_3[1 + _aSn_])}
          set_methods
           (_aSm_,
            [0,
             _aSp_,
             function(self_3,param)
              {try
                {var _aSw_=self_3[1 + _aSn_],_aSx_=read$0(_aSw_);return _aSx_}
               catch(_aSy_)
                {_aSy_ = caml_wrap_exception(_aSy_);
                 if(_aSy_ === No_more_input)throw End_of_file;
                 throw _aSy_}},
             _aSq_,
             _aSr_]);
          return function(_aSu_,_aSt_,_aSs_)
           {var _aSv_=create_object_opt(_aSt_,_aSm_);
            _aSv_[1 + _aSn_] = _aSs_;
            return _aSv_}});
      make_class
       (_hZ_,
        function(_aR$_)
         {var
           _aSa_=new_variable(_aR$_,_h5_),
           _aSb_=get_method_labels(_aR$_,_hZ_),
           _aSc_=_aSb_[1],
           _aSd_=_aSb_[2],
           _aSe_=_aSb_[3];
          function _aSf_(self_4,param)
           {var _aSl_=self_4[1 + _aSa_];close_out$0(_aSl_);return 0}
          function _aSg_(self_4,param){return flush$0(self_4[1 + _aSa_])}
          set_methods
           (_aR$_,
            [0,
             _aSc_,
             function(self_4,t){return write(self_4[1 + _aSa_],t)},
             _aSd_,
             _aSg_,
             _aSe_,
             _aSf_]);
          return function(_aSj_,_aSi_,_aSh_)
           {var _aSk_=create_object_opt(_aSi_,_aR$_);
            _aSk_[1 + _aSa_] = _aSh_;
            return _aSk_}});
      var
       MakeInfix=
        function(Base)
         {var
           symbol=Base[12],
           symbol$0=Base[10],
           symbol$1=Base[9],
           symbol$2=Base[8],
           symbol$3=Base[7];
          function symbol$4(x,y)
           {function _aR9_(x)
             {var _aR__=Base[13];return caml_call2(_aR__,x,y) <= 0?1:0}
            return seq(x,Base[4],_aR9_)}
          function symbol$5(x,y)
           {var _aR6_=Base[13];
            if(0 < caml_call2(_aR6_,x,y))
             {var
               _aR7_=
                function(x)
                 {var _aR8_=Base[13];return 0 <= caml_call2(_aR8_,x,y)?1:0};
              return seq(x,Base[5],_aR7_)}
            return symbol$4(x,y)}
          return [0,
                  symbol$3,
                  symbol$2,
                  symbol$1,
                  symbol$0,
                  symbol,
                  symbol$4,
                  symbol$5]},
       MakeCompare=
        function(Base)
         {function symbol(a,b)
           {var _aR5_=Base[13];return 0 === caml_call2(_aR5_,a,b)?1:0}
          function symbol$0(a,b)
           {var _aR4_=Base[13];return caml_call2(_aR4_,a,b) < 0?1:0}
          function symbol$1(a,b)
           {var _aR3_=Base[13];return 0 < caml_call2(_aR3_,a,b)?1:0}
          function symbol$2(a,b)
           {var _aR2_=Base[13];return caml_call2(_aR2_,a,b) <= 0?1:0}
          function symbol$3(a,b)
           {var _aR1_=Base[13];return 0 <= caml_call2(_aR1_,a,b)?1:0}
          function symbol$4(a,b)
           {var _aR0_=Base[13];return 0 !== caml_call2(_aR0_,a,b)?1:0}
          return [0,symbol$4,symbol$3,symbol$2,symbol$1,symbol$0,symbol]},
       MakeRefOps=
        function(Base)
         {function symbol(a,b)
           {var _aRY_=a[1],_aRZ_=Base[7];
            a[1] = caml_call2(_aRZ_,_aRY_,b);
            return 0}
          function symbol$0(a,b)
           {var _aRW_=a[1],_aRX_=Base[8];
            a[1] = caml_call2(_aRX_,_aRW_,b);
            return 0}
          function symbol$1(a,b)
           {var _aRU_=a[1],_aRV_=Base[9];
            a[1] = caml_call2(_aRV_,_aRU_,b);
            return 0}
          function symbol$2(a,b)
           {var _aRS_=a[1],_aRT_=Base[10];
            a[1] = caml_call2(_aRT_,_aRS_,b);
            return 0}
          return [0,symbol,symbol$0,symbol$1,symbol$2]},
       MakeNumeric=
        function(Base)
         {var
           zero=Base[1],
           one=Base[2],
           neg=Base[3],
           succ=Base[4],
           pred=Base[5],
           abs=Base[6],
           add=Base[7],
           sub=Base[8],
           mul=Base[9],
           div=Base[10],
           modulo=Base[11],
           pow=Base[12],
           compare=Base[13],
           of_int=Base[14],
           to_int=Base[15],
           of_string=Base[16],
           to_string=Base[17],
           of_float=Base[18],
           to_float=Base[19],
           operations=
            [0,
             Base[1],
             Base[2],
             Base[3],
             Base[4],
             Base[5],
             Base[6],
             Base[7],
             Base[8],
             Base[9],
             Base[10],
             Base[11],
             Base[12],
             Base[13],
             Base[14],
             Base[15],
             Base[16],
             Base[17],
             Base[18],
             Base[19]];
          function equal(x,y)
           {var _aRR_=Base[13];return 0 === caml_call2(_aRR_,x,y)?1:0}
          function ord(x,y)
           {var _aRQ_=Base[13];return ord0(caml_call2(_aRQ_,x,y))}
          var
           Infix=MakeInfix(Base),
           Compare=MakeCompare(Base),
           symbol=Infix[1],
           symbol$0=Infix[2],
           symbol$1=Infix[3],
           symbol$2=Infix[4],
           symbol$3=Infix[5],
           symbol$4=Infix[6],
           symbol$5=Infix[7],
           include=MakeRefOps(Base),
           symbol$6=include[1],
           symbol$7=include[2],
           symbol$8=include[3],
           symbol$9=include[4];
          return [0,
                  zero,
                  one,
                  neg,
                  abs,
                  add,
                  sub,
                  mul,
                  div,
                  modulo,
                  pow,
                  compare,
                  equal,
                  ord,
                  of_int,
                  to_int,
                  of_float,
                  to_float,
                  of_string,
                  to_string,
                  operations,
                  succ,
                  pred,
                  Infix,
                  Compare,
                  symbol,
                  symbol$0,
                  symbol$1,
                  symbol$2,
                  symbol$3,
                  symbol$4,
                  symbol$5,
                  symbol$6,
                  symbol$7,
                  symbol$8,
                  symbol$9]},
       generic_pow=
        function(zero,one,div_two,mod_two,symbol,a,n)
         {function pow(a,n)
           {if(caml_equal(n,zero))return one;
            if(caml_equal(n,one))return a;
            var
             _aRO_=caml_call1(div_two,n),
             b=pow(a,_aRO_),
             _aRP_=caml_call1(mod_two,n),
             one$0=caml_equal(_aRP_,zero)?one:a;
            return caml_call2(symbol,caml_call2(symbol,b,b),one$0)}
          return caml_lessthan(n,zero)?invalid_arg(_h6_):pow(a,n)},
       Overflow=[248,_h7_,caml_fresh_oo_id(0)],
       NaN$0=[248,_h8_,caml_fresh_oo_id(0)],
       compare$7=function(x,y){return y < x?1:x < y?-1:0},
       symbol$0=function(a,b){return a === b?1:0},
       _h9_=32;
      if(! symbol$0(match$0,_h9_))
       {caml_int_of_string(_wy_);
        caml_int_of_string(_wz_);
        caml_int_of_string(_wA_)}
      var
       one$2=1.,
       zero$2=0.,
       neg=function(_aRN_){return - _aRN_},
       succ$2=function(x){return x + 1.},
       pred$2=function(x){return x - 1.},
       abs$3=function(_aRM_){return Math.abs(_aRM_)},
       div=function(_aRL_,_aRK_){return _aRL_ / _aRK_},
       mul=function(_aRJ_,_aRI_){return _aRJ_ * _aRI_},
       sub$4=function(_aRH_,_aRG_){return _aRH_ - _aRG_},
       add$3=function(_aRF_,_aRE_){return _aRF_ + _aRE_},
       modulo=function(_aRD_,_aRC_){return _aRD_ % _aRC_},
       pow=function(_aRB_,_aRA_){return Math.pow(_aRB_,_aRA_)},
       compare$8=function(_aRz_,_aRy_){return caml_compare(_aRz_,_aRy_)},
       of_int=function(_aRx_){return _aRx_},
       to_int=function(_aRw_){return _aRw_ | 0},
       of_string=function(_aRv_){return caml_float_of_string(_aRv_)},
       _h__=function(_aRu_){return _aRu_},
       _h$_=
        MakeNumeric
          ([0,
            zero$2,
            one$2,
            neg,
            succ$2,
            pred$2,
            abs$3,
            add$3,
            sub$4,
            mul,
            div,
            modulo,
            pow,
            compare$8,
            of_int,
            to_int,
            of_string,
            to_string$0,
            function(_aRt_){return _aRt_},
            _h__])
         [11],
       if_safe=
        function(x)
         {var match=caml_classify_float(x);
          if(3 === match)throw Overflow;
          if(4 <= match)throw NaN$0;
          return 0},
       check$0=function(x){if_safe(x);return x},
       safe1=function(f,x){return check$0(caml_call1(f,x))},
       _ia_=function(_aRs_){return Math.atan(_aRs_)},
       atan=function(_aRr_){return safe1(_ia_,_aRr_)},
       _ib_=1.;
      atan(_ib_);
      var
       modulo$0=function(_aRq_,_aRp_){return caml_mod(_aRq_,_aRp_)},
       _ic_=function(_aRo_,_aRn_){return caml_mul(_aRo_,_aRn_)},
       _id_=function(_aRm_,_aRl_){return _aRm_ & _aRl_},
       _ie_=function(_aRk_){return _id_(one,_aRk_)},
       _if_=function(n){return n >> 1},
       pow$0=
        function(_aRi_,_aRj_)
         {return generic_pow(zero,one,_if_,_ie_,_ic_,_aRi_,_aRj_)},
       _ig_=function(_aRh_){return _aRh_},
       _ih_=function(_aRg_){return _aRg_ | 0},
       _ii_=function(_aRf_){return caml_int_of_string(_aRf_)},
       _ij_=function(_aRe_){return _aRe_},
       _ik_=function(_aRd_){return _aRd_},
       _il_=function(_aRc_,_aRb_){return caml_div(_aRc_,_aRb_)},
       _im_=function(_aRa_,_aQ$_){return caml_mul(_aRa_,_aQ$_)},
       _in_=function(_aQ__,_aQ9_){return _aQ__ - _aQ9_ | 0},
       _io_=function(_aQ8_,_aQ7_){return _aQ8_ + _aQ7_ | 0},
       include=
        MakeNumeric
         ([0,
           zero,
           one,
           function(_aQ6_){return - _aQ6_ | 0},
           succ,
           pred,
           abs$0,
           _io_,
           _in_,
           _im_,
           _il_,
           modulo$0,
           pow$0,
           compare$1,
           _ik_,
           _ij_,
           _ii_,
           to_string$2,
           _ih_,
           _ig_]),
       compare$9=include[11],
       modulo$1=function(_aQ5_,_aQ4_){return caml_int64_mod(_aQ5_,_aQ4_)},
       _ip_=function(_aQ3_,_aQ2_){return caml_int64_mul(_aQ3_,_aQ2_)},
       _iq_=function(_aQ1_,_aQ0_){return caml_int64_and(_aQ1_,_aQ0_)},
       _ir_=function(_aQZ_){return _iq_(one$0,_aQZ_)},
       _is_=function(n){return caml_int64_shift_right(n,1)},
       pow$1=
        function(_aQX_,_aQY_)
         {return generic_pow(zero$0,one$0,_is_,_ir_,_ip_,_aQX_,_aQY_)},
       _it_=function(_aQW_){return caml_int64_to_float(_aQW_)},
       _iu_=function(_aQV_){return caml_int64_of_float(_aQV_)},
       _iv_=function(_aQU_){return caml_int64_of_string(_aQU_)},
       _iw_=function(_aQT_){return caml_int64_to_int32(_aQT_)},
       _ix_=function(_aQS_){return caml_int64_of_int32(_aQS_)},
       _iy_=function(_aQR_,_aQQ_){return caml_int64_div(_aQR_,_aQQ_)},
       _iz_=function(_aQP_,_aQO_){return caml_int64_mul(_aQP_,_aQO_)},
       _iA_=function(_aQN_,_aQM_){return caml_int64_sub(_aQN_,_aQM_)},
       _iB_=function(_aQL_,_aQK_){return caml_int64_add(_aQL_,_aQK_)},
       include$0=
        MakeNumeric
         ([0,
           zero$0,
           one$0,
           function(_aQJ_){return caml_int64_neg(_aQJ_)},
           succ$0,
           pred$0,
           abs$1,
           _iB_,
           _iA_,
           _iz_,
           _iy_,
           modulo$1,
           pow$1,
           compare$2,
           _ix_,
           _iw_,
           _iv_,
           to_string$3,
           _iu_,
           _it_]),
       compare$10=include$0[11],
       modulo$2=function(_aQI_,_aQH_){return caml_mod(_aQI_,_aQH_)},
       _iC_=function(_aQG_,_aQF_){return caml_mul(_aQG_,_aQF_)},
       _iD_=function(_aQE_,_aQD_){return _aQE_ & _aQD_},
       _iE_=function(_aQC_){return _iD_(one$1,_aQC_)},
       _iF_=function(n){return n >> 1},
       pow$2=
        function(_aQA_,_aQB_)
         {return generic_pow(zero$1,one$1,_iF_,_iE_,_iC_,_aQA_,_aQB_)},
       _iG_=function(_aQz_){return _aQz_},
       _iH_=function(_aQy_){return _aQy_ | 0},
       _iI_=function(_aQx_){return caml_int_of_string(_aQx_)},
       _iJ_=function(_aQw_){return _aQw_},
       _iK_=function(_aQv_){return _aQv_},
       _iL_=function(_aQu_,_aQt_){return caml_div(_aQu_,_aQt_)},
       _iM_=function(_aQs_,_aQr_){return caml_mul(_aQs_,_aQr_)},
       _iN_=function(_aQq_,_aQp_){return _aQq_ - _aQp_ | 0},
       _iO_=function(_aQo_,_aQn_){return _aQo_ + _aQn_ | 0},
       include$1=
        MakeNumeric
         ([0,
           zero$1,
           one$1,
           function(_aQm_){return - _aQm_ | 0},
           succ$1,
           pred$1,
           abs$2,
           _iO_,
           _iN_,
           _iM_,
           _iL_,
           modulo$2,
           pow$2,
           compare$3,
           _iK_,
           _iJ_,
           _iI_,
           to_string$4,
           _iH_,
           _iG_]),
       compare$11=include$1[11],
       fold_left$1=
        function(f,acc,s)
         {var acc$0=acc,s$0=s;
          for(;;)
           {var _aQl_=0,match=caml_call1(s$0,_aQl_);
            if(match)
             {var
               s$1=match[2],
               e=match[1],
               acc$1=caml_call2(f,acc$0,e),
               acc$0=acc$1,
               s$0=s$1;
              continue}
            return acc$0}},
       empty$0=0,
       is_singleton=
        function(param)
         {if(param && ! param[1] && ! param[3])return 1;return 0},
       height=function(param){if(param){var h=param[4];return h}return 0},
       create$6=
        function(l,v,r)
         {if(l)var h=l[4],hl=h;else var hl=0;
          if(r)var h$0=r[4],hr=h$0;else var hr=0;
          var _aQk_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
          return [0,l,v,r,_aQk_]},
       bal=
        function(l,v,r)
         {if(l)var h=l[4],hl=h;else var hl=0;
          if(r)var h$0=r[4],hr=h$0;else var hr=0;
          if((hr + 2 | 0) < hl)
           {if(l)
             {var lr=l[3],lv=l[2],ll=l[1],_aQf_=height(lr);
              if(_aQf_ <= height(ll))return create$6(ll,lv,create$6(lr,v,r));
              if(lr)
               {var lrr=lr[3],lrv=lr[2],lrl=lr[1],_aQg_=create$6(lrr,v,r);
                return create$6(create$6(ll,lv,lrl),lrv,_aQg_)}
              return invalid_arg(_iP_)}
            return invalid_arg(_iQ_)}
          if((hl + 2 | 0) < hr)
           {if(r)
             {var rr=r[3],rv=r[2],rl=r[1],_aQh_=height(rl);
              if(_aQh_ <= height(rr))return create$6(create$6(l,v,rl),rv,rr);
              if(rl)
               {var rlr=rl[3],rlv=rl[2],rll=rl[1],_aQi_=create$6(rlr,rv,rr);
                return create$6(create$6(l,v,rll),rlv,_aQi_)}
              return invalid_arg(_iR_)}
            return invalid_arg(_iS_)}
          var _aQj_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
          return [0,l,v,r,_aQj_]},
       min_elt=
        function(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var _aQe_=param$0[1];
              if(_aQe_){var param$0=_aQe_;continue}
              var v=param$0[2];
              return v}
            throw Not_found}},
       min_elt_opt=
        function(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var _aQd_=param$0[1];
              if(_aQd_){var param$0=_aQd_;continue}
              var v=param$0[2];
              return [0,v]}
            return 0}},
       get_root=
        function(param){if(param){var v=param[2];return v}throw Not_found},
       pop_min=
        function(s)
         {var mini=[0,get_root(s)];
          function loop(param)
           {if(param)
             {var _aQc_=param[1];
              if(_aQc_){var r=param[3],v=param[2];return bal(loop(_aQc_),v,r)}
              var r$0=param[3],v$0=param[2];
              mini[1] = v$0;
              return r$0}
            throw Not_found}
          var others=loop(s);
          return [0,mini[1],others]},
       pop_max=
        function(s)
         {var maxi=[0,get_root(s)];
          function loop(param)
           {if(param)
             {var _aQb_=param[1];
              if(param[3])
               {var r=param[3],v=param[2];return bal(_aQb_,v,loop(r))}
              var v$0=param[2];
              maxi[1] = v$0;
              return _aQb_}
            throw Not_found}
          var others=loop(s);
          return [0,maxi[1],others]},
       max_elt=
        function(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {if(param$0[3]){var param$1=param$0[3],param$0=param$1;continue}
              var v=param$0[2];
              return v}
            throw Not_found}},
       max_elt_opt=
        function(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {if(param$0[3]){var param$1=param$0[3],param$0=param$1;continue}
              var v=param$0[2];
              return [0,v]}
            return 0}},
       remove_min_elt=
        function(param)
         {if(param)
           {var _aQa_=param[1];
            if(_aQa_)
             {var r=param[3],v=param[2];return bal(remove_min_elt(_aQa_),v,r)}
            var r$0=param[3];
            return r$0}
          return invalid_arg(_iT_)},
       merge=
        function(t1,t2)
         {if(t1)
           {if(t2)
             {var _aP$_=remove_min_elt(t2);return bal(t1,min_elt(t2),_aP$_)}
            return t1}
          return t2},
       pop$1=
        function(s)
         {if(s){var r=s[3],v=s[2],l=s[1];return [0,v,merge(l,r)]}
          throw Not_found},
       add$4=
        function(cmp,x,t)
         {if(t)
           {var r=t[3],v=t[2],l=t[1],c=caml_call2(cmp,x,v);
            if(0 === c)return t;
            if(0 <= c){var nr=add$4(cmp,x,r);return nr === r?t:bal(l,v,nr)}
            var nl=add$4(cmp,x,l);
            return nl === l?t:bal(nl,v,r)}
          return [0,0,x,0,1]},
       remove=
        function(cmp,x,t)
         {if(t)
           {var r=t[3],v=t[2],l=t[1],c=caml_call2(cmp,x,v);
            if(0 === c)return merge(l,r);
            if(0 <= c){var nr=remove(cmp,x,r);return nr === r?t:bal(l,v,nr)}
            var nl=remove(cmp,x,l);
            return nl === l?t:bal(nl,v,r)}
          return t},
       remove_exn=
        function(cmp,x,param)
         {if(param)
           {var r=param[3],v=param[2],l=param[1],c=caml_call2(cmp,x,v);
            return 0 === c
                    ?merge(l,r)
                    :0 <= c
                      ?bal(l,v,remove_exn(cmp,x,r))
                      :bal(remove_exn(cmp,x,l),v,r)}
          throw Not_found},
       update=
        function(cmp,x,y,s)
         {if(0 === caml_call2(cmp,x,y))
           {var
             loop=
              function(t)
               {if(t)
                 {var h=t[4],r=t[3],v=t[2],l=t[1],c=caml_call2(cmp,x,v);
                  if(0 === c)return v === y?t:[0,l,y,r,h];
                  if(0 <= c){var nr=loop(r);return nr === r?t:[0,l,v,nr,h]}
                  var nl=loop(l);
                  return nl === l?t:[0,nl,v,r,h]}
                throw Not_found};
            return loop(s)}
          return add$4(cmp,y,remove_exn(cmp,x,s))},
       find$0=
        function(cmp,x,param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var
               r=param$0[3],
               v=param$0[2],
               l=param$0[1],
               c=caml_call2(cmp,x,v);
              if(0 === c)return v;
              var param$1=0 <= c?r:l,param$0=param$1;
              continue}
            throw Not_found}},
       find_opt=
        function(cmp,x,param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var
               r=param$0[3],
               v=param$0[2],
               l=param$0[1],
               c=caml_call2(cmp,x,v);
              if(0 === c)return [0,v];
              var param$1=0 <= c?r:l,param$0=param$1;
              continue}
            return 0}},
       find_first_helper_found=
        function(k0,f,param)
         {var k0$0=k0,param$0=param;
          for(;;)
           {if(param$0)
             {var r=param$0[3],k=param$0[2],l=param$0[1];
              if(caml_call1(f,k)){var k0$0=k,param$0=l;continue}
              var param$0=r;
              continue}
            return k0$0}},
       find_first=
        function(f,m)
         {var m$0=m;
          for(;;)
           {if(m$0)
             {var r=m$0[3],k=m$0[2],l=m$0[1];
              if(caml_call1(f,k))return find_first_helper_found(k,f,l);
              var m$0=r;
              continue}
            throw Not_found}},
       find_first_opt=
        function(f,m)
         {var m$0=m;
          for(;;)
           {if(m$0)
             {var r=m$0[3],k=m$0[2],l=m$0[1];
              if(caml_call1(f,k))return [0,find_first_helper_found(k,f,l)];
              var m$0=r;
              continue}
            return 0}},
       find_last_helper_found=
        function(k0,f,param)
         {var k0$0=k0,param$0=param;
          for(;;)
           {if(param$0)
             {var r=param$0[3],k=param$0[2],l=param$0[1];
              if(caml_call1(f,k)){var k0$0=k,param$0=r;continue}
              var param$0=l;
              continue}
            return k0$0}},
       find_last=
        function(f,m)
         {var m$0=m;
          for(;;)
           {if(m$0)
             {var r=m$0[3],k=m$0[2],l=m$0[1];
              if(caml_call1(f,k))return find_last_helper_found(k,f,r);
              var m$0=l;
              continue}
            throw Not_found}},
       find_last_opt=
        function(f,m)
         {var m$0=m;
          for(;;)
           {if(m$0)
             {var r=m$0[3],k=m$0[2],l=m$0[1];
              if(caml_call1(f,k))return [0,find_last_helper_found(k,f,r)];
              var m$0=l;
              continue}
            return 0}},
       iter$7=
        function(f,param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var r=param$0[3],v=param$0[2],l=param$0[1];
              iter$7(f,l);
              caml_call1(f,v);
              var param$0=r;
              continue}
            return 0}},
       fold$2=
        function(f,s,accu)
         {var s$0=s,accu$0=accu;
          for(;;)
           {if(s$0)
             {var
               r=s$0[3],
               v=s$0[2],
               l=s$0[1],
               _aP__=fold$2(f,l,accu$0),
               accu$1=caml_call2(f,v,_aP__),
               s$0=r,
               accu$0=accu$1;
              continue}
            return accu$0}},
       Found=[248,_iU_,caml_fresh_oo_id(0)],
       at_rank_exn=
        function(i,s)
         {if(i < 0)invalid_arg(_iV_);
          var res=[0,get_root(s)];
          try
           {var
             _aP6_=0,
             _aP7_=
              function(node,j)
               {if(j !== i)return j + 1 | 0;res[1] = node;throw Found};
            fold$2(_aP7_,s,_aP6_);
            var _aP8_=invalid_arg(_iW_);
            return _aP8_}
          catch(_aP9_)
           {_aP9_ = caml_wrap_exception(_aP9_);
            if(_aP9_ === Found)return res[1];
            throw _aP9_}},
       singleton$0=function(x){return [0,0,x,0,1]},
       add_min=
        function(v,param)
         {if(param)
           {var r=param[3],x=param[2],l=param[1];return bal(add_min(v,l),x,r)}
          return singleton$0(v)},
       add_max=
        function(v,param)
         {if(param)
           {var r=param[3],x=param[2],l=param[1];return bal(l,x,add_max(v,r))}
          return singleton$0(v)},
       join$0=
        function(l,v,r)
         {if(l)
           {if(r)
             {var
               rh=r[4],
               rr=r[3],
               rv=r[2],
               rl=r[1],
               lh=l[4],
               lr=l[3],
               lv=l[2],
               ll=l[1];
              return (rh + 2 | 0) < lh
                      ?bal(ll,lv,join$0(lr,v,r))
                      :(lh + 2 | 0) < rh?bal(join$0(l,v,rl),rv,rr):create$6(l,v,r)}
            return add_max(v,l)}
          return add_min(v,r)},
       split=
        function(cmp,x,param)
         {if(param)
           {var r=param[3],v=param[2],l=param[1],c=caml_call2(cmp,x,v);
            if(0 === c)return [0,l,1,r];
            if(0 <= c)
             {var match=split(cmp,x,r),rr=match[3],pres=match[2],lr=match[1];
              return [0,join$0(l,v,lr),pres,rr]}
            var
             match$0=split(cmp,x,l),
             rl=match$0[3],
             pres$0=match$0[2],
             ll=match$0[1];
            return [0,ll,pres$0,join$0(rl,v,r)]}
          return _iX_},
       split_opt=
        function(cmp,x,param)
         {if(param)
           {var r=param[3],v=param[2],l=param[1],c=caml_call2(cmp,x,v);
            if(0 === c)return [0,l,[0,v],r];
            if(0 <= c)
             {var
               match=split_opt(cmp,x,r),
               rr=match[3],
               pres=match[2],
               lr=match[1];
              return [0,join$0(l,v,lr),pres,rr]}
            var
             match$0=split_opt(cmp,x,l),
             rl=match$0[3],
             pres$0=match$0[2],
             ll=match$0[1];
            return [0,ll,pres$0,join$0(rl,v,r)]}
          return _iY_},
       split_lt=
        function(cmp,x,s)
         {var match=split_opt(cmp,x,s),r=match[3],maybe=match[2],l=match[1];
          if(maybe){var eq_x=maybe[1];return [0,l,add$4(cmp,eq_x,r)]}
          return [0,l,r]},
       split_le=
        function(cmp,x,s)
         {var match=split_opt(cmp,x,s),r=match[3],maybe=match[2],l=match[1];
          if(maybe){var eq_x=maybe[1];return [0,add$4(cmp,eq_x,l),r]}
          return [0,l,r]},
       cardinal=
        function(param)
         {if(param)
           {var r=param[3],l=param[1],_aP5_=cardinal(r);
            return (cardinal(l) + 1 | 0) + _aP5_ | 0}
          return 0},
       elements_aux=
        function(accu,param)
         {var accu$0=accu,param$0=param;
          for(;;)
           {if(param$0)
             {var
               r=param$0[3],
               v=param$0[2],
               l=param$0[1],
               accu$1=[0,v,elements_aux(accu$0,r)],
               accu$0=accu$1,
               param$0=l;
              continue}
            return accu$0}},
       elements=function(s){return elements_aux(0,s)},
       to_array=
        function(s)
         {if(s)
           {var
             e=s[2],
             _aP2_=cardinal(s),
             arr=caml_make_vect(_aP2_,e),
             i=[0,0],
             _aP3_=
              function(x){var _aP4_=i[1];arr[1 + _aP4_] = x;i[1]++;return 0};
            iter$7(_aP3_,s);
            return arr}
          return [0]},
       cons_iter=
        function(s,t)
         {var s$0=s,t$0=t;
          for(;;)
           {if(s$0)
             {var
               r=s$0[3],
               e=s$0[2],
               s$1=s$0[1],
               t$1=[0,e,r,t$0],
               s$0=s$1,
               t$0=t$1;
              continue}
            return t$0}},
       rev_cons_iter=
        function(s,t)
         {var s$0=s,t$0=t;
          for(;;)
           {if(s$0)
             {var
               s$1=s$0[3],
               e=s$0[2],
               l=s$0[1],
               t$1=[0,e,l,t$0],
               s$0=s$1,
               t$0=t$1;
              continue}
            return t$0}},
       cons_iter_from=
        function(cmp,k2,m,e)
         {var m$0=m,e$0=e;
          for(;;)
           {if(m$0)
             {var r=m$0[3],k=m$0[2],l=m$0[1];
              if(0 < caml_call2(cmp,k2,k)){var m$0=r;continue}
              var e$1=[0,k,r,e$0],m$0=l,e$0=e$1;
              continue}
            return e$0}},
       enum_next=
        function(l,param)
         {var _aP1_=l[1];
          if(_aP1_)
           {var t=_aP1_[3],s=_aP1_[2],e=_aP1_[1];
            l[1] = cons_iter(s,t);
            return e}
          throw No_more_elements},
       enum_backwards_next=
        function(l,param)
         {var _aP0_=l[1];
          if(_aP0_)
           {var t=_aP0_[3],s=_aP0_[2],e=_aP0_[1];
            l[1] = rev_cons_iter(s,t);
            return e}
          throw No_more_elements},
       enum_count=
        function(l,param)
         {function aux(n,param)
           {var n$0=n,param$0=param;
            for(;;)
             {if(param$0)
               {var
                 t=param$0[3],
                 s=param$0[2],
                 n$1=(n$0 + 1 | 0) + cardinal(s) | 0,
                 n$0=n$1,
                 param$0=t;
                continue}
              return n$0}}
          return aux(0,l[1])},
       enum$1=
        function(t)
         {function make(l)
           {var l$0=[0,l];
            function clone(param){return make(l$0[1])}
            function _aPX_(_aPZ_){return enum_count(l$0,_aPZ_)}
            return make$3
                    (function(_aPY_){return enum_next(l$0,_aPY_)},_aPX_,clone)}
          var _aPW_=0;
          return make(cons_iter(t,_aPW_))},
       backwards=
        function(t)
         {function make(l)
           {var l$0=[0,l];
            function clone(param){return make(l$0[1])}
            function _aPT_(_aPV_){return enum_count(l$0,_aPV_)}
            return make$3
                    (function(_aPU_){return enum_backwards_next(l$0,_aPU_)},
                     _aPT_,
                     clone)}
          var _aPS_=0;
          return make(rev_cons_iter(t,_aPS_))},
       of_enum$0=
        function(cmp,e)
         {return fold$1
                  (function(acc,elem){return add$4(cmp,elem,acc)},empty$0,e)},
       of_list$0=
        function(cmp,l)
         {return fold(function(a,x){return add$4(cmp,x,a)},empty$0,l)},
       of_array=
        function(cmp,l)
         {return fold_left$0(function(a,x){return add$4(cmp,x,a)},empty$0,l)},
       print$0=
        function(opt,_aPQ_,_aPP_,print_elt,out,t)
         {if(opt)var sth=opt[1],first=sth;else var first=_i2_;
          if(_aPQ_)var sth$0=_aPQ_[1],last=sth$0;else var last=_i1_;
          if(_aPP_)var sth$1=_aPP_[1],sep=sth$1;else var sep=_i0_;
          var _aPR_=enum$1(t);
          return print
                  ([0,first],
                   [0,last],
                   [0,sep],
                   function(out,e)
                    {return caml_call2(fprintf$0(out,_iZ_),print_elt,e)},
                   out,
                   _aPR_)},
       for_all$0=
        function(p,param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var
               r=param$0[3],
               v=param$0[2],
               l=param$0[1],
               _aPM_=caml_call1(p,v);
              if(_aPM_)
               {var _aPN_=for_all$0(p,l);
                if(_aPN_){var param$0=r;continue}
                var _aPO_=_aPN_}
              else
               var _aPO_=_aPM_;
              return _aPO_}
            return 1}},
       exists$0=
        function(p,param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var
               r=param$0[3],
               v=param$0[2],
               l=param$0[1],
               _aPJ_=caml_call1(p,v);
              if(_aPJ_)
               var _aPK_=_aPJ_;
              else
               {var _aPL_=exists$0(p,l);
                if(! _aPL_){var param$0=r;continue}
                var _aPK_=_aPL_}
              return _aPK_}
            return 0}},
       partition=
        function(cmp,p,s)
         {function part(accu,param)
           {var accu$0=accu,param$0=param;
            for(;;)
             {var _aPG_=accu$0[2],_aPH_=accu$0[1];
              if(param$0)
               {var
                 r=param$0[3],
                 v=param$0[2],
                 l=param$0[1],
                 _aPI_=
                  caml_call1(p,v)
                   ?[0,add$4(cmp,v,_aPH_),_aPG_]
                   :[0,_aPH_,add$4(cmp,v,_aPG_)],
                 accu$1=part(_aPI_,l),
                 accu$0=accu$1,
                 param$0=r;
                continue}
              return accu$0}}
          return part(_i3_,s)},
       concat=
        function(t1,t2)
         {if(t1)
           {if(t2)
             {var _aPF_=remove_min_elt(t2);
              return join$0(t1,min_elt(t2),_aPF_)}
            return t1}
          return t2},
       union=
        function(cmp12,s1,s2)
         {if(s1)
           {if(s2)
             {var
               h2=s2[4],
               r2=s2[3],
               v2=s2[2],
               l2=s2[1],
               h1=s1[4],
               r1=s1[3],
               v1=s1[2],
               l1=s1[1];
              if(h2 <= h1)
               {if(1 === h2)return add$4(cmp12,v2,s1);
                var
                 match=split(cmp12,v1,s2),
                 r2$0=match[3],
                 l2$0=match[1],
                 _aPD_=union(cmp12,r1,r2$0);
                return join$0(union(cmp12,l1,l2$0),v1,_aPD_)}
              if(1 === h1)return add$4(cmp12,v1,s2);
              var
               match$0=split(cmp12,v2,s1),
               r1$0=match$0[3],
               l1$0=match$0[1],
               _aPE_=union(cmp12,r1$0,r2);
              return join$0(union(cmp12,l1$0,l2),v2,_aPE_)}
            return s1}
          return s2},
       filter=
        function(p,t)
         {if(t)
           {var
             r=t[3],
             v=t[2],
             l=t[1],
             l$0=filter(p,l),
             pv=caml_call1(p,v),
             r$0=filter(p,r);
            if(pv)
             {if(l === l$0 && r === r$0)return t;return join$0(l$0,v,r$0)}
            return concat(l$0,r$0)}
          return 0},
       try_join=
        function(cmp,l,v,r)
         {var switch$0=0;
          if(0 !== l)
           {var _aPC_=max_elt(l);if(0 <= caml_call2(cmp,_aPC_,v))switch$0 = 1}
          if(! switch$0)
           {var switch$1=0;
            if(0 !== r)
             {var _aPB_=min_elt(r);
              if(0 <= caml_call2(cmp,v,_aPB_))switch$1 = 1}
            if(! switch$1)return join$0(l,v,r)}
          return union(cmp,l,add$4(cmp,v,r))},
       map_endo=
        function(cmp,f,t)
         {if(t)
           {var
             r=t[3],
             v=t[2],
             l=t[1],
             l$0=map_endo(cmp,f,l),
             v$0=caml_call1(f,v),
             r$0=map_endo(cmp,f,r);
            if(l === l$0 && v === v$0 && r === r$0)return t;
            return try_join(cmp,l$0,v$0,r$0)}
          return 0},
       try_concat=
        function(cmp,t1,t2)
         {if(t1)
           {if(t2)
             {var _aPA_=remove_min_elt(t2);
              return try_join(cmp,t1,min_elt(t2),_aPA_)}
            return t1}
          return t2},
       filter_map_endo=
        function(cmp,f,t)
         {if(t)
           {var
             r=t[3],
             v=t[2],
             l=t[1],
             l$0=filter_map_endo(cmp,f,l),
             v$0=caml_call1(f,v),
             r$0=filter_map_endo(cmp,f,r);
            if(v$0)
             {var v$1=v$0[1];
              if(l === l$0 && v === v$1 && r === r$0)return t;
              return try_join(cmp,l$0,v$1,r$0)}
            return try_concat(cmp,l$0,r$0)}
          return 0},
       sym_diff=
        function(cmp12,s1,s2)
         {if(s1)
           {if(s2)
             {var
               r1=s1[3],
               v1=s1[2],
               l1=s1[1],
               _aPw_=split(cmp12,v1,s2),
               _aPx_=_aPw_[1];
              if(_aPw_[2])
               {var r2=_aPw_[3],_aPy_=sym_diff(cmp12,r1,r2);
                return concat(sym_diff(cmp12,l1,_aPx_),_aPy_)}
              var r2$0=_aPw_[3],_aPz_=sym_diff(cmp12,r1,r2$0);
              return join$0(sym_diff(cmp12,l1,_aPx_),v1,_aPz_)}
            return s1}
          return s2},
       inter=
        function(cmp12,s1,s2)
         {if(s1)
           {if(s2)
             {var
               r1=s1[3],
               v1=s1[2],
               l1=s1[1],
               _aPs_=split(cmp12,v1,s2),
               _aPt_=_aPs_[1];
              if(_aPs_[2])
               {var r2=_aPs_[3],_aPu_=inter(cmp12,r1,r2);
                return join$0(inter(cmp12,l1,_aPt_),v1,_aPu_)}
              var r2$0=_aPs_[3],_aPv_=inter(cmp12,r1,r2$0);
              return concat(inter(cmp12,l1,_aPt_),_aPv_)}
            return 0}
          return 0},
       diff=
        function(cmp12,s1,s2)
         {if(s1)
           {if(s2)
             {var
               r1=s1[3],
               v1=s1[2],
               l1=s1[1],
               _aPo_=split(cmp12,v1,s2),
               _aPp_=_aPo_[1];
              if(_aPo_[2])
               {var r2=_aPo_[3],_aPq_=diff(cmp12,r1,r2);
                return concat(diff(cmp12,l1,_aPp_),_aPq_)}
              var r2$0=_aPo_[3],_aPr_=diff(cmp12,r1,r2$0);
              return join$0(diff(cmp12,l1,_aPp_),v1,_aPr_)}
            return s1}
          return 0},
       disjoint=
        function(cmp12,s1,s2)
         {var s1$0=s1,s2$0=s2;
          for(;;)
           {if(s1$0 && s2$0)
             {var
               r1=s1$0[3],
               v1=s1$0[2],
               l1=s1$0[1],
               _aPl_=split(cmp12,v1,s2$0),
               _aPm_=_aPl_[1];
              if(_aPl_[2])return 0;
              var r2=_aPl_[3],_aPn_=disjoint(cmp12,l1,_aPm_);
              if(_aPn_){var s1$0=r1,s2$0=r2;continue}
              return _aPn_}
            return 1}},
       compare$12=
        function(cmp,s1,s2)
         {function compare_aux(t1,t2)
           {var t1$0=t1,t2$0=t2;
            for(;;)
             {if(t1$0)
               {if(t2$0)
                 {var
                   t2$1=t2$0[3],
                   r2=t2$0[2],
                   e2=t2$0[1],
                   t1$1=t1$0[3],
                   r1=t1$0[2],
                   e1=t1$0[1],
                   c=caml_call2(cmp,e1,e2);
                  if(0 === c)
                   {var
                     t2$2=cons_iter(r2,t2$1),
                     t1$2=cons_iter(r1,t1$1),
                     t1$0=t1$2,
                     t2$0=t2$2;
                    continue}
                  return c}
                return 1}
              return t2$0?-1:0}}
          var _aPi_=0,_aPj_=cons_iter(s2,_aPi_),_aPk_=0;
          return compare_aux(cons_iter(s1,_aPk_),_aPj_)},
       equal$3=function(cmp,s1,s2){return 0 === compare$12(cmp,s1,s2)?1:0},
       subset=
        function(cmp,s1,s2)
         {var s1$0=s1,s2$0=s2;
          for(;;)
           {if(s1$0)
             {if(s2$0)
               {var
                 r2=s2$0[3],
                 v2=s2$0[2],
                 l2=s2$0[1],
                 r1=s1$0[3],
                 v1=s1$0[2],
                 l1=s1$0[1],
                 c=caml_call2(cmp,v1,v2);
                if(0 === c)
                 {var _aPd_=subset(cmp,l1,l2);
                  if(_aPd_){var s1$0=r1,s2$0=r2;continue}
                  return _aPd_}
                if(0 <= c)
                 {var _aPe_=[0,0,v1,r1,0],_aPf_=subset(cmp,_aPe_,r2);
                  if(_aPf_){var s1$0=l1;continue}
                  return _aPf_}
                var _aPg_=[0,l1,v1,0,0],_aPh_=subset(cmp,_aPg_,l2);
                if(_aPh_){var s1$0=r1;continue}
                return _aPh_}
              return 0}
            return 1}},
       add_seq=
        function(cmp,s,m)
         {return fold_left$1(function(m,e){return add$4(cmp,e,m)},m,s)},
       of_seq=function(cmp,s){return add_seq(cmp,s,empty$0)},
       seq_of_iter=
        function(m,param)
         {if(m)
           {var e=m[3],r=m[2],k=m[1],_aPb_=cons_iter(r,e);
            return [0,k,function(_aPc_){return seq_of_iter(_aPb_,_aPc_)}]}
          return 0},
       to_seq$0=
        function(m)
         {var _aO__=0,_aO$_=cons_iter(m,_aO__);
          return function(_aPa_){return seq_of_iter(_aO$_,_aPa_)}},
       rev_seq_of_iter=
        function(m,param)
         {if(m)
           {var e=m[3],r=m[2],k=m[1],_aO8_=rev_cons_iter(r,e);
            return [0,k,function(_aO9_){return rev_seq_of_iter(_aO8_,_aO9_)}]}
          return 0},
       to_rev_seq=
        function(m)
         {var _aO5_=0,_aO6_=rev_cons_iter(m,_aO5_);
          return function(_aO7_){return rev_seq_of_iter(_aO6_,_aO7_)}},
       to_seq_from=
        function(cmp,k,m)
         {var _aO2_=0,_aO3_=cons_iter_from(cmp,k,m,_aO2_);
          return function(_aO4_){return seq_of_iter(_aO3_,_aO4_)}},
       Make$6=
        function(Ord)
         {var
           include=_Y_(Ord),
           empty=include[1],
           is_empty=include[2],
           mem=include[3];
          function cardinal$0(t){return cardinal(t)}
          function is_singleton$0(t){return is_singleton(t)}
          function enum$0(t){return enum$1(t)}
          function of_enum(e){return of_enum$0(Ord[1],e)}
          function backwards$0(t){return backwards(t)}
          function remove$0(e,t){return remove(Ord[1],e,t)}
          function remove_exn$0(e,t){return remove_exn(Ord[1],e,t)}
          function update$0(e1,e2,t){return update(Ord[1],e1,e2,t)}
          function add(e,t){return add$4(Ord[1],e,t)}
          function iter(f,t){return iter$7(f,t)}
          function at_rank_exn$0(i,t){return at_rank_exn(i,t)}
          function map(f,t){return map_endo(Ord[1],f,t)}
          function fold(f,t,acc){return fold$2(f,t,acc)}
          function filter$0(f,t){return filter(f,t)}
          function filter_map(f,t){return filter_map_endo(Ord[1],f,t)}
          function find(x,t){return find$0(Ord[1],x,t)}
          function find_opt$0(x,t){return find_opt(Ord[1],x,t)}
          function find_first$0(f,t){return find_first(f,t)}
          function find_first_opt$0(f,t){return find_first_opt(f,t)}
          function find_last$0(f,t){return find_last(f,t)}
          function find_last_opt$0(f,t){return find_last_opt(f,t)}
          function exists(f,t){return exists$0(f,t)}
          function for_all(f,t){return for_all$0(f,t)}
          function partition$0(f,t)
           {var _aO1_=Ord[1],match=partition(_aO1_,f,t),r=match[2],l=match[1];
            return [0,l,r]}
          function min_elt$0(t){return min_elt(t)}
          function min_elt_opt$0(t){return min_elt_opt(t)}
          function pop_min$0(t)
           {var match=pop_min(t),others=match[2],mini=match[1];
            return [0,mini,others]}
          function pop_max$0(t)
           {var match=pop_max(t),others=match[2],maxi=match[1];
            return [0,maxi,others]}
          function max_elt$0(t){return max_elt(t)}
          function max_elt_opt$0(t){return max_elt_opt(t)}
          function choose(t){return min_elt(t)}
          function choose_opt(t){return min_elt_opt(t)}
          function any(t){return get_root(t)}
          function pop(t)
           {var match=pop$1(t),t$0=match[2],e=match[1];return [0,e,t$0]}
          function split$0(e,s)
           {var
             _aO0_=Ord[1],
             match=split(_aO0_,e,s),
             r=match[3],
             v=match[2],
             l=match[1];
            return [0,l,v,r]}
          function split_opt$0(e,s)
           {var
             _aOZ_=Ord[1],
             match=split_opt(_aOZ_,e,s),
             r=match[3],
             maybe_v=match[2],
             l=match[1];
            return [0,l,maybe_v,r]}
          function split_lt$0(e,s)
           {var _aOY_=Ord[1],match=split_lt(_aOY_,e,s),r=match[2],l=match[1];
            return [0,l,r]}
          function split_le$0(e,s)
           {var _aOX_=Ord[1],match=split_le(_aOX_,e,s),r=match[2],l=match[1];
            return [0,l,r]}
          function singleton(e){return singleton$0(e)}
          function elements$0(t){return elements(t)}
          function to_array$0(t){return to_array(t)}
          function union$0(s1,s2){return union(Ord[1],s1,s2)}
          function diff$0(s1,s2){return diff(Ord[1],s1,s2)}
          function inter$0(s1,s2){return inter(Ord[1],s1,s2)}
          function sym_diff$0(s1,s2){return sym_diff(Ord[1],s1,s2)}
          function compare(t1,t2){return compare$12(Ord[1],t1,t2)}
          function equal(t1,t2){return equal$3(Ord[1],t1,t2)}
          function subset$0(t1,t2){return subset(Ord[1],t1,t2)}
          function disjoint$0(t1,t2){return disjoint(Ord[1],t1,t2)}
          function add_seq$0(s,t){return add_seq(Ord[1],s,t)}
          function of_seq$0(s){return of_seq(Ord[1],s)}
          function to_seq(t){return to_seq$0(t)}
          function to_rev_seq$0(t){return to_rev_seq(t)}
          function to_seq_from$0(k,t){return to_seq_from(Ord[1],k,t)}
          function _aOJ_(s1,s2)
           {if(s1)
             {if(s2)
               {var
                 r1=s1[3],
                 v1=s1[2],
                 l1=s1[1],
                 _aOU_=split$0(v1,s2),
                 _aOV_=_aOU_[1];
                if(_aOU_[2])
                 {var
                   r2=_aOU_[3],
                   match=_aOJ_(l1,_aOV_),
                   match$0=_aOJ_(r1,r2),
                   _aOW_=match + 1 | 0;
                  if(! (2 < _aOW_ >>> 0))
                   {var switch$0=0;
                    switch(_aOW_)
                     {case 0:if(! (1 < match$0 + 1 >>> 0))switch$0 = 1;break;
                      case 1:
                       var switcher=match$0 + 1 | 0;
                       if(! (2 < switcher >>> 0))
                        switch(switcher)
                         {case 0:switch$0 = 1;break;
                          case 1:return 0;
                          default:switch$0 = 2}
                       break;
                      default:if(! (1 < match$0 >>> 0))switch$0 = 2}
                    switch(switch$0)
                     {case 0:break;case 1:return -1;default:return 1}}
                  return min_num}
                var r2$0=_aOU_[3];
                if(0 <= _aOJ_(l1,_aOV_) && 0 <= _aOJ_(r1,r2$0))return 1;
                return min_num}
              return 1}
            return s2?-1:0}
          function compare_subset(s1,s2){return _aOJ_(s1,s2)}
          function of_list(l){return of_list$0(Ord[1],l)}
          function of_array$0(a){return of_array(Ord[1],a)}
          function print(first,last,sep,print_elt,out,t)
           {return print$0(first,last,sep,print_elt,out,t)}
          function min_elt$1(t)
           {try
             {var _aOS_=[0,min_elt$0(t)];return _aOS_}
            catch(_aOT_)
             {_aOT_ = caml_wrap_exception(_aOT_);
              if(_aOT_ === Not_found)return 0;
              throw _aOT_}}
          function max_elt$1(t)
           {try
             {var _aOQ_=[0,max_elt$0(t)];return _aOQ_}
            catch(_aOR_)
             {_aOR_ = caml_wrap_exception(_aOR_);
              if(_aOR_ === Not_found)return 0;
              throw _aOR_}}
          function choose$0(t)
           {try
             {var _aOO_=[0,choose(t)];return _aOO_}
            catch(_aOP_)
             {_aOP_ = caml_wrap_exception(_aOP_);
              if(_aOP_ === Not_found)return 0;
              throw _aOP_}}
          function any$0(t)
           {try
             {var _aOM_=[0,any(t)];return _aOM_}
            catch(_aON_)
             {_aON_ = caml_wrap_exception(_aON_);
              if(_aON_ === Not_found)return 0;
              throw _aON_}}
          function find$1(e,t)
           {try
             {var _aOK_=[0,find(e,t)];return _aOK_}
            catch(_aOL_)
             {_aOL_ = caml_wrap_exception(_aOL_);
              if(_aOL_ === Not_found)return 0;
              throw _aOL_}}
          var Exceptionless=[0,min_elt$1,max_elt$1,choose$0,any$0,find$1];
          function iter$0(f,t){return iter(f,t)}
          function fold$0(f,t,init){return fold(f,t,init)}
          function for_all$1(f,t){return for_all(f,t)}
          function exists$1(f,t){return exists(f,t)}
          function map$0(f,t){return map(f,t)}
          function filter$1(f,t){return filter$0(f,t)}
          function filter_map$0(f,t){return filter_map(f,t)}
          function partition$1(f,t){return partition$0(f,t)}
          var
           Labels=
            [0,
             iter$0,
             fold$0,
             for_all$1,
             exists$1,
             map$0,
             filter$1,
             filter_map$0,
             partition$1];
          return [0,
                  empty,
                  is_empty,
                  mem,
                  cardinal$0,
                  is_singleton$0,
                  enum$0,
                  of_enum,
                  backwards$0,
                  remove$0,
                  remove_exn$0,
                  update$0,
                  add,
                  iter,
                  at_rank_exn$0,
                  map,
                  fold,
                  filter$0,
                  filter_map,
                  find,
                  find_opt$0,
                  find_first$0,
                  find_first_opt$0,
                  find_last$0,
                  find_last_opt$0,
                  exists,
                  for_all,
                  partition$0,
                  min_elt$0,
                  min_elt_opt$0,
                  pop_min$0,
                  pop_max$0,
                  max_elt$0,
                  max_elt_opt$0,
                  choose,
                  choose_opt,
                  any,
                  pop,
                  split$0,
                  split_opt$0,
                  split_lt$0,
                  split_le$0,
                  singleton,
                  elements$0,
                  elements$0,
                  to_array$0,
                  union$0,
                  diff$0,
                  inter$0,
                  sym_diff$0,
                  compare,
                  equal,
                  subset$0,
                  disjoint$0,
                  add_seq$0,
                  of_seq$0,
                  to_seq,
                  to_rev_seq$0,
                  to_seq_from$0,
                  compare_subset,
                  of_list,
                  of_array$0,
                  print,
                  Exceptionless,
                  Labels]};
      Make$6([0,compare$7]);
      Make$6([0,compare$9]);
      Make$6([0,compare$10]);
      Make$6([0,compare$11]);
      Make$6([0,_h$_]);
      Make$6([0,compare]);
      Make$6([0,compare$0]);
      var
       dummy$0=function(param){return [0,0,0]},
       create$7=function(x){return [0,x,0]},
       accum=function(acc,x){var cell=create$7(x);acc[2] = cell;return cell},
       is_empty$2=function(param){return param?0:1},
       nth=
        function(l,index)
         {if(index < 0)invalid_arg(at_negative_index_msg);
          function loop(n,param)
           {var n$0=n,param$0=param;
            for(;;)
             {if(param$0)
               {var t=param$0[2],h=param$0[1];
                if(0 === n$0)return h;
                var n$1=n$0 - 1 | 0,n$0=n$1,param$0=t;
                continue}
              return invalid_arg(at_after_end_msg)}}
          return loop(index,l)},
       flatten$0=
        function(l)
         {function inner(dst,param)
           {var dst$0=dst,param$0=param;
            for(;;)
             {if(param$0)
               {var
                 t=param$0[2],
                 h=param$0[1],
                 dst$1=accum(dst$0,h),
                 dst$0=dst$1,
                 param$0=t;
                continue}
              return dst$0}}
          function outer(dst,param)
           {var dst$0=dst,param$0=param;
            for(;;)
             {if(param$0)
               {var
                 t=param$0[2],
                 h=param$0[1],
                 dst$1=inner(dst$0,h),
                 dst$0=dst$1,
                 param$0=t;
                continue}
              return 0}}
          var _aOI_=0,r=dummy$0(_aOI_);
          outer(r,l);
          return r[2]},
       map$4=
        function(f,param)
         {if(param)
           {var
             t=param[2],
             h=param[1],
             loop=
              function(dst,param)
               {var dst$0=dst,param$0=param;
                for(;;)
                 {if(param$0)
                   {var
                     t=param$0[2],
                     h=param$0[1],
                     _aOH_=caml_call1(f,h),
                     dst$1=accum(dst$0,_aOH_),
                     dst$0=dst$1,
                     param$0=t;
                    continue}
                  return 0}},
             _aOG_=caml_call1(f,h),
             r=create$7(_aOG_);
            loop(r,t);
            return r}
          return 0},
       fold_right$1=
        function(f,l,init)
         {function tail_loop(acc,param)
           {var acc$0=acc,param$0=param;
            for(;;)
             {if(param$0)
               {var
                 t=param$0[2],
                 h=param$0[1],
                 acc$1=caml_call2(f,h,acc$0),
                 acc$0=acc$1,
                 param$0=t;
                continue}
              return acc$0}}
          function loop(n,param)
           {if(param)
             {var t=param[2],h=param[1];
              if(n < 1000)
               {var _aOE_=n + 1 | 0;return caml_call2(f,h,loop(_aOE_,t))}
              var _aOF_=rev(t);
              return caml_call2(f,h,tail_loop(init,_aOF_))}
            return init}
          return loop(0,l)},
       iter2=
        function(f,l1,l2)
         {var l1$0=l1,l2$0=l2;
          for(;;)
           {if(l1$0)
             {if(l2$0)
               {var t2=l2$0[2],h2=l2$0[1],t1=l1$0[2],h1=l1$0[1];
                caml_call2(f,h1,h2);
                var l1$0=t1,l2$0=t2;
                continue}}
            else
             if(! l2$0)return 0;
            return invalid_arg(_i4_)}},
       fold_left2=
        function(f,accum,l1,l2)
         {var accum$0=accum,l1$0=l1,l2$0=l2;
          for(;;)
           {if(l1$0)
             {if(l2$0)
               {var
                 t2=l2$0[2],
                 h2=l2$0[1],
                 t1=l1$0[2],
                 h1=l1$0[1],
                 accum$1=caml_call3(f,accum$0,h1,h2),
                 accum$0=accum$1,
                 l1$0=t1,
                 l2$0=t2;
                continue}}
            else
             if(! l2$0)return accum$0;
            return invalid_arg(_i5_)}},
       for_all2=
        function(p,l1,l2)
         {function loop(l1,l2)
           {var l1$0=l1,l2$0=l2;
            for(;;)
             {if(l1$0)
               {if(l2$0)
                 {var t2=l2$0[2],h2=l2$0[1],t1=l1$0[2],h1=l1$0[1];
                  if(caml_call2(p,h1,h2)){var l1$0=t1,l2$0=t2;continue}
                  return 0}}
              else
               if(! l2$0)return 1;
              return invalid_arg(_i6_)}}
          return loop(l1,l2)},
       remove_at=
        function(i,lst)
         {function loop(dst,i,param)
           {var dst$0=dst,i$0=i,param$0=param;
            for(;;)
             {if(param$0)
               {var xs=param$0[2],x=param$0[1];
                if(0 === i$0){dst$0[2] = xs;return 0}
                var
                 i$1=i$0 - 1 | 0,
                 dst$1=accum(dst$0,x),
                 dst$0=dst$1,
                 i$0=i$1,
                 param$0=xs;
                continue}
              return invalid_arg(_i7_)}}
          if(0 <= i)
           {var _aOD_=0,dummy=dummy$0(_aOD_);
            loop(dummy,i,lst);
            return dummy[2]}
          return invalid_arg(_i8_)},
       find_all$0=
        function(p,l)
         {function findnext(dst,param)
           {var dst$0=dst,param$0=param;
            for(;;)
             {if(param$0)
               {var t=param$0[2],h=param$0[1];
                if(caml_call1(p,h))
                 {var dst$1=accum(dst$0,h),dst$0=dst$1,param$0=t;continue}
                var param$0=t;
                continue}
              return 0}}
          var _aOC_=0,dummy=dummy$0(_aOC_);
          findnext(dummy,l);
          return dummy[2]},
       findi=
        function(p,l)
         {function loop(n,param)
           {var n$0=n,param$0=param;
            for(;;)
             {if(param$0)
               {var t=param$0[2],h=param$0[1];
                if(caml_call2(p,n$0,h))return [0,n$0,h];
                var n$1=n$0 + 1 | 0,n$0=n$1,param$0=t;
                continue}
              throw Not_found}}
          return loop(0,l)},
       combine=
        function(l1,l2)
         {if(l1)
           {if(l2)
             {var
               ys=l2[2],
               y=l2[1],
               xs=l1[2],
               x=l1[1],
               _aOA_=[0,x,y],
               acc=create$7(_aOA_),
               loop=
                function(dst,l1,l2)
                 {var dst$0=dst,l1$0=l1,l2$0=l2;
                  for(;;)
                   {if(l1$0)
                     {if(l2$0)
                       {var
                         t2=l2$0[2],
                         h2=l2$0[1],
                         t1=l1$0[2],
                         h1=l1$0[1],
                         _aOB_=[0,h1,h2],
                         dst$1=accum(dst$0,_aOB_),
                         dst$0=dst$1,
                         l1$0=t1,
                         l2$0=t2;
                        continue}}
                    else
                     if(! l2$0)return acc;
                    return invalid_arg(_i9_)}};
              return loop(acc,xs,ys)}}
          else
           if(! l2)return 0;
          return invalid_arg(_i__)},
       init$0=
        function(size,f)
         {if(0 === size)return 0;
          if(0 <= size)
           {var
             loop=
              function(dst,n)
               {var dst$0=dst,n$0=n;
                for(;;)
                 {var _aOy_=n$0 < size?1:0;
                  if(_aOy_)
                   {var
                     n$1=n$0 + 1 | 0,
                     _aOz_=caml_call1(f,n$0),
                     dst$1=accum(dst$0,_aOz_),
                     dst$0=dst$1,
                     n$0=n$1;
                    continue}
                  return _aOy_}},
             _aOv_=0,
             _aOw_=caml_call1(f,_aOv_),
             r=create$7(_aOw_),
             _aOx_=1;
            loop(r,_aOx_);
            return r}
          return invalid_arg(_i$_)},
       mapi=
        function(f,param)
         {if(param)
           {var
             t=param[2],
             h=param[1],
             loop=
              function(dst,n,param)
               {var dst$0=dst,n$0=n,param$0=param;
                for(;;)
                 {if(param$0)
                   {var
                     t=param$0[2],
                     h=param$0[1],
                     n$1=n$0 + 1 | 0,
                     _aOu_=caml_call2(f,n$0,h),
                     dst$1=accum(dst$0,_aOu_),
                     dst$0=dst$1,
                     n$0=n$1,
                     param$0=t;
                    continue}
                  return 0}},
             _aOr_=0,
             _aOs_=caml_call2(f,_aOr_,h),
             r=create$7(_aOs_),
             _aOt_=1;
            loop(r,_aOt_,t);
            return r}
          return 0},
       split_nth=
        function(index,l)
         {if(l)
           {var t=l[2],h=l[1];
            if(0 === index)return [0,0,l];
            if(0 <= index)
             {var
               loop=
                function(n,dst,l)
                 {var n$0=n,dst$0=dst,l$0=l;
                  for(;;)
                   {if(0 === n$0)return l$0;
                    if(l$0)
                     {var
                       t=l$0[2],
                       h=l$0[1],
                       dst$1=accum(dst$0,h),
                       n$1=n$0 - 1 | 0,
                       n$0=n$1,
                       dst$0=dst$1,
                       l$0=t;
                      continue}
                    return invalid_arg(at_after_end_msg)}},
               r=create$7(h),
               _aOq_=index - 1 | 0;
              return [0,r,loop(_aOq_,r,t)]}
            return invalid_arg(at_negative_index_msg)}
          return 0 === index?_ja_:invalid_arg(at_after_end_msg)},
       remove$0=
        function(l,x)
         {function loop(dst,param)
           {var dst$0=dst,param$0=param;
            for(;;)
             {if(param$0)
               {var t=param$0[2],h=param$0[1];
                if(caml_equal(x,h)){dst$0[2] = t;return 0}
                var dst$1=accum(dst$0,h),dst$0=dst$1,param$0=t;
                continue}
              return 0}}
          var _aOp_=0,dummy=dummy$0(_aOp_);
          loop(dummy,l);
          return dummy[2]},
       remove_if=
        function(f,lst)
         {function loop(dst,param)
           {var dst$0=dst,param$0=param;
            for(;;)
             {if(param$0)
               {var l=param$0[2],x=param$0[1];
                if(caml_call1(f,x)){dst$0[2] = l;return 0}
                var dst$1=accum(dst$0,x),dst$0=dst$1,param$0=l;
                continue}
              return 0}}
          var _aOo_=0,dummy=dummy$0(_aOo_);
          loop(dummy,lst);
          return dummy[2]},
       of_enum$1=
        function(e)
         {var _aOn_=0,h=dummy$0(_aOn_);fold$1(accum,h,e);return h[2]},
       modify_opt_at=
        function(n,f,l)
         {if(n < 0)invalid_arg(at_negative_index_msg);
          function loop(acc,n,param)
           {var acc$0=acc,n$0=n,param$0=param;
            for(;;)
             {if(param$0)
               {var t=param$0[2],h=param$0[1];
                if(0 === n$0)
                 {var match=caml_call1(f,h);
                  if(match){var v=match[1];return rev_append(acc$0,[0,v,t])}
                  return rev_append(acc$0,t)}
                var
                 n$1=n$0 - 1 | 0,
                 acc$1=[0,h,acc$0],
                 acc$0=acc$1,
                 n$0=n$1,
                 param$0=t;
                continue}
              return invalid_arg(at_after_end_msg)}}
          return loop(0,n,l)},
       modify_at=
        function(n,f,l)
         {return modify_opt_at(n,function(x){return [0,caml_call1(f,x)]},l)},
       cartesian_product=
        function(l1,l2)
         {function _aOm_(i){return map$0(function(j){return [0,i,j]},l2)}
          return flatten(map$0(_aOm_,l1))},
       findi$0=
        function(p,l)
         {try
           {var _aOk_=[0,findi(p,l)];return _aOk_}
          catch(_aOl_)
           {_aOl_ = caml_wrap_exception(_aOl_);
            if(_aOl_ === Not_found)return 0;
            throw _aOl_}},
       assoc$0=
        function(e,l)
         {try
           {var _aOi_=[0,assoc(e,l)];return _aOi_}
          catch(_aOj_)
           {_aOj_ = caml_wrap_exception(_aOj_);
            if(_aOj_ === Not_found)return 0;
            throw _aOj_}},
       height$0=function(param){if(param){var h=param[5];return h}return 0},
       empty$1=0,
       create$8=
        function(l,x,d,r)
         {var
           hl=height$0(l),
           hr=height$0(r),
           _aOh_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
          return [0,l,x,d,r,_aOh_]},
       bal$0=
        function(l,x,d,r)
         {if(l)var h=l[5],hl=h;else var hl=0;
          if(r)var h$0=r[5],hr=h$0;else var hr=0;
          if((hr + 2 | 0) < hl)
           {if(l)
             {var lr=l[4],ld=l[3],lv=l[2],ll=l[1],_aOc_=height$0(lr);
              if(_aOc_ <= height$0(ll))
               return create$8(ll,lv,ld,create$8(lr,x,d,r));
              if(lr)
               {var
                 lrr=lr[4],
                 lrd=lr[3],
                 lrv=lr[2],
                 lrl=lr[1],
                 _aOd_=create$8(lrr,x,d,r);
                return create$8(create$8(ll,lv,ld,lrl),lrv,lrd,_aOd_)}
              return invalid_arg(_jb_)}
            return invalid_arg(_jc_)}
          if((hl + 2 | 0) < hr)
           {if(r)
             {var rr=r[4],rd=r[3],rv=r[2],rl=r[1],_aOe_=height$0(rl);
              if(_aOe_ <= height$0(rr))
               return create$8(create$8(l,x,d,rl),rv,rd,rr);
              if(rl)
               {var
                 rlr=rl[4],
                 rld=rl[3],
                 rlv=rl[2],
                 rll=rl[1],
                 _aOf_=create$8(rlr,rv,rd,rr);
                return create$8(create$8(l,x,d,rll),rlv,rld,_aOf_)}
              return invalid_arg(_jd_)}
            return invalid_arg(_je_)}
          var _aOg_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
          return [0,l,x,d,r,_aOg_]},
       min_binding=
        function(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var _aOb_=param$0[1];
              if(_aOb_){var param$0=_aOb_;continue}
              var v=param$0[3],k=param$0[2];
              return [0,k,v]}
            throw Not_found}},
       min_binding_opt=
        function(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var _aOa_=param$0[1];
              if(_aOa_){var param$0=_aOa_;continue}
              var v=param$0[3],k=param$0[2];
              return [0,[0,k,v]]}
            return 0}},
       get_root$0=
        function(param)
         {if(param){var v=param[3],k=param[2];return [0,k,v]}throw Not_found},
       pop_min_binding=
        function(s)
         {var mini=[0,get_root$0(s)];
          function loop(param)
           {if(param)
             {var _aN$_=param[1];
              if(_aN$_)
               {var r=param[4],v=param[3],k=param[2];
                return bal$0(loop(_aN$_),k,v,r)}
              var r$0=param[4],v$0=param[3],k$0=param[2];
              mini[1] = [0,k$0,v$0];
              return r$0}
            throw [0,Assert_failure,_jf_]}
          var others=loop(s);
          return [0,mini[1],others]},
       max_binding=
        function(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {if(param$0[4]){var param$1=param$0[4],param$0=param$1;continue}
              var v=param$0[3],k=param$0[2];
              return [0,k,v]}
            throw Not_found}},
       max_binding_opt=
        function(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {if(param$0[4]){var param$1=param$0[4],param$0=param$1;continue}
              var v=param$0[3],k=param$0[2];
              return [0,[0,k,v]]}
            return 0}},
       pop_max_binding=
        function(s)
         {var maxi=[0,get_root$0(s)];
          function loop(param)
           {if(param)
             {var _aN__=param[1];
              if(param[4])
               {var r=param[4],v=param[3],k=param[2];
                return bal$0(_aN__,k,v,loop(r))}
              var v$0=param[3],k$0=param[2];
              maxi[1] = [0,k$0,v$0];
              return _aN__}
            throw [0,Assert_failure,_jg_]}
          var others=loop(s);
          return [0,maxi[1],others]},
       remove_min_binding=
        function(param)
         {if(param)
           {var _aN9_=param[1];
            if(_aN9_)
             {var r=param[4],v=param[3],k=param[2];
              return bal$0(remove_min_binding(_aN9_),k,v,r)}
            var r$0=param[4];
            return r$0}
          throw Not_found},
       _jh_=
        function(t1,t2)
         {if(t1)
           {if(t2)
             {var match=min_binding(t2),v=match[2],k=match[1];
              return bal$0(t1,k,v,remove_min_binding(t2))}
            return t1}
          return t2},
       add$5=
        function(x,d,cmp,map)
         {function loop(node)
           {if(node)
             {var
               h=node[5],
               r=node[4],
               v=node[3],
               k=node[2],
               l=node[1],
               c=caml_call2(cmp,x,k);
              if(0 === c)return d === v?node:[0,l,x,d,r,h];
              if(0 <= c){var nr=loop(r);return nr === r?node:bal$0(l,k,v,nr)}
              var nl=loop(l);
              return nl === l?node:bal$0(nl,k,v,r)}
            return [0,0,x,d,0,1]}
          return loop(map)},
       find$1=
        function(x,cmp,map)
         {function loop(param)
           {var param$0=param;
            for(;;)
             {if(param$0)
               {var
                 r=param$0[4],
                 v=param$0[3],
                 k=param$0[2],
                 l=param$0[1],
                 c=caml_call2(cmp,x,k);
                if(0 <= c){if(0 < c){var param$0=r;continue}return v}
                var param$0=l;
                continue}
              throw Not_found}}
          return loop(map)},
       find_first_helper_found$0=
        function(k0,v0,f,param)
         {var k0$0=k0,v0$0=v0,param$0=param;
          for(;;)
           {if(param$0)
             {var r=param$0[4],v=param$0[3],k=param$0[2],l=param$0[1];
              if(caml_call1(f,k)){var k0$0=k,v0$0=v,param$0=l;continue}
              var param$0=r;
              continue}
            return [0,k0$0,v0$0]}},
       find_first$0=
        function(f,m)
         {var m$0=m;
          for(;;)
           {if(m$0)
             {var r=m$0[4],v=m$0[3],k=m$0[2],l=m$0[1];
              if(caml_call1(f,k))return find_first_helper_found$0(k,v,f,l);
              var m$0=r;
              continue}
            throw Not_found}},
       find_first_opt$0=
        function(f,m)
         {var m$0=m;
          for(;;)
           {if(m$0)
             {var r=m$0[4],v=m$0[3],k=m$0[2],l=m$0[1];
              if(caml_call1(f,k))
               return [0,find_first_helper_found$0(k,v,f,l)];
              var m$0=r;
              continue}
            return 0}},
       find_last_helper_found$0=
        function(k0,v0,f,param)
         {var k0$0=k0,v0$0=v0,param$0=param;
          for(;;)
           {if(param$0)
             {var r=param$0[4],v=param$0[3],k=param$0[2],l=param$0[1];
              if(caml_call1(f,k)){var k0$0=k,v0$0=v,param$0=r;continue}
              var param$0=l;
              continue}
            return [0,k0$0,v0$0]}},
       find_last$0=
        function(f,m)
         {var m$0=m;
          for(;;)
           {if(m$0)
             {var r=m$0[4],v=m$0[3],k=m$0[2],l=m$0[1];
              if(caml_call1(f,k))return find_last_helper_found$0(k,v,f,r);
              var m$0=l;
              continue}
            throw Not_found}},
       find_last_opt$0=
        function(f,m)
         {var m$0=m;
          for(;;)
           {if(m$0)
             {var r=m$0[4],v=m$0[3],k=m$0[2],l=m$0[1];
              if(caml_call1(f,k))return [0,find_last_helper_found$0(k,v,f,r)];
              var m$0=l;
              continue}
            return 0}},
       find_option=
        function(x,cmp,map)
         {try
           {var _aN7_=[0,find$1(x,cmp,map)];return _aN7_}
          catch(_aN8_)
           {_aN8_ = caml_wrap_exception(_aN8_);
            if(_aN8_ === Not_found)return 0;
            throw _aN8_}},
       find_default=
        function(def,x,cmp,map)
         {try
           {var _aN5_=find$1(x,cmp,map);return _aN5_}
          catch(_aN6_)
           {_aN6_ = caml_wrap_exception(_aN6_);
            if(_aN6_ === Not_found)return def;
            throw _aN6_}},
       remove$1=
        function(x,cmp,map)
         {function loop(node)
           {if(node)
             {var
               r=node[4],
               v=node[3],
               k=node[2],
               l=node[1],
               c=caml_call2(cmp,x,k);
              if(0 === c)return _jh_(l,r);
              if(0 <= c){var nr=loop(r);return nr === r?node:bal$0(l,k,v,nr)}
              var nl=loop(l);
              return nl === l?node:bal$0(nl,k,v,r)}
            return 0}
          return loop(map)},
       remove_exn$0=
        function(x,cmp,map)
         {function loop(param)
           {if(param)
             {var
               r=param[4],
               v=param[3],
               k=param[2],
               l=param[1],
               c=caml_call2(cmp,x,k);
              return 0 === c
                      ?_jh_(l,r)
                      :0 <= c?bal$0(l,k,v,loop(r)):bal$0(loop(l),k,v,r)}
            throw Not_found}
          return loop(map)},
       update$0=
        function(k1,k2,v2,cmp,map)
         {if(0 === caml_call2(cmp,k1,k2))
           {var
             loop=
              function(node)
               {if(node)
                 {var
                   h=node[5],
                   r=node[4],
                   v=node[3],
                   k=node[2],
                   l=node[1],
                   c=caml_call2(cmp,k1,k);
                  if(0 === c)
                   {if(v === v2 && k === k2)return node;return [0,l,k2,v2,r,h]}
                  if(0 <= c)
                   {var nr=loop(r);return nr === r?node:[0,l,k,v,nr,h]}
                  var nl=loop(l);
                  return nl === l?node:[0,nl,k,v,r,h]}
                throw Not_found};
            return loop(map)}
          return add$5(k2,v2,cmp,remove_exn$0(k1,cmp,map))},
       update_stdlib=
        function(x,f,cmp,m)
         {if(m)
           {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(cmp,x,v);
            if(0 === c)
             {var _aN3_=[0,d],match=caml_call1(f,_aN3_);
              if(match)
               {var data=match[1];return d === data?m:[0,l,x,data,r,h]}
              return _jh_(l,r)}
            if(0 <= c)
             {var rr=update_stdlib(x,f,cmp,r);
              return r === rr?m:bal$0(l,v,d,rr)}
            var ll=update_stdlib(x,f,cmp,l);
            return l === ll?m:bal$0(ll,v,d,r)}
          var _aN4_=0,match$0=caml_call1(f,_aN4_);
          if(match$0){var data$0=match$0[1];return [0,0,x,data$0,0,1]}
          return 0},
       mem$0=
        function(x,cmp,map)
         {function loop(param)
           {var param$0=param;
            for(;;)
             {if(param$0)
               {var
                 r=param$0[4],
                 k=param$0[2],
                 l=param$0[1],
                 c=caml_call2(cmp,x,k),
                 _aN2_=0 === c?1:0;
                if(_aN2_)return _aN2_;
                var param$1=0 <= c?r:l,param$0=param$1;
                continue}
              return 0}}
          return loop(map)},
       map$5=
        function(f,map)
         {function loop(param)
           {if(param)
             {var
               h=param[5],
               r=param[4],
               v=param[3],
               k=param[2],
               l=param[1],
               l$0=loop(l),
               v$0=caml_call1(f,v),
               r$0=loop(r);
              return [0,l$0,k,v$0,r$0,h]}
            return 0}
          return loop(map)},
       mapi$0=
        function(f,map)
         {function loop(param)
           {if(param)
             {var
               h=param[5],
               r=param[4],
               v=param[3],
               k=param[2],
               l=param[1],
               l$0=loop(l),
               v$0=caml_call2(f,k,v),
               r$0=loop(r);
              return [0,l$0,k,v$0,r$0,h]}
            return 0}
          return loop(map)},
       foldi=
        function(f,map,acc)
         {function loop(acc,param)
           {var acc$0=acc,param$0=param;
            for(;;)
             {if(param$0)
               {var
                 r=param$0[4],
                 v=param$0[3],
                 k=param$0[2],
                 l=param$0[1],
                 _aN1_=loop(acc$0,l),
                 acc$1=caml_call3(f,k,v,_aN1_),
                 acc$0=acc$1,
                 param$0=r;
                continue}
              return acc$0}}
          return loop(acc,map)},
       singleton$1=function(x,d){return [0,0,x,d,0,1]},
       add_min_binding=
        function(k,v,param)
         {if(param)
           {var r=param[4],d=param[3],x=param[2],l=param[1];
            return bal$0(add_min_binding(k,v,l),x,d,r)}
          return singleton$1(k,v)},
       add_max_binding=
        function(k,v,param)
         {if(param)
           {var r=param[4],d=param[3],x=param[2],l=param[1];
            return bal$0(l,x,d,add_max_binding(k,v,r))}
          return singleton$1(k,v)},
       join$1=
        function(l,v,d,r)
         {if(l)
           {if(r)
             {var
               rh=r[5],
               rr=r[4],
               rd=r[3],
               rv=r[2],
               rl=r[1],
               lh=l[5],
               lr=l[4],
               ld=l[3],
               lv=l[2],
               ll=l[1];
              return (rh + 2 | 0) < lh
                      ?bal$0(ll,lv,ld,join$1(lr,v,d,r))
                      :(lh + 2 | 0) < rh
                        ?bal$0(join$1(l,v,d,rl),rv,rd,rr)
                        :create$8(l,v,d,r)}
            return add_max_binding(v,d,l)}
          return add_min_binding(v,d,r)},
       split$0=
        function(key,cmp,param)
         {if(param)
           {var
             r=param[4],
             d=param[3],
             x=param[2],
             l=param[1],
             c=caml_call2(cmp,key,x);
            if(0 === c)return [0,l,[0,d],r];
            if(0 <= c)
             {var
               match=split$0(key,cmp,r),
               rr=match[3],
               pres=match[2],
               lr=match[1];
              return [0,join$1(l,x,d,lr),pres,rr]}
            var
             match$0=split$0(key,cmp,l),
             rl=match$0[3],
             pres$0=match$0[2],
             ll=match$0[1];
            return [0,ll,pres$0,join$1(rl,x,d,r)]}
          return _ji_},
       cardinal$0=
        function(map)
         {function loop(acc,param)
           {var acc$0=acc,param$0=param;
            for(;;)
             {if(param$0)
               {var
                 r=param$0[4],
                 l=param$0[1],
                 _aN0_=acc$0 + 1 | 0,
                 acc$1=loop(_aN0_,r),
                 acc$0=acc$1,
                 param$0=l;
                continue}
              return acc$0}}
          return loop(0,map)},
       bindings_aux=
        function(accu,param)
         {var accu$0=accu,param$0=param;
          for(;;)
           {if(param$0)
             {var
               r=param$0[4],
               d=param$0[3],
               v=param$0[2],
               l=param$0[1],
               accu$1=[0,[0,v,d],bindings_aux(accu$0,r)],
               accu$0=accu$1,
               param$0=l;
              continue}
            return accu$0}},
       bindings=function(s){return bindings_aux(0,s)},
       cons_iter$0=
        function(s,t)
         {var s$0=s,t$0=t;
          for(;;)
           {if(s$0)
             {var
               r=s$0[4],
               v=s$0[3],
               k=s$0[2],
               s$1=s$0[1],
               t$1=[0,k,v,r,t$0],
               s$0=s$1,
               t$0=t$1;
              continue}
            return t$0}},
       rev_cons_iter$0=
        function(s,t)
         {var s$0=s,t$0=t;
          for(;;)
           {if(s$0)
             {var
               s$1=s$0[4],
               v=s$0[3],
               k=s$0[2],
               l=s$0[1],
               t$1=[0,k,v,l,t$0],
               s$0=s$1,
               t$0=t$1;
              continue}
            return t$0}},
       cons_iter_from$0=
        function(cmp,k2,m,e)
         {var m$0=m,e$0=e;
          for(;;)
           {if(m$0)
             {var r=m$0[4],v=m$0[3],k=m$0[2],l=m$0[1];
              if(0 < caml_call2(cmp,k2,k)){var m$0=r;continue}
              var e$1=[0,k,v,r,e$0],m$0=l,e$0=e$1;
              continue}
            return e$0}},
       enum_next$0=
        function(l,param)
         {var _aNZ_=l[1];
          if(_aNZ_)
           {var t=_aNZ_[4],m=_aNZ_[3],v=_aNZ_[2],k=_aNZ_[1];
            l[1] = cons_iter$0(m,t);
            return [0,k,v]}
          throw No_more_elements},
       enum_backwards_next$0=
        function(l,param)
         {var _aNY_=l[1];
          if(_aNY_)
           {var t=_aNY_[4],m=_aNY_[3],v=_aNY_[2],k=_aNY_[1];
            l[1] = rev_cons_iter$0(m,t);
            return [0,k,v]}
          throw No_more_elements},
       enum_count$0=
        function(l,param)
         {function aux(n,param)
           {var n$0=n,param$0=param;
            for(;;)
             {if(param$0)
               {var
                 t=param$0[4],
                 m=param$0[3],
                 n$1=(n$0 + 1 | 0) + cardinal$0(m) | 0,
                 n$0=n$1,
                 param$0=t;
                continue}
              return n$0}}
          return aux(0,l[1])},
       enum$2=
        function(t)
         {function make(l)
           {var l$0=[0,l];
            function clone(param){return make(l$0[1])}
            function _aNV_(_aNX_){return enum_count$0(l$0,_aNX_)}
            return make$3
                    (function(_aNW_){return enum_next$0(l$0,_aNW_)},_aNV_,clone)}
          var _aNU_=0;
          return make(cons_iter$0(t,_aNU_))},
       backwards$0=
        function(t)
         {function make(l)
           {var l$0=[0,l];
            function clone(param){return make(l$0[1])}
            function _aNR_(_aNT_){return enum_count$0(l$0,_aNT_)}
            return make$3
                    (function(_aNS_){return enum_backwards_next$0(l$0,_aNS_)},
                     _aNR_,
                     clone)}
          var _aNQ_=0;
          return make(rev_cons_iter$0(t,_aNQ_))},
       keys=
        function(t)
         {var _aNO_=enum$2(t);
          return symbol(function(_aNP_){return _aNP_[1]},_aNO_)},
       values=
        function(t)
         {var _aNM_=enum$2(t);
          return symbol(function(_aNN_){return _aNN_[2]},_aNM_)},
       of_enum$2=
        function(cmp,e)
         {return fold$1
                  (function(m,param)
                    {var v=param[2],k=param[1];return add$5(k,v,cmp,m)},
                   empty$1,
                   e)},
       print$1=
        function(opt,_aNK_,_aNJ_,_aNI_,print_k,print_v,out,t)
         {if(opt)var sth=opt[1],first=sth;else var first=_jn_;
          if(_aNK_)var sth$0=_aNK_[1],last=sth$0;else var last=_jm_;
          if(_aNJ_)var sth$1=_aNJ_[1],sep=sth$1;else var sep=_jl_;
          if(_aNI_)var sth$2=_aNI_[1],kvsep=sth$2;else var kvsep=_jk_;
          var _aNL_=enum$2(t);
          return print
                  ([0,first],
                   [0,last],
                   [0,sep],
                   function(out,param)
                    {var v=param[2],k=param[1];
                     return caml_call5
                             (fprintf$0(out,_jj_),print_k,k,kvsep,print_v,v)},
                   out,
                   _aNL_)},
       filterv=
        function(f,t,cmp)
         {return foldi
                  (function(k,a,acc)
                    {return caml_call1(f,a)?acc:remove$1(k,cmp,acc)},
                   t,
                   t)},
       filter$0=
        function(f,t,cmp)
         {return foldi
                  (function(k,a,acc)
                    {return caml_call2(f,k,a)?acc:remove$1(k,cmp,acc)},
                   t,
                   t)},
       filter_map=
        function(f,t,cmp)
         {return foldi
                  (function(k,a,acc)
                    {var match=caml_call2(f,k,a);
                     if(match){var v=match[1];return add$5(k,v,cmp,acc)}
                     return acc},
                   t,
                   empty$1)},
       for_all$1=
        function(f,map)
         {function loop(param)
           {var param$0=param;
            for(;;)
             {if(param$0)
               {var
                 r=param$0[4],
                 v=param$0[3],
                 k=param$0[2],
                 l=param$0[1],
                 _aNF_=caml_call2(f,k,v);
                if(_aNF_)
                 {var _aNG_=loop(l);
                  if(_aNG_){var param$0=r;continue}
                  var _aNH_=_aNG_}
                else
                 var _aNH_=_aNF_;
                return _aNH_}
              return 1}}
          return loop(map)},
       exists$1=
        function(f,map)
         {function loop(param)
           {var param$0=param;
            for(;;)
             {if(param$0)
               {var
                 r=param$0[4],
                 v=param$0[3],
                 k=param$0[2],
                 l=param$0[1],
                 _aNC_=caml_call2(f,k,v);
                if(_aNC_)
                 var _aND_=_aNC_;
                else
                 {var _aNE_=loop(l);
                  if(! _aNE_){var param$0=r;continue}
                  var _aND_=_aNE_}
                return _aND_}
              return 0}}
          return loop(map)},
       partition$0=
        function(f,cmp,map)
         {function loop(m1,m2,param)
           {if(param)
             {var
               r=param[4],
               v=param[3],
               k=param[2],
               l=param[1],
               match=loop(m1,m2,l),
               m2$0=match[2],
               m1$0=match[1],
               match$0=loop(m1$0,m2$0,r),
               m2$1=match$0[2],
               m1$1=match$0[1];
              return caml_call2(f,k,v)
                      ?[0,add$5(k,v,cmp,m1$1),m2$1]
                      :[0,m1$1,add$5(k,v,cmp,m2$1)]}
            return [0,m1,m2]}
          return loop(empty$1,empty$1,map)},
       choose_opt=
        function(m)
         {try
           {var _aNA_=[0,min_binding(m)];return _aNA_}
          catch(_aNB_)
           {_aNB_ = caml_wrap_exception(_aNB_);
            if(_aNB_ === Not_found)return 0;
            throw _aNB_}},
       any=
        function(param)
         {if(param){var v=param[3],k=param[2];return [0,k,v]}throw Not_found},
       modify=
        function(x,f,cmp,map)
         {function loop(param)
           {if(param)
             {var
               h=param[5],
               r=param[4],
               v=param[3],
               k=param[2],
               l=param[1],
               c=caml_call2(cmp,x,k);
              if(0 === c)return [0,l,x,caml_call1(f,v),r,h];
              if(0 <= c){var nr=loop(r);return bal$0(l,k,v,nr)}
              var nl=loop(l);
              return bal$0(nl,k,v,r)}
            throw Not_found}
          return loop(map)},
       modify_def=
        function(v0,x,f,cmp,map)
         {function loop(param)
           {if(param)
             {var
               h=param[5],
               r=param[4],
               v=param[3],
               k=param[2],
               l=param[1],
               c=caml_call2(cmp,x,k);
              if(0 === c)return [0,l,x,caml_call1(f,v),r,h];
              if(0 <= c){var nr=loop(r);return bal$0(l,k,v,nr)}
              var nl=loop(l);
              return bal$0(nl,k,v,r)}
            var _aNy_=1,_aNz_=0;
            return [0,0,x,caml_call1(f,v0),_aNz_,_aNy_]}
          return loop(map)},
       modify_opt=
        function(x,f,cmp,map)
         {function loop(param)
           {if(param)
             {var
               h=param[5],
               r=param[4],
               v=param[3],
               k=param[2],
               l=param[1],
               c=caml_call2(cmp,x,k);
              if(0 === c)
               {var _aNw_=[0,v],match=caml_call1(f,_aNw_);
                if(match){var v$0=match[1];return [0,l,x,v$0,r,h]}
                return _jh_(l,r)}
              if(0 <= c){var nr=loop(r);return bal$0(l,k,v,nr)}
              var nl=loop(l);
              return bal$0(nl,k,v,r)}
            var _aNx_=0,match$0=caml_call1(f,_aNx_);
            if(match$0){var d=match$0[1];return [0,0,x,d,0,1]}
            throw Exit}
          try
           {var _aNu_=loop(map);return _aNu_}
          catch(_aNv_)
           {_aNv_ = caml_wrap_exception(_aNv_);
            if(_aNv_ === Exit)return map;
            throw _aNv_}},
       extract=
        function(x,cmp,map)
         {function loop(param)
           {if(param)
             {var
               r=param[4],
               v=param[3],
               k=param[2],
               l=param[1],
               c=caml_call2(cmp,x,k);
              if(0 === c)return [0,v,_jh_(l,r)];
              if(0 <= c)
               {var match=loop(r),nr=match[2],vout=match[1];
                return [0,vout,bal$0(l,k,v,nr)]}
              var match$0=loop(l),nl=match$0[2],vout$0=match$0[1];
              return [0,vout$0,bal$0(nl,k,v,r)]}
            throw Not_found}
          return loop(map)},
       pop$2=
        function(map)
         {if(map)
           {var r=map[4],v=map[3],k=map[2],l=map[1];
            return [0,[0,k,v],_jh_(l,r)]}
          throw Not_found},
       concat$0=
        function(t1,t2)
         {if(t1)
           {if(t2)
             {var match=min_binding(t2),d=match[2],x=match[1];
              return join$1(t1,x,d,remove_min_binding(t2))}
            return t1}
          return t2},
       concat_or_join=
        function(t1,v,d,t2)
         {if(d){var d$0=d[1];return join$1(t1,v,d$0,t2)}
          return concat$0(t1,t2)},
       merge$0=
        function(f,cmp12,s1,s2)
         {function loop(s1,s2)
           {if(s1)
             {var h1=s1[5],r1=s1[4],d1=s1[3],v1=s1[2],l1=s1[1];
              if(height$0(s2) <= h1)
               {var
                 match=split$0(v1,cmp12,s2),
                 r2=match[3],
                 d2=match[2],
                 l2=match[1],
                 _aNo_=loop(r1,r2),
                 _aNp_=[0,d1],
                 _aNq_=caml_call3(f,v1,_aNp_,d2);
                return concat_or_join(loop(l1,l2),v1,_aNq_,_aNo_)}}
            else
             if(! s2)return 0;
            if(s2)
             {var
               r2$0=s2[4],
               d2$0=s2[3],
               v2=s2[2],
               l2$0=s2[1],
               match$0=split$0(v2,cmp12,s1),
               r1$0=match$0[3],
               d1$0=match$0[2],
               l1$0=match$0[1],
               _aNr_=loop(r1$0,r2$0),
               _aNs_=[0,d2$0],
               _aNt_=caml_call3(f,v2,d1$0,_aNs_);
              return concat_or_join(loop(l1$0,l2$0),v2,_aNt_,_aNr_)}
            throw [0,Assert_failure,_jo_]}
          return loop(s1,s2)},
       merge_diverse=
        function(f,cmp1,s1,cmp2,s2)
         {function _aNj_(k,v1,acc)
           {var
             _aNm_=find_option(k,cmp2,s2),
             _aNn_=[0,v1],
             match=caml_call3(f,k,_aNn_,_aNm_);
            if(match){var v3=match[1];return add$5(k,v3,cmp1,acc)}
            return acc}
          var first_phase_result=foldi(_aNj_,s1,empty$1);
          return foldi
                  (function(k,v2,acc)
                    {if(mem$0(k,cmp1,s1))return acc;
                     var _aNk_=[0,v2],_aNl_=0,match=caml_call3(f,k,_aNl_,_aNk_);
                     if(match){var v3=match[1];return add$5(k,v3,cmp1,acc)}
                     return acc},
                   s2,
                   first_phase_result)},
       ordered=
        function(cmp,s)
         {if(0 === s)return 1;
          try
           {var
             _aNe_=min_binding(s)[1],
             _aNf_=remove_min_binding(s),
             _aNg_=
              function(k,param,last_k)
               {if(0 <= caml_call2(cmp,last_k,k))throw Exit;return k};
            foldi(_aNg_,_aNf_,_aNe_);
            var _aNh_=1;
            return _aNh_}
          catch(_aNi_)
           {_aNi_ = caml_wrap_exception(_aNi_);
            if(_aNi_ === Exit)return 0;
            throw _aNi_}},
       compatible_cmp=
        function(cmp1,m1,cmp2,m2)
         {var _aNd_=cmp1 === cmp2?1:0;return _aNd_?_aNd_:ordered(cmp1,m2)},
       heuristic_merge=
        function(f,cmp1,m1,cmp2,m2)
         {return compatible_cmp(cmp1,m1,cmp2,m2)
                  ?merge$0(f,cmp1,m1,m2)
                  :merge_diverse(f,cmp1,m1,cmp2,m2)},
       add_seq$0=
        function(cmp,s,m)
         {return fold_left$1
                  (function(m,param)
                    {var v=param[2],k=param[1];return add$5(k,v,cmp,m)},
                   m,
                   s)},
       of_seq$0=function(cmp,s){return add_seq$0(cmp,s,empty$1)},
       seq_of_iter$0=
        function(m,param)
         {if(m)
           {var e=m[4],r=m[3],v=m[2],k=m[1],_aNb_=cons_iter$0(r,e);
            return [0,
                    [0,k,v],
                    function(_aNc_){return seq_of_iter$0(_aNb_,_aNc_)}]}
          return 0},
       to_seq$1=
        function(m)
         {var _aM__=0,_aM$_=cons_iter$0(m,_aM__);
          return function(_aNa_){return seq_of_iter$0(_aM$_,_aNa_)}},
       rev_seq_of_iter$0=
        function(m,param)
         {if(m)
           {var e=m[4],r=m[3],v=m[2],k=m[1],_aM8_=rev_cons_iter$0(r,e);
            return [0,
                    [0,k,v],
                    function(_aM9_){return rev_seq_of_iter$0(_aM8_,_aM9_)}]}
          return 0},
       to_rev_seq$0=
        function(m)
         {var _aM5_=0,_aM6_=rev_cons_iter$0(m,_aM5_);
          return function(_aM7_){return rev_seq_of_iter$0(_aM6_,_aM7_)}},
       to_seq_from$0=
        function(cmp,k,m)
         {var _aM2_=0,_aM3_=cons_iter_from$0(cmp,k,m,_aM2_);
          return function(_aM4_){return seq_of_iter$0(_aM3_,_aM4_)}},
       union_stdlib=
        function(f,cmp1,m1,cmp2,m2)
         {function fwrap(a,b1,b2)
           {if(b1 && b2)
             {var b2$0=b2[1],b1$0=b1[1];return caml_call3(f,a,b1$0,b2$0)}
            var x=b2 || b1;
            return x}
          return heuristic_merge(fwrap,cmp1,m1,cmp2,m2)},
       Make$7=
        function(Ord)
         {var
           include=_af_(Ord),
           empty=include[1],
           is_empty=include[2],
           mem=include[3],
           add=include[4],
           remove=include[7],
           compare=include[10],
           equal=include[11],
           iter=include[12],
           fold=include[13],
           find=include[28];
          function cardinal(t){return cardinal$0(t)}
          function enum$0(t){return enum$2(t)}
          function backwards(t){return backwards$0(t)}
          function keys$0(t){return keys(t)}
          function values$0(t){return values(t)}
          function update(k1,k2,v2,t){return update$0(k1,k2,v2,Ord[1],t)}
          function update_stdlib$0(k,f,m){return update_stdlib(k,f,Ord[1],m)}
          function find_default$0(d,k,t){return find_default(d,k,Ord[1],t)}
          function find_opt(k,t){return find_option(k,Ord[1],t)}
          function find_first(f,t){return find_first$0(f,t)}
          function find_first_opt(f,t){return find_first_opt$0(f,t)}
          function find_last(f,t){return find_last$0(f,t)}
          function find_last_opt(f,t){return find_last_opt$0(f,t)}
          function of_enum(e){return of_enum$2(Ord[1],e)}
          function mapi(f,t){return mapi$0(f,t)}
          function map(f,t){return map$5(f,t)}
          function print(first,last,sep,kvsep,print_k,print_v,out,t)
           {return print$1(first,last,sep,kvsep,print_k,print_v,out,t)}
          function filterv$0(f,t){return filterv(f,t,Ord[1])}
          function filter(f,t){return filter$0(f,t,Ord[1])}
          function filter_map$0(f,t){return filter_map(f,t,Ord[1])}
          function exists(f,t){return exists$1(f,t)}
          function for_all(f,t){return for_all$1(f,t)}
          function min_binding$0(t){return min_binding(t)}
          function pop_min_binding$0(t)
           {var match=pop_min_binding(t),rest=match[2],mini=match[1];
            return [0,mini,rest]}
          function max_binding$0(t){return max_binding(t)}
          function pop_max_binding$0(t)
           {var match=pop_max_binding(t),rest=match[2],maxi=match[1];
            return [0,maxi,rest]}
          function max_binding_opt$0(t){return max_binding_opt(t)}
          function min_binding_opt$0(t){return min_binding_opt(t)}
          function choose(t){return min_binding(t)}
          function choose_opt$0(t){return choose_opt(t)}
          function any$0(t){return any(t)}
          function split(k,t)
           {var
             _aM1_=Ord[1],
             match=split$0(k,_aM1_,t),
             r=match[3],
             v=match[2],
             l=match[1];
            return [0,l,v,r]}
          function partition(p,t)
           {var
             _aM0_=Ord[1],
             match=partition$0(p,_aM0_,t),
             r=match[2],
             l=match[1];
            return [0,l,r]}
          function remove_exn(x,m){return remove_exn$0(x,Ord[1],m)}
          function modify$0(x,f,m){return modify(x,f,Ord[1],m)}
          function modify_def$0(v0,x,f,m){return modify_def(v0,x,f,Ord[1],m)}
          function modify_opt$0(x,f,m){return modify_opt(x,f,Ord[1],m)}
          function extract$0(k,t)
           {var _aMZ_=Ord[1],match=extract(k,_aMZ_,t),t$0=match[2],v=match[1];
            return [0,v,t$0]}
          function pop(t)
           {var match=pop$2(t),t$0=match[2],kv=match[1];return [0,kv,t$0]}
          function singleton(k,v){return singleton$1(k,v)}
          function bindings$0(t){return bindings(t)}
          function union(f,m1,m2){return union_stdlib(f,Ord[1],m1,Ord[1],m2)}
          function merge(f,t1,t2){return merge$0(f,Ord[1],t1,t2)}
          function of_seq(s){return of_seq$0(Ord[1],s)}
          function add_seq(s,m){return add_seq$0(Ord[1],s,m)}
          function to_seq(m){return to_seq$1(m)}
          function to_rev_seq(m){return to_rev_seq$0(m)}
          function to_seq_from(k,m){return to_seq_from$0(Ord[1],k,m)}
          function find$0(k,t)
           {try
             {var _aMX_=[0,caml_call2(find,k,t)];return _aMX_}
            catch(_aMY_)
             {_aMY_ = caml_wrap_exception(_aMY_);
              if(_aMY_ === Not_found)return 0;
              throw _aMY_}}
          function choose$0(t)
           {try
             {var _aMV_=[0,choose(t)];return _aMV_}
            catch(_aMW_)
             {_aMW_ = caml_wrap_exception(_aMW_);
              if(_aMW_ === Not_found)return 0;
              throw _aMW_}}
          function any$1(t)
           {try
             {var _aMT_=[0,any$0(t)];return _aMT_}
            catch(_aMU_)
             {_aMU_ = caml_wrap_exception(_aMU_);
              if(_aMU_ === Not_found)return 0;
              throw _aMU_}}
          var Exceptionless=[0,find$0,choose$0,any$1];
          function symbol(map,key){return caml_call2(find,key,map)}
          function symbol$0(map,param)
           {var value=param[2],key=param[1];
            return caml_call3(add,key,value,map)}
          var Infix=[0,symbol,symbol$0];
          function add$0(key,data,t){return caml_call3(add,key,data,t)}
          function iter$0(f,t)
           {return caml_call2
                    (iter,function(key,data){return caml_call2(f,key,data)},t)}
          function map$0(f,t){return map(f,t)}
          function mapi$1(f,t)
           {return mapi(function(key,data){return caml_call2(f,key,data)},t)}
          function fold$0(f,t,init)
           {return caml_call3
                    (fold,
                     function(key,data,acc){return caml_call3(f,key,data,acc)},
                     t,
                     init)}
          function compare$0(cmp,a,b){return caml_call3(compare,cmp,a,b)}
          function equal$0(cmp,a,b){return caml_call3(equal,cmp,a,b)}
          function filterv$1(f)
           {return function(_aMS_){return filterv$0(f,_aMS_)}}
          function filter$1(f){return function(_aMR_){return filter(f,_aMR_)}}
          var
           Labels=
            [0,
             add$0,
             iter$0,
             map$0,
             mapi$1,
             fold$0,
             compare$0,
             equal$0,
             filterv$1,
             filter$1];
          return [0,
                  empty,
                  is_empty,
                  mem,
                  add,
                  remove,
                  compare,
                  equal,
                  iter,
                  fold,
                  find,
                  cardinal,
                  enum$0,
                  backwards,
                  keys$0,
                  values$0,
                  update,
                  update_stdlib$0,
                  find_default$0,
                  find_opt,
                  find_first,
                  find_first_opt,
                  find_last,
                  find_last_opt,
                  of_enum,
                  mapi,
                  map,
                  print,
                  filterv$0,
                  filter,
                  filter_map$0,
                  exists,
                  for_all,
                  min_binding$0,
                  pop_min_binding$0,
                  max_binding$0,
                  pop_max_binding$0,
                  max_binding_opt$0,
                  min_binding_opt$0,
                  choose,
                  choose_opt$0,
                  any$0,
                  split,
                  partition,
                  remove_exn,
                  modify$0,
                  modify_def$0,
                  modify_opt$0,
                  extract$0,
                  pop,
                  singleton,
                  bindings$0,
                  union,
                  merge,
                  of_seq,
                  add_seq,
                  to_seq,
                  to_rev_seq,
                  to_seq_from,
                  Exceptionless,
                  Infix,
                  Labels]};
      Make$7([0,compare$7]);
      Make$7([0,compare$9]);
      Make$7([0,compare$10]);
      Make$7([0,compare$11]);
      Make$7([0,_h$_]);
      Make$7([0,compare]);
      Make$7([0,compare$0]);
      var
       add$6=
        function(x,d,m)
         {return add$5
                  (x,
                   d,
                   function(_aMQ_,_aMP_){return caml_compare(_aMQ_,_aMP_)},
                   m)},
       find$2=
        function(x,m)
         {return find$1
                  (x,
                   function(_aMO_,_aMN_){return caml_compare(_aMO_,_aMN_)},
                   m)},
       find_opt$0=
        function(x,m)
         {return find_option
                  (x,
                   function(_aMM_,_aML_){return caml_compare(_aMM_,_aML_)},
                   m)},
       find_default$0=
        function(def,x,m)
         {return find_default
                  (def,
                   x,
                   function(_aMK_,_aMJ_){return caml_compare(_aMK_,_aMJ_)},
                   m)},
       remove$2=
        function(x,m)
         {return remove$1
                  (x,
                   function(_aMI_,_aMH_){return caml_compare(_aMI_,_aMH_)},
                   m)},
       mem$1=
        function(x,m)
         {return mem$0
                  (x,
                   function(_aMG_,_aMF_){return caml_compare(_aMG_,_aMF_)},
                   m)},
       keys$0=
        function(t)
         {var _aMD_=enum$2(t);
          return symbol(function(_aME_){return _aME_[1]},_aMD_)},
       singleton$2=function(k,v){return singleton$1(k,v)},
       modify$0=
        function(x,f,m)
         {return modify
                  (x,
                   f,
                   function(_aMC_,_aMB_){return caml_compare(_aMC_,_aMB_)},
                   m)},
       modify_def$0=
        function(v0,x,f,m)
         {return modify_def
                  (v0,
                   x,
                   f,
                   function(_aMA_,_aMz_){return caml_compare(_aMA_,_aMz_)},
                   m)},
       modify_opt$0=
        function(x,f,m)
         {return modify_opt
                  (x,
                   f,
                   function(_aMy_,_aMx_){return caml_compare(_aMy_,_aMx_)},
                   m)},
       find$3=
        function(k,m)
         {try
           {var _aMv_=[0,find$2(k,m)];return _aMv_}
          catch(_aMw_)
           {_aMw_ = caml_wrap_exception(_aMw_);
            if(_aMw_ === Not_found)return 0;
            throw _aMw_}},
       _jp_=caml_sys_argv(0);
      caml_check_bound(_jp_,0);
      caml_sys_argv(0);
      at_exit(close_all);
      at_exit(flush_all$0);
      var
       Out_of_range=[248,_jq_,caml_fresh_oo_id(0)],
       of_char=function(_aMu_){return _aMu_},
       chr$0=
        function(n)
         {var switch$0=0;
          if(0 <= n && ! (55295 < n))switch$0 = 1;
          if(! switch$0)
           {var switch$1=0;
            if(! (57344 <= n) || 1114111 < n)switch$1 = 1;
            if(switch$1)throw Out_of_range}
          return n},
       of_int$0=function(n){return chr$0(n)},
       add_uchar=
        function(buf,k)
         {if(127 < k)
           {if(2047 < k)
             {if(65535 < k)
               {var _aMo_=240 + (k >>> 18 | 0) | 0;
                add_char(buf,_aMo_);
                var _aMp_=128 | (k >>> 12 | 0) & 63;
                add_char(buf,_aMp_);
                var _aMq_=128 | (k >>> 6 | 0) & 63;
                add_char(buf,_aMq_);
                return add_char(buf,128 | k & 63)}
              var _aMr_=224 | k >>> 12 | 0;
              add_char(buf,_aMr_);
              var _aMs_=128 | (k >>> 6 | 0) & 63;
              add_char(buf,_aMs_);
              return add_char(buf,128 | k & 63)}
            var _aMt_=192 | k >>> 6 | 0;
            add_char(buf,_aMt_);
            return add_char(buf,128 | k & 63)}
          return add_char(buf,k)},
       init$1=
        function(len,f)
         {var buf=create$1(len),_aMl_=len - 1 | 0,_aMk_=0;
          if(! (_aMl_ < 0))
           {var c=_aMk_;
            for(;;)
             {var _aMm_=caml_call1(f,c);
              add_uchar(buf,_aMm_);
              var _aMn_=c + 1 | 0;
              if(_aMl_ !== c){var c=_aMn_;continue}
              break}}
          return contents(buf)},
       make$4=function(len,u){return init$1(len,function(param){return u})},
       of_char$0=function(u){return make$4(1,u)},
       of_latin1=
        function(s)
         {return init$1
                  (caml_ml_string_length(s),
                   function(i){return of_char(caml_string_get(s,i))})},
       equal$4=function(x,y){return x === y?1:0},
       to_int$0=function(x){return x},
       intersect=function(x,y){return 0 !== (x & y)?1:0},
       symbol$1=function(x,y){return x | y},
       dummy$1=-1,
       inexistant=1,
       letter=2,
       not_letter=4,
       newline=8,
       lastnewline=16,
       search_boundary=32,
       from_char=
        function(param)
         {var switch$0=0;
          if(170 <= param)
           if(187 <= param)
            {var _aMh_=param - 192 | 0;
             if(54 < _aMh_ >>> 0)
              {if(56 <= _aMh_)switch$0 = 1}
             else
              if(23 !== _aMh_)switch$0 = 1}
           else
            {var _aMi_=param - 171 | 0;
             if(14 < _aMi_ >>> 0 || 10 === _aMi_)switch$0 = 1}
          else
           if(65 <= param)
            {var _aMj_=param - 91 | 0;
             if(5 < _aMj_ >>> 0)
              {if(! (32 <= _aMj_))switch$0 = 1}
             else
              if(4 === _aMj_)switch$0 = 1}
           else
            if(48 <= param)
             {if(! (58 <= param))switch$0 = 1}
            else
             if(10 === param)return symbol$1(not_letter,newline);
          return switch$0?letter:not_letter},
       union$0=
        function(l$0,l)
         {var l$2=l$0,l$1=l;
          for(;;)
           {if(l$1)
             {if(l$2)
               {var
                 r=l$1[2],
                 _aMg_=l$1[1],
                 c2=_aMg_[2],
                 c1=_aMg_[1],
                 r$0=l$2[2],
                 match=l$2[1],
                 c2$0=match[2],
                 c1$0=match[1];
                if((c2$0 + 1 | 0) < c1)
                 return [0,[0,c1$0,c2$0],union$0(r$0,l$1)];
                if((c2 + 1 | 0) < c1$0)return [0,[0,c1,c2],union$0(l$2,r)];
                if(c2$0 < c2)
                 {var l$3=[0,[0,min(c1$0,c1),c2],r],l$2=r$0,l$1=l$3;continue}
                var l$4=[0,[0,min(c1$0,c1),c2$0],r$0],l$2=l$4,l$1=r;
                continue}
              return l$1}
            return l$2}},
       inter$0=
        function(l$0,l)
         {var l$2=l$0,l$1=l;
          for(;;)
           {if(l$1)
             {if(l$2)
               {var
                 r=l$1[2],
                 _aMd_=l$1[1],
                 c2=_aMd_[2],
                 c1=_aMd_[1],
                 r$0=l$2[2],
                 match=l$2[1],
                 c2$0=match[2],
                 c1$0=match[1];
                if(caml_lessthan(c2$0,c1)){var l$2=r$0;continue}
                if(caml_lessthan(c2,c1$0)){var l$1=r;continue}
                if(caml_lessthan(c2$0,c2))
                 {var _aMe_=inter$0(r$0,l$1);
                  return [0,[0,max(c1$0,c1),c2$0],_aMe_]}
                var _aMf_=inter$0(l$2,r);
                return [0,[0,max(c1$0,c1),c2],_aMf_]}
              return 0}
            return 0}},
       diff$0=
        function(l$0,l)
         {var l$2=l$0,l$1=l;
          for(;;)
           {if(l$1)
             {if(l$2)
               {var
                 r=l$1[2],
                 _aMc_=l$1[1],
                 c2=_aMc_[2],
                 c1=_aMc_[1],
                 r$0=l$2[2],
                 match=l$2[1],
                 c2$0=match[2],
                 c1$0=match[1];
                if(c2$0 < c1)return [0,[0,c1$0,c2$0],diff$0(r$0,l$1)];
                if(c2 < c1$0){var l$1=r;continue}
                var r$1=c2 < c2$0?[0,[0,c2 + 1 | 0,c2$0],r$0]:r$0;
                if(c1$0 < c1)return [0,[0,c1$0,c1 - 1 | 0],diff$0(r$1,r)];
                var l$2=r$1,l$1=r;
                continue}
              return 0}
            return l$2}},
       single=function(c){return [0,[0,c,c],0]},
       add$7=function(c,l){return union$0(single(c),l)},
       seq$0=
        function(c$0,c)
         {return caml_lessequal(c$0,c)?[0,[0,c$0,c],0]:[0,[0,c,c$0],0]},
       offset=
        function(o,l)
         {if(l)
           {var r=l[2],match=l[1],c2=match[2],c1=match[1];
            return [0,[0,c1 + o | 0,c2 + o | 0],offset(o,r)]}
          return 0},
       empty$2=0,
       mem$2=
        function(c,s)
         {var s$0=s;
          for(;;)
           {if(s$0)
             {var rem=s$0[2],match=s$0[1],c2=match[2],c1=match[1];
              if(c <= c2)return c1 <= c?1:0;
              var s$0=rem;
              continue}
            return 0}},
       hash_rec=
        function(param)
         {if(param)
           {var r=param[2],match=param[1],j=match[2],i=match[1];
            return (i + (13 * j | 0) | 0) + (257 * hash_rec(r) | 0) | 0}
          return 0},
       iter$8=
        function(t,f)
         {var t$0=t;
          for(;;)
           {if(t$0)
             {var xs=t$0[2],match=t$0[1],y=match[2],x=match[1];
              caml_call2(f,x,y);
              var t$0=xs;
              continue}
            return 0}},
       one_char=
        function(param)
         {if(param && ! param[2])
           {var match=param[1],j=match[2],i=match[1];
            if(caml_equal(i,j))return [0,i]}
          return 0},
       compare$13=
        function(param,_aMb_)
         {var v=_aMb_[2],j=_aMb_[1],u=param[2],i=param[1],c=caml_compare(i,j);
          return 0 === c?caml_compare(u,v):c},
       CSetMap=_af_([0,compare$13]),
       fold_right$2=function(t,init,f){return fold_right(f,t,init)},
       csingle=function(c){return single(c)},
       is_empty$3=function(param){return param?0:1},
       equal$5=function(x,y){return x === y?1:0},
       compare$14=function(x,y){return caml_int_compare(x,y)},
       Set=_Y_([0,compare$14]),
       hash_combine=function(h,accu){return (accu * 65599 | 0) + h | 0},
       empty$3=[0,0,Set[1]],
       hash_marks_offset=
        function(l,accu)
         {var l$0=l,accu$0=accu;
          for(;;)
           {if(l$0)
             {var
               r=l$0[2],
               match=l$0[1],
               i=match[2],
               a=match[1],
               _aMa_=hash_combine(i,accu$0),
               accu$1=hash_combine(a,_aMa_),
               l$0=r,
               accu$0=accu$1;
              continue}
            return accu$0}},
       hash$2=
        function(m,accu)
         {var _aL9_=m[2],_aL__=hash(_aL9_),_aL$_=hash_combine(_aL__,accu);
          return hash_marks_offset(m[1],_aL$_)},
       _jr_=
        function(idx,marks)
         {if(marks)
           {var _aL8_=marks[1];
            if(-1 === _aL8_[2])
             {var rem=marks[2],a=_aL8_[1];return [0,[0,a,idx],_jr_(idx,rem)]}}
          return marks},
       marks_set_idx=
        function(marks,idx)
         {var _aL6_=marks[2],_aL7_=marks[1];return [0,_jr_(idx,_aL7_),_aL6_]},
       first=
        function(f,param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var r=param$0[2],x=param$0[1],res=caml_call1(f,x);
              if(res)return res;
              var param$0=r;
              continue}
            return 0}},
       create_ids=function(param){return [0,0]},
       mk_expr=function(ids,def){ids[1]++;return [0,ids[1],def]},
       empty$4=function(ids){return mk_expr(ids,_js_)},
       cst=
        function(ids,s){return is_empty$3(s)?empty$4(ids):mk_expr(ids,[0,s])},
       alt=
        function(ids,l)
         {if(l){if(l[2])return mk_expr(ids,[1,l]);var c=l[1];return c}
          return empty$4(ids)},
       seq$1=
        function(ids,kind,x,y)
         {var _aL4_=x[2],_aL5_=y[2];
          if(typeof _aL4_ !== "number" && 1 === _aL4_[0] && ! _aL4_[1])
           return x;
          if(typeof _aL5_ !== "number" && 1 === _aL5_[0] && ! _aL5_[1])
           return y;
          if(typeof _aL4_ === "number")return y;
          if(typeof _aL5_ === "number" && 332064784 === kind)return x;
          return mk_expr(ids,[2,kind,x,y])},
       is_eps=function(expr){return typeof expr[2] === "number"?1:0},
       eps=function(ids){return mk_expr(ids,0)},
       rep=function(ids,kind,sem,x){return mk_expr(ids,[3,kind,sem,x])},
       mark=function(ids,m){return mk_expr(ids,[4,m])},
       pmark=function(ids,i){return mk_expr(ids,[8,i])},
       erase=function(ids,m$0,m){return mk_expr(ids,[5,m$0,m])},
       before=function(ids,c){return mk_expr(ids,[6,c])},
       after=function(ids,c){return mk_expr(ids,[7,c])},
       rename=
        function(ids,x)
         {var _aL0_=x[2];
          if(typeof _aL0_ !== "number")
           switch(_aL0_[0])
            {case 1:
              var l=_aL0_[1],_aL1_=function(_aL3_){return rename(ids,_aL3_)};
              return mk_expr(ids,[1,map$0(_aL1_,l)]);
             case 2:
              var z=_aL0_[3],y=_aL0_[2],k=_aL0_[1],_aL2_=rename(ids,z);
              return mk_expr(ids,[2,k,rename(ids,y),_aL2_]);
             case 3:
              var y$0=_aL0_[3],k$0=_aL0_[2],g=_aL0_[1];
              return mk_expr(ids,[3,g,k$0,rename(ids,y$0)])
             }
          return mk_expr(ids,x[2])},
       equal$6=
        function(l1,l2)
         {var l1$0=l1,l2$0=l2;
          for(;;)
           {if(l1$0)
             {var _aLH_=l1$0[1];
              switch(_aLH_[0])
               {case 0:
                 if(l2$0)
                  {var
                    _aLI_=l2$0[1],
                    _aLJ_=l1$0[2],
                    _aLK_=_aLH_[2],
                    _aLL_=_aLH_[1];
                   if(0 === _aLI_[0])
                    {var
                      r2=l2$0[2],
                      e2=_aLI_[2],
                      l2$1=_aLI_[1],
                      _aLM_=_aLK_[1] === e2[1]?1:0;
                     if(_aLM_)
                      {var _aLN_=equal$6(_aLL_,l2$1);
                       if(_aLN_){var l1$0=_aLJ_,l2$0=r2;continue}
                       var _aLO_=_aLN_}
                     else
                      var _aLO_=_aLM_;
                     return _aLO_}}
                 break;
                case 1:
                 if(l2$0)
                  {var
                    _aLP_=l2$0[1],
                    _aLQ_=l1$0[2],
                    _aLR_=_aLH_[2],
                    _aLS_=_aLH_[1];
                   if(1 === _aLP_[0])
                    {var
                      r2$0=l2$0[2],
                      e2$0=_aLP_[2],
                      marks2=_aLP_[1],
                      _aLT_=_aLR_[1] === e2$0[1]?1:0;
                     if(_aLT_)
                      {var _aLU_=caml_equal(_aLS_,marks2);
                       if(_aLU_){var l1$0=_aLQ_,l2$0=r2$0;continue}
                       var _aLV_=_aLU_}
                     else
                      var _aLV_=_aLT_;
                     return _aLV_}}
                 break;
                default:
                 if(l2$0)
                  {var _aLW_=l2$0[1],_aLX_=l1$0[2],_aLY_=_aLH_[1];
                   if(2 === _aLW_[0])
                    {var
                      r2$1=l2$0[2],
                      marks2$0=_aLW_[1],
                      _aLZ_=caml_equal(_aLY_,marks2$0);
                     if(_aLZ_){var l1$0=_aLX_,l2$0=r2$1;continue}
                     return _aLZ_}}}}
            else
             if(! l2$0)return 1;
            return 0}},
       hash$3=
        function(l,accu)
         {var l$0=l,accu$0=accu;
          for(;;)
           {if(l$0)
             {var _aLw_=l$0[1];
              switch(_aLw_[0])
               {case 0:
                 var
                  r=l$0[2],
                  e=_aLw_[2],
                  l$1=_aLw_[1],
                  _aLx_=hash$3(l$1,accu$0),
                  _aLy_=e[1],
                  _aLz_=hash_combine(_aLy_,_aLx_),
                  _aLA_=388635598,
                  accu$1=hash_combine(_aLA_,_aLz_),
                  l$0=r,
                  accu$0=accu$1;
                 continue;
                case 1:
                 var
                  r$0=l$0[2],
                  e$0=_aLw_[2],
                  marks=_aLw_[1],
                  _aLB_=hash$2(marks,accu$0),
                  _aLC_=e$0[1],
                  _aLD_=hash_combine(_aLC_,_aLB_),
                  _aLE_=726404471,
                  accu$2=hash_combine(_aLE_,_aLD_),
                  l$0=r$0,
                  accu$0=accu$2;
                 continue;
                default:
                 var
                  r$1=l$0[2],
                  marks$0=_aLw_[1],
                  _aLF_=hash$2(marks$0,accu$0),
                  _aLG_=471882453,
                  accu$3=hash_combine(_aLG_,_aLF_),
                  l$0=r$1,
                  accu$0=accu$3;
                 continue}}
            return accu$0}},
       texp=function(marks,x){return [1,marks,x]},
       tseq=
        function(kind,x,y,rem)
         {if(x)
           {var _aLv_=x[1];
            if(1 === _aLv_[0] && typeof _aLv_[2][2] === "number" && ! x[2])
             {var marks=_aLv_[1];return [0,[1,marks,y],rem]}
            return [0,[0,x,y,kind],rem]}
          return rem},
       dummy$2=[0,-1,dummy$1,0,0,-1],
       hash$4=
        function(idx,cat,desc)
         {var
           _aLr_=0,
           _aLs_=to_int$0(cat),
           _aLt_=hash_combine(_aLs_,_aLr_),
           _aLu_=hash_combine(idx,_aLt_);
          return hash$3(desc,_aLu_) & 1073741823},
       mk$0=
        function(idx,cat,desc){return [0,idx,cat,desc,0,hash$4(idx,cat,desc)]},
       create$9=function(cat,e){return mk$0(0,cat,[0,[1,empty$3,e],0])},
       equal$7=
        function(x,y)
         {var _aLl_=x[5] === y[5]?1:0;
          if(_aLl_)
           {var _aLm_=x[1] === y[1]?1:0;
            if(_aLm_)
             {var _aLn_=y[2],_aLo_=x[2],_aLp_=equal$4(_aLo_,_aLn_);
              if(_aLp_)return equal$6(x[3],y[3]);
              var _aLq_=_aLp_}
            else
             var _aLq_=_aLm_}
          else
           var _aLq_=_aLl_;
          return _aLq_},
       hash$5=function(t){return t[5]},
       Table=Make$1([0,equal$7,hash$5]),
       create_working_area=function(param){return [0,[0,0]]},
       index_count=function(w){return w[1].length - 1},
       reset_table=function(a){return fill(a,0,a.length - 1,0)},
       mark_used_indices=
        function(tbl)
         {function _aLf_(param)
           {if(0 === param[0])
             {var l=param[1];return caml_call1(mark_used_indices(tbl),l)}
            var marks=param[1],_aLh_=marks[1];
            return iter$0
                    (function(param)
                      {var i=param[2],_aLi_=0 <= i?1:0;
                       if(_aLi_)
                        {var _aLj_=1;
                         caml_check_bound(tbl,i)[1 + i] = _aLj_;
                         var _aLk_=0}
                       else
                        var _aLk_=_aLi_;
                       return _aLk_},
                     _aLh_)}
          return function(_aLg_){return iter$0(_aLf_,_aLg_)}},
       find_free=
        function(tbl,idx,len)
         {var idx$0=idx;
          for(;;)
           {if(idx$0 !== len && caml_check_bound(tbl,idx$0)[1 + idx$0])
             {var idx$1=idx$0 + 1 | 0,idx$0=idx$1;continue}
            return idx$0}},
       free_index=
        function(tbl_ref,l)
         {var tbl=tbl_ref[1];
          reset_table(tbl);
          caml_call1(mark_used_indices(tbl),l);
          var len=tbl.length - 1,_aLd_=0,idx=find_free(tbl,_aLd_,len);
          if(idx === len)
           {var _aLe_=2 * len | 0;tbl_ref[1] = caml_make_vect(_aLe_,0)}
          return idx},
       _jt_=function(param){return 2 === param[0]?0:1},
       remove_matches=find_all(_jt_),
       split_at_match_rec=
        function(l,param)
         {var l$0=l,param$0=param;
          for(;;)
           {if(param$0)
             {var _aLb_=param$0[1];
              if(2 === _aLb_[0])
               {var r=param$0[2],_aLc_=caml_call1(remove_matches,r);
                return [0,rev(l$0),_aLc_]}
              var
               param$1=param$0[2],
               l$1=[0,_aLb_,l$0],
               l$0=l$1,
               param$0=param$1;
              continue}
            throw [0,Assert_failure,_ju_]}},
       split_at_match=function(l){return split_at_match_rec(0,l)},
       remove_duplicates=
        function(prev,l,y)
         {var l$0=l;
          for(;;)
           {if(l$0)
             {var _aK8_=l$0[1];
              switch(_aK8_[0])
               {case 0:
                 var
                  r=l$0[2],
                  kind=_aK8_[3],
                  x=_aK8_[2],
                  l$1=_aK8_[1],
                  match=remove_duplicates(prev,l$1,x),
                  prev$0=match[2],
                  l$2=match[1],
                  match$0=remove_duplicates(prev$0,r,y),
                  prev$1=match$0[2],
                  r$0=match$0[1];
                 return [0,tseq(kind,l$2,x,r$0),prev$1];
                case 1:
                 if(typeof _aK8_[2][2] === "number")
                  {var r$1=l$0[2],_aK9_=y[1];
                   if(memq(_aK9_,prev)){var l$0=r$1;continue}
                   var
                    _aK__=[0,y[1],prev],
                    match$1=remove_duplicates(_aK__,r$1,y),
                    prev$2=match$1[2],
                    r$2=match$1[1];
                   return [0,[0,_aK8_,r$2],prev$2]}
                 var r$3=l$0[2],x$0=_aK8_[2],_aK$_=x$0[1];
                 if(memq(_aK$_,prev)){var l$0=r$3;continue}
                 var
                  _aLa_=[0,x$0[1],prev],
                  match$2=remove_duplicates(_aLa_,r$3,y),
                  prev$3=match$2[2],
                  r$4=match$2[1];
                 return [0,[0,_aK8_,r$4],prev$3];
                default:return [0,[0,_aK8_,0],prev]}}
            return [0,0,prev]}},
       set_idx=
        function(idx,param)
         {if(param)
           {var _aK4_=param[1];
            switch(_aK4_[0])
             {case 0:
               var
                r=param[2],
                kind=_aK4_[3],
                x=_aK4_[2],
                l=_aK4_[1],
                _aK5_=set_idx(idx,r);
               return [0,[0,set_idx(idx,l),x,kind],_aK5_];
              case 1:
               var
                r$0=param[2],
                x$0=_aK4_[2],
                marks=_aK4_[1],
                _aK6_=set_idx(idx,r$0);
               return [0,[1,marks_set_idx(marks,idx),x$0],_aK6_];
              default:
               var r$1=param[2],marks$0=_aK4_[1],_aK7_=set_idx(idx,r$1);
               return [0,[2,marks_set_idx(marks$0,idx)],_aK7_]}}
          return 0},
       filter_marks=
        function(b,e,marks)
         {var _aKZ_=marks[2],_aK0_=marks[1];
          function _aK1_(param)
           {var i=param[1],_aK2_=i < b?1:0,_aK3_=_aK2_ || (e < i?1:0);
            return _aK3_}
          return [0,caml_call1(find_all(_aK1_),_aK0_),_aKZ_]},
       delta_1$0=
        function(counter,init,c,next_cat,prev_cat,x,rem)
         {var _aKP_=x[2];
          if(typeof _aKP_ === "number")
           return [0,[2,init],rem];
          else
           switch(_aKP_[0])
            {case 0:
              var s=_aKP_[1];
              return mem$2(c,s)?[0,texp(init,eps_expr),rem]:rem;
             case 1:
              var l=_aKP_[1];
              if(counter < 50)
               {var counter$1=counter + 1 | 0;
                return delta_2$0(counter$1,init,c,next_cat,prev_cat,l,rem)}
              return caml_trampoline_return
                      (delta_2$0,[0,init,c,next_cat,prev_cat,l,rem]);
             case 2:
              var
               z=_aKP_[3],
               y=_aKP_[2],
               kind=_aKP_[1],
               _aKQ_=0,
               y$0=delta_1(init,c,next_cat,prev_cat,y,_aKQ_);
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return delta_seq$0
                        (counter$0,c,next_cat,prev_cat,kind,y$0,z,rem)}
              return caml_trampoline_return
                      (delta_seq$0,[0,c,next_cat,prev_cat,kind,y$0,z,rem]);
             case 3:
              var
               y$1=_aKP_[3],
               kind$0=_aKP_[2],
               rep_kind=_aKP_[1],
               _aKR_=0,
               y$2=delta_1(init,c,next_cat,prev_cat,y$1,_aKR_),
               _aKS_=
                function(param)
                 {if(2 === param[0]){var marks=param[1];return [0,marks]}
                  return 0},
               match=first(_aKS_,y$2);
              if(match)
               var
                marks=match[1],
                _aKT_=caml_call1(remove_matches,y$2),
                marks$0=marks,
                y$3=_aKT_;
              else
               var marks$0=init,y$3=y$2;
              return 620821490 <= rep_kind
                      ?[0,[2,init],tseq(kind$0,y$3,x,rem)]
                      :tseq(kind$0,y$3,x,[0,[2,marks$0],rem]);
             case 4:
              var
               i=_aKP_[1],
               _aKU_=init[2],
               _aKV_=init[1],
               marks$1=[0,[0,[0,i,-1],remove_assq(i,_aKV_)],_aKU_];
              return [0,[2,marks$1],rem];
             case 5:
              var e=_aKP_[2],b=_aKP_[1];
              return [0,[2,filter_marks(b,e,init)],rem];
             case 6:
              var cat=_aKP_[1];
              return intersect(next_cat,cat)?[0,[2,init],rem]:rem;
             case 7:
              var cat$0=_aKP_[1];
              return intersect(prev_cat,cat$0)?[0,[2,init],rem]:rem;
             default:
              var
               i$0=_aKP_[1],
               _aKW_=init[2],
               _aKX_=Set[4],
               _aKY_=caml_call2(_aKX_,i$0,_aKW_),
               marks$2=[0,init[1],_aKY_];
              return [0,[2,marks$2],rem]}},
       delta_2$0=
        function(counter,marks,c,next_cat,prev_cat,l,rem)
         {if(l)
           {var r=l[2],y=l[1],_aKO_=delta_2(marks,c,next_cat,prev_cat,r,rem);
            if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return delta_1$0(counter$0,marks,c,next_cat,prev_cat,y,_aKO_)}
            return caml_trampoline_return
                    (delta_1$0,[0,marks,c,next_cat,prev_cat,y,_aKO_])}
          return rem},
       delta_seq$0=
        function(counter,c,next_cat,prev_cat,kind,y,z,rem)
         {function _aKJ_(param)
           {if(2 === param[0]){var marks=param[1];return [0,marks]}return 0}
          var match=first(_aKJ_,y);
          if(match)
           {var marks=match[1];
            if(-730718166 === kind)
             {var _aKK_=delta_1(marks,c,next_cat,prev_cat,z,rem);
              return tseq(kind,caml_call1(remove_matches,y),z,_aKK_)}
            if(332064784 <= kind)
             {var
               match$0=split_at_match(y),
               y$0=match$0[2],
               y$1=match$0[1],
               _aKL_=tseq(kind,y$0,z,rem);
              return tseq
                      (kind,y$1,z,delta_1(marks,c,next_cat,prev_cat,z,_aKL_))}
            var
             _aKM_=caml_call1(remove_matches,y),
             _aKN_=tseq(kind,_aKM_,z,rem);
            if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return delta_1$0(counter$0,marks,c,next_cat,prev_cat,z,_aKN_)}
            return caml_trampoline_return
                    (delta_1$0,[0,marks,c,next_cat,prev_cat,z,_aKN_])}
          return tseq(kind,y,z,rem)},
       delta_1=
        function(init,c,next_cat,prev_cat,x,rem)
         {return caml_trampoline(delta_1$0(0,init,c,next_cat,prev_cat,x,rem))},
       delta_2=
        function(marks,c,next_cat,prev_cat,l,rem)
         {return caml_trampoline(delta_2$0(0,marks,c,next_cat,prev_cat,l,rem))},
       delta_seq=
        function(c,next_cat,prev_cat,kind,y,z,rem)
         {return caml_trampoline
                  (delta_seq$0(0,c,next_cat,prev_cat,kind,y,z,rem))},
       delta_4=
        function(c,next_cat,prev_cat,l,rem)
         {if(l)
           {var r=l[2],y=l[1];
            return delta_3
                    (c,next_cat,prev_cat,y,delta_4(c,next_cat,prev_cat,r,rem))}
          return rem},
       delta_3=
        function(c,next_cat,prev_cat,x,rem)
         {switch(x[0])
           {case 0:
             var
              kind=x[3],
              z=x[2],
              y=x[1],
              _aKI_=0,
              y$0=delta_4(c,next_cat,prev_cat,y,_aKI_);
             return delta_seq(c,next_cat,prev_cat,kind,y$0,z,rem);
            case 1:
             var e=x[2],marks=x[1];
             return delta_1(marks,c,next_cat,prev_cat,e,rem);
            default:return [0,x,rem]}},
       delta=
        function(tbl_ref,next_cat,char$0,st)
         {var
           prev_cat=st[2],
           _aKE_=0,
           _aKF_=st[3],
           _aKG_=delta_4(char$0,next_cat,prev_cat,_aKF_,_aKE_),
           _aKH_=0,
           match=remove_duplicates(_aKH_,_aKG_,eps_expr),
           expr=match[1],
           idx=free_index(tbl_ref,expr),
           expr$0=set_idx(idx,expr);
          return mk$0(idx,next_cat,expr$0)},
       flatten_match=
        function(m)
         {var _aKA_=-1;
          function _aKB_(ma,param){var i=param[1];return max(ma,i)}
          var
           ma=fold(_aKB_,_aKA_,m),
           _aKC_=ma + 1 | 0,
           res=caml_make_vect(_aKC_,-1);
          function _aKD_(param)
           {var v=param[2],i=param[1];
            caml_check_bound(res,i)[1 + i] = v;
            return 0}
          iter$0(_aKD_,m);
          return res},
       status=
        function(s)
         {var _aKu_=s[4];
          if(_aKu_){var st=_aKu_[1];return st}
          var _aKv_=s[3];
          if(_aKv_)
           {var _aKw_=_aKv_[1];
            if(2 === _aKw_[0])
             var
              m=_aKw_[1],
              _aKx_=m[2],
              _aKy_=m[1],
              _aKz_=[0,flatten_match(_aKy_),_aKx_],
              st$0=_aKz_;
            else
             var st$0=1}
          else
           var st$0=0;
          s[4] = [0,st$0];
          return st$0},
       make$5=function(param){return make$0(257,0)},
       flatten$1=
        function(cm)
         {var
           c=caml_create_bytes(256),
           color_repr=caml_create_bytes(256),
           v=[0,0];
          caml_bytes_set(c,0,0);
          caml_bytes_set(color_repr,0,0);
          var i=1;
          for(;;)
           {if(0 !== caml_bytes_get(cm,i))v[1]++;
            var _aKp_=v[1],_aKq_=chr(_aKp_);
            caml_bytes_set(c,i,_aKq_);
            var _aKr_=chr(i),_aKs_=v[1];
            caml_bytes_set(color_repr,_aKs_,_aKr_);
            var _aKt_=i + 1 | 0;
            if(255 !== i){var i=_aKt_;continue}
            var _aKm_=v[1] + 1 | 0,_aKn_=v[1] + 1 | 0,_aKo_=0;
            return [0,c,sub(color_repr,_aKo_,_aKn_),_aKm_]}},
       split$1=
        function(s,cm)
         {return iter$8
                  (s,
                   function(i,j)
                    {caml_bytes_set(cm,i,1);
                     var _aKl_=j + 1 | 0;
                     return caml_bytes_set(cm,_aKl_,1)})},
       get_ofs=
        function(t,i)
         {if(t[2].length - 1 <= ((2 * i | 0) + 1 | 0))throw Not_found;
          var
           _aKe_=2 * i | 0,
           _aKf_=t[2],
           m1=caml_check_bound(_aKf_,_aKe_)[1 + _aKe_];
          if(-1 === m1)throw Not_found;
          var
           _aKg_=t[4],
           p1=caml_check_bound(_aKg_,m1)[1 + m1] - 1 | 0,
           _aKh_=(2 * i | 0) + 1 | 0,
           _aKi_=t[2],
           _aKj_=caml_check_bound(_aKi_,_aKh_)[1 + _aKh_],
           _aKk_=t[4],
           p2=caml_check_bound(_aKk_,_aKj_)[1 + _aKj_] - 1 | 0;
          return [0,p1,p2]},
       get$4=
        function(t,i)
         {var match=get_ofs(t,i),p2=match[2],p1=match[1];
          return sub$0(t[1],p1,p2 - p1 | 0)},
       iter$9=
        function(n,f,v)
         {var n$0=n,v$0=v;
          for(;;)
           {if(0 === n$0)return v$0;
            var v$1=caml_call1(f,v$0),n$1=n$0 - 1 | 0,n$0=n$1,v$0=v$1;
            continue}},
       unknown$0=-2,
       break$0=-3,
       category=
        function(re,color)
         {if(-1 === color)return inexistant;
          if(color === re[6])
           return symbol$1(symbol$1(lastnewline,newline),not_letter);
          var _aKd_=re[4];
          return from_char(caml_bytes_get(_aKd_,color))},
       dummy_next=[0],
       unknown_state=[0,unknown$0,0,dummy_next,0,dummy$2],
       mk_state=
        function(ncol,desc)
         {var match=status(desc),switch$0=0;
          if(typeof match === "number" && match)
           {var break_state=0;switch$0 = 1}
          if(! switch$0)var break_state=1;
          var
           _aJ$_=0,
           _aKa_=break_state?dummy_next:caml_make_vect(ncol,unknown_state),
           _aKb_=desc[1],
           _aKc_=break_state?break$0:desc[1];
          return [0,_aKc_,_aKb_,_aKa_,_aJ$_,desc]},
       find_state=
        function(re,desc)
         {try
           {var _aJ7_=re[8],_aJ8_=Table[7],_aJ9_=caml_call2(_aJ8_,_aJ7_,desc);
            return _aJ9_}
          catch(_aJ__)
           {_aJ__ = caml_wrap_exception(_aJ__);
            if(_aJ__ === Not_found)
             {var
               _aJ4_=re[5],
               st=mk_state(_aJ4_,desc),
               _aJ5_=re[8],
               _aJ6_=Table[5];
              caml_call3(_aJ6_,_aJ5_,desc,st);
              return st}
            throw _aJ__}},
       delta$0=
        function(info,cat,color,st)
         {var
           _aJW_=st[5],
           _aJX_=info[1][7],
           desc=delta(_aJX_,cat,color,_aJW_),
           len=info[3].length - 1,
           _aJY_=desc[1] === len?1:0,
           _aJZ_=_aJY_?0 < len?1:0:_aJY_;
          if(_aJZ_)
           {var pos=info[3],_aJ0_=2 * len | 0;
            info[3] = caml_make_vect(_aJ0_,0);
            var _aJ1_=0,_aJ2_=info[3],_aJ3_=0;
            blit$1(pos,_aJ3_,_aJ2_,_aJ1_,len)}
          return desc},
       validate=
        function(info,s,pos,st)
         {var
           _aJR_=caml_string_get(s,pos),
           _aJS_=info[2],
           color=caml_bytes_get(_aJS_,_aJR_),
           _aJT_=info[1],
           cat=category(_aJT_,color),
           desc=delta$0(info,cat,color,st),
           _aJU_=info[1],
           st$0=find_state(_aJU_,desc),
           _aJV_=st[3];
          caml_check_bound(_aJV_,color)[1 + color] = st$0;
          return 0},
       loop$0=
        function(counter,info,s,pos,st)
         {if(pos < info[5])
           {var
             _aJN_=caml_string_get(s,pos),
             _aJO_=info[2],
             _aJP_=caml_bytes_get(_aJO_,_aJN_),
             _aJQ_=st[3],
             st$0=caml_check_bound(_aJQ_,_aJP_)[1 + _aJP_];
            if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return loop2(counter$0,info,s,pos,st,st$0)}
            return caml_trampoline_return(loop2,[0,info,s,pos,st,st$0])}
          return st},
       loop2=
        function(counter,info,s,pos,st$0,st)
         {var pos$0=pos,st$2=st$0,st$1=st;
          for(;;)
           {if(0 <= st$1[1])
             {var pos$1=pos$0 + 1 | 0;
              if(pos$1 < info[5])
               {var
                 _aJC_=caml_string_get(s,pos$1),
                 _aJD_=info[2],
                 _aJE_=caml_bytes_get(_aJD_,_aJC_),
                 _aJF_=st$1[3],
                 st$3=caml_check_bound(_aJF_,_aJE_)[1 + _aJE_],
                 _aJG_=st$1[1],
                 _aJH_=info[3];
                caml_check_bound(_aJH_,_aJG_)[1 + _aJG_] = pos$1;
                var pos$0=pos$1,st$2=st$1,st$1=st$3;
                continue}
              var _aJI_=st$1[1],_aJJ_=info[3];
              caml_check_bound(_aJJ_,_aJI_)[1 + _aJI_] = pos$1;
              return st$1}
            if(st$1[1] === -3)
             {var _aJL_=st$1[2],_aJK_=pos$0 + 1 | 0,_aJM_=info[3];
              caml_check_bound(_aJM_,_aJL_)[1 + _aJL_] = _aJK_;
              return st$1}
            validate(info,s,pos$0,st$2);
            if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return loop$0(counter$0,info,s,pos$0,st$2)}
            return caml_trampoline_return(loop$0,[0,info,s,pos$0,st$2])}},
       loop=
        function(info,s,pos,st)
         {return caml_trampoline(loop$0(0,info,s,pos,st))},
       loop_no_mark=
        function(info,s,pos,last,st)
         {var pos$0=pos,st$0=st;
          for(;;)
           {if(pos$0 < last)
             {var
               _aJy_=caml_string_get(s,pos$0),
               _aJz_=info[2],
               _aJA_=caml_bytes_get(_aJz_,_aJy_),
               _aJB_=st$0[3],
               st$1=caml_check_bound(_aJB_,_aJA_)[1 + _aJA_];
              if(0 <= st$1[1])
               {var pos$1=pos$0 + 1 | 0,pos$0=pos$1,st$0=st$1;continue}
              if(st$1[1] === -3)return st$1;
              validate(info,s,pos$0,st$0);
              continue}
            return st$0}},
       final$0=
        function(info,st,cat)
         {try
           {var _aJv_=st[4],_aJw_=assq(cat,_aJv_);return _aJw_}
          catch(_aJx_)
           {_aJx_ = caml_wrap_exception(_aJx_);
            if(_aJx_ === Not_found)
             {var
               _aJt_=-1,
               st$0=delta$0(info,cat,_aJt_,st),
               _aJu_=status(st$0),
               res=[0,st$0[1],_aJu_];
              st[4] = [0,[0,cat,res],st[4]];
              return res}
            throw _aJx_}},
       find_initial_state=
        function(re,cat)
         {try
           {var _aJq_=re[2],_aJr_=assq(cat,_aJq_);return _aJr_}
          catch(_aJs_)
           {_aJs_ = caml_wrap_exception(_aJs_);
            if(_aJs_ === Not_found)
             {var
               _aJo_=re[1],
               _aJp_=create$9(cat,_aJo_),
               st=find_state(re,_aJp_);
              re[2] = [0,[0,cat,st],re[2]];
              return st}
            throw _aJs_}},
       get_color=
        function(re,s,pos)
         {if(0 <= pos)
           {var slen=caml_ml_string_length(s);
            if(slen <= pos)return -1;
            if
             (pos
              ===
              (slen - 1 | 0)
              &&
              -1
              !==
              re[6]
              &&
              10
              ===
              caml_string_get(s,pos))
             return re[6];
            var _aJm_=caml_string_get(s,pos),_aJn_=re[3];
            return caml_bytes_get(_aJn_,_aJm_)}
          return -1},
       handle_last_newline=
        function(info,pos,st,groups)
         {for(;;)
           {var
             _aJa_=info[1][6],
             _aJb_=st[3],
             st$0=caml_check_bound(_aJb_,_aJa_)[1 + _aJa_];
            if(0 <= st$0[1])
             {if(groups)
               {var _aJd_=st$0[1],_aJc_=pos + 1 | 0,_aJe_=info[3];
                caml_check_bound(_aJe_,_aJd_)[1 + _aJd_] = _aJc_}
              return st$0}
            if(st$0[1] === -3)
             {if(groups)
               {var _aJg_=st$0[2],_aJf_=pos + 1 | 0,_aJh_=info[3];
                caml_check_bound(_aJh_,_aJg_)[1 + _aJg_] = _aJf_}
              return st$0}
            var
             color=info[1][6],
             _aJi_=info[2],
             real_c=caml_bytes_get(_aJi_,10),
             _aJj_=info[1],
             cat=category(_aJj_,color),
             desc=delta$0(info,cat,real_c,st),
             _aJk_=info[1],
             st$1=find_state(_aJk_,desc),
             _aJl_=st[3];
            caml_check_bound(_aJl_,color)[1 + color] = st$1;
            continue}},
       scan_str=
        function(info,s,initial_state,groups)
         {var pos=info[4],last=info[5];
          if
           (last
            ===
            caml_ml_string_length(s)
            &&
            -1
            !==
            info[1][6]
            &&
            pos
            <
            last)
           {var _aI$_=last - 1 | 0;
            if(10 === caml_string_get(s,_aI$_))
             {var
               info$0=[0,info[1],info[2],info[3],info[4],last - 1 | 0],
               st=scan_str(info$0,s,initial_state,groups);
              return st[1] === -3
                      ?st
                      :handle_last_newline(info$0,last - 1 | 0,st,groups)}}
          return groups
                  ?loop(info,s,pos,initial_state)
                  :loop_no_mark(info,s,pos,last,initial_state)},
       match_str=
        function(groups,partial,re,s,pos,len)
         {var
           slen=caml_ml_string_length(s),
           last=-1 === len?slen:pos + len | 0;
          if(groups)
           var
            _aI0_=re[7],
            n=index_count(_aI0_) + 1 | 0,
            _aI1_=10 < n?caml_make_vect(n,0):_jv_.slice(),
            _aI2_=_aI1_;
          else
           var _aI2_=[0];
          var info=[0,re,re[3],_aI2_,pos,last];
          if(0 === pos)
           var initial_cat=symbol$1(search_boundary,inexistant);
          else
           var
            _aI8_=pos - 1 | 0,
            _aI9_=get_color(re,s,_aI8_),
            _aI__=category(re,_aI9_),
            initial_cat=symbol$1(search_boundary,_aI__);
          var
           initial_state=find_initial_state(re,initial_cat),
           st=scan_str(info,s,initial_state,groups),
           switch$0=0;
          if(st[1] !== -3 && ! partial)
           {if(last === slen)
             var final_cat=symbol$1(search_boundary,inexistant);
            else
             var
              _aI6_=get_color(re,s,last),
              _aI7_=category(re,_aI6_),
              final_cat=symbol$1(search_boundary,_aI7_);
            var match=final$0(info,st,final_cat),res$0=match[2],idx=match[1];
            if(groups)
             {var _aI4_=last + 1 | 0,_aI5_=info[3];
              caml_check_bound(_aI5_,idx)[1 + idx] = _aI4_}
            var res=res$0;
            switch$0 = 1}
          if(! switch$0)var _aI3_=st[5],res=status(_aI3_);
          if(typeof res === "number")return res?1:0;
          var pmarks=res[2],marks=res[1];
          return [0,[0,s,marks,pmarks,info[3],re[9]]]},
       mk_re=
        function(initial,colors,color_repr,ncolor,lnl,group_count)
         {var _aIW_=97,_aIX_=Table[1],_aIY_=caml_call1(_aIX_,_aIW_),_aIZ_=0;
          return [0,
                  initial,
                  0,
                  colors,
                  color_repr,
                  ncolor,
                  lnl,
                  create_working_area(_aIZ_),
                  _aIY_,
                  group_count]},
       cseq=function(c$0,c){return seq$0(c$0,c)},
       cadd=function(c,s){return add$7(c,s)},
       trans_set=
        function(cache,cm,s)
         {var match=one_char(s);
          if(match){var i=match[1];return csingle(caml_bytes_get(cm,i))}
          var v=[0,hash_rec(s),s];
          try
           {var
             _aIQ_=cache[1],
             _aIR_=CSetMap[28],
             _aIS_=caml_call2(_aIR_,v,_aIQ_);
            return _aIS_}
          catch(_aIT_)
           {_aIT_ = caml_wrap_exception(_aIT_);
            if(_aIT_ === Not_found)
             {var
               _aIN_=
                function(param,l)
                 {var
                   j=param[2],
                   i=param[1],
                   _aIU_=caml_bytes_get(cm,j),
                   _aIV_=caml_bytes_get(cm,i);
                  return union$0(cseq(_aIV_,_aIU_),l)},
               l=fold_right$2(s,empty$2,_aIN_),
               _aIO_=cache[1],
               _aIP_=CSetMap[4];
              cache[1] = caml_call3(_aIP_,v,l,_aIO_);
              return l}
            throw _aIT_}},
       is_charset=
        function(param)
         {var param$0=param;
          for(;;)
           {var switch$0=0;
            if(typeof param$0 === "number")
             switch$0 = 1;
            else
             switch(param$0[0])
              {case 0:return 1;
               case 13:
                var r=param$0[2],r$0=param$0[1],_aIM_=is_charset(r$0);
                if(_aIM_){var param$0=r;continue}
                return _aIM_;
               case 4:
               case 5:var param$1=param$0[2];break;
               case 2:
               case 11:
               case 12:var l=param$0[1];return for_all(is_charset,l);
               case 7:
               case 9:
               case 10:var param$1=param$0[1];break;
               default:switch$0 = 1}
            if(switch$0)return 0;
            var param$0=param$1;
            continue}},
       _jw_=222,
       _jx_=216,
       _jy_=cseq(_jx_,_jw_),
       _jz_=214,
       _jA_=192,
       _jB_=cseq(_jA_,_jz_),
       _jC_=union$0(_jB_,_jy_),
       _jD_=90,
       _jE_=65,
       _jF_=cseq(_jE_,_jD_),
       cupper=union$0(_jF_,_jC_),
       _jG_=32,
       clower=offset(_jG_,cupper),
       _jH_=union$0(clower,cupper),
       calpha=fold_right(cadd,_jI_,_jH_),
       _jJ_=57,
       _jK_=48,
       cdigit=cseq(_jK_,_jJ_),
       calnum=union$0(calpha,cdigit),
       _jL_=95,
       cword=cadd(_jL_,calnum),
       colorize=
        function(c,regexp)
         {var lnl=[0,0];
          function colorize(regexp)
           {var regexp$0=regexp;
            for(;;)
             {if(typeof regexp$0 === "number")
               switch(regexp$0)
                {case 7:lnl[1] = 1;return 0;
                 case 0:
                 case 1:var _aIL_=10;return split$1(csingle(_aIL_),c);
                 case 2:
                 case 3:
                 case 4:return split$1(cword,c);
                 default:return 0}
              else
               switch(regexp$0[0])
                {case 0:var s=regexp$0[1];return split$1(s,c);
                 case 1:var l=regexp$0[1];return iter$0(colorize,l);
                 case 2:var l$0=regexp$0[1];return iter$0(colorize,l$0);
                 case 3:var regexp$1=regexp$0[1],regexp$0=regexp$1;continue;
                 case 4:
                 case 5:
                 case 14:var regexp$2=regexp$0[2];break;
                 case 6:
                 case 7:
                 case 8:var regexp$2=regexp$0[1];break;
                 default:throw [0,Assert_failure,_jM_]}
              var regexp$0=regexp$2;
              continue}}
          colorize(regexp);
          return lnl[1]},
       equal$8=
        function(x1,x2)
         {var x1$0=x1,x2$0=x2;
          for(;;)
           {var switch$0=0;
            if(typeof x1$0 === "number")
             switch(x1$0)
              {case 0:
                if(typeof x2$0 === "number" && ! x2$0)switch$0 = 1;break;
               case 1:
                if(typeof x2$0 === "number" && 1 === x2$0)switch$0 = 1;break;
               case 2:
                if(typeof x2$0 === "number" && 2 === x2$0)switch$0 = 1;break;
               case 3:
                if(typeof x2$0 === "number" && 3 === x2$0)switch$0 = 1;break;
               case 4:
                if(typeof x2$0 === "number" && 4 === x2$0)switch$0 = 1;break;
               case 5:
                if(typeof x2$0 === "number" && 5 === x2$0)switch$0 = 1;break;
               case 6:
                if(typeof x2$0 === "number" && 6 === x2$0)switch$0 = 1;break;
               case 7:
                if(typeof x2$0 === "number" && 7 === x2$0)switch$0 = 1;break;
               case 8:
                if(typeof x2$0 === "number" && 8 === x2$0)switch$0 = 1;break;
               default:if(typeof x2$0 === "number" && 9 <= x2$0)switch$0 = 1}
            else
             switch(x1$0[0])
              {case 0:
                if(typeof x2$0 !== "number" && 0 === x2$0[0])
                 {var s2=x2$0[1],s1=x1$0[1];return caml_equal(s1,s2)}
                break;
               case 1:
                if(typeof x2$0 !== "number" && 1 === x2$0[0])
                 {var l2=x2$0[1],l1=x1$0[1];return eq_list(l1,l2)}
                break;
               case 2:
                if(typeof x2$0 !== "number" && 2 === x2$0[0])
                 {var l2$0=x2$0[1],l1$0=x1$0[1];return eq_list(l1$0,l2$0)}
                break;
               case 3:
                if(typeof x2$0 !== "number" && 3 === x2$0[0])
                 {var
                   j2=x2$0[3],
                   i2=x2$0[2],
                   x2$1=x2$0[1],
                   j1=x1$0[3],
                   i1=x1$0[2],
                   x1$1=x1$0[1],
                   _aIE_=i1 === i2?1:0;
                  if(_aIE_)
                   {var _aIF_=caml_equal(j1,j2);
                    if(_aIF_){var x1$0=x1$1,x2$0=x2$1;continue}
                    var _aIG_=_aIF_}
                  else
                   var _aIG_=_aIE_;
                  return _aIG_}
                break;
               case 4:
                if(typeof x2$0 !== "number" && 4 === x2$0[0])
                 {var
                   x2$2=x2$0[2],
                   sem2=x2$0[1],
                   x1$2=x1$0[2],
                   sem1=x1$0[1],
                   _aIH_=sem1 === sem2?1:0;
                  if(_aIH_){var x1$0=x1$2,x2$0=x2$2;continue}
                  return _aIH_}
                break;
               case 5:
                if(typeof x2$0 !== "number" && 5 === x2$0[0])
                 {var
                   x2$3=x2$0[2],
                   k2=x2$0[1],
                   x1$3=x1$0[2],
                   k1=x1$0[1],
                   _aII_=k1 === k2?1:0;
                  if(_aII_){var x1$0=x1$3,x2$0=x2$3;continue}
                  return _aII_}
                break;
               case 6:
                if(typeof x2$0 !== "number" && 6 === x2$0[0])return 0;break;
               case 7:
                if(typeof x2$0 !== "number" && 7 === x2$0[0])
                 {var x2$4=x2$0[1],x1$4=x1$0[1],x1$0=x1$4,x2$0=x2$4;continue}
                break;
               case 8:
                if(typeof x2$0 !== "number" && 8 === x2$0[0])
                 {var x2$5=x2$0[1],x1$5=x1$0[1],x1$0=x1$5,x2$0=x2$5;continue}
                break;
               case 9:
                if(typeof x2$0 !== "number" && 9 === x2$0[0])
                 {var x2$6=x2$0[1],x1$6=x1$0[1],x1$0=x1$6,x2$0=x2$6;continue}
                break;
               case 10:
                if(typeof x2$0 !== "number" && 10 === x2$0[0])
                 {var x2$7=x2$0[1],x1$7=x1$0[1],x1$0=x1$7,x2$0=x2$7;continue}
                break;
               case 11:
                if(typeof x2$0 !== "number" && 11 === x2$0[0])
                 {var l2$1=x2$0[1],l1$1=x1$0[1];return eq_list(l1$1,l2$1)}
                break;
               case 12:
                if(typeof x2$0 !== "number" && 12 === x2$0[0])
                 {var l2$2=x2$0[1],l1$2=x1$0[1];return eq_list(l1$2,l2$2)}
                break;
               case 13:
                if(typeof x2$0 !== "number" && 13 === x2$0[0])
                 {var
                   x2$8=x2$0[2],
                   x2$9=x2$0[1],
                   x1$8=x1$0[2],
                   x1$9=x1$0[1],
                   _aIJ_=equal$8(x1$9,x2$9);
                  if(_aIJ_){var x1$0=x1$8,x2$0=x2$8;continue}
                  return _aIJ_}
                break;
               default:
                if(typeof x2$0 !== "number" && 14 === x2$0[0])
                 {var
                   r2=x2$0[2],
                   m2=x2$0[1],
                   r1=x1$0[2],
                   m1=x1$0[1],
                   _aIK_=equal$5(m1,m2);
                  if(_aIK_){var x1$0=r1,x2$0=r2;continue}
                  return _aIK_}}
            return switch$0?1:0}},
       eq_list=
        function(l1,l2)
         {var l1$0=l1,l2$0=l2;
          for(;;)
           {if(l1$0)
             {if(l2$0)
               {var
                 r2=l2$0[2],
                 x2=l2$0[1],
                 r1=l1$0[2],
                 x1=l1$0[1],
                 _aID_=equal$8(x1,x2);
                if(_aID_){var l1$0=r1,l2$0=r2;continue}
                return _aID_}}
            else
             if(! l2$0)return 1;
            return 0}},
       sequence=function(l){if(l && ! l[2]){var x=l[1];return x}return [1,l]},
       merge_sequences=
        function(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var _aIw_=param$0[1];
              if(typeof _aIw_ !== "number")
               switch(_aIw_[0])
                {case 1:
                  var _aIx_=_aIw_[1];
                  if(_aIx_)
                   {var
                     r$0=param$0[2],
                     y=_aIx_[2],
                     x=_aIx_[1],
                     r$1=merge_sequences(r$0);
                    if(r$1)
                     {var _aIy_=r$1[1],switch$0=0;
                      if(typeof _aIy_ === "number" || ! (1 === _aIy_[0]))
                       switch$0 = 1;
                      else
                       {var _aIz_=_aIy_[1];
                        if(_aIz_)
                         {var r$2=r$1[2],y$0=_aIz_[2],x$0=_aIz_[1];
                          if(equal$8(x,x$0))
                           {var _aIA_=0,_aIB_=0,_aIC_=[0,sequence(y$0),_aIB_];
                            return [0,[1,[0,x,[0,[2,[0,sequence(y),_aIC_]],_aIA_]]],r$2]}}}}
                    return [0,[1,[0,x,y]],r$1]}
                  break;
                 case 2:
                  var
                   r$3=param$0[2],
                   l=_aIw_[1],
                   param$1=append(l,r$3),
                   param$0=param$1;
                  continue
                 }
              var r=param$0[2];
              return [0,_aIw_,merge_sequences(r)]}
            return 0}},
       enforce_kind=
        function(ids,kind,k,cr)
         {return 332064784 === kind
                  ?332064784 === k?cr:seq$1(ids,k,cr,eps(ids))
                  :cr},
       trans_seq=
        function(ids,kind,ign_group,ign_case,greedy,pos,cache,c,param)
         {if(param)
           {var _aIv_=param[1];
            if(param[2])
             {var
               rem=param[2],
               match=
                translate
                 (ids,kind,ign_group,ign_case,greedy,pos,cache,c,_aIv_),
               kind$0=match[2],
               cr=match[1],
               cr$0=
                trans_seq(ids,kind,ign_group,ign_case,greedy,pos,cache,c,rem);
              return is_eps(cr$0)?cr:is_eps(cr)?cr$0:seq$1(ids,kind$0,cr,cr$0)}
            var
             match$0=
              translate(ids,kind,ign_group,ign_case,greedy,pos,cache,c,_aIv_),
             kind$1=match$0[2],
             cr$1=match$0[1];
            return enforce_kind(ids,kind,kind$1,cr$1)}
          return eps(ids)},
       translate=
        function(ids,kind,ign_group,ign_case,greedy,pos,cache,c,param)
         {var ign_group$0=ign_group,greedy$0=greedy,param$0=param;
          for(;;)
           if(typeof param$0 === "number")
            switch(param$0)
             {case 0:
               var _aHP_=symbol$1(inexistant,newline);
               return [0,after(ids,_aHP_),kind];
              case 1:
               var _aHQ_=symbol$1(inexistant,newline);
               return [0,before(ids,_aHQ_),kind];
              case 2:
               var
                _aHR_=before(ids,letter),
                _aHS_=symbol$1(inexistant,not_letter),
                _aHT_=after(ids,_aHS_),
                _aHU_=332064784;
               return [0,seq$1(ids,_aHU_,_aHT_,_aHR_),kind];
              case 3:
               var
                _aHV_=symbol$1(inexistant,not_letter),
                _aHW_=before(ids,_aHV_),
                _aHX_=after(ids,letter),
                _aHY_=332064784;
               return [0,seq$1(ids,_aHY_,_aHX_,_aHW_),kind];
              case 4:
               var
                _aHZ_=0,
                _aH0_=symbol$1(inexistant,not_letter),
                _aH1_=before(ids,_aH0_),
                _aH2_=symbol$1(inexistant,not_letter),
                _aH3_=after(ids,_aH2_),
                _aH4_=332064784,
                _aH5_=[0,seq$1(ids,_aH4_,_aH3_,_aH1_),_aHZ_],
                _aH6_=before(ids,letter),
                _aH7_=after(ids,letter),
                _aH8_=332064784,
                _aH9_=[0,seq$1(ids,_aH8_,_aH7_,_aH6_),_aH5_];
               return [0,alt(ids,_aH9_),kind];
              case 5:return [0,after(ids,inexistant),kind];
              case 6:return [0,before(ids,inexistant),kind];
              case 7:
               var _aH__=symbol$1(inexistant,lastnewline);
               return [0,before(ids,_aH__),kind];
              case 8:return [0,after(ids,search_boundary),kind];
              default:return [0,before(ids,search_boundary),kind]}
           else
            switch(param$0[0])
             {case 0:
               var s=param$0[1],_aH$_=trans_set(cache,c,s);
               return [0,cst(ids,_aH$_),kind];
              case 1:
               var l=param$0[1];
               return [0,
                       trans_seq
                        (ids,kind,ign_group$0,ign_case,greedy$0,pos,cache,c,l),
                       kind];
              case 2:
               var l$0=param$0[1],merged_sequences=merge_sequences(l$0);
               if(merged_sequences && ! merged_sequences[2])
                {var
                  r=merged_sequences[1],
                  match=
                   translate
                    (ids,kind,ign_group$0,ign_case,greedy$0,pos,cache,c,r),
                  kind$0=match[2],
                  cr=match[1];
                 return [0,enforce_kind(ids,kind,kind$0,cr),kind]}
               var
                _aIa_=
                 function(r)
                  {var
                    match=
                     translate
                      (ids,kind,ign_group$0,ign_case,greedy$0,pos,cache,c,r),
                    kind$0=match[2],
                    cr=match[1];
                   return enforce_kind(ids,kind,kind$0,cr)},
                _aIb_=map$0(_aIa_,merged_sequences);
               return [0,alt(ids,_aIb_),kind];
              case 3:
               var
                j=param$0[3],
                i=param$0[2],
                r$0=param$0[1],
                match$0=
                 translate
                  (ids,kind,ign_group$0,ign_case,greedy$0,pos,cache,c,r$0),
                kind$1=match$0[2],
                cr$0=match$0[1];
               if(j)
                var
                 j$0=j[1],
                 f=
                  620821490 <= greedy$0
                   ?function(rem)
                     {var
                       _aIp_=0,
                       _aIq_=rename(ids,cr$0),
                       _aIr_=[0,seq$1(ids,kind$1,_aIq_,rem),_aIp_];
                      return alt(ids,[0,eps(ids),_aIr_])}
                   :function(rem)
                     {var
                       _aIs_=0,
                       _aIt_=[0,eps(ids),_aIs_],
                       _aIu_=rename(ids,cr$0);
                      return alt(ids,[0,seq$1(ids,kind$1,_aIu_,rem),_aIt_])},
                 _aIc_=eps(ids),
                 _aId_=j$0 - i | 0,
                 rem=iter$9(_aId_,f,_aIc_);
               else
                var rem=rep(ids,greedy$0,kind$1,cr$0);
               var
                _aIe_=
                 function(rem){return seq$1(ids,kind$1,rename(ids,cr$0),rem)};
               return [0,iter$9(i,_aIe_,rem),kind];
              case 4:
               var
                r$1=param$0[2],
                kind$2=param$0[1],
                match$1=
                 translate
                  (ids,kind$2,ign_group$0,ign_case,greedy$0,pos,cache,c,r$1),
                kind$3=match$1[2],
                cr$1=match$1[1];
               return [0,enforce_kind(ids,kind$2,kind$3,cr$1),kind$2];
              case 5:
               var
                param$1=param$0[2],
                greedy$1=param$0[1],
                greedy$0=greedy$1,
                param$0=param$1;
               continue;
              case 6:
               var r$2=param$0[1];
               if(ign_group$0){var param$0=r$2;continue}
               var p=pos[1];
               pos[1] = pos[1] + 2 | 0;
               var
                match$2=
                 translate
                  (ids,kind,ign_group$0,ign_case,greedy$0,pos,cache,c,r$2),
                kind$4=match$2[2],
                cr$2=match$2[1],
                _aIf_=p + 1 | 0,
                _aIg_=mark(ids,_aIf_),
                _aIh_=332064784,
                _aIi_=seq$1(ids,_aIh_,cr$2,_aIg_),
                _aIj_=mark(ids,p),
                _aIk_=332064784;
               return [0,seq$1(ids,_aIk_,_aIj_,_aIi_),kind$4];
              case 7:
               var param$2=param$0[1],ign_group$0=1,param$0=param$2;continue;
              case 8:
               var
                r$3=param$0[1],
                b=pos[1],
                match$3=
                 translate
                  (ids,kind,ign_group$0,ign_case,greedy$0,pos,cache,c,r$3),
                kind$5=match$3[2],
                cr$3=match$3[1],
                e=pos[1] - 1 | 0;
               if(e < b)return [0,cr$3,kind$5];
               var _aIl_=erase(ids,b,e),_aIm_=332064784;
               return [0,seq$1(ids,_aIm_,_aIl_,cr$3),kind$5];
              case 14:
               var
                r$4=param$0[2],
                i$0=param$0[1],
                match$4=
                 translate
                  (ids,kind,ign_group$0,ign_case,greedy$0,pos,cache,c,r$4),
                kind$6=match$4[2],
                cr$4=match$4[1],
                _aIn_=pmark(ids,i$0),
                _aIo_=332064784;
               return [0,seq$1(ids,_aIo_,_aIn_,cr$4),kind$6];
              default:throw [0,Assert_failure,_jN_]}},
       case_insens=
        function(s)
         {var
           _aHJ_=inter$0(s,clower),
           _aHK_=-32,
           _aHL_=offset(_aHK_,_aHJ_),
           _aHM_=inter$0(s,cupper),
           _aHN_=32,
           _aHO_=offset(_aHN_,_aHM_);
          return union$0(s,union$0(_aHO_,_aHL_))},
       as_set=
        function(param)
         {if(typeof param !== "number" && 0 === param[0])
           {var s=param[1];return s}
          throw [0,Assert_failure,_jO_]},
       handle_case=
        function(ign_case,r)
         {var ign_case$0=ign_case,r$0=r;
          for(;;)
           if(typeof r$0 === "number")
            return r$0;
           else
            switch(r$0[0])
             {case 0:
               var s=r$0[1],_aHs_=ign_case$0?case_insens(s):s;
               return [0,_aHs_];
              case 1:
               var
                l=r$0[1],
                _aHt_=function(_aHI_){return handle_case(ign_case$0,_aHI_)};
               return [1,map$0(_aHt_,l)];
              case 2:
               var
                l$0=r$0[1],
                _aHu_=function(_aHH_){return handle_case(ign_case$0,_aHH_)},
                l$1=map$0(_aHu_,l$0),
                _aHv_=[2,l$1];
               if(is_charset(_aHv_))
                {var _aHw_=function(s,r){return union$0(s,as_set(r))};
                 return [0,fold(_aHw_,empty$2,l$1)]}
               return [2,l$1];
              case 3:
               var j=r$0[3],i=r$0[2],r$1=r$0[1];
               return [3,handle_case(ign_case$0,r$1),i,j];
              case 4:
               var r$2=r$0[2],k=r$0[1],r$3=handle_case(ign_case$0,r$2);
               return is_charset(r$3)?r$3:[4,k,r$3];
              case 5:
               var r$4=r$0[2],k$0=r$0[1],r$5=handle_case(ign_case$0,r$4);
               return is_charset(r$5)?r$5:[5,k$0,r$5];
              case 6:var r$6=r$0[1];return [6,handle_case(ign_case$0,r$6)];
              case 7:
               var r$7=r$0[1],r$8=handle_case(ign_case$0,r$7);
               return is_charset(r$8)?r$8:[7,r$8];
              case 8:
               var r$9=r$0[1],r$10=handle_case(ign_case$0,r$9);
               return is_charset(r$10)?r$10:[8,r$10];
              case 9:var r$11=r$0[1],ign_case$0=0,r$0=r$11;continue;
              case 10:var r$12=r$0[1],ign_case$0=1,r$0=r$12;continue;
              case 11:
               var
                l$2=r$0[1],
                _aHx_=function(r){return handle_case(ign_case$0,r)},
                l$3=map$0(_aHx_,l$2),
                _aHy_=function(s,r){return inter$0(s,as_set(r))};
               return [0,fold(_aHy_,cany,l$3)];
              case 12:
               var
                l$4=r$0[1],
                _aHz_=function(r){return handle_case(ign_case$0,r)},
                l$5=map$0(_aHz_,l$4),
                _aHA_=function(s,r){return union$0(s,as_set(r))},
                _aHB_=fold(_aHA_,empty$2,l$5);
               return [0,diff$0(cany,_aHB_)];
              case 13:
               var
                r$13=r$0[2],
                r$14=r$0[1],
                _aHC_=handle_case(ign_case$0,r$13),
                _aHD_=as_set(_aHC_),
                _aHE_=diff$0(cany,_aHD_),
                _aHF_=handle_case(ign_case$0,r$14),
                _aHG_=as_set(_aHF_);
               return [0,inter$0(_aHG_,_aHE_)];
              default:
               var r$15=r$0[2],i$0=r$0[1];
               return [14,i$0,handle_case(ign_case$0,r$15)]}},
       compile_1=
        function(regexp)
         {var
           _aHj_=0,
           regexp$0=handle_case(_aHj_,regexp),
           _aHk_=0,
           c=make$5(_aHk_),
           need_lnl=colorize(c,regexp$0),
           match=flatten$1(c),
           ncolor=match[3],
           color_repr=match[2],
           colors=match[1],
           lnl=need_lnl?ncolor:-1,
           ncolor$0=need_lnl?ncolor + 1 | 0:ncolor,
           _aHl_=0,
           ids=create_ids(_aHl_),
           pos=[0,0],
           _aHm_=[0,CSetMap[1]],
           _aHn_=-904640576,
           _aHo_=0,
           _aHp_=0,
           _aHq_=332064784,
           match$0=
            translate(ids,_aHq_,_aHp_,_aHo_,_aHn_,pos,_aHm_,colors,regexp$0),
           kind=match$0[2],
           r=match$0[1],
           _aHr_=332064784,
           r$0=enforce_kind(ids,_aHr_,kind,r);
          return mk_re(r$0,colors,color_repr,ncolor$0,lnl,pos[1] / 2 | 0)},
       anchored=
        function(param)
         {var param$0=param;
          for(;;)
           {var switch$0=0;
            if(typeof param$0 === "number")
             switch(param$0){case 5:case 8:return 1}
            else
             switch(param$0[0])
              {case 1:var l=param$0[1];return exists(anchored,l);
               case 2:var l$0=param$0[1];return for_all(anchored,l$0);
               case 3:
                var i=param$0[2],r=param$0[1],_aHi_=0 < i?1:0;
                if(_aHi_){var param$0=r;continue}
                return _aHi_;
               case 4:
               case 5:
               case 14:var param$1=param$0[2];switch$0 = 1;break;
               case 0:
               case 11:
               case 12:
               case 13:break;
               default:var param$1=param$0[1];switch$0 = 1}
            if(switch$0){var param$0=param$1;continue}
            return 0}},
       str$0=
        function(s)
         {var l=[0,0],_aHe_=caml_ml_string_length(s) - 1 | 0;
          if(! (_aHe_ < 0))
           {var i=_aHe_;
            for(;;)
             {var _aHf_=l[1],_aHg_=caml_string_get(s,i);
              l[1] = [0,[0,csingle(_aHg_)],_aHf_];
              var _aHh_=i - 1 | 0;
              if(0 !== i){var i=_aHh_;continue}
              break}}
          return [1,l[1]]},
       char$0=function(c){return [0,csingle(c)]},
       alt$0=function(l){if(l && ! l[2]){var r=l[1];return r}return [2,l]},
       seq$2=function(l){if(l && ! l[2]){var r=l[1];return r}return [1,l]},
       repn=
        function(r,i,j)
         {if(i < 0)invalid_arg(_jP_);
          var switch$0=0;
          if(j){var j$0=j[1];if(j$0 < i){invalid_arg(_jQ_);switch$0 = 1}}
          return [3,r,i,j]},
       rep$0=function(r){return repn(r,0,0)},
       bos=5,
       shortest=function(r){return [4,-1034406550,r]},
       group=function(r){return [6,r]},
       set$0=
        function(str)
         {var s=[0,empty$2],_aG$_=caml_ml_string_length(str) - 1 | 0,_aG__=0;
          if(! (_aG$_ < 0))
           {var i=_aG__;
            for(;;)
             {var
               _aHa_=s[1],
               _aHb_=caml_string_get(str,i),
               _aHc_=csingle(_aHb_);
              s[1] = union$0(_aHc_,_aHa_);
              var _aHd_=i + 1 | 0;
              if(_aG$_ !== i){var i=_aHd_;continue}
              break}}
          return [0,s[1]]},
       rg=function(c$0,c){return [0,cseq(c$0,c)]},
       any$0=[0,cany],
       _jR_=10,
       _jS_=csingle(_jR_);
      diff$0(cany,_jS_);
      var _jT_=255,_jU_=248;
      rg(_jU_,_jT_);
      var _jV_=246,_jW_=223;
      rg(_jW_,_jV_);
      var _jX_=181;
      char$0(_jX_);
      var _jY_=122,_jZ_=97;
      rg(_jZ_,_jY_);
      var _j0_=222,_j1_=216;
      rg(_j1_,_j0_);
      var _j2_=214,_j3_=192;
      rg(_j3_,_j2_);
      var _j4_=90,_j5_=65;
      rg(_j5_,_j4_);
      var _j6_=186;
      char$0(_j6_);
      var _j7_=170;
      char$0(_j7_);
      var _j8_=57,_j9_=48;
      rg(_j9_,_j8_);
      var _j__=95;
      char$0(_j__);
      var _j$_=127,_ka_=0;
      rg(_ka_,_j$_);
      set$0(_kb_);
      var _kc_=159,_kd_=127;
      rg(_kd_,_kc_);
      var _ke_=31,_kf_=0;
      rg(_kf_,_ke_);
      var _kg_=255,_kh_=160;
      rg(_kh_,_kg_);
      var _ki_=126,_kj_=33;
      rg(_kj_,_ki_);
      var _kk_=255,_kl_=160;
      rg(_kl_,_kk_);
      var _km_=126,_kn_=32;
      rg(_kn_,_km_);
      var _ko_=247;
      char$0(_ko_);
      var _kp_=215;
      char$0(_kp_);
      var _kq_=191,_kr_=187;
      rg(_kr_,_kq_);
      var _ks_=185,_kt_=182;
      rg(_kt_,_ks_);
      var _ku_=180,_kv_=171;
      rg(_kv_,_ku_);
      var _kw_=169,_kx_=160;
      rg(_kx_,_kw_);
      var _ky_=126,_kz_=123;
      rg(_kz_,_ky_);
      var _kA_=96,_kB_=91;
      rg(_kB_,_kA_);
      var _kC_=64,_kD_=58;
      rg(_kD_,_kC_);
      var _kE_=47,_kF_=33;
      rg(_kF_,_kE_);
      var _kG_=13,_kH_=9;
      rg(_kH_,_kG_);
      var _kI_=32;
      char$0(_kI_);
      var _kJ_=70,_kK_=65;
      rg(_kK_,_kJ_);
      var _kL_=102,_kM_=97;
      rg(_kM_,_kL_);
      var
       compile=
        function(r)
         {if(anchored(r))
           var _aG5_=group(r);
          else
           var
            _aG6_=0,
            _aG7_=[0,group(r),_aG6_],
            _aG8_=rep$0(any$0),
            _aG9_=[0,shortest(_aG8_),_aG7_],
            _aG5_=seq$2(_aG9_);
          return compile_1(_aG5_)},
       replace=
        function(opt,len,_aGU_,re,f,s)
         {if(opt)var sth=opt[1],pos=sth;else var pos=0;
          if(_aGU_)var sth$0=_aGU_[1],all=sth$0;else var all=1;
          if(pos < 0)invalid_arg(_kN_);
          if(len)
           {var
             l=len[1],
             _aGV_=l < 0?1:0,
             _aGW_=_aGV_ || (caml_ml_string_length(s) < (pos + l | 0)?1:0);
            if(_aGW_)invalid_arg(_kO_);
            var limit=pos + l | 0}
          else
           var limit=caml_ml_string_length(s);
          var _aGX_=caml_ml_string_length(s),buf=create$1(_aGX_);
          function iter(pos)
           {var pos$0=pos;
            for(;;)
             {var _aGY_=pos$0 < limit?1:0;
              if(_aGY_)
               {var
                 _aGZ_=limit - pos$0 | 0,
                 _aG0_=0,
                 _aG1_=1,
                 match=match_str(_aG1_,_aG0_,re,s,pos$0,_aGZ_);
                if(typeof match === "number")
                 return match?0:add_substring(buf,s,pos$0,limit - pos$0 | 0);
                var
                 substr=match[1],
                 _aG2_=0,
                 match$0=get_ofs(substr,_aG2_),
                 p2=match$0[2],
                 p1=match$0[1],
                 _aG3_=p1 - pos$0 | 0;
                add_substring(buf,s,pos$0,_aG3_);
                var replacing=caml_call1(f,substr);
                add_string(buf,replacing);
                if(all)
                 {if(p1 === p2)
                   {if(p2 < limit)
                     {var _aG4_=caml_string_get(s,p2);add_char(buf,_aG4_)}
                    var pos$1=p2 + 1 | 0}
                  else
                   var pos$1=p2;
                  var pos$0=pos$1;
                  continue}
                return add_substring(buf,s,p2,limit - p2 | 0)}
              return _aGY_}}
          iter(pos);
          return contents(buf)},
       replace_string=
        function(pos,len,all,re,by,s)
         {return replace(pos,len,all,re,function(param){return by},s)},
       fmap=function(f){return f},
       nil=function(param){return 0},
       singleton$3=function(x){return [0,x,0]},
       cons=function(x,xs){return [0,x,xs]},
       append$0=function(x,y){return append(x,y)},
       _kP_=
        [0,
         function(_aGT_){return _aGT_},
         fmap,
         nil,
         singleton$3,
         cons,
         append$0,
         map$0],
       is_control=
        function(c)
         {var _aGN_=c <= 8?1:0;
          if(_aGN_)
           var _aGO_=_aGN_;
          else
           {var _aGP_=11 === c?1:0;
            if(_aGP_)
             var _aGO_=_aGP_;
            else
             {var _aGQ_=12 === c?1:0;
              if(_aGQ_)
               var _aGO_=_aGQ_;
              else
               var
                _aGR_=14 <= c?1:0,
                _aGS_=_aGR_?c <= 31?1:0:_aGR_,
                _aGO_=_aGS_ || (127 === c?1:0)}}
          return _aGO_},
       add_unsafe_char=
        function(b,c)
         {if(34 === c)return add_string(b,_kQ_);
          if(60 <= c)
           {if(! (63 <= c))
             switch(c - 60 | 0)
              {case 0:return add_string(b,_kT_);
               case 1:break;
               default:return add_string(b,_kU_)}}
          else
           if(38 === c)return add_string(b,_kV_);
          if(is_control(c))
           {add_string(b,_kR_);
            var _aGM_=to_string(c);
            add_string(b,_aGM_);
            return add_string(b,_kS_)}
          return add_char(b,c)},
       encode_unsafe_char=
        function(s)
         {var _aGJ_=caml_ml_string_length(s),b=create$1(_aGJ_);
          function _aGK_(_aGL_){return add_unsafe_char(b,_aGL_)}
          iter$1(_aGK_,s);
          return contents(b)},
       _kW_=0,
       _kY_=[0,str$0(_kX_),_kW_],
       _k0_=[0,str$0(_kZ_),_kY_],
       _k1_=0,
       _k3_=[0,bos,[0,str$0(_k2_),_k1_]],
       _k4_=[0,seq$2(_k3_),_k0_],
       _k5_=0,
       _k7_=[0,bos,[0,str$0(_k6_),_k5_]],
       _k8_=[0,seq$2(_k7_),_k4_],
       _k9_=alt$0(_k8_),
       re_end_comment=compile(_k9_),
       escape_comment=
        function(s)
         {function f(g)
           {var _aGI_=0,s=get$4(g,_aGI_);
            return caml_string_notequal(s,_k__)
                    ?caml_string_notequal(s,_k$_)
                      ?caml_string_notequal(s,_la_)
                        ?caml_string_notequal(s,_lb_)?s:_lc_
                        :_ld_
                      :_le_
                    :_lf_}
          return replace(0,0,_lg_,re_end_comment,f,s)},
       pp_number=
        function(fmt,v)
         {if(v == infinity)return str(fmt,_lh_);
          if(v == neg_infinity)return str(fmt,_li_);
          if(v != v)return str(fmt,_lj_);
          var vint=v | 0;
          if(vint == v)
           {var
             div=
              function(n,i)
               {var n$0=n,i$0=i;
                for(;;)
                 {if(0 !== n$0 && 0 === (n$0 % 10 | 0))
                   {var i$1=i$0 + 1 | 0,n$1=n$0 / 10 | 0,n$0=n$1,i$0=i$1;
                    continue}
                  return 2 < i$0
                          ?caml_call3(pp$0(fmt),_lk_,n$0,i$0)
                          :pp(fmt,vint)}};
            return div(vint,0)}
          var s1=caml_call1(sprintf(_ll_),v);
          if(v == caml_float_of_string(s1))return str(fmt,s1);
          var s2=caml_call1(sprintf(_lm_),v);
          return v == caml_float_of_string(s2)
                  ?str(fmt,s2)
                  :caml_call2(pp$0(fmt),_ln_,v)},
       string_of_number=
        function(v){return caml_call2(asprintf(_lo_),pp_number,v)},
       pp_noop=function(fmt,param){return 0},
       Make_fmt=
        function(Xml,_aFH_)
         {function open_box(indent,fmt){return indent?pp_open_box(fmt,0):0}
          function close_box(indent,fmt){return indent?pp_close_box(fmt,0):0}
          function sp(indent,fmt)
           {return indent?pp_print_space(fmt,0):str(fmt,_lp_)}
          function cut(indent,fmt){return indent?pp_print_cut(fmt,0):0}
          var S=_Y_([0,compare$0]),_aFI_=_aFH_[1];
          if(_aFI_)
           var
            _aFJ_=S[1],
            _aFK_=function(s,x){return caml_call2(S[4],x,s)},
            set=fold(_aFK_,_aFJ_,_aFI_),
            is_emptytag=function(x){return caml_call2(S[3],x,set)};
          else
           var is_emptytag=function(param){return 0};
          function pp_encode(encode,indent,fmt,s)
           {var s$0=caml_call1(encode,s);
            return indent
                    ?caml_call3(pp$0(fmt),_lq_,pp_print_text,s$0)
                    :str(fmt,s$0)}
          function pp_sep(indent,param)
           {return param
                    ?function(fmt,param)
                      {function _aGG_(_aGH_){return sp(indent,_aGH_)}
                       return caml_call2(pp$0(fmt),_lr_,_aGG_)}
                    :function(fmt,param){return sp(indent,fmt)}}
          function pp_attrib_value(encode,indent,fmt,a)
           {var _aGx_=Xml[26],match=caml_call1(_aGx_,a);
            switch(match[0])
             {case 0:
               var f=match[1];return caml_call3(pp$0(fmt),_ls_,pp_number,f);
              case 1:var i=match[1];return caml_call2(pp$0(fmt),_lt_,i);
              case 2:
               var s=match[1],_aGy_=caml_call1(encode,s);
               return caml_call2(pp$0(fmt),_lu_,_aGy_);
              default:
               var
                slist=match[2],
                sep=match[1],
                _aGz_=
                 function(_aGE_,_aGF_)
                  {return pp_encode(encode,indent,_aGE_,_aGF_)},
                _aGA_=[0,pp_sep(indent,sep)],
                _aGB_=
                 function(_aGC_,_aGD_){return list(_aGA_,_aGz_,_aGC_,_aGD_)};
               return caml_call3(pp$0(fmt),_lv_,_aGB_,slist)}}
          function pp_attrib(encode,indent,fmt,a)
           {function _aGq_(_aGv_,_aGw_)
             {return pp_attrib_value(encode,indent,_aGv_,_aGw_)}
            var _aGr_=Xml[25],_aGs_=caml_call1(_aGr_,a);
            function _aGt_(_aGu_){return sp(indent,_aGu_)}
            return caml_call5(pp$0(fmt),_lw_,_aGt_,_aGs_,_aGq_,a)}
          function pp_attribs(encode,indent)
           {function _aGk_(_aGo_,_aGp_)
             {return pp_attrib(encode,indent,_aGo_,_aGp_)}
            var _aGl_=[0,pp_noop];
            return function(_aGm_,_aGn_){return list(_aGl_,_aGk_,_aGm_,_aGn_)}}
          function pp_tag_and_attribs(encode,indent,fmt,param)
           {var attrs=param[2],tag=param[1];
            open_box(indent,fmt);
            function _aGh_(_aGj_){return cut(indent,_aGj_)}
            var _aGi_=pp_attribs(encode,indent);
            caml_call5(pp$0(fmt),_lx_,tag,_aGi_,attrs,_aGh_);
            return close_box(indent,fmt)}
          function pp_closedtag(encode,indent,fmt,tag,attrs)
           {if(is_emptytag(tag))
             {var
               _aF9_=[0,tag,attrs],
               _aF__=
                function(_aGf_,_aGg_)
                 {return pp_tag_and_attribs(encode,indent,_aGf_,_aGg_)};
              return caml_call3(pp$0(fmt),_ly_,_aF__,_aF9_)}
            open_box(indent,fmt);
            function _aF$_(_aGe_){return cut(indent,_aGe_)}
            var _aGa_=[0,tag,attrs];
            function _aGb_(_aGc_,_aGd_)
             {return pp_tag_and_attribs(encode,indent,_aGc_,_aGd_)}
            caml_call5(pp$0(fmt),_lz_,_aGb_,_aGa_,_aF$_,tag);
            return close_box(indent,fmt)}
          function pp_elts(encode,indent)
           {function _aF3_(_aF7_,_aF8_)
             {return pp_elt(encode,indent,_aF7_,_aF8_)}
            var _aF4_=[0,function(fmt,param){return cut(indent,fmt)}];
            return function(_aF5_,_aF6_){return list(_aF4_,_aF3_,_aF5_,_aF6_)}}
          function pp_tag(encode,indent,fmt,tag,attrs,children)
           {if(children)
             {open_box(indent,fmt);
              var
               _aFQ_=function(_aF2_){return cut(indent,_aF2_)},
               _aFR_=function(_aF1_){return close_box(indent,_aF1_)},
               _aFS_=pp_elts(encode,indent),
               _aFT_=function(_aF0_){return cut(indent,_aF0_)},
               _aFU_=[0,tag,attrs],
               _aFV_=
                function(_aFY_,_aFZ_)
                 {return pp_tag_and_attribs(encode,indent,_aFY_,_aFZ_)},
               _aFW_=function(_aFX_){return open_box(indent,_aFX_)};
              caml_call10
               (pp$0(fmt),
                _lA_,
                _aFW_,
                _aFV_,
                _aFU_,
                _aFT_,
                _aFS_,
                children,
                _aFR_,
                _aFQ_,
                tag);
              return close_box(indent,fmt)}
            return pp_closedtag(encode,indent,fmt,tag,attrs)}
          function pp_elt(encode,indent,fmt,elt)
           {var _aFO_=Xml[27],match=caml_call1(_aFO_,elt);
            if(typeof match === "number")
             return 0;
            else
             switch(match[0])
              {case 0:
                var texte=match[1],_aFP_=escape_comment(texte);
                return caml_call2(pp$0(fmt),_lB_,_aFP_);
               case 1:var texte$0=match[1];return str(fmt,texte$0);
               case 2:
                var texte$1=match[1];
                return pp_encode(encode,indent,fmt,texte$1);
               case 3:var e=match[1];return caml_call2(pp$0(fmt),_lC_,e);
               case 4:
                var xh_attrs=match[2],name=match[1];
                return pp_closedtag(encode,indent,fmt,name,xh_attrs);
               default:
                var xh_taglist=match[3],xh_attrs$0=match[2],name$0=match[1];
                return pp_tag(encode,indent,fmt,name$0,xh_attrs$0,xh_taglist)}}
          function pp(opt,_aFL_,param)
           {if(opt)
             var sth=opt[1],encode=sth;
            else
             var encode=encode_unsafe_char;
            if(_aFL_)var sth$0=_aFL_[1],indent=sth$0;else var indent=0;
            return function(_aFM_,_aFN_)
             {return pp_elt(encode,indent,_aFM_,_aFN_)}}
          return [0,
                  open_box,
                  close_box,
                  sp,
                  cut,
                  S,
                  is_emptytag,
                  pp_encode,
                  pp_sep,
                  pp_attrib_value,
                  pp_attrib,
                  pp_attribs,
                  pp_tag_and_attribs,
                  pp_closedtag,
                  pp_tag,
                  pp_elt,
                  pp_elts,
                  pp]},
       Make$8=
        function(Xml,I,O)
         {var symbol=O[2];
          function separator_to_string(param){return param?_lD_:_lE_}
          function attrib_value_to_string(encode,a)
           {var _aFB_=Xml[26],match=caml_call1(_aFB_,a);
            switch(match[0])
             {case 0:
               var f=match[1],_aFC_=string_of_number(f);
               return caml_call1(sprintf(_lF_),_aFC_);
              case 1:var i=match[1];return caml_call1(sprintf(_lG_),i);
              case 2:
               var s=match[1],_aFD_=caml_call1(encode,s);
               return caml_call1(sprintf(_lH_),_aFD_);
              default:
               var
                slist=match[2],
                sep=match[1],
                _aFE_=separator_to_string(sep),
                _aFF_=join(_aFE_,slist),
                _aFG_=caml_call1(encode,_aFF_);
               return caml_call1(sprintf(_lI_),_aFG_)}}
          function attrib_to_string(encode,a)
           {var
             _aFy_=attrib_value_to_string(encode,a),
             _aFz_=Xml[25],
             _aFA_=caml_call1(_aFz_,a);
            return caml_call2(sprintf(_lJ_),_aFA_,_aFy_)}
          function xh_print_attrs(encode,attrs)
           {if(attrs)
             {var
               queue=attrs[2],
               attr=attrs[1],
               _aFu_=xh_print_attrs(encode,queue),
               _aFv_=attrib_to_string(encode,attr),
               _aFw_=cat(_lK_,_aFv_),
               _aFx_=O[3];
              return caml_call2(symbol,caml_call1(_aFx_,_aFw_),_aFu_)}
            return O[1]}
          function xh_print_closedtag(encode,tag,attrs)
           {if(0 !== I[1])
             {var _aFl_=I[1];
              if(! mem(tag,_aFl_))
               {var
                 _aFm_=cat(tag,_lN_),
                 _aFn_=cat(_lO_,_aFm_),
                 _aFo_=O[3],
                 _aFp_=caml_call1(_aFo_,_aFn_),
                 _aFq_=xh_print_attrs(encode,attrs),
                 _aFr_=cat(_lP_,tag),
                 _aFs_=O[3],
                 _aFt_=caml_call1(_aFs_,_aFr_);
                return caml_call2(symbol,caml_call2(symbol,_aFt_,_aFq_),_aFp_)}}
            var
             _aFf_=O[3],
             _aFg_=caml_call1(_aFf_,_lL_),
             _aFh_=xh_print_attrs(encode,attrs),
             _aFi_=cat(_lM_,tag),
             _aFj_=O[3],
             _aFk_=caml_call1(_aFj_,_aFi_);
            return caml_call2(symbol,caml_call2(symbol,_aFk_,_aFh_),_aFg_)}
          function xh_print_taglist(encode,taglist)
           {var taglist$0=taglist;
            for(;;)
             {if(taglist$0)
               {var
                 queue=taglist$0[2],
                 elt=taglist$0[1],
                 _aE2_=Xml[27],
                 match=caml_call1(_aE2_,elt);
                if(typeof match === "number")
                 {var taglist$0=queue;continue}
                else
                 switch(match[0])
                  {case 0:
                    var
                     texte=match[1],
                     _aE3_=xh_print_taglist(encode,queue),
                     _aE4_=caml_call1(encode,texte),
                     _aE5_=cat(_aE4_,_lU_),
                     _aE6_=cat(_lV_,_aE5_),
                     _aE7_=O[3];
                    return caml_call2(symbol,caml_call1(_aE7_,_aE6_),_aE3_);
                   case 1:
                    var
                     texte$0=match[1],
                     _aE8_=xh_print_taglist(encode,queue),
                     _aE9_=O[3];
                    return caml_call2(symbol,caml_call1(_aE9_,texte$0),_aE8_);
                   case 2:
                    var
                     texte$1=match[1],
                     _aE__=xh_print_taglist(encode,queue),
                     _aE$_=caml_call1(encode,texte$1),
                     _aFa_=O[3];
                    return caml_call2(symbol,caml_call1(_aFa_,_aE$_),_aE__);
                   case 3:
                    var
                     e=match[1],
                     _aFb_=xh_print_taglist(encode,queue),
                     _aFc_=cat(e,_lW_),
                     _aFd_=cat(_lX_,_aFc_),
                     _aFe_=O[3];
                    return caml_call2(symbol,caml_call1(_aFe_,_aFd_),_aFb_);
                   case 4:
                    var xh_attrs=match[2],name=match[1];
                    return print_nodes(encode,name,xh_attrs,0,queue);
                   default:
                    var xh_taglist=match[3],xh_attrs$0=match[2],name$0=match[1];
                    return print_nodes
                            (encode,name$0,xh_attrs$0,xh_taglist,queue)}}
              return O[1]}}
          function print_nodes(encode,name,xh_attrs,xh_taglist,queue)
           {var _aE1_=xh_print_taglist(encode,queue);
            return caml_call2
                    (symbol,xh_print_tag(encode,name,xh_attrs,xh_taglist),_aE1_)}
          function xh_print_tag(encode,tag,attrs,taglist)
           {if(0 === taglist)return xh_print_closedtag(encode,tag,attrs);
            var
             _aEO_=cat(tag,_lQ_),
             _aEP_=cat(_lR_,_aEO_),
             _aEQ_=O[3],
             _aER_=caml_call1(_aEQ_,_aEP_),
             _aES_=xh_print_taglist(encode,taglist),
             _aET_=O[3],
             _aEU_=caml_call1(_aET_,_lS_),
             _aEV_=xh_print_attrs(encode,attrs),
             _aEW_=cat(_lT_,tag),
             _aEX_=O[3],
             _aEY_=caml_call1(_aEX_,_aEW_),
             _aEZ_=caml_call2(symbol,_aEY_,_aEV_),
             _aE0_=caml_call2(symbol,_aEZ_,_aEU_);
            return caml_call2(symbol,caml_call2(symbol,_aE0_,_aES_),_aER_)}
          function print_list(opt,foret)
           {if(opt)
             var sth=opt[1],encode=sth;
            else
             var encode=encode_unsafe_char;
            var _aEN_=xh_print_taglist(encode,foret);
            return caml_call1(O[4],_aEN_)}
          return [0,
                  symbol,
                  separator_to_string,
                  attrib_value_to_string,
                  attrib_to_string,
                  xh_print_attrs,
                  xh_print_closedtag,
                  xh_print_tag,
                  print_nodes,
                  xh_print_taglist,
                  print_list]},
       Simple_output=
        function(M)
         {function empty(param){return 0}
          function concat(f1,f2,param)
           {var _aEM_=0;caml_call1(f1,_aEM_);return caml_call1(f2,0)}
          function put(s,param){return caml_call1(M[1],s)}
          function make(f){return caml_call1(f,0)}
          return [0,empty,concat,put,make]},
       Make_simple=
        function(Xml,I)
         {function print_list(output)
           {var _aEH_=Simple_output([0,output]);
            function _aEI_(_aEK_,_aEL_){return Make$8(Xml,_aEK_,_aEL_)}
            return function(_aEJ_){return _aEI_(I,_aEJ_)}(_aEH_)[10]}
          return [0,print_list]},
       _lY_=function(_aEG_,_aEF_){return [0,Make_fmt(_aEG_,_aEF_)[17]]},
       uri_of_string=function(s){return s},
       string_of_uri=function(s){return s},
       acontent=function(param){var a=param[2];return a},
       aname=function(param){var name=param[1];return name},
       float_attrib=function(name,value){return [0,name,[0,value]]},
       int_attrib=function(name,value){return [0,name,[1,value]]},
       string_attrib=function(name,value){return [0,name,[2,value]]},
       space_sep_attrib=function(name,values){return [0,name,[3,0,values]]},
       comma_sep_attrib=function(name,values){return [0,name,[3,1,values]]},
       event_handler_attrib=function(name,value){return [0,name,[2,value]]},
       mouse_event_handler_attrib=
        function(name,value){return [0,name,[2,value]]},
       keyboard_event_handler_attrib=
        function(name,value){return [0,name,[2,value]]},
       touch_event_handler_attrib=
        function(name,value){return [0,name,[2,value]]},
       uri_attrib=function(name,value){return [0,name,[2,value]]},
       uris_attrib=function(name,values){return [0,name,[3,0,values]]},
       content=function(elt){return elt},
       empty$5=function(param){return 0},
       comment=function(c){return [0,c]},
       pcdata=function(d){return [2,d]},
       encodedpcdata=function(d){return [1,d]},
       entity=function(e){return [3,e]},
       _l0_=str$0(_lZ_),
       re_end_cdata=compile(_l0_),
       encoded_cdata=
        function(s1,s2,s)
         {var
           _aEC_=0,
           _aED_=0,
           _aEE_=replace_string(_aED_,_aEC_,_l2_,re_end_cdata,_l1_,s);
          return encodedpcdata(caml_call3(sprintf(_l3_),s1,_aEE_,s2))},
       cdata=function(_aEB_){return encoded_cdata(_l5_,_l4_,_aEB_)},
       cdata_script=function(_aEA_){return encoded_cdata(_l7_,_l6_,_aEA_)},
       cdata_style=function(_aEz_){return encoded_cdata(_l9_,_l8_,_aEz_)},
       leaf=
        function(opt,name)
         {if(opt)var sth=opt[1],a=sth;else var a=0;return [4,name,a]},
       node=
        function(opt,name,children)
         {if(opt)var sth=opt[1],a=sth;else var a=0;return [5,name,a,children]},
       _l__=[0,0],
       _l$_=
        [0,
         _kP_,
         string_of_uri,
         uri_of_string,
         float_attrib,
         int_attrib,
         string_attrib,
         space_sep_attrib,
         comma_sep_attrib,
         event_handler_attrib,
         mouse_event_handler_attrib,
         keyboard_event_handler_attrib,
         touch_event_handler_attrib,
         uri_attrib,
         uris_attrib,
         empty$5,
         comment,
         pcdata,
         encodedpcdata,
         entity,
         leaf,
         node,
         cdata,
         cdata_script,
         cdata_style,
         aname,
         acontent,
         content];
      (function(_aEy_){return Make_simple(_l$_,_aEy_)}(_l__));
      var
       _ma_=[0,0],
       _mb_=
        [0,
         _kP_,
         string_of_uri,
         uri_of_string,
         float_attrib,
         int_attrib,
         string_attrib,
         space_sep_attrib,
         comma_sep_attrib,
         event_handler_attrib,
         mouse_event_handler_attrib,
         keyboard_event_handler_attrib,
         touch_event_handler_attrib,
         uri_attrib,
         uris_attrib,
         empty$5,
         comment,
         pcdata,
         encodedpcdata,
         entity,
         leaf,
         node,
         cdata,
         cdata_script,
         cdata_style,
         aname,
         acontent,
         content],
       pp$1=function(_aEx_){return _lY_(_mb_,_aEx_)}(_ma_)[1],
       remove$3=
        function(node)
         {var
           _aEv_=node[4],
           _aEw_=
            _aEv_
             ?(node[4] = 0,node[1][2] = node[2],node[2][1] = node[1],0)
             :_aEv_;
          return _aEw_},
       create$10=
        function(param)
         {var seq=[],_aEu_=[0,seq,seq];
          caml_update_dummy(seq,_aEu_);
          return seq},
       compare$15=function(_aEt_,_aEs_){return caml_compare(_aEt_,_aEs_)},
       Storage_map=_af_([0,compare$15]),
       to_public_promise=function(_aEr_){return _aEr_},
       to_internal_promise=function(p){return p},
       identical=
        function(p1,p2)
         {var _aEq_=to_public_promise(p2);
          return to_public_promise(p1) === _aEq_?1:0},
       underlying=
        function(p)
         {var _aEp_=p[1];
          switch(_aEp_[0])
           {case 0:return p;
            case 1:return p;
            case 2:return p;
            default:
             var p$0=_aEp_[1],p$1=underlying(p$0);
             if(1 - identical(p$1,p$0))p[1] = [3,p$1];
             return p$1}},
       set_promise_state=function(p,state){p[1] = state;return p},
       may_now_be_proxy=function(p){return p},
       current_storage=[0,Storage_map[1]],
       concat_regular_callbacks=
        function(l1,l2)
         {return typeof l1 === "number"?l2:typeof l2 === "number"?l1:[0,l1,l2]},
       concat_cancel_callbacks=
        function(l1,l2)
         {return typeof l1 === "number"?l2:typeof l2 === "number"?l1:[0,l1,l2]},
       clean_up_callback_cells=
        function(callbacks)
         {if(typeof callbacks !== "number")
           switch(callbacks[0])
            {case 0:
              var
               l2=callbacks[2],
               l1=callbacks[1],
               l1$0=clean_up_callback_cells(l1),
               l2$0=clean_up_callback_cells(l2);
              return concat_regular_callbacks(l1$0,l2$0);
             case 2:if(! callbacks[1][1])return 0;break
             }
          return callbacks},
       merge_callbacks=
        function(from,into)
         {var
           _aEk_=from[1],
           _aEl_=into[1],
           regular_callbacks=concat_regular_callbacks(_aEl_,_aEk_),
           cleanups_deferred=into[4] + from[4] | 0;
          if(42 < cleanups_deferred)
           var
            cleanups_deferred$0=0,
            _aEm_=clean_up_callback_cells(regular_callbacks),
            cleanups_deferred$1=cleanups_deferred$0,
            regular_callbacks$0=_aEm_;
          else
           var
            cleanups_deferred$1=cleanups_deferred,
            regular_callbacks$0=regular_callbacks;
          var
           _aEn_=from[2],
           _aEo_=into[2],
           cancel_callbacks=concat_cancel_callbacks(_aEo_,_aEn_);
          into[1] = regular_callbacks$0;
          into[2] = cancel_callbacks;
          into[4] = cleanups_deferred$1;
          return 0},
       add_regular_callback_list_node=
        function(callbacks,node)
         {var
           _aEj_=callbacks[1],
           node$0=typeof _aEj_ === "number"?node:[0,node,_aEj_];
          callbacks[1] = node$0;
          return 0},
       add_implicitly_removed_callbac=
        function(callbacks,f)
         {return add_regular_callback_list_node(callbacks,[1,f])},
       _mc_=
        function(exn)
         {prerr_string(_md_);
          var _aEh_=to_string$5(exn);
          prerr_string(_aEh_);
          var _aEi_=10;
          prerr_char(_aEi_);
          print_backtrace(stderr);
          flush(stderr);
          return exit(2)},
       handle_with_async_exception_ho=
        function(f,v)
         {try
           {var _aEg_=caml_call1(f,v);return _aEg_}
          catch(exn){exn = caml_wrap_exception(exn);return _mc_(exn)}},
       Canceled=[248,_me_,caml_fresh_oo_id(0)],
       run_callbacks=
        function(callbacks,result)
         {function run_cancel_callbacks(fs)
           {function iter_callback_list$0(counter,fs,rest)
             {var fs$0=fs,rest$0=rest;
              for(;;)
               if(typeof fs$0 === "number")
                {if(counter < 50)
                  {var counter$0=counter + 1 | 0;
                   return iter_list(counter$0,rest$0)}
                 return caml_trampoline_return(iter_list,[0,rest$0])}
               else
                switch(fs$0[0])
                 {case 0:
                   var
                    fs$1=fs$0[2],
                    fs$2=fs$0[1],
                    rest$1=[0,fs$1,rest$0],
                    fs$0=fs$2,
                    rest$0=rest$1;
                   continue;
                  case 1:
                   var f=fs$0[2],storage=fs$0[1];
                   current_storage[1] = storage;
                   var _aEf_=0;
                   handle_with_async_exception_ho(f,_aEf_);
                   if(counter < 50)
                    {var counter$1=counter + 1 | 0;
                     return iter_list(counter$1,rest$0)}
                   return caml_trampoline_return(iter_list,[0,rest$0]);
                  default:
                   var node=fs$0[1];
                   remove$3(node);
                   if(counter < 50)
                    {var counter$2=counter + 1 | 0;
                     return iter_list(counter$2,rest$0)}
                   return caml_trampoline_return(iter_list,[0,rest$0])}}
            function iter_list(counter,rest)
             {if(rest)
               {var rest$0=rest[2],fs=rest[1];
                if(counter < 50)
                 {var counter$0=counter + 1 | 0;
                  return iter_callback_list$0(counter$0,fs,rest$0)}
                return caml_trampoline_return
                        (iter_callback_list$0,[0,fs,rest$0])}
              return 0}
            function iter_callback_list(fs,rest)
             {return caml_trampoline(iter_callback_list$0(0,fs,rest))}
            return iter_callback_list(fs,0)}
          function run_regular_callbacks(fs)
           {function iter_callback_list$0(counter,fs,rest)
             {var fs$0=fs,rest$0=rest;
              for(;;)
               if(typeof fs$0 === "number")
                {if(counter < 50)
                  {var counter$0=counter + 1 | 0;
                   return iter_list(counter$0,rest$0)}
                 return caml_trampoline_return(iter_list,[0,rest$0])}
               else
                switch(fs$0[0])
                 {case 0:
                   var
                    fs$1=fs$0[2],
                    fs$2=fs$0[1],
                    rest$1=[0,fs$1,rest$0],
                    fs$0=fs$2,
                    rest$0=rest$1;
                   continue;
                  case 1:
                   var f=fs$0[1];
                   caml_call1(f,result);
                   if(counter < 50)
                    {var counter$1=counter + 1 | 0;
                     return iter_list(counter$1,rest$0)}
                   return caml_trampoline_return(iter_list,[0,rest$0]);
                  default:
                   var _aEe_=fs$0[1][1];
                   if(_aEe_)
                    {var f$0=_aEe_[1];
                     caml_call1(f$0,result);
                     if(counter < 50)
                      {var counter$2=counter + 1 | 0;
                       return iter_list(counter$2,rest$0)}
                     return caml_trampoline_return(iter_list,[0,rest$0])}
                   if(counter < 50)
                    {var counter$3=counter + 1 | 0;
                     return iter_list(counter$3,rest$0)}
                   return caml_trampoline_return(iter_list,[0,rest$0])}}
            function iter_list(counter,rest)
             {if(rest)
               {var rest$0=rest[2],fs=rest[1];
                if(counter < 50)
                 {var counter$0=counter + 1 | 0;
                  return iter_callback_list$0(counter$0,fs,rest$0)}
                return caml_trampoline_return
                        (iter_callback_list$0,[0,fs,rest$0])}
              return 0}
            function iter_callback_list(fs,rest)
             {return caml_trampoline(iter_callback_list$0(0,fs,rest))}
            return iter_callback_list(fs,0)}
          if(1 === result[0])
           var _aEd_=result[1] === Canceled?1:0,is_canceled=_aEd_;
          else
           var is_canceled=0;
          if(is_canceled){var _aEc_=callbacks[2];run_cancel_callbacks(_aEc_)}
          return run_regular_callbacks(callbacks[1])},
       current_callback_nesting_depth=[0,0],
       default_maximum_callback_nesti=42,
       _mf_=0,
       deferred_callbacks=create$0(_mf_),
       enter_resolution_loop=
        function(param)
         {current_callback_nesting_depth[1]
          =
          current_callback_nesting_depth[1]
          +
          1
          |
          0;
          var storage_snapshot=current_storage[1];
          return storage_snapshot},
       leave_resolution_loop=
        function(storage_snapshot)
         {if(1 === current_callback_nesting_depth[1])
           for(;;)
            {if(! is_empty$0(deferred_callbacks))
              {var
                match=take(deferred_callbacks),
                result=match[2],
                callbacks=match[1];
               run_callbacks(callbacks,result);
               continue}
             break}
          current_callback_nesting_depth[1]
          =
          current_callback_nesting_depth[1]
          -
          1
          |
          0;
          current_storage[1] = storage_snapshot;
          return 0},
       run_in_resolution_loop=
        function(f)
         {var
           _aEa_=0,
           storage_snapshot=enter_resolution_loop(_aEa_),
           _aEb_=0,
           result=caml_call1(f,_aEb_);
          leave_resolution_loop(storage_snapshot);
          return result},
       run_callbacks_or_defer_them=
        function(opt,_aD$_,callbacks,result)
         {if(opt)
           var sth=opt[1],allow_deferring=sth;
          else
           var allow_deferring=1;
          if(_aD$_)
           var sth$0=_aD$_[1],maximum_callback_nesting_depth=sth$0;
          else
           var maximum_callback_nesting_depth=default_maximum_callback_nesti;
          var
           should_defer=
            allow_deferring
             ?maximum_callback_nesting_depth
               <=
               current_callback_nesting_depth[1]
               ?1
               :0
             :allow_deferring;
          return should_defer
                  ?add([0,callbacks,result],deferred_callbacks)
                  :run_in_resolution_loop
                    (function(param){return run_callbacks(callbacks,result)})},
       resolve=
        function(allow_deferring,maximum_callback_nesting_depth,p,result)
         {var match=p[1],callbacks=match[1],p$0=set_promise_state(p,result);
          run_callbacks_or_defer_them
           (allow_deferring,maximum_callback_nesting_depth,callbacks,result);
          return p$0},
       run_callback_or_defer_it=
        function(opt,f,if_deferred)
         {if(opt)
           var sth=opt[1],run_immediately_and_ensure_tai=sth;
          else
           var run_immediately_and_ensure_tai=0;
          if(run_immediately_and_ensure_tai)return caml_call1(f,0);
          var should_defer=42 <= current_callback_nesting_depth[1]?1:0;
          if(should_defer)
           {var
             _aD9_=0,
             match=caml_call1(if_deferred,_aD9_),
             deferred_result=match[3],
             deferred_callback=match[2],
             immediate_result=match[1],
             deferred_record=[0,[1,deferred_callback],0,0,0],
             _aD__=[0,deferred_record,deferred_result];
            add(_aD__,deferred_callbacks);
            return immediate_result}
          return run_in_resolution_loop
                  (function(param){return caml_call1(f,0)})},
       return$0=function(v){return to_public_promise([0,[0,v]])},
       fail=function(exn){return to_public_promise([0,[1,exn]])},
       _mg_=0;
      return$0(_mg_);
      var _mh_=0;
      return$0(_mh_);
      var _mi_=0;
      return$0(_mi_);
      var _mj_=1;
      return$0(_mj_);
      var _mk_=0;
      return$0(_mk_);
      var
       new_pending=
        function(how_to_cancel)
         {var state=[2,[0,0,0,how_to_cancel,0]];return [0,state]},
       make_into_proxy=
        function(outer_promise,user_provided_promise)
         {var p=underlying(user_provided_promise);
          if(identical(p,outer_promise))return p;
          var _aD7_=p[1];
          switch(_aD7_[0])
           {case 1:return resolve(_mm_,0,outer_promise,p[1]);
            case 2:
             var
              p_callbacks=_aD7_[1],
              match=outer_promise[1],
              outer_callbacks=match[1];
             merge_callbacks(p_callbacks,outer_callbacks);
             outer_callbacks[3] = p_callbacks[3];
             var _aD8_=[3,outer_promise];
             set_promise_state(p,_aD8_);
             return outer_promise;
            default:return resolve(_ml_,0,outer_promise,p[1])}},
       backtrace_bind=
        function(add_loc,p,f)
         {var p$0=to_internal_promise(p),p$1=underlying(p$0);
          function create_result_promise_and_call(param)
           {var
             _aD2_=[0,p$1],
             p=new_pending(_aD2_),
             saved_storage=current_storage[1];
            function callback(p_result)
             {if(1 === p_result[0])
               {var
                 exn=p_result[1],
                 p$4=may_now_be_proxy(p),
                 p$5=underlying(p$4),
                 _aD5_=[1,caml_call1(add_loc,exn)],
                 _aD6_=0;
                resolve(_mn_,_aD6_,p$5,_aD5_);
                return 0}
              var v=p_result[1];
              current_storage[1] = saved_storage;
              try
               {var _aD4_=caml_call1(f,v),p$0=_aD4_}
              catch(exn)
               {exn = caml_wrap_exception(exn);
                var _aD3_=caml_call1(add_loc,exn),p$0=fail(_aD3_)}
              var
               p$1=to_internal_promise(p$0),
               p$2=may_now_be_proxy(p),
               p$3=underlying(p$2);
              make_into_proxy(p$3,p$1);
              return 0}
            return [0,to_public_promise(p),callback]}
          var _aDY_=p$1[1];
          switch(_aDY_[0])
           {case 1:
             var exn=_aDY_[1];
             return to_public_promise([0,[1,caml_call1(add_loc,exn)]]);
            case 2:
             var
              p_callbacks=_aDY_[1],
              _aD0_=0,
              match=create_result_promise_and_call(_aD0_),
              callback=match[2],
              p$2=match[1];
             add_implicitly_removed_callbac(p_callbacks,callback);
             return p$2;
            default:
             var
              v=_aDY_[1],
              _aDZ_=
               function(param)
                {var
                  _aD1_=0,
                  match=create_result_promise_and_call(_aD1_),
                  callback=match[2],
                  p=match[1];
                 return [0,p,callback,p$1[1]]};
             return run_callback_or_defer_it
                     (_mo_,function(param){return caml_call1(f,v)},_aDZ_)}},
       _mp_=0;
      create$10(_mp_);
      var
       OTProduct=
        function(X,Y)
         {function compare(param,_aDW_)
           {var
             y2=_aDW_[2],
             x2=_aDW_[1],
             y1=param[2],
             x1=param[1],
             _aDX_=X[1],
             cv=caml_call2(_aDX_,x1,x2);
            return 0 === cv?caml_call2(Y[1],y1,y2):cv}
          return [0,compare]},
       Dfs=
        function(G)
         {var _aB7_=G[2],H=Make$1([0,_aB7_[3],_aB7_[2]]);
          function fold(f,i,g)
           {var
             _aDN_=97,
             _aDO_=H[1],
             h=caml_call1(_aDO_,_aDN_),
             _aDP_=0,
             s=create(_aDP_);
            function push$0(v)
             {var _aDS_=H[11],_aDT_=1 - caml_call2(_aDS_,h,v);
              if(_aDT_)
               {var _aDU_=0,_aDV_=H[5];
                caml_call3(_aDV_,h,v,_aDU_);
                return push(v,s)}
              return _aDT_}
            function loop(acc)
             {var acc$0=acc;
              for(;;)
               {if(is_empty(s))return acc$0;
                var v=pop(s),acc$1=caml_call2(f,v,acc$0),_aDR_=G[5];
                caml_call3(_aDR_,push$0,g,v);
                var acc$0=acc$1;
                continue}}
            function _aDQ_(v,s){push$0(v);return loop(s)}
            return caml_call3(G[4],_aDQ_,g,i)}
          function iter(opt,_aDF_,g)
           {if(opt)
             var sth=opt[1],pre=sth;
            else
             var pre=function(param){return 0};
            if(_aDF_)
             var sth$0=_aDF_[1],post=sth$0;
            else
             var post=function(param){return 0};
            var _aDG_=97,_aDH_=H[1],h=caml_call1(_aDH_,_aDG_);
            function visit(v)
             {var _aDI_=H[11],_aDJ_=1 - caml_call2(_aDI_,h,v);
              if(_aDJ_)
               {var _aDK_=0,_aDL_=H[5];
                caml_call3(_aDL_,h,v,_aDK_);
                caml_call1(pre,v);
                var _aDM_=G[5];
                caml_call3(_aDM_,visit,g,v);
                return caml_call1(post,v)}
              return _aDJ_}
            return caml_call2(G[3],visit,g)}
          function postfix(post,g){return iter(0,[0,post],g)}
          function fold_component(f,i,g,v0)
           {var
             _aDx_=97,
             _aDy_=H[1],
             h=caml_call1(_aDy_,_aDx_),
             _aDz_=0,
             s=create(_aDz_);
            function push$0(v)
             {var _aDB_=H[11],_aDC_=1 - caml_call2(_aDB_,h,v);
              if(_aDC_)
               {var _aDD_=0,_aDE_=H[5];
                caml_call3(_aDE_,h,v,_aDD_);
                return push(v,s)}
              return _aDC_}
            push$0(v0);
            function loop(acc)
             {var acc$0=acc;
              for(;;)
               {if(is_empty(s))return acc$0;
                var v=pop(s),acc$1=caml_call2(f,v,acc$0),_aDA_=G[5];
                caml_call3(_aDA_,push$0,g,v);
                var acc$0=acc$1;
                continue}}
            return loop(i)}
          function iter_component(opt,_aDo_,g,v)
           {if(opt)
             var sth=opt[1],pre=sth;
            else
             var pre=function(param){return 0};
            if(_aDo_)
             var sth$0=_aDo_[1],post=sth$0;
            else
             var post=function(param){return 0};
            var _aDp_=97,_aDq_=H[1],h=caml_call1(_aDq_,_aDp_);
            function visit(v)
             {var _aDr_=0,_aDs_=H[5];
              caml_call3(_aDs_,h,v,_aDr_);
              caml_call1(pre,v);
              function _aDt_(w)
               {var _aDv_=H[11],_aDw_=1 - caml_call2(_aDv_,h,w);
                return _aDw_?visit(w):_aDw_}
              var _aDu_=G[5];
              caml_call3(_aDu_,_aDt_,g,v);
              return caml_call1(post,v)}
            return visit(v)}
          function postfix_component(post,g)
           {var _aDl_=[0,post],_aDm_=0;
            return function(_aDn_){return iter_component(_aDm_,_aDl_,g,_aDn_)}}
          function _aB8_(g)
           {var
             _aC4_=97,
             _aC5_=H[1],
             h=caml_call1(_aC5_,_aC4_),
             _aC6_=0,
             stack=create(_aC6_);
            function loop(param)
             {for(;;)
               {if(is_empty(stack))return 0;
                var v=top(stack),_aDb_=H[11];
                if(caml_call2(_aDb_,h,v))
                 {var _aDc_=0,_aDd_=H[10];
                  caml_call3(_aDd_,h,v,_aDc_);
                  pop(stack)}
                else
                 {var _aDe_=1,_aDf_=H[5];
                  caml_call3(_aDf_,h,v,_aDe_);
                  var
                   _aDg_=
                    function(w)
                     {try
                       {var _aDi_=H[7],_aDj_=caml_call2(_aDi_,h,w);
                        if(_aDj_)throw Exit;
                        return _aDj_}
                      catch(_aDk_)
                       {_aDk_ = caml_wrap_exception(_aDk_);
                        if(_aDk_ === Not_found)return push(w,stack);
                        throw _aDk_}},
                   _aDh_=G[5];
                  caml_call3(_aDh_,_aDg_,g,v)}
                continue}}
            try
             {var
               _aC7_=
                function(v)
                 {var _aC$_=H[11],_aDa_=1 - caml_call2(_aC$_,h,v);
                  return _aDa_?(push(v,stack),loop(0)):_aDa_},
               _aC8_=G[3];
              caml_call2(_aC8_,_aC7_,g);
              var _aC9_=0;
              return _aC9_}
            catch(_aC__)
             {_aC__ = caml_wrap_exception(_aC__);
              if(_aC__ === Exit)return 1;
              throw _aC__}}
          function has_cycle_undirected(g)
           {var
             _aCB_=97,
             _aCC_=H[1],
             h=caml_call1(_aCC_,_aCB_),
             _aCD_=97,
             _aCE_=H[1],
             father=caml_call1(_aCE_,_aCD_);
            function is_father(u,v)
             {try
               {var
                 _aCZ_=H[7],
                 _aC0_=caml_call2(_aCZ_,father,v),
                 _aC1_=G[2][3],
                 _aC2_=caml_call2(_aC1_,_aC0_,u);
                return _aC2_}
              catch(_aC3_)
               {_aC3_ = caml_wrap_exception(_aC3_);
                if(_aC3_ === Not_found)return 0;
                throw _aC3_}}
            var _aCF_=0,stack=create(_aCF_);
            function loop(param)
             {for(;;)
               {if(is_empty(stack))return 0;
                var v=top(stack),_aCM_=H[11];
                if(caml_call2(_aCM_,h,v))
                 {var _aCN_=H[6];
                  caml_call2(_aCN_,father,v);
                  var _aCO_=0,_aCP_=H[10];
                  caml_call3(_aCP_,h,v,_aCO_);
                  pop(stack)}
                else
                 {var _aCQ_=1,_aCR_=H[5];
                  caml_call3(_aCR_,h,v,_aCQ_);
                  var
                   _aCS_=
                    function(v)
                      {return function(w)
                        {try
                          {var
                            _aCV_=H[7],
                            _aCW_=caml_call2(_aCV_,h,w),
                            _aCX_=_aCW_?1 - is_father(w,v):_aCW_;
                           if(_aCX_)throw Exit;
                           return _aCX_}
                         catch(_aCY_)
                          {_aCY_ = caml_wrap_exception(_aCY_);
                           if(_aCY_ === Not_found)
                            {var _aCU_=H[5];
                             caml_call3(_aCU_,father,w,v);
                             return push(w,stack)}
                           throw _aCY_}}}
                     (v),
                   _aCT_=G[5];
                  caml_call3(_aCT_,_aCS_,g,v)}
                continue}}
            try
             {var
               _aCG_=
                function(v)
                 {var _aCK_=H[11],_aCL_=1 - caml_call2(_aCK_,h,v);
                  return _aCL_?(push(v,stack),loop(0)):_aCL_},
               _aCH_=G[3];
              caml_call2(_aCH_,_aCG_,g);
              var _aCI_=0;
              return _aCI_}
            catch(_aCJ_)
             {_aCJ_ = caml_wrap_exception(_aCJ_);
              if(_aCJ_ === Exit)return 1;
              throw _aCJ_}}
          function has_cycle(g){return G[1]?_aB8_(g):has_cycle_undirected(g)}
          function iter$0(f,g)
           {var
             _aCo_=97,
             _aCp_=H[1],
             h=caml_call1(_aCp_,_aCo_),
             _aCq_=0,
             stack=create(_aCq_);
            function loop(param)
             {for(;;)
               {if(is_empty(stack))return 0;
                var v=pop(stack),_aCu_=H[11];
                if(1 - caml_call2(_aCu_,h,v))
                 {var _aCv_=0,_aCw_=H[5];
                  caml_call3(_aCw_,h,v,_aCv_);
                  caml_call1(f,v);
                  var
                   _aCx_=
                    function(w)
                     {var _aCz_=H[11],_aCA_=1 - caml_call2(_aCz_,h,w);
                      return _aCA_?push(w,stack):_aCA_},
                   _aCy_=G[5];
                  caml_call3(_aCy_,_aCx_,g,v)}
                continue}}
            function _aCr_(v)
             {var _aCs_=H[11],_aCt_=1 - caml_call2(_aCs_,h,v);
              return _aCt_?(push(v,stack),loop(0)):_aCt_}
            return caml_call2(G[3],_aCr_,g)}
          function iter_component$0(f,g,v0)
           {var
             _aCe_=97,
             _aCf_=H[1],
             h=caml_call1(_aCf_,_aCe_),
             _aCg_=0,
             stack=create(_aCg_);
            push(v0,stack);
            for(;;)
             {if(is_empty(stack))return 0;
              var v=pop(stack),_aCh_=H[11];
              if(1 - caml_call2(_aCh_,h,v))
               {var _aCi_=0,_aCj_=H[5];
                caml_call3(_aCj_,h,v,_aCi_);
                caml_call1(f,v);
                var
                 _aCk_=
                  function(w)
                   {var _aCm_=H[11],_aCn_=1 - caml_call2(_aCm_,h,w);
                    return _aCn_?push(w,stack):_aCn_},
                 _aCl_=G[5];
                caml_call3(_aCl_,_aCk_,g,v)}
              continue}}
          var
           Tail=[0,has_cycle_undirected,has_cycle,iter$0,iter_component$0],
           prefix=Tail[3],
           has_cycle$0=Tail[2],
           prefix_component=Tail[4],
           S=_Y_([0,G[2][1]]);
          function start(g)
           {var _aCb_=0;
            function _aCc_(v,st){return [0,v,st]}
            var _aCd_=G[4],st=caml_call3(_aCd_,_aCc_,g,_aCb_);
            return [0,S[1],st,g]}
          function get(param)
           {var st=param[2];if(st){var v=st[1];return v}throw Exit}
          function step(param)
           {var g=param[3],st=param[2],s=param[1];
            if(st)
             {var
               st$0=st[2],
               v=st[1],
               _aB9_=S[4],
               s$0=caml_call2(_aB9_,v,s),
               _aB__=function(w,st){return [0,w,st]},
               _aB$_=G[6],
               st$1=caml_call4(_aB$_,_aB__,g,v,st$0),
               clean=
                function(st)
                 {var st$0=st;
                  for(;;)
                   {if(st$0)
                     {var st$1=st$0[2],w=st$0[1],_aCa_=S[3];
                      if(caml_call2(_aCa_,w,s$0)){var st$0=st$1;continue}}
                    return st$0}};
              return [0,s$0,clean(st$1),g]}
            throw Exit}
          return [0,
                  H,
                  fold,
                  iter,
                  postfix,
                  fold_component,
                  iter_component,
                  postfix_component,
                  Tail,
                  prefix,
                  has_cycle$0,
                  prefix_component,
                  S,
                  start,
                  get,
                  step]},
       _mq_=
        function(_aB5_)
         {var _aB6_=Dfs(_aB5_);
          return [0,
                  _aB6_[3],
                  _aB6_[9],
                  _aB6_[4],
                  _aB6_[6],
                  _aB6_[11],
                  _aB6_[7],
                  _aB6_[2],
                  _aB6_[5],
                  _aB6_[13],
                  _aB6_[15],
                  _aB6_[14],
                  _aB6_[10]]},
       Make_Map=
        function(X)
         {var
           include=_af_([0,X[1]]),
           empty=include[1],
           is_empty=include[2],
           mem=include[3],
           add=include[4],
           update=include[5],
           singleton=include[6],
           remove=include[7],
           merge=include[8],
           union=include[9],
           compare=include[10],
           equal=include[11],
           iter=include[12],
           fold=include[13],
           for_all=include[14],
           exists=include[15],
           filter=include[16],
           filter_map=include[17],
           partition=include[18],
           cardinal=include[19],
           bindings=include[20],
           min_binding=include[21],
           min_binding_opt=include[22],
           max_binding=include[23],
           max_binding_opt=include[24],
           choose=include[25],
           choose_opt=include[26],
           split=include[27],
           find=include[28],
           find_opt=include[29],
           find_first=include[30],
           find_first_opt=include[31],
           find_last=include[32],
           find_last_opt=include[33],
           mapi=include[35],
           to_seq=include[36],
           to_rev_seq=include[37],
           to_seq_from=include[38],
           add_seq=include[39],
           of_seq=include[40];
          function create(param,_aB4_){throw [0,Assert_failure,_mr_]}
          function create_from(param){return empty}
          function copy(m){return m}
          function map(f,m)
           {return caml_call3
                    (fold,
                     function(k,v,m)
                      {var match=caml_call2(f,k,v),v$0=match[2],k$0=match[1];
                       return caml_call3(add,k$0,v$0,m)},
                     m,
                     empty)}
          function find_and_raise(k,h,s)
           {try
             {var _aB2_=caml_call2(find,k,h);return _aB2_}
            catch(_aB3_)
             {_aB3_ = caml_wrap_exception(_aB3_);
              if(_aB3_ === Not_found)return invalid_arg(s);
              throw _aB3_}}
          function clear(param){throw [0,Assert_failure,_ms_]}
          return [0,
                  empty,
                  is_empty,
                  mem,
                  add,
                  update,
                  singleton,
                  remove,
                  merge,
                  union,
                  compare,
                  equal,
                  iter,
                  fold,
                  for_all,
                  exists,
                  filter,
                  filter_map,
                  partition,
                  cardinal,
                  bindings,
                  min_binding,
                  min_binding_opt,
                  max_binding,
                  max_binding_opt,
                  choose,
                  choose_opt,
                  split,
                  find,
                  find_opt,
                  find_first,
                  find_first_opt,
                  find_last,
                  find_last_opt,
                  mapi,
                  to_seq,
                  to_rev_seq,
                  to_seq_from,
                  add_seq,
                  of_seq,
                  create,
                  create_from,
                  copy,
                  map,
                  find_and_raise,
                  clear]},
       Minimal=
        function(S,HM)
         {var
           empty=HM[3],
           create=HM[1],
           is_empty=HM[5],
           copy=HM[14],
           clear=HM[4],
           is_directed=1;
          function nb_vertex(g)
           {var _aBY_=0;
            function _aBZ_(param,_aB0_)
             {return function(_aB1_){return _aB1_ + 1 | 0}}
            return caml_call3(HM[13],_aBZ_,g,_aBY_)}
          function nb_edges(g)
           {var _aBV_=0;
            function _aBW_(param,s,n)
             {var _aBX_=S[22];return n + caml_call1(_aBX_,s) | 0}
            return caml_call3(HM[13],_aBW_,g,_aBV_)}
          function out_degree(g,v)
           {try
             {var _aBS_=HM[9],_aBT_=caml_call2(_aBS_,v,g),_aBR_=_aBT_}
            catch(_aBU_)
             {_aBU_ = caml_wrap_exception(_aBU_);
              if(_aBU_ !== Not_found)throw _aBU_;
              var _aBQ_=invalid_arg(_mt_),_aBR_=_aBQ_}
            return caml_call1(S[22],_aBR_)}
          function mem_vertex(g,v){return caml_call2(HM[8],v,g)}
          function unsafe_add_vertex(g,v){return caml_call3(HM[6],v,S[1],g)}
          function unsafe_add_edge(g,v1,v2)
           {var
             _aBM_=HM[9],
             _aBN_=caml_call2(_aBM_,v1,g),
             _aBO_=S[4],
             _aBP_=caml_call2(_aBO_,v2,_aBN_);
            return caml_call3(HM[6],v1,_aBP_,g)}
          function add_vertex(g,v)
           {var _aBL_=HM[8];
            return caml_call2(_aBL_,v,g)?g:unsafe_add_vertex(g,v)}
          function iter_vertex(f)
           {function _aBK_(v,param){return caml_call1(f,v)}
            return caml_call1(HM[11],_aBK_)}
          function fold_vertex(f)
           {function _aBJ_(v,param){return caml_call1(f,v)}
            return caml_call1(HM[13],_aBJ_)}
          return [0,
                  is_directed,
                  empty,
                  create,
                  is_empty,
                  copy,
                  clear,
                  nb_vertex,
                  nb_edges,
                  out_degree,
                  mem_vertex,
                  unsafe_add_vertex,
                  unsafe_add_edge,
                  add_vertex,
                  iter_vertex,
                  fold_vertex]},
       Pred=
        function(S)
         {function iter_pred(f,g,v)
           {var _aBF_=S[3];
            if(1 - caml_call2(_aBF_,v,g))invalid_arg(_mu_);
            function _aBG_(v1,v2)
             {var _aBH_=S[1][3],_aBI_=caml_call2(_aBH_,v,v2);
              return _aBI_?caml_call1(f,v1):_aBI_}
            return caml_call2(S[4],_aBG_,g)}
          function fold_pred(f,g,v)
           {var _aBC_=S[3];
            if(1 - caml_call2(_aBC_,v,g))invalid_arg(_mv_);
            function _aBD_(v1,v2,a)
             {var _aBE_=S[1][3];
              return caml_call2(_aBE_,v,v2)?caml_call2(f,v1,a):a}
            return caml_call2(S[5],_aBD_,g)}
          function pred(g,v)
           {var _aBB_=0;
            return caml_call1
                    (fold_pred(function(v,l){return [0,v,l]},g,v),_aBB_)}
          function in_degree(g,v)
           {var _aBz_=S[3];
            if(1 - caml_call2(_aBz_,v,g))invalid_arg(_mw_);
            var _aBA_=0;
            return caml_call1
                    (fold_pred(function(param,n){return n + 1 | 0},g,v),_aBA_)}
          function iter_pred_e(f,g,v)
           {var _aBt_=S[3];
            if(1 - caml_call2(_aBt_,v,g))invalid_arg(_mx_);
            function _aBu_(e)
             {var
               _aBv_=S[2][3],
               _aBw_=caml_call1(_aBv_,e),
               _aBx_=S[1][3],
               _aBy_=caml_call2(_aBx_,v,_aBw_);
              return _aBy_?caml_call1(f,e):_aBy_}
            return caml_call2(S[6],_aBu_,g)}
          function fold_pred_e(f,g,v)
           {var _aBo_=S[3];
            if(1 - caml_call2(_aBo_,v,g))invalid_arg(_my_);
            function _aBp_(e,a)
             {var _aBq_=S[2][3],_aBr_=caml_call1(_aBq_,e),_aBs_=S[1][3];
              return caml_call2(_aBs_,v,_aBr_)?caml_call2(f,e,a):a}
            return caml_call2(S[7],_aBp_,g)}
          function pred_e(g,v)
           {var _aBn_=0;
            return caml_call1
                    (fold_pred_e(function(v,l){return [0,v,l]},g,v),_aBn_)}
          return [0,
                  iter_pred,
                  fold_pred,
                  pred,
                  in_degree,
                  iter_pred_e,
                  fold_pred_e,
                  pred_e]},
       Unlabeled=
        function(V,HM)
         {var
           S=_Y_([0,V[1]]),
           _aAM_=[0,V[1]],
           _aAN_=[0,V[1]],
           include=function(_aBm_){return OTProduct(_aAN_,_aBm_)}(_aAM_),
           compare=include[1];
          function src(_aBl_){return _aBl_[1]}
          function dst(_aBk_){return _aBk_[2]}
          function label(param){return 0}
          function create(v1,param,v2){return [0,v1,v2]}
          var E=[0,compare,src,dst,label,create];
          function mem_edge(g,v1,v2)
           {try
             {var
               _aBf_=HM[9],
               _aBg_=caml_call2(_aBf_,v1,g),
               _aBh_=S[3],
               _aBi_=caml_call2(_aBh_,v2,_aBg_);
              return _aBi_}
            catch(_aBj_)
             {_aBj_ = caml_wrap_exception(_aBj_);
              if(_aBj_ === Not_found)return 0;
              throw _aBj_}}
          function mem_edge_e(g,param)
           {var v2=param[2],v1=param[1];return mem_edge(g,v1,v2)}
          function find_edge(g,v1,v2)
           {if(mem_edge(g,v1,v2))return [0,v1,v2];throw Not_found}
          function find_all_edges(g,v1,v2)
           {try
             {var _aBc_=0,_aBd_=[0,find_edge(g,v1,v2),_aBc_];return _aBd_}
            catch(_aBe_)
             {_aBe_ = caml_wrap_exception(_aBe_);
              if(_aBe_ === Not_found)return 0;
              throw _aBe_}}
          function unsafe_remove_edge(g,v1,v2)
           {var
             _aA__=HM[9],
             _aA$_=caml_call2(_aA__,v1,g),
             _aBa_=S[6],
             _aBb_=caml_call2(_aBa_,v2,_aA$_);
            return caml_call3(HM[6],v1,_aBb_,g)}
          function unsafe_remove_edge_e(g,param)
           {var v2=param[2],v1=param[1];return unsafe_remove_edge(g,v1,v2)}
          function remove_edge(g,v1,v2)
           {var _aA5_=HM[8];
            if(1 - caml_call2(_aA5_,v2,g))invalid_arg(_mz_);
            var
             _aA6_=HM[10],
             _aA7_=caml_call3(_aA6_,v1,g,_mA_),
             _aA8_=S[6],
             _aA9_=caml_call2(_aA8_,v2,_aA7_);
            return caml_call3(HM[6],v1,_aA9_,g)}
          function remove_edge_e(g,param)
           {var v2=param[2],v1=param[1];return remove_edge(g,v1,v2)}
          function iter_succ(f,g,v)
           {var _aA3_=HM[10],_aA4_=caml_call3(_aA3_,v,g,_mB_);
            return caml_call2(S[14],f,_aA4_)}
          function fold_succ(f,g,v)
           {var _aA1_=HM[10],_aA2_=caml_call3(_aA1_,v,g,_mC_);
            return caml_call2(S[16],f,_aA2_)}
          function iter_succ_e(f,g,v)
           {return iter_succ(function(v2){return caml_call1(f,[0,v,v2])},g,v)}
          function fold_succ_e(f,g,v)
           {return fold_succ(function(v2){return caml_call1(f,[0,v,v2])},g,v)}
          function succ(g,v)
           {var _aAZ_=HM[10],_aA0_=caml_call3(_aAZ_,v,g,_mD_);
            return caml_call1(S[23],_aA0_)}
          function succ_e(g,v)
           {var _aAY_=0;
            return caml_call1
                    (fold_succ_e(function(e,l){return [0,e,l]},g,v),_aAY_)}
          function map_vertex(f)
           {function _aAS_(v,s)
             {var _aAT_=S[1];
              function _aAU_(v,s)
               {var _aAX_=caml_call1(f,v);return caml_call2(S[4],_aAX_,s)}
              var _aAV_=S[16],_aAW_=caml_call3(_aAV_,_aAU_,s,_aAT_);
              return [0,caml_call1(f,v),_aAW_]}
            return caml_call1(HM[12],_aAS_)}
          function iter_edges(f)
           {function _aAQ_(v)
             {var _aAR_=caml_call1(f,v);return caml_call1(S[14],_aAR_)}
            return caml_call1(HM[11],_aAQ_)}
          function fold_edges(f)
           {function _aAO_(v)
             {var _aAP_=caml_call1(f,v);return caml_call1(S[16],_aAP_)}
            return caml_call1(HM[13],_aAO_)}
          function iter_edges_e(f)
           {return iter_edges(function(v1,v2){return caml_call1(f,[0,v1,v2])})}
          function fold_edges_e(f)
           {return fold_edges
                    (function(v1,v2,a){return caml_call2(f,[0,v1,v2],a)})}
          var
           I=[0,V,iter_edges,fold_edges,iter_edges_e,fold_edges_e],
           PV=I[1],
           iter_edges$0=I[2],
           fold_edges$0=I[3],
           iter_edges_e$0=I[4],
           fold_edges_e$0=I[5],
           PV$0=I[1],
           iter_edges$1=I[2],
           fold_edges$1=I[3],
           iter_edges_e$1=I[4],
           fold_edges_e$1=I[5],
           mem_vertex=HM[8],
           include$0=
            Pred
             ([0,
               PV$0,
               [0,E[1],E[2],E[3],E[5],E[4]],
               mem_vertex,
               iter_edges$1,
               fold_edges$1,
               iter_edges_e$1,
               fold_edges_e$1]),
           iter_pred=include$0[1],
           fold_pred=include$0[2],
           pred=include$0[3],
           in_degree=include$0[4],
           iter_pred_e=include$0[5],
           fold_pred_e=include$0[6],
           pred_e=include$0[7];
          return [0,
                  S,
                  E,
                  mem_edge,
                  mem_edge_e,
                  find_edge,
                  find_all_edges,
                  unsafe_remove_edge,
                  unsafe_remove_edge_e,
                  remove_edge,
                  remove_edge_e,
                  iter_succ,
                  fold_succ,
                  iter_succ_e,
                  fold_succ_e,
                  succ,
                  succ_e,
                  map_vertex,
                  I,
                  PV,
                  iter_edges$0,
                  fold_edges$0,
                  iter_edges_e$0,
                  fold_edges_e$0,
                  iter_pred,
                  fold_pred,
                  pred,
                  in_degree,
                  iter_pred_e,
                  fold_pred_e,
                  pred_e]},
       Labeled=
        function(V,E,HM)
         {var
           _azs_=[0,V[1]],
           VE=function(_aAL_){return OTProduct(_azs_,_aAL_)}(E),
           S=_Y_(VE);
          function src(param){var v=param[1];return v}
          function dst(param){var v=param[3];return v}
          function label(param){var l=param[2];return l}
          function create(v1,l,v2){return [0,v1,l,v2]}
          var
           _azt_=[0,V[1]],
           C=function(_aAK_){return OTProduct(_azt_,_aAK_)}(VE);
          function compare(param,_aAJ_)
           {var
             y3=_aAJ_[3],
             y2=_aAJ_[2],
             y1=_aAJ_[1],
             x3=param[3],
             x2=param[2],
             x1=param[1];
            return caml_call2(C[1],[0,x1,[0,x3,x2]],[0,y1,[0,y3,y2]])}
          var E$0=[0,src,dst,label,create,C,compare];
          function mem_edge(g,v1,v2)
           {try
             {var
               _aAD_=HM[9],
               _aAE_=caml_call2(_aAD_,v1,g),
               _aAF_=
                function(param)
                 {var v2$0=param[1];return caml_call2(V[3],v2,v2$0)},
               _aAG_=S[18],
               _aAH_=caml_call2(_aAG_,_aAF_,_aAE_);
              return _aAH_}
            catch(_aAI_)
             {_aAI_ = caml_wrap_exception(_aAI_);
              if(_aAI_ === Not_found)return 0;
              throw _aAI_}}
          function mem_edge_e(g,param)
           {var v2=param[3],l=param[2],v1=param[1];
            try
             {var
               ve=[0,v2,l],
               _aAw_=HM[9],
               _aAx_=caml_call2(_aAw_,v1,g),
               _aAy_=
                function(ve$0)
                 {var _aAC_=VE[1];return 0 === caml_call2(_aAC_,ve,ve$0)?1:0},
               _aAz_=S[18],
               _aAA_=caml_call2(_aAz_,_aAy_,_aAx_);
              return _aAA_}
            catch(_aAB_)
             {_aAB_ = caml_wrap_exception(_aAB_);
              if(_aAB_ === Not_found)return 0;
              throw _aAB_}}
          var Found=[248,_mE_,caml_fresh_oo_id(0)];
          function find_edge(g,v1,v2)
           {try
             {var
               _aAq_=HM[9],
               _aAr_=caml_call2(_aAq_,v1,g),
               _aAs_=
                function(param)
                 {var
                   l=param[2],
                   v2$0=param[1],
                   _aAu_=V[3],
                   _aAv_=caml_call2(_aAu_,v2,v2$0);
                  if(_aAv_)throw [0,Found,[0,v1,l,v2$0]];
                  return _aAv_},
               _aAt_=S[14];
              caml_call2(_aAt_,_aAs_,_aAr_);
              throw Not_found}
            catch(exn)
             {exn = caml_wrap_exception(exn);
              if(exn[1] === Found){var e=exn[2];return e}
              throw exn}}
          function find_all_edges(g,v1,v2)
           {try
             {var
               _aAi_=0,
               _aAj_=HM[9],
               _aAk_=caml_call2(_aAj_,v1,g),
               _aAl_=
                function(param,acc)
                 {var l=param[2],v2$0=param[1],_aAp_=V[3];
                  return caml_call2(_aAp_,v2,v2$0)?[0,[0,v1,l,v2$0],acc]:acc},
               _aAm_=S[16],
               _aAn_=caml_call3(_aAm_,_aAl_,_aAk_,_aAi_);
              return _aAn_}
            catch(_aAo_)
             {_aAo_ = caml_wrap_exception(_aAo_);
              if(_aAo_ === Not_found)return 0;
              throw _aAo_}}
          function unsafe_remove_edge(g,v1,v2)
           {var _aAc_=HM[9],_aAd_=caml_call2(_aAc_,v1,g);
            function _aAe_(param)
             {var v2$0=param[1],_aAh_=V[3];
              return 1 - caml_call2(_aAh_,v2,v2$0)}
            var _aAf_=S[19],_aAg_=caml_call2(_aAf_,_aAe_,_aAd_);
            return caml_call3(HM[6],v1,_aAg_,g)}
          function unsafe_remove_edge_e(g,param)
           {var
             v2=param[3],
             l=param[2],
             v1=param[1],
             _az9_=HM[9],
             _az__=caml_call2(_az9_,v1,g),
             _az$_=[0,v2,l],
             _aAa_=S[6],
             _aAb_=caml_call2(_aAa_,_az$_,_az__);
            return caml_call3(HM[6],v1,_aAb_,g)}
          function remove_edge(g,v1,v2)
           {var _az2_=HM[8];
            if(1 - caml_call2(_az2_,v2,g))invalid_arg(_mF_);
            var _az3_=HM[10],_az4_=caml_call3(_az3_,v1,g,_mG_);
            function _az5_(param)
             {var v2$0=param[1],_az8_=V[3];
              return 1 - caml_call2(_az8_,v2,v2$0)}
            var _az6_=S[19],_az7_=caml_call2(_az6_,_az5_,_az4_);
            return caml_call3(HM[6],v1,_az7_,g)}
          function remove_edge_e(g,param)
           {var v2=param[3],l=param[2],v1=param[1],_azW_=HM[8];
            if(1 - caml_call2(_azW_,v2,g))invalid_arg(_mH_);
            var
             _azX_=HM[10],
             _azY_=caml_call3(_azX_,v1,g,_mI_),
             _azZ_=[0,v2,l],
             _az0_=S[6],
             _az1_=caml_call2(_az0_,_azZ_,_azY_);
            return caml_call3(HM[6],v1,_az1_,g)}
          function iter_succ(f,g,v)
           {var _azT_=HM[10],_azU_=caml_call3(_azT_,v,g,_mJ_);
            function _azV_(param){var w=param[1];return caml_call1(f,w)}
            return caml_call2(S[14],_azV_,_azU_)}
          function fold_succ(f,g,v)
           {var _azQ_=HM[10],_azR_=caml_call3(_azQ_,v,g,_mK_);
            function _azS_(param){var w=param[1];return caml_call1(f,w)}
            return caml_call2(S[16],_azS_,_azR_)}
          function iter_succ_e(f,g,v)
           {var _azN_=HM[10],_azO_=caml_call3(_azN_,v,g,_mL_);
            function _azP_(param)
             {var l=param[2],w=param[1];return caml_call1(f,[0,v,l,w])}
            return caml_call2(S[14],_azP_,_azO_)}
          function fold_succ_e(f,g,v)
           {var _azK_=HM[10],_azL_=caml_call3(_azK_,v,g,_mM_);
            function _azM_(param)
             {var l=param[2],w=param[1];return caml_call1(f,[0,v,l,w])}
            return caml_call2(S[16],_azM_,_azL_)}
          function succ(g,v)
           {var _azJ_=0;
            return caml_call1
                    (fold_succ(function(w,l){return [0,w,l]},g,v),_azJ_)}
          function succ_e(g,v)
           {var _azI_=0;
            return caml_call1
                    (fold_succ_e(function(e,l){return [0,e,l]},g,v),_azI_)}
          function map_vertex(f)
           {function _azC_(v,s)
             {var _azD_=S[1];
              function _azE_(param,s)
               {var l=param[2],v=param[1],_azH_=[0,caml_call1(f,v),l];
                return caml_call2(S[4],_azH_,s)}
              var _azF_=S[16],_azG_=caml_call3(_azF_,_azE_,s,_azD_);
              return [0,caml_call1(f,v),_azG_]}
            return caml_call1(HM[12],_azC_)}
          function iter_edges(f)
           {function _azA_(v)
             {function _azB_(param){var w=param[1];return caml_call2(f,v,w)}
              return caml_call1(S[14],_azB_)}
            return caml_call1(HM[11],_azA_)}
          function fold_edges(f)
           {function _azy_(v)
             {function _azz_(param){var w=param[1];return caml_call2(f,v,w)}
              return caml_call1(S[16],_azz_)}
            return caml_call1(HM[13],_azy_)}
          function iter_edges_e(f)
           {function _azw_(v)
             {function _azx_(param)
               {var l=param[2],w=param[1];return caml_call1(f,[0,v,l,w])}
              return caml_call1(S[14],_azx_)}
            return caml_call1(HM[11],_azw_)}
          function fold_edges_e(f)
           {function _azu_(v)
             {function _azv_(param)
               {var l=param[2],w=param[1];return caml_call1(f,[0,v,l,w])}
              return caml_call1(S[16],_azv_)}
            return caml_call1(HM[13],_azu_)}
          var
           I=[0,V,iter_edges,fold_edges,iter_edges_e,fold_edges_e],
           PV=I[1],
           iter_edges$0=I[2],
           fold_edges$0=I[3],
           iter_edges_e$0=I[4],
           fold_edges_e$0=I[5],
           PV$0=I[1],
           iter_edges$1=I[2],
           fold_edges$1=I[3],
           iter_edges_e$1=I[4],
           fold_edges_e$1=I[5],
           mem_vertex=HM[8],
           include=
            Pred
             ([0,
               PV$0,
               [0,E$0[6],E$0[1],E$0[2],E$0[4],E$0[3]],
               mem_vertex,
               iter_edges$1,
               fold_edges$1,
               iter_edges_e$1,
               fold_edges_e$1]),
           iter_pred=include[1],
           fold_pred=include[2],
           pred=include[3],
           in_degree=include[4],
           iter_pred_e=include[5],
           fold_pred_e=include[6],
           pred_e=include[7];
          return [0,
                  VE,
                  S,
                  E$0,
                  mem_edge,
                  mem_edge_e,
                  Found,
                  find_edge,
                  find_all_edges,
                  unsafe_remove_edge,
                  unsafe_remove_edge_e,
                  remove_edge,
                  remove_edge_e,
                  iter_succ,
                  fold_succ,
                  iter_succ_e,
                  fold_succ_e,
                  succ,
                  succ_e,
                  map_vertex,
                  I,
                  PV,
                  iter_edges$0,
                  fold_edges$0,
                  iter_edges_e$0,
                  fold_edges_e$0,
                  iter_pred,
                  fold_pred,
                  pred,
                  in_degree,
                  iter_pred_e,
                  fold_pred_e,
                  pred_e]},
       ConcreteVertex=
        function(F,V)
         {var compare=V[1],hash=V[2],equal=V[3];
          function label(v){return v}
          function create(v){return v}
          var
           V$0=[0,compare,hash,equal,label,create],
           HM=caml_call1(F,[0,V$0[1],V$0[2],V$0[3]]);
          return [0,V$0,HM]},
       Make_Abstract=
        function(G)
         {var PV=G[3],PE=G[4];
          function iter_edges(f,g){return caml_call2(G[22],f,g[1])}
          function fold_edges(f,g){return caml_call2(G[23],f,g[1])}
          function iter_edges_e(f,g){return caml_call2(G[24],f,g[1])}
          function fold_edges_e(f,g){return caml_call2(G[25],f,g[1])}
          function mem_vertex(v,g){return caml_call2(G[11],g[1],v)}
          function create(size,param)
           {var _azp_=0,_azq_=0,_azr_=G[40];
            return [0,caml_call2(_azr_,size,_azq_),_azp_]}
          function clear(g)
           {var _azn_=g[1],_azo_=G[41];
            caml_call1(_azo_,_azn_);
            g[2] = 0;
            return 0}
          var
           I=
            [0,
             PV,
             PE,
             iter_edges,
             fold_edges,
             iter_edges_e,
             fold_edges_e,
             mem_vertex,
             create,
             clear],
           PV$0=I[1],
           PE$0=I[2],
           iter_edges$0=I[3],
           fold_edges$0=I[4],
           iter_edges_e$0=I[5],
           fold_edges_e$0=I[6],
           create$0=I[8],
           clear$0=I[9],
           _ay$_=I[1],
           include=
            Pred
             ([0,[0,_ay$_[1],_ay$_[2],_ay$_[3]],I[2],I[7],I[3],I[4],I[5],I[6]]),
           iter_pred=include[1],
           fold_pred=include[2],
           pred=include[3],
           iter_pred_e=include[5],
           fold_pred_e=include[6],
           pred_e=include[7];
          function is_empty(g){return 0 === g[2]?1:0}
          function nb_vertex(g){return g[2]}
          var
           V=G[3],
           E=G[4],
           HM=G[1],
           S=G[2],
           unsafe_add_edge=G[37],
           unsafe_remove_edge=G[38],
           unsafe_remove_edge_e=G[39],
           is_directed=G[5];
          function remove_edge(g){return caml_call1(G[35],g[1])}
          function remove_edge_e(g){return caml_call1(G[36],g[1])}
          function out_degree(g){return caml_call1(G[9],g[1])}
          function in_degree(g){return caml_call1(G[10],g[1])}
          function nb_edges(g){return caml_call1(G[8],g[1])}
          function succ(g){return caml_call1(G[16],g[1])}
          function mem_vertex$0(g){return caml_call1(G[11],g[1])}
          function mem_edge(g){return caml_call1(G[12],g[1])}
          function mem_edge_e(g){return caml_call1(G[13],g[1])}
          function find_edge(g){return caml_call1(G[14],g[1])}
          function find_all_edges(g){return caml_call1(G[15],g[1])}
          function iter_vertex(f,g){return caml_call2(G[20],f,g[1])}
          function fold_vertex(f,g){return caml_call2(G[21],f,g[1])}
          function iter_succ(f,g){return caml_call2(G[27],f,g[1])}
          function fold_succ(f,g){return caml_call2(G[29],f,g[1])}
          function succ_e(g){return caml_call1(G[18],g[1])}
          function iter_succ_e(f,g){return caml_call2(G[31],f,g[1])}
          function fold_succ_e(f,g){return caml_call2(G[32],f,g[1])}
          function map_vertex(f,g)
           {var _azk_=g[2],_azl_=g[1],_azm_=G[26];
            return [0,caml_call2(_azm_,f,_azl_),_azk_]}
          function copy(g)
           {var _aza_=0,_azb_=0,_azc_=HM[1],h=caml_call2(_azc_,_azb_,_aza_);
            function vertex(v)
             {try
               {var _azh_=HM[9],_azi_=caml_call2(_azh_,v,h);return _azi_}
              catch(_azj_)
               {_azj_ = caml_wrap_exception(_azj_);
                if(_azj_ === Not_found)
                 {var
                   _azd_=V[5],
                   _aze_=caml_call1(_azd_,v),
                   _azf_=V[4],
                   v$0=caml_call1(_azf_,_aze_),
                   _azg_=HM[6],
                   h$0=caml_call3(_azg_,v,v$0,h);
                  if(h === h$0)return v$0;
                  throw [0,Assert_failure,_mN_]}
                throw _azj_}}
            return map_vertex(vertex,g)}
          return [0,
                  I,
                  PV$0,
                  PE$0,
                  iter_edges$0,
                  fold_edges$0,
                  iter_edges_e$0,
                  fold_edges_e$0,
                  create$0,
                  clear$0,
                  iter_pred,
                  fold_pred,
                  pred,
                  iter_pred_e,
                  fold_pred_e,
                  pred_e,
                  is_empty,
                  nb_vertex,
                  V,
                  E,
                  HM,
                  S,
                  unsafe_add_edge,
                  unsafe_remove_edge,
                  unsafe_remove_edge_e,
                  is_directed,
                  remove_edge,
                  remove_edge_e,
                  out_degree,
                  in_degree,
                  nb_edges,
                  succ,
                  mem_vertex$0,
                  mem_edge,
                  mem_edge_e,
                  find_edge,
                  find_all_edges,
                  iter_vertex,
                  fold_vertex,
                  iter_succ,
                  fold_succ,
                  succ_e,
                  iter_succ_e,
                  fold_succ_e,
                  map_vertex,
                  copy]},
       BidirectionalMinimal=
        function(S,HM)
         {var
           empty=HM[3],
           create=HM[1],
           clear=HM[4],
           is_empty=HM[5],
           copy=HM[14],
           is_directed=1;
          function nb_vertex(g)
           {var _ay7_=0;
            function _ay8_(param,_ay9_)
             {return function(_ay__){return _ay__ + 1 | 0}}
            return caml_call3(HM[13],_ay8_,g,_ay7_)}
          function nb_edges(g)
           {var _ay3_=0;
            function _ay4_(param,_ay5_,n)
             {var s=_ay5_[2],_ay6_=S[22];return n + caml_call1(_ay6_,s) | 0}
            return caml_call3(HM[13],_ay4_,g,_ay3_)}
          function out_degree(g,v)
           {try
             {var _ay0_=HM[9],_ay1_=caml_call2(_ay0_,v,g),_ayZ_=_ay1_}
            catch(_ay2_)
             {_ay2_ = caml_wrap_exception(_ay2_);
              if(_ay2_ !== Not_found)throw _ay2_;
              var _ayY_=invalid_arg(_mO_),_ayZ_=_ayY_}
            return caml_call1(S[22],_ayZ_[2])}
          function mem_vertex(g,v){return caml_call2(HM[8],v,g)}
          function unsafe_add_vertex(g,v)
           {return caml_call3(HM[6],v,[0,S[1],S[1]],g)}
          function add_vertex(g,v)
           {var _ayX_=HM[8];
            return caml_call2(_ayX_,v,g)?g:unsafe_add_vertex(g,v)}
          function iter_vertex(f)
           {function _ayW_(v,param){return caml_call1(f,v)}
            return caml_call1(HM[11],_ayW_)}
          function fold_vertex(f)
           {function _ayV_(v,param){return caml_call1(f,v)}
            return caml_call1(HM[13],_ayV_)}
          return [0,
                  is_directed,
                  empty,
                  create,
                  clear,
                  is_empty,
                  copy,
                  nb_vertex,
                  nb_edges,
                  out_degree,
                  mem_vertex,
                  unsafe_add_vertex,
                  add_vertex,
                  iter_vertex,
                  fold_vertex]},
       BidirectionalUnlabeled=
        function(V,HM)
         {var
           S=_Y_([0,V[1]]),
           _ax1_=[0,V[1]],
           _ax2_=[0,V[1]],
           include=function(_ayU_){return OTProduct(_ax2_,_ayU_)}(_ax1_),
           compare=include[1];
          function src(_ayT_){return _ayT_[1]}
          function dst(_ayS_){return _ayS_[2]}
          function label(param){return 0}
          function create(v1,param,v2){return [0,v1,v2]}
          var E=[0,compare,src,dst,label,create];
          function mem_edge(g,v1,v2)
           {try
             {var
               _ayN_=HM[9],
               _ayO_=caml_call2(_ayN_,v1,g)[2],
               _ayP_=S[3],
               _ayQ_=caml_call2(_ayP_,v2,_ayO_);
              return _ayQ_}
            catch(_ayR_)
             {_ayR_ = caml_wrap_exception(_ayR_);
              if(_ayR_ === Not_found)return 0;
              throw _ayR_}}
          function mem_edge_e(g,param)
           {var v2=param[2],v1=param[1];return mem_edge(g,v1,v2)}
          function find_edge(g,v1,v2)
           {if(mem_edge(g,v1,v2))return [0,v1,v2];throw Not_found}
          function find_all_edges(g,v1,v2)
           {try
             {var _ayK_=0,_ayL_=[0,find_edge(g,v1,v2),_ayK_];return _ayL_}
            catch(_ayM_)
             {_ayM_ = caml_wrap_exception(_ayM_);
              if(_ayM_ === Not_found)return 0;
              throw _ayM_}}
          function unsafe_remove_edge(g,v1,v2)
           {var
             _ayD_=HM[9],
             match=caml_call2(_ayD_,v1,g),
             out_set=match[2],
             in_set=match[1],
             _ayE_=S[6],
             _ayF_=[0,in_set,caml_call2(_ayE_,v2,out_set)],
             _ayG_=HM[6],
             g$0=caml_call3(_ayG_,v1,_ayF_,g),
             _ayH_=HM[9],
             match$0=caml_call2(_ayH_,v2,g$0),
             out_set$0=match$0[2],
             in_set$0=match$0[1],
             _ayI_=S[6],
             _ayJ_=[0,caml_call2(_ayI_,v1,in_set$0),out_set$0];
            return caml_call3(HM[6],v2,_ayJ_,g$0)}
          function unsafe_remove_edge_e(g,param)
           {var v2=param[2],v1=param[1];return unsafe_remove_edge(g,v1,v2)}
          function remove_edge(g,v1,v2)
           {var _ayz_=HM[8],_ayA_=caml_call2(_ayz_,v2,g);
            if(_ayA_)
             var _ayB_=HM[8],_ayC_=caml_call2(_ayB_,v1,g);
            else
             var _ayC_=_ayA_;
            if(1 - _ayC_)invalid_arg(_mP_);
            return unsafe_remove_edge(g,v1,v2)}
          function remove_edge_e(g,param)
           {var v2=param[2],v1=param[1];return remove_edge(g,v1,v2)}
          function iter_succ(f,g,v)
           {var _ayx_=HM[10],_ayy_=caml_call3(_ayx_,v,g,_mQ_)[2];
            return caml_call2(S[14],f,_ayy_)}
          function fold_succ(f,g,v)
           {var _ayv_=HM[10],_ayw_=caml_call3(_ayv_,v,g,_mR_)[2];
            return caml_call2(S[16],f,_ayw_)}
          function iter_succ_e(f,g,v)
           {return iter_succ(function(v2){return caml_call1(f,[0,v,v2])},g,v)}
          function fold_succ_e(f,g,v)
           {return fold_succ(function(v2){return caml_call1(f,[0,v,v2])},g,v)}
          function succ(g,v)
           {var _ayt_=HM[10],_ayu_=caml_call3(_ayt_,v,g,_mS_)[2];
            return caml_call1(S[23],_ayu_)}
          function succ_e(g,v)
           {var _ays_=0;
            return caml_call1
                    (fold_succ_e(function(e,l){return [0,e,l]},g,v),_ays_)}
          function map_vertex(f)
           {function _ayh_(v,param)
             {var s2=param[2],s1=param[1],_ayi_=S[1];
              function _ayj_(v,s)
               {var _ayr_=caml_call1(f,v);return caml_call2(S[4],_ayr_,s)}
              var
               _ayk_=S[16],
               _ayl_=caml_call3(_ayk_,_ayj_,s2,_ayi_),
               _aym_=S[1];
              function _ayn_(v,s)
               {var _ayq_=caml_call1(f,v);return caml_call2(S[4],_ayq_,s)}
              var
               _ayo_=S[16],
               _ayp_=[0,caml_call3(_ayo_,_ayn_,s1,_aym_),_ayl_];
              return [0,caml_call1(f,v),_ayp_]}
            return caml_call1(HM[12],_ayh_)}
          function iter_edges(f)
           {function _ayf_(v,param)
             {var outset=param[2],_ayg_=caml_call1(f,v);
              return caml_call2(S[14],_ayg_,outset)}
            return caml_call1(HM[11],_ayf_)}
          function fold_edges(f)
           {function _ayd_(v,param)
             {var outset=param[2],_aye_=caml_call1(f,v);
              return caml_call2(S[16],_aye_,outset)}
            return caml_call1(HM[13],_ayd_)}
          function iter_edges_e(f)
           {return iter_edges(function(v1,v2){return caml_call1(f,[0,v1,v2])})}
          function fold_edges_e(f)
           {return fold_edges
                    (function(v1,v2,a){return caml_call2(f,[0,v1,v2],a)})}
          var
           I=[0,V,iter_edges,fold_edges,iter_edges_e,fold_edges_e],
           PV=I[1],
           iter_edges$0=I[2],
           fold_edges$0=I[3],
           iter_edges_e$0=I[4],
           fold_edges_e$0=I[5];
          function iter_pred(f,g,v)
           {var _ayb_=HM[10],_ayc_=caml_call3(_ayb_,v,g,_mT_)[1];
            return caml_call2(S[14],f,_ayc_)}
          function fold_pred(f,g,v)
           {var _ax$_=HM[10],_aya_=caml_call3(_ax$_,v,g,_mU_)[1];
            return caml_call2(S[16],f,_aya_)}
          function pred(g,v)
           {var _ax9_=HM[10],_ax__=caml_call3(_ax9_,v,g,_mV_)[1];
            return caml_call1(S[23],_ax__)}
          function in_degree(g,v)
           {try
             {var _ax6_=HM[9],_ax7_=caml_call2(_ax6_,v,g),_ax5_=_ax7_}
            catch(_ax8_)
             {_ax8_ = caml_wrap_exception(_ax8_);
              if(_ax8_ !== Not_found)throw _ax8_;
              var _ax4_=invalid_arg(_mW_),_ax5_=_ax4_}
            return caml_call1(S[22],_ax5_[1])}
          function iter_pred_e(f,g,v)
           {return iter_pred(function(v2){return caml_call1(f,[0,v2,v])},g,v)}
          function fold_pred_e(f,g,v)
           {return fold_pred(function(v2){return caml_call1(f,[0,v2,v])},g,v)}
          function pred_e(g,v)
           {var _ax3_=0;
            return caml_call1
                    (fold_pred_e(function(e,l){return [0,e,l]},g,v),_ax3_)}
          return [0,
                  S,
                  E,
                  mem_edge,
                  mem_edge_e,
                  find_edge,
                  find_all_edges,
                  unsafe_remove_edge,
                  unsafe_remove_edge_e,
                  remove_edge,
                  remove_edge_e,
                  iter_succ,
                  fold_succ,
                  iter_succ_e,
                  fold_succ_e,
                  succ,
                  succ_e,
                  map_vertex,
                  I,
                  PV,
                  iter_edges$0,
                  fold_edges$0,
                  iter_edges_e$0,
                  fold_edges_e$0,
                  iter_pred,
                  fold_pred,
                  pred,
                  in_degree,
                  iter_pred_e,
                  fold_pred_e,
                  pred_e]},
       BidirectionalLabeled=
        function(V,E,HM)
         {var
           _awb_=[0,V[1]],
           VE=function(_ax0_){return OTProduct(_awb_,_ax0_)}(E),
           S=_Y_(VE);
          function src(param){var v=param[1];return v}
          function dst(param){var v=param[3];return v}
          function label(param){var l=param[2];return l}
          function create(v1,l,v2){return [0,v1,l,v2]}
          var
           _awc_=[0,V[1]],
           C=function(_axZ_){return OTProduct(_awc_,_axZ_)}(VE);
          function compare(param,_axY_)
           {var
             y3=_axY_[3],
             y2=_axY_[2],
             y1=_axY_[1],
             x3=param[3],
             x2=param[2],
             x1=param[1];
            return caml_call2(C[1],[0,x1,[0,x3,x2]],[0,y1,[0,y3,y2]])}
          var E$0=[0,src,dst,label,create,C,compare];
          function mem_edge(g,v1,v2)
           {try
             {var
               _axS_=HM[9],
               _axT_=caml_call2(_axS_,v1,g)[2],
               _axU_=
                function(param)
                 {var v2$0=param[1];return caml_call2(V[3],v2,v2$0)},
               _axV_=S[18],
               _axW_=caml_call2(_axV_,_axU_,_axT_);
              return _axW_}
            catch(_axX_)
             {_axX_ = caml_wrap_exception(_axX_);
              if(_axX_ === Not_found)return 0;
              throw _axX_}}
          function mem_edge_e(g,param)
           {var v2=param[3],l=param[2],v1=param[1];
            try
             {var
               ve=[0,v2,l],
               _axL_=HM[9],
               _axM_=caml_call2(_axL_,v1,g)[2],
               _axN_=
                function(ve$0)
                 {var _axR_=VE[1];return 0 === caml_call2(_axR_,ve,ve$0)?1:0},
               _axO_=S[18],
               _axP_=caml_call2(_axO_,_axN_,_axM_);
              return _axP_}
            catch(_axQ_)
             {_axQ_ = caml_wrap_exception(_axQ_);
              if(_axQ_ === Not_found)return 0;
              throw _axQ_}}
          var Found=[248,_mX_,caml_fresh_oo_id(0)];
          function find_edge(g,v1,v2)
           {try
             {var
               _axF_=HM[9],
               _axG_=caml_call2(_axF_,v1,g)[2],
               _axH_=
                function(param)
                 {var
                   l=param[2],
                   v2$0=param[1],
                   _axJ_=V[3],
                   _axK_=caml_call2(_axJ_,v2,v2$0);
                  if(_axK_)throw [0,Found,[0,v1,l,v2$0]];
                  return _axK_},
               _axI_=S[14];
              caml_call2(_axI_,_axH_,_axG_);
              throw Not_found}
            catch(exn)
             {exn = caml_wrap_exception(exn);
              if(exn[1] === Found){var e=exn[2];return e}
              throw exn}}
          function find_all_edges(g,v1,v2)
           {try
             {var
               _axx_=0,
               _axy_=HM[9],
               _axz_=caml_call2(_axy_,v1,g)[2],
               _axA_=
                function(param,acc)
                 {var l=param[2],v2$0=param[1],_axE_=V[3];
                  return caml_call2(_axE_,v2,v2$0)?[0,[0,v1,l,v2$0],acc]:acc},
               _axB_=S[16],
               _axC_=caml_call3(_axB_,_axA_,_axz_,_axx_);
              return _axC_}
            catch(_axD_)
             {_axD_ = caml_wrap_exception(_axD_);
              if(_axD_ === Not_found)return 0;
              throw _axD_}}
          function unsafe_remove_edge(g,v1,v2)
           {var
             _axq_=HM[9],
             match=caml_call2(_axq_,v1,g),
             out_set=match[2],
             in_set=match[1];
            function del(v,set)
             {function _axv_(param)
               {var v$0=param[1],_axw_=V[3];
                return 1 - caml_call2(_axw_,v,v$0)}
              return caml_call2(S[19],_axv_,set)}
            var
             _axr_=[0,in_set,del(v2,out_set)],
             _axs_=HM[6],
             g$0=caml_call3(_axs_,v1,_axr_,g),
             _axt_=HM[9],
             match$0=caml_call2(_axt_,v2,g$0),
             out_set$0=match$0[2],
             in_set$0=match$0[1],
             _axu_=[0,del(v1,in_set$0),out_set$0];
            return caml_call3(HM[6],v2,_axu_,g$0)}
          function unsafe_remove_edge_e(g,param)
           {var
             v2=param[3],
             l=param[2],
             v1=param[1],
             _axh_=HM[9],
             match=caml_call2(_axh_,v1,g),
             out_set=match[2],
             in_set=match[1],
             _axi_=[0,v2,l],
             _axj_=S[6],
             _axk_=[0,in_set,caml_call2(_axj_,_axi_,out_set)],
             _axl_=HM[6],
             g$0=caml_call3(_axl_,v1,_axk_,g),
             _axm_=HM[9],
             match$0=caml_call2(_axm_,v2,g$0),
             out_set$0=match$0[2],
             in_set$0=match$0[1],
             _axn_=[0,v1,l],
             _axo_=S[6],
             _axp_=[0,caml_call2(_axo_,_axn_,in_set$0),out_set$0];
            return caml_call3(HM[6],v2,_axp_,g$0)}
          function remove_edge(g,v1,v2)
           {var
             _axa_=HM[10],
             match=caml_call3(_axa_,v1,g,_mY_),
             out_set=match[2],
             in_set=match[1];
            function del(v,set)
             {function _axf_(param)
               {var v$0=param[1],_axg_=V[3];
                return 1 - caml_call2(_axg_,v,v$0)}
              return caml_call2(S[19],_axf_,set)}
            var
             _axb_=[0,in_set,del(v2,out_set)],
             _axc_=HM[6],
             g$0=caml_call3(_axc_,v1,_axb_,g),
             _axd_=HM[10],
             match$0=caml_call3(_axd_,v2,g$0,_mZ_),
             out_set$0=match$0[2],
             in_set$0=match$0[1],
             _axe_=[0,del(v1,in_set$0),out_set$0];
            return caml_call3(HM[6],v2,_axe_,g$0)}
          function remove_edge_e(g,param)
           {var
             v2=param[3],
             l=param[2],
             v1=param[1],
             _aw3_=HM[10],
             match=caml_call3(_aw3_,v1,g,_m0_),
             out_set=match[2],
             in_set=match[1],
             _aw4_=[0,v2,l],
             _aw5_=S[6],
             _aw6_=[0,in_set,caml_call2(_aw5_,_aw4_,out_set)],
             _aw7_=HM[6],
             g$0=caml_call3(_aw7_,v1,_aw6_,g),
             _aw8_=HM[10],
             match$0=caml_call3(_aw8_,v2,g$0,_m1_),
             out_set$0=match$0[2],
             in_set$0=match$0[1],
             _aw9_=[0,v1,l],
             _aw__=S[6],
             _aw$_=[0,caml_call2(_aw__,_aw9_,in_set$0),out_set$0];
            return caml_call3(HM[6],v2,_aw$_,g$0)}
          function iter_succ(f,g,v)
           {var _aw0_=HM[10],_aw1_=caml_call3(_aw0_,v,g,_m2_)[2];
            function _aw2_(param){var w=param[1];return caml_call1(f,w)}
            return caml_call2(S[14],_aw2_,_aw1_)}
          function fold_succ(f,g,v)
           {var _awX_=HM[10],_awY_=caml_call3(_awX_,v,g,_m3_)[2];
            function _awZ_(param){var w=param[1];return caml_call1(f,w)}
            return caml_call2(S[16],_awZ_,_awY_)}
          function iter_succ_e(f,g,v)
           {var _awU_=HM[10],_awV_=caml_call3(_awU_,v,g,_m4_)[2];
            function _awW_(param)
             {var l=param[2],w=param[1];return caml_call1(f,[0,v,l,w])}
            return caml_call2(S[14],_awW_,_awV_)}
          function fold_succ_e(f,g,v)
           {var _awR_=HM[10],_awS_=caml_call3(_awR_,v,g,_m5_)[2];
            function _awT_(param)
             {var l=param[2],w=param[1];return caml_call1(f,[0,v,l,w])}
            return caml_call2(S[16],_awT_,_awS_)}
          function succ(g,v)
           {var _awQ_=0;
            return caml_call1
                    (fold_succ(function(w,l){return [0,w,l]},g,v),_awQ_)}
          function succ_e(g,v)
           {var _awP_=0;
            return caml_call1
                    (fold_succ_e(function(e,l){return [0,e,l]},g,v),_awP_)}
          function map_vertex(f)
           {function _awE_(v,param)
             {var s2=param[2],s1=param[1],_awF_=S[1];
              function _awG_(param,s)
               {var l=param[2],v=param[1],_awO_=[0,caml_call1(f,v),l];
                return caml_call2(S[4],_awO_,s)}
              var
               _awH_=S[16],
               _awI_=caml_call3(_awH_,_awG_,s2,_awF_),
               _awJ_=S[1];
              function _awK_(param,s)
               {var l=param[2],v=param[1],_awN_=[0,caml_call1(f,v),l];
                return caml_call2(S[4],_awN_,s)}
              var
               _awL_=S[16],
               _awM_=[0,caml_call3(_awL_,_awK_,s1,_awJ_),_awI_];
              return [0,caml_call1(f,v),_awM_]}
            return caml_call1(HM[12],_awE_)}
          function iter_edges(f)
           {function _awC_(v,param)
             {var outset=param[2];
              function _awD_(param){var w=param[1];return caml_call2(f,v,w)}
              return caml_call2(S[14],_awD_,outset)}
            return caml_call1(HM[11],_awC_)}
          function fold_edges(f)
           {function _awA_(v,param)
             {var outset=param[2];
              function _awB_(param){var w=param[1];return caml_call2(f,v,w)}
              return caml_call2(S[16],_awB_,outset)}
            return caml_call1(HM[13],_awA_)}
          function iter_edges_e(f)
           {function _awy_(v,param)
             {var outset=param[2];
              function _awz_(param)
               {var l=param[2],w=param[1];return caml_call1(f,[0,v,l,w])}
              return caml_call2(S[14],_awz_,outset)}
            return caml_call1(HM[11],_awy_)}
          function fold_edges_e(f)
           {function _aww_(v,param)
             {var outset=param[2];
              function _awx_(param)
               {var l=param[2],w=param[1];return caml_call1(f,[0,v,l,w])}
              return caml_call2(S[16],_awx_,outset)}
            return caml_call1(HM[13],_aww_)}
          var
           I=[0,V,iter_edges,fold_edges,iter_edges_e,fold_edges_e],
           PV=I[1],
           iter_edges$0=I[2],
           fold_edges$0=I[3],
           iter_edges_e$0=I[4],
           fold_edges_e$0=I[5];
          function iter_pred(f,g,v)
           {var _awt_=HM[10],_awu_=caml_call3(_awt_,v,g,_m6_)[1];
            function _awv_(param){var w=param[1];return caml_call1(f,w)}
            return caml_call2(S[14],_awv_,_awu_)}
          function fold_pred(f,g,v)
           {var _awq_=HM[10],_awr_=caml_call3(_awq_,v,g,_m7_)[1];
            function _aws_(param){var w=param[1];return caml_call1(f,w)}
            return caml_call2(S[16],_aws_,_awr_)}
          function in_degree(g,v)
           {try
             {var _awn_=HM[9],_awo_=caml_call2(_awn_,v,g),_awm_=_awo_}
            catch(_awp_)
             {_awp_ = caml_wrap_exception(_awp_);
              if(_awp_ !== Not_found)throw _awp_;
              var _awl_=invalid_arg(_m8_),_awm_=_awl_}
            return caml_call1(S[22],_awm_[1])}
          function iter_pred_e(f,g,v)
           {var _awi_=HM[10],_awj_=caml_call3(_awi_,v,g,_m9_)[1];
            function _awk_(param)
             {var l=param[2],w=param[1];return caml_call1(f,[0,w,l,v])}
            return caml_call2(S[14],_awk_,_awj_)}
          function fold_pred_e(f,g,v)
           {var _awf_=HM[10],_awg_=caml_call3(_awf_,v,g,_m__)[1];
            function _awh_(param)
             {var l=param[2],w=param[1];return caml_call1(f,[0,w,l,v])}
            return caml_call2(S[16],_awh_,_awg_)}
          function pred(g,v)
           {var _awe_=0;
            return caml_call1
                    (fold_pred(function(w,l){return [0,w,l]},g,v),_awe_)}
          function pred_e(g,v)
           {var _awd_=0;
            return caml_call1
                    (fold_pred_e(function(e,l){return [0,e,l]},g,v),_awd_)}
          return [0,
                  VE,
                  S,
                  E$0,
                  mem_edge,
                  mem_edge_e,
                  Found,
                  find_edge,
                  find_all_edges,
                  unsafe_remove_edge,
                  unsafe_remove_edge_e,
                  remove_edge,
                  remove_edge_e,
                  iter_succ,
                  fold_succ,
                  iter_succ_e,
                  fold_succ_e,
                  succ,
                  succ_e,
                  map_vertex,
                  I,
                  PV,
                  iter_edges$0,
                  fold_edges$0,
                  iter_edges_e$0,
                  fold_edges_e$0,
                  iter_pred,
                  fold_pred,
                  in_degree,
                  iter_pred_e,
                  fold_pred_e,
                  pred,
                  pred_e]},
       Make$9=
        function(F)
         {function Concrete(_av6_)
           {var
             _av7_=function(_awa_){return ConcreteVertex(F,_awa_)}(_av6_),
             V=_av7_[1],
             HM=_av7_[2],
             _av8_=[0,V[1],V[2],V[3]],
             _av9_=function(_av$_){return Unlabeled(_av8_,_av$_)}(HM),
             S=_av9_[1],
             E=_av9_[2],
             mem_edge=_av9_[3],
             mem_edge_e=_av9_[4],
             find_edge=_av9_[5],
             find_all_edges=_av9_[6],
             unsafe_remove_edge=_av9_[7],
             unsafe_remove_edge_e=_av9_[8],
             remove_edge=_av9_[9],
             remove_edge_e=_av9_[10],
             iter_succ=_av9_[11],
             fold_succ=_av9_[12],
             iter_succ_e=_av9_[13],
             fold_succ_e=_av9_[14],
             succ=_av9_[15],
             succ_e=_av9_[16],
             map_vertex=_av9_[17],
             I=_av9_[18],
             PV=_av9_[19],
             iter_edges=_av9_[20],
             fold_edges=_av9_[21],
             iter_edges_e=_av9_[22],
             fold_edges_e=_av9_[23],
             iter_pred=_av9_[24],
             fold_pred=_av9_[25],
             pred=_av9_[26],
             in_degree=_av9_[27],
             iter_pred_e=_av9_[28],
             fold_pred_e=_av9_[29],
             pred_e=_av9_[30],
             include=function(_av__){return Minimal(S,_av__)}(HM),
             is_directed=include[1],
             empty=include[2],
             create=include[3],
             is_empty=include[4],
             copy=include[5],
             clear=include[6],
             nb_vertex=include[7],
             nb_edges=include[8],
             out_degree=include[9],
             mem_vertex=include[10],
             unsafe_add_vertex=include[11],
             unsafe_add_edge=include[12],
             add_vertex=include[13],
             iter_vertex=include[14],
             fold_vertex=include[15];
            function add_edge(g,v1,v2)
             {if(caml_call3(mem_edge,g,v1,v2))return g;
              var
               g$0=caml_call2(add_vertex,g,v1),
               g$1=caml_call2(add_vertex,g$0,v2);
              return caml_call3(unsafe_add_edge,g$1,v1,v2)}
            function add_edge_e(g,param)
             {var v2=param[2],v1=param[1];return add_edge(g,v1,v2)}
            return [0,
                    V,
                    HM,
                    S,
                    E,
                    mem_edge,
                    mem_edge_e,
                    find_edge,
                    find_all_edges,
                    unsafe_remove_edge,
                    unsafe_remove_edge_e,
                    remove_edge,
                    remove_edge_e,
                    iter_succ,
                    fold_succ,
                    iter_succ_e,
                    fold_succ_e,
                    succ,
                    succ_e,
                    map_vertex,
                    I,
                    PV,
                    iter_edges,
                    fold_edges,
                    iter_edges_e,
                    fold_edges_e,
                    iter_pred,
                    fold_pred,
                    pred,
                    in_degree,
                    iter_pred_e,
                    fold_pred_e,
                    pred_e,
                    is_directed,
                    empty,
                    create,
                    is_empty,
                    copy,
                    clear,
                    nb_vertex,
                    nb_edges,
                    out_degree,
                    mem_vertex,
                    unsafe_add_vertex,
                    unsafe_add_edge,
                    add_vertex,
                    iter_vertex,
                    fold_vertex,
                    add_edge,
                    add_edge_e]}
          function ConcreteBidirectional(_avR_)
           {var
             _avS_=function(_av5_){return ConcreteVertex(F,_av5_)}(_avR_),
             V=_avS_[1],
             HM=_avS_[2],
             _avT_=[0,V[1],V[2],V[3]],
             _avU_=
              function(_av4_){return BidirectionalUnlabeled(_avT_,_av4_)}(HM),
             S=_avU_[1],
             E=_avU_[2],
             mem_edge=_avU_[3],
             mem_edge_e=_avU_[4],
             find_edge=_avU_[5],
             find_all_edges=_avU_[6],
             unsafe_remove_edge=_avU_[7],
             unsafe_remove_edge_e=_avU_[8],
             remove_edge=_avU_[9],
             remove_edge_e=_avU_[10],
             iter_succ=_avU_[11],
             fold_succ=_avU_[12],
             iter_succ_e=_avU_[13],
             fold_succ_e=_avU_[14],
             succ=_avU_[15],
             succ_e=_avU_[16],
             map_vertex=_avU_[17],
             I=_avU_[18],
             PV=_avU_[19],
             iter_edges=_avU_[20],
             fold_edges=_avU_[21],
             iter_edges_e=_avU_[22],
             fold_edges_e=_avU_[23],
             iter_pred=_avU_[24],
             fold_pred=_avU_[25],
             pred=_avU_[26],
             in_degree=_avU_[27],
             iter_pred_e=_avU_[28],
             fold_pred_e=_avU_[29],
             pred_e=_avU_[30],
             include=function(_av3_){return BidirectionalMinimal(S,_av3_)}(HM),
             is_directed=include[1],
             empty=include[2],
             create=include[3],
             clear=include[4],
             is_empty=include[5],
             copy=include[6],
             nb_vertex=include[7],
             nb_edges=include[8],
             out_degree=include[9],
             mem_vertex=include[10],
             unsafe_add_vertex=include[11],
             add_vertex=include[12],
             iter_vertex=include[13],
             fold_vertex=include[14];
            function unsafe_add_edge(g,v1,v2)
             {function find(v,g)
               {try
                 {var _av0_=HM[9],_av1_=caml_call2(_av0_,v,g);return _av1_}
                catch(_av2_)
                 {_av2_ = caml_wrap_exception(_av2_);
                  if(_av2_ === Not_found)return [0,S[1],S[1]];
                  throw _av2_}}
              var
               match=find(v1,g),
               out_set=match[2],
               in_set=match[1],
               _avV_=S[4],
               _avW_=[0,in_set,caml_call2(_avV_,v2,out_set)],
               _avX_=HM[6],
               g$0=caml_call3(_avX_,v1,_avW_,g),
               match$0=find(v2,g$0),
               out_set$0=match$0[2],
               in_set$0=match$0[1],
               _avY_=S[4],
               _avZ_=[0,caml_call2(_avY_,v1,in_set$0),out_set$0];
              return caml_call3(HM[6],v2,_avZ_,g$0)}
            function add_edge(g,v1,v2)
             {return caml_call3(mem_edge,g,v1,v2)?g:unsafe_add_edge(g,v1,v2)}
            function add_edge_e(g,param)
             {var v2=param[2],v1=param[1];return add_edge(g,v1,v2)}
            return [0,
                    V,
                    HM,
                    S,
                    E,
                    mem_edge,
                    mem_edge_e,
                    find_edge,
                    find_all_edges,
                    unsafe_remove_edge,
                    unsafe_remove_edge_e,
                    remove_edge,
                    remove_edge_e,
                    iter_succ,
                    fold_succ,
                    iter_succ_e,
                    fold_succ_e,
                    succ,
                    succ_e,
                    map_vertex,
                    I,
                    PV,
                    iter_edges,
                    fold_edges,
                    iter_edges_e,
                    fold_edges_e,
                    iter_pred,
                    fold_pred,
                    pred,
                    in_degree,
                    iter_pred_e,
                    fold_pred_e,
                    pred_e,
                    is_directed,
                    empty,
                    create,
                    clear,
                    is_empty,
                    copy,
                    nb_vertex,
                    nb_edges,
                    out_degree,
                    mem_vertex,
                    unsafe_add_vertex,
                    add_vertex,
                    iter_vertex,
                    fold_vertex,
                    unsafe_add_edge,
                    add_edge,
                    add_edge_e]}
          function ConcreteLabeled(_avG_,Edge)
           {var
             _avH_=function(_avQ_){return ConcreteVertex(F,_avQ_)}(_avG_),
             V=_avH_[1],
             HM=_avH_[2],
             _avI_=[0,Edge[1]],
             _avJ_=[0,V[1],V[2],V[3]];
            function _avK_(_avO_,_avP_){return Labeled(_avJ_,_avO_,_avP_)}
            var
             _avL_=function(_avN_){return _avK_(_avI_,_avN_)}(HM),
             VE=_avL_[1],
             S=_avL_[2],
             E=_avL_[3],
             mem_edge=_avL_[4],
             mem_edge_e=_avL_[5],
             Found=_avL_[6],
             find_edge=_avL_[7],
             find_all_edges=_avL_[8],
             unsafe_remove_edge=_avL_[9],
             unsafe_remove_edge_e=_avL_[10],
             remove_edge=_avL_[11],
             remove_edge_e=_avL_[12],
             iter_succ=_avL_[13],
             fold_succ=_avL_[14],
             iter_succ_e=_avL_[15],
             fold_succ_e=_avL_[16],
             succ=_avL_[17],
             succ_e=_avL_[18],
             map_vertex=_avL_[19],
             I=_avL_[20],
             PV=_avL_[21],
             iter_edges=_avL_[22],
             fold_edges=_avL_[23],
             iter_edges_e=_avL_[24],
             fold_edges_e=_avL_[25],
             iter_pred=_avL_[26],
             fold_pred=_avL_[27],
             pred=_avL_[28],
             in_degree=_avL_[29],
             iter_pred_e=_avL_[30],
             fold_pred_e=_avL_[31],
             pred_e=_avL_[32],
             include=function(_avM_){return Minimal(S,_avM_)}(HM),
             is_directed=include[1],
             empty=include[2],
             create=include[3],
             is_empty=include[4],
             copy=include[5],
             clear=include[6],
             nb_vertex=include[7],
             nb_edges=include[8],
             out_degree=include[9],
             mem_vertex=include[10],
             unsafe_add_vertex=include[11],
             unsafe_add_edge=include[12],
             add_vertex=include[13],
             iter_vertex=include[14],
             fold_vertex=include[15];
            function add_edge_e(g,e)
             {var v2=e[3],l=e[2],v1=e[1];
              if(caml_call2(mem_edge_e,g,e))return g;
              var
               g$0=caml_call2(add_vertex,g,v1),
               g$1=caml_call2(add_vertex,g$0,v2);
              return caml_call3(unsafe_add_edge,g$1,v1,[0,v2,l])}
            function add_edge(g,v1,v2){return add_edge_e(g,[0,v1,Edge[2],v2])}
            return [0,
                    V,
                    HM,
                    VE,
                    S,
                    E,
                    mem_edge,
                    mem_edge_e,
                    Found,
                    find_edge,
                    find_all_edges,
                    unsafe_remove_edge,
                    unsafe_remove_edge_e,
                    remove_edge,
                    remove_edge_e,
                    iter_succ,
                    fold_succ,
                    iter_succ_e,
                    fold_succ_e,
                    succ,
                    succ_e,
                    map_vertex,
                    I,
                    PV,
                    iter_edges,
                    fold_edges,
                    iter_edges_e,
                    fold_edges_e,
                    iter_pred,
                    fold_pred,
                    pred,
                    in_degree,
                    iter_pred_e,
                    fold_pred_e,
                    pred_e,
                    is_directed,
                    empty,
                    create,
                    is_empty,
                    copy,
                    clear,
                    nb_vertex,
                    nb_edges,
                    out_degree,
                    mem_vertex,
                    unsafe_add_vertex,
                    unsafe_add_edge,
                    add_vertex,
                    iter_vertex,
                    fold_vertex,
                    add_edge_e,
                    add_edge]}
          function ConcreteBidirectionalLabeled(_avl_,Edge)
           {var
             _avm_=function(_avF_){return ConcreteVertex(F,_avF_)}(_avl_),
             V=_avm_[1],
             HM=_avm_[2],
             _avn_=[0,Edge[1]],
             _avo_=[0,V[1],V[2],V[3]];
            function _avp_(_avD_,_avE_)
             {return BidirectionalLabeled(_avo_,_avD_,_avE_)}
            var
             _avq_=function(_avC_){return _avp_(_avn_,_avC_)}(HM),
             VE=_avq_[1],
             S=_avq_[2],
             E=_avq_[3],
             mem_edge=_avq_[4],
             mem_edge_e=_avq_[5],
             Found=_avq_[6],
             find_edge=_avq_[7],
             find_all_edges=_avq_[8],
             unsafe_remove_edge=_avq_[9],
             unsafe_remove_edge_e=_avq_[10],
             remove_edge=_avq_[11],
             remove_edge_e=_avq_[12],
             iter_succ=_avq_[13],
             fold_succ=_avq_[14],
             iter_succ_e=_avq_[15],
             fold_succ_e=_avq_[16],
             succ=_avq_[17],
             succ_e=_avq_[18],
             map_vertex=_avq_[19],
             I=_avq_[20],
             PV=_avq_[21],
             iter_edges=_avq_[22],
             fold_edges=_avq_[23],
             iter_edges_e=_avq_[24],
             fold_edges_e=_avq_[25],
             iter_pred=_avq_[26],
             fold_pred=_avq_[27],
             in_degree=_avq_[28],
             iter_pred_e=_avq_[29],
             fold_pred_e=_avq_[30],
             pred=_avq_[31],
             pred_e=_avq_[32],
             include=function(_avB_){return BidirectionalMinimal(S,_avB_)}(HM),
             is_directed=include[1],
             empty=include[2],
             create=include[3],
             clear=include[4],
             is_empty=include[5],
             copy=include[6],
             nb_vertex=include[7],
             nb_edges=include[8],
             out_degree=include[9],
             mem_vertex=include[10],
             unsafe_add_vertex=include[11],
             add_vertex=include[12],
             iter_vertex=include[13],
             fold_vertex=include[14];
            function unsafe_add_edge_e(g,param)
             {var v2=param[3],l=param[2],v1=param[1];
              function find(v,g)
               {try
                 {var _avy_=HM[9],_avz_=caml_call2(_avy_,v,g);return _avz_}
                catch(_avA_)
                 {_avA_ = caml_wrap_exception(_avA_);
                  if(_avA_ === Not_found)return [0,S[1],S[1]];
                  throw _avA_}}
              var
               match=find(v1,g),
               out_set=match[2],
               in_set=match[1],
               _avr_=[0,v2,l],
               _avs_=S[4],
               _avt_=[0,in_set,caml_call2(_avs_,_avr_,out_set)],
               _avu_=HM[6],
               g$0=caml_call3(_avu_,v1,_avt_,g),
               match$0=find(v2,g$0),
               out_set$0=match$0[2],
               in_set$0=match$0[1],
               _avv_=[0,v1,l],
               _avw_=S[4],
               _avx_=[0,caml_call2(_avw_,_avv_,in_set$0),out_set$0];
              return caml_call3(HM[6],v2,_avx_,g$0)}
            function add_edge_e(g,e)
             {return caml_call2(mem_edge_e,g,e)?g:unsafe_add_edge_e(g,e)}
            function add_edge(g,v1,v2){return add_edge_e(g,[0,v1,Edge[2],v2])}
            return [0,
                    V,
                    HM,
                    VE,
                    S,
                    E,
                    mem_edge,
                    mem_edge_e,
                    Found,
                    find_edge,
                    find_all_edges,
                    unsafe_remove_edge,
                    unsafe_remove_edge_e,
                    remove_edge,
                    remove_edge_e,
                    iter_succ,
                    fold_succ,
                    iter_succ_e,
                    fold_succ_e,
                    succ,
                    succ_e,
                    map_vertex,
                    I,
                    PV,
                    iter_edges,
                    fold_edges,
                    iter_edges_e,
                    fold_edges_e,
                    iter_pred,
                    fold_pred,
                    in_degree,
                    iter_pred_e,
                    fold_pred_e,
                    pred,
                    pred_e,
                    is_directed,
                    empty,
                    create,
                    clear,
                    is_empty,
                    copy,
                    nb_vertex,
                    nb_edges,
                    out_degree,
                    mem_vertex,
                    unsafe_add_vertex,
                    add_vertex,
                    iter_vertex,
                    fold_vertex,
                    unsafe_add_edge_e,
                    add_edge_e,
                    add_edge]}
          function Abstract(V)
           {var
             HM=caml_call1(F,[0,V[1],V[2],V[3]]),
             _avg_=[0,V[1],V[2],V[3]],
             _avh_=function(_avk_){return Unlabeled(_avg_,_avk_)}(HM),
             S=_avh_[1],
             E=_avh_[2],
             mem_edge=_avh_[3],
             mem_edge_e=_avh_[4],
             find_edge=_avh_[5],
             find_all_edges=_avh_[6],
             unsafe_remove_edge=_avh_[7],
             unsafe_remove_edge_e=_avh_[8],
             remove_edge=_avh_[9],
             remove_edge_e=_avh_[10],
             iter_succ=_avh_[11],
             fold_succ=_avh_[12],
             iter_succ_e=_avh_[13],
             fold_succ_e=_avh_[14],
             succ=_avh_[15],
             succ_e=_avh_[16],
             map_vertex=_avh_[17],
             I=_avh_[18],
             PV=_avh_[19],
             iter_edges=_avh_[20],
             fold_edges=_avh_[21],
             iter_edges_e=_avh_[22],
             fold_edges_e=_avh_[23],
             iter_pred=_avh_[24],
             fold_pred=_avh_[25],
             pred=_avh_[26],
             in_degree=_avh_[27],
             iter_pred_e=_avh_[28],
             fold_pred_e=_avh_[29],
             pred_e=_avh_[30],
             include=function(_avj_){return Minimal(S,_avj_)}(HM),
             is_directed=include[1],
             empty=include[2],
             create=include[3],
             is_empty=include[4],
             copy=include[5],
             clear=include[6],
             nb_vertex=include[7],
             nb_edges=include[8],
             out_degree=include[9],
             mem_vertex=include[10],
             unsafe_add_vertex=include[11],
             unsafe_add_edge=include[12],
             add_vertex=include[13],
             iter_vertex=include[14],
             fold_vertex=include[15],
             G=
              [0,
               V,
               HM,
               S,
               E,
               mem_edge,
               mem_edge_e,
               find_edge,
               find_all_edges,
               unsafe_remove_edge,
               unsafe_remove_edge_e,
               remove_edge,
               remove_edge_e,
               iter_succ,
               fold_succ,
               iter_succ_e,
               fold_succ_e,
               succ,
               succ_e,
               map_vertex,
               I,
               PV,
               iter_edges,
               fold_edges,
               iter_edges_e,
               fold_edges_e,
               iter_pred,
               fold_pred,
               pred,
               in_degree,
               iter_pred_e,
               fold_pred_e,
               pred_e,
               is_directed,
               empty,
               create,
               is_empty,
               copy,
               clear,
               nb_vertex,
               nb_edges,
               out_degree,
               mem_vertex,
               unsafe_add_vertex,
               unsafe_add_edge,
               add_vertex,
               iter_vertex,
               fold_vertex],
             _avi_=G[4],
             include$0=
              Make_Abstract
               ([0,
                 G[2],
                 G[3],
                 G[1],
                 [0,_avi_[1],_avi_[2],_avi_[3],_avi_[5],_avi_[4]],
                 G[33],
                 G[36],
                 G[39],
                 G[40],
                 G[41],
                 G[29],
                 G[42],
                 G[5],
                 G[6],
                 G[7],
                 G[8],
                 G[17],
                 G[28],
                 G[18],
                 G[32],
                 G[46],
                 G[47],
                 G[22],
                 G[23],
                 G[24],
                 G[25],
                 G[19],
                 G[13],
                 G[26],
                 G[14],
                 G[27],
                 G[15],
                 G[16],
                 G[30],
                 G[31],
                 G[11],
                 G[12],
                 G[44],
                 G[9],
                 G[10],
                 G[35],
                 G[38]]),
             I$0=include$0[1],
             PV$0=include$0[2],
             PE=include$0[3],
             iter_edges$0=include$0[4],
             fold_edges$0=include$0[5],
             iter_edges_e$0=include$0[6],
             fold_edges_e$0=include$0[7],
             create$0=include$0[8],
             clear$0=include$0[9],
             iter_pred$0=include$0[10],
             fold_pred$0=include$0[11],
             pred$0=include$0[12],
             iter_pred_e$0=include$0[13],
             fold_pred_e$0=include$0[14],
             pred_e$0=include$0[15],
             is_empty$0=include$0[16],
             nb_vertex$0=include$0[17],
             V$0=include$0[18],
             E$0=include$0[19],
             HM$0=include$0[20],
             S$0=include$0[21],
             unsafe_add_edge$0=include$0[22],
             unsafe_remove_edge$0=include$0[23],
             unsafe_remove_edge_e$0=include$0[24],
             is_directed$0=include$0[25],
             remove_edge$0=include$0[26],
             remove_edge_e$0=include$0[27],
             out_degree$0=include$0[28],
             in_degree$0=include$0[29],
             nb_edges$0=include$0[30],
             succ$0=include$0[31],
             mem_vertex$0=include$0[32],
             mem_edge$0=include$0[33],
             mem_edge_e$0=include$0[34],
             find_edge$0=include$0[35],
             find_all_edges$0=include$0[36],
             iter_vertex$0=include$0[37],
             fold_vertex$0=include$0[38],
             iter_succ$0=include$0[39],
             fold_succ$0=include$0[40],
             succ_e$0=include$0[41],
             iter_succ_e$0=include$0[42],
             fold_succ_e$0=include$0[43],
             map_vertex$0=include$0[44],
             copy$0=include$0[45];
            return [0,
                    G,
                    I$0,
                    PV$0,
                    PE,
                    iter_edges$0,
                    fold_edges$0,
                    iter_edges_e$0,
                    fold_edges_e$0,
                    create$0,
                    clear$0,
                    iter_pred$0,
                    fold_pred$0,
                    pred$0,
                    iter_pred_e$0,
                    fold_pred_e$0,
                    pred_e$0,
                    is_empty$0,
                    nb_vertex$0,
                    V$0,
                    E$0,
                    HM$0,
                    S$0,
                    unsafe_add_edge$0,
                    unsafe_remove_edge$0,
                    unsafe_remove_edge_e$0,
                    is_directed$0,
                    remove_edge$0,
                    remove_edge_e$0,
                    out_degree$0,
                    in_degree$0,
                    nb_edges$0,
                    succ$0,
                    mem_vertex$0,
                    mem_edge$0,
                    mem_edge_e$0,
                    find_edge$0,
                    find_all_edges$0,
                    iter_vertex$0,
                    fold_vertex$0,
                    iter_succ$0,
                    fold_succ$0,
                    succ_e$0,
                    iter_succ_e$0,
                    fold_succ_e$0,
                    map_vertex$0,
                    copy$0]}
          function AbstractLabeled(V,_au8_)
           {var
             HM=caml_call1(F,[0,V[1],V[2],V[3]]),
             _au9_=[0,_au8_[1]],
             _au__=[0,V[1],V[2],V[3]];
            function _au$_(_ave_,_avf_){return Labeled(_au__,_ave_,_avf_)}
            var
             _ava_=function(_avd_){return _au$_(_au9_,_avd_)}(HM),
             VE=_ava_[1],
             S=_ava_[2],
             E=_ava_[3],
             mem_edge=_ava_[4],
             mem_edge_e=_ava_[5],
             Found=_ava_[6],
             find_edge=_ava_[7],
             find_all_edges=_ava_[8],
             unsafe_remove_edge=_ava_[9],
             unsafe_remove_edge_e=_ava_[10],
             remove_edge=_ava_[11],
             remove_edge_e=_ava_[12],
             iter_succ=_ava_[13],
             fold_succ=_ava_[14],
             iter_succ_e=_ava_[15],
             fold_succ_e=_ava_[16],
             succ=_ava_[17],
             succ_e=_ava_[18],
             map_vertex=_ava_[19],
             I=_ava_[20],
             PV=_ava_[21],
             iter_edges=_ava_[22],
             fold_edges=_ava_[23],
             iter_edges_e=_ava_[24],
             fold_edges_e=_ava_[25],
             iter_pred=_ava_[26],
             fold_pred=_ava_[27],
             pred=_ava_[28],
             in_degree=_ava_[29],
             iter_pred_e=_ava_[30],
             fold_pred_e=_ava_[31],
             pred_e=_ava_[32],
             include=function(_avc_){return Minimal(S,_avc_)}(HM),
             is_directed=include[1],
             empty=include[2],
             create=include[3],
             is_empty=include[4],
             copy=include[5],
             clear=include[6],
             nb_vertex=include[7],
             nb_edges=include[8],
             out_degree=include[9],
             mem_vertex=include[10],
             unsafe_add_vertex=include[11],
             unsafe_add_edge=include[12],
             add_vertex=include[13],
             iter_vertex=include[14],
             fold_vertex=include[15],
             G=
              [0,
               V,
               HM,
               VE,
               S,
               E,
               mem_edge,
               mem_edge_e,
               Found,
               find_edge,
               find_all_edges,
               unsafe_remove_edge,
               unsafe_remove_edge_e,
               remove_edge,
               remove_edge_e,
               iter_succ,
               fold_succ,
               iter_succ_e,
               fold_succ_e,
               succ,
               succ_e,
               map_vertex,
               I,
               PV,
               iter_edges,
               fold_edges,
               iter_edges_e,
               fold_edges_e,
               iter_pred,
               fold_pred,
               pred,
               in_degree,
               iter_pred_e,
               fold_pred_e,
               pred_e,
               is_directed,
               empty,
               create,
               is_empty,
               copy,
               clear,
               nb_vertex,
               nb_edges,
               out_degree,
               mem_vertex,
               unsafe_add_vertex,
               unsafe_add_edge,
               add_vertex,
               iter_vertex,
               fold_vertex],
             _avb_=G[5],
             include$0=
              Make_Abstract
               ([0,
                 G[2],
                 G[4],
                 G[1],
                 [0,_avb_[6],_avb_[1],_avb_[2],_avb_[4],_avb_[3]],
                 G[35],
                 G[38],
                 G[41],
                 G[42],
                 G[43],
                 G[31],
                 G[44],
                 G[6],
                 G[7],
                 G[9],
                 G[10],
                 G[19],
                 G[30],
                 G[20],
                 G[34],
                 G[48],
                 G[49],
                 G[24],
                 G[25],
                 G[26],
                 G[27],
                 G[21],
                 G[15],
                 G[28],
                 G[16],
                 G[29],
                 G[17],
                 G[18],
                 G[32],
                 G[33],
                 G[13],
                 G[14],
                 G[46],
                 G[11],
                 G[12],
                 G[37],
                 G[40]]),
             I$0=include$0[1],
             PV$0=include$0[2],
             PE=include$0[3],
             iter_edges$0=include$0[4],
             fold_edges$0=include$0[5],
             iter_edges_e$0=include$0[6],
             fold_edges_e$0=include$0[7],
             create$0=include$0[8],
             clear$0=include$0[9],
             iter_pred$0=include$0[10],
             fold_pred$0=include$0[11],
             pred$0=include$0[12],
             iter_pred_e$0=include$0[13],
             fold_pred_e$0=include$0[14],
             pred_e$0=include$0[15],
             is_empty$0=include$0[16],
             nb_vertex$0=include$0[17],
             V$0=include$0[18],
             E$0=include$0[19],
             HM$0=include$0[20],
             S$0=include$0[21],
             unsafe_add_edge$0=include$0[22],
             unsafe_remove_edge$0=include$0[23],
             unsafe_remove_edge_e$0=include$0[24],
             is_directed$0=include$0[25],
             remove_edge$0=include$0[26],
             remove_edge_e$0=include$0[27],
             out_degree$0=include$0[28],
             in_degree$0=include$0[29],
             nb_edges$0=include$0[30],
             succ$0=include$0[31],
             mem_vertex$0=include$0[32],
             mem_edge$0=include$0[33],
             mem_edge_e$0=include$0[34],
             find_edge$0=include$0[35],
             find_all_edges$0=include$0[36],
             iter_vertex$0=include$0[37],
             fold_vertex$0=include$0[38],
             iter_succ$0=include$0[39],
             fold_succ$0=include$0[40],
             succ_e$0=include$0[41],
             iter_succ_e$0=include$0[42],
             fold_succ_e$0=include$0[43],
             map_vertex$0=include$0[44],
             copy$0=include$0[45];
            return [0,
                    G,
                    I$0,
                    PV$0,
                    PE,
                    iter_edges$0,
                    fold_edges$0,
                    iter_edges_e$0,
                    fold_edges_e$0,
                    create$0,
                    clear$0,
                    iter_pred$0,
                    fold_pred$0,
                    pred$0,
                    iter_pred_e$0,
                    fold_pred_e$0,
                    pred_e$0,
                    is_empty$0,
                    nb_vertex$0,
                    V$0,
                    E$0,
                    HM$0,
                    S$0,
                    unsafe_add_edge$0,
                    unsafe_remove_edge$0,
                    unsafe_remove_edge_e$0,
                    is_directed$0,
                    remove_edge$0,
                    remove_edge_e$0,
                    out_degree$0,
                    in_degree$0,
                    nb_edges$0,
                    succ$0,
                    mem_vertex$0,
                    mem_edge$0,
                    mem_edge_e$0,
                    find_edge$0,
                    find_all_edges$0,
                    iter_vertex$0,
                    fold_vertex$0,
                    iter_succ$0,
                    fold_succ$0,
                    succ_e$0,
                    iter_succ_e$0,
                    fold_succ_e$0,
                    map_vertex$0,
                    copy$0]}
          var
           Digraph=
            [0,
             Concrete,
             ConcreteBidirectional,
             ConcreteLabeled,
             ConcreteBidirectionalLabeled,
             Abstract,
             AbstractLabeled];
          return [0,Digraph]},
       P=
        Make$9
         (function(_au6_)
           {var _au7_=Make_Map(_au6_);
            return [0,
                    _au7_[40],
                    _au7_[41],
                    _au7_[1],
                    _au7_[45],
                    _au7_[2],
                    _au7_[4],
                    _au7_[7],
                    _au7_[3],
                    _au7_[28],
                    _au7_[44],
                    _au7_[12],
                    _au7_[43],
                    _au7_[13],
                    _au7_[42]]}),
       Concrete=
        function(_au0_)
         {var
           include=caml_call1(P[1][1],_au0_),
           V=include[1],
           HM=include[2],
           S=include[3],
           E=include[4],
           mem_edge=include[5],
           mem_edge_e=include[6],
           find_edge=include[7],
           find_all_edges=include[8],
           unsafe_remove_edge=include[9],
           unsafe_remove_edge_e=include[10],
           remove_edge=include[11],
           remove_edge_e=include[12],
           iter_succ=include[13],
           fold_succ=include[14],
           iter_succ_e=include[15],
           fold_succ_e=include[16],
           succ=include[17],
           succ_e=include[18],
           map_vertex=include[19],
           I=include[20],
           PV=include[21],
           iter_edges=include[22],
           fold_edges=include[23],
           iter_edges_e=include[24],
           fold_edges_e=include[25],
           iter_pred=include[26],
           fold_pred=include[27],
           pred=include[28],
           in_degree=include[29],
           iter_pred_e=include[30],
           fold_pred_e=include[31],
           pred_e=include[32],
           is_directed=include[33],
           empty=include[34],
           create=include[35],
           is_empty=include[36],
           copy=include[37],
           clear=include[38],
           nb_vertex=include[39],
           nb_edges=include[40],
           out_degree=include[41],
           mem_vertex=include[42],
           unsafe_add_vertex=include[43],
           unsafe_add_edge=include[44],
           add_vertex=include[45],
           iter_vertex=include[46],
           fold_vertex=include[47],
           add_edge=include[48],
           add_edge_e=include[49];
          function remove_vertex(g,v)
           {var _au1_=HM[8];
            if(caml_call2(_au1_,v,g))
             {var
               _au2_=HM[7],
               g$0=caml_call2(_au2_,v,g),
               _au3_=
                function(k,s)
                 {var _au4_=S[6],_au5_=caml_call2(_au4_,v,s);
                  return caml_call2(HM[6],k,_au5_)};
              return caml_call3(HM[13],_au3_,g$0,empty)}
            return g}
          return [0,
                  V,
                  HM,
                  S,
                  E,
                  mem_edge,
                  mem_edge_e,
                  find_edge,
                  find_all_edges,
                  unsafe_remove_edge,
                  unsafe_remove_edge_e,
                  remove_edge,
                  remove_edge_e,
                  iter_succ,
                  fold_succ,
                  iter_succ_e,
                  fold_succ_e,
                  succ,
                  succ_e,
                  map_vertex,
                  I,
                  PV,
                  iter_edges,
                  fold_edges,
                  iter_edges_e,
                  fold_edges_e,
                  iter_pred,
                  fold_pred,
                  pred,
                  in_degree,
                  iter_pred_e,
                  fold_pred_e,
                  pred_e,
                  is_directed,
                  empty,
                  create,
                  is_empty,
                  copy,
                  clear,
                  nb_vertex,
                  nb_edges,
                  out_degree,
                  mem_vertex,
                  unsafe_add_vertex,
                  unsafe_add_edge,
                  add_vertex,
                  iter_vertex,
                  fold_vertex,
                  add_edge,
                  add_edge_e,
                  remove_vertex]},
       _m$_=
        function(_auW_)
         {var _auX_=Concrete(_auW_),_auY_=_auX_[4],_auZ_=_auX_[1];
          return [0,
                  [0,_auZ_[1],_auZ_[2],_auZ_[3],_auZ_[5],_auZ_[4]],
                  [0,_auY_[1],_auY_[2],_auY_[3],_auY_[5],_auY_[4]],
                  _auX_[33],
                  _auX_[36],
                  _auX_[39],
                  _auX_[40],
                  _auX_[41],
                  _auX_[29],
                  _auX_[42],
                  _auX_[5],
                  _auX_[6],
                  _auX_[7],
                  _auX_[8],
                  _auX_[17],
                  _auX_[28],
                  _auX_[18],
                  _auX_[32],
                  _auX_[46],
                  _auX_[47],
                  _auX_[22],
                  _auX_[23],
                  _auX_[24],
                  _auX_[25],
                  _auX_[19],
                  _auX_[13],
                  _auX_[26],
                  _auX_[14],
                  _auX_[27],
                  _auX_[15],
                  _auX_[16],
                  _auX_[30],
                  _auX_[31],
                  _auX_[34],
                  _auX_[45],
                  _auX_[50],
                  _auX_[48],
                  _auX_[49],
                  _auX_[11],
                  _auX_[12]]},
       Error=[248,_na_,caml_fresh_oo_id(0)],
       _nb_=[0,Error,[0]];
      register_exception(_nc_,_nb_);
      var
       raise=function(exn){throw exn},
       global=globalThis,
       null$0=null,
       undefined$0=undefined,
       return$1=function(_auV_){return _auV_},
       case$0=
        function(x,f,g){return x == null$0?caml_call1(f,0):caml_call1(g,x)},
       option=
        function(x){if(x){var x$0=x[1];return return$1(x$0)}return null$0},
       to_option=
        function(x)
         {function _auU_(x){return [0,x]}
          return case$0(x,function(param){return 0},_auU_)},
       case$1=
        function(x,f,g)
         {return x === undefined$0?caml_call1(f,0):caml_call1(g,x)},
       to_option$0=
        function(x)
         {function _auT_(x){return [0,x]}
          return case$1(x,function(param){return 0},_auT_)},
       _nd_=
        function(x)
         {return caml_call1(caml_get_public_method(x,944440446,20),x)},
       _ne_=function(t2,param){return t2.Object},
       object_constructor=_ne_(global,_nd_),
       object_keys=
        function(o)
         {function _auS_(x)
           {return caml_call1(caml_get_public_method(x,-955850252,21),x)}
          return function(t4,t3,param){return t4.keys(t3)}
                  (object_constructor,o,_auS_)},
       _nf_=
        function(x)
         {return caml_call1(caml_get_public_method(x,883172538,22),x)},
       _ng_=function(t5,param){return t5.Array},
       array_length=_ng_(global,_nf_),
       _nh_=
        function(x)
         {return caml_call1(caml_get_public_method(x,37651177,26),x)},
       _ni_=function(t10,param){return t10.Error},
       error_constr=_ni_(global,_nh_),
       to_string$7=
        function(e)
         {function _auP_(x)
           {return caml_call1(caml_get_public_method(x,946786476,30),x)}
          function _auQ_(t14,param){return t14.toString()}
          var _auR_=_auQ_(e,_auP_);
          return caml_string_of_jsstring(_auR_)},
       raise_js_error=function(e){return caml_call1(raise,e)},
       _nj_=
        function(param)
         {if(param[1] === Error){var e=param[2];return [0,to_string$7(e)]}
          return 0};
      register_printer(_nj_);
      var
       _nk_=
        function(e)
         {if(e instanceof array_length)return 0;
          function _auM_(x)
           {return caml_call1(caml_get_public_method(x,946786476,41),x)}
          function _auN_(t25,param){return t25.toString()}
          var _auO_=_auN_(e,_auM_);
          return [0,caml_string_of_jsstring(_auO_)]};
      register_printer(_nk_);
      var
       export_js=
        function(field,x){var _auL_=jsoo_exports;return _auL_[field] = x},
       export$0=
        function(field,x){return export_js(caml_jsstring_of_string(field),x)},
       console=caml_js_get_console(0),
       js_log=
        function(s)
         {function _auJ_(x)
           {return caml_call1(caml_get_public_method(x,5395588,43),x)}
          var _auK_=caml_jsstring_of_string(s);
          return function(t1,t0,param){return t1.log(t0)}(console,_auK_,_auJ_)},
       snd_map=
        function(f,param)
         {var y=param[2],x=param[1];return [0,x,caml_call1(f,y)]},
       pair_map=
        function(f,param)
         {var y=param[2],x=param[1],_auI_=caml_call1(f,y);
          return [0,caml_call1(f,x),_auI_]},
       symbol$2=function(f,g,x){return caml_call1(g,caml_call1(f,x))},
       symbol$3=function(f,g,x){return caml_call1(f,caml_call1(g,x))},
       curry=
        function(f,param){var y=param[2],x=param[1];return caml_call2(f,x,y)},
       uncurry=function(f,x,y){return caml_call1(f,[0,x,y])},
       symbol$4=function(f,x,y){return caml_call2(f,y,x)},
       fold$3=
        function(f,acc,param)
         {if(param){var v=param[1];return caml_call2(f,acc,v)}return acc},
       fst=function(xs){return map$0(function(_auH_){return _auH_[1]},xs)},
       snd=function(xs){return map$0(function(_auG_){return _auG_[2]},xs)},
       pop_at=
        function(i,l)
         {function aux(acc,i,l)
           {var acc$0=acc,i$0=i,l$0=l;
            for(;;)
             {if(0 === i$0)
               {if(l$0)
                 {var l$1=l$0[2],x=l$0[1];return [0,x,rev_append(acc$0,l$1)]}}
              else
               if(l$0)
                {var
                  l$2=l$0[2],
                  x$0=l$0[1],
                  i$1=i$0 - 1 | 0,
                  acc$1=[0,x$0,acc$0],
                  acc$0=acc$1,
                  i$0=i$1,
                  l$0=l$2;
                 continue}
              throw Not_found}}
          return aux(0,i,l)},
       join$2=
        function(sep)
         {function doit(acc,xs)
           {var acc$0=acc,xs$0=xs;
            for(;;)
             {if(xs$0)
               {var
                 xs$1=xs$0[2],
                 x=xs$0[1],
                 acc$1=[0,x,[0,sep,acc$0]],
                 acc$0=acc$1,
                 xs$0=xs$1;
                continue}
              return rev(acc$0)}}
          return function(xs)
           {if(xs)
             {var _auF_=xs[1];
              if(xs[2]){var xs$0=xs[2];return doit([0,_auF_,0],xs$0)}}
            return xs}},
       of_option=function(x){if(x){var x$0=x[1];return [0,x$0,0]}return 0},
       pivoti=
        function(f)
         {function aux(i,pre,s)
           {var i$0=i,pre$0=pre,s$0=s;
            for(;;)
             {if(s$0)
               {var s$1=s$0[2],x=s$0[1];
                if(caml_call2(f,i$0,x))return [0,rev(pre$0),x,s$1];
                var
                 pre$1=[0,x,pre$0],
                 i$1=i$0 + 1 | 0,
                 i$0=i$1,
                 pre$0=pre$1,
                 s$0=s$1;
                continue}
              return invalid_arg(_nl_)}}
          return function(s){return aux(0,0,s)}},
       pivot=
        function(f,s){return caml_call1(pivoti(function(param){return f}),s)},
       find_map_opt=
        function(f)
         {function doit(xs)
           {var xs$0=xs;
            for(;;)
             {if(xs$0)
               {var xs$1=xs$0[2],x=xs$0[1],match=caml_call1(f,x);
                if(match){var v=match[1];return [0,v]}
                var xs$0=xs$1;
                continue}
              return 0}}
          return function(xs){return doit(xs)}},
       is_prefix=
        function(xs,pr)
         {var xs$0=xs,pr$0=pr;
          for(;;)
           {if(pr$0)
             {if(xs$0)
               {var
                 pr$1=pr$0[2],
                 y=pr$0[1],
                 xs$1=xs$0[2],
                 x=xs$0[1],
                 _auE_=caml_equal(x,y);
                if(_auE_){var xs$0=xs$1,pr$0=pr$1;continue}
                return _auE_}
              return 0}
            return 1}},
       to_string$8=
        function(opt,_auv_,_auu_,print)
         {if(opt)var sth=opt[1],sep=sth;else var sep=_no_;
          if(_auv_)var sth$0=_auv_[1],left=sth$0;else var left=_nn_;
          if(_auu_)var sth$1=_auu_[1],right=sth$1;else var right=_nm_;
          function _auw_(s){return cat(left,cat(s,right))}
          function _aux_(_auD_){return join(sep,_auD_)}
          function _auy_(_auC_){return map$0(print,_auC_)}
          function _auz_(_auB_){return symbol$2(_auy_,_aux_,_auB_)}
          return function(_auA_){return symbol$2(_auz_,_auw_,_auA_)}},
       empty$6=[0,empty$1,empty$1],
       inverse=function(param){var l=param[2],r=param[1];return [0,l,r]},
       add$8=
        function(k,v,param)
         {var l=param[2],r=param[1],_aut_=add$6(v,k,l);
          return [0,add$6(k,v,r),_aut_]},
       find$4=function(k,param){var r=param[1];return find$2(k,r)},
       find_opt$1=function(k,param){var r=param[1];return find_opt$0(k,r)},
       codomain=function(param){var l=param[2];return of_enum$1(keys$0(l))},
       count$0=[0,-1],
       fresh=function(param){count$0[1]++;return count$0[1]},
       Disposed=[248,_np_,caml_fresh_oo_id(0)],
       get$5=
        function(p)
         {var _aus_=p[1];
          if(_aus_){var match=_aus_[1],x=match[2];return x}
          throw Disposed},
       create$11=function(cb,x){var r=[0,[0,[0,cb,x]]];return r},
       pr=
        function(opt,c)
         {if(opt)var sth=opt[1],doit=sth;else var doit=1;
          return doit?caml_call1(sprintf$0(_nq_),c):c},
       spaced=
        function(opt,_aup_,c)
         {if(opt)var sth=opt[1],left=sth;else var left=1;
          if(_aup_)var sth$0=_aup_[1],right=sth$0;else var right=1;
          var _auq_=right?_nr_:_nv_,_aur_=left?_ns_:_nu_;
          return caml_call3(sprintf$0(_nt_),_aur_,c,_auq_)},
       span=function(a){return function(_auo_){return node(a,_nw_,_auo_)}},
       spaced$0=
        function(opt,_auj_,c)
         {if(opt)var sth=opt[1],left=sth;else var left=1;
          if(_auj_)var sth$0=_auj_[1],right=sth$0;else var right=1;
          var
           _auk_=0,
           _aul_=0,
           _aum_=[0,entity(_nx_),_aul_],
           _aun_=0,
           sp=[0,caml_call1(span(_aun_),_aum_),_auk_],
           c$0=left?append(sp,c):c,
           c$1=right?append(c$0,sp):c$0;
          return c$1},
       pr$0=
        function(opt,c)
         {if(opt)var sth=opt[1],doit=sth;else var doit=1;
          var
           _aub_=0,
           _auc_=0,
           _aud_=[0,pcdata(_ny_),_auc_],
           _aue_=0,
           l=[0,caml_call1(span(_aue_),_aud_),_aub_],
           _auf_=0,
           _aug_=0,
           _auh_=[0,pcdata(_nz_),_aug_],
           _aui_=0,
           r=[0,caml_call1(span(_aui_),_auh_),_auf_];
          return doit?append(l,append(c,r)):c},
       math=function(a){return function(_aua_){return node(a,_nA_,_aua_)}},
       row=function(a){return function(_at$_){return node(a,_nB_,_at$_)}},
       mo=function(c){var _at__=0;return node(0,_nC_,[0,pcdata(c),_at__])},
       mi=function(c){var _at9_=0;return node(0,_nD_,[0,pcdata(c),_at9_])},
       mn=function(c){var _at8_=0;return node(0,_nE_,[0,pcdata(c),_at8_])},
       pr$1=
        function(opt,c)
         {if(opt)var sth=opt[1],doit=sth;else var doit=1;
          if(doit)
           {var
             _at5_=0,
             _at6_=[0,c,[0,mo(_nF_),_at5_]],
             _at7_=[0,mo(_nG_),_at6_];
            return caml_call1(row(0),_at7_)}
          return c},
       make$6=
        function(p1,p2)
         {function mkpos(p){return [0,p[2],p[4] - p[3] | 0]}
          var _at1_=p2[4],_at2_=p1[4],_at3_=mkpos(p2),_at4_=mkpos(p1);
          return [0,p1[1],_at4_,_at3_,_at2_,_at1_]},
       of_lexbuf=
        function(lb)
         {var p1=lexeme_start_p(lb),p2=lexeme_end_p(lb);return make$6(p1,p2)},
       unloc=function(x){return x[2]},
       mkloc=function(loc,x){return [0,loc,x]},
       ParseError=[248,_nH_,caml_fresh_oo_id(0)],
       State=
        function(T)
         {function return$0(x,st){return [0,x,st]}
          function bind(m,f,st)
           {var match=caml_call1(m,st),st$0=match[2],x=match[1];
            return caml_call2(f,x,st$0)}
          function fold$0(f,x,l,st)
           {var _at0_=[0,x,st];
            return fold
                    (function(param,y)
                      {var st=param[2],x=param[1];return caml_call3(f,x,y,st)},
                     _at0_,
                     l)}
          function iter(f,l)
           {var _atX_=0;
            function _atY_(param,y){return caml_call1(f,y)}
            return function(_atZ_){return fold$0(_atY_,_atX_,l,_atZ_)}}
          function get(st){return [0,st,st]}
          function put(st,param){return [0,0,st]}
          function run(m)
           {function _atU_(_atW_){return _atW_[1]}
            return function(_atV_){return symbol$2(m,_atU_,_atV_)}}
          return [0,return$0,bind,bind,bind,fold$0,iter,get,put,run]},
       return$2=function(x){return [0,x,0]},
       bind=function(m,f){return flatten$0(map$4(f,m))},
       concat$1=
        function(param)
         {if(param){var _atT_=param[1];if(_atT_){var x=_atT_[1];return [0,x]}}
          return 0},
       concat_map$0=function(f,x){return concat$1(map$3(f,x))},
       return$3=function(x){return [0,x]},
       bind$0=function(x,f){return concat_map$0(f,x)},
       e_vars=
        function(param)
         {if(0 === param[0]){var x=param[1];return return$2(x)}
          var ts=param[2];
          return bind(ts,e_vars)},
       term_of_expr=function(e){return [0,69,e]},
       term_of_form=function(f){return [0,70,f]},
       expr_of_term=
        function(t)
         {if(typeof t !== "number" && 69 === t[1]){var e=t[2];return e}
          throw [0,Invalid_argument,_nI_]},
       form_of_term=
        function(t)
         {if(typeof t !== "number" && 70 === t[1]){var f=t[2];return f}
          throw [0,Invalid_argument,_nJ_]},
       succ$3=function(n){return [1,_nK_,[0,n,0]]},
       _nN_=function(_atS_){return add$6(_nM_,_nL_,_atS_)},
       _nO_=_nN_(empty$1),
       _nP_=[0,0,nat],
       _nR_=function(_atR_){return add$6(_nQ_,_nP_,_atR_)},
       _nS_=_nR_(empty$1),
       _nT_=[0,[0,nat,0],nat],
       _nV_=function(_atQ_){return add$6(_nU_,_nT_,_atQ_)},
       _nW_=_nV_(_nS_),
       _nX_=[0,[0,nat,[0,nat,0]],nat],
       _nZ_=function(_atP_){return add$6(_nY_,_nX_,_atP_)},
       _n0_=_nZ_(_nW_),
       _n1_=[0,[0,nat,[0,nat,0]],nat],
       _n3_=function(_atO_){return add$6(_n2_,_n1_,_atO_)},
       empty$7=[0,empty$1,_n3_(_n0_),empty$1,_nO_,empty$1,empty$6],
       DuplicatedEntry=[248,_n4_,caml_fresh_oo_id(0)],
       empty$8=[0,empty$1,0],
       indices=function(lenv){return lenv[1]},
       get_index=function(lenv,name){return find$2(name,lenv[1])},
       exists$2=
        function(lenv,x){var _atN_=lenv[1];return mem(x,bindings(_atN_))},
       enter=
        function(lenv,name)
         {var _atE_=[0,name,lenv[2]],_atF_=lenv[1],_atG_=1;
          function _atH_(_atM_,_atL_){return _atM_ + _atL_ | 0}
          function _atI_(_atK_){return _atH_(_atG_,_atK_)}
          var _atJ_=-1;
          return [0,modify_def$0(_atJ_,name,_atI_,_atF_),_atE_]},
       push$1=
        function(env,param)
         {var sg=param[2],name=param[1],_atx_=env[1];
          if(mem$1(name,_atx_))throw [0,DuplicatedEntry,4003854,name];
          var
           _aty_=env[6],
           _atz_=env[5],
           _atA_=env[4],
           _atB_=env[3],
           _atC_=env[2],
           _atD_=env[1];
          return [0,add$6(name,sg,_atD_),_atC_,_atB_,_atA_,_atz_,_aty_]},
       get$6=function(env,name){return find$3(name,env[1])},
       all=function(env){return env[1]},
       push$2=
        function(init,param)
         {var sg=param[2],name=param[1],_atq_=init[1];
          if(mem$1(name,_atq_))throw [0,DuplicatedEntry,3507231,name];
          var
           _atr_=init[6],
           _ats_=init[5],
           _att_=init[4],
           _atu_=init[3],
           _atv_=init[2],
           _atw_=add$6(name,sg,_atv_);
          return [0,init[1],_atw_,_atu_,_att_,_ats_,_atr_]},
       get$7=function(env,name){return find$3(name,env[2])},
       all$0=function(env){return env[2]},
       push$3=
        function(init,param)
         {var
           body=param[2],
           name=param[1],
           _atk_=init[6],
           _atl_=init[5],
           _atm_=init[4];
          function _atn_(bds)
           {var _atp_=0,v=[0,body,default$0(_atp_,bds)];return [0,v]}
          var _ato_=modify_opt$0(name,_atn_,_atm_);
          return [0,init[1],init[2],init[3],_ato_,_atl_,_atk_]},
       get$8=
        function(env,param)
         {var
           idx=param[2],
           name=param[1],
           _ati_=env[4],
           _atj_=0,
           bds=find_default$0(_atj_,name,_ati_);
          return nth_opt(bds,idx)},
       exists$3=function(env,x){return is_some(get$8(env,x))},
       prio_of_form=function _ath_(_atg_){return _ath_.fun(_atg_)},
       prio_of_expr=function _atf_(_ate_){return _atf_.fun(_ate_)},
       prio_of_type=function _atd_(_atc_){return _atd_.fun(_atc_)},
       prio_of_op=function _atb_(_ata_){return _atb_.fun(_ata_)},
       prio_of_fun=function _as$_(_as__){return _as$_.fun(_as__)},
       prio_Not=5,
       prio_And=4,
       prio_Or=3,
       prio_Imp=2,
       prio_Equiv=1;
      caml_update_dummy
       (prio_of_form,
        function(param)
         {if(typeof param === "number")
           return 0 === param?max_num:max_num;
          else
           switch(param[0])
            {case 0:return max_num;
             case 1:var op=param[1];return caml_call1(prio_of_op,op);
             default:return min_num}});
      caml_update_dummy
       (prio_of_expr,
        function(param)
         {if(0 === param[0])return max_num;
          var f=param[1];
          return caml_call1(prio_of_fun,f)});
      caml_update_dummy
       (prio_of_type,
        function(param)
         {if(typeof param === "number")
           return max_num;
          else
           switch(param[0])
            {case 0:return max_num;
             case 1:return prio_And;
             case 2:return prio_Or;
             default:return min_num}});
      caml_update_dummy
       (prio_of_op,
        function(param)
         {return 3257015 === param
                  ?prio_And
                  :3903731 <= param
                    ?95438486 <= param?prio_Equiv:prio_Not
                    :3654636 <= param?prio_Imp:prio_Or});
      caml_update_dummy
       (prio_of_fun,
        function(param)
         {return caml_string_notequal(param,_n5_)
                  ?caml_string_notequal(param,_n6_)
                    ?caml_string_notequal(param,_n7_)
                      ?caml_string_notequal(param,_n8_)?min_num:2
                      :1
                    :max_num
                  :3});
      var
       _n9_=0,
       _n__=[0,function(_as9_,_as8_){return caml_lessequal(_as9_,_as8_)},_n9_],
       left_assoc=
        [0,function(_as7_,_as6_){return caml_lessthan(_as7_,_as6_)},_n__],
       _n$_=0,
       _oa_=[0,function(_as5_,_as4_){return caml_lessthan(_as5_,_as4_)},_n$_],
       right_assoc=
        [0,function(_as3_,_as2_){return caml_lessequal(_as3_,_as2_)},_oa_],
       _ob_=0,
       _oc_=[0,function(_as1_,_as0_){return caml_lessequal(_as1_,_as0_)},_ob_],
       no_assoc=
        [0,function(_asZ_,_asY_){return caml_lessequal(_asZ_,_asY_)},_oc_],
       assoc_of_op=
        function(param)
         {if(3903731 <= param)
           {if(95438486 <= param)return no_assoc;
            var _asV_=0;
            return [0,
                    function(_asX_,_asW_){return caml_lessthan(_asX_,_asW_)},
                    _asV_]}
          return 3654636 <= param?right_assoc:left_assoc},
       assoc_of_fun=
        function(param)
         {if(caml_string_notequal(param,_od_))
           {if(caml_string_notequal(param,_oe_))
             {if
               (caml_string_notequal(param,_of_)
                &&
                caml_string_notequal(param,_og_))
               throw [0,Assert_failure,_oh_];
              return left_assoc}
            return 0}
          var _asS_=0;
          return [0,
                  function(_asU_,_asT_){return caml_lessthan(_asU_,_asT_)},
                  _asS_]},
       unicode_of_op=
        function(param)
         {return 3257015 === param
                  ?8743
                  :3903731 <= param
                    ?95438486 <= param?10234:172
                    :3654636 <= param?10233:8744},
       ascii_of_op=
        function(param)
         {return 3257015 === param
                  ?_oi_
                  :3903731 <= param
                    ?95438486 <= param?_oj_:_ok_
                    :3654636 <= param?_ol_:_om_},
       for_type=
        function(opt)
         {if(opt)var sth=opt[1],is_pr=sth;else var is_pr=0;
          function _asy_(ty)
           {if(typeof ty === "number")
             return _on_;
            else
             switch(ty[0])
              {case 0:
                var _asD_=ty[1],_asE_=_asD_[1];
                if(0 === _asD_[2])return of_latin1(_asE_);
                var i=_asD_[2],_asF_=of_latin1(_asE_);
                return caml_call2(sprintf(_oo_),_asF_,i);
               case 3:
                var
                 t=ty[2],
                 x=ty[1],
                 _asP_=0,
                 _asQ_=caml_call1(for_type(_asP_),t),
                 _asR_=of_latin1(x);
                return caml_call2(sprintf$0(_oq_),_asR_,_asQ_);
               default:
                var
                 t2=ty[2],
                 t1=ty[1],
                 _asG_=caml_call1(prio_of_type,ty),
                 _asH_=[0,caml_call1(prio_of_type,t1) < _asG_?1:0],
                 t1$0=caml_call1(for_type(_asH_),t1),
                 _asI_=caml_call1(prio_of_type,ty),
                 _asJ_=[0,caml_call1(prio_of_type,t2) <= _asI_?1:0],
                 t2$0=caml_call1(for_type(_asJ_),t2),
                 switch$0=0;
                if(typeof ty !== "number")
                 switch(ty[0])
                  {case 1:var tycon=42;switch$0 = 1;break;
                   case 2:var tycon=43;switch$0 = 1;break
                   }
                if(switch$0)
                 {var
                   _asK_=of_char(tycon),
                   _asL_=of_char$0(_asK_),
                   _asM_=0,
                   _asN_=0,
                   _asO_=spaced(_asN_,_asM_,_asL_);
                  return cat(t1$0,cat(_asO_,t2$0))}
                throw [0,Assert_failure,_op_]}}
          var _asz_=[0,is_pr];
          function _asA_(_asC_){return pr(_asz_,_asC_)}
          return function(_asB_){return symbol$3(_asA_,_asy_,_asB_)}},
       for_expr=
        function(param)
         {if(0 === param[0])
           {var _ass_=param[1],_ast_=_ass_[1];
            if(0 === _ass_[2])return of_latin1(_ast_);
            var i=_ass_[2],_asu_=of_latin1(_ast_);
            return caml_call2(sprintf$0(_or_),_asu_,i)}
          var
           args=param[2],
           f=param[1],
           _asv_=map$4(for_expr,args),
           args$0=join(_os_,_asv_),
           _asw_=0,
           _asx_=pr(_asw_,args$0);
          return cat(of_latin1(f),_asx_)},
       for_form=
        function(opt)
         {if(opt)var sth=opt[1],is_pr=sth;else var is_pr=0;
          function _ar1_(param)
           {if(typeof param === "number")
             return 0 === param?_ot_:_ou_;
            else
             switch(param[0])
              {case 0:
                var _ar6_=param[1],switch$0=0;
                if(caml_string_notequal(_ar6_,_ov_))
                 switch$0 = 1;
                else
                 {var _ar9_=param[2];
                  if(_ar9_)
                   {var _ar__=_ar9_[2];
                    if(_ar__ && ! _ar__[2])
                     {var
                       e2=_ar__[1],
                       e1=_ar9_[1],
                       _ar$_=for_expr(e2),
                       _asa_=for_expr(e1);
                      return caml_call2(sprintf$0(_ox_),_asa_,_ar$_)}}
                  else
                   switch$0 = 1}
                if(switch$0 && ! param[2])return of_latin1(_ar6_);
                var
                 args=param[2],
                 args$0=map$4(for_expr,args),
                 args$1=join(_ow_,args$0),
                 _ar7_=0,
                 _ar8_=pr(_ar7_,args$1);
                return cat(of_latin1(_ar6_),_ar8_);
               case 1:
                var
                 fs=param[2],
                 lg=param[1],
                 text_lg=ascii_of_op(lg),
                 _asb_=assoc_of_op(lg),
                 _asc_=combine(fs,_asb_),
                 _asd_=
                  function(param)
                   {var
                     cmp=param[2],
                     f=param[1],
                     _asq_=caml_call1(prio_of_op,lg),
                     _asr_=caml_call1(prio_of_form,f);
                    return caml_call1
                            (for_form([0,caml_call2(cmp,_asr_,_asq_)]),f)},
                 _ase_=function(_asp_){return map$4(_asd_,_asp_)},
                 text_fs=_ase_(_asc_);
                if(3903731 === lg)
                 {if(text_fs && ! text_fs[2])
                   {var f=text_fs[1],_asf_=0;
                    return cat(spaced(_oz_,_asf_,text_lg),f)}}
                else
                 if(text_fs)
                  {var _asg_=text_fs[2];
                   if(_asg_ && ! _asg_[2])
                    {var
                      f2=_asg_[1],
                      f1=text_fs[1],
                      _ash_=0,
                      _asi_=0,
                      _asj_=spaced(_asi_,_ash_,text_lg);
                     return cat(f1,cat(_asj_,f2))}}
                throw [0,Assert_failure,_oy_];
               default:
                var
                 f$0=param[4],
                 ty=param[3],
                 x=param[2],
                 bd=param[1],
                 bd$0=840561112 <= bd?_oA_:_oC_,
                 _ask_=0,
                 _asl_=caml_call1(for_form(_ask_),f$0),
                 _asm_=0,
                 _asn_=caml_call1(for_type(_asm_),ty),
                 _aso_=of_latin1(x);
                return caml_call4(sprintf$0(_oB_),bd$0,_aso_,_asn_,_asl_)}}
          var _ar2_=[0,is_pr];
          function _ar3_(_ar5_){return pr(_ar2_,_ar5_)}
          return function(_ar4_){return symbol$3(_ar3_,_ar1_,_ar4_)}},
       t_toascii=function(t){return caml_call1(for_type(0),t)},
       e_toascii=function(e){return for_expr(e)},
       f_toascii=function(f){return caml_call1(for_form(0),f)},
       for_type$0=
        function(opt)
         {if(opt)var sth=opt[1],is_pr=sth;else var is_pr=0;
          function _arH_(ty)
           {if(typeof ty === "number")
             return _oD_;
            else
             switch(ty[0])
              {case 0:
                var _arM_=ty[1],_arN_=_arM_[1];
                if(caml_string_notequal(_arN_,_oE_))
                 {if(0 === _arM_[2])return of_latin1(_arN_);
                  var i=_arM_[2],_arO_=of_latin1(_arN_);
                  return caml_call2(sprintf(_oF_),_arO_,i)}
                return _oG_;
               case 3:
                var
                 t=ty[2],
                 x=ty[1],
                 _arY_=0,
                 _arZ_=caml_call1(for_type$0(_arY_),t),
                 _ar0_=of_latin1(x);
                return caml_call2(sprintf$0(_oI_),_ar0_,_arZ_);
               default:
                var
                 t2=ty[2],
                 t1=ty[1],
                 _arP_=caml_call1(prio_of_type,ty),
                 _arQ_=[0,caml_call1(prio_of_type,t1) < _arP_?1:0],
                 t1$0=caml_call1(for_type$0(_arQ_),t1),
                 _arR_=caml_call1(prio_of_type,ty),
                 _arS_=[0,caml_call1(prio_of_type,t2) <= _arR_?1:0],
                 t2$0=caml_call1(for_type$0(_arS_),t2),
                 switch$0=0;
                if(typeof ty !== "number")
                 switch(ty[0])
                  {case 1:var tycon=42;switch$0 = 1;break;
                   case 2:var tycon=43;switch$0 = 1;break
                   }
                if(switch$0)
                 {var
                   _arT_=of_char(tycon),
                   _arU_=of_char$0(_arT_),
                   _arV_=0,
                   _arW_=0,
                   _arX_=spaced(_arW_,_arV_,_arU_);
                  return cat(t1$0,cat(_arX_,t2$0))}
                throw [0,Assert_failure,_oH_]}}
          var _arI_=[0,is_pr];
          function _arJ_(_arL_){return pr(_arI_,_arL_)}
          return function(_arK_){return symbol$3(_arJ_,_arH_,_arK_)}},
       arg=
        function(opt,expr)
         {if(0 === expr[0])
           {var _arf_=expr[1],_arg_=_arf_[1];
            if(0 === _arf_[2])return of_latin1(_arg_);
            var i=_arf_[2],_arh_=of_latin1(_arg_);
            return caml_call2(sprintf$0(_oJ_),_arh_,i)}
          var _ari_=expr[1];
          if
           (caml_string_notequal(_ari_,_oK_)
            &&
            caml_string_notequal(_ari_,_oL_)
            &&
            caml_string_notequal(_ari_,_oM_)
            &&
            caml_string_notequal(_ari_,_oN_))
           {var
             args=expr[2],
             _arj_=function(eta){return arg(0,eta)},
             _ark_=map$4(_arj_,args),
             args$0=join(_oO_,_ark_),
             _arl_=0,
             _arm_=pr(_arl_,args$0);
            return cat(of_latin1(_ari_),_arm_)}
          var es=expr[2];
          function str(es)
           {var _arB_=assoc_of_fun(_ari_),_arC_=combine(es,_arB_);
            function _arD_(i,param)
             {var
               cmp=param[2],
               e=param[1],
               _arF_=caml_call1(prio_of_fun,_ari_),
               _arG_=caml_call1(prio_of_expr,e);
              return arg([0,caml_call2(cmp,_arG_,_arF_)],e)}
            return function(_arE_){return mapi(_arD_,_arE_)}(_arC_)}
          var match=str(es);
          if(caml_string_notequal(_ari_,_oP_))
           {if(caml_string_notequal(_ari_,_oQ_))
             {if(caml_string_notequal(_ari_,_oR_))
               {if(! caml_string_notequal(_ari_,_oS_) && match)
                 {var _arn_=match[2];
                  if(_arn_ && ! _arn_[2])
                   {var
                     e2=_arn_[1],
                     e1=match[1],
                     _aro_=0,
                     _arp_=0,
                     _arq_=spaced(_arp_,_aro_,_oU_);
                    return cat(e1,cat(_arq_,e2))}}}
              else
               if(match)
                {var _arr_=match[2];
                 if(_arr_ && ! _arr_[2])
                  {var
                    e2$0=_arr_[1],
                    e1$0=match[1],
                    _ars_=0,
                    _art_=0,
                    _aru_=spaced(_art_,_ars_,_oV_);
                   return cat(e1$0,cat(_aru_,e2$0))}}}
            else
             if(! match)return _oW_;
            throw [0,Assert_failure,_oT_]}
          function numeral(num,e)
           {var num$0=num,e$0=e;
            for(;;)
             {if(1 === e$0[0])
               {var _arz_=e$0[1];
                if(caml_string_notequal(_arz_,_oY_))
                 {if(! caml_string_notequal(_arz_,_oZ_) && ! e$0[2])
                   return to_string(num$0)}
                else
                 {var _arA_=e$0[2];
                  if(_arA_ && ! _arA_[2])
                   {var e$1=_arA_[1],num$1=num$0 + 1 | 0,num$0=num$1,e$0=e$1;
                    continue}}}
              var
               _arv_=to_string(num$0),
               _arw_=cat(_oX_,_arv_),
               _arx_=[0,e$0,0],
               _ary_=str(_arx_);
              return cat(hd(_ary_),_arw_)}}
          return numeral(0,expr)},
       for_form$0=
        function(opt)
         {if(opt)var sth=opt[1],is_pr=sth;else var is_pr=0;
          function _aqo_(param)
           {if(typeof param === "number")
             {if(0 === param){var _aqt_=8868;return of_char$0(chr$0(_aqt_))}
              var _aqu_=8869;
              return of_char$0(chr$0(_aqu_))}
            else
             switch(param[0])
              {case 0:
                var _aqv_=param[1],switch$0=0;
                if(caml_string_notequal(_aqv_,_o0_))
                 switch$0 = 1;
                else
                 {var _aqz_=param[2];
                  if(_aqz_)
                   {var _aqA_=_aqz_[2];
                    if(_aqA_ && ! _aqA_[2])
                     {var
                       e2=_aqA_[1],
                       e1=_aqz_[1],
                       _aqB_=0,
                       _aqC_=arg(_aqB_,e2),
                       _aqD_=0,
                       _aqE_=arg(_aqD_,e1);
                      return caml_call2(sprintf$0(_o2_),_aqE_,_aqC_)}}
                  else
                   switch$0 = 1}
                if(switch$0 && ! param[2])return of_latin1(_aqv_);
                var
                 args=param[2],
                 _aqw_=function(eta){return arg(0,eta)},
                 args$0=map$4(_aqw_,args),
                 args$1=join(_o1_,args$0),
                 _aqx_=0,
                 _aqy_=pr(_aqx_,args$1);
                return cat(of_latin1(_aqv_),_aqy_);
               case 1:
                var _aqF_=param[1];
                if(3903731 === _aqF_)
                 {var _aqG_=param[2];
                  if(_aqG_)
                   {var _aqH_=_aqG_[1],switch$1=0;
                    if(typeof _aqH_ === "number" || ! (0 === _aqH_[0]))
                     switch$1 = 1;
                    else
                     if(! caml_string_notequal(_aqH_[1],_o5_))
                      {var _aqT_=_aqH_[2];
                       if(_aqT_)
                        {var _aqU_=_aqT_[2];
                         if(_aqU_ && ! _aqU_[2] && ! _aqG_[2])
                          {var
                            e2$0=_aqU_[1],
                            e1$0=_aqT_[1],
                            _aqV_=0,
                            _aqW_=arg(_aqV_,e2$0),
                            _aqX_=8800,
                            _aqY_=chr$0(_aqX_),
                            _aqZ_=of_char$0(_aqY_),
                            _aq0_=0,
                            _aq1_=0,
                            _aq2_=spaced(_aq1_,_aq0_,_aqZ_),
                            _aq3_=cat(_aq2_,_aqW_),
                            _aq4_=0;
                           return cat(arg(_aq4_,e1$0),_aq3_)}}}}}
                var
                 fs=param[2],
                 _aqI_=unicode_of_op(_aqF_),
                 _aqJ_=chr$0(_aqI_),
                 text_lg=of_char$0(_aqJ_),
                 _aqK_=assoc_of_op(_aqF_),
                 _aqL_=combine(fs,_aqK_),
                 _aqM_=
                  function(param)
                   {var
                     cmp=param[2],
                     f=param[1],
                     _ard_=caml_call1(prio_of_op,_aqF_),
                     _are_=caml_call1(prio_of_form,f);
                    return caml_call1
                            (for_form$0([0,caml_call2(cmp,_are_,_ard_)]),f)},
                 _aqN_=function(_arc_){return map$4(_aqM_,_arc_)},
                 text_fs=_aqN_(_aqL_);
                if(3903731 === _aqF_)
                 {if(text_fs && ! text_fs[2])
                   {var f=text_fs[1],_aqO_=0;
                    return cat(spaced(_o4_,_aqO_,text_lg),f)}}
                else
                 if(text_fs)
                  {var _aqP_=text_fs[2];
                   if(_aqP_ && ! _aqP_[2])
                    {var
                      f2=_aqP_[1],
                      f1=text_fs[1],
                      _aqQ_=0,
                      _aqR_=0,
                      _aqS_=spaced(_aqR_,_aqQ_,text_lg);
                     return cat(f1,cat(_aqS_,f2))}}
                throw [0,Assert_failure,_o3_];
               default:
                var f$0=param[4],ty=param[3],x=param[2],bd=param[1];
                if(840561112 <= bd)
                 var _aq5_=8704,_aq6_=chr$0(_aq5_),bd$0=of_char$0(_aq6_);
                else
                 var _ara_=8707,_arb_=chr$0(_ara_),bd$0=of_char$0(_arb_);
                var
                 _aq7_=0,
                 _aq8_=caml_call1(for_form$0(_aq7_),f$0),
                 _aq9_=0,
                 _aq__=caml_call1(for_type$0(_aq9_),ty),
                 _aq$_=of_latin1(x);
                return caml_call4(sprintf$0(_o6_),bd$0,_aq$_,_aq__,_aq8_)}}
          var _aqp_=[0,is_pr];
          function _aqq_(_aqs_){return pr(_aqp_,_aqs_)}
          return function(_aqr_){return symbol$3(_aqq_,_aqo_,_aqr_)}},
       t_tostring=function(t){return caml_call1(for_type$0(0),t)},
       e_tostring=function(e){return arg(0,e)},
       f_tostring=function(f){return caml_call1(for_form$0(0),f)},
       for_type$1=
        function(opt,ty)
         {if(opt)var sth=opt[1],is_pr=sth;else var is_pr=0;
          if(typeof ty === "number")
           var
            _apg_=0,
            _aph_=0,
            _api_=[0,pcdata(_o7_),_aph_],
            _apj_=0,
            data=[0,caml_call1(span(_apj_),_api_),_apg_];
          else
           switch(ty[0])
            {case 0:
              var _apo_=ty[1],_app_=_apo_[1];
              if(caml_string_notequal(_app_,_o8_))
               {if(0 === _apo_[2])
                 var
                  _apq_=0,
                  _apr_=0,
                  _aps_=of_latin1(_app_),
                  _apt_=[0,pcdata(_aps_),_apr_],
                  _apu_=0,
                  _apv_=[0,caml_call1(span(_apu_),_apt_),_apq_];
                else
                 var
                  i=_apo_[2],
                  _apx_=0,
                  _apy_=0,
                  _apz_=of_latin1(_app_),
                  _apA_=caml_call2(sprintf(_o9_),_apz_,i),
                  _apB_=[0,pcdata(_apA_),_apy_],
                  _apC_=0,
                  _apv_=[0,caml_call1(span(_apC_),_apB_),_apx_];
                var _apw_=_apv_}
              else
               var
                _apD_=0,
                _apE_=0,
                _apF_=[0,pcdata(_o__),_apE_],
                _apG_=0,
                _apw_=[0,caml_call1(span(_apG_),_apF_),_apD_];
              var data=_apw_;
              break;
             case 3:
              var
               t=ty[2],
               x=ty[1],
               _apT_=0,
               _apU_=0,
               _apV_=0,
               _apW_=for_type$1(_apV_,t),
               _apX_=0,
               _apY_=[0,[0,caml_call1(span(_apX_),_apW_),_apU_],_apT_],
               _apZ_=0,
               _ap0_=0,
               _ap1_=0,
               _ap2_=[0,pcdata(_pa_),_ap1_],
               _ap3_=0,
               _ap4_=[0,[0,caml_call1(span(_ap3_),_ap2_),_ap0_],_apZ_],
               _ap5_=append(_ap4_,_apY_),
               _ap6_=0,
               _ap7_=0,
               _ap8_=0,
               _ap9_=of_latin1(x),
               _ap__=[0,pcdata(_ap9_),_ap8_],
               _ap$_=0,
               _aqa_=[0,[0,caml_call1(span(_ap$_),_ap__),_ap7_],_ap6_],
               _aqb_=append(_aqa_,_ap5_),
               _aqc_=0,
               _aqd_=0,
               _aqe_=0,
               _aqf_=[0,pcdata(_pb_),_aqe_],
               _aqg_=0,
               _aqh_=[0,[0,caml_call1(span(_aqg_),_aqf_),_aqd_],_aqc_],
               aout=append(_aqh_,_aqb_),
               _aqi_=0,
               _aqj_=0,
               _aqk_=[0,entity(_pc_),_aqj_],
               _aql_=0,
               _aqm_=[0,caml_call1(span(_aql_),_aqk_),_aqi_],
               _aqn_=caml_call1(join$2(_aqm_),aout),
               data=flatten$0(_aqn_);
              break;
             default:
              var
               t2=ty[2],
               t1=ty[1],
               _apH_=caml_call1(prio_of_type,ty),
               _apI_=[0,caml_call1(prio_of_type,t1) < _apH_?1:0],
               t1$0=for_type$1(_apI_,t1),
               _apJ_=caml_call1(prio_of_type,ty),
               _apK_=[0,caml_call1(prio_of_type,t2) <= _apJ_?1:0],
               t2$0=for_type$1(_apK_,t2),
               switch$0=0;
              if(typeof ty !== "number")
               switch(ty[0])
                {case 1:var tycon=42;switch$0 = 1;break;
                 case 2:var tycon=43;switch$0 = 1;break
                 }
              if(! switch$0)throw [0,Assert_failure,_o$_];
              var
               _apL_=0,
               _apM_=of_char(tycon),
               _apN_=of_char$0(_apM_),
               _apO_=[0,pcdata(_apN_),_apL_],
               _apP_=0,
               _apQ_=0,
               _apR_=spaced$0(_apQ_,_apP_,_apO_),
               _apS_=append(_apR_,t2$0),
               data=append(t1$0,_apS_)}
          var _apk_=0,_apl_=[0,is_pr],_apm_=pr$0(_apl_,data),_apn_=0;
          return [0,caml_call1(span(_apn_),_apm_),_apk_]},
       for_expr$0=
        function(id,opt,p)
         {if(opt)var sth=opt[1],is_pr=sth;else var is_pr=0;
          return function(expr)
           {function for_expr(_ape_,_apf_){return for_expr$0(id,_ape_,_apf_)}
            function thisid(p)
             {function _ao8_(prefix)
               {var _apd_=rev_map(to_string,p),p$0=join(_pd_,_apd_);
                return fold$3
                        (function(p,prefix)
                          {return caml_call2(sprintf$0(_pe_),prefix,p)},
                         p$0,
                         prefix)}
              function _ao9_(_apc_){return map$3(_ao8_,_apc_)}
              var _ao__=_ao9_(id);
              function _ao$_(x){return string_attrib(_pf_,x)}
              function _apa_(_apb_){return map$3(_ao$_,_apb_)}
              return of_option(_apa_(_ao__))}
            var id$0=[0,1];
            if(0 === expr[0])
             {var _anr_=expr[1],_ans_=_anr_[1];
              if(0 === _anr_[2])
               var
                _ant_=0,
                _anu_=0,
                _anv_=of_latin1(_ans_),
                _anw_=[0,pcdata(_anv_),_anu_],
                _anx_=0,
                _any_=[0,caml_call1(span(_anx_),_anw_),_ant_];
              else
               var
                i=_anr_[2],
                _anE_=0,
                _anF_=0,
                _anG_=of_latin1(_ans_),
                _anH_=caml_call2(sprintf(_pg_),_anG_,i),
                _anI_=[0,pcdata(_anH_),_anF_],
                _anJ_=0,
                _any_=[0,caml_call1(span(_anJ_),_anI_),_anE_];
              var data=_any_}
            else
             {var _anK_=expr[1],switch$0=0;
              if
               (caml_string_notequal(_anK_,_ph_)
                &&
                caml_string_notequal(_anK_,_pi_)
                &&
                caml_string_notequal(_anK_,_pj_)
                &&
                caml_string_notequal(_anK_,_pk_))
               {var
                 args=expr[2],
                 _anL_=function(i,e){return caml_call1(for_expr(0,[0,i,p]),e)},
                 args$0=mapi(_anL_,args),
                 _anM_=0,
                 _anN_=0,
                 _anO_=0,
                 _anP_=[0,entity(_pl_),_anO_],
                 _anQ_=[0,pcdata(_pm_),_anP_],
                 _anR_=0,
                 _anS_=[0,caml_call1(span(_anR_),_anQ_),_anN_],
                 _anT_=caml_call1(join$2(_anS_),args$0),
                 _anU_=flatten$0(_anT_),
                 _anV_=0,
                 _anW_=[0,pr$0(_anV_,_anU_),_anM_],
                 _anX_=0,
                 _anY_=0,
                 _anZ_=0,
                 _an0_=of_latin1(_anK_),
                 _an1_=[0,pcdata(_an0_),_anZ_],
                 _an2_=0,
                 _an3_=[0,[0,caml_call1(span(_an2_),_an1_),_anY_],_anX_],
                 aout=append(_an3_,_anW_),
                 _an4_=0,
                 _an5_=0,
                 _an6_=[0,entity(_pn_),_an5_],
                 _an7_=0,
                 _an8_=[0,caml_call1(span(_an7_),_an6_),_an4_],
                 _an9_=caml_call1(join$2(_an8_),aout),
                 _an__=flatten$0(_an9_);
                switch$0 = 1}
              if(! switch$0)
               {var
                 es=expr[2],
                 xml=
                  function(es,p)
                   {var _ao1_=assoc_of_fun(_anK_),_ao2_=combine(es,_ao1_);
                    function _ao3_(i,param)
                     {var
                       cmp=param[2],
                       e=param[1],
                       _ao5_=[0,i,p],
                       _ao6_=caml_call1(prio_of_fun,_anK_),
                       _ao7_=caml_call1(prio_of_expr,e);
                      return caml_call1
                              (for_expr([0,caml_call2(cmp,_ao7_,_ao6_)],_ao5_),e)}
                    return function(_ao4_){return mapi(_ao3_,_ao4_)}(_ao2_)},
                 match=xml(es,p);
                if(caml_string_notequal(_anK_,_po_))
                 {var switch$1=0;
                  if(caml_string_notequal(_anK_,_pp_))
                   {if(caml_string_notequal(_anK_,_pq_))
                     {if(! caml_string_notequal(_anK_,_pr_) && match)
                       {var _an$_=match[2];
                        if(_an$_ && ! _an$_[2])
                         {var
                           e2=_an$_[1],
                           e1=match[1],
                           _aoa_=0,
                           _aob_=0,
                           _aoc_=[0,pcdata(_pt_),_aob_],
                           _aod_=0,
                           _aoe_=[0,caml_call1(span(_aod_),_aoc_),_aoa_],
                           _aof_=0,
                           _aog_=0,
                           _aoh_=spaced$0(_aog_,_aof_,_aoe_),
                           _aoi_=append(_aoh_,e2),
                           _aoj_=append(e1,_aoi_),
                           _aok_=_aoj_;
                          switch$1 = 1}}}
                    else
                     if(match)
                      {var _aol_=match[2];
                       if(_aol_ && ! _aol_[2])
                        {var
                          e2$0=_aol_[1],
                          e1$0=match[1],
                          _aom_=0,
                          _aon_=0,
                          _aoo_=[0,pcdata(_pu_),_aon_],
                          _aop_=0,
                          _aoq_=[0,caml_call1(span(_aop_),_aoo_),_aom_],
                          _aor_=0,
                          _aos_=0,
                          _aot_=spaced$0(_aos_,_aor_,_aoq_),
                          _aou_=append(_aot_,e2$0),
                          _aov_=append(e1$0,_aou_),
                          _aok_=_aov_;
                         switch$1 = 1}}}
                  else
                   if(! match)
                    {var
                      _aow_=0,
                      _aox_=0,
                      _aoy_=[0,pcdata(_pv_),_aox_],
                      _aoz_=0,
                      _aok_=[0,caml_call1(span(_aoz_),_aoy_),_aow_];
                     switch$1 = 1}
                  if(! switch$1)throw [0,Assert_failure,_ps_]}
                else
                 {id$0[1] = 0;
                  var
                   numeral=
                    function(acc,num,sub,e)
                     {var acc$0=acc,num$0=num,sub$0=sub,e$0=e;
                      for(;;)
                       {if(1 === e$0[0])
                         {var _aoQ_=e$0[1];
                          if(caml_string_notequal(_aoQ_,_px_))
                           {if(! caml_string_notequal(_aoQ_,_py_) && ! e$0[2])
                             {var
                               _aoR_=0,
                               _aoS_=0,
                               _aoT_=to_string(num$0),
                               _aoU_=[0,pcdata(_aoT_),_aoS_],
                               _aoV_=caml_call1(acc$0,_aoU_),
                               _aoW_=[0,thisid(sub$0)];
                              return [0,caml_call1(span(_aoW_),_aoV_),_aoR_]}}
                          else
                           {var _aoX_=e$0[2];
                            if(_aoX_ && ! _aoX_[2])
                             {var
                               e$1=_aoX_[1],
                               sub$1=[0,0,sub$0],
                               num$1=num$0 + 1 | 0,
                               acc$2=
                                function(sub,acc)
                                 {function acc$0(x)
                                   {var _aoY_=0,_aoZ_=caml_call1(acc,x),_ao0_=[0,thisid(sub)];
                                    return [0,caml_call1(span(_ao0_),_aoZ_),_aoY_]}
                                  return acc$0},
                               acc$1=acc$2(sub$0,acc$0),
                               acc$0=acc$1,
                               num$0=num$1,
                               sub$0=sub$1,
                               e$0=e$1;
                              continue}}}
                        var
                         _aoD_=0,
                         _aoE_=to_string(num$0),
                         _aoF_=[0,pcdata(_aoE_),_aoD_],
                         _aoG_=0,
                         _aoH_=0,
                         _aoI_=[0,pcdata(_pw_),_aoH_],
                         _aoJ_=0,
                         _aoK_=[0,caml_call1(span(_aoJ_),_aoI_),_aoG_],
                         _aoL_=append(_aoK_,_aoF_),
                         _aoM_=tl(sub$0),
                         _aoN_=[0,e$0,0],
                         _aoO_=xml(_aoN_,_aoM_),
                         _aoP_=hd(_aoO_);
                        return caml_call1(acc$0,append(_aoP_,_aoL_))}},
                   _aoA_=0,
                   _aoB_=function(_aoC_){return _aoC_},
                   _aok_=numeral(_aoB_,_aoA_,p,expr)}
                var _an__=_aok_}
              var data=_an__}
            var
             _anz_=0,
             _anA_=[0,is_pr],
             _anB_=pr$0(_anA_,data),
             _anC_=id$0[1]?thisid(p):0,
             _anD_=[0,_anC_];
            return [0,caml_call1(span(_anD_),_anB_),_anz_]}},
       for_form$1=
        function(id,opt,p)
         {if(opt)var sth=opt[1],is_pr=sth;else var is_pr=0;
          return function(form)
           {function for_form(_anp_,_anq_){return for_form$1(id,_anp_,_anq_)}
            function thisid(p)
             {function _anh_(prefix)
               {var _ano_=rev_map(to_string,p),p$0=join(_pz_,_ano_);
                return fold$3
                        (function(p,prefix)
                          {return caml_call2(sprintf$0(_pA_),prefix,p)},
                         p$0,
                         prefix)}
              function _ani_(_ann_){return map$3(_anh_,_ann_)}
              var _anj_=_ani_(id);
              function _ank_(x){return string_attrib(_pB_,x)}
              function _anl_(_anm_){return map$3(_ank_,_anm_)}
              return of_option(_anl_(_anj_))}
            if(typeof form === "number")
             if(0 === form)
              var
               _akM_=0,
               _akN_=0,
               _akO_=[0,entity(_pC_),_akN_],
               _akP_=0,
               data=[0,caml_call1(span(_akP_),_akO_),_akM_];
             else
              var
               _akU_=0,
               _akV_=0,
               _akW_=[0,entity(_pD_),_akV_],
               _akX_=0,
               data=[0,caml_call1(span(_akX_),_akW_),_akU_];
            else
             switch(form[0])
              {case 0:
                var _akY_=form[1],switch$0=0;
                if(caml_string_notequal(_akY_,_pE_))
                 switch$0 = 2;
                else
                 {var _als_=form[2];
                  if(_als_)
                   {var _alt_=_als_[2];
                    if(_alt_ && ! _alt_[2])
                     {var
                       e2=_alt_[1],
                       e1=_als_[1],
                       _alu_=0,
                       _alv_=[0,1,p],
                       _alw_=0,
                       _alx_=caml_call1(for_expr$0(id,_alw_,_alv_),e2),
                       _aly_=0,
                       _alz_=[0,caml_call1(span(_aly_),_alx_),_alu_],
                       _alA_=0,
                       _alB_=[0,entity(_pI_),_alA_],
                       _alC_=[0,pcdata(_pJ_),_alB_],
                       _alD_=[0,entity(_pK_),_alC_],
                       _alE_=0,
                       _alF_=[0,caml_call1(span(_alE_),_alD_),_alz_],
                       _alG_=[0,0,p],
                       _alH_=0,
                       _alI_=caml_call1(for_expr$0(id,_alH_,_alG_),e1),
                       _alJ_=0,
                       _alK_=[0,caml_call1(span(_alJ_),_alI_),_alF_],
                       _alm_=_alK_;
                      switch$0 = 1}}
                  else
                   switch$0 = 2}
                var switch$1=0;
                switch(switch$0)
                 {case 2:
                   if(form[2])
                    switch$1 = 1;
                   else
                    var
                     _aln_=0,
                     _alo_=0,
                     _alp_=of_latin1(_akY_),
                     _alq_=[0,pcdata(_alp_),_alo_],
                     _alr_=0,
                     _alm_=[0,caml_call1(span(_alr_),_alq_),_aln_];
                   break;
                  case 0:switch$1 = 1;break
                  }
                if(switch$1)
                 var
                  args=form[2],
                  _akZ_=
                   function(i,e){return caml_call1(for_expr$0(id,0,[0,i,p]),e)},
                  args$0=mapi(_akZ_,args),
                  _ak0_=0,
                  _ak1_=0,
                  _ak2_=0,
                  _ak3_=[0,entity(_pF_),_ak2_],
                  _ak4_=[0,pcdata(_pG_),_ak3_],
                  _ak5_=0,
                  _ak6_=[0,caml_call1(span(_ak5_),_ak4_),_ak1_],
                  _ak7_=caml_call1(join$2(_ak6_),args$0),
                  _ak8_=flatten$0(_ak7_),
                  _ak9_=0,
                  _ak__=[0,pr$0(_ak9_,_ak8_),_ak0_],
                  _ak$_=0,
                  _ala_=0,
                  _alb_=0,
                  _alc_=of_latin1(_akY_),
                  _ald_=[0,pcdata(_alc_),_alb_],
                  _ale_=0,
                  _alf_=[0,[0,caml_call1(span(_ale_),_ald_),_ala_],_ak$_],
                  aout=append(_alf_,_ak__),
                  _alg_=0,
                  _alh_=0,
                  _ali_=[0,entity(_pH_),_alh_],
                  _alj_=0,
                  _alk_=[0,caml_call1(span(_alj_),_ali_),_alg_],
                  _all_=caml_call1(join$2(_alk_),aout),
                  _alm_=flatten$0(_all_);
                var data=_alm_;
                break;
               case 1:
                var _alL_=form[1],switch$2=0;
                if(3903731 === _alL_)
                 {var _alM_=form[2];
                  if(_alM_)
                   {var _alN_=_alM_[1],switch$3=0;
                    if(typeof _alN_ !== "number" && 0 === _alN_[0])
                     if(caml_string_notequal(_alN_[1],_pO_))
                      switch$3 = 1;
                     else
                      {var _al7_=_alN_[2];
                       if(_al7_)
                        {var _al8_=_al7_[2];
                         if(_al8_ && ! (_al8_[2] || _alM_[2]))
                          {var
                            e2$0=_al8_[1],
                            e1$0=_al7_[1],
                            _al9_=0,
                            _al__=0,
                            _al$_=[0,1,[0,0,p]],
                            _ama_=0,
                            _amb_=caml_call1(for_expr$0(id,_ama_,_al$_),e2$0),
                            _amc_=0,
                            _amd_=[0,caml_call1(span(_amc_),_amb_),_al__],
                            _ame_=0,
                            _amf_=[0,entity(_pP_),_ame_],
                            _amg_=[0,entity(_pQ_),_amf_],
                            _amh_=[0,entity(_pR_),_amg_],
                            _ami_=0,
                            _amj_=[0,caml_call1(span(_ami_),_amh_),_amd_],
                            _amk_=[0,0,[0,0,p]],
                            _aml_=0,
                            _amm_=caml_call1(for_expr$0(id,_aml_,_amk_),e1$0),
                            _amn_=0,
                            _amo_=[0,caml_call1(span(_amn_),_amm_),_amj_],
                            _amp_=[0,0,p],
                            _amq_=[0,thisid(_amp_)],
                            _amr_=[0,caml_call1(span(_amq_),_amo_),_al9_],
                            _al0_=_amr_;
                           switch$2 = 1;
                           switch$3 = 1}
                         else
                          switch$3 = 1}
                       else
                        switch$3 = 1}}}
                if(! switch$2)
                 {var
                   fs=form[2],
                   _alO_=unicode_of_op(_alL_),
                   hexcode=caml_call1(sprintf(_pL_),_alO_),
                   _alP_=0,
                   _alQ_=0,
                   _alR_=[0,entity(hexcode),_alQ_],
                   _alS_=0,
                   xml_lg=[0,caml_call1(span(_alS_),_alR_),_alP_],
                   _alT_=assoc_of_op(_alL_),
                   _alU_=combine(fs,_alT_),
                   _alV_=
                    function(i,param)
                     {var
                       cmp=param[2],
                       f=param[1],
                       _ane_=[0,i,p],
                       _anf_=caml_call1(prio_of_op,_alL_),
                       _ang_=caml_call1(prio_of_form,f);
                      return caml_call1
                              (for_form([0,caml_call2(cmp,_ang_,_anf_)],_ane_),f)},
                   _alW_=function(_and_){return mapi(_alV_,_and_)},
                   xml_fs=_alW_(_alU_),
                   switch$4=0;
                  if(3903731 === _alL_)
                   {if(xml_fs && ! xml_fs[2])
                     {var
                       f=xml_fs[1],
                       _alX_=0,
                       _alY_=spaced$0(_pN_,_alX_,xml_lg),
                       _alZ_=append(_alY_,f);
                      switch$4 = 1}}
                  else
                   if(xml_fs)
                    {var _al1_=xml_fs[2];
                     if(_al1_ && ! _al1_[2])
                      {var
                        f2=_al1_[1],
                        f1=xml_fs[1],
                        _al2_=0,
                        _al3_=0,
                        _al4_=spaced$0(_al3_,_al2_,xml_lg),
                        _al5_=append(_al4_,f2),
                        _al6_=append(f1,_al5_),
                        _alZ_=_al6_;
                       switch$4 = 1}}
                  if(! switch$4)throw [0,Assert_failure,_pM_];
                  var _al0_=_alZ_}
                var data=_al0_;
                break;
               default:
                var f$0=form[4],ty=form[3],x=form[2],bd=form[1];
                if(840561112 <= bd)
                 var _ams_=8704,_amt_=chr$0(_ams_),bd$0=of_char$0(_amt_);
                else
                 var _anb_=8707,_anc_=chr$0(_anb_),bd$0=of_char$0(_anc_);
                var
                 _amu_=0,
                 _amv_=[0,0,p],
                 _amw_=0,
                 _amx_=[0,caml_call1(for_form(_amw_,_amv_),f$0),_amu_],
                 _amy_=0,
                 _amz_=0,
                 _amA_=0,
                 _amB_=[0,pcdata(_pS_),_amA_],
                 _amC_=0,
                 _amD_=[0,[0,caml_call1(span(_amC_),_amB_),_amz_],_amy_],
                 _amE_=append(_amD_,_amx_),
                 _amF_=0,
                 _amG_=0,
                 _amH_=0,
                 _amI_=for_type$1(_amH_,ty),
                 _amJ_=0,
                 _amK_=[0,[0,caml_call1(span(_amJ_),_amI_),_amG_],_amF_],
                 _amL_=append(_amK_,_amE_),
                 _amM_=0,
                 _amN_=0,
                 _amO_=0,
                 _amP_=[0,pcdata(_pT_),_amO_],
                 _amQ_=0,
                 _amR_=[0,[0,caml_call1(span(_amQ_),_amP_),_amN_],_amM_],
                 _amS_=append(_amR_,_amL_),
                 _amT_=0,
                 _amU_=0,
                 _amV_=0,
                 _amW_=of_latin1(x),
                 _amX_=[0,pcdata(_amW_),_amV_],
                 _amY_=0,
                 _amZ_=[0,[0,caml_call1(span(_amY_),_amX_),_amU_],_amT_],
                 _am0_=append(_amZ_,_amS_),
                 _am1_=0,
                 _am2_=0,
                 _am3_=0,
                 _am4_=[0,pcdata(bd$0),_am3_],
                 _am5_=0,
                 _am6_=[0,[0,caml_call1(span(_am5_),_am4_),_am2_],_am1_],
                 aout$0=append(_am6_,_am0_),
                 _am7_=0,
                 _am8_=0,
                 _am9_=[0,entity(_pU_),_am8_],
                 _am__=0,
                 _am$_=[0,caml_call1(span(_am__),_am9_),_am7_],
                 _ana_=caml_call1(join$2(_am$_),aout$0),
                 data=flatten$0(_ana_)}
            var
             _akQ_=0,
             _akR_=[0,is_pr],
             _akS_=pr$0(_akR_,data),
             _akT_=[0,thisid(p)];
            return [0,caml_call1(span(_akT_),_akS_),_akQ_]}},
       t_tohtml=
        function(ty)
         {var _akK_=0,_akL_=for_type$1(_akK_,ty);
          return caml_call1(span(0),_akL_)},
       e_tohtml=
        function(id,expr)
         {var
           _akH_=0,
           _akI_=0,
           _akJ_=caml_call1(for_expr$0(id,_akI_,_akH_),expr);
          return caml_call1(span(0),_akJ_)},
       f_tohtml=
        function(id,form)
         {var
           _akE_=0,
           _akF_=0,
           _akG_=caml_call1(for_form$1(id,_akF_,_akE_),form);
          return caml_call1(span(0),_akG_)},
       for_type$2=
        function(opt,ty)
         {if(opt)var sth=opt[1],is_pr=sth;else var is_pr=0;
          if(typeof ty === "number")
           var
            _aj3_=0,
            _aj4_=8226,
            _aj5_=of_int$0(_aj4_),
            _aj6_=of_char$0(_aj5_),
            data=[0,mo(_aj6_),_aj3_];
          else
           switch(ty[0])
            {case 0:
              var _aj$_=ty[1],_aka_=_aj$_[1];
              if(caml_string_notequal(_aka_,_pV_))
               {if(0 === _aj$_[2])
                 var _akb_=0,_akc_=of_latin1(_aka_),_akd_=[0,mi(_akc_),_akb_];
                else
                 var
                  i=_aj$_[2],
                  _akf_=of_latin1(_aka_),
                  x=caml_call2(sprintf(_pW_),_akf_,i),
                  _akg_=0,
                  _akh_=of_latin1(x),
                  _akd_=[0,mi(_akh_),_akg_];
                var _ake_=_akd_}
              else
               var _aki_=0,_ake_=[0,mo(_pX_),_aki_];
              var data=_ake_;
              break;
             case 3:
              var
               t=ty[2],
               x$0=ty[1],
               _akt_=0,
               _aku_=for_type$2(_akt_,t),
               _akv_=0,
               _akw_=of_latin1(_pZ_),
               _akx_=[0,mo(_akw_),_akv_],
               _aky_=of_latin1(x$0),
               _akz_=[0,mi(_aky_),_akx_],
               _akA_=956,
               _akB_=of_int$0(_akA_),
               _akC_=of_char$0(_akB_),
               _akD_=[0,mo(_akC_),_akz_],
               data=append(_akD_,_aku_);
              break;
             default:
              var
               t2=ty[2],
               t1=ty[1],
               _akj_=caml_call1(prio_of_type,ty),
               _akk_=[0,caml_call1(prio_of_type,t1) < _akj_?1:0],
               t1$0=for_type$2(_akk_,t1),
               _akl_=caml_call1(prio_of_type,ty),
               _akm_=[0,caml_call1(prio_of_type,t2) <= _akl_?1:0],
               t2$0=for_type$2(_akm_,t2),
               switch$0=0;
              if(typeof ty !== "number")
               switch(ty[0])
                {case 1:
                  var _akn_=215,tycon=of_int$0(_akn_);switch$0 = 1;break;
                 case 2:var _aks_=43,tycon=of_int$0(_aks_);switch$0 = 1;break
                 }
              if(! switch$0)throw [0,Assert_failure,_pY_];
              var
               _ako_=0,
               _akp_=of_char$0(tycon),
               _akq_=[0,mo(_akp_),_ako_],
               _akr_=append(_akq_,t2$0),
               data=append(t1$0,_akr_)}
          var
           _aj7_=0,
           _aj8_=0,
           _aj9_=caml_call1(row(_aj8_),data),
           _aj__=[0,is_pr];
          return [0,pr$1(_aj__,_aj9_),_aj7_]},
       for_expr$1=
        function(id,opt,p)
         {if(opt)var sth=opt[1],is_pr=sth;else var is_pr=0;
          return function(expr)
           {function for_expr(_aj1_,_aj2_){return for_expr$1(id,_aj1_,_aj2_)}
            if(0 === expr[0])
             {var _aiU_=expr[1],_aiV_=_aiU_[1];
              if(0 === _aiU_[2])
               var _aiW_=0,_aiX_=of_latin1(_aiV_),_aiY_=[0,mi(_aiX_),_aiW_];
              else
               var
                i=_aiU_[2],
                _ai7_=of_latin1(_aiV_),
                x=caml_call2(sprintf(_p3_),_ai7_,i),
                _ai8_=0,
                _ai9_=of_latin1(x),
                _aiY_=[0,mi(_ai9_),_ai8_];
              var data=_aiY_}
            else
             {var _ai__=expr[1],switch$0=0;
              if
               (caml_string_notequal(_ai__,_p4_)
                &&
                caml_string_notequal(_ai__,_p5_)
                &&
                caml_string_notequal(_ai__,_p6_)
                &&
                caml_string_notequal(_ai__,_p7_))
               {var
                 args=expr[2],
                 _ai$_=function(i,e){return caml_call1(for_expr(0,[0,i,p]),e)},
                 args$0=mapi(_ai$_,args),
                 _aja_=0,
                 _ajb_=0,
                 _ajc_=[0,mo(_p8_),_ajb_],
                 _ajd_=caml_call1(join$2(_ajc_),args$0),
                 _aje_=flatten$0(_ajd_),
                 _ajf_=0,
                 _ajg_=caml_call1(row(_ajf_),_aje_),
                 _ajh_=0,
                 _aji_=[0,pr$1(_ajh_,_ajg_),_aja_],
                 _ajj_=0,
                 _ajk_=of_latin1(_ai__),
                 _ajl_=[0,mi(_ajk_),_ajj_],
                 _ajm_=append(_ajl_,_aji_);
                switch$0 = 1}
              if(! switch$0)
               {var
                 es=expr[2],
                 xml=
                  function(es,p)
                   {var _ajU_=assoc_of_fun(_ai__),_ajV_=combine(es,_ajU_);
                    function _ajW_(i,param)
                     {var
                       cmp=param[2],
                       e=param[1],
                       _ajY_=[0,i,p],
                       _ajZ_=caml_call1(prio_of_fun,_ai__),
                       _aj0_=caml_call1(prio_of_expr,e);
                      return caml_call1
                              (for_expr([0,caml_call2(cmp,_aj0_,_ajZ_)],_ajY_),e)}
                    return function(_ajX_){return mapi(_ajW_,_ajX_)}(_ajV_)},
                 match=xml(es,p);
                if(caml_string_notequal(_ai__,_p9_))
                 {var switch$1=0;
                  if(caml_string_notequal(_ai__,_p__))
                   {if(caml_string_notequal(_ai__,_p$_))
                     {if(! caml_string_notequal(_ai__,_qa_) && match)
                       {var _ajn_=match[2];
                        if(_ajn_ && ! _ajn_[2])
                         {var
                           e2=_ajn_[1],
                           e1=match[1],
                           _ajo_=0,
                           _ajp_=[0,mo(_qc_),_ajo_],
                           _ajq_=append(_ajp_,e2),
                           _ajr_=append(e1,_ajq_),
                           _ajs_=_ajr_;
                          switch$1 = 1}}}
                    else
                     if(match)
                      {var _ajt_=match[2];
                       if(_ajt_ && ! _ajt_[2])
                        {var
                          e2$0=_ajt_[1],
                          e1$0=match[1],
                          _aju_=0,
                          _ajv_=[0,mo(_qd_),_aju_],
                          _ajw_=append(_ajv_,e2$0),
                          _ajx_=append(e1$0,_ajw_),
                          _ajs_=_ajx_;
                         switch$1 = 1}}}
                  else
                   if(! match)
                    {var _ajy_=0,_ajs_=[0,mn(_qe_),_ajy_];switch$1 = 1}
                  if(! switch$1)throw [0,Assert_failure,_qb_]}
                else
                 {var switch$2=0;
                  if(es && ! es[2])
                   {var
                     n=es[1],
                     numeral=
                      function(acc,e)
                       {var acc$0=acc,e$0=e;
                        for(;;)
                         {if(1 === e$0[0])
                           {var _ajQ_=e$0[1];
                            if(caml_string_notequal(_ajQ_,_qh_))
                             {if(! caml_string_notequal(_ajQ_,_qi_) && ! e$0[2])
                               {var _ajR_=0,_ajS_=to_string(acc$0);
                                return [0,mn(_ajS_),_ajR_]}}
                            else
                             {var _ajT_=e$0[2];
                              if(_ajT_ && ! _ajT_[2])
                               {var e$1=_ajT_[1],acc$1=acc$0 + 1 | 0,acc$0=acc$1,e$0=e$1;
                                continue}}}
                          var
                           _ajE_=0,
                           _ajF_=to_string(acc$0),
                           _ajG_=[0,mn(_ajF_),_ajE_],
                           _ajH_=0,
                           _ajI_=[0,mo(_qg_),_ajH_],
                           _ajJ_=append(_ajI_,_ajG_),
                           _ajK_=function(param){return 0},
                           _ajL_=acc$0 - 1 | 0,
                           _ajM_=init$0(_ajL_,_ajK_),
                           _ajN_=append(_ajM_,p),
                           _ajO_=[0,e$0,0],
                           _ajP_=xml(_ajO_,_ajN_);
                          return append(hd(_ajP_),_ajJ_)}},
                     _ajz_=1,
                     _ajs_=numeral(_ajz_,n);
                    switch$2 = 1}
                  if(! switch$2)throw [0,Assert_failure,_qf_]}
                var _ajm_=_ajs_}
              var data=_ajm_}
            function _aiZ_(prefix)
             {var _ajD_=rev_map(to_string,p),p$0=join(_p0_,_ajD_);
              return fold$3
                      (function(p,prefix)
                        {return caml_call2(sprintf$0(_p1_),prefix,p)},
                       p$0,
                       prefix)}
            function _ai0_(_ajC_){return map$3(_aiZ_,_ajC_)}
            var thisid=_ai0_(id);
            function _ai1_(_ajB_){return string_attrib(_p2_,_ajB_)}
            function _ai2_(_ajA_){return map$3(_ai1_,_ajA_)}
            var
             thisid$0=_ai2_(thisid),
             _ai3_=0,
             _ai4_=[0,of_option(thisid$0)],
             _ai5_=caml_call1(row(_ai4_),data),
             _ai6_=[0,is_pr];
            return [0,pr$1(_ai6_,_ai5_),_ai3_]}},
       for_form$2=
        function(id,opt,p)
         {if(opt)var sth=opt[1],is_pr=sth;else var is_pr=0;
          return function(form)
           {function for_form(_aiS_,_aiT_){return for_form$2(id,_aiS_,_aiT_)}
            function thisid(p)
             {function _aiK_(prefix)
               {var _aiR_=rev_map(to_string,p),p$0=join(_qj_,_aiR_);
                return fold$3
                        (function(p,prefix)
                          {return caml_call2(sprintf$0(_qk_),prefix,p)},
                         p$0,
                         prefix)}
              function _aiL_(_aiQ_){return map$3(_aiK_,_aiQ_)}
              var _aiM_=_aiL_(id);
              function _aiN_(x){return string_attrib(_ql_,x)}
              function _aiO_(_aiP_){return map$3(_aiN_,_aiP_)}
              return of_option(_aiO_(_aiM_))}
            if(typeof form === "number")
             if(0 === form)
              var
               _aha_=0,
               _ahb_=8868,
               _ahc_=of_int$0(_ahb_),
               _ahd_=of_char$0(_ahc_),
               data=[0,mo(_ahd_),_aha_];
             else
              var
               _ahi_=0,
               _ahj_=8869,
               _ahk_=of_int$0(_ahj_),
               _ahl_=of_char$0(_ahk_),
               data=[0,mo(_ahl_),_ahi_];
            else
             switch(form[0])
              {case 0:
                var _ahm_=form[1],switch$0=0;
                if(caml_string_notequal(_ahm_,_qm_))
                 switch$0 = 2;
                else
                 {var _ahD_=form[2];
                  if(_ahD_)
                   {var _ahE_=_ahD_[2];
                    if(_ahE_ && ! _ahE_[2])
                     {var
                       e2=_ahE_[1],
                       e1=_ahD_[1],
                       _ahF_=[0,1,p],
                       _ahG_=0,
                       _ahH_=caml_call1(for_expr$1(id,_ahG_,_ahF_),e2),
                       _ahI_=0,
                       _ahJ_=of_latin1(_qo_),
                       _ahK_=[0,mo(_ahJ_),_ahI_],
                       _ahL_=append(_ahK_,_ahH_),
                       _ahM_=[0,0,p],
                       _ahN_=0,
                       _ahO_=caml_call1(for_expr$1(id,_ahN_,_ahM_),e1),
                       _ahP_=append(_ahO_,_ahL_),
                       _ahA_=_ahP_;
                      switch$0 = 1}}
                  else
                   switch$0 = 2}
                var switch$1=0;
                switch(switch$0)
                 {case 2:
                   if(form[2])
                    switch$1 = 1;
                   else
                    var
                     _ahB_=0,
                     _ahC_=of_latin1(_ahm_),
                     _ahA_=[0,mi(_ahC_),_ahB_];
                   break;
                  case 0:switch$1 = 1;break
                  }
                if(switch$1)
                 var
                  args=form[2],
                  _ahn_=
                   function(i,e){return caml_call1(for_expr$1(id,0,[0,i,p]),e)},
                  args$0=mapi(_ahn_,args),
                  _aho_=0,
                  _ahp_=0,
                  _ahq_=[0,mo(_qn_),_ahp_],
                  _ahr_=caml_call1(join$2(_ahq_),args$0),
                  _ahs_=flatten$0(_ahr_),
                  _aht_=0,
                  _ahu_=caml_call1(row(_aht_),_ahs_),
                  _ahv_=0,
                  _ahw_=[0,pr$1(_ahv_,_ahu_),_aho_],
                  _ahx_=0,
                  _ahy_=of_latin1(_ahm_),
                  _ahz_=[0,mi(_ahy_),_ahx_],
                  _ahA_=append(_ahz_,_ahw_);
                var data=_ahA_;
                break;
               case 1:
                var _ahQ_=form[1],switch$2=0;
                if(3903731 === _ahQ_)
                 {var _ahR_=form[2];
                  if(_ahR_)
                   {var _ahS_=_ahR_[1],switch$3=0;
                    if(typeof _ahS_ !== "number" && 0 === _ahS_[0])
                     if(caml_string_notequal(_ahS_[1],_qq_))
                      switch$3 = 1;
                     else
                      {var _ah6_=_ahS_[2];
                       if(_ah6_)
                        {var _ah7_=_ah6_[2];
                         if(_ah7_ && ! (_ah7_[2] || _ahR_[2]))
                          {var
                            e2$0=_ah7_[1],
                            e1$0=_ah6_[1],
                            _ah8_=0,
                            _ah9_=[0,1,[0,0,p]],
                            _ah__=0,
                            _ah$_=caml_call1(for_expr$1(id,_ah__,_ah9_),e2$0),
                            _aia_=0,
                            _aib_=8800,
                            _aic_=of_int$0(_aib_),
                            _aid_=of_char$0(_aic_),
                            _aie_=[0,mo(_aid_),_aia_],
                            _aif_=append(_aie_,_ah$_),
                            _aig_=[0,0,[0,0,p]],
                            _aih_=0,
                            _aii_=caml_call1(for_expr$1(id,_aih_,_aig_),e1$0),
                            _aij_=append(_aii_,_aif_),
                            _aik_=[0,0,p],
                            _ail_=[0,thisid(_aik_)],
                            _aim_=[0,caml_call1(row(_ail_),_aij_),_ah8_],
                            _ah2_=_aim_;
                           switch$2 = 1;
                           switch$3 = 1}
                         else
                          switch$3 = 1}
                       else
                        switch$3 = 1}}}
                if(! switch$2)
                 {var
                   fs=form[2],
                   _ahT_=0,
                   _ahU_=unicode_of_op(_ahQ_),
                   _ahV_=of_int$0(_ahU_),
                   _ahW_=of_char$0(_ahV_),
                   xml_lg=[0,mo(_ahW_),_ahT_],
                   _ahX_=assoc_of_op(_ahQ_),
                   _ahY_=combine(fs,_ahX_),
                   _ahZ_=
                    function(i,param)
                     {var
                       cmp=param[2],
                       f=param[1],
                       _aiH_=[0,i,p],
                       _aiI_=caml_call1(prio_of_op,_ahQ_),
                       _aiJ_=caml_call1(prio_of_form,f);
                      return caml_call1
                              (for_form([0,caml_call2(cmp,_aiJ_,_aiI_)],_aiH_),f)},
                   _ah0_=function(_aiG_){return mapi(_ahZ_,_aiG_)},
                   xml_fs=_ah0_(_ahY_),
                   switch$4=0;
                  if(3903731 === _ahQ_)
                   {if(xml_fs && ! xml_fs[2])
                     {var f=xml_fs[1],_ah1_=append(xml_lg,f);switch$4 = 1}}
                  else
                   if(xml_fs)
                    {var _ah3_=xml_fs[2];
                     if(_ah3_ && ! _ah3_[2])
                      {var
                        f2=_ah3_[1],
                        f1=xml_fs[1],
                        _ah4_=append(xml_lg,f2),
                        _ah5_=append(f1,_ah4_),
                        _ah1_=_ah5_;
                       switch$4 = 1}}
                  if(! switch$4)throw [0,Assert_failure,_qp_];
                  var _ah2_=_ah1_}
                var data=_ah2_;
                break;
               default:
                var f$0=form[4],ty=form[3],x=form[2],bd=form[1];
                if(840561112 <= bd)
                 var _ain_=8704,_aio_=chr$0(_ain_),bd$0=of_char$0(_aio_);
                else
                 var _aiE_=8707,_aiF_=chr$0(_aiE_),bd$0=of_char$0(_aiF_);
                var
                 _aip_=[0,0,p],
                 _aiq_=0,
                 _air_=caml_call1(for_form(_aiq_,_aip_),f$0),
                 _ais_=0,
                 _ait_=of_latin1(_qr_),
                 _aiu_=[0,mo(_ait_),_ais_],
                 _aiv_=append(_aiu_,_air_),
                 _aiw_=0,
                 _aix_=for_type$2(_aiw_,ty),
                 _aiy_=append(_aix_,_aiv_),
                 _aiz_=0,
                 _aiA_=[0,mo(_qs_),_aiz_],
                 _aiB_=of_latin1(x),
                 _aiC_=[0,mi(_aiB_),_aiA_],
                 _aiD_=[0,mo(bd$0),_aiC_],
                 data=append(_aiD_,_aiy_)}
            var
             _ahe_=0,
             _ahf_=[0,thisid(p)],
             _ahg_=caml_call1(row(_ahf_),data),
             _ahh_=[0,is_pr];
            return [0,pr$1(_ahh_,_ahg_),_ahe_]}},
       t_tomathml=
        function(ty)
         {var _ag__=0,_ag$_=for_type$2(_ag__,ty);
          return caml_call1(row(0),_ag$_)},
       e_tomathml=
        function(id,expr)
         {var
           _ag7_=0,
           _ag8_=0,
           _ag9_=caml_call1(for_expr$1(id,_ag8_,_ag7_),expr);
          return caml_call1(row(0),_ag9_)},
       f_tomathml=
        function(id,form)
         {var
           _ag4_=0,
           _ag5_=0,
           _ag6_=caml_call1(for_form$2(id,_ag5_,_ag4_),form);
          return caml_call1(row(0),_ag6_)},
       name_counters=[0,empty$1],
       fresh$0=
        function(env,opt,param)
         {if(opt)var sth=opt[1],basename=sth;else var basename=_qt_;
          var _agW_=env[3];
          if(mem$1(basename,_agW_))
           {try
             {var _agZ_=name_counters[1],_ag0_=find$2(env,_agZ_),n$0=_ag0_}
            catch(_ag3_)
             {_ag3_ = caml_wrap_exception(_ag3_);
              if(_ag3_ !== Not_found)throw _ag3_;
              var n=[0,0],_agX_=name_counters[1];
              name_counters[1] = add$6(env,n,_agX_);
              var n$0=n}
            var
             aux=
              function(n)
               {var n$0=n;
                for(;;)
                 {var
                   _ag1_=to_string(n$0),
                   basename$0=cat(basename,_ag1_),
                   _ag2_=env[3];
                  if(mem$1(basename$0,_ag2_))
                   {var n$1=n$0 + 1 | 0,n$0=n$1;continue}
                  return [0,basename$0,n$0]}},
             _agY_=n$0[1],
             match=aux(_agY_),
             n$1=match[2],
             basename$0=match[1];
            n$0[1] = n$1;
            return basename$0}
          return basename},
       push$4=
        function(env,param)
         {var
           match=param[2],
           body=match[2],
           ty=match[1],
           name=param[1],
           i=[0,0],
           _agP_=env[3];
          function _agQ_(bds)
           {var _agV_=0,v=[0,[0,ty,body],default$0(_agV_,bds)];
            i[1] = length(v) - 1 | 0;
            return [0,v]}
          var
           env_var=modify_opt$0(name,_agQ_,_agP_),
           _agR_=env[6],
           _agS_=0,
           _agT_=fresh(_agS_),
           _agU_=[0,name,i[1]],
           env_handles=add$8(_agU_,_agT_,_agR_);
          return [0,env[1],env[2],env_var,env[4],env[5],env_handles]},
       get$9=
        function(env,param)
         {var
           idx=param[2],
           name=param[1],
           _agN_=env[3],
           _agO_=0,
           bds=find_default$0(_agO_,name,_agN_);
          return nth_opt(bds,idx)},
       modify$1=
        function(env,param)
         {var b=param[2],match=param[1],i=match[2],x=match[1],_agJ_=env[3];
          function _agK_(param){return b}
          function _agL_(_agM_){return modify_at(i,_agK_,_agM_)}
          var env_var=modify$0(x,_agL_,_agJ_);
          return [0,env[1],env[2],env_var,env[4],env[5],env[6]]},
       exists$4=function(env,x){return is_some(get$9(env,x))},
       getid=function(env,x){return find_opt$1(x,env[6])},
       byid=
        function(env,id)
         {function _agD_(x)
           {function _agI_(body){return return$3([0,x,body])}
            return bind$0(get$9(env,x),_agI_)}
          var _agE_=env[6],_agF_=inverse(_agE_);
          function _agG_(_agH_){return find_opt$1(id,_agH_)}
          return bind$0(_agG_(_agF_),_agD_)},
       map$6=
        function(init,f)
         {var _agu_=init[6],_agv_=init[5],_agw_=init[4],_agx_=init[3];
          function _agy_(_agC_){return snd_map(f,_agC_)}
          function _agz_(_agB_){return map$4(_agy_,_agB_)}
          var _agA_=map$5(_agz_,_agx_);
          return [0,init[1],init[2],_agA_,_agw_,_agv_,_agu_]},
       to_list$0=
        function(env)
         {function _agp_(param)
           {var bs=param[2],x=param[1];
            return mapi
                    (function(i,b)
                      {var _agr_=[0,x,i],_ags_=[0,x,i],_agt_=getid(env,_ags_);
                       return [0,get$3(_agt_),_agr_,b]},
                     bs)}
          var _agq_=env[3];
          return bind(bindings(_agq_),_agp_)},
       evar_name_counter=[0,-1],
       fresh$1=
        function(opt,param)
         {if(opt)var sth=opt[1],basename=sth;else var basename=_qv_;
          evar_name_counter[1]++;
          var _agn_=evar_name_counter[1],_ago_=to_string(_agn_);
          return cat(_qu_,cat(basename,_ago_))},
       RecheckFailure=[248,_qw_,caml_fresh_oo_id(0)],
       TypingError=[248,_qx_,caml_fresh_oo_id(0)],
       empty$9=0,
       push$5=function(bds,x,y){return [0,[0,x,y],bds]},
       lindex=
        function(bds,x)
         {function aux(i,param)
           {var i$0=i,param$0=param;
            for(;;)
             {if(param$0)
               {var
                 bds=param$0[2],
                 match=param$0[1],
                 y=match[1],
                 _agm_=caml_string_equal(x,y)?1:0,
                 i$1=i$0 + _agm_ | 0,
                 i$0=i$1,
                 param$0=bds;
                continue}
              return i$0}}
          return aux(0,bds)},
       rindex=
        function(bds,x)
         {function aux(i,param)
           {var i$0=i,param$0=param;
            for(;;)
             {if(param$0)
               {var
                 bds=param$0[2],
                 match=param$0[1],
                 y=match[2],
                 _agl_=caml_string_equal(x,y)?1:0,
                 i$1=i$0 + _agl_ | 0,
                 i$0=i$1,
                 param$0=bds;
                continue}
              return i$0}}
          return aux(0,bds)},
       lfind=
        function(bds,param)
         {var i=param[2],x=param[1];
          function aux(j,param)
           {var j$0=j,param$0=param;
            for(;;)
             {if(param$0)
               {var match=param$0[1],y=match[1],z=match[2];
                if(caml_string_equal(x,y) && 0 === j$0)return z;
                var bds=param$0[2];
                if(caml_string_equal(x,y) && 0 < j$0)
                 {var j$1=j$0 - 1 | 0,j$0=j$1,param$0=bds;continue}
                var param$1=param$0[2],param$0=param$1;
                continue}
              throw Not_found}}
          return aux(i,bds)},
       equal$9=
        function(bds,param,_agb_)
         {var
           j=_agb_[2],
           m=_agb_[1],
           i=param[2],
           n=param[1],
           _agc_=caml_string_equal(n,m);
          if(_agc_)
           var
            _agd_=j - rindex(bds,m) | 0,
            _age_=(i - lindex(bds,n) | 0) === _agd_?1:0;
          else
           var _age_=_agc_;
          if(_age_)
           var _agf_=_age_;
          else
           {var _agg_=i === j?1:0;
            if(_agg_)
             try
              {var
                _agh_=[0,n,i],
                _agi_=lfind(bds,_agh_),
                _agj_=caml_string_equal(_agi_,m);
               return _agj_}
             catch(_agk_)
              {_agk_ = caml_wrap_exception(_agk_);
               if(_agk_ === Not_found)return 0;
               throw _agk_}
            var _agf_=_agg_}
          return _agf_},
       f_and=function(f1,f2){return [1,3257015,[0,f1,[0,f2,0]]]},
       f_imp=function(f1,f2){return [1,3654636,[0,f1,[0,f2,0]]]},
       f_false=1,
       f_true=0,
       f_ands=
        function(fs)
         {if(fs)
           {var _aga_=fs[1];
            if(fs[2]){var fs$0=fs[2];return fold(f_and,_aga_,fs$0)}
            return _aga_}
          return f_true},
       doit=
        function(acc,f)
         {var acc$0=acc,f$0=f;
          for(;;)
           {if(typeof f$0 !== "number" && 1 === f$0[0] && 17731 === f$0[1])
             {var _af__=f$0[2];
              if(_af__)
               {var _af$_=_af__[2];
                if(_af$_ && ! _af$_[2])
                 {var
                   f2=_af$_[1],
                   f$1=_af__[1],
                   acc$1=[0,f2,acc$0],
                   acc$0=acc$1,
                   f$0=f$1;
                  continue}}}
            return [0,f$0,acc$0]}},
       flatten_disjunctions=function(f){return doit(0,f)},
       doit$0=
        function(acc,f)
         {var acc$0=acc,f$0=f;
          for(;;)
           {if(typeof f$0 !== "number" && 1 === f$0[0] && 3257015 === f$0[1])
             {var _af8_=f$0[2];
              if(_af8_)
               {var _af9_=_af8_[2];
                if(_af9_ && ! _af9_[2])
                 {var
                   f2=_af9_[1],
                   f$1=_af8_[1],
                   acc$1=[0,f2,acc$0],
                   acc$0=acc$1,
                   f$0=f$1;
                  continue}}}
            return [0,f$0,acc$0]}},
       flatten_conjunctions=function(f){return doit$0(0,f)},
       parity=
        function(lg)
         {return 3257015 === lg
                  ?2
                  :3903731 <= lg?95438486 <= lg?2:1:3654636 <= lg?2:2},
       eq_alias=
        function(counter,bds,env,a,ty)
         {var ty$0=ty;
          for(;;)
           {var tgt_a=get$8(env,a),switch$0=0;
            if(typeof ty$0 !== "number" && 0 === ty$0[0])
             {var
               b$2=ty$0[1],
               _af6_=get$8(env,b$2),
               _af7_=[0,b$2],
               tgt_b$0=_af6_,
               b$0=_af7_;
              switch$0 = 1}
            if(! switch$0)var tgt_b=0,b=0,tgt_b$0=tgt_b,b$0=b;
            var _af3_=[0,tgt_a,tgt_b$0],_af4_=pair_map(concat$1,_af3_);
            if(b$0)
             {if(! _af4_[1] && ! _af4_[2])
               {var b$1=b$0[1];return equal$9(bds,a,b$1)}}
            else
             if(! _af4_[1])return 0;
            var _af5_=_af4_[1];
            if(_af5_)
             {var ty$1=_af5_[1];
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return eq$1(counter$0,bds,env,ty$0,ty$1)}
              return caml_trampoline_return(eq$1,[0,bds,env,ty$0,ty$1])}
            var match=_af4_[2],ty$2=match[1],ty$0=ty$2;
            continue}},
       eq$1=
        function(counter,bds,env,ty1,ty2)
         {var bds$0=bds,ty1$0=ty1,ty2$0=ty2;
          for(;;)
           {var switch$0=0;
            if(typeof ty1$0 === "number")
             {if(typeof ty2$0 === "number")
               return 1;
              else
               if(0 !== ty2$0[0])switch$0 = 1}
            else
             switch(ty1$0[0])
              {case 0:var _afR_=ty1$0[1],ty=ty2$0,a=_afR_;switch$0 = 2;break;
               case 1:
                var switch$1=0,_afS_=ty1$0[2],_afT_=ty1$0[1];
                if(typeof ty2$0 !== "number")
                 switch(ty2$0[0])
                  {case 0:switch$1 = 1;break;
                   case 1:
                    var
                     _afU_=ty2$0[2],
                     _afV_=ty2$0[1],
                     tyb2=_afU_,
                     tya2=_afV_,
                     tyb1=_afS_,
                     tya1=_afT_;
                    switch$0 = 3;
                    switch$1 = 1;
                    break
                   }
                if(! switch$1)switch$0 = 1;
                break;
               case 2:
                var switch$2=0,_afX_=ty1$0[2],_afY_=ty1$0[1];
                if(typeof ty2$0 !== "number")
                 switch(ty2$0[0])
                  {case 0:switch$2 = 1;break;
                   case 2:
                    var
                     _afZ_=ty2$0[2],
                     _af0_=ty2$0[1],
                     tyb2=_afZ_,
                     tya2=_af0_,
                     tyb1=_afX_,
                     tya1=_afY_;
                    switch$0 = 3;
                    switch$2 = 1;
                    break
                   }
                if(! switch$2)switch$0 = 1;
                break;
               default:
                var switch$3=0,_af1_=ty1$0[2],_af2_=ty1$0[1];
                if(typeof ty2$0 === "number")
                 switch$3 = 1;
                else
                 switch(ty2$0[0])
                  {case 0:break;
                   case 3:
                    var
                     ty2$1=ty2$0[2],
                     a2=ty2$0[1],
                     bds$1=push$5(bds$0,_af2_,a2),
                     bds$0=bds$1,
                     ty1$0=_af1_,
                     ty2$0=ty2$1;
                    continue;
                   default:switch$3 = 1}
                if(switch$3)switch$0 = 1}
            switch(switch$0)
             {case 0:var _afQ_=ty2$0[1],ty=ty1$0,a=_afQ_;break;
              case 1:return 0;
              case 2:break;
              default:
               var _afW_=eq(bds$0,env,tya1,tya2);
               if(_afW_){var ty1$0=tyb1,ty2$0=tyb2;continue}
               return _afW_}
            if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return eq_alias(counter$0,bds$0,env,a,ty)}
            return caml_trampoline_return(eq_alias,[0,bds$0,env,a,ty])}},
       eq=
        function(bds,env,ty1,ty2)
         {return caml_trampoline(eq$1(0,bds,env,ty1,ty2))},
       t_equal=
        function(opt,env,ty1,ty2)
         {if(opt)var sth=opt[1],bds=sth;else var bds=empty$9;
          return eq(bds,env,ty1,ty2)},
       aux=
        function(bds,env,e1,e2)
         {var e1$0=e1,e2$0=e2;
          for(;;)
           {if(0 === e1$0[0])
             {var _afH_=e1$0[1];
              if(0 === e2$0[0])
               {var x2=e2$0[1];if(equal$9(bds,_afH_,x2))return 1}
              var t=e2$0,x1=_afH_}
            else
             {var _afJ_=e1$0[2],_afK_=e1$0[1];
              if(0 !== e2$0[0])
               {var es2=e2$0[2],f2=e2$0[1],_afM_=length(es2);
                if(length(_afJ_) === _afM_)
                 {var _afN_=caml_string_equal(_afK_,f2);
                  return _afN_
                          ?for_all2
                            (function(_afO_,_afP_){return aux(bds,env,_afO_,_afP_)},
                             _afJ_,
                             es2)
                          :_afN_}
                return 0}
              var _afL_=e2$0[1],t=e1$0,x1=_afL_}
            var match=get$9(env,x1);
            if(match)
             {var _afI_=match[1][2];
              if(_afI_){var e2$1=_afI_[1],e1$0=t,e2$0=e2$1;continue}}
            return 0}},
       e_equal=
        function(opt,env,e1,e2)
         {if(opt)var sth=opt[1],bds=sth;else var bds=empty$9;
          return aux(bds,env,e1,e2)},
       aux$0=
        function(bds,env,f1,f2)
         {var bds$0=bds,f1$0=f1,f2$0=f2;
          for(;;)
           {var switch$0=0;
            if(typeof f1$0 === "number")
             {if(0 === f1$0)
               {if(typeof f2$0 === "number" && ! f2$0)switch$0 = 1}
              else
               if(typeof f2$0 === "number" && f2$0)switch$0 = 1}
            else
             switch(f1$0[0])
              {case 0:
                if(typeof f2$0 !== "number" && 0 === f2$0[0])
                 {var
                   es2=f2$0[2],
                   p2=f2$0[1],
                   es1=f1$0[2],
                   p1=f1$0[1],
                   _afw_=length(es2);
                  if(length(es1) === _afw_)
                   {var _afx_=caml_string_equal(p1,p2);
                    if(_afx_)
                     {var _afy_=[0,bds$0];
                      return for_all2
                              (function(_afF_,_afG_)
                                {return e_equal(_afy_,env,_afF_,_afG_)},
                               es1,
                               es2)}
                    return _afx_}}
                break;
               case 1:
                if(typeof f2$0 !== "number" && 1 === f2$0[0])
                 {var
                   fs2=f2$0[2],
                   c2=f2$0[1],
                   fs1=f1$0[2],
                   c1=f1$0[1],
                   _afz_=length(fs2);
                  if(length(fs1) === _afz_)
                   {var _afA_=c1 === c2?1:0;
                    return _afA_
                            ?for_all2
                              (function(_afD_,_afE_){return aux$0(bds$0,env,_afD_,_afE_)},
                               fs1,
                               fs2)
                            :_afA_}}
                break;
               default:
                if(typeof f2$0 !== "number" && 2 === f2$0[0])
                 {var
                   f2$1=f2$0[4],
                   ty2=f2$0[3],
                   x2=f2$0[2],
                   b2=f2$0[1],
                   f1$1=f1$0[4],
                   ty1=f1$0[3],
                   x1=f1$0[2],
                   b1=f1$0[1];
                  if(b1 === b2)
                   {var _afB_=0,_afC_=t_equal(_afB_,env,ty1,ty2);
                    if(_afC_)
                     {var
                       bds$1=push$5(bds$0,x1,x2),
                       bds$0=bds$1,
                       f1$0=f1$1,
                       f2$0=f2$1;
                      continue}
                    return _afC_}}}
            return switch$0?1:0}},
       f_equal=
        function(opt,f1,f2)
         {if(opt)var sth=opt[1],bds=sth;else var bds=empty$9;
          return function(_afv_){return aux$0(bds,f1,f2,_afv_)}},
       equal$10=
        function(bds,env,t1,t2)
         {if(70 <= t1[1])
           {if(typeof t2 !== "number" && 70 === t2[1])
             {var f2=t2[2],f1=t1[2];return caml_call1(f_equal(bds,env,f1),f2)}}
          else
           if(typeof t2 !== "number" && 69 === t2[1])
            {var e2=t2[2],e1=t1[2];return e_equal(bds,env,e1,e2)}
          return 0},
       e_shift=
        function(opt,param,e)
         {var i=param[2],x=param[1];
          if(opt)var sth=opt[1],incr=sth;else var incr=1;
          if(0 === e[0])
           {var match=e[1],j=match[2],y=match[1];
            if(caml_string_equal(x,y) && i <= j)return [0,[0,y,j + incr | 0]];
            return e}
          var es=e[2],f=e[1],_afr_=[0,x,i],_afs_=[0,incr];
          function _aft_(_afu_){return e_shift(_afs_,_afr_,_afu_)}
          return [1,f,map$4(_aft_,es)]},
       f_shift=
        function(opt,param,f)
         {var i=param[2],x=param[1];
          if(opt)var sth=opt[1],incr=sth;else var incr=1;
          if(typeof f === "number")
           return f;
          else
           switch(f[0])
            {case 0:
              var
               es=f[2],
               p=f[1],
               _afg_=[0,x,i],
               _afh_=[0,incr],
               _afi_=function(_afq_){return e_shift(_afh_,_afg_,_afq_)};
              return [0,p,map$4(_afi_,es)];
             case 1:
              var
               fs=f[2],
               c=f[1],
               _afj_=[0,x,i],
               _afk_=[0,incr],
               _afl_=function(_afp_){return f_shift(_afk_,_afj_,_afp_)};
              return [1,c,map$4(_afl_,fs)];
             default:
              var
               f$0=f[4],
               ty=f[3],
               y=f[2],
               b=f[1],
               _afm_=caml_string_equal(x,y)?1:0,
               _afn_=[0,x,i + _afm_ | 0],
               _afo_=[0,incr];
              return [2,b,y,ty,f_shift(_afo_,_afn_,f$0)]}},
       shift=
        function(incr,x,param)
         {if(70 <= param[1]){var f=param[2];return [0,70,f_shift(incr,x,f)]}
          var e=param[2];
          return [0,69,e_shift(incr,x,e)]},
       shift_under=
        function(t,u)
         {if(typeof t !== "number" && 70 === t[1])
           {var _aff_=t[2];
            if(typeof _aff_ !== "number" && 2 === _aff_[0])
             {var x=_aff_[2];return shift(0,[0,x,0],u)}}
          return u},
       direct_subforms=
        function(param)
         {if(typeof param !== "number")
           switch(param[0])
            {case 1:var fs=param[2];return fs;
             case 2:var f=param[4];return [0,f,0]
             }
          return 0},
       direct_subexprs=
        function(param){if(0 === param[0])return 0;var es=param[2];return es},
       direct_subterms=
        function(param)
         {if(70 <= param[1])
           {var _afe_=param[2];
            if(typeof _afe_ !== "number" && 0 === _afe_[0])
             {var es=_afe_[2];return map$4(term_of_expr,es)}
            return map$4(term_of_form,direct_subforms(_afe_))}
          var e=param[2];
          return map$4(term_of_expr,direct_subexprs(e))},
       modify_direct_subforms=
        function(f,fs)
         {var switch$0=0;
          if(typeof f === "number")
           switch$0 = 1;
          else
           switch(f[0])
            {case 1:
              var fs$0=f[2],c=f[1],_afd_=length(fs);
              if(length(fs$0) === _afd_)return [1,c,fs];
              break;
             case 2:
              if(fs && ! fs[2])
               {var f$0=fs[1],ty=f[3],x=f[2],b=f[1];return [2,b,x,ty,f$0]}
              break;
             default:switch$0 = 1}
          if(switch$0)return f;
          throw [0,Invalid_argument,_qy_]},
       modify_direct_subexprs=
        function(e,es)
         {if(0 === e[0])return e;
          var es$0=e[2],f=e[1],_afc_=length(es);
          if(length(es$0) === _afc_)return [1,f,es];
          throw [0,Invalid_argument,_qz_]},
       modify_direct_subterms=
        function(t,ts)
         {if(70 <= t[1])
           {var _ae2_=t[2];
            if(typeof _ae2_ !== "number" && 0 === _ae2_[0])
             {var es=_ae2_[2],p=_ae2_[1],_ae6_=length(ts);
              if(length(es) === _ae6_)
               return [0,70,[0,p,map$4(expr_of_term,ts)]]}
            var
             _ae3_=function(_afb_){return map$4(form_of_term,_afb_)},
             _ae4_=_ae3_(ts),
             _ae5_=function(_afa_){return modify_direct_subforms(_ae2_,_afa_)};
            return term_of_form(_ae5_(_ae4_))}
          var e=t[2];
          function _ae7_(_ae$_){return map$4(expr_of_term,_ae$_)}
          var _ae8_=_ae7_(ts);
          function _ae9_(_ae__){return modify_direct_subexprs(e,_ae__)}
          return term_of_expr(_ae9_(_ae8_))},
       rewrite=
        function(bds,env,red,res,t)
         {if(equal$10(bds,env,red,t))return res;
          var
           _aeS_=direct_subterms(t),
           _aeT_=shift_under(t,res),
           _aeU_=shift_under(t,red),
           _aeV_=0;
          function _aeW_(_ae1_){return rewrite(_aeV_,env,_aeU_,_aeT_,_ae1_)}
          function _aeX_(_ae0_){return map$4(_aeW_,_ae0_)}
          var _aeY_=_aeX_(_aeS_);
          return function(_aeZ_){return modify_direct_subterms(t,_aeZ_)}
                  (_aeY_)},
       fc_is_bound=
        function(param,_aeN_)
         {var param$0=param,_aeO_=_aeN_;
          for(;;)
           {var _aeP_=param$0[2],_aeQ_=param$0[1];
            if(_aeO_)
             {var _aeR_=_aeO_[1];
              if(0 === _aeR_[0])
               {var
                 c=_aeO_[2],
                 param$1=[0,_aeQ_,_aeP_],
                 param$0=param$1,
                 _aeO_=c;
                continue}
              var c$0=_aeO_[2],y=_aeR_[2];
              if(caml_string_equal(_aeQ_,y))
               {if(0 === _aeP_)return 1;
                var param$2=[0,_aeQ_,_aeP_ - 1 | 0],param$0=param$2,_aeO_=c$0;
                continue}
              var param$3=[0,_aeQ_,_aeP_],param$0=param$3,_aeO_=c$0;
              continue}
            return 0}},
       fc_exit=
        function(param)
         {var i=param[2],x=param[1];
          function aux(i,param)
           {var i$0=i,param$0=param;
            for(;;)
             {if(param$0)
               {var _aeM_=param$0[1];
                if(1 === _aeM_[0])
                 {var c=param$0[2],y=_aeM_[2];
                  if(caml_string_equal(x,y))
                   {var i$1=i$0 - 1 | 0,i$0=i$1,param$0=c;continue}}
                var param$1=param$0[2],param$0=param$1;
                continue}
              return i$0}}
          return function(c){return [0,x,aux(i,c)]}},
       fc_fill=
        function(f,param)
         {if(param)
           {var _aeI_=param[1];
            if(0 === _aeI_[0])
             {var
               c=param[2],
               i=_aeI_[3],
               fs=_aeI_[2],
               conn=_aeI_[1],
               match=split_nth(i,fs),
               rs=match[2],
               ls=match[1],
               _aeJ_=0,
               _aeK_=[0,fc_fill(f,c),_aeJ_],
               _aeL_=append(_aeK_,rs);
              return [1,conn,append(ls,_aeL_)]}
            var c$0=param[2],ty=_aeI_[3],x=_aeI_[2],b=_aeI_[1];
            return [2,b,x,ty,fc_fill(f,c$0)]}
          return f},
       e_unloc=
        function(e)
         {var match=unloc(e);
          if(0 === match[0])
           {var i=match[2],x=match[1];return [0,[0,unloc(x),i]]}
          var args=match[2],f=match[1],_aeH_=map$4(e_unloc,args);
          return [1,unloc(f),_aeH_]},
       trecheck=
        function(env,ty)
         {var env$0=env,ty$0=ty;
          for(;;)
           if(typeof ty$0 === "number")
            return 0;
           else
            switch(ty$0[0])
             {case 0:
               var x=ty$0[1],_aeD_=1 - exists$3(env$0,x);
               if(_aeD_)throw RecheckFailure;
               return _aeD_;
              case 3:
               var
                ty$1=ty$0[2],
                x$0=ty$0[1],
                _aeF_=[0,x$0,0],
                env$1=push$3(env$0,_aeF_),
                env$0=env$1,
                ty$0=ty$1;
               continue;
              default:
               var ty2=ty$0[2],ty1=ty$0[1],_aeE_=[0,ty1,[0,ty2,0]];
               return iter$0
                       (function(_aeG_){return trecheck(env$0,_aeG_)},_aeE_)}},
       einfer=
        function(env,e)
         {if(0 === e[0])
           {var x=e[1],match=get$9(env,x);
            if(match){var match$0=match[1],xty=match$0[1];return xty}
            throw TypingError}
          var args=e[2],f=e[1],match$1=get$7(env,f);
          if(match$1)
           {var
             match$2=match$1[1],
             fres=match$2[2],
             fargs=match$2[1],
             _aew_=length(args);
            if(length(fargs) !== _aew_)throw TypingError;
            var
             _aex_=function(_aeC_){return einfer(env,_aeC_)},
             args$0=map$4(_aex_,args),
             _aey_=0,
             _aez_=
              function(_aeA_,_aeB_){return t_equal(_aey_,env,_aeA_,_aeB_)};
            if(1 - for_all2(_aez_,fargs,args$0))throw TypingError;
            return fres}
          throw TypingError},
       erecheck=
        function(env,ty,expr)
         {if(0 === expr[0])
           {var
             x=expr[1],
             _aeo_=get$9(env,x),
             match=get_exn(_aeo_,RecheckFailure),
             xty=match[1],
             _aep_=0,
             _aeq_=1 - t_equal(_aep_,env,ty,xty);
            if(_aeq_)throw RecheckFailure;
            return _aeq_}
          var
           args=expr[2],
           f=expr[1],
           _aer_=get$7(env,f),
           match$0=get_exn(_aer_,RecheckFailure),
           res=match$0[2],
           sig=match$0[1],
           _aes_=0;
          if(1 - t_equal(_aes_,env,ty,res))throw RecheckFailure;
          var _aet_=length(args);
          if(length(sig) !== _aet_)throw RecheckFailure;
          return iter2
                  (function(_aeu_,_aev_){return erecheck(env,_aeu_,_aev_)},
                   sig,
                   args)},
       recheck=
        function(env,form)
         {var env$0=env,form$0=form;
          for(;;)
           if(typeof form$0 === "number")
            return 0;
           else
            switch(form$0[0])
             {case 0:
               var _ad$_=form$0[1],_aea_=form$0[2];
               if(_aea_)
                {var _aeb_=_aea_[2];
                 if(_aeb_ && ! _aeb_[2])
                  {var e2=_aeb_[1],e1=_aea_[1];
                   if(caml_string_equal(_ad$_,_qA_))
                    {var
                      _aee_=[0,e1,e2],
                      _aef_=function(_aen_){return einfer(env$0,_aen_)},
                      match=pair_map(_aef_,_aee_),
                      t2=match[2],
                      t1=match[1],
                      _aeg_=0,
                      _aeh_=1 - t_equal(_aeg_,env$0,t1,t2);
                     if(_aeh_)throw RecheckFailure;
                     return _aeh_}}}
               var
                args=form$0[2],
                _aec_=get$6(env$0,_ad$_),
                sig=get_exn(_aec_,RecheckFailure),
                _aed_=length(args);
               if(length(sig) !== _aed_)throw RecheckFailure;
               return iter2
                       (function(_ael_,_aem_){return erecheck(env$0,_ael_,_aem_)},
                        sig,
                        args);
              case 1:
               var forms=form$0[2],lg=form$0[1],_aei_=parity(lg);
               if(length(forms) !== _aei_)throw RecheckFailure;
               return iter$0
                       (function(_aek_){return recheck(env$0,_aek_)},forms);
              default:
               var f=form$0[4],xty=form$0[3],x=form$0[2];
               trecheck(env$0,xty);
               var
                _aej_=[0,x,[0,xty,0]],
                env$1=push$4(env$0,_aej_),
                env$0=env$1,
                form$0=f;
               continue}},
       tcheck=
        function(env,ty)
         {var match=unloc(ty);
          if(typeof match === "number")
           return 0;
          else
           switch(match[0])
            {case 0:
              var x=match[1],_ad2_=0,_ad3_=[0,unloc(x),_ad2_];
              if(1 - exists$3(env,_ad3_))throw TypingError;
              var _ad4_=0;
              return [0,[0,unloc(x),_ad4_]];
             case 1:
              var t2=match[2],t1=match[1],_ad5_=tcheck(env,t2);
              return [2,tcheck(env,t1),_ad5_];
             case 2:
              var t2$0=match[2],t1$0=match[1],_ad6_=tcheck(env,t2$0);
              return [1,tcheck(env,t1$0),_ad6_];
             default:
              var
               t=match[2],
               x$0=match[1],
               _ad7_=0,
               _ad8_=[0,unloc(x$0),_ad7_],
               _ad9_=push$3(env,_ad8_),
               _ad__=tcheck(_ad9_,t);
              return [3,unloc(x$0),_ad__]}},
       echeck=
        function(env,e){var e$0=e_unloc(e);return [0,e$0,einfer(env,e$0)]},
       check$1=
        function(env,form)
         {function pred(name,fs)
           {function _ad0_(_ad1_){return check$1(env,_ad1_)}
            return [1,name,map$4(_ad0_,fs)]}
          var match=unloc(form);
          switch(match[0])
           {case 0:
             var _adA_=match[1],_adB_=match[2];
             if(_adB_)
              {var _adC_=_adB_[2];
               if(_adC_ && ! _adC_[2])
                {var e2=_adC_[1],e1=_adB_[1],_adK_=unloc(_adA_);
                 if(caml_string_equal(_adK_,_qB_))
                  {var
                    _adL_=[0,e1,e2],
                    _adM_=function(_adZ_){return echeck(env,_adZ_)},
                    _adN_=pair_map(_adM_,_adL_),
                    _adO_=_adN_[2],
                    t2=_adO_[2],
                    e2$0=_adO_[1],
                    match$1=_adN_[1],
                    t1=match$1[2],
                    e1$0=match$1[1],
                    _adP_=0;
                   if(t_equal(_adP_,env,t1,t2))
                    return [0,_qC_,[0,e1$0,[0,e2$0,0]]];
                   throw TypingError}}}
             var args=match[2],_adD_=unloc(_adA_),match$0=get$6(env,_adD_);
             if(match$0)
              {var ar=match$0[1],_adE_=length(ar);
               if(length(args) !== _adE_)throw TypingError;
               var
                _adF_=function(_adY_){return echeck(env,_adY_)},
                args$0=map$4(_adF_,args),
                _adG_=snd(args$0),
                _adH_=0,
                _adI_=
                 function(_adW_,_adX_){return t_equal(_adH_,env,_adW_,_adX_)};
               if(1 - for_all2(_adI_,ar,_adG_))throw TypingError;
               var _adJ_=fst(args$0);
               return [0,unloc(_adA_),_adJ_]}
             throw TypingError;
            case 1:return match[1]?0:1;
            case 2:
             var f2=match[2],f1=match[1];return pred(3257015,[0,f1,[0,f2,0]]);
            case 3:
             var f2$0=match[2],f1$0=match[1];
             return pred(17731,[0,f1$0,[0,f2$0,0]]);
            case 4:
             var f2$1=match[2],f1$1=match[1];
             return pred(3654636,[0,f1$1,[0,f2$1,0]]);
            case 5:
             var f2$2=match[2],f1$2=match[1];
             return pred(95438486,[0,f1$2,[0,f2$2,0]]);
            case 6:var f1$3=match[1];return pred(3903731,[0,f1$3,0]);
            case 7:
             var
              f=match[2],
              match$2=match[1],
              xty=match$2[2],
              x=match$2[1],
              xty$0=tcheck(env,xty),
              _adQ_=[0,xty$0,0],
              _adR_=[0,unloc(x),_adQ_],
              _adS_=push$4(env,_adR_),
              f$0=check$1(_adS_,f);
             return [2,840561112,unloc(x),xty$0,f$0];
            default:
             var
              f$1=match[2],
              match$3=match[1],
              xty$1=match$3[2],
              x$0=match$3[1],
              xty$2=tcheck(env,xty$1),
              _adT_=[0,xty$2,0],
              _adU_=[0,unloc(x$0),_adT_],
              _adV_=push$4(env,_adU_),
              f$2=check$1(_adV_,f$1);
             return [2,172470935,unloc(x$0),xty$2,f$2]}},
       empty$10=0,
       aslist=function(s){return s},
       oflist=function(s){return s},
       get_tag=
        function(x,s)
         {var x$0=x,s$0=s;
          for(;;)
           {var i=x$0[2],n=x$0[1];
            if(s$0)
             {var match=s$0[1],s$1=s$0[2],tag=match[2],m=match[1];
              if(caml_string_equal(n,m))
               {if(0 === i)return [0,tag];
                var x$1=[0,n,i - 1 | 0],x$0=x$1,s$0=s$1;
                continue}
              var s$2=s$0[2],s$0=s$2;
              continue}
            return 0}},
       flex=
        function(x,s){var _adz_=get_tag(x,s);return caml_equal(_adz_,_qD_)},
       bound=
        function(x,s)
         {var match=get_tag(x,s);if(match && match[1])return 1;return 0},
       UnboundVariable=[248,_qE_,caml_fresh_oo_id(0)],
       fetch=
        function(x,s)
         {var match=get_tag(x,s);
          if(match){var _ady_=match[1];if(_ady_){var e=_ady_[1];return e}}
          throw [0,UnboundVariable,x,s]},
       add$9=
        function(x,e,param)
         {var _adv_=x[2],_adw_=x[1];
          if(param)
           {var match=param[1],t=match[2],m=match[1],s=param[2];
            if(caml_string_notequal(_adw_,m))return [0,[0,m,t],add$9(x,e,s)];
            if(caml_string_equal(_adw_,m) && 0 < _adv_)
             {var _adx_=[0,_adw_,_adv_ - 1 | 0];
              return [0,[0,m,t],add$9(_adx_,e,s)]}
            if(! t)
             {var s$0=param[2];
              if(caml_string_equal(_adw_,m) && 0 === _adv_)
               return [0,[0,m,[0,e]],s$0]}
            return failwith(_qF_)}
          return failwith(_qG_)},
       push$6=function(m,t,s){return [0,[0,m,t],s]},
       is_complete=
        function(s)
         {return for_all
                  (function(param){var tag=param[2];return 0 !== tag?1:0},s)},
       e_apply1=
        function(param,e,tg)
         {var i=param[2],x=param[1];
          if(0 === tg[0])
           {var match=tg[1],y=match[1],j=match[2];
            if(caml_string_equal(x,y) && i === j)return e;
            var j$0=match[2];
            if(caml_string_equal(x,y) && i < j$0)return [0,[0,y,j$0 - 1 | 0]];
            return tg}
          var args=tg[2],f=tg[1],_ads_=[0,x,i];
          function _adt_(_adu_){return e_apply1(_ads_,e,_adu_)}
          return [1,f,map$4(_adt_,args)]},
       f_apply1=
        function(param,e,f)
         {var i=param[2],x=param[1];
          if(typeof f === "number")
           return f;
          else
           switch(f[0])
            {case 0:
              var
               args=f[2],
               name=f[1],
               _adh_=[0,x,i],
               _adi_=function(_adr_){return e_apply1(_adh_,e,_adr_)};
              return [0,name,map$4(_adi_,args)];
             case 1:
              var
               fs=f[2],
               lg=f[1],
               _adj_=[0,x,i],
               _adk_=function(_adq_){return f_apply1(_adj_,e,_adq_)};
              return [1,lg,map$4(_adk_,fs)];
             default:
              var
               f$0=f[4],
               ty=f[3],
               y=f[2],
               bd=f[1],
               _adl_=[0,y,i],
               _adm_=0,
               _adn_=e_shift(_adm_,_adl_,e),
               _ado_=caml_string_equal(x,y)?1:0,
               _adp_=[0,x,i + _ado_ | 0];
              return [2,bd,y,ty,f_apply1(_adp_,_adn_,f$0)]}},
       f_iter=
        function(s,i,f)
         {var s$0=s,i$0=i,f$0=f;
          for(;;)
           {if(0 === i$0)return f$0;
            if(s$0)
             {var _add_=s$0[1],_adf_=_add_[2],_ade_=_add_[1];
              if(_adf_)
               {var
                 s$1=s$0[2],
                 e=_adf_[1],
                 _adg_=[0,_ade_,0],
                 f$1=f_apply1(_adg_,e,f$0),
                 i$1=i$0 - 1 | 0,
                 s$0=s$1,
                 i$0=i$1,
                 f$0=f$1;
                continue}
              var s$2=s$0[2],i$2=i$0 - 1 | 0,s$0=s$2,i$0=i$2;
              continue}
            throw [0,Assert_failure,_qH_]}},
       f_apply=function(s,f){return f_iter(s,length(s),f)},
       e_close=
        function(s,param)
         {if(0 === param[0])
           {var x=param[1];
            try
             {var _ac__=fetch(x,s),_ac$_=e_close(s,_ac__);return _ac$_}
            catch(_adc_)
             {_adc_ = caml_wrap_exception(_adc_);
              if(_adc_[1] === UnboundVariable)return [0,x];
              throw _adc_}}
          var es=param[2],f=param[1];
          function _ada_(_adb_){return e_close(s,_adb_)}
          return [1,f,map$4(_ada_,es)]},
       close$0=
        function(s)
         {function _ac8_(param)
           {var tag=param[2],x=param[1];
            if(tag)var e=tag[1],tag$0=[0,e_close(s,e)];else var tag$0=tag;
            return [0,x,tag$0]}
          return function(_ac9_){return map$4(_ac8_,_ac9_)}(s)},
       occurs=
        function(x,param)
         {if(0 === param[0]){var y=param[1];return caml_equal(x,y)?1:0}
          var ts=param[2],_ac7_=0;
          return fold(function(b,t){return b?b:occurs(x,t)},_ac7_,ts)},
       occurs_under=
        function(x,param)
         {var _ac4_=x[2],_ac5_=x[1];
          if(0 === param[0])
           {var match=param[1],j=match[2],m=match[1];
            if(caml_string_equal(_ac5_,m) && j <= _ac4_)return 1;
            return 0}
          var ts=param[2],_ac6_=0;
          return fold(function(b,t){return b?b:occurs_under(x,t)},_ac6_,ts)},
       Invalid_constant=[248,_qI_,caml_fresh_oo_id(0)],
       e_unify=
        function(venv,lenv,s,param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var
               eqns=param$0[2],
               match=param$0[1],
               u=match[2],
               t=match[1],
               unify_cond=
                function(x,t)
                 {var _acZ_=flex(x,s);
                  if(_acZ_)
                   {var _ac0_=1 - occurs(x,t);
                    if(_ac0_)
                     {var _ac1_=indices(lenv);
                      return for_all$1
                              (function(n,i)
                                {var _ac3_=[0,n,i];return 1 - occurs_under(_ac3_,t)},
                               _ac1_)}
                    var _ac2_=_ac0_}
                  else
                   var _ac2_=_acZ_;
                  return _ac2_},
               unify_body$0=
                function(eqns)
                 {function unify_body(x,t)
                   {return e_unify(venv,lenv,add$9(x,t,s),eqns)}
                  return unify_body},
               unify_body=unify_body$0(eqns),
               substitute_cond=function(x){return bound(x,s)},
               substitute_body$0=
                function(eqns)
                 {function substitute_body(x,t)
                   {return e_unify(venv,lenv,s,[0,[0,fetch(x,s),t],eqns])}
                  return substitute_body},
               substitute_body=substitute_body$0(eqns),
               is_const=
                function(x)
                 {var match=get$9(venv,x);
                  if(match && match[1][2])return 1;
                  return 0},
               switch$0=0;
              if(0 === t[0])
               {var x=t[1];
                if(unify_cond(x,u))return unify_body(x,u);
                switch$0 = 1}
              else
               {var _acW_=t[2],_acX_=t[1];
                if(0 === u[0])
                 switch$0 = 1;
                else
                 {var us=u[2],g=u[1];
                  if(caml_string_equal(_acX_,g))
                   {var
                     _acY_=combine(_acW_,us),
                     param$3=append(_acY_,eqns),
                     param$0=param$3;
                    continue}}}
              if(switch$0)
               {if(0 === u[0])
                 {var x$0=u[1];if(unify_cond(x$0,t))return unify_body(x$0,t)}
                if(0 === t[0])
                 {var x$1=t[1];
                  if(substitute_cond(x$1))return substitute_body(x$1,u)}
                if(0 === u[0])
                 {var x$2=u[1];
                  if(substitute_cond(x$2))return substitute_body(x$2,t);
                  if(0 === t[0])
                   {var y=u[1],x$3=t[1];
                    if(caml_equal(x$3,y)){var param$0=eqns;continue}}
                  var y$0=u[1];
                  if(is_const(y$0))
                   {var match$0=get$9(venv,y$0);
                    if(match$0)
                     {var _acU_=match$0[1][2];
                      if(_acU_)
                       {var ye=_acU_[1],param$1=[0,[0,t,ye],eqns],param$0=param$1;
                        continue}}
                    throw Invalid_constant}}
                if(0 === t[0])
                 {var x$4=t[1];
                  if(is_const(x$4))
                   {var match$1=get$9(venv,x$4);
                    if(match$1)
                     {var _acV_=match$1[1][2];
                      if(_acV_)
                       {var xe=_acV_[1],param$2=[0,[0,xe,u],eqns],param$0=param$2;
                        continue}}
                    throw Invalid_constant}}}
              return 0}
            return [0,close$0(s)]}},
       f_unify=
        function(venv,lenv,s)
         {return function(param)
           {if(param)
             {var
               eqns=param[2],
               match=param[1],
               f2=match[2],
               f1=match[1],
               switch$0=0;
              if(typeof f1 === "number")
               {if(0 === f1)
                 {if(typeof f2 === "number" && ! f2)switch$0 = 1}
                else
                 if(typeof f2 === "number" && f2)switch$0 = 1}
              else
               switch(f1[0])
                {case 0:
                  if(typeof f2 !== "number" && 0 === f2[0])
                   {var l2=f2[2],p2=f2[1],l1=f1[2],p1=f1[1];
                    if(caml_string_equal(p1,p2))
                     {var _acH_=length(l2);
                      if(length(l1) === _acH_)
                       {var
                         _acI_=
                          function(s){return caml_call1(f_unify(venv,lenv,s),eqns)},
                         _acJ_=combine(l1,l2);
                        return bind$0(e_unify(venv,lenv,s,_acJ_),_acI_)}}}
                  break;
                 case 1:
                  if(typeof f2 !== "number" && 1 === f2[0])
                   {var l2$0=f2[2],c2=f2[1],l1$0=f1[2],c1=f1[1];
                    if(c1 === c2)
                     {var _acK_=length(l2$0);
                      if(length(l1$0) === _acK_)
                       {var subeqns=combine(l1$0,l2$0),_acL_=append(subeqns,eqns);
                        return caml_call1(f_unify(venv,lenv,s),_acL_)}}}
                  break;
                 default:
                  if(typeof f2 !== "number" && 2 === f2[0])
                   {var
                     f2$0=f2[4],
                     ty2=f2[3],
                     x2=f2[2],
                     b2=f2[1],
                     f1$0=f1[4],
                     ty1=f1[3],
                     x1=f1[2],
                     b1=f1[1];
                    if(b1 === b2 && caml_equal(ty1,ty2))
                     {var
                       _acM_=[0,x1,0],
                       _acN_=0,
                       _acO_=f_shift(_acN_,_acM_,f2$0),
                       _acP_=[0,[0,x1,0]],
                       _acQ_=[0,x2,0],
                       f2$1=f_apply1(_acQ_,_acP_,_acO_),
                       _acR_=
                        function(s){return caml_call1(f_unify(venv,lenv,s),eqns)},
                       _acS_=[0,[0,f1$0,f2$1],0],
                       _acT_=enter(lenv,x1);
                      return bind$0(caml_call1(f_unify(venv,_acT_,s),_acS_),_acR_)}}}
              return switch$0?caml_call1(f_unify(venv,lenv,s),eqns):0}
            return [0,s]}},
       check_entry=
        function(env)
         {function for_type(_acG_){return tcheck(env,_acG_)}
          function for_expr(_acF_){return echeck(env,_acF_)}
          return function(param)
           {switch(param[0])
             {case 0:
               var ar=param[2],name=param[1],_acx_=map$4(for_type,ar);
               return [0,[0,unloc(name),_acx_]];
              case 1:
               var
                match=param[2],
                ty=match[2],
                ar$0=match[1],
                name$0=param[1],
                _acy_=for_type(ty),
                _acz_=[0,map$4(for_type,ar$0),_acy_];
               return [1,[0,unloc(name$0),_acz_]];
              case 2:
               var
                ty$0=param[2],
                name$1=param[1],
                _acA_=0,
                _acB_=[0,for_type(ty$0),_acA_];
               return [2,[0,unloc(name$1),_acB_]];
              case 3:
               var
                body=param[2],
                name$2=param[1],
                match$0=for_expr(body),
                ty$1=match$0[2],
                body$0=match$0[1],
                _acC_=[0,ty$1,[0,body$0]];
               return [2,[0,unloc(name$2),_acC_]];
              case 4:
               var name$3=param[1],_acD_=0;return [3,[0,unloc(name$3),_acD_]];
              default:
               var ty$2=param[2],name$4=param[1],_acE_=[0,for_type(ty$2)];
               return [3,[0,unloc(name$4),_acE_]]}}},
       env_of_entries=
        function(entries)
         {return fold
                  (function(env,entry)
                    {var match=caml_call1(check_entry(env),entry);
                     switch(match[0])
                      {case 0:var nmty=match[1];return push$1(env,nmty);
                       case 1:var nmty$0=match[1];return push$2(env,nmty$0);
                       case 2:var nmty$1=match[1];return push$4(env,nmty$1);
                       default:var nmty$2=match[1];return push$3(env,nmty$2)}},
                   empty$7,
                   entries)},
       check$2=
        function(param)
         {var f=param[3],hs=param[2],ps=param[1],env=env_of_entries(ps);
          function for_form(_acw_){return check$1(env,_acw_)}
          var _acv_=for_form(f);
          return [0,env,map$4(for_form,hs),_acv_]},
       Error$0=[248,_qJ_,caml_fresh_oo_id(0)],
       token2terminal=
        function(tok)
         {if(typeof tok === "number")
           switch(tok)
            {case 0:return 1;
             case 1:return 2;
             case 2:return 3;
             case 3:return 4;
             case 4:return 5;
             case 5:return 6;
             case 6:return 7;
             case 7:return 8;
             case 8:return 9;
             case 9:return 11;
             case 10:return 12;
             case 11:return 13;
             case 12:return 14;
             case 13:return 15;
             case 14:return 16;
             case 15:return 17;
             case 16:return 19;
             case 17:return 20;
             case 18:return 21;
             case 19:return 22;
             case 20:return 23;
             case 21:return 24;
             case 22:return 25;
             case 23:return 26;
             case 24:return 27;
             case 25:return 28;
             default:return 29}
          else
           return 0 === tok[0]?10:18},
       error_terminal=0,
       token2value=
        function(tok)
         {if(typeof tok === "number")
           switch(tok)
            {case 0:return 0;
             case 1:return 0;
             case 2:return 0;
             case 3:return 0;
             case 4:return 0;
             case 5:return 0;
             case 6:return 0;
             case 7:return 0;
             case 8:return 0;
             case 9:return 0;
             case 10:return 0;
             case 11:return 0;
             case 12:return 0;
             case 13:return 0;
             case 14:return 0;
             case 15:return 0;
             case 16:return 0;
             case 17:return 0;
             case 18:return 0;
             case 19:return 0;
             case 20:return 0;
             case 21:return 0;
             case 22:return 0;
             case 23:return 0;
             case 24:return 0;
             case 25:return 0;
             default:return 0}
          else
           {if(0 === tok[0]){var v=tok[1];return v}var v$0=tok[1];return v$0}},
       start=5,
       _qK_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5],
           menhir_stack$0=match[5],
           startpos_t=match[3],
           t=match[2],
           menhir_s=match[1],
           endpos_2=menhir_stack[4];
          return [0,menhir_s,t,startpos_t,endpos_2,menhir_stack$0]},
       _qL_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           endpos_1=menhir_stack[4],
           startpos_1=menhir_stack[3],
           _acu_=0;
          throw [0,ParseError,[0,make$6(startpos_1,endpos_1)],_acu_]},
       _qM_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5],
           menhir_stack$0=match[5],
           startpos_e=match[3],
           e=match[2],
           menhir_s=match[1],
           endpos_2=menhir_stack[4];
          return [0,menhir_s,e,startpos_e,endpos_2,menhir_stack$0]},
       _qN_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           endpos_1=menhir_stack[4],
           startpos_1=menhir_stack[3],
           _act_=0;
          throw [0,ParseError,[0,make$6(startpos_1,endpos_1)],_act_]},
       _qO_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5],
           menhir_stack$0=match[5],
           startpos_p=match[3],
           p=match[2],
           menhir_s=match[1],
           endpos_2=menhir_stack[4];
          return [0,menhir_s,p,startpos_p,endpos_2,menhir_stack$0]},
       _qP_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           endpos_1=menhir_stack[4],
           startpos_1=menhir_stack[3],
           _acs_=0;
          throw [0,ParseError,[0,make$6(startpos_1,endpos_1)],_acs_]},
       _qQ_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5],
           menhir_stack$0=match[5],
           startpos_f=match[3],
           f=match[2],
           menhir_s=match[1],
           endpos_2=menhir_stack[4];
          return [0,menhir_s,f,startpos_f,endpos_2,menhir_stack$0]},
       _qR_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           endpos_1=menhir_stack[4],
           startpos_1=menhir_stack[3],
           _acr_=0;
          throw [0,ParseError,[0,make$6(startpos_1,endpos_1)],_acr_]},
       _qS_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5],
           menhir_stack$0=match[5],
           startpos_e=match[3],
           e=match[2],
           menhir_s=match[1],
           endpos_2=menhir_stack[4];
          return [0,menhir_s,e,startpos_e,endpos_2,menhir_stack$0]},
       _qT_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           endpos_1=menhir_stack[4],
           startpos_1=menhir_stack[3],
           _acq_=0;
          throw [0,ParseError,[0,make$6(startpos_1,endpos_1)],_acq_]},
       _qU_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           _acp_=menhir_stack[5],
           match=_acp_[5][5],
           menhir_stack$0=match[5],
           endpos_x=match[4],
           startpos_x=match[3],
           x=match[2],
           menhir_s=match[1],
           aout=_acp_[2],
           endpos_3=menhir_stack[4],
           f=[0,make$6(startpos_x,endpos_x),x],
           v=[1,f,aout];
          return [0,menhir_s,v,startpos_x,endpos_3,menhir_stack$0]},
       _qV_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5][5],
           menhir_stack$0=match[5],
           endpos_x=match[4],
           startpos_x=match[3],
           x=match[2],
           menhir_s=match[1],
           endpos_3=menhir_stack[4],
           f=[0,make$6(startpos_x,endpos_x),x],
           v=[1,f,0];
          return [0,menhir_s,v,startpos_x,endpos_3,menhir_stack$0]},
       _qW_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           _aco_=menhir_stack[5],
           match=_aco_[5][5],
           menhir_stack$0=match[5],
           endpos_x=match[4],
           startpos_x=match[3],
           x=match[2],
           menhir_s=match[1],
           i=_aco_[2],
           endpos_4=menhir_stack[4],
           x$0=[0,make$6(startpos_x,endpos_x),x],
           v=[0,x$0,i];
          return [0,menhir_s,v,startpos_x,endpos_4,menhir_stack$0]},
       _qX_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           menhir_stack$0=menhir_stack[5],
           endpos_x=menhir_stack[4],
           startpos_x=menhir_stack[3],
           x=menhir_stack[2],
           menhir_s=menhir_stack[1],
           x$0=[0,make$6(startpos_x,endpos_x),x],
           v=[0,x$0,0];
          return [0,menhir_s,v,startpos_x,endpos_x,menhir_stack$0]},
       _qY_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           menhir_stack$0=menhir_stack[5],
           endpos_x=menhir_stack[4],
           startpos_x=menhir_stack[3],
           x=menhir_stack[2],
           menhir_s=menhir_stack[1],
           v=[0,make$6(startpos_x,endpos_x),x];
          return [0,menhir_s,v,startpos_x,endpos_x,menhir_stack$0]},
       _qZ_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           _acn_=menhir_stack[5][5],
           match=_acn_[5],
           menhir_stack$0=match[5],
           startpos_1=match[3],
           menhir_s=match[1],
           endpos_x=_acn_[4],
           startpos_x=_acn_[3],
           x=_acn_[2],
           endpos_t=menhir_stack[4],
           t=menhir_stack[2],
           x$0=[0,make$6(startpos_x,endpos_x),x],
           v=[3,x$0,t];
          return [0,menhir_s,v,startpos_1,endpos_t,menhir_stack$0]},
       _q0_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5][5],
           menhir_stack$0=match[5],
           startpos_t1=match[3],
           t1=match[2],
           menhir_s=match[1],
           endpos_t2=menhir_stack[4],
           t2=menhir_stack[2],
           v=[2,t1,t2];
          return [0,menhir_s,v,startpos_t1,endpos_t2,menhir_stack$0]},
       _q1_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5][5],
           menhir_stack$0=match[5],
           startpos_t1=match[3],
           t1=match[2],
           menhir_s=match[1],
           endpos_t2=menhir_stack[4],
           t2=menhir_stack[2],
           v=[1,t1,t2];
          return [0,menhir_s,v,startpos_t1,endpos_t2,menhir_stack$0]},
       _q2_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           menhir_stack$0=menhir_stack[5],
           endpos_x=menhir_stack[4],
           startpos_x=menhir_stack[3],
           x=menhir_stack[2],
           menhir_s=menhir_stack[1],
           x$0=[0,make$6(startpos_x,endpos_x),x],
           v=[0,x$0];
          return [0,menhir_s,v,startpos_x,endpos_x,menhir_stack$0]},
       _q3_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5],
           menhir_stack$0=match[5],
           startpos_1=match[3],
           menhir_s=match[1],
           endpos_3=menhir_stack[4];
          return [0,menhir_s,0,startpos_1,endpos_3,menhir_stack$0]},
       _q4_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           _acm_=menhir_stack[5],
           match=_acm_[5],
           menhir_stack$0=match[5],
           startpos_1=match[3],
           menhir_s=match[1],
           x=_acm_[2],
           endpos_3=menhir_stack[4];
          return [0,menhir_s,x,startpos_1,endpos_3,menhir_stack$0]},
       _q5_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           menhir_stack$0=menhir_stack[5],
           endpos_x=menhir_stack[4],
           startpos_x=menhir_stack[3],
           x=menhir_stack[2],
           menhir_s=menhir_stack[1],
           v=[0,make$6(startpos_x,endpos_x),x];
          return [0,menhir_s,v,startpos_x,endpos_x,menhir_stack$0]},
       _q6_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5][5],
           menhir_stack$0=match[5],
           endpos_x=match[4],
           startpos_x=match[3],
           x=match[2],
           menhir_s=match[1],
           endpos_ty=menhir_stack[4],
           ty=menhir_stack[2],
           x$0=[0,make$6(startpos_x,endpos_x),x],
           v=[0,x$0,ty];
          return [0,menhir_s,v,startpos_x,endpos_ty,menhir_stack$0]},
       _q7_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5][5],
           menhir_stack$0=match[5],
           startpos_xs=match[3],
           xs=match[2],
           menhir_s=match[1],
           endpos_ty=menhir_stack[4],
           ty=menhir_stack[2],
           v=[0,xs,ty];
          return [0,menhir_s,v,startpos_xs,endpos_ty,menhir_stack$0]},
       _q8_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5][5],
           menhir_stack$0=match[5],
           startpos_x=match[3],
           x=match[2],
           menhir_s=match[1],
           endpos_xs=menhir_stack[4],
           xs=menhir_stack[2],
           v=[0,x,xs];
          return [0,menhir_s,v,startpos_x,endpos_xs,menhir_stack$0]},
       _q9_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           menhir_stack$0=menhir_stack[5],
           endpos_x=menhir_stack[4],
           startpos_x=menhir_stack[3],
           x=menhir_stack[2],
           menhir_s=menhir_stack[1],
           v=[0,x,0];
          return [0,menhir_s,v,startpos_x,endpos_x,menhir_stack$0]},
       _q__=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5][5],
           menhir_stack$0=match[5],
           startpos_x=match[3],
           x=match[2],
           menhir_s=match[1],
           endpos_xs=menhir_stack[4],
           xs=menhir_stack[2],
           v=[0,x,xs];
          return [0,menhir_s,v,startpos_x,endpos_xs,menhir_stack$0]},
       _q$_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           menhir_stack$0=menhir_stack[5],
           endpos_x=menhir_stack[4],
           startpos_x=menhir_stack[3],
           x=menhir_stack[2],
           menhir_s=menhir_stack[1],
           v=[0,x,0];
          return [0,menhir_s,v,startpos_x,endpos_x,menhir_stack$0]},
       _ra_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5][5],
           menhir_stack$0=match[5],
           startpos_x=match[3],
           x=match[2],
           menhir_s=match[1],
           endpos_xs=menhir_stack[4],
           xs=menhir_stack[2],
           v=[0,x,xs];
          return [0,menhir_s,v,startpos_x,endpos_xs,menhir_stack$0]},
       _rb_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           menhir_stack$0=menhir_stack[5],
           endpos_x=menhir_stack[4],
           startpos_x=menhir_stack[3],
           x=menhir_stack[2],
           menhir_s=menhir_stack[1],
           v=[0,x,0];
          return [0,menhir_s,v,startpos_x,endpos_x,menhir_stack$0]},
       _rc_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5][5],
           menhir_stack$0=match[5],
           startpos_x=match[3],
           x=match[2],
           menhir_s=match[1],
           endpos_xs=menhir_stack[4],
           xs=menhir_stack[2],
           v=[0,x,xs];
          return [0,menhir_s,v,startpos_x,endpos_xs,menhir_stack$0]},
       _rd_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           menhir_stack$0=menhir_stack[5],
           endpos_x=menhir_stack[4],
           startpos_x=menhir_stack[3],
           x=menhir_stack[2],
           menhir_s=menhir_stack[1],
           v=[0,x,0];
          return [0,menhir_s,v,startpos_x,endpos_x,menhir_stack$0]},
       _re_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5],
           menhir_stack$0=match[5],
           startpos_1=match[3],
           menhir_s=match[1],
           endpos_xs=menhir_stack[4],
           xs=menhir_stack[2],
           v=[0,xs];
          return [0,menhir_s,v,startpos_1,endpos_xs,menhir_stack$0]},
       _rf_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           menhir_s=menhir_env[4],
           startpos=menhir_stack[4];
          return [0,menhir_s,0,startpos,startpos,menhir_stack]},
       _rg_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5][5],
           menhir_stack$0=match[5],
           endpos_x=match[4],
           startpos_x=match[3],
           x=match[2],
           menhir_s=match[1],
           endpos_e=menhir_stack[4],
           e=menhir_stack[2],
           x$0=[0,make$6(startpos_x,endpos_x),x],
           v=[0,x$0,e];
          return [0,menhir_s,v,startpos_x,endpos_e,menhir_stack$0]},
       _rh_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           menhir_stack$0=menhir_stack[5],
           endpos_x=menhir_stack[4],
           startpos_x=menhir_stack[3],
           x=menhir_stack[2],
           menhir_s=menhir_stack[1];
          return [0,menhir_s,x,startpos_x,endpos_x,menhir_stack$0]},
       _ri_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           menhir_s=menhir_env[4],
           startpos=menhir_stack[4];
          return [0,menhir_s,0,startpos,startpos,menhir_stack]},
       _rj_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           menhir_stack$0=menhir_stack[5],
           endpos_x=menhir_stack[4],
           startpos_x=menhir_stack[3],
           x=menhir_stack[2],
           menhir_s=menhir_stack[1];
          return [0,menhir_s,x,startpos_x,endpos_x,menhir_stack$0]},
       _rk_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           menhir_s=menhir_env[4],
           startpos=menhir_stack[4];
          return [0,menhir_s,0,startpos,startpos,menhir_stack]},
       _rl_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           menhir_stack$0=menhir_stack[5],
           endpos_x=menhir_stack[4],
           startpos_x=menhir_stack[3],
           x=menhir_stack[2],
           menhir_s=menhir_stack[1];
          return [0,menhir_s,x,startpos_x,endpos_x,menhir_stack$0]},
       _rm_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           menhir_s=menhir_env[4],
           startpos=menhir_stack[4];
          return [0,menhir_s,0,startpos,startpos,menhir_stack]},
       _rn_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           _ack_=menhir_stack[5][5],
           match=_ack_[5],
           menhir_stack$0=match[5],
           startpos_xs=match[3],
           xs=match[2],
           menhir_s=match[1],
           hs=_ack_[2],
           endpos_f=menhir_stack[4],
           f=menhir_stack[2],
           _acl_=0,
           v=[0,xs,default$0(_acl_,hs),f];
          return [0,menhir_s,v,startpos_xs,endpos_f,menhir_stack$0]},
       _ro_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           _acj_=menhir_stack[5][5],
           match=_acj_[5],
           menhir_stack$0=match[5],
           startpos_1=match[3],
           menhir_s=match[1],
           xty=_acj_[2],
           endpos_f=menhir_stack[4],
           f=menhir_stack[2],
           v=[8,xty,f];
          return [0,menhir_s,v,startpos_1,endpos_f,menhir_stack$0]},
       _rp_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           _aci_=menhir_stack[5][5],
           match=_aci_[5],
           menhir_stack$0=match[5],
           startpos_1=match[3],
           menhir_s=match[1],
           xty=_aci_[2],
           endpos_f=menhir_stack[4],
           f=menhir_stack[2],
           v=[7,xty,f];
          return [0,menhir_s,v,startpos_1,endpos_f,menhir_stack$0]},
       _rq_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5],
           menhir_stack$0=match[5],
           startpos_1=match[3],
           menhir_s=match[1],
           endpos_f=menhir_stack[4],
           f=menhir_stack[2],
           v=[6,f];
          return [0,menhir_s,v,startpos_1,endpos_f,menhir_stack$0]},
       _rr_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5][5],
           menhir_stack$0=match[5],
           startpos_f1=match[3],
           f1=match[2],
           menhir_s=match[1],
           endpos_f2=menhir_stack[4],
           f2=menhir_stack[2],
           v=[5,f1,f2];
          return [0,menhir_s,v,startpos_f1,endpos_f2,menhir_stack$0]},
       _rs_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5][5],
           menhir_stack$0=match[5],
           startpos_f1=match[3],
           f1=match[2],
           menhir_s=match[1],
           endpos_f2=menhir_stack[4],
           f2=menhir_stack[2],
           v=[4,f1,f2];
          return [0,menhir_s,v,startpos_f1,endpos_f2,menhir_stack$0]},
       _rt_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5][5],
           menhir_stack$0=match[5],
           startpos_f1=match[3],
           f1=match[2],
           menhir_s=match[1],
           endpos_f2=menhir_stack[4],
           f2=menhir_stack[2],
           v=[3,f1,f2];
          return [0,menhir_s,v,startpos_f1,endpos_f2,menhir_stack$0]},
       _ru_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5][5],
           menhir_stack$0=match[5],
           startpos_f1=match[3],
           f1=match[2],
           menhir_s=match[1],
           endpos_f2=menhir_stack[4],
           f2=menhir_stack[2],
           v=[2,f1,f2];
          return [0,menhir_s,v,startpos_f1,endpos_f2,menhir_stack$0]},
       _rv_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           _ach_=menhir_stack[5],
           match=_ach_[5][5],
           menhir_stack$0=match[5],
           endpos_x=match[4],
           startpos_x=match[3],
           x=match[2],
           menhir_s=match[1],
           aout=_ach_[2],
           endpos_3=menhir_stack[4],
           x$0=[0,make$6(startpos_x,endpos_x),x],
           v=[0,x$0,aout];
          return [0,menhir_s,v,startpos_x,endpos_3,menhir_stack$0]},
       _rw_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5][5],
           menhir_stack$0=match[5],
           startpos_e1=match[3],
           e1=match[2],
           menhir_s=match[1],
           endpos_e2=menhir_stack[4],
           e2=menhir_stack[2],
           _acg_=[0,e1,[0,e2,0]],
           v=[0,mkloc(dummy$3,_rx_),_acg_];
          return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]},
       _ry_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           menhir_stack$0=menhir_stack[5],
           endpos_x=menhir_stack[4],
           startpos_x=menhir_stack[3],
           x=menhir_stack[2],
           menhir_s=menhir_stack[1],
           x$0=[0,make$6(startpos_x,endpos_x),x],
           v=[0,x$0,0];
          return [0,menhir_s,v,startpos_x,endpos_x,menhir_stack$0]},
       _rz_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           menhir_stack$0=menhir_stack[5],
           endpos_1=menhir_stack[4],
           startpos_1=menhir_stack[3],
           menhir_s=menhir_stack[1];
          return [0,menhir_s,v,startpos_1,endpos_1,menhir_stack$0]},
       _rA_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           menhir_stack$0=menhir_stack[5],
           endpos_1=menhir_stack[4],
           startpos_1=menhir_stack[3],
           menhir_s=menhir_stack[1];
          return [0,menhir_s,v$0,startpos_1,endpos_1,menhir_stack$0]},
       _rB_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           _acf_=menhir_stack[5],
           match=_acf_[5],
           menhir_stack$0=match[5],
           startpos_1=match[3],
           menhir_s=match[1],
           x=_acf_[2],
           endpos_3=menhir_stack[4];
          return [0,menhir_s,x,startpos_1,endpos_3,menhir_stack$0]},
       _rC_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           menhir_stack$0=menhir_stack[5],
           endpos_x=menhir_stack[4],
           startpos_x=menhir_stack[3],
           x=menhir_stack[2],
           menhir_s=menhir_stack[1],
           v=[0,make$6(startpos_x,endpos_x),x];
          return [0,menhir_s,v,startpos_x,endpos_x,menhir_stack$0]},
       _rD_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           _ace_=menhir_stack[5],
           match=_ace_[5],
           menhir_stack$0=match[5],
           startpos_1=match[3],
           menhir_s=match[1],
           x=_ace_[2],
           endpos_3=menhir_stack[4];
          return [0,menhir_s,x,startpos_1,endpos_3,menhir_stack$0]},
       _rE_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           menhir_stack$0=menhir_stack[5],
           endpos_e=menhir_stack[4],
           startpos_e=menhir_stack[3],
           e=menhir_stack[2],
           menhir_s=menhir_stack[1];
          return [0,menhir_s,e,startpos_e,endpos_e,menhir_stack$0]},
       _rF_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           menhir_stack$0=menhir_stack[5],
           endpos_x=menhir_stack[4],
           startpos_x=menhir_stack[3],
           x=menhir_stack[2],
           menhir_s=menhir_stack[1],
           v=[0,make$6(startpos_x,endpos_x),x];
          return [0,menhir_s,v,startpos_x,endpos_x,menhir_stack$0]},
       _rG_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           _acd_=menhir_stack[5][5],
           match=_acd_[5],
           menhir_stack$0=match[5],
           startpos_1=match[3],
           menhir_s=match[1],
           endpos_x=_acd_[4],
           startpos_x=_acd_[3],
           x=_acd_[2],
           endpos_t=menhir_stack[4],
           t=menhir_stack[2],
           a=[0,make$6(startpos_x,endpos_x),x],
           v=[5,a,t];
          return [0,menhir_s,v,startpos_1,endpos_t,menhir_stack$0]},
       _rH_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5],
           menhir_stack$0=match[5],
           startpos_1=match[3],
           menhir_s=match[1],
           endpos_x=menhir_stack[4],
           startpos_x=menhir_stack[3],
           x=menhir_stack[2],
           a=[0,make$6(startpos_x,endpos_x),x],
           v=[4,a];
          return [0,menhir_s,v,startpos_1,endpos_x,menhir_stack$0]},
       _rI_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5][5],
           menhir_stack$0=match[5],
           endpos_x=match[4],
           startpos_x=match[3],
           x=match[2],
           menhir_s=match[1],
           endpos_body=menhir_stack[4],
           body=menhir_stack[2],
           x$0=[0,make$6(startpos_x,endpos_x),x],
           v=[3,x$0,body];
          return [0,menhir_s,v,startpos_x,endpos_body,menhir_stack$0]},
       _rJ_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5][5],
           menhir_stack$0=match[5],
           endpos_x=match[4],
           startpos_x=match[3],
           x=match[2],
           menhir_s=match[1],
           endpos_xty=menhir_stack[4],
           xty=menhir_stack[2],
           x$0=[0,make$6(startpos_x,endpos_x),x],
           v=[2,x$0,xty];
          return [0,menhir_s,v,startpos_x,endpos_xty,menhir_stack$0]},
       _rK_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5][5],
           menhir_stack$0=match[5],
           endpos_x=match[4],
           startpos_x=match[3],
           x=match[2],
           menhir_s=match[1],
           endpos_xty=menhir_stack[4],
           xty=menhir_stack[2],
           x$0=[0,make$6(startpos_x,endpos_x),x],
           v=[1,x$0,xty];
          return [0,menhir_s,v,startpos_x,endpos_xty,menhir_stack$0]},
       _rL_=
        function(menhir_env)
         {var
           menhir_stack=menhir_env[3],
           match=menhir_stack[5][5],
           menhir_stack$0=match[5],
           endpos_x=match[4],
           startpos_x=match[3],
           x=match[2],
           menhir_s=match[1],
           endpos_xs=menhir_stack[4],
           xs=menhir_stack[2],
           x$0=[0,make$6(startpos_x,endpos_x),x],
           v=[0,x$0,xs];
          return [0,menhir_s,v,startpos_x,endpos_xs,menhir_stack$0]},
       semantic_action=
        [0,
         function(menhir_env)
          {var
            menhir_stack=menhir_env[3],
            menhir_stack$0=menhir_stack[5],
            endpos_x=menhir_stack[4],
            startpos_x=menhir_stack[3],
            x=menhir_stack[2],
            menhir_s=menhir_stack[1],
            x$0=[0,make$6(startpos_x,endpos_x),x],
            v=[0,x$0,0];
           return [0,menhir_s,v,startpos_x,endpos_x,menhir_stack$0]},
         _rL_,
         _rK_,
         _rJ_,
         _rI_,
         _rH_,
         _rG_,
         _rF_,
         _rE_,
         _rD_,
         _rC_,
         _rB_,
         _rA_,
         _rz_,
         _ry_,
         _rw_,
         _rv_,
         _ru_,
         _rt_,
         _rs_,
         _rr_,
         _rq_,
         _rp_,
         _ro_,
         _rn_,
         _rm_,
         _rl_,
         _rk_,
         _rj_,
         _ri_,
         _rh_,
         _rg_,
         _rf_,
         _re_,
         _rd_,
         _rc_,
         _rb_,
         _ra_,
         _q$_,
         _q__,
         _q9_,
         _q8_,
         _q7_,
         _q6_,
         _q5_,
         _q4_,
         _q3_,
         _q2_,
         _q1_,
         _q0_,
         _qZ_,
         _qY_,
         _qX_,
         _qW_,
         _qV_,
         _qU_,
         _qT_,
         _qS_,
         _qR_,
         _qQ_,
         _qP_,
         _qO_,
         _qN_,
         _qM_,
         _qL_,
         _qK_],
       ET=
        _fq_
         ([0,
           token2terminal,
           error_terminal,
           token2value,
           default_reduction,
           error,
           action,
           lhs,
           goto$0,
           start,
           semantic_action,
           Error$0,
           0]),
       TI=_fs_(ET),
       entry=TI[2],
       trace=0,
       _rM_=[0],
       terminal=
        function(t)
         {if(29 < t >>> 0)throw [0,Assert_failure,_rN_];
          switch(t)
           {case 0:return _rO_;
            case 1:return _rP_;
            case 2:return _rQ_;
            case 3:return _rR_;
            case 4:return _rS_;
            case 5:return _rT_;
            case 6:return _rU_;
            case 7:return _rV_;
            case 8:return _rW_;
            case 9:return _rX_;
            case 10:return _rY_;
            case 11:return _rZ_;
            case 12:return _r0_;
            case 13:return _r1_;
            case 14:return _r2_;
            case 15:return _r3_;
            case 16:return _r4_;
            case 17:return _r5_;
            case 18:return _r6_;
            case 19:return _r7_;
            case 20:return _r8_;
            case 21:return _r9_;
            case 22:return _r__;
            case 23:return _r$_;
            case 24:return _sa_;
            case 25:return _sb_;
            case 26:return _sc_;
            case 27:return _sd_;
            case 28:return _se_;
            default:return _sf_}},
       nonterminal=
        function(nt)
         {var switcher=nt - 5 | 0;
          if(25 < switcher >>> 0)throw [0,Assert_failure,_sg_];
          switch(switcher)
           {case 0:return _sh_;
            case 1:return _si_;
            case 2:return _sj_;
            case 3:return _sk_;
            case 4:return _sl_;
            case 5:return _sm_;
            case 6:return _sn_;
            case 7:return _so_;
            case 8:return _sp_;
            case 9:return _sq_;
            case 10:return _sr_;
            case 11:return _ss_;
            case 12:return _st_;
            case 13:return _su_;
            case 14:return _sv_;
            case 15:return _sw_;
            case 16:return _sx_;
            case 17:return _sy_;
            case 18:return _sz_;
            case 19:return _sA_;
            case 20:return _sB_;
            case 21:return _sC_;
            case 22:return _sD_;
            case 23:return _sE_;
            case 24:return _sF_;
            default:return _sG_}},
       _sH_=
        [0,
         terminal,
         nonterminal,
         rhs,
         lr0_core,
         lr0_items,
         lr0_incoming,
         nullable,
         first$0],
       _sI_=
        [0,
         token2terminal,
         error_terminal,
         token2value,
         default_reduction,
         error,
         action,
         lhs,
         goto$0,
         start,
         semantic_action,
         Error$0,
         trace],
       _sJ_=function(_aca_,_acb_,_acc_){return _fr_(_sI_,_aca_,_acb_,_acc_)},
       _sK_=function(_ab__,_ab$_){return _sJ_(_sH_,_ab__,_ab$_)};
      (function(_ab9_){return _sK_(ET,_ab9_)}(_rM_));
      var
       xnexpr=
        function(lexer,lexbuf)
         {return caml_call4(entry,-822677911,115,lexer,lexbuf)},
       xgoal=
        function(lexer,lexbuf)
         {return caml_call4(entry,-822677911,77,lexer,lexbuf)},
       xform=
        function(lexer,lexbuf)
         {return caml_call4(entry,-822677911,21,lexer,lexbuf)},
       xexpr=
        function(lexer,lexbuf)
         {return caml_call4(entry,-822677911,0,lexer,lexbuf)},
       lex_error=
        function(lexbuf,msg)
         {var _ab8_=[0,msg];throw [0,ParseError,[0,of_lexbuf(lexbuf)],_ab8_]},
       _sL_=0,
       _sM_=0,
       table=create$2(_sM_,_sL_),
       _sN_=function(_ab6_,_ab7_){return add$0(table,_ab6_,_ab7_)},
       _sO_=function(_ab5_){return curry(_sN_,_ab5_)};
      iter$0(_sO_,keywords);
      var
       main$0=
        function(counter,lexbuf)
         {var _ab4_=0;
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return ocaml_lex_main_rec(counter$0,lexbuf,_ab4_)}
          return caml_trampoline_return(ocaml_lex_main_rec,[0,lexbuf,_ab4_])},
       ocaml_lex_main_rec=
        function(counter,lexbuf,ocaml_lex_state)
         {var ocaml_lex_state$0=ocaml_lex_state;
          for(;;)
           {var
             ocaml_lex_state$1=
              engine(ocaml_lex_tables,ocaml_lex_state$0,lexbuf);
            if(25 < ocaml_lex_state$1 >>> 0)
             {var _abW_=lexbuf[1];
              caml_call1(_abW_,lexbuf);
              var ocaml_lex_state$0=ocaml_lex_state$1;
              continue}
            switch(ocaml_lex_state$1)
             {case 0:
               new_line(lexbuf);
               if(counter < 50)
                {var counter$0=counter + 1 | 0;
                 return main$0(counter$0,lexbuf)}
               return caml_trampoline_return(main$0,[0,lexbuf]);
              case 1:
               if(counter < 50)
                {var counter$1=counter + 1 | 0;
                 return main$0(counter$1,lexbuf)}
               return caml_trampoline_return(main$0,[0,lexbuf]);
              case 2:
               var
                _abX_=lexbuf[6],
                _abY_=lexbuf[5],
                id=sub_lexeme(lexbuf,_abY_,_abX_);
               try
                {var _abZ_=find(table,id);return _abZ_}
               catch(_ab3_)
                {_ab3_ = caml_wrap_exception(_ab3_);
                 if(_ab3_ === Not_found)return [1,id];
                 throw _ab3_}
              case 3:
               var
                _ab0_=lexbuf[6],
                _ab1_=lexbuf[5],
                n=sub_lexeme(lexbuf,_ab1_,_ab0_);
               return [0,caml_int_of_string(n)];
              case 4:return 10;
              case 5:return 4;
              case 6:return 13;
              case 7:return 6;
              case 8:return 15;
              case 9:return 11;
              case 10:return 12;
              case 11:return 14;
              case 12:return 9;
              case 13:return 7;
              case 14:return 23;
              case 15:return 21;
              case 16:return 3;
              case 17:return 25;
              case 18:return 22;
              case 19:return 19;
              case 20:return 24;
              case 21:return 26;
              case 22:return 8;
              case 23:return 2;
              case 24:return 20;
              default:
               var _ab2_=lexbuf[5],c=sub_lexeme_char(lexbuf,_ab2_);
               return lex_error(lexbuf,caml_call1(sprintf(_sP_),c))}}},
       main=function(lexbuf){return caml_trampoline(main$0(0,lexbuf))},
       parserfun_expr=traditional2revised$0(xexpr),
       parserfun_nexpr=traditional2revised$0(xnexpr),
       parserfun_form=traditional2revised$0(xform),
       parserfun_goal=traditional2revised$0(xgoal),
       lexbuf=function(reader){return get$5(reader)},
       from_string$1=
        function(data)
         {var _abV_=0;return create$11(0,from_string(_abV_,data))},
       lexer=
        function(lexbuf)
         {var token=main(lexbuf),_abU_=lexeme_end_p(lexbuf);
          return [0,token,lexeme_start_p(lexbuf),_abU_]},
       parse_expr=
        function(reader)
         {return caml_call1
                  (parserfun_expr,
                   function(param){return lexer(lexbuf(reader))})},
       parse_nexpr=
        function(reader)
         {return caml_call1
                  (parserfun_nexpr,
                   function(param){return lexer(lexbuf(reader))})},
       parse_form=
        function(reader)
         {return caml_call1
                  (parserfun_form,
                   function(param){return lexer(lexbuf(reader))})},
       parse_goal=
        function(reader)
         {return caml_call1
                  (parserfun_goal,
                   function(param){return lexer(lexbuf(reader))})},
       empty$11=function(env){return [0,env,empty$1]},
       LemmaNotFound=[248,_sQ_,caml_fresh_oo_id(0)],
       find$5=
        function(db,name)
         {var _abS_=[0,LemmaNotFound,name],_abT_=db[2];
          return get_exn(find_opt$0(name,_abT_),_abS_)},
       add$10=
        function(init,name,form)
         {var
           _abO_=from_string$1(form),
           form$0=parse_form(_abO_),
           _abP_=init[1],
           form$1=check$1(_abP_,form$0),
           _abQ_=init[2],
           _abR_=add$6(name,form$1,_abQ_);
          return [0,init[1],_abR_]},
       load=
        function(db,lemmas)
         {return fold
                  (function(db,param)
                    {var form=param[2],name=param[1];
                     return add$10(db,name,form)},
                   db,
                   lemmas)},
       all$1=function(db){return bindings(db[2])},
       fresh$2=function(param){return fresh(0)},
       ofint=function(i){return i},
       toint=function(t){return t},
       eq$0=function(_abN_,_abM_){return _abN_ === _abM_?1:0},
       InvalidGoalId=[248,_sR_,caml_fresh_oo_id(0)],
       InvalidHyphId=[248,_sS_,caml_fresh_oo_id(0)],
       SubgoalNotOpened=[248,_sT_,caml_fresh_oo_id(0)],
       empty$12=0,
       byid$0=
        function(hyps,id)
         {var _abL_=[0,InvalidHyphId,id];
          return get_exn(assoc$0(id,hyps),_abL_)},
       add$11=
        function(hyps,id,h)
         {var _abK_=assoc$0(id,hyps);
          if(is_none(_abK_))return [0,[0,id,h],hyps];
          throw [0,Assert_failure,_sU_]},
       remove$4=
        function(hyps,id)
         {return find_all$0
                  (function(param){var x=param[1];return 1 - eq$0(x,id)},hyps)},
       move=
        function(hyps,from,before)
         {var tg=byid$0(hyps,from),hyps$0=remove$4(hyps,from);
          if(before)
           {var
             before$0=before[1],
             _abF_=[0,InvalidHyphId,before$0],
             _abG_=
              function(param,_abJ_){var x=_abJ_[1];return eq$0(x,before$0)},
             _abH_=findi$0(_abG_,hyps$0),
             match=get_exn(_abH_,_abF_),
             pos=match[1],
             _abI_=1 + pos | 0,
             match$0=split_nth(_abI_,hyps$0),
             pre=match$0[2],
             post=match$0[1];
            return append(post,[0,[0,from,tg],pre])}
          return [0,[0,from,tg],hyps$0]},
       bump=
        function(hyps)
         {return map$4
                  (function(param)
                    {var h=param[2],id=param[1];
                     return [0,id,[0,h[1],h[2] + 1 | 0,h[3]]]},
                   hyps)},
       ids=function(hyps){return fst(hyps)},
       map$7=
        function(f,hyps)
         {return map$4(function(_abE_){return snd_map(f,_abE_)},hyps)},
       to_list$1=function(hyps){return hyps},
       mk_hyp=
        function(src,opt,form)
         {if(opt)var sth=opt[1],gen=sth;else var gen=0;
          return [0,src,gen,form]},
       init$2=
        function(env,hyps,goal)
         {recheck(env,goal);
          function _abt_(_abD_){return recheck(env,_abD_)}
          iter$0(_abt_,hyps);
          var _abu_=0,uid=fresh$2(_abu_);
          function _abv_(hs,f)
           {var _abz_=0,_abA_=0,_abB_=mk_hyp(_abA_,_abz_,f),_abC_=0;
            return add$11(hs,fresh$2(_abC_),_abB_)}
          var
           g_hyps=fold(_abv_,empty$12,hyps),
           root=[0,uid,[0,env,g_hyps,goal]],
           _abw_=empty$11(env),
           _abx_=[0,empty$1],
           _aby_=[0,uid,0];
          return [0,
                  uid,
                  singleton$2(uid,root),
                  _aby_,
                  empty$1,
                  empty$1,
                  _abx_,
                  _abw_]},
       db=function(proof){return proof[7]},
       loaddb=
        function(init,lemmas)
         {var _abr_=init[7],_abs_=load(_abr_,lemmas);
          return [0,init[1],init[2],init[3],init[4],init[5],init[6],_abs_]},
       closed=function(proof){return is_empty$2(proof[3])},
       opened=function(proof){return proof[3]},
       after$0=
        function(proof,id){var _abq_=proof[4];return find$2(id,_abq_)[2]},
       focused=function(proof,id){return hd(after$0(proof,id))},
       byid$1=
        function(proof,id)
         {var
           _abn_=[0,InvalidGoalId,id],
           _abo_=proof[2],
           _abp_=find$3(id,_abo_),
           goal=get_exn(_abp_,_abn_);
          return goal[2]},
       set_meta=
        function(proof,id,meta)
         {if(meta)
           {var meta$0=meta[1],_abj_=proof[6][1],_abk_=add$6(id,meta$0,_abj_);
            proof[6][1] = _abk_;
            return 0}
          var _abl_=proof[6][1],_abm_=remove$2(id,_abl_);
          proof[6][1] = _abm_;
          return 0},
       get_meta=function(proof,id){return find$3(id,proof[6][1])},
       hprogress=
        function(pr,id,pn,sub)
         {byid$1(pr,id);
          var
           _aa2_=0,
           g_id=fresh$2(_aa2_),
           _aa3_=sub[2],
           hyps=bump(_aa3_),
           sub$0=[0,sub[1],hyps,sub[3]],
           sub$1=[0,g_id,sub$0];
          try
           {var
             _aa4_=pr[3],
             _aa5_=function(_abi_){return eq$0(id,_abi_)},
             match=pivot(_aa5_,_aa4_)}
          catch(_abh_)
           {_abh_ = caml_wrap_exception(_abh_);
            if(_abh_[1] === Invalid_argument)throw [0,SubgoalNotOpened,id];
            throw _abh_}
          var
           go=match[3],
           gr=match[1],
           dep=[0,id,[0,g_id,0],pn],
           _aa6_=pr[6][1],
           match$0=find$3(id,_aa6_);
          if(match$0)
           var meta=match$0[1],_aa7_=pr[6][1],meta$0=add$6(g_id,meta,_aa7_);
          else
           var meta$0=pr[6][1];
          var
           _aa8_=pr[2],
           _aa9_=sub$1[1],
           map=add$6(_aa9_,sub$1,_aa8_),
           _aa__=pr[7],
           _aa$_=[0,meta$0],
           _aba_=pr[5],
           _abb_=add$6(g_id,dep,_aba_),
           _abc_=pr[4],
           _abd_=add$6(id,dep,_abc_),
           _abe_=[0,g_id,0],
           _abf_=append(_abe_,go),
           _abg_=append(gr,_abf_);
          return [0,g_id,[0,pr[1],map,_abg_,_abd_,_abb_,_aa$_,_aa__]]},
       xprogress=
        function(pr,id,pn,sub)
         {byid$1(pr,id);
          function for1(sub)
           {var
             _aa0_=sub[2],
             hyps=bump(_aa0_),
             sub$0=[0,sub[1],hyps,sub[3]],
             _aa1_=0;
            return [0,fresh$2(_aa1_),sub$0]}
          var sub$0=map$4(for1,sub);
          function _aaG_(x){return x[1]}
          var sids=map$4(_aaG_,sub$0);
          try
           {var
             _aaH_=pr[3],
             _aaI_=function(_aaZ_){return eq$0(id,_aaZ_)},
             match=pivot(_aaI_,_aaH_)}
          catch(_aaY_)
           {_aaY_ = caml_wrap_exception(_aaY_);
            if(_aaY_[1] === Invalid_argument)throw [0,SubgoalNotOpened,id];
            throw _aaY_}
          var
           go=match[3],
           gr=match[1],
           dep=[0,id,sids,pn],
           _aaJ_=pr[6][1],
           match$0=find$3(id,_aaJ_);
          if(match$0)
           var
            meta=match$0[1],
            _aaK_=pr[6][1],
            _aaL_=function(map,id){return add$6(id,meta,map)},
            meta$0=fold(_aaL_,_aaK_,sids);
          else
           var meta$0=pr[6][1];
          var _aaM_=pr[2];
          function _aaN_(sub,map){return add$6(sub[1],sub,map)}
          var
           map=fold_right$1(_aaN_,sub$0,_aaM_),
           _aaO_=pr[7],
           _aaP_=[0,meta$0],
           _aaQ_=pr[5];
          function _aaR_(_aaX_){return symbol$4(add$6,dep,_aaX_)}
          var
           _aaS_=fold_right$1(_aaR_,sids,_aaQ_),
           _aaT_=pr[4],
           _aaU_=add$6(id,dep,_aaT_),
           _aaV_=append(sids,go),
           _aaW_=append(gr,_aaV_);
          return [0,pr[1],map,_aaW_,_aaU_,_aaS_,_aaP_,_aaO_]},
       sgprogress=
        function(goal,opt,sub)
         {if(opt)var sth=opt[1],clear=sth;else var clear=0;
          function for1(param)
           {var concl=param[2],newlc=param[1];
            function subfor1(hyps,param)
             {var newlc=param[2],hid=param[1];
              function _aaB_(hyps,hid)
               {byid$0(hyps,hid);return clear?remove$4(hyps,hid):hyps}
              var hyps$0=fold$3(_aaB_,hyps,hid),hsrc=clear?0:hid;
              function _aaC_(hyps,newh)
               {var _aaD_=0,_aaE_=mk_hyp(hsrc,_aaD_,newh),_aaF_=0;
                return add$11(hyps,fresh$2(_aaF_),_aaE_)}
              var hyps$1=fold(_aaC_,hyps$0,newlc);
              return hyps$1}
            var _aaA_=goal[2],hyps=fold(subfor1,_aaA_,newlc);
            return [0,goal[1],hyps,concl]}
          return map$4(for1,sub)},
       sprogress=
        function(pr,opt,id)
         {if(opt)var sth=opt[1],clear=sth;else var clear=0;
          return function(pn,sub)
           {var
             goal=byid$1(pr,id),
             _aaz_=[0,clear],
             sub$0=sgprogress(goal,_aaz_,sub);
            return xprogress(pr,id,pn,sub$0)}},
       progress=
        function(pr,id,pn,sub)
         {var goal=byid$1(pr,id);
          function _aay_(x){return [0,goal[1],goal[2],x]}
          var sub$0=map$4(_aay_,sub);
          return xprogress(pr,id,pn,sub$0)},
       TacticNotApplicable=[248,_sV_,caml_fresh_oo_id(0)],
       TId=[248,_sW_,caml_fresh_oo_id(0)],
       id_tac=
        function(param)
         {var id=param[2],pr=param[1],_aax_=0;
          return xprogress(pr,id,TId,[0,byid$1(pr,id),_aax_])},
       then_tac=
        function(t1,t2,targ)
         {var id=targ[2],pr=caml_call1(t1,targ),hd=focused(pr,id);
          return caml_call1(t2,[0,pr,hd])},
       doit$1=
        function(acc,f)
         {var acc$0=acc,f$0=f;
          for(;;)
           {if(typeof f$0 !== "number" && 1 === f$0[0] && 3654636 === f$0[1])
             {var _aav_=f$0[2];
              if(_aav_)
               {var _aaw_=_aav_[2];
                if(_aaw_ && ! _aaw_[2])
                 {var
                   f$1=_aaw_[1],
                   f1=_aav_[1],
                   acc$1=[0,f1,acc$0],
                   acc$0=acc$1,
                   f$0=f$1;
                  continue}}}
            return [0,rev(acc$0),f$0]}},
       prune_premisses=function(f){return doit$1(0,f)},
       doit$2=
        function(i,acc,s,f)
         {var i$0=i,acc$0=acc,s$0=s,f$0=f;
          for(;;)
           {if(typeof f$0 !== "number")
             switch(f$0[0])
              {case 1:
                if(3654636 === f$0[1])
                 {var _aat_=f$0[2];
                  if(_aat_)
                   {var _aau_=_aat_[2];
                    if(_aau_ && ! _aau_[2])
                     {var
                       f$1=_aau_[1],
                       f1=_aat_[1],
                       acc$1=[0,[0,i$0,f1],acc$0],
                       acc$0=acc$1,
                       f$0=f$1;
                      continue}}}
                break;
               case 2:
                if(840561112 === f$0[1])
                 {var
                   f$2=f$0[4],
                   x=f$0[2],
                   s$1=[0,[0,x,0],s$0],
                   i$1=i$0 + 1 | 0,
                   i$0=i$1,
                   s$0=s$1,
                   f$0=f$2;
                  continue}
                break
               }
            return [0,rev(acc$0),f$0,s$0]}},
       prune_premisses_fa=
        function(f)
         {var
           _aaq_=0,
           _aar_=0,
           _aas_=0,
           match=doit$2(_aas_,_aar_,_aaq_,f),
           s=match[3],
           hy=match[2],
           pre=match[1];
          return [0,pre,hy,oflist(s)]},
       doit$3=
        function(i,acc,s,f)
         {var s$0=s,f$0=f;
          for(;;)
           {if
             (typeof f$0 !== "number" && 2 === f$0[0] && 172470935 === f$0[1])
             {var f$1=f$0[4],x=f$0[2],s$1=[0,[0,x,0],s$0],s$0=s$1,f$0=f$1;
              continue}
            return [0,rev(acc),f$0,s$0]}},
       prune_premisses_ex=
        function(f)
         {var
           _aan_=0,
           _aao_=0,
           _aap_=0,
           match=doit$3(_aap_,_aao_,_aan_,f),
           s=match[3],
           hy=match[2],
           pre=match[1];
          return [0,pre,hy,oflist(s)]},
       remove_form=
        function(env,f,param)
         {if(param)
           {var g=param[1],l=param[2],_aam_=0;
            if(caml_call1(f_equal(_aam_,env,g),f))return l;
            var l$0=param[2];
            return [0,g,remove_form(env,f,l$0)]}
          throw TacticNotApplicable},
       TDef=[248,_sX_,caml_fresh_oo_id(0)],
       add_local=
        function(param,_$2_)
         {var
           hd=_$2_[2],
           proof=_$2_[1],
           body=param[3],
           ty=param[2],
           name=param[1],
           goal=byid$1(proof,hd),
           _$3_=0,
           _$4_=goal[1];
          function _$5_(_aal_){return erecheck(_$4_,ty,_aal_)}
          map_default(_$5_,_$3_,body);
          var
           _$6_=[0,name,[0,ty,body]],
           _$7_=goal[1],
           g_env=push$4(_$7_,_$6_),
           _$8_=[0,name,0],
           _$9_=0;
          function _$__(_aak_){return e_shift(_$9_,_$8_,_aak_)}
          function _$$_(_aaj_){return map$3(_$__,_aaj_)}
          var g_env$0=map$6(g_env,_$$_),_aaa_=goal[2];
          function _aab_(init)
           {var
             _aaf_=init[3],
             _aag_=[0,name,0],
             _aah_=0,
             _aai_=f_shift(_aah_,_aag_,_aaf_);
            return [0,init[1],init[2],_aai_]}
          var
           g_hyps=map$7(_aab_,_aaa_),
           _aac_=goal[3],
           _aad_=[0,name,0],
           _aae_=0,
           g_goal=f_shift(_aae_,_aad_,_aac_);
          return xprogress
                  (proof,
                   hd,
                   [0,TDef,[0,ty,body],hd],
                   [0,[0,g_env$0,g_hyps,g_goal],0])},
       TIntro=[248,_sY_,caml_fresh_oo_id(0)],
       intro=
        function(opt,param)
         {var id=param[2],pr=param[1];
          if(opt)var sth=opt[1],variant=sth;else var variant=_s0_;
          var
           pterm=[0,TIntro,variant],
           goal=byid$1(pr,id),
           g_env=goal[1],
           _$C_=byid$1(pr,id)[3],
           _$D_=variant[1],
           switch$0=0;
          if(0 === _$D_)
           {var _$E_=variant[2];
            if(_$E_)
             {var switch$1=0;
              if(typeof _$C_ !== "number" && 2 === _$C_[0])
               {if(172470935 === _$C_[1])
                 {var
                   body=_$C_[4],
                   xty=_$C_[3],
                   x=_$C_[2],
                   match=_$E_[1],
                   ety=match[2],
                   e=match[1],
                   goal$0=byid$1(pr,id),
                   _$F_=goal$0[1];
                  erecheck(_$F_,ety,e);
                  var _$G_=goal$0[1],_$H_=0;
                  if(1 - t_equal(_$H_,_$G_,xty,ety))throw TacticNotApplicable;
                  var _$I_=[0,x,0],goal$1=f_apply1(_$I_,e,body);
                  return caml_call2
                          (sprogress(pr,0,id),pterm,[0,[0,0,goal$1],0])}
                switch$1 = 1}}
            else
             if(typeof _$C_ === "number")
              {if(0 === _$C_)return progress(pr,id,pterm,0)}
             else
              switch(_$C_[0])
               {case 0:
                 if(! caml_string_notequal(_$C_[1],_sZ_))
                  {var _$J_=_$C_[2];
                   if(_$J_)
                    {var _$K_=_$J_[2];
                     if(_$K_ && ! _$K_[2])
                      {var e2=_$K_[1],e1=_$J_[1],_$L_=0;
                       if(e_equal(_$L_,g_env,e1,e2))return progress(pr,id,pterm,0)}}}
                 break;
                case 1:
                 var _$M_=_$C_[1];
                 if(3654637 <= _$M_)
                  if(3903731 === _$M_)
                   {var _$N_=_$C_[2];
                    if(_$N_ && ! _$N_[2])
                     {var f=_$N_[1];
                      return caml_call2
                              (sprogress(pr,0,id),pterm,[0,[0,[0,[0,0,[0,f,0]],0],1],0])}}
                  else
                   if(95438486 === _$M_)
                    {var _$O_=_$C_[2];
                     if(_$O_)
                      {var _$P_=_$O_[2];
                       if(_$P_ && ! _$P_[2])
                        {var
                          f2=_$P_[1],
                          f1=_$O_[1],
                          _$Q_=0,
                          _$R_=[0,f_imp(f2,f1),_$Q_];
                         return progress(pr,id,pterm,[0,f_imp(f1,f2),_$R_])}}}
                   else
                    switch$0 = 1;
                 else
                  if(3257015 === _$M_)
                   {var _$S_=_$C_[2];
                    if(_$S_)
                     {var _$T_=_$S_[2];
                      if(_$T_ && ! _$T_[2])
                       {var f2$0=_$T_[1],f1$0=_$S_[1];
                        return progress(pr,id,pterm,[0,f1$0,[0,f2$0,0]])}}}
                  else
                   if(3654636 <= _$M_)
                    {var _$U_=_$C_[2];
                     if(_$U_)
                      {var _$V_=_$U_[2];
                       if(_$V_ && ! _$V_[2])
                        {var f2$1=_$V_[1],f1$1=_$U_[1];
                         return caml_call2
                                 (sprogress(pr,0,id),
                                  pterm,
                                  [0,[0,[0,[0,0,[0,f1$1,0]],0],f2$1],0])}}}
                   else
                    switch$0 = 1;
                 break;
                default:
                 if(840561112 === _$C_[1])
                  {var
                    body$0=_$C_[4],
                    xty$0=_$C_[3],
                    x$0=_$C_[2],
                    _$W_=[0,pr,id],
                    _$X_=
                     function(param)
                      {var id=param[2],pr=param[1];
                       return progress(pr,id,pterm,[0,body$0,0])},
                    _$Y_=[0,x$0,xty$0,0],
                    _$Z_=function(_$1_){return add_local(_$Y_,_$1_)};
                   return function(_$0_){return then_tac(_$Z_,_$X_,_$0_)}(_$W_)}}}
          else
           switch$0 = 1;
          if(switch$0 && ! variant[2])
           {var switch$2=0;
            if(typeof _$C_ === "number" || ! (1 === _$C_[0]))
             switch$2 = 1;
            else
             if(17731 === _$C_[1])
              {var fl=flatten_disjunctions(_$C_),g=nth(fl,_$D_);
               return progress(pr,id,pterm,[0,g,0])}}
          throw TacticNotApplicable},
       OrDrop=[248,_s1_,caml_fresh_oo_id(0)],
       or_drop=
        function(h,param,hl)
         {var id=param[2],pr=param[1],gl=byid$1(pr,id),_$A_=gl[2];
          byid$0(_$A_,h);
          var _$B_=gl[3];
          flatten_disjunctions(_$B_);
          return caml_call2(sprogress(pr,0,id),[0,OrDrop,id],hl)},
       AndDrop=[248,_s2_,caml_fresh_oo_id(0)],
       and_drop=
        function(h,param)
         {var
           id=param[2],
           pr=param[1],
           gl=byid$1(pr,id),
           _$w_=gl[2],
           hy=byid$0(_$w_,h)[3],
           _$x_=gl[3],
           gll=flatten_conjunctions(_$x_),
           _$y_=gl[1],
           _$z_=remove_form(_$y_,hy,gll),
           ng=f_ands(_$z_);
          return caml_call2
                  (sprogress(pr,0,id),[0,AndDrop,id],[0,[0,_s3_,ng],0])},
       TElim=[248,_s4_,caml_fresh_oo_id(0)],
       core_elim=
        function(h,param)
         {var
           id=param[2],
           pr=param[1],
           result=[0,0],
           gl=byid$1(pr,id),
           __M_=gl[2],
           hyp=byid$0(__M_,h)[3],
           __N_=gl[3],
           __O_=gl[1],
           __P_=0;
          if(caml_call1(f_equal(__P_,__O_,hyp),__N_))
           result[1] = [0,[0,[0,TElim,id],_s5_],0];
          else
           {var
             match=prune_premisses_fa(hyp),
             s=match[3],
             hy=match[2],
             pre=match[1],
             __Q_=[0,[0,hy,gl[3]],0],
             __R_=gl[1],
             match$0=caml_call1(f_unify(__R_,empty$8,s),__Q_);
            if(match$0)
             {var s$0=match$0[1];
              if(is_complete(s$0))
               {var
                 __S_=
                  function(param)
                   {var x=param[2],i=param[1];
                    return [0,[0,[0,[0,h],0],0],f_iter(s$0,i,x)]},
                 pres=map$4(__S_,pre);
                result[1] = [0,[0,[0,TElim,id],[0,83,pres]],result[1]]}}
            var
             __T_=
              function(param){var f=param[2];return [0,[0,[0,[0,h],0],0],f]},
             subs=map$4(__T_,pre),
             switch$0=0;
            if(typeof hy === "number")
             if(0 === hy)
              {var __U_=result[1],__V_=[0,[0,[0,[0,[0,h],0],0],gl[3]],0];
               result[1] = [0,[0,[0,TElim,id],[0,83,append(subs,__V_)]],__U_];
               switch$0 = 1}
             else
              {result[1] = [0,[0,[0,TElim,id],[0,83,subs]],result[1]];
               switch$0 = 1}
            else
             switch(hy[0])
              {case 1:
                var __0_=hy[1],switch$1=0;
                if(3257016 <= __0_)
                 if(3903731 === __0_)
                  {var __1_=hy[2];
                   if(__1_ && ! __1_[2])
                    {var
                      f=__1_[1],
                      __2_=result[1],
                      __3_=[0,[0,[0,[0,[0,h],0],0],f],0];
                     result[1]
                     =
                     [0,[0,[0,TElim,id],[0,83,append(subs,__3_)]],__2_]}
                   else
                    switch$1 = 1}
                 else
                  if(95438486 === __0_)
                   {var __4_=hy[2];
                    if(__4_)
                     {var __5_=__4_[2];
                      if(__5_ && ! __5_[2])
                       {var
                         f2=__5_[1],
                         f1=__4_[1],
                         __6_=result[1],
                         __7_=0,
                         __8_=gl[3],
                         __9_=0,
                         ____=0,
                         __$_=[0,f_imp(f2,f1),____],
                         _$a_=
                          [0,[0,[0,[0,[0,h],[0,f_imp(f1,f2),__$_]],__9_],__8_],__7_];
                        result[1]
                        =
                        [0,[0,[0,TElim,id],[0,83,append(subs,_$a_)]],__6_]}
                      else
                       switch$1 = 1}
                    else
                     switch$1 = 1}
                  else
                   switch$1 = 1;
                else
                 if(17731 === __0_)
                  {var _$b_=hy[2];
                   if(_$b_)
                    {var _$c_=_$b_[2];
                     if(_$c_ && ! _$c_[2])
                      {var
                        f2$0=_$c_[1],
                        f1$0=_$b_[1],
                        _$d_=result[1],
                        _$e_=
                         [0,
                          [0,[0,[0,[0,h],[0,f1$0,0]],0],gl[3]],
                          [0,[0,[0,[0,[0,h],[0,f2$0,0]],0],gl[3]],0]];
                       result[1]
                       =
                       [0,[0,[0,TElim,id],[0,83,append(subs,_$e_)]],_$d_]}
                     else
                      switch$1 = 1}
                   else
                    switch$1 = 1}
                 else
                  if(3257015 <= __0_)
                   {var _$f_=hy[2];
                    if(_$f_)
                     {var _$g_=_$f_[2];
                      if(_$g_ && ! _$g_[2])
                       {var
                         f2$1=_$g_[1],
                         f1$1=_$f_[1],
                         _$h_=result[1],
                         _$i_=[0,[0,[0,[0,[0,h],[0,f1$1,[0,f2$1,0]]],0],gl[3]],0];
                        result[1]
                        =
                        [0,[0,[0,TElim,id],[0,83,append(subs,_$i_)]],_$h_]}
                      else
                       switch$1 = 1}
                    else
                     switch$1 = 1}
                  else
                   switch$1 = 1;
                if(! switch$1)switch$0 = 1;
                break;
               case 2:
                if(172470935 === hy[1])
                 {var
                   f$0=hy[4],
                   ty=hy[3],
                   x=hy[2],
                   _$j_=[0,pr,id],
                   _$k_=
                    function(param)
                     {var
                       id=param[2],
                       pr=param[1],
                       goal=byid$1(pr,id),
                       _$s_=goal[2],
                       g_hyps=remove$4(_$s_,h),
                       _$t_=0,
                       _$u_=0,
                       _$v_=mk_hyp(_$u_,_$t_,f$0),
                       g_hyps$0=add$11(g_hyps,h,_$v_),
                       goal$0=[0,goal[1],g_hyps$0,goal[3]];
                      result[1]
                      =
                      [0,[0,[0,TElim,id],[0,88,[0,goal$0,0]]],result[1]];
                      return pr},
                   _$l_=[0,x,ty,0],
                   _$m_=function(_$r_){return add_local(_$l_,_$r_)},
                   _$n_=function(_$q_){return then_tac(_$m_,_$k_,_$q_)};
                  _$n_(_$j_);
                  switch$0 = 1}
                break
               }
            var
             __W_=gl[3],
             match$1=prune_premisses_ex(__W_),
             s$1=match$1[3],
             goal=match$1[2],
             match$2=prune_premisses(hyp),
             hy$0=match$2[2],
             pre$0=match$2[1],
             __X_=function(x){return [0,[0,[0,[0,h],0],0],x]},
             pre$1=map$4(__X_,pre$0),
             __Y_=[0,[0,hy$0,goal],0],
             __Z_=gl[1],
             match$3=caml_call1(f_unify(__Z_,empty$8,s$1),__Y_);
            if(match$3)
             {var s$2=match$3[1];
              if(is_complete(s$2))
               result[1] = [0,[0,[0,TElim,id],[0,83,pre$1]],result[1]]}
            else
             {var switch$2=0;
              if
               (typeof goal
                !==
                "number"
                &&
                1
                ===
                goal[0]
                &&
                17731
                ===
                goal[1])
               {var
                 gll=flatten_disjunctions(goal),
                 aux=
                  function(param)
                   {var param$0=param;
                    for(;;)
                     {if(param$0)
                       {var
                         l=param$0[2],
                         g=param$0[1],
                         _$o_=[0,[0,hyp,g],0],
                         _$p_=gl[1],
                         match=caml_call1(f_unify(_$p_,empty$8,s$1),_$o_);
                        if(match){var s=match[1];if(is_complete(s))return 1}
                        var param$0=l;
                        continue}
                      return 0}};
                if(aux(gll))result[1] = [0,[0,[0,TElim,id],_s6_],result[1]];
                switch$2 = 1}}}
          return result[1]},
       perform=
        function(clear,l,pr,id)
         {if(l)
           {var __I_=l[1],__J_=__I_[2];
            if(typeof __J_ !== "number")
             {var __K_=__J_[1],__L_=__I_[1];
              if(83 === __K_)
               {var l$0=__J_[2];
                return caml_call2(sprogress(pr,clear,id),__L_,l$0)}
              if(88 === __K_)
               {var l$1=__J_[2];return xprogress(pr,id,__L_,l$1)}}}
          throw TacticNotApplicable},
       arg$0=
        function(clear,h,param)
         {var id=param[2],pr=param[1],__H_=[0,pr,id];
          return perform(clear,core_elim(h,__H_),pr,id)},
       TInd=[248,_s7_,caml_fresh_oo_id(0)],
       induction=
        function(h,param)
         {var
           id=param[2],
           pr=param[1],
           init=byid$1(pr,id),
           env=init[1],
           __n_=toint(h),
           __o_=byid(env,__n_),
           match=get$3(__o_),
           x=match[1],
           n=x[1],
           __p_=init[3],
           __q_=init[2],
           __r_=[0,x,[0,nat,[0,zero$3]]],
           base_case=[0,modify$1(env,__r_),__q_,__p_],
           __s_=0,
           __t_=[0,n],
           n$0=fresh$0(env,__t_,__s_),
           __u_=init[3],
           __v_=init[3],
           __w_=[0,[0,n$0,0]],
           indh=f_apply1(x,__w_,__v_),
           __x_=0,
           __y_=0,
           __z_=mk_hyp(__y_,__x_,indh),
           __A_=0,
           __B_=fresh$2(__A_),
           __C_=init[2],
           __D_=add$11(__C_,__B_,__z_),
           __E_=[0,n$0,[0,nat,0]],
           env$0=push$4(env,__E_),
           __F_=[0,[0,n$0,0]],
           __G_=[0,x,[0,nat,[0,succ$3(__F_)]]],
           ind_case=[0,modify$1(env$0,__G_),__D_,__u_];
          return xprogress(pr,id,TInd,[0,base_case,[0,ind_case,0]])},
       ivariants=
        function(param)
         {var id=param[2],pr=param[1],__l_=byid$1(pr,id)[3];
          if(typeof __l_ === "number")
           {if(0 === __l_)return _s8_}
          else
           switch(__l_[0])
            {case 0:if(! caml_string_notequal(__l_[1],_s9_))return _s__;break;
             case 1:
              var __m_=__l_[1];
              if(3257015 === __m_)return _s$_;
              if(3903731 <= __m_)return 95438486 <= __m_?_ta_:_tb_;
              if(3654636 <= __m_)return _tc_;
              var fl=flatten_disjunctions(__l_);
              return mapi(function(i,param){return cat(_td_,to_string(i))},fl);
             default:return 840561112 <= __l_[1]?_te_:_tf_}
          return 0},
       TForward=[248,_tg_,caml_fresh_oo_id(0)],
       core_forward=
        function(param,_ZZ_)
         {var
           id=_ZZ_[2],
           pr=_ZZ_[1],
           s=param[4],
           p=param[3],
           hdst=param[2],
           hsrc=param[1],
           gl=byid$1(pr,id),
           _Z0_=gl[2];
          byid$0(_Z0_,hsrc);
          var _Z1_=gl[2],dst=byid$0(_Z1_,hdst)[3];
          function build_dest(param)
           {var param$0=param;
            for(;;)
             {var _Z3_=param$0[1],switch$0=0;
              if(typeof _Z3_ === "number")
               switch$0 = 1;
              else
               switch(_Z3_[0])
                {case 0:switch$0 = 1;break;
                 case 1:
                  if(3654636 === _Z3_[1])
                   {var _Z4_=_Z3_[2];
                    if(_Z4_)
                     {var _Z5_=_Z4_[2];
                      if(_Z5_ && ! _Z5_[2])
                       {var _Z6_=param$0[2];
                        if(_Z6_)
                         {var _Z7_=_Z6_[1],_Z8_=_Z5_[1],_Z9_=_Z4_[1];
                          if(0 === _Z7_)
                           {var s=param$0[3];return f_apply(oflist(s),_Z8_)}
                          if(1 === _Z7_)
                           {var
                             s$0=param$0[3],
                             p=_Z6_[2],
                             _Z__=0,
                             _Z$_=[0,_Z8_,p,s$0],
                             __a_=[0,build_dest(_Z$_),_Z__],
                             __b_=oflist(s$0);
                            return [1,3654636,[0,f_apply(__b_,_Z9_),__a_]]}}}}}
                  break;
                 default:
                  if(840561112 === _Z3_[1])
                   {var __c_=param$0[2];
                    if(__c_ && 0 === __c_[1])
                     {var __d_=param$0[3];
                      if(__d_)
                       {var
                         __e_=__d_[1][2],
                         __f_=__c_[2],
                         __g_=_Z3_[4],
                         __i_=_Z3_[2],
                         __h_=_Z3_[3];
                        if(__e_)
                         {var
                           s$1=__d_[2],
                           e=__e_[1],
                           __j_=[0,__i_,0],
                           param$1=[0,f_apply1(__j_,e,__g_),__f_,s$1],
                           param$0=param$1;
                          continue}
                        var s$2=__d_[2],__k_=[0,__g_,__f_,s$2];
                        return [2,840561112,__i_,__h_,build_dest(__k_)]}}}}
              return failwith(_th_)}}
          var _Z2_=[0,dst,p,s],nf=build_dest(_Z2_);
          return [0,
                  [0,
                   [0,TForward,hsrc,hdst],
                   [0,83,[0,[0,[0,[0,[0,hdst],[0,nf,0]],0],gl[3]],0]]],
                  0]},
       forward=
        function(param,_ZW_)
         {var
           id=_ZW_[2],
           pr=_ZW_[1],
           s=param[4],
           p=param[3],
           hdst=param[2],
           hsrc=param[1],
           _ZX_=[0,pr,id],
           _ZY_=[0,hsrc,hdst,p,aslist(s)];
          return perform(0,core_forward(_ZY_,_ZX_),pr,id)},
       TCut=[248,_ti_,caml_fresh_oo_id(0)],
       cut=
        function(form,param)
         {var hd=param[2],proof=param[1],goal=byid$1(proof,hd),_ZT_=goal[1];
          recheck(_ZT_,form);
          var
           subs=[0,[0,0,form],0],
           _ZU_=[0,[0,[0,[0,0,[0,form,0]],0],goal[3]],0],
           _ZV_=append(subs,_ZU_);
          return caml_call2(sprogress(proof,0,hd),[0,TCut,form,hd],_ZV_)},
       TAssume=[248,_tj_,caml_fresh_oo_id(0)],
       assume=
        function(form,param)
         {var hd=param[2],proof=param[1],goal=byid$1(proof,hd),_ZR_=goal[1];
          recheck(_ZR_,form);
          var _ZS_=[0,[0,[0,[0,0,[0,form,0]],0],goal[3]],0];
          return caml_call2(sprogress(proof,0,hd),[0,TAssume,form,hd],_ZS_)},
       TGeneralize=[248,_tk_,caml_fresh_oo_id(0)],
       generalize=
        function(hid,param)
         {var
           id=param[2],
           proof=param[1],
           goal=byid$1(proof,id),
           _ZM_=goal[2],
           hyp=byid$0(_ZM_,hid)[3],
           _ZN_=0,
           _ZO_=[1,3654636,[0,hyp,[0,goal[3],0]]],
           _ZP_=goal[2],
           _ZQ_=remove$4(_ZP_,hid);
          return xprogress
                  (proof,
                   id,
                   [0,TGeneralize,hid],
                   [0,[0,goal[1],_ZQ_,_ZO_],_ZN_])},
       TMove=[248,_tl_,caml_fresh_oo_id(0)],
       move$0=
        function(from,before,param)
         {var id=param[2],proof=param[1],goal=byid$1(proof,id),_ZI_=goal[2];
          function _ZJ_(_ZL_){return byid$0(_ZI_,_ZL_)}
          map$3(_ZJ_,before);
          var _ZK_=goal[2],hyps=move(_ZK_,from,before);
          return xprogress
                  (proof,
                   id,
                   [0,TMove,from,before],
                   [0,[0,goal[1],hyps,goal[3]],0])},
       TDuplicate=[248,_tm_,caml_fresh_oo_id(0)],
       duplicate=
        function(hd,param)
         {var
           id=param[2],
           proof=param[1],
           goal=byid$1(proof,id),
           _ZH_=goal[2],
           form=byid$0(_ZH_,hd)[3],
           subgoal=[0,[0,[0,[0,hd],[0,form,0]],0],goal[3]];
          return caml_call2
                  (sprogress(proof,0,id),[0,TDuplicate,hd],[0,subgoal,0])},
       close_with_unit=
        function(targ)
         {var g_id=targ[2],proof=targ[1],goal=byid$1(proof,g_id);
          if(0 === goal[3])return intro(0,targ);
          var _ZA_=goal[2],_ZB_=to_list$1(_ZA_);
          function _ZC_(param)
           {var match=param[2],f=match[3],hd=param[1];
            if(1 === f){var _ZG_=0;return [0,arg$0(_ZG_,hd,targ)]}
            return 0}
          var _ZD_=find_map_opt(_ZC_),_ZE_=caml_call1(_ZD_,_ZB_);
          return function(_ZF_){return default$0(proof,_ZF_)}(_ZE_)},
       form_of_item=
        function(param)
         {if(typeof param !== "number")
           {var _Zz_=param[1],switch$0=0;
            if(67 === _Zz_)
             {var f=param[2];switch$0 = 1}
            else
             if(72 === _Zz_){var f=param[2][2][3];switch$0 = 1}
            if(switch$0)return f}
          throw [0,Invalid_argument,_tn_]},
       expr_of_item=
        function(opt,param)
         {if(opt)var sth=opt[1],where=sth;else var where=737453762;
          if(typeof param !== "number" && 86 === param[1])
           {var _Zy_=param[2],match=_Zy_[2],b=match[2],x=_Zy_[1];
            return 803493184 <= where
                    ?[0,x]
                    :get_exn(b,[0,Invalid_argument,_tp_])}
          throw [0,Invalid_argument,_to_]},
       term_of_item=
        function(where,it)
         {try
           {var _Zv_=[0,70,form_of_item(it)];return _Zv_}
          catch(_Zw_)
           {_Zw_ = caml_wrap_exception(_Zw_);
            if(_Zw_[1] === Invalid_argument)
             try
              {var _Zu_=[0,69,expr_of_item(where,it)];return _Zu_}
             catch(_Zx_)
              {_Zx_ = caml_wrap_exception(_Zx_);
               if(_Zx_[1] === Invalid_argument)
                throw [0,Invalid_argument,_tq_];
               throw _Zx_}
            throw _Zw_}},
       InvalidPath=[248,_tr_,caml_fresh_oo_id(0)],
       InvalidSubFormPath=[248,_ts_,caml_fresh_oo_id(0)],
       InvalidSubExprPath=[248,_tt_,caml_fresh_oo_id(0)],
       direct_subterm=
        function(t,i)
         {try
           {var _Zr_=direct_subterms(t),_Zs_=nth(_Zr_,i);return _Zs_}
          catch(_Zt_)
           {_Zt_ = caml_wrap_exception(_Zt_);
            if(_Zt_[1] === Invalid_argument)
             {if(70 <= t[1])
               {var switch$0=0,_Zq_=t[2];
                if(typeof _Zq_ !== "number" && 0 === _Zq_[0])switch$0 = 1;
                if(! switch$0)throw [0,InvalidSubFormPath,[0,i,0]]}
              throw [0,InvalidSubExprPath,[0,i,0]]}
            throw _Zt_}},
       subterm=
        function(t,p)
         {try
           {var _Zo_=fold(direct_subterm,t,p);return _Zo_}
          catch(_Zp_)
           {_Zp_ = caml_wrap_exception(_Zp_);
            if(_Zp_[1] === InvalidSubFormPath)throw [0,InvalidSubFormPath,p];
            if(_Zp_[1] === InvalidSubExprPath)throw [0,InvalidSubExprPath,p];
            throw _Zp_}},
       modify_direct_subterm=
        function(f,t,i)
         {try
           {var
             _Zi_=direct_subterms(t),
             _Zj_=modify_at(i,f,_Zi_),
             _Zk_=function(_Zn_){return modify_direct_subterms(t,_Zn_)},
             _Zl_=_Zk_(_Zj_);
            return _Zl_}
          catch(_Zm_)
           {_Zm_ = caml_wrap_exception(_Zm_);
            if(_Zm_[1] === Invalid_argument)
             {if(70 <= t[1])
               {var switch$0=0,_Zh_=t[2];
                if(typeof _Zh_ !== "number" && 0 === _Zh_[0])switch$0 = 1;
                if(! switch$0)throw [0,InvalidSubFormPath,[0,i,0]]}
              throw [0,InvalidSubExprPath,[0,i,0]]}
            throw _Zm_}},
       modify_subterm=
        function(f,acc,a,t,p)
         {function aux(a,t,param)
           {if(param)
             {var
               p=param[2],
               i=param[1],
               _Zf_=direct_subterm(t,i),
               _Zg_=caml_call3(acc,i,t,a),
               subt=aux(_Zg_,_Zf_,p);
              return modify_direct_subterm(function(param){return subt},t,i)}
            return caml_call2(f,a,t)}
          return aux(a,t,p)},
       rewrite_subterm_all=
        function(env,red,res)
         {var _Y8_=[0,red,res];
          function _Y9_(param,t,_Zd_)
           {var res=_Zd_[2],red=_Zd_[1],_Ze_=shift_under(t,res);
            return [0,shift_under(t,red),_Ze_]}
          function _Y__(param)
           {var res=param[2],red=param[1],_Zb_=0;
            return function(_Zc_){return rewrite(_Zb_,env,red,res,_Zc_)}}
          return function(_Y$_,_Za_)
           {return modify_subterm(_Y__,_Y9_,_Y8_,_Y$_,_Za_)}},
       rewrite_subterm=
        function(res)
         {function _Y4_(param,t,res){return shift_under(t,res)}
          function _Y5_(res,param){return res}
          return function(_Y6_,_Y7_)
           {return modify_subterm(_Y5_,_Y4_,res,_Y6_,_Y7_)}},
       subexpr=
        function(t,p)
         {var match=subterm(t,p);
          if(typeof match !== "number" && 69 === match[1])
           {var e=match[2];return e}
          throw [0,InvalidSubExprPath,p]},
       rebuild_pathd=
        function(l,i)
         {if((i + 1 | 0) === l)return _tu_;
          function aux(i)
           {if(0 === i)return 0;var _Y3_=i - 1 | 0;return [0,0,aux(_Y3_)]}
          if(0 === i)return aux(l - 1 | 0);
          var _Y2_=(l - i | 0) - 1 | 0;
          return append(aux(_Y2_),_tv_)},
       mk_ipath=
        function(opt,_Y1_,root)
         {if(opt)var sth=opt[1],ctxt=sth;else var ctxt=_tw_;
          if(_Y1_)var sth$0=_Y1_[1],sub=sth$0;else var sub=0;
          return [0,root,ctxt,sub]},
       _tx_=0,
       _ty_=0,
       _tz_=0,
       dummy_path=mk_ipath(_tz_,_ty_,_tx_),
       concl_ipath=
        function(param){var g_id=param[1];return mk_ipath(0,0,toint(g_id))},
       all_hyps_ipaths=
        function(param)
         {var
           g_pregoal=param[2],
           g_id=param[1],
           _YV_=g_pregoal[2],
           _YW_=ids(_YV_);
          function _YX_(hd)
           {var _YZ_=toint(g_id),_Y0_=0;
            return mk_ipath([0,[0,3607583,toint(hd)]],_Y0_,_YZ_)}
          return function(_YY_){return map$4(_YX_,_YY_)}(_YW_)},
       all_vars_ipaths=
        function(opt,param)
         {if(opt)var sth=opt[1],heads=sth;else var heads=1;
          var
           g_pregoal=param[2],
           g_id=param[1],
           env=g_pregoal[1],
           _YG_=env[6],
           _YH_=codomain(_YG_);
          function _YI_(hd)
           {var match=byid(env,hd),switch$0=0;
            if(match && match[1][2][2])
             {var
               _YK_=0,
               _YL_=toint(g_id),
               _YM_=0,
               _YN_=[0,[0,_tA_,hd]],
               _YO_=[0,mk_ipath(_YN_,_YM_,_YL_),_YK_],
               _YP_=_YO_;
              switch$0 = 1}
            if(! switch$0)var _YP_=0;
            if(heads)
             var
              _YQ_=0,
              _YR_=toint(g_id),
              _YS_=0,
              _YT_=[0,[0,_tB_,hd]],
              _YU_=[0,mk_ipath(_YT_,_YS_,_YR_),_YQ_];
            else
             var _YU_=0;
            return append(_YU_,_YP_)}
          return function(_YJ_){return concat_map(_YI_,_YJ_)}(_YH_)},
       all_items_ipaths=
        function(heads,goal)
         {var _YE_=all_vars_ipaths(heads,goal),_YF_=all_hyps_ipaths(goal);
          return append([0,concl_ipath(goal),_YF_],_YE_)},
       _tD_=function(m,param){var b=param[2],a=param[1];return add$8(a,b,m)},
       pkind_codes=fold(_tD_,empty$6,_tC_),
       string_of_pkind=
        function(_YD_){return symbol$4(find$4,pkind_codes,_YD_)},
       _tE_=inverse(pkind_codes),
       pkind_of_string=function(_YC_){return symbol$4(find$4,_tE_,_YC_)},
       p2p=
        function(p)
         {var _Yu_=[0,function(fmt,param){return caml_call1(pp$0(fmt),_tF_)}];
          function pp_sub(_YA_,_YB_){return list(_Yu_,pp,_YA_,_YB_)}
          var
           _Yv_=p[3],
           _Yw_=p[2][2],
           _Yx_=p[2][1],
           _Yy_=string_of_pkind(_Yx_),
           _Yz_=p[1];
          return caml_call5(asprintf(_tG_),_Yz_,_Yy_,_Yw_,pp_sub,_Yv_)},
       ipath_of_path=
        function(p)
         {try
           {var
             _Yl_=
              function(x1,x2,x3,x4)
               {return [0,x1,[0,pkind_of_string(x2),x3],x4]},
             match=caml_call1(sscanf(p,_tH_),_Yl_)}
          catch(_Yt_)
           {_Yt_ = caml_wrap_exception(_Yt_);
            if
             (_Yt_[1]
              !==
              Scan_failure
              &&
              _Yt_
              !==
              Not_found
              &&
              _Yt_
              !==
              End_of_file)
             throw _Yt_;
            throw [0,Invalid_argument,p]}
          var
           sub=match[3],
           ctxt=match[2],
           handle=ctxt[2],
           root=match[1],
           _Ym_=root < 0?1:0,
           _Yn_=_Ym_ || (handle < 0?1:0);
          if(_Yn_)throw [0,InvalidPath,p];
          if(caml_string_equal(sub,_tI_))
           var sub$0=0;
          else
           var _Yq_=47,sub$0=split_on_char(_Yq_,sub);
          try
           {var
             _Yo_=function(_Ys_){return caml_int_of_string(_Ys_)},
             sub$1=map$4(_Yo_,sub$0)}
          catch(_Yr_)
           {_Yr_ = caml_wrap_exception(_Yr_);
            if(_Yr_[1] === Failure)throw [0,InvalidPath,p];
            throw _Yr_}
          function _Yp_(x){return x < 0?1:0}
          if(exists(_Yp_,sub$1))throw [0,InvalidPath,p];
          return [0,root,ctxt,sub$1]},
       of_ipath=
        function(proof,p)
         {var exn=[0,InvalidPath,p2p(p)],sub=p[3],ctxt=p[2],root=p[1];
          try
           {var _X$_=ofint(root),goal=byid$1(proof,_X$_)}
          catch(_Yk_)
           {_Yk_ = caml_wrap_exception(_Yk_);
            if(_Yk_[1] === InvalidGoalId)throw exn;
            throw _Yk_}
          var _Ya_=ctxt[1],_Yb_=ctxt[2];
          if(typeof _Ya_ === "number")
           if(3607583 <= _Ya_)
            {try
              {var
                rp=ofint(_Yb_),
                _Yc_=goal[2],
                hyd=byid$0(_Yc_,rp),
                hf=hyd[3],
                _Yd_=[0,70,hf],
                _Ye_=[0,72,[0,rp,hyd]]}
             catch(_Yj_)
              {_Yj_ = caml_wrap_exception(_Yj_);
               if(_Yj_[1] === InvalidHyphId)throw exn;
               throw _Yj_}
             var t_item=_Yd_,item=_Ye_}
           else
            {if(0 !== _Yb_)throw exn;
             var f=goal[3],_Yf_=[0,70,f],_Yg_=[0,67,f],t_item=_Yf_,item=_Yg_}
          else
           var
            part=_Ya_[2],
            _Yh_=goal[1],
            _Yi_=byid(_Yh_,_Yb_),
            def=get_exn(_Yi_,exn),
            match=def[2],
            body=match[2],
            x=def[1],
            expr=803493184 <= part?[0,x]:get_exn(body,exn),
            t_item$0=[0,69,expr],
            item$0=[0,86,def],
            t_item=t_item$0,
            item=item$0;
          var target=subterm(t_item,sub),goal$0=[0,ofint(root),goal];
          return [0,goal$0,item,[0,sub,target]]},
       goal_of_ipath=
        function(proof,p){var match=of_ipath(proof,p),g=match[1];return g},
       term_of_ipath=
        function(proof,p){var match=of_ipath(proof,p)[3],t=match[2];return t},
       env_of_ipath=
        function(proof,p)
         {var
           _X7_=of_ipath(proof,p),
           match=_X7_[3],
           sub=match[1],
           item=_X7_[2],
           goal=_X7_[1],
           env=goal[2][1],
           _X8_=item[1];
          if(72 === _X8_)
           var f=item[2][2][3];
          else
           {if(86 <= _X8_)return env;var f=item[2]}
          function aux(env,t,sub)
           {var env$0=env,t$0=t,sub$0=sub;
            for(;;)
             {if(sub$0)
               {var sub$1=sub$0[2],i=sub$0[1];
                if(70 <= t$0[1])
                 {var _X9_=t$0[2];
                  if(typeof _X9_ !== "number" && 2 === _X9_[0] && 0 === i)
                   {var
                     f=_X9_[4],
                     ty=_X9_[3],
                     x=_X9_[2],
                     t$2=[0,70,f],
                     _X__=[0,x,[0,ty,0]],
                     env$1=push$4(env$0,_X__),
                     env$0=env$1,
                     t$0=t$2,
                     sub$0=sub$1;
                    continue}
                  var t$1=direct_subterm(t$0,i),t$0=t$1,sub$0=sub$1;
                  continue}
                return env$0}
              return env$0}}
          return aux(env,[0,70,f],sub)},
       is_sub_path=
        function(p,sp)
         {var _XX_=p[1] === sp[1]?1:0;
          if(_XX_)
           {var _XY_=p[2][2] === sp[2][2]?1:0;
            if(_XY_)
             {var _XZ_=sp[2][1],_X0_=p[2][1],_X1_=caml_equal(_X0_,_XZ_);
              if(_X1_)
               var _X2_=_X1_;
              else
               {var _X4_=p[2][1],_X5_=caml_equal(_X4_,_tJ_);
                if(_X5_)
                 var _X6_=sp[2][1],_X2_=caml_equal(_X6_,_tK_);
                else
                 var _X2_=_X5_}
              if(_X2_)return is_prefix(sp[3],p[3]);
              var _X3_=_X2_}
            else
             var _X3_=_XY_}
          else
           var _X3_=_XX_;
          return _X3_},
       TRewriteAt=[248,_tL_,caml_fresh_oo_id(0)],
       rewrite_at=
        function(t,p)
         {return function(param)
           {var
             proof=param[1],
             _XK_=of_ipath(proof,p),
             sub=_XK_[3][1],
             item=_XK_[2],
             match=_XK_[1],
             goal=match[2],
             g_id=match[1],
             pnode=[0,TRewriteAt,t,p],
             _XL_=item[1];
            if(72 === _XL_)
             {var
               _XM_=item[2],
               match$0=_XM_[2],
               f=match$0[3],
               hd=_XM_[1],
               _XN_=[0,70,f],
               _XO_=caml_call2(rewrite_subterm(t),_XN_,sub),
               new_hyp=form_of_term(_XO_),
               subgoal=[0,[0,[0,[0,hd],[0,new_hyp,0]],0],goal[3]];
              return caml_call2
                      (sprogress(proof,_tM_,g_id),pnode,[0,subgoal,0])}
            if(86 <= _XL_)
             {var
               _XP_=item[2],
               match$1=_XP_[2],
               body=match$1[2],
               ty=match$1[1],
               x=_XP_[1],
               _XQ_=p[2][1];
              if(typeof _XQ_ !== "number" && 4298439 === _XQ_[1])
               {if(803493184 <= _XQ_[2])return failwith(_tO_);
                if(body)
                 {var
                   b=body[1],
                   _XR_=[0,69,b],
                   _XS_=caml_call2(rewrite_subterm(t),_XR_,sub),
                   new_body=expr_of_term(_XS_),
                   _XT_=[0,x,[0,ty,[0,new_body]]],
                   _XU_=goal[1],
                   g_env=modify$1(_XU_,_XT_);
                  return xprogress
                          (proof,g_id,pnode,[0,[0,g_env,goal[2],goal[3]],0])}
                return failwith(_tP_)}
              throw [0,Assert_failure,_tN_]}
            var
             f$0=item[2],
             _XV_=[0,70,f$0],
             _XW_=caml_call2(rewrite_subterm(t),_XV_,sub),
             new_concl=form_of_term(_XW_);
            return progress(proof,g_id,pnode,[0,new_concl,0])}},
       TRewrite=[248,_tQ_,caml_fresh_oo_id(0)],
       rewrite$0=
        function(red,res,tgt,param)
         {var
           hd=param[2],
           proof=param[1],
           _Xm_=tgt[3],
           _Xn_=tgt[2],
           tgt$0=[0,toint(hd),_Xn_,_Xm_],
           _Xo_=of_ipath(proof,tgt$0),
           match=_Xo_[3],
           sub=match[1],
           it=_Xo_[2],
           goal=byid$1(proof,hd),
           pnode=[0,TRewrite,red,res,tgt$0],
           _Xp_=it[1];
          if(72 === _Xp_)
           {var
             _Xq_=it[2],
             match$0=_Xq_[2],
             f=match$0[3],
             src=_Xq_[1],
             _Xr_=[0,70,f],
             _Xs_=[0,69,res],
             _Xt_=[0,69,red],
             _Xu_=goal[1],
             _Xv_=caml_call2(rewrite_subterm_all(_Xu_,_Xt_,_Xs_),_Xr_,sub),
             new_hyp=form_of_term(_Xv_),
             subgoal=[0,[0,[0,[0,src],[0,new_hyp,0]],0],goal[3]];
            return caml_call2(sprogress(proof,_tR_,hd),pnode,[0,subgoal,0])}
          if(86 <= _Xp_)
           {var
             _Xw_=it[2],
             match$1=_Xw_[2],
             b=match$1[2],
             ty=match$1[1],
             x=_Xw_[1],
             _Xx_=tgt$0[2][1];
            if(typeof _Xx_ !== "number" && 4298439 === _Xx_[1])
             {if(803493184 <= _Xx_[2])return failwith(_tT_);
              if(b)
               {var
                 b$0=b[1],
                 _Xy_=[0,69,b$0],
                 _Xz_=[0,69,res],
                 _XA_=[0,69,red],
                 _XB_=goal[1],
                 _XC_=caml_call2(rewrite_subterm_all(_XB_,_XA_,_Xz_),_Xy_,sub),
                 new_body=expr_of_term(_XC_),
                 _XD_=[0,x,[0,ty,[0,new_body]]],
                 _XE_=goal[1],
                 g_env=modify$1(_XE_,_XD_);
                return xprogress
                        (proof,hd,pnode,[0,[0,g_env,goal[2],goal[3]],0])}
              return failwith(_tU_)}
            throw [0,Assert_failure,_tS_]}
          var
           f$0=it[2],
           _XF_=[0,70,f$0],
           _XG_=[0,69,res],
           _XH_=[0,69,red],
           _XI_=goal[1],
           _XJ_=caml_call2(rewrite_subterm_all(_XI_,_XH_,_XG_),_XF_,sub),
           new_concl=form_of_term(_XJ_);
          return progress(proof,hd,pnode,[0,new_concl,0])},
       rewrite_in=
        function(red,res,tgts)
         {return fold
                  (function(tac,tgt)
                    {function _Xj_(_Xl_){return rewrite$0(red,res,tgt,_Xl_)}
                     return function(_Xk_){return then_tac(_Xj_,tac,_Xk_)}},
                   id_tac,
                   tgts)},
       unfold=
        function(opt,x)
         {if(opt)var sth=opt[1],fold=sth;else var fold=0;
          return function(tgts,param)
           {var
             hd=param[2],
             proof=param[1],
             goal=byid$1(proof,hd),
             _Xb_=goal[1],
             _Xc_=get$9(_Xb_,x);
            function _Xd_(_Xi_)
             {return symbol$4(get_exn,TacticNotApplicable,_Xi_)}
            var _Xe_=_Xd_(_Xc_)[2];
            function _Xf_(_Xh_)
             {return symbol$4(get_exn,TacticNotApplicable,_Xh_)}
            var body=_Xf_(_Xe_);
            if(fold)
             var _Xg_=[0,x],res=_Xg_,red=body;
            else
             var red$0=[0,x],res=body,red=red$0;
            return caml_call1(rewrite_in(red,res,tgts),[0,proof,hd])}},
       unfold_all=
        function(fold,x,targ)
         {var
           hd=targ[2],
           proof=targ[1],
           goal=[0,hd,byid$1(proof,hd)],
           _W7_=goal[2][1],
           _W8_=getid(_W7_,x),
           id=get$3(_W8_),
           _W9_=all_items_ipaths(_tV_,goal);
          function _W__(p){return p[2][2] === id?1:0}
          function _W$_(_Xa_){return remove_if(_W__,_Xa_)}
          var tgts=_W$_(_W9_);
          return caml_call2(unfold(fold,x),tgts,targ)},
       opp=
        function(param)
         {switch(param){case 0:return 1;case 1:return 0;default:return 2}},
       direct_subform_pol=
        function(param,i)
         {var f=param[2],p=param[1];
          if(typeof f !== "number")
           switch(f[0])
            {case 1:
              var fs=f[2],c=f[1],switch$0=0;
              if(3654636 === c || 3903731 === c)
               switch$0 = 1;
              else
               if(95438486 === c)var subp=2;else switch$0 = 2;
              var switch$1=0;
              switch(switch$0)
               {case 1:if(0 === i)var subp=opp(p);else switch$1 = 1;break;
                case 2:switch$1 = 1;break
                }
              if(switch$1)var subp=p;
              try
               {var subf=nth(fs,i)}
              catch(_W6_)
               {_W6_ = caml_wrap_exception(_W6_);
                if(_W6_[1] === Invalid_argument)
                 throw [0,InvalidSubFormPath,[0,i,0]];
                throw _W6_}
              return [0,subp,subf];
             case 2:var subf$0=f[4];return [0,p,subf$0]
             }
          throw [0,InvalidSubFormPath,[0,i,0]]},
       direct_subterm_pol=
        function(param,i)
         {var t=param[2],p=param[1],match=direct_subterm(t,i);
          if
           (typeof t
            !==
            "number"
            &&
            70
            ===
            t[1]
            &&
            typeof match
            !==
            "number"
            &&
            70
            ===
            match[1])
           {var
             f=t[2],
             _W5_=[0,p,f],
             match$0=direct_subform_pol(_W5_,i),
             f$0=match$0[2],
             p$0=match$0[1];
            return [0,p$0,[0,70,f$0]]}
          return [0,p,match]},
       subform_pol=
        function(param,sub)
         {var f=param[2],p=param[1];
          try
           {var _W2_=[0,p,f],_W3_=fold(direct_subform_pol,_W2_,sub);
            return _W3_}
          catch(_W4_)
           {_W4_ = caml_wrap_exception(_W4_);
            if(_W4_[1] === InvalidSubFormPath)
             throw [0,InvalidSubFormPath,sub];
            throw _W4_}},
       neg_count=
        function(f,sub)
         {function aux(param,_WW_)
           {var param$0=param,_WX_=_WW_;
            for(;;)
             {var _WY_=param$0[2],_WZ_=param$0[1];
              if(_WX_)
               {var sub=_WX_[2],i=_WX_[1];
                if(typeof _WY_ !== "number")
                 switch(_WY_[0])
                  {case 1:
                    var fs=_WY_[2],c=_WY_[1],switch$0=0;
                    if(3654636 !== c && 3903731 !== c)switch$0 = 1;
                    var switch$1=0;
                    if(! switch$0 && 0 === i){var n=_WZ_ + 1 | 0;switch$1 = 1}
                    if(! switch$1)var n=_WZ_;
                    try
                     {var subf=nth(fs,i)}
                    catch(_W1_)
                     {_W1_ = caml_wrap_exception(_W1_);
                      if(_W1_[1] === Invalid_argument)
                       throw [0,InvalidSubFormPath,sub];
                      throw _W1_;
                      var _W0_=_W1_}
                    var param$1=[0,n,subf],param$0=param$1,_WX_=sub;
                    continue;
                   case 2:
                    var
                     subf$0=_WY_[4],
                     param$2=[0,_WZ_,subf$0],
                     param$0=param$2,
                     _WX_=sub;
                    continue
                   }
                return _WZ_}
              return _WZ_}}
          return aux([0,0,f],sub)},
       pol_of_item=
        function(param){var _WV_=param[1];return 72 === _WV_?1:86 <= _WV_?1:0},
       pol_of_ipath=
        function(proof,p)
         {var
           _WR_=of_ipath(proof,p),
           match=_WR_[3],
           sub=match[1],
           item=_WR_[2],
           _WS_=item[1];
          if(72 === _WS_)
           var match$0=item[2][2],f=match$0[3],pol=1,form=f,pol$0=pol;
          else
           {if(86 <= _WS_)throw [0,InvalidSubFormPath,sub];
            var f$0=item[2],_WU_=0,form=f$0,pol$0=_WU_}
          var _WT_=[0,pol$0,form];
          return subform_pol(_WT_,sub)[1]},
       instantiate=
        function(wit,tgt,targ)
         {var proof=targ[1],match=term_of_ipath(proof,tgt);
          if(typeof match !== "number" && 70 === match[1])
           {var _WH_=match[2];
            if(typeof _WH_ !== "number" && 2 === _WH_[0])
             {var f=_WH_[4],x=_WH_[2];
              if(3607583 === tgt[2][1])
               var
                _WI_=tgt[2][2],
                _WJ_=ofint(_WI_),
                first=function(_WQ_){return duplicate(_WJ_,_WQ_)};
              else
               var first=id_tac;
              var
               _WK_=
                function(param)
                 {var
                   id=param[2],
                   pr=param[1],
                   _WM_=tgt[3],
                   _WN_=tgt[2],
                   tgt$0=[0,toint(id),_WN_,_WM_],
                   _WO_=[0,pr,id],
                   _WP_=[0,x,0];
                  return caml_call1
                          (rewrite_at([0,70,f_apply1(_WP_,wit,f)],tgt$0),_WO_)};
              return function(_WL_){return then_tac(first,_WK_,_WL_)}(targ)}}
          throw TacticNotApplicable},
       print_choice=
        function(param)
         {var witness=param[2],side=param[1],side$0=0 === side?_tW_:_t0_;
          function _WD_(e)
           {var _WG_=e_tostring(e);return caml_call1(sprintf(_tY_),_WG_)}
          function _WE_(_WF_){return map_default(_WD_,_tX_,_WF_)}
          var witness$0=_WE_(witness);
          return caml_call2(sprintf(_tZ_),side$0,witness$0)},
       print_itrace=to_string$8(_t3_,_t2_,_t1_,print_choice),
       TLink=[248,_t4_,caml_fresh_oo_id(0)],
       elim_units=
        function(f)
         {var f$0=f;
          for(;;)
           {var switch$0=0;
            if(typeof f$0 === "number")
             switch$0 = 2;
            else
             switch(f$0[0])
              {case 1:
                var _Wb_=f$0[1],switch$1=0;
                if(3257015 === _Wb_)
                 {var _Wc_=f$0[2];
                  if(_Wc_)
                   {var _Wd_=_Wc_[1],_We_=_Wc_[2];
                    if(_We_)
                     {var _Wf_=_We_[1],switch$2=0;
                      if(typeof _Wf_ === "number" && _Wf_)
                       if(_We_[2])
                        switch$2 = 1;
                       else
                        {switch$0 = 1;switch$1 = 2;switch$2 = 1}
                      if(! switch$2)
                       {var switch$3=0;
                        if(typeof _Wd_ === "number" && _Wd_)
                         if(_Wc_[2][2])
                          switch$3 = 1;
                         else
                          {switch$0 = 1;switch$1 = 2;switch$3 = 1}
                        if(! switch$3)
                         {var _Wg_=_Wc_[2];
                          if(typeof _Wg_[1] === "number")
                           {if(! _Wg_[2]){var f$2=_Wd_;switch$1 = 1}}
                          else
                           if(typeof _Wd_ === "number")
                            {var _Wh_=_Wc_[2];
                             if(! _Wh_[2]){var f$2=_Wh_[1];switch$1 = 1}}}}}}}
                else
                 if(3903731 <= _Wb_)
                  if(95438486 <= _Wb_)
                   {var _Wi_=f$0[2];
                    if(_Wi_)
                     {var _Wj_=_Wi_[1],switch$4=0;
                      if(typeof _Wj_ === "number" && ! _Wj_)
                       {var _Wm_=_Wi_[2];
                        if(_Wm_ && ! _Wm_[2]){var f$2=_Wm_[1];switch$1 = 1}}
                      else
                       switch$4 = 1;
                      if(switch$4)
                       {var _Wk_=_Wi_[2];
                        if(_Wk_)
                         {var _Wl_=_Wk_[1];
                          if(typeof _Wl_ === "number" && ! _Wl_ && ! _Wk_[2])
                           {var f$2=_Wj_;switch$1 = 1}}}}}
                  else
                   {var _Wn_=f$0[2];
                    if(_Wn_)
                     {var _Wo_=_Wn_[1];
                      if(typeof _Wo_ === "number")
                       if(_Wo_)
                        {if(! _Wn_[2])switch$1 = 2}
                       else
                        if(! _Wn_[2]){switch$0 = 1;switch$1 = 2}}}
                 else
                  if(3654636 <= _Wb_)
                   {var _Wp_=f$0[2];
                    if(_Wp_)
                     {var _Wq_=_Wp_[1],_Wr_=_Wp_[2];
                      if(_Wr_)
                       {var _Ws_=_Wr_[1],switch$5=0;
                        if(typeof _Ws_ === "number" && ! _Ws_)
                         {if(! _Wr_[2])switch$1 = 2}
                        else
                         switch$5 = 1;
                        if(switch$5 && typeof _Wq_ === "number")
                         if(_Wq_)
                          {if(! _Wp_[2][2])switch$1 = 2}
                         else
                          {var _Wt_=_Wp_[2];
                           if(! _Wt_[2]){var f$2=_Wt_[1];switch$1 = 1}}}}}
                  else
                   {var _Wu_=f$0[2];
                    if(_Wu_)
                     {var _Wv_=_Wu_[1],_Ww_=_Wu_[2];
                      if(_Ww_)
                       {var _Wx_=_Ww_[1],switch$6=0;
                        if(typeof _Wx_ === "number" && ! _Wx_)
                         {if(! _Ww_[2])switch$1 = 2}
                        else
                         switch$6 = 1;
                        if(switch$6)
                         {var switch$7=0;
                          if(typeof _Wv_ === "number" && ! _Wv_)
                           {if(! _Wu_[2][2])switch$1 = 2}
                          else
                           switch$7 = 1;
                          if(switch$7)
                           {var _Wy_=_Wu_[2];
                            if(typeof _Wy_[1] === "number")
                             {if(! _Wy_[2]){var f$2=_Wv_;switch$1 = 1}}
                            else
                             if(typeof _Wv_ === "number")
                              {var _Wz_=_Wu_[2];
                               if(! _Wz_[2]){var f$2=_Wz_[1];switch$1 = 1}}}}}}}
                switch(switch$1)
                 {case 2:break;
                  case 0:
                   var fs=f$0[2],fs$0=map$4(elim_units,fs);
                   if(caml_equal(fs,fs$0))return f$0;
                   var f$1=[1,_Wb_,fs$0],f$0=f$1;
                   continue;
                  default:var f$0=f$2;continue}
                break;
               case 2:
                var _WA_=f$0[1],switch$8=0;
                if(840561112 <= _WA_)
                 {var _WB_=f$0[4];
                  if(typeof _WB_ === "number" && ! _WB_)switch$8 = 1}
                else
                 {var _WC_=f$0[4];
                  if(typeof _WC_ === "number" && _WC_)
                   {switch$0 = 1;switch$8 = 1}}
                if(! switch$8)
                 {var f1=f$0[4],ty=f$0[3],x=f$0[2],f1$0=elim_units(f1);
                  if(caml_equal(f1,f1$0))return f$0;
                  var f$3=[2,_WA_,x,ty,f1$0],f$0=f$3;
                  continue}
                break;
               default:switch$0 = 2}
            switch(switch$0)
             {case 1:return f_false;case 0:return f_true;default:return f$0}}},
       print_linkage=
        function(mode,param)
         {var
           r=param[2][1],
           match=param[1],
           l=match[1],
           op=857475493 <= mode?_t5_:_t7_,
           _V$_=f_tostring(r),
           _Wa_=f_tostring(l);
          return caml_call3(sprintf(_t6_),_Wa_,op,_V$_)},
       dlink=
        function(param,_RU_,_RT_)
         {var
           g_id=_RT_[2],
           proof=_RT_[1],
           s_dst=_RU_[2],
           s_src=_RU_[1],
           dst=param[2],
           src=param[1],
           _RV_=of_ipath(proof,src),
           _RW_=_RV_[3],
           t_src=_RW_[2],
           sub_src=_RW_[1],
           item_src=_RV_[2],
           match=_RV_[1],
           goal=match[2],
           _RX_=of_ipath(proof,dst),
           match$0=_RX_[3],
           t_dst=match$0[2],
           sub_dst=match$0[1],
           item_dst=_RX_[2],
           switch$0=0;
          if(70 <= t_src[1])
           {if(typeof t_dst !== "number" && 69 === t_dst[1])switch$0 = 1}
          else
           if(typeof t_dst !== "number" && 70 === t_dst[1])switch$0 = 1;
          if(switch$0)throw TacticNotApplicable;
          function well_scoped(ctx,e)
           {var _V6_=e_vars(e);
            function _V7_(x)
             {var _V9_=fc_is_bound(x,ctx);
              if(_V9_)return _V9_;
              var _V__=caml_call1(fc_exit(x),ctx);
              return exists$4(goal[1],_V__)}
            return function(_V8_){return for_all(_V7_,_V8_)}(_V6_)}
          function instantiable(lenv,ctx,s,x)
           {var
             lenv$0=enter(lenv,x),
             _V4_=[0,x,get_index(lenv$0,x)],
             match=get_tag(_V4_,s);
            if(match)
             {var _V5_=match[1];
              if(_V5_){var e=_V5_[1];return well_scoped(ctx,e)}
              return 1}
            return 0}
          function invertible(kind,f)
           {if(847852583 === kind)
             {if(typeof f !== "number")
               switch(f[0])
                {case 1:var c=f[1];return 17731 === c?1:0;
                 case 2:if(172470935 === f[1])return 1;break
                 }
              return 0}
            if(857475493 <= kind)
             {if(typeof f !== "number")
               switch(f[0])
                {case 1:return 0;case 2:if(172470935 === f[1])return 1;break}
              return 0}
            if(typeof f !== "number")
             switch(f[0])
              {case 1:
                var c$0=f[1];
                if(3654636 !== c$0 && 3903731 !== c$0 && 95438486 !== c$0)
                 return 0;
                return 1;
               case 2:if(840561112 === f[1])return 1;break
               }
            return 0}
          function no_prio(kind,param)
           {var sub=param[2],f=param[1],inv=invertible(kind,f),_V3_=1 - inv;
            return _V3_?_V3_:is_empty$2(sub)}
          function backward(ctx,itrace,s,linkage)
           {var
             c=linkage[2],
             rsub=c[2],
             r=c[1],
             h=linkage[1],
             lsub=h[2],
             l=h[1],
             es2=s[2],
             s2=es2[2],
             env2=es2[1],
             es1=s[1],
             s1=es1[2],
             env1=es1[1],
             _TR_=13277187,
             _TS_=print_linkage(_TR_,linkage);
            js_log(_TS_);
            var _TT_=linkage[1],_TU_=_TT_[1];
            if(_TT_[2])
             {var switch$0=0;
              if(typeof _TU_ === "number" || ! (0 === _TU_[0]))
               switch$0 = 1;
              else
               if(! caml_string_notequal(_TU_[1],_ut_))
                {var _VC_=_TU_[2];
                 if(_VC_)
                  {var _VD_=_VC_[2];
                   if(_VD_ && ! _VD_[2])
                    {var _VE_=_TT_[2];
                     if(! _VE_[2])
                      {var
                        i$4=_VE_[1],
                        e2=_VD_[1],
                        e1=_VC_[1],
                        e1$0=0 === i$4?e1:e2,
                        _VF_=[0,70,r],
                        _VG_=subexpr(_VF_,rsub),
                        _VH_=goal[1],
                        _VI_=0;
                       if(e_equal(_VI_,_VH_,_VG_,e1$0))
                        {var
                          res=0 === i$4?e2:e1,
                          _VJ_=[0,70,r],
                          _VK_=[0,69,res],
                          _VL_=caml_call2(rewrite_subterm(_VK_),_VJ_,rsub),
                          f=form_of_term(_VL_),
                          _VM_=rev(ctx);
                         return [0,fc_fill(f,_VM_),itrace]}}}}}}
            else
             if(! linkage[2][2])
              {var _VN_=goal[1],_VO_=0;
               if(caml_call1(f_equal(_VO_,_VN_,l),r))
                var f$0=f_true;
               else
                {var switch$1=0;
                 if
                  (typeof l
                   !==
                   "number"
                   &&
                   0
                   ===
                   l[0]
                   &&
                   typeof r
                   !==
                   "number"
                   &&
                   0
                   ===
                   r[0])
                  {var ts2=r[2],c2=r[1],ts1=l[2],c1=l[1];
                   if(caml_string_equal(c1,c2))
                    {var
                      _VQ_=
                       function(f,t1,t2){return f_and(f,[0,_uu_,[0,t1,[0,t2,0]]])},
                      _VR_=fold_left2(_VQ_,f_true,ts1,ts2),
                      f$0=_VR_;
                     switch$1 = 1}}
                 if(! switch$1)var f$0=f_imp(l,r)}
               var _VP_=rev(ctx);
               return [0,fc_fill(f$0,_VP_),itrace]}
            var
             switch_pol=[0,0],
             s$0=[0,s],
             _TV_=linkage[1],
             _TW_=linkage[2],
             _TX_=_TW_[1],
             switch$2=0;
            if(typeof _TX_ === "number")
             switch$2 = 2;
            else
             switch(_TX_[0])
              {case 0:switch$2 = 2;break;
               case 1:
                var _UN_=_TX_[1];
                if(3257015 === _UN_)
                 {var _UO_=_TW_[2];
                  if(_UO_)
                   {var sub$6=_UO_[2],i$2=_UO_[1],fs$3=_TX_[2],_UP_=847852583;
                    if(no_prio(_UP_,h))
                     {try
                       {var
                         switch$3=0,
                         match$1=pop_at(i$2,fs$3),
                         fs$4=match$1[2],
                         fi$0=match$1[1],
                         _UU_=[0,h,[0,fi$0,sub$6]],
                         _UV_=[0,[0,3257015,fs$4,i$2]]}
                      catch(_V1_)
                       {_V1_ = caml_wrap_exception(_V1_);
                        if(_V1_ !== Not_found)throw _V1_;
                        var
                         _UQ_=failwith(_uh_),
                         _UR_=_UQ_[3],
                         _US_=_UQ_[2],
                         _UT_=_UQ_[1],
                         linkage$0=_UR_,
                         choice=_US_,
                         ictx=_UT_;
                        switch$2 = 1;
                        switch$3 = 1}
                      if(! switch$3)
                       {var linkage$0=_UU_,choice=_ui_,ictx=_UV_;switch$2 = 1}}}}
                else
                 if(3903731 <= _UN_)
                  if(95438486 <= _UN_)
                   {var _UW_=_TX_[2];
                    if(_UW_)
                     {var _UX_=_UW_[2];
                      if(_UX_ && ! _UX_[2])
                       {var
                         _UY_=failwith(_uj_),
                         _UZ_=_UY_[3],
                         _U0_=_UY_[2],
                         _U1_=_UY_[1],
                         linkage$0=_UZ_,
                         choice=_U0_,
                         ictx=_U1_;
                        switch$2 = 1}}}
                  else
                   {var _U2_=_TX_[2];
                    if(_U2_ && ! _U2_[2])
                     {var _U3_=_TW_[2];
                      if(_U3_ && 0 === _U3_[1])
                       {var sub$7=_U3_[2],f1$3=_U2_[1];
                        switch_pol[1] = 1;
                        var
                         _U4_=[0,h,[0,f1$3,sub$7]],
                         linkage$0=_U4_,
                         choice=_uk_,
                         ictx=_ul_;
                        switch$2 = 1}}}
                 else
                  if(3654636 <= _UN_)
                   {var _U5_=_TX_[2];
                    if(_U5_)
                     {var _U6_=_U5_[2];
                      if(_U6_ && ! _U6_[2])
                       {var _U7_=_TW_[2];
                        if(_U7_)
                         {var _U8_=_U7_[1],_U9_=_U6_[1],_U__=_U5_[1];
                          if(0 === _U8_)
                           {var sub$8=_U7_[2];
                            switch_pol[1] = 1;
                            var
                             _U$_=[0,h,[0,_U__,sub$8]],
                             _Va_=[0,[0,3654636,[0,_U9_,0],0]],
                             linkage$0=_U$_,
                             choice=_um_,
                             ictx=_Va_;
                            switch$2 = 1}
                          else
                           if(1 === _U8_)
                            {var
                              sub$9=_U7_[2],
                              _Vb_=[0,h,[0,_U9_,sub$9]],
                              _Vc_=[0,[0,3654636,[0,_U__,0],1]],
                              linkage$0=_Vb_,
                              choice=_un_,
                              ictx=_Vc_;
                             switch$2 = 1}}}}}
                  else
                   {var _Vd_=_TW_[2];
                    if(_Vd_)
                     {var sub$10=_Vd_[2],i$3=_Vd_[1],fs$5=_TX_[2],_Ve_=847852583;
                      if(no_prio(_Ve_,h))
                       {try
                         {var
                           switch$4=0,
                           match$2=pop_at(i$3,fs$5),
                           fs$6=match$2[2],
                           fi$1=match$2[1],
                           _Vj_=[0,h,[0,fi$1,sub$10]],
                           _Vk_=[0,[0,17731,fs$6,i$3]];
                          switch$4 = 1}
                        catch(_V2_)
                         {_V2_ = caml_wrap_exception(_V2_);
                          if(_V2_ !== Not_found)throw _V2_;
                          var
                           _Vf_=failwith(_uo_),
                           _Vg_=_Vf_[3],
                           _Vh_=_Vf_[2],
                           _Vi_=_Vf_[1],
                           linkage$0=_Vg_,
                           choice=_Vh_,
                           ictx=_Vi_;
                          switch$2 = 1}
                        if(switch$4)
                         {var linkage$0=_Vj_,choice=_up_,ictx=_Vk_;switch$2 = 1}}}}
                break;
               default:
                if(840561112 <= _TX_[1])
                 {var _Vl_=_TW_[2];
                  if(_Vl_ && 0 === _Vl_[1])
                   {var sub$11=_Vl_[2],f1$4=_TX_[4],ty$1=_TX_[3],x$1=_TX_[2];
                    s$0[1] = [0,es1,[0,enter(env2,x$1),s2]];
                    var
                     _Vm_=[0,x$1,0],
                     _Vn_=0,
                     h$0=[0,f_shift(_Vn_,_Vm_,l),lsub],
                     _Vo_=[0,h$0,[0,f1$4,sub$11]],
                     _Vp_=[0,[1,840561112,x$1,ty$1]],
                     linkage$0=_Vo_,
                     choice=_uq_,
                     ictx=_Vp_;
                    switch$2 = 1}}
                else
                 {var _Vq_=_TW_[2];
                  if(_Vq_ && 0 === _Vq_[1])
                   {var
                     sub$12=_Vq_[2],
                     f1$5=_TX_[4],
                     ty$2=_TX_[3],
                     x$2=_TX_[2],
                     _Vr_=847852583,
                     switch$5=0;
                    if(no_prio(_Vr_,h) && instantiable(env2,ctx,s2,x$2))
                     {var env2$0=enter(env2,x$2);
                      s$0[1] = [0,es1,[0,env2$0,s2]];
                      var
                       _Vs_=[0,x$2,get_index(env2$0,x$2)],
                       match$3=get_tag(_Vs_,s2);
                      if(! match$3)throw [0,Assert_failure,_us_];
                      var _Vt_=match$3[1];
                      if(_Vt_)
                       {var
                         e$0=_Vt_[1],
                         _Vu_=[0,x$2,0],
                         f1$6=f_apply1(_Vu_,e$0,f1$5),
                         _Vv_=[0,h,[0,f1$6,sub$12]],
                         _Vw_=[0,1,[0,e$0]],
                         _Vx_=0,
                         linkage$0=_Vv_,
                         choice=_Vw_,
                         ictx=_Vx_;
                        switch$2 = 1}
                      else
                       {s$0[1] = [0,es1,[0,env2$0,s2]];
                        var
                         _Vy_=[0,x$2,0],
                         _Vz_=0,
                         h$1=[0,f_shift(_Vz_,_Vy_,l),lsub],
                         _VA_=[0,h$1,[0,f1$5,sub$12]],
                         _VB_=[0,[1,172470935,x$2,ty$2]],
                         linkage$0=_VA_,
                         choice=_ur_,
                         ictx=_VB_;
                        switch$2 = 1}}
                    else
                     switch$5 = 1}}}
            var switch$6=0;
            switch(switch$2)
             {case 2:switch$6 = 1;break;case 0:switch$6 = 1;break}
            if(switch$6)
             {var _TY_=_TV_[1],switch$7=0;
              if(typeof _TY_ === "number")
               switch$7 = 2;
              else
               switch(_TY_[0])
                {case 0:switch$7 = 2;break;
                 case 1:
                  var _TZ_=_TY_[1];
                  if(3257016 <= _TZ_)
                   {if(3654636 === _TZ_)
                     {var _T0_=_TY_[2];
                      if(_T0_)
                       {var _T1_=_T0_[2];
                        if(_T1_ && ! _T1_[2])
                         {var _T2_=_TV_[2];
                          if(_T2_ && 1 === _T2_[1])
                           {var sub=_T2_[2],f2=_T1_[1],f1=_T0_[1],_T3_=-57574468;
                            if(no_prio(_T3_,c))
                             {var
                               _T4_=[0,[0,f2,sub],c],
                               _T5_=[0,[0,3257015,[0,f1,0],1]],
                               linkage$0=_T4_,
                               choice=_t8_,
                               ictx=_T5_;
                              switch$7 = 1}}}}}
                    else
                     if(95438486 === _TZ_)
                      {var _T6_=_TY_[2];
                       if(_T6_)
                        {var _T7_=_T6_[2];
                         if(_T7_ && ! _T7_[2])
                          {var _T8_=_TV_[2];
                           if(_T8_)
                            {var _T9_=_T8_[1],_T__=_T7_[1],_T$_=_T6_[1];
                             if(0 === _T9_)
                              {var sub$0=_T8_[2],_Ua_=-57574468;
                               if(no_prio(_Ua_,c))
                                {var
                                  _Ub_=[0,[0,_T$_,sub$0],c],
                                  _Uc_=[0,[0,3257015,[0,_T__,0],0]],
                                  linkage$0=_Ub_,
                                  choice=_t__,
                                  ictx=_Uc_;
                                 switch$7 = 1}}
                             else
                              if(1 === _T9_)
                               {var sub$1=_T8_[2],_Ud_=-57574468;
                                if(no_prio(_Ud_,c))
                                 {var
                                   _Ue_=[0,[0,_T__,sub$1],c],
                                   _Uf_=[0,[0,3257015,[0,_T$_,0],1]],
                                   linkage$0=_Ue_,
                                   choice=_t$_,
                                   ictx=_Uf_;
                                  switch$7 = 1}}}}}}}
                  else
                   if(17731 === _TZ_)
                    {var _Ug_=_TV_[2];
                     if(_Ug_)
                      {var sub$2=_Ug_[2],i$0=_Ug_[1],fs=_TY_[2];
                       try
                        {var
                          switch$8=0,
                          match=pop_at(i$0,fs),
                          fs$0=match[2],
                          fi=match[1],
                          _Ul_=function(fj){return f_imp(fj,r)},
                          fs$1=map$4(_Ul_,fs$0),
                          _Um_=[0,[0,fi,sub$2],c],
                          _Un_=[0,[0,3257015,fs$1,i$0]]}
                       catch(_VZ_)
                        {_VZ_ = caml_wrap_exception(_VZ_);
                         if(_VZ_ !== Not_found)throw _VZ_;
                         var
                          _Uh_=failwith(_ua_),
                          _Ui_=_Uh_[3],
                          _Uj_=_Uh_[2],
                          _Uk_=_Uh_[1],
                          linkage$0=_Ui_,
                          choice=_Uj_,
                          ictx=_Uk_;
                         switch$7 = 1;
                         switch$8 = 1}
                       if(! switch$8)
                        {var linkage$0=_Um_,choice=_ub_,ictx=_Un_;switch$7 = 1}}}
                   else
                    if(3257015 <= _TZ_)
                     {var _Uo_=_TV_[2];
                      if(_Uo_)
                       {var sub$3=_Uo_[2],i$1=_Uo_[1],fs$2=_TY_[2],_Up_=-57574468;
                        if(no_prio(_Up_,c))
                         {try
                           {var switch$9=0,_Uu_=[0,[0,nth(fs$2,i$1),sub$3],c],_Uv_=0;
                            switch$9 = 1}
                          catch(_V0_)
                           {_V0_ = caml_wrap_exception(_V0_);
                            if(_V0_[1] !== Invalid_argument)throw _V0_;
                            var
                             _Uq_=failwith(_uc_),
                             _Ur_=_Uq_[3],
                             _Us_=_Uq_[2],
                             _Ut_=_Uq_[1],
                             linkage$0=_Ur_,
                             choice=_Us_,
                             ictx=_Ut_;
                            switch$7 = 1}
                          if(switch$9)
                           {var linkage$0=_Uu_,choice=_ud_,ictx=_Uv_;switch$7 = 1}}}}
                  break;
                 default:
                  if(840561112 <= _TY_[1])
                   {var _Uw_=_TV_[2];
                    if(_Uw_ && 0 === _Uw_[1])
                     {var
                       sub$4=_Uw_[2],
                       f1$0=_TY_[4],
                       ty=_TY_[3],
                       x=_TY_[2],
                       _Ux_=-57574468,
                       switch$10=0;
                      if(no_prio(_Ux_,c) && instantiable(env1,ctx,s1,x))
                       {var env1$0=enter(env1,x);
                        s$0[1] = [0,[0,env1$0,s1],es2];
                        var _Uy_=[0,x,get_index(env1$0,x)],match$0=get_tag(_Uy_,s1);
                        if(! match$0)throw [0,Assert_failure,_uf_];
                        var _Uz_=match$0[1];
                        if(_Uz_)
                         {var
                           e=_Uz_[1],
                           _UA_=[0,x,0],
                           f1$1=f_apply1(_UA_,e,f1$0),
                           _UB_=[0,[0,f1$1,sub$4],c],
                           _UC_=[0,0,[0,e]],
                           _UD_=0,
                           linkage$0=_UB_,
                           choice=_UC_,
                           ictx=_UD_;
                          switch$7 = 1}
                        else
                         {s$0[1] = [0,[0,env1$0,s1],es2];
                          var
                           _UE_=[0,x,0],
                           _UF_=0,
                           c$0=[0,f_shift(_UF_,_UE_,r),rsub],
                           _UG_=[0,[0,f1$0,sub$4],c$0],
                           _UH_=[0,[1,172470935,x,ty]],
                           linkage$0=_UG_,
                           choice=_ue_,
                           ictx=_UH_;
                          switch$7 = 1}}
                      else
                       switch$10 = 1}}
                  else
                   {var _UI_=_TV_[2];
                    if(_UI_ && 0 === _UI_[1])
                     {var sub$5=_UI_[2],f1$2=_TY_[4],ty$0=_TY_[3],x$0=_TY_[2];
                      s$0[1] = [0,[0,enter(env1,x$0),s1],es2];
                      var
                       _UJ_=[0,x$0,0],
                       _UK_=0,
                       c$1=[0,f_shift(_UK_,_UJ_,r),rsub],
                       _UL_=[0,[0,f1$2,sub$5],c$1],
                       _UM_=[0,[1,840561112,x$0,ty$0]],
                       linkage$0=_UL_,
                       choice=_ug_,
                       ictx=_UM_;
                      switch$7 = 1}}}
              var switch$11=0;
              switch(switch$7)
               {case 2:break;case 0:break;default:switch$11 = 1}
              if(! switch$11)throw TacticNotApplicable}
            var
             cont=
              switch_pol[1]
               ?function(_VS_)
                 {function _VT_(_VW_,_VX_,_VY_)
                   {return forward(_VS_,_VW_,_VX_,_VY_)}
                  return function(_VU_)
                   {return function(_VV_){return _VT_(_VU_,_t9_,_VV_)}}}
               :backward;
            if(ictx)var i=ictx[1],ctx$0=[0,i,ctx];else var ctx$0=ctx;
            return caml_call4(cont,ctx$0,[0,choice,itrace],s$0[1],linkage$0)}
          function forward(ctx,itrace,opt,s)
           {if(opt)var sth=opt[1],side=sth;else var side=1;
            var es2=s[2],s2=es2[2],env2=es2[1],es1=s[1];
            return function(linkage)
             {var
               match=linkage[2],
               rsub=match[2],
               r=match[1],
               h=linkage[1],
               lsub=h[2],
               l=h[1],
               _Ss_=857475493,
               _St_=print_linkage(_Ss_,linkage);
              js_log(_St_);
              var _Su_=linkage[1],_Sv_=_Su_[1];
              if(_Su_[2])
               {var switch$0=0;
                if(typeof _Sv_ === "number" || ! (0 === _Sv_[0]))
                 switch$0 = 1;
                else
                 if(! caml_string_notequal(_Sv_[1],_uz_))
                  {var _Tu_=_Sv_[2];
                   if(_Tu_)
                    {var _Tv_=_Tu_[2];
                     if(_Tv_ && ! _Tv_[2])
                      {var _Tw_=_Su_[2];
                       if(! _Tw_[2])
                        {var
                          i$2=_Tw_[1],
                          e2=_Tv_[1],
                          e1=_Tu_[1],
                          e1$0=0 === i$2?e1:e2,
                          _Tx_=[0,70,r],
                          _Ty_=subexpr(_Tx_,rsub),
                          _Tz_=goal[1],
                          _TA_=0;
                         if(e_equal(_TA_,_Tz_,_Ty_,e1$0))
                          {var
                            res=0 === i$2?e2:e1,
                            _TB_=[0,70,r],
                            _TC_=[0,69,res],
                            _TD_=caml_call2(rewrite_subterm(_TC_),_TB_,rsub),
                            f=form_of_term(_TD_),
                            _TE_=rev(ctx);
                           return [0,fc_fill(f,_TE_),itrace]}}}}}}
              else
               if(! linkage[2][2])
                {var
                  _TF_=goal[1],
                  _TG_=0,
                  f$0=caml_call1(f_equal(_TG_,_TF_,l),r)?l:f_and(l,r),
                  _TH_=rev(ctx);
                 return [0,fc_fill(f$0,_TH_),itrace]}
              var
               switch_pol=[0,0],
               s$0=[0,s],
               new_side=[0,side],
               witness=[0,0],
               _Sx_=linkage[2],
               _Sy_=_Sx_[1],
               switch$1=0,
               _Sw_=linkage[1];
              if(typeof _Sy_ === "number")
               switch$1 = 2;
              else
               switch(_Sy_[0])
                {case 0:switch$1 = 2;break;
                 case 1:
                  var _SA_=_Sy_[1];
                  if(3257015 === _SA_)
                   {var _SB_=_Sx_[2];
                    if(_SB_)
                     {var sub=_SB_[2],i$0=_SB_[1],fs=_Sy_[2];
                      try
                       {var switch$2=0,_SF_=[0,h,[0,nth(fs,i$0),sub]],_SG_=0}
                      catch(_TP_)
                       {_TP_ = caml_wrap_exception(_TP_);
                        if(_TP_ !== Not_found)throw _TP_;
                        var
                         _SC_=failwith(_uv_),
                         _SD_=_SC_[2],
                         _SE_=_SC_[1],
                         linkage$1=_SD_,
                         ictx$0=_SE_;
                        switch$1 = 1;
                        switch$2 = 1}
                      if(! switch$2){var linkage$1=_SF_,ictx$0=_SG_;switch$1 = 1}}}
                  else
                   if(3903731 <= _SA_)
                    if(95438486 <= _SA_)
                     {var _SH_=_Sy_[2];
                      if(_SH_)
                       {var _SI_=_SH_[2];
                        if(_SI_ && ! _SI_[2])
                         {var _SJ_=_Sx_[2];
                          if(_SJ_)
                           {var _SK_=_SJ_[1],_SL_=_SI_[1],_SM_=_SH_[1];
                            if(0 === _SK_)
                             {var sub$0=_SJ_[2],_SN_=857475493;
                              if(no_prio(_SN_,h))
                               {switch_pol[1] = 1;
                                var
                                 _SO_=[0,h,[0,_SM_,sub$0]],
                                 _SP_=[0,[0,3654636,[0,_SL_,0],0]],
                                 linkage$1=_SO_,
                                 ictx$0=_SP_;
                                switch$1 = 1}}
                            else
                             if(1 === _SK_)
                              {var sub$1=_SJ_[2],_SQ_=857475493;
                               if(no_prio(_SQ_,h))
                                {switch_pol[1] = 1;
                                 var
                                  _SR_=[0,h,[0,_SL_,sub$1]],
                                  _SS_=[0,[0,3654636,[0,_SM_,0],0]],
                                  linkage$1=_SR_,
                                  ictx$0=_SS_;
                                 switch$1 = 1}}}}}}
                    else
                     {var _ST_=_Sy_[2];
                      if(_ST_ && ! _ST_[2])
                       {var _SU_=_Sx_[2];
                        if(_SU_ && 0 === _SU_[1])
                         {var sub$2=_SU_[2],f1=_ST_[1],_SV_=857475493;
                          if(no_prio(_SV_,h))
                           {switch_pol[1] = 1;
                            var _SW_=[0,h,[0,f1,sub$2]],linkage$1=_SW_,ictx$0=_uw_;
                            switch$1 = 1}}}}
                   else
                    if(3654636 <= _SA_)
                     {var _SX_=_Sy_[2];
                      if(_SX_)
                       {var _SY_=_SX_[2];
                        if(_SY_ && ! _SY_[2])
                         {var _SZ_=_Sx_[2];
                          if(_SZ_)
                           {var _S0_=_SZ_[1],_S1_=_SY_[1],_S2_=_SX_[1];
                            if(0 === _S0_)
                             {var sub$3=_SZ_[2],_S3_=857475493;
                              if(no_prio(_S3_,h))
                               {switch_pol[1] = 1;
                                var
                                 _S4_=[0,h,[0,_S2_,sub$3]],
                                 _S5_=[0,[0,3654636,[0,_S1_,0],0]],
                                 linkage$1=_S4_,
                                 ictx$0=_S5_;
                                switch$1 = 1}}
                            else
                             if(1 === _S0_)
                              {var sub$4=_SZ_[2],_S6_=857475493;
                               if(no_prio(_S6_,h))
                                {var
                                  _S7_=[0,h,[0,_S1_,sub$4]],
                                  _S8_=[0,[0,3654636,[0,_S2_,0],1]],
                                  linkage$1=_S7_,
                                  ictx$0=_S8_;
                                 switch$1 = 1}}}}}}
                    else
                     {var _S9_=_Sx_[2];
                      if(_S9_)
                       {var sub$5=_S9_[2],i$1=_S9_[1],fs$0=_Sy_[2],_S__=857475493;
                        if(no_prio(_S__,h))
                         {try
                           {var
                             switch$3=0,
                             match$0=pop_at(i$1,fs$0),
                             fs$1=match$0[2],
                             fi=match$0[1],
                             _Tc_=[0,h,[0,fi,sub$5]],
                             _Td_=[0,[0,17731,fs$1,i$1]];
                            switch$3 = 1}
                          catch(_TQ_)
                           {_TQ_ = caml_wrap_exception(_TQ_);
                            if(_TQ_ !== Not_found)throw _TQ_;
                            var
                             _S$_=failwith(_ux_),
                             _Ta_=_S$_[2],
                             _Tb_=_S$_[1],
                             linkage$1=_Ta_,
                             ictx$0=_Tb_;
                            switch$1 = 1}
                          if(switch$3){var linkage$1=_Tc_,ictx$0=_Td_;switch$1 = 1}}}}
                  break;
                 default:
                  if(840561112 <= _Sy_[1])
                   {var _Te_=_Sx_[2];
                    if(_Te_ && 0 === _Te_[1])
                     {var
                       sub$6=_Te_[2],
                       f1$0=_Sy_[4],
                       ty=_Sy_[3],
                       x=_Sy_[2],
                       _Tf_=857475493,
                       switch$4=0;
                      if(no_prio(_Tf_,h) && instantiable(env2,ctx,s2,x))
                       {var env2$0=enter(env2,x);
                        s$0[1] = [0,es1,[0,env2$0,s2]];
                        var _Tg_=[0,x,get_index(env2$0,x)],match$1=get_tag(_Tg_,s2);
                        if(! match$1)throw [0,Assert_failure,_uy_];
                        var _Th_=match$1[1];
                        if(_Th_)
                         {var e=_Th_[1],_Ti_=[0,x,0],f1$1=f_apply1(_Ti_,e,f1$0);
                          witness[1] = [0,e];
                          var
                           _Tj_=[0,h,[0,f1$1,sub$6]],
                           _Tk_=0,
                           linkage$1=_Tj_,
                           ictx$0=_Tk_;
                          switch$1 = 1}
                        else
                         {s$0[1] = [0,es1,[0,enter(env2$0,x),s2]];
                          var
                           _Tl_=[0,x,0],
                           _Tm_=0,
                           h$1=[0,f_shift(_Tm_,_Tl_,l),lsub],
                           _Tn_=[0,h$1,[0,f1$0,sub$6]],
                           _To_=[0,[1,840561112,x,ty]],
                           linkage$1=_Tn_,
                           ictx$0=_To_;
                          switch$1 = 1}}
                      else
                       switch$4 = 1}}
                  else
                   {var _Tp_=_Sx_[2];
                    if(_Tp_ && 0 === _Tp_[1])
                     {var sub$7=_Tp_[2],f1$2=_Sy_[4],ty$0=_Sy_[3],x$0=_Sy_[2];
                      s$0[1] = [0,es1,[0,enter(env2,x$0),s2]];
                      var
                       _Tq_=[0,x$0,0],
                       _Tr_=0,
                       h$2=[0,f_shift(_Tr_,_Tq_,l),lsub],
                       _Ts_=[0,h$2,[0,f1$2,sub$7]],
                       _Tt_=[0,[1,172470935,x$0,ty$0]],
                       linkage$1=_Ts_,
                       ictx$0=_Tt_;
                      switch$1 = 1}}}
              var switch$5=0;
              switch(switch$1){case 2:break;case 0:break;default:switch$5 = 1}
              if(! switch$5)
               {var h$0=linkage[2];
                s$0[1] = [0,es2,es1];
                new_side[1] = 0;
                var
                 linkage$0=[0,h$0,_Sw_],
                 ictx=0,
                 linkage$1=linkage$0,
                 ictx$0=ictx}
              if(switch_pol[1])
               var cont=backward;
              else
               var
                _Sz_=[0,new_side[1]],
                cont=
                 function(_TI_)
                  {function _TJ_(_TM_,_TN_,_TO_)
                    {return forward(_TI_,_TM_,_TN_,_TO_)}
                   return function(_TK_)
                    {return function(_TL_){return _TJ_(_TK_,_Sz_,_TL_)}}};
              if(ictx$0)var i=ictx$0[1],ctx$0=[0,i,ctx];else var ctx$0=ctx;
              var
               itrace$0=
                new_side[1] !== side
                 ?itrace
                 :[0,[0,new_side[1],witness[1]],itrace];
              return caml_call4(cont,ctx$0,itrace$0,s$0[1],linkage$1)}}
          if(typeof item_src !== "number")
           {var _RY_=item_src[1],switch$1=0;
            if(67 === _RY_)
             {if(typeof item_dst !== "number" && 72 === item_dst[1])
               {var
                 _RZ_=item_dst[2],
                 _R0_=_RZ_[2][3],
                 _R1_=_RZ_[1],
                 _R2_=item_src[2],
                 sc=s_src,
                 subc=sub_src,
                 c=_R2_,
                 sh=s_dst,
                 subh=sub_dst,
                 h=_R0_,
                 hid=_R1_;
                switch$1 = 1}}
            else
             if(72 === _RY_ && typeof item_dst !== "number")
              {var
                _Sa_=item_dst[1],
                _Sb_=item_src[2],
                _Sc_=_Sb_[2][3],
                _Sd_=_Sb_[1];
               if(67 === _Sa_)
                {var
                  _Se_=item_dst[2],
                  sc=s_dst,
                  subc=sub_dst,
                  c=_Se_,
                  sh=s_src,
                  subh=sub_src,
                  h=_Sc_,
                  hid=_Sd_;
                 switch$1 = 1}
               else
                if(72 === _Sa_)
                 {var
                   _Sf_=item_dst[2],
                   match$2=_Sf_[2],
                   h$0=match$2[3],
                   hid$0=_Sf_[1],
                   _Sg_=[0,[0,_Sc_,sub_src],[0,h$0,sub_dst]],
                   _Sh_=[0,[0,empty$8,s_src],[0,empty$8,s_dst]],
                   _Si_=0,
                   _Sj_=0,
                   _Sk_=0,
                   match$3=caml_call1(forward(_Sk_,_Sj_,_Si_,_Sh_),_Sg_),
                   itrace$2=match$3[2],
                   form$0=match$3[1],
                   _Sl_=0,
                   _Sm_=goal[3],
                   _Sn_=0,
                   _So_=0,
                   _Sp_=
                    [0,
                     [0,
                      [0,
                       [0,[0,_Sd_],0],
                       [0,[0,[0,hid$0],[0,elim_units(form$0),_So_]],_Sn_]],
                      _Sm_],
                     _Sl_],
                   itrace$0=itrace$2,
                   subgoal$0=_Sp_;
                  switch$1 = 2}}
            var switch$2=0;
            switch(switch$1)
             {case 0:break;
              case 1:
               var
                _R3_=[0,[0,h,subh],[0,c,subc]],
                _R4_=[0,[0,empty$8,sh],[0,empty$8,sc]],
                _R5_=0,
                _R6_=0,
                match$1=backward(_R6_,_R5_,_R4_,_R3_),
                itrace=match$1[2],
                form=match$1[1],
                _R7_=0,
                subgoal=[0,[0,[0,[0,[0,hid],0],0],elim_units(form)],_R7_],
                itrace$0=itrace,
                subgoal$0=subgoal;
               switch$2 = 1;
               break;
              default:switch$2 = 1}
            if(switch$2)
             {var
               itrace$1=rev(itrace$0),
               _R8_=caml_call1(print_itrace,itrace$1),
               _R9_=caml_call1(sprintf(_uA_),_R8_);
              js_log(_R9_);
              var
               _R__=[0,TLink,itrace$1],
               pr=caml_call2(sprogress(proof,_uB_,g_id),_R__,subgoal$0),
               _R$_=opened(pr);
              return fold
                      (function(_Sq_,_Sr_)
                        {return uncurry(close_with_unit,_Sq_,_Sr_)},
                       pr,
                       _R$_)}}
          throw TacticNotApplicable},
       remove_nothing=
        function(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var l=param$0[2],a=param$0[1];
              if(typeof a === "number")
               {if(481346541 === a){var param$0=l;continue}}
              else
               if(737457313 === a[1])
                {var
                  match=a[2],
                  a$0=match[2],
                  a$1=match[1],
                  _RQ_=[0,a$1,[0,a$0,0]],
                  match$0=remove_nothing(_RQ_);
                 if(match$0)
                  {var _RR_=match$0[2],_RS_=match$0[1];
                   if(_RR_)
                    {if(_RR_[2])throw [0,Assert_failure,_uC_];
                     var a$2=_RR_[1];
                     return [0,[0,737457313,[0,_RS_,a$2]],remove_nothing(l)]}
                   return [0,_RS_,remove_nothing(l)]}
                 var param$0=l;
                 continue}
              return [0,a,remove_nothing(l)]}
            return 0}},
       t_subs=
        function(t)
         {function aux(sub,param)
           {if(typeof param !== "number")
             {var _RC_=param[1],switch$0=0;
              if(69 === _RC_)
               {var _RD_=param[2];
                if(0 !== _RD_[0]){var es=_RD_[2];switch$0 = 1}}
              else
               if(70 === _RC_)
                {var _RG_=param[2];
                 if(typeof _RG_ !== "number")
                  switch(_RG_[0])
                   {case 0:var es=_RG_[2];switch$0 = 1;break;
                    case 1:
                     var
                      fs=_RG_[2],
                      _RH_=
                       function(i,f)
                        {var _RO_=[0,i,0],sub$0=append(sub,_RO_),_RP_=[0,70,f];
                         return [0,sub$0,aux(sub$0,_RP_)]},
                      _RI_=function(_RN_){return mapi(_RH_,_RN_)};
                     return flatten$0(_RI_(fs));
                    default:
                     var f=_RG_[4],sub$0=append(sub,_uD_),_RJ_=[0,70,f];
                     return [0,sub$0,aux(sub$0,_RJ_)]}}
              if(switch$0)
               {var
                 _RE_=
                  function(i,e)
                   {var _RL_=[0,i,0],sub$0=append(sub,_RL_),_RM_=[0,69,e];
                    return [0,sub$0,aux(sub$0,_RM_)]},
                 _RF_=function(_RK_){return mapi(_RE_,_RK_)};
                return flatten$0(_RF_(es))}}
            return 0}
          var _RB_=0;
          return [0,0,aux(_RB_,t)]},
       hlpred_of_lpred=
        function(p,pr,param)
         {var _Rz_=param[1];
          if(_Rz_ && ! _Rz_[2])
           {var _RA_=param[2];
            if(_RA_ && ! _RA_[2])
             {var dst=_RA_[1],src=_Rz_[1];return caml_call2(p,pr,[0,src,dst])}}
          return 0},
       mult=
        function(p1,p2,pr,lnk)
         {var
           _Ru_=caml_call2(p2,pr,lnk),
           _Rv_=caml_call2(p1,pr,lnk),
           _Rw_=cartesian_product(_Rv_,_Ru_);
          function _Rx_(param)
           {var a2=param[2],a1=param[1];return [0,737457313,[0,a1,a2]]}
          return function(_Ry_){return map$4(_Rx_,_Ry_)}(_Rw_)},
       _uE_=function(param,_Rt_){return _uF_},
       hlpred_mult=function(_Rs_){return fold(mult,_uE_,_Rs_)},
       hlpred_add=
        function(ps,pr,lnk)
         {function _Rr_(p){return caml_call2(p,pr,lnk)}
          return flatten$0(map$4(_Rr_,ps))},
       hlpred_if_empty=
        function(p1,p2,pr,lnk)
         {var actions=caml_call2(p1,pr,lnk);
          return is_empty$2(actions)?caml_call2(p2,pr,lnk):actions},
       search_linkactions=
        function(fixed_srcs,fixed_dsts,hlp,proof,param)
         {var dst=param[2],src=param[1];
          function subpath(p,sub)
           {var _Rp_=p[3],_Rq_=append(_Rp_,sub);return [0,p[1],p[2],_Rq_]}
          function query_actions(lnk)
           {var actions=caml_call2(hlp,proof,lnk);
            return actions?[0,[0,lnk,actions],0]:0}
          if(fixed_srcs)
           {var _Rf_=fixed_srcs[1];
            if(fixed_dsts)
             {var dsts=fixed_dsts[1];return query_actions([0,_Rf_,dsts])}
            var
             match=of_ipath(proof,dst)[3],
             t_dst=match[2],
             _Rg_=
              function(sub_dst)
               {var _Ro_=0;
                return query_actions([0,_Rf_,[0,subpath(dst,sub_dst),_Ro_]])};
            return bind(t_subs(t_dst),_Rg_)}
          if(fixed_dsts)
           {var
             dsts$0=fixed_dsts[1],
             match$0=of_ipath(proof,src)[3],
             t_src=match$0[2],
             _Rh_=
              function(sub_src)
               {var _Rn_=0;
                return query_actions([0,[0,subpath(src,sub_src),_Rn_],dsts$0])};
            return bind(t_subs(t_src),_Rh_)}
          var
           match$1=of_ipath(proof,src)[3],
           t_src$0=match$1[2],
           match$2=of_ipath(proof,dst)[3],
           t_dst$0=match$2[2];
          function _Ri_(sub_src)
           {function _Rj_(sub_dst)
             {var _Rk_=0,_Rl_=[0,subpath(dst,sub_dst),_Rk_],_Rm_=0;
              return query_actions([0,[0,subpath(src,sub_src),_Rm_],_Rl_])}
            return bind(t_subs(t_dst$0),_Rj_)}
          return bind(t_subs(t_src$0),_Ri_)},
       include$2=_m$_([0,compare$0,hash,equal$2]),
       V=include$2[1],
       is_directed=include$2[3],
       iter_vertex=include$2[18],
       fold_vertex=include$2[19],
       iter_succ=include$2[25],
       fold_succ=include$2[27],
       empty$13=include$2[33],
       add_edge=include$2[36],
       subst=
        function(deps,s)
         {return fold
                  (function(deps,param)
                    {var tag=param[2],x=param[1];
                     if(tag)var e=tag[1],fvs=e_vars(e);else var fvs=0;
                     try
                      {var
                        _Rc_=
                         function(y,deps)
                          {return fold
                                   (function(deps,param)
                                     {var z=param[1];return caml_call3(add_edge,deps,z,y)},
                                    deps,
                                    fvs)},
                        _Rd_=caml_call4(fold_succ,_Rc_,deps,x,deps);
                       return _Rd_}
                     catch(_Re_)
                      {_Re_ = caml_wrap_exception(_Re_);
                       if(_Re_[1] === Invalid_argument)return deps;
                       throw _Re_}},
                   deps,
                   s)},
       TraverseDeps=
        _mq_
         ([0,
           is_directed,
           [0,V[1],V[2],V[3]],
           iter_vertex,
           fold_vertex,
           iter_succ,
           fold_succ]),
       _uG_=TraverseDeps[12],
       _uH_=function(_Rb_){return 1 - _Rb_},
       acyclic=function(_Ra_){return symbol$3(_uH_,_uG_,_Ra_)},
       Env=[0],
       State$0=State(Env),
       traverse=
        function(param,i)
         {var t=param[2],p=param[1],switch$0=0;
          switch(p)
           {case 0:
             if(typeof t !== "number" && 70 === t[1])
              {var _QG_=t[2],switch$1=0;
               if(typeof _QG_ !== "number" && 2 === _QG_[0])
                if(840561112 <= _QG_[1])
                 {var _QH_=_QG_[4],_QI_=_QG_[2],f=_QH_,x=_QI_;
                  switch$0 = 1;
                  switch$1 = 1}
                else
                 {var _QK_=_QG_[4],_QL_=_QG_[2],f$0=_QK_,x$0=_QL_;
                  switch$0 = 2;
                  switch$1 = 1}}
             break;
            case 1:
             if(typeof t !== "number" && 70 === t[1])
              {var _QN_=t[2],switch$2=0;
               if(typeof _QN_ !== "number" && 2 === _QN_[0])
                if(840561112 <= _QN_[1])
                 {var _QO_=_QN_[4],_QP_=_QN_[2],f$0=_QO_,x$0=_QP_;
                  switch$0 = 2;
                  switch$2 = 1}
                else
                 {var _QQ_=_QN_[4],_QR_=_QN_[2],f=_QQ_,x=_QR_;
                  switch$0 = 1;
                  switch$2 = 1}}
             break
            }
          switch(switch$0)
           {case 0:
             var _QE_=[0,p,t],_QF_=direct_subterm_pol(_QE_,i);
             return caml_call1(State$0[1],_QF_);
            case 1:
             var
              _QJ_=
               function(param)
                {var
                  subst=param[3],
                  rnm=param[2],
                  deps=param[1],
                  _QS_=0,
                  _QT_=0,
                  z=fresh$1(_QT_,_QS_),
                  _QU_=0;
                 function _QV_(acc,param)
                  {var t=param[2],x=param[1];return 0 === t?[0,x,acc]:acc}
                 var exs=fold(_QV_,_QU_,subst);
                 function _QW_(deps,y){return caml_call3(add_edge,deps,y,z)}
                 var deps$0=fold(_QW_,deps,exs),rnm$0=[0,[0,z,x],rnm];
                 function _QX_(param)
                  {var
                    _Q1_=[0,[0,z,0]],
                    _Q2_=[0,x,0],
                    f$0=f_apply1(_Q2_,_Q1_,f);
                   return caml_call1(State$0[1],[0,p,[0,70,f$0]])}
                 var
                  _QY_=[0,deps$0,rnm$0,subst],
                  _QZ_=State$0[8],
                  _Q0_=caml_call1(_QZ_,_QY_);
                 return caml_call2(State$0[3],_Q0_,_QX_)};
             return caml_call2(State$0[3],State$0[7],_QJ_);
            default:
             var
              _QM_=
               function(st)
                {var
                  subst=st[3],
                  rnm=st[2],
                  _Q3_=0,
                  _Q4_=0,
                  z=fresh$1(_Q4_,_Q3_),
                  rnm$0=[0,[0,z,x$0],rnm],
                  _Q5_=0,
                  subst$0=push$6(z,_Q5_,subst);
                 function _Q6_(param)
                  {var
                    _Q__=[0,[0,z,0]],
                    _Q$_=[0,x$0,0],
                    f=f_apply1(_Q$_,_Q__,f$0);
                   return caml_call1(State$0[1],[0,p,[0,70,f]])}
                 var
                  _Q7_=[0,st[1],rnm$0,subst$0],
                  _Q8_=State$0[8],
                  _Q9_=caml_call1(_Q8_,_Q7_);
                 return caml_call2(State$0[3],_Q9_,_Q6_)};
             return caml_call2(State$0[3],State$0[7],_QM_)}},
       _uI_=State$0[5],
       traverse$0=caml_call1(_uI_,traverse),
       arg$1=
        function(opt)
         {if(opt)var sth=opt[1],drewrite=sth;else var drewrite=0;
          function is_eq_operand(proof,p)
           {try
             {var
               _Qx_=p[3],
               _Qy_=p[3],
               _Qz_=length(_Qy_) - 1 | 0,
               eq_sub=remove_at(_Qz_,_Qx_),
               eq_path=[0,p[1],p[2],eq_sub],
               match=of_ipath(proof,eq_path)[3],
               t=match[2],
               switch$0=0;
              if(typeof t !== "number" && 70 === t[1])
               {var _QB_=t[2],switch$1=0;
                if(typeof _QB_ !== "number" && 0 === _QB_[0])
                 if(caml_string_notequal(_QB_[1],_uJ_))
                  switch$1 = 1;
                 else
                  {var _QC_=1,_QA_=_QC_;switch$0 = 1;switch$1 = 1}}
              if(! switch$0)var _QA_=0;
              return _QA_}
            catch(_QD_)
             {_QD_ = caml_wrap_exception(_QD_);
              if(_QD_[1] === Invalid_argument)return 0;
              throw _QD_}}
          return function(proof,param)
           {var
             dst=param[2],
             src=param[1],
             _PM_=of_ipath(proof,src),
             match=_PM_[3],
             t_src=match[2],
             sub_src=match[1],
             item_src=_PM_[2],
             goal=_PM_[1],
             _PN_=of_ipath(proof,dst),
             match$0=_PN_[3],
             t_dst=match$0[2],
             sub_dst=match$0[1],
             item_dst=_PN_[2];
            try
             {var
               _PO_=[0,item_src,item_dst],
               match$1=pair_map(form_of_item,_PO_),
               f2=match$1[2],
               f1=match$1[1],
               p1=pol_of_item(item_src),
               p2=pol_of_item(item_dst),
               _PP_=[0,empty$13,0,empty$10],
               _PQ_=
                function(param)
                 {var sf1=param[2],sp1=param[1];
                  function _Qo_(st1)
                   {function _Qp_(param)
                     {function _Qt_(param)
                       {var sf2=param[2],sp2=param[1];
                        function _Qw_(st2)
                         {return caml_call1
                                  (State$0[1],
                                   [0,st2[1],sp1,sf1,st1[2],st1[3],sp2,sf2,st2[2],st2[3]])}
                        return caml_call2(State$0[3],State$0[7],_Qw_)}
                      var
                       _Qu_=[0,p2,[0,70,f2]],
                       _Qv_=caml_call2(traverse$0,_Qu_,sub_dst);
                      return caml_call2(State$0[3],_Qv_,_Qt_)}
                    var
                     _Qq_=[0,st1[1],0,empty$10],
                     _Qr_=State$0[8],
                     _Qs_=caml_call1(_Qr_,_Qq_);
                    return caml_call2(State$0[3],_Qs_,_Qp_)}
                  return caml_call2(State$0[3],State$0[7],_Qo_)},
               _PR_=[0,p1,[0,70,f1]],
               _PS_=caml_call2(traverse$0,_PR_,sub_src),
               _PT_=State$0[3],
               _PU_=caml_call2(_PT_,_PS_,_PQ_),
               _PV_=State$0[9],
               match$2=caml_call2(_PV_,_PU_,_PP_),
               s2=match$2[9],
               rnm2=match$2[8],
               st2=match$2[7],
               sp2=match$2[6],
               s1=match$2[5],
               rnm1=match$2[4],
               st1=match$2[3],
               sp1=match$2[2],
               deps=match$2[1],
               s1$0=aslist(s1),
               s2$0=aslist(s2),
               _PW_=append(s1$0,s2$0),
               s=oflist(_PW_),
               switch$0=0;
              if(70 <= st1[1])
               {if(typeof st2 !== "number" && 70 === st2[1])
                 {var f2$0=st2[2],f1$0=st1[2];
                  if(! drewrite)
                   {var switch$1=0;
                    switch(sp1)
                     {case 0:if(0 === sp2)switch$1 = 1;break;
                      case 1:if(1 === sp2)switch$1 = 1;break
                      }
                    if(switch$1)
                     var _P8_=0;
                    else
                     var
                      _P__=[0,[0,f1$0,f2$0],0],
                      _P$_=goal[2][1],
                      _P8_=caml_call1(f_unify(_P$_,empty$8,s),_P__);
                    var _P9_=_P8_;
                    switch$0 = 1}}}
              else
               if(typeof st2 !== "number" && 69 === st2[1])
                {var e2=st2[2],e1=st1[2],switch$2=0;
                 if(drewrite)
                  {var
                    env=goal[2][1],
                    _Qa_=expr_of_term(t_src),
                    _Qb_=env_of_ipath(proof,src),
                    ty1=einfer(_Qb_,_Qa_),
                    _Qc_=expr_of_term(t_dst),
                    _Qd_=env_of_ipath(proof,dst),
                    ty2=einfer(_Qd_,_Qc_),
                    _Qe_=0;
                   if(t_equal(_Qe_,env,ty1,ty2))
                    {var
                      _Qf_=[0,src,dst],
                      _Qg_=function(_Qn_){return is_eq_operand(proof,_Qn_)},
                      match$4=pair_map(_Qg_,_Qf_),
                      eq2=match$4[2],
                      eq1=match$4[1],
                      switch$3=0;
                     if(1 === sp1 && eq1)switch$3 = 1;
                     var switch$4=0;
                     if(! switch$3)
                      {var switch$5=0;
                       if(1 === sp2 && eq2)switch$5 = 1;
                       if(! switch$5){var _Qj_=0;switch$4 = 1}}
                     if(! switch$4)
                      var
                       _Qh_=[0,[0,e1,e2],0],
                       _Qi_=goal[2][1],
                       _Qj_=e_unify(_Qi_,empty$8,s,_Qh_);
                     var _P9_=_Qj_;
                     switch$0 = 1;
                     switch$2 = 1}}}
              var s$0=switch$0?_P9_:0,switch$6=0;
              if(s$0)
               {var s$1=s$0[1],_PX_=subst(deps,s$1);
                if(acyclic(_PX_))
                 {var
                   _PY_=aslist(s$1),
                   _PZ_=length(s1$0),
                   match$3=split_nth(_PZ_,_PY_),
                   s2$1=match$3[2],
                   s1$1=match$3[1],
                   rename=
                    function(rnm1,rnm2)
                     {function _Ql_(param)
                       {var tag=param[2],x=param[1];
                        function get_name(x,rnm)
                         {return default$0(x,assoc_opt(x,rnm))}
                        var x$0=get_name(x,rnm1);
                        function rename(param)
                         {if(0 === param[0])
                           {var match=param[1],i=match[2],x=match[1];
                            return [0,[0,get_name(x,rnm2),i]]}
                          var es=param[2],f=param[1];
                          return [1,f,map$4(rename,es)]}
                        if(tag)var e=tag[1],tag$0=[0,rename(e)];else var tag$0=tag;
                        return [0,x$0,tag$0]}
                      return function(_Qm_){return map$4(_Ql_,_Qm_)}},
                   _P0_=rename(rnm1,rnm2),
                   _P1_=caml_call1(_P0_,s1$1),
                   _P2_=rev(_P1_),
                   s1$2=oflist(_P2_),
                   _P3_=rename(rnm2,rnm1),
                   _P4_=caml_call1(_P3_,s2$1),
                   _P5_=rev(_P4_),
                   s2$2=oflist(_P5_),
                   _P6_=[0,[0,-197397852,[0,s1$2,s2$2]],0],
                   _P7_=_P6_;
                  switch$6 = 1}}
              if(! switch$6)var _P7_=0;
              return _P7_}
            catch(_Qk_)
             {_Qk_ = caml_wrap_exception(_Qk_);
              if(_Qk_[1] === Invalid_argument)return 0;
              throw _Qk_}}},
       intuitionistic_link=
        function(proof,param)
         {var dst=param[2],src=param[1];
          function neg_count$0(p)
           {var
             _PK_=of_ipath(proof,p),
             match=_PK_[3],
             sub=match[1],
             it=_PK_[2],
             f=form_of_item(it),
             n=neg_count(f,sub),
             _PL_=it[1];
            if(72 === _PL_)return n + 1 | 0;
            if(86 <= _PL_)throw [0,Invalid_argument,_uK_];
            return n}
          try
           {var m=neg_count$0(src),match=neg_count$0(dst),switch$0=0;
            if(! (0 < m) || ! (0 < match))switch$0 = 1;
            var switch$1=0;
            if(switch$0)
             {var switch$2=0;
              if(0 === m && ! (1 < match))switch$2 = 1;
              if(! switch$2)
               {var switch$3=0;
                if(! (1 < m) && 0 === match)switch$3 = 1;
                if(! switch$3){var _PI_=0;switch$1 = 1}}}
            if(! switch$1)var _PI_=_uL_;
            return _PI_}
          catch(_PJ_)
           {_PJ_ = caml_wrap_exception(_PJ_);
            if(_PJ_[1] !== InvalidSubFormPath && _PJ_[1] !== Invalid_argument)
             throw _PJ_;
            return 0}},
       is_free_expr=
        function(t,sub)
         {var _Py_=[0,empty$8,t];
          function _Pz_(param,i)
           {var t=param[2],lenv=param[1],switch$0=0;
            if(typeof t !== "number" && 70 === t[1])
             {var _PG_=t[2],switch$1=0;
              if(typeof _PG_ !== "number" && 2 === _PG_[0])
               {var x=_PG_[2],_PH_=enter(lenv,x),lenv$0=_PH_;
                switch$0 = 1;
                switch$1 = 1}}
            if(! switch$0)var lenv$0=lenv;
            var t$0=direct_subterm(t,i);
            return [0,lenv$0,t$0]}
          var match=fold(_Pz_,_Py_,sub),subt=match[2],lenv=match[1];
          if(70 <= subt[1])return 0;
          var e=subt[2],_PA_=e_vars(e);
          function _PB_(_PF_){return exists$2(lenv,_PF_)}
          function _PC_(_PE_){return 1 - _PE_}
          return for_all(function(_PD_){return symbol$3(_PC_,_PB_,_PD_)},_PA_)},
       instantiate_link=
        function(proof,param)
         {var dsts=param[2],srcs=param[1];
          function to_form(p_wit,p_form)
           {var
             _Pp_=of_ipath(proof,p_wit),
             _Pq_=_Pp_[3],
             wit=_Pq_[2],
             sub_wit=_Pq_[1],
             item_wit=_Pp_[2],
             match=_Pp_[1],
             goal=match[2],
             _Pr_=p_wit[2][1],
             switch$0=0;
            if(typeof _Pr_ !== "number" && 4298439 === _Pr_[1])
             {var w=_Pr_[2],where=w;switch$0 = 1}
            if(! switch$0)var where=737453762;
            var _Ps_=[0,where],ctxt_wit=term_of_item(_Ps_,item_wit);
            if(is_free_expr(ctxt_wit,sub_wit))
             {var
               pol=pol_of_ipath(proof,p_form),
               f=term_of_ipath(proof,p_form),
               wit$0=expr_of_term(wit),
               _Pt_=goal[1],
               ty_wit=einfer(_Pt_,wit$0),
               switch$1=0;
              switch(pol)
               {case 0:
                 if(typeof f !== "number" && 70 === f[1])
                  {var _Pu_=f[2],switch$2=0;
                   if(typeof _Pu_ !== "number" && 2 === _Pu_[0])
                    if(172470935 === _Pu_[1])
                     {var ty=_Pu_[3];switch$1 = 1;switch$2 = 1}
                    else
                     switch$2 = 1}
                 break;
                case 1:
                 if(typeof f !== "number" && 70 === f[1])
                  {var _Px_=f[2],switch$3=0;
                   if(typeof _Px_ !== "number" && 2 === _Px_[0])
                    if(840561112 === _Px_[1])
                     {var ty=_Px_[3];switch$1 = 1;switch$3 = 1}
                    else
                     switch$3 = 1}
                 break
                }
              if(switch$1)
               {var _Pv_=goal[1],_Pw_=0;
                if(t_equal(_Pw_,_Pv_,ty,ty_wit))
                 return [0,[0,-641049974,[0,wit$0,p_form]],0]}
              return 0}
            return 0}
          if(srcs && ! srcs[2] && dsts && ! dsts[2])
           {var
             dst=dsts[1],
             src=srcs[1],
             _Pl_=[0,src,dst],
             _Pm_=function(_Po_){return term_of_ipath(proof,_Po_)},
             match=pair_map(_Pm_,_Pl_);
            if(70 <= match[1][1])
             {var _Pn_=match[2];
              if(typeof _Pn_ !== "number" && 69 === _Pn_[1])
               return to_form(dst,src);
              return 0}
            return 70 <= match[2][1]?to_form(src,dst):0}
          return 0},
       rewrite_link=
        function(proof,lnk)
         {function rewrite_data(p)
           {if(3607583 === p[2][1])
             {var
               match=of_ipath(proof,p),
               it=match[2],
               _Pb_=p[3],
               match$0=form_of_item(it);
              if(_Pb_)
               {var _Pc_=_Pb_[1],switch$0=0;
                if(0 === _Pc_)
                 {if(! _Pb_[2])
                   {var switch$1=0;
                    if(typeof match$0 !== "number" && 0 === match$0[0])
                     if(caml_string_notequal(match$0[1],_uM_))
                      switch$1 = 1;
                     else
                      {var _Pd_=match$0[2];
                       if(_Pd_)
                        {var _Pe_=_Pd_[2];
                         if(_Pe_ && ! _Pe_[2])
                          {var _Pf_=_Pe_[1],_Pg_=_Pd_[1],res=_Pf_,red=_Pg_;
                           switch$0 = 1;
                           switch$1 = 1}
                         else
                          switch$1 = 1}
                       else
                        switch$1 = 1}}}
                else
                 if(1 === _Pc_ && ! _Pb_[2])
                  {var switch$2=0;
                   if(typeof match$0 !== "number" && 0 === match$0[0])
                    if(caml_string_notequal(match$0[1],_uN_))
                     switch$2 = 1;
                    else
                     {var _Ph_=match$0[2];
                      if(_Ph_)
                       {var _Pi_=_Ph_[2];
                        if(_Pi_ && ! _Pi_[2])
                         {var _Pj_=_Pi_[1],_Pk_=_Ph_[1],res=_Pk_,red=_Pj_;
                          switch$0 = 1;
                          switch$2 = 1}
                        else
                         switch$2 = 1}
                      else
                       switch$2 = 1}}
                if(switch$0)return [0,[0,red,res]]}
              return 0}
            return 0}
          try
           {var
             _OS_=function(_Pa_){return symbol$2(hd,rewrite_data,_Pa_)},
             match=pair_map(_OS_,lnk),
             _OT_=lnk[1],
             switch$0=0;
            if(_OT_ && ! _OT_[2])
             {var _O3_=lnk[2],switch$1=0;
              if(_O3_ && ! _O3_[2])
               {var _O8_=match[1];
                if(_O8_)
                 {if(match[2])
                   {var
                     match$0=_O8_[1],
                     res$0=match$0[2],
                     red$0=match$0[1],
                     dst=_O3_[1],
                     _O9_=[0,[0,71624748,[0,red$0,res$0,[0,dst,0]]],0],
                     _OV_=_O9_;
                    switch$0 = 1;
                    switch$1 = 1}}
                else
                 switch$1 = 1}
              if(! switch$1)
               {var _O4_=match[1];
                if(_O4_)
                 {var
                   _O5_=_O4_[1],
                   _O6_=_O5_[2],
                   _O7_=_O5_[1],
                   res=_O6_,
                   red=_O7_,
                   tgts=_O3_;
                  switch$0 = 2}}}
            var switch$2=0;
            switch(switch$0)
             {case 0:
               var _OU_=lnk[2],switch$3=0;
               if(_OU_ && ! _OU_[2])
                {var _OX_=match[2];
                 if(_OX_)
                  {var
                    _OY_=_OX_[1],
                    _OZ_=_OY_[2],
                    _O0_=_OY_[1],
                    res=_OZ_,
                    red=_O0_,
                    tgts=_OT_;
                   switch$2 = 1;
                   switch$3 = 1}}
               if(! switch$3)var _OV_=0;
               break;
              case 1:break;
              default:switch$2 = 1}
            if(switch$2)
             var
              _O1_=function(p){var _O$_=p[2][1];return caml_equal(_O$_,_uO_)},
              _O2_=exists(_O1_,tgts)?0:[0,[0,71624748,[0,red,res,tgts]],0],
              _OW_=_O2_;
            else
             var _OW_=_OV_;
            return _OW_}
          catch(_O__)
           {_O__ = caml_wrap_exception(_O__);
            if(_O__[1] === Failure)return 0;
            throw _O__}},
       fold_link=
        function(proof,lnk)
         {function fold_data(p)
           {var match=of_ipath(proof,p),it=match[2],_OP_=p[2][1],_OQ_=p[3];
            if(typeof it !== "number" && 86 === it[1])
             {var _OR_=it[2];
              if
               (_OR_[2][2]
                &&
                typeof _OP_
                !==
                "number"
                &&
                4298439
                ===
                _OP_[1]
                &&
                !
                _OQ_)
               {var where=_OP_[2],x=_OR_[1];return [0,[0,x,where]]}}
            return 0}
          try
           {var
             _Ok_=function(_OO_){return symbol$2(hd,fold_data,_OO_)},
             match=pair_map(_Ok_,lnk),
             _Ol_=lnk[1],
             switch$0=0;
            if(_Ol_ && ! _Ol_[2])
             {var _OB_=lnk[2],switch$1=0,_OC_=_Ol_[1];
              if(_OB_ && ! _OB_[2])
               {var _OH_=match[1];
                if(_OH_)
                 {var _OI_=_OH_[1];
                  if(737453762 === _OI_[2])
                   {var _OJ_=match[2];
                    if(_OJ_ && 737453762 === _OJ_[1][2])
                     {var
                       x$0=_OI_[1],
                       dst=_OB_[1],
                       _OK_=[0,[0,781813793,[0,x$0,[0,dst,0]]],0],
                       _On_=_OK_;
                      switch$0 = 1;
                      switch$1 = 1}}}
                else
                 switch$1 = 1}
              if(! switch$1)
               {var _OD_=match[1];
                if(_OD_)
                 {var
                   _OE_=_OD_[1],
                   _OF_=_OE_[2],
                   _OG_=_OE_[1],
                   where=_OF_,
                   x=_OG_,
                   tgts=_OB_,
                   p=_OC_;
                  switch$0 = 2}}}
            var switch$2=0;
            switch(switch$0)
             {case 0:
               var _Om_=lnk[2],switch$3=0;
               if(_Om_ && ! _Om_[2])
                {var _Op_=match[2];
                 if(_Op_)
                  {var
                    _Oq_=_Op_[1],
                    _Or_=_Oq_[2],
                    _Os_=_Oq_[1],
                    _Ot_=_Om_[1],
                    where=_Or_,
                    x=_Os_,
                    tgts=_Ol_,
                    p=_Ot_;
                   switch$2 = 1;
                   switch$3 = 1}}
               if(! switch$3)var _On_=0;
               break;
              case 1:break;
              default:switch$2 = 1}
            if(switch$2)
             {var
               is_head=
                function(p){var _ON_=p[2][1];return caml_equal(_ON_,_uP_)};
              if(803493184 === where)
               var _Ou_=exists(is_head,tgts)?0:[0,[0,371840762,[0,x,tgts]],0];
              else
               {var match$0=find_all$0(is_head,tgts);
                if(match$0)
                 {var _Ov_=match$0[1];
                  if(match$0[2])
                   var _Ow_=0;
                  else
                   var
                    _Oy_=fold_data(_Ov_),
                    _Oz_=0,
                    _OA_=
                     function(param)
                      {var y=param[1],_OM_=0;
                       return [0,
                               [0,371840762,[0,y,[0,p,remove$0(tgts,_Ov_)]]],
                               _OM_]},
                    _Ow_=map_default(_OA_,_Oz_,_Oy_);
                  var _Ox_=_Ow_}
                else
                 var _Ox_=[0,[0,781813793,[0,x,tgts]],0];
                var _Ou_=_Ox_}
              var _Oo_=_Ou_}
            else
             var _Oo_=_On_;
            return _Oo_}
          catch(_OL_)
           {_OL_ = caml_wrap_exception(_OL_);
            if(_OL_[1] === Failure)return 0;
            throw _OL_}},
       lemmas=
        function(selection,proof)
         {var
           _NX_=0,
           _NY_=arg$1(_uQ_),
           _NZ_=
            [0,
             function(_Oi_,_Oj_){return hlpred_of_lpred(_NY_,_Oi_,_Oj_)},
             _NX_],
           _N0_=[0,intuitionistic_link,0],
           _N1_=[0,function(eta){return caml_call1(arg$1(0),eta)},_N0_],
           _N2_=map$4(hlpred_of_lpred,_N1_),
           _N3_=[0,hlpred_mult(_N2_),_NZ_];
          function filter(_Og_,_Oh_){return hlpred_add(_N3_,_Og_,_Oh_)}
          if(selection)
           {var _N4_=selection[1];
            if(_N4_)
             {var
               p=_N4_[1],
               match=goal_of_ipath(proof,p),
               sub=match[2],
               g_id=match[1],
               _N5_=db(proof),
               _N6_=all$1(_N5_),
               _N7_=
                function(param)
                 {var
                   stmt=param[2],
                   _N9_=0,
                   hd=fresh$2(_N9_),
                   _N__=0,
                   _N$_=0,
                   hyp=mk_hyp(_N$_,_N__,stmt),
                   _Oa_=sub[2],
                   g_hyps=add$11(_Oa_,hd,hyp),
                   sub$0=[0,sub[1],g_hyps,sub[3]],
                   _Ob_=[0,TAssume,stmt,g_id],
                   match=hprogress(proof,g_id,_Ob_,sub$0),
                   proof$0=match[2],
                   g_id$0=match[1],
                   _Oc_=toint(g_id$0),
                   _Od_=0,
                   _Oe_=[0,[0,3607583,toint(hd)]],
                   lp=mk_ipath(_Oe_,_Od_,_Oc_);
                  function _Of_(src)
                   {return search_linkactions
                            ([0,[0,src,0]],0,filter,proof$0,[0,dummy_path,lp])}
                  var linkactions=bind(_N4_,_Of_);
                  return 1 - is_empty$2(linkactions)};
              return function(_N8_){return find_all$0(_N7_,_N8_)}(_N6_)}}
          return all$1(db(proof))},
       dnd_actions=
        function(param,proof)
         {var
           selection=param[2],
           dnd=param[1],
           _Nn_=dnd[1],
           goal=goal_of_ipath(proof,_Nn_),
           g_id=goal[1],
           _No_=dnd[1];
          function _Np_(_NW_){return is_sub_path(_No_,_NW_)}
          var srcsel=find_all$0(_Np_,selection);
          function _Nq_(p){return p[2][2] === dnd[1][2][2]?1:0}
          var dstsel=remove_if(_Nq_,selection);
          function hlpred_only_sel(p,pr,lnk)
           {var _NV_=[0,srcsel,dstsel];
            return caml_equal(lnk,_NV_)?caml_call2(p,pr,lnk):0}
          var
           _Nr_=[0,instantiate_link,0],
           _Ns_=
            [0,
             function(_NT_,_NU_){return hlpred_only_sel(fold_link,_NT_,_NU_)},
             _Nr_];
          function _Nt_(_NR_,_NS_)
           {return hlpred_only_sel(rewrite_link,_NR_,_NS_)}
          var _Nu_=arg$1(_uR_);
          function _Nv_(_NP_,_NQ_){return hlpred_of_lpred(_Nu_,_NP_,_NQ_)}
          var
           _Nw_=
            [0,
             function(_NN_,_NO_){return hlpred_if_empty(_Nv_,_Nt_,_NN_,_NO_)},
             _Ns_],
           _Nx_=[0,intuitionistic_link,0],
           _Ny_=[0,function(eta){return caml_call1(arg$1(0),eta)},_Nx_],
           _Nz_=map$4(hlpred_of_lpred,_Ny_),
           _NA_=[0,hlpred_mult(_Nz_),_Nw_];
          function hlp(_NL_,_NM_){return hlpred_add(_NA_,_NL_,_NM_)}
          if(srcsel)
           var
            _NB_=[0,srcsel],
            _NC_=[0,dummy_path,0],
            fixed_srcs=_NB_,
            srcs=_NC_;
          else
           var
            srcs$0=[0,dnd[1],0],
            fixed_srcs$0=0,
            fixed_srcs=fixed_srcs$0,
            srcs=srcs$0;
          if(dstsel)
           var
            _ND_=[0,dstsel],
            _NE_=[0,dummy_path,0],
            fixed_dsts=_ND_,
            dsts=_NE_;
          else
           {var _NF_=dnd[2];
            if(_NF_)
             var dst=_NF_[1],dsts$0=[0,dst,0];
            else
             var
              src=dnd[1],
              _NG_=0,
              _NH_=all_items_ipaths(_NG_,goal),
              dsts$0=remove$0(_NH_,src);
            var fixed_dsts$0=0,fixed_dsts=fixed_dsts$0,dsts=dsts$0}
          return bind
                  (srcs,
                   function(src)
                    {return bind
                             (dsts,
                              function(dst)
                               {var
                                 _NI_=[0,src,dst],
                                 linkactions=
                                  search_linkactions(fixed_srcs,fixed_dsts,hlp,proof,_NI_);
                                return bind
                                        (linkactions,
                                         function(param)
                                          {var
                                            actions=param[2],
                                            lnk=param[1],
                                            dsts=lnk[2],
                                            srcs=lnk[1],
                                            actions$0=remove_nothing(actions);
                                           return bind
                                                   (srcs,
                                                    function(src)
                                                     {return bind
                                                              (dsts,
                                                               function(dst)
                                                                {var
                                                                  _NJ_=[0,g_id,[0,-611444666,[0,lnk,actions$0]]],
                                                                  _NK_=[0,3406170,[0,src,dst]];
                                                                 return return$2([0,_uS_,append(srcs,dsts),_NK_,_NJ_])})})})})})},
       actions=
        function(proof,p)
         {var _MT_=p[1];
          if(3406170 <= _MT_[1])
           {var dnd=_MT_[2];return dnd_actions([0,dnd,p[2]],proof)}
          var
           path=_MT_[2],
           _MU_=of_ipath(proof,path),
           item=_MU_[2],
           match=_MU_[1],
           goal=match[2],
           hd=match[1],
           _MV_=item[1];
          if(72 === _MV_)
           {var
             match$0=item[2],
             rp=match$0[1],
             _MW_=toint(hd),
             _MX_=0,
             _MY_=[0,[0,3607583,toint(rp)]],
             hg=mk_ipath(_MY_,_MX_,_MW_);
            return [0,
                    [0,_uT_,[0,hg,0],[0,-611587032,hg],[0,hd,[0,770574379,rp]]],
                    0]}
          if(86 <= _MV_)
           {var _MZ_=item[2],_M0_=_MZ_[2],_M2_=_MZ_[1],_M1_=_M0_[1];
            if(_M0_[2])
             {var
               _M3_=goal[1],
               _M4_=getid(_M3_,_M2_),
               rp$0=get$3(_M4_),
               _M5_=toint(hd),
               _M6_=0,
               _M7_=[0,[0,_uU_,rp$0]],
               hg_unfold=mk_ipath(_M7_,_M6_,_M5_),
               _M8_=toint(hd),
               _M9_=0,
               _M__=[0,[0,_uV_,rp$0]],
               hg_fold=mk_ipath(_M__,_M9_,_M8_);
              return [0,
                      [0,
                       _uX_,
                       [0,hg_unfold,0],
                       [0,-611587032,hg_unfold],
                       [0,hd,[0,371840762,_M2_]]],
                      [0,
                       [0,
                        _uW_,
                        [0,hg_fold,0],
                        [0,-611587032,hg_fold],
                        [0,hd,[0,781813793,_M2_]]],
                       0]]}
            var _M$_=goal[1],_Na_=0;
            if(t_equal(_Na_,_M$_,_M1_,nat))
             {var
               _Nb_=goal[1],
               _Nc_=getid(_Nb_,_M2_),
               rp$1=get$3(_Nc_),
               _Nd_=toint(hd),
               _Ne_=0,
               _Nf_=[0,[0,_uY_,rp$1]],
               hg$0=mk_ipath(_Nf_,_Ne_,_Nd_),
               _Ng_=0;
              return [0,
                      [0,
                       _uZ_,
                       [0,hg$0,0],
                       [0,-611587032,hg$0],
                       [0,hd,[0,3654847,ofint(rp$1)]]],
                      _Ng_]}
            return 0}
          var _Nh_=[0,proof,hd],iv=ivariants(_Nh_),bv=length(iv) <= 1?1:0;
          return mapi
                  (function(i,x)
                    {var _Ni_=toint(hd);
                     if(bv)
                      var _Nj_=0;
                     else
                      var _Nm_=length(iv),_Nj_=rebuild_pathd(_Nm_,i);
                     var _Nk_=[0,_Nj_],_Nl_=0,hg=mk_ipath(_Nl_,_Nk_,_Ni_);
                     return [0,
                             x,
                             [0,hg,0],
                             [0,-611587032,hg],
                             [0,hd,[0,-783402420,i]]]},
                   iv)},
       apply=
        function(proof,param)
         {var a=param[2],hd=param[1],targ=[0,proof,hd],_MI_=a[1];
          if(371840762 <= _MI_)
           {if(770574379 === _MI_)
             {var
               subhd=a[2],
               goal=byid$1(proof,hd),
               _MJ_=goal[2],
               form=byid$0(_MJ_,subhd)[3],
               _MK_=0,
               _ML_=goal[1],
               _MM_=0,
               clear=caml_call1(f_equal(_MM_,_ML_,form),_MK_);
              return arg$0([0,clear],subhd,targ)}
            if(822537815 <= _MI_)
             {if(857475493 <= _MI_)
               {var
                 match=a[2],
                 s=match[4],
                 p=match[3],
                 dst=match[2],
                 src=match[1];
                return forward([0,src,dst,p,s],targ)}
              var subhd$0=a[2];
              return and_drop(subhd$0,targ)}
            if(781813793 <= _MI_){var x=a[2];return unfold_all(_u0_,x,targ)}
            var x$0=a[2];
            return unfold_all(0,x$0,targ)}
          if(-259955253 <= _MI_)
           {if(3654847 <= _MI_)
             {var subhd$1=a[2];return induction(subhd$1,targ)}
            var
             match$0=a[2],
             fl=match$0[2],
             subhd$2=match$0[1],
             _MN_=function(x){return [0,[0,[0,[0,hd],0],0],x]};
            return or_drop(subhd$2,targ,map$4(_MN_,fl))}
          if(-611444666 <= _MI_)
           {var
             match$1=a[2],
             actions=match$1[2],
             lnk=match$1[1],
             _MO_=lnk[1],
             switch$0=0;
            if(_MO_ && ! _MO_[2])
             {var _MR_=lnk[2];
              if(_MR_ && ! _MR_[2])
               if(actions)
                {var _MS_=actions[1];
                 if
                  (typeof _MS_
                   !==
                   "number"
                   &&
                   -197397852
                   ===
                   _MS_[1]
                   &&
                   !
                   actions[2])
                  {var substs=_MS_[2],dst$0=_MR_[1],src$0=_MO_[1];
                   return dlink([0,src$0,dst$0],substs,targ)}}
               else
                switch$0 = 1}
            if(! switch$0 && actions)
             {var _MP_=actions[1];
              if(typeof _MP_ !== "number")
               {var _MQ_=_MP_[1];
                if(71624749 <= _MQ_)
                 {if(371840762 === _MQ_)
                   {if(! actions[2])
                     {var match$2=_MP_[2],tgts=match$2[2],x$1=match$2[1];
                      return caml_call2(unfold(0,x$1),tgts,targ)}}
                  else
                   if(781813793 === _MQ_ && ! actions[2])
                    {var match$3=_MP_[2],tgts$0=match$3[2],x$2=match$3[1];
                     return caml_call2(unfold(_u2_,x$2),tgts$0,targ)}}
                else
                 if(-641049974 === _MQ_)
                  {if(! actions[2])
                    {var match$4=_MP_[2],tgt=match$4[2],wit=match$4[1];
                     return instantiate(wit,tgt,targ)}}
                 else
                  if(71624748 <= _MQ_ && ! actions[2])
                   {var
                     match$5=_MP_[2],
                     tgts$1=match$5[3],
                     res=match$5[2],
                     red=match$5[1];
                    return caml_call1(rewrite_in(red,res,tgts$1),targ)}}
              if(actions[2])return failwith(_u1_)}
            throw TacticNotApplicable}
          var variant=a[2];
          return intro([0,[0,variant,0]],targ)},
       InvalidASource=[248,_vf_,caml_fresh_oo_id(0)],
       InvalidLemmaDB=[248,_vg_,caml_fresh_oo_id(0)],
       translators=[0,0],
       register=
        function(tx)
         {var _MG_=[0,tx,0],_MH_=translators[1];
          translators[1] = append(_MH_,_MG_);
          return 0},
       translate$0=
        function(e)
         {var Found=[248,_vh_,caml_fresh_oo_id(0)];
          try
           {var
             _MA_=translators[1],
             _MB_=
              function(tx)
               {var _MD_=caml_call1(tx,e);
                function _ME_(msg){throw [0,Found,msg]}
                return function(_MF_){return may(_ME_,_MF_)}(_MD_)};
            iter$0(_MB_,_MA_);
            var _MC_=0;
            return _MC_}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Found){var msg=exn[2];return [0,msg]}
            throw exn}},
       as_string=
        function(exn,v)
         {var _Mz_=typeof v,match=caml_string_of_jsstring(_Mz_);
          if(caml_string_notequal(match,_vi_))throw exn;
          return caml_string_of_jsstring(v)},
       _vj_=
        function(exn)
         {if(exn[1] === ParseError)return _vk_;
          if(exn[1] === DuplicatedEntry)
           {var name=exn[3],_Mx_=cat(name,_vl_);return [0,cat(_vm_,_Mx_)]}
          if(exn[1] === LemmaNotFound)
           {var name$0=exn[2],_My_=cat(name$0,_vn_);return [0,cat(_vo_,_My_)]}
          if(exn !== TypingError && exn !== RecheckFailure)
           return exn === TacticNotApplicable?_vq_:0;
          return _vp_};
      register(_vj_);
      var
       symbol$5=
        function(f,x)
         {try
           {var _Mv_=caml_call1(f,x);return _Mv_}
          catch(e)
           {e = caml_wrap_exception(e);
            var
             _Mq_=translate$0(e),
             _Mr_=
              function(param)
               {var _Mw_=to_string$5(e);
                return caml_call1(sprintf$0(_vr_),_Mw_)},
             msg=default_delayed(_Mr_,_Mq_),
             _Ms_=0,
             _Mt_=caml_jsstring_of_string(msg),
             _Mu_=function(t1,t0,param){return new t1(t0)};
            return raise_js_error(_Mu_(error_constr,_Mt_,_Ms_))}},
       of_obj=
        function(obj)
         {function _Mo_(_Mp_){return as_string(InvalidASource,_Mp_)}
          return ipath_of_path(_Mo_(obj))},
       of_array$0=
        function(obj)
         {var _Ml_=caml_js_to_array(obj),_Mm_=to_list(_Ml_);
          return function(_Mn_){return map$4(of_obj,_Mn_)}(_Mm_)},
       of_opt=
        function(obj)
         {var _Mj_=to_option(obj);
          return function(_Mk_){return map$3(of_obj,_Mk_)}(_Mj_)},
       js_proof_engine=function _Mi_(_Mh_){return _Mi_.fun(_Mh_)},
       js_subgoal=function _Mg_(_Me_,_Mf_){return _Mg_.fun(_Me_,_Mf_)},
       js_hyps=function _Md_(_Mb_,_Mc_){return _Md_.fun(_Mb_,_Mc_)},
       js_tvar=function _Ma_(_L__,_L$_){return _Ma_.fun(_L__,_L$_)},
       js_form=function _L9_(_L7_,_L8_){return _L9_.fun(_L7_,_L8_)},
       js_expr=function _L6_(_L5_){return _L6_.fun(_L5_)},
       js_type=function _L4_(_L3_){return _L4_.fun(_L3_)},
       _vs_=[0,0,0,0];
      caml_update_dummy
       (js_proof_engine,
        function(proof)
         {function _JS_
           (self,
            proof,
            handle,
            subgoals,
            closed,
            getmeta,
            setmeta,
            actions,
            pactions,
            apply,
            loaddb,
            getdb)
           {if(! _vs_[1])
             {var
               _LC_=create_table(_u9_),
               _LD_=new_variable(_LC_,_vt_),
               _LE_=get_method_labels(_LC_,_u8_),
               _LF_=_LE_[1],
               _LG_=_LE_[2],
               _LH_=_LE_[3],
               _LI_=_LE_[4],
               _LJ_=_LE_[5],
               _LK_=_LE_[6],
               _LL_=_LE_[7],
               _LM_=_LE_[8],
               _LN_=_LE_[9],
               _LO_=_LE_[10],
               _LP_=_LE_[11],
               _LQ_=
                function(self_1)
                 {var env=self_1[1 + _LD_];return caml_call1(env[2],env[1])},
               _LR_=
                function(self_1)
                 {var env=self_1[1 + _LD_];return caml_call1(env[3],env[1])},
               _LS_=
                function(self_1)
                 {var env=self_1[1 + _LD_];return caml_call1(env[4],env[1])},
               _LT_=
                function(self_1)
                 {var env=self_1[1 + _LD_];return caml_call1(env[5],env[1])},
               _LU_=
                function(self_1)
                 {var env=self_1[1 + _LD_];return caml_call1(env[6],env[1])},
               _LV_=
                function(self_1)
                 {var env=self_1[1 + _LD_];return caml_call1(env[7],env[1])},
               _LW_=
                function(self_1)
                 {var env=self_1[1 + _LD_];return caml_call1(env[8],env[1])},
               _LX_=
                function(self_1)
                 {var env=self_1[1 + _LD_];return caml_call1(env[9],env[1])},
               _LY_=
                function(self_1)
                 {var env=self_1[1 + _LD_];return caml_call1(env[10],env[1])},
               _LZ_=function(self_1){var env=self_1[1 + _LD_];return env[11]};
              set_methods
               (_LC_,
                [0,
                 _LH_,
                 function(self_1){var env=self_1[1 + _LD_];return env[12]},
                 _LK_,
                 _LZ_,
                 _LF_,
                 _LY_,
                 _LN_,
                 _LX_,
                 _LL_,
                 _LW_,
                 _LG_,
                 _LV_,
                 _LP_,
                 _LU_,
                 _LI_,
                 _LT_,
                 _LO_,
                 _LS_,
                 _LJ_,
                 _LR_,
                 _LM_,
                 _LQ_]);
              var
               _L0_=
                function(_L1_)
                 {var _L2_=create_object_opt(0,_LC_);
                  _L2_[1 + _LD_] = _L1_;
                  return _L2_};
              init_class(_LC_);
              _vs_[1] = _L0_}
            return caml_call1
                    (_vs_[1],
                     [0,
                      self,
                      getdb,
                      loaddb,
                      apply,
                      pactions,
                      actions,
                      setmeta,
                      getmeta,
                      closed,
                      subgoals,
                      handle,
                      proof])}
          function _JT_(self,selection)
           {var _Ln_=to_option$0(selection);
            function _Lo_(_LB_){return map$3(of_array$0,_LB_)}
            var selection$0=_Lo_(_Ln_);
            function _Lp_(x)
             {return caml_call1(caml_get_public_method(x,-930093436,44),x)}
            function _Lq_(t20,param){return t20.proof}
            var _Lr_=_Lq_(self,_Lp_);
            function _Ls_(_LA_){return lemmas(selection$0,_LA_)}
            var _Lt_=_Ls_(_Lr_);
            function _Lu_(param)
             {var
               form=param[2],
               name=param[1],
               _Lz_=f_tostring(form),
               stmt=caml_jsstring_of_string(_Lz_);
              return [0,name,stmt]}
            function _Lv_(_Ly_){return map$4(_Lu_,_Ly_)}
            var _Lw_=_Lv_(_Lt_),_Lx_=of_list(_Lw_);
            return caml_js_object(_Lx_)}
          function _JU_(self,lemmas)
           {var _Lc_=typeof lemmas,match=caml_string_of_jsstring(_Lc_);
            if(caml_string_notequal(match,_vu_))throw InvalidLemmaDB;
            var
             _Ld_=object_keys(lemmas),
             _Le_=caml_js_to_array(_Ld_),
             _Lf_=to_list(_Le_);
            function _Lg_(name)
             {var
               name$0=as_string(InvalidLemmaDB,name),
               _Lm_=lemmas[name$0],
               stmt=as_string(InvalidLemmaDB,_Lm_);
              return [0,name$0,stmt]}
            function _Lh_(_Ll_){return map$4(_Lg_,_Ll_)}
            var lemmas$0=_Lh_(_Lf_);
            function _Li_(x)
             {return caml_call1(caml_get_public_method(x,-930093436,45),x)}
            function _Lj_(t18,param){return t18.proof}
            var _Lk_=_Lj_(self,_Li_),pr=loaddb(_Lk_,lemmas$0);
            return caml_call1(js_proof_engine,pr)}
          function _JV_(self,action)
           {function _K7_(x)
             {return caml_call1(caml_get_public_method(x,-930093436,46),x)}
            function _K8_(t16,param){return t16.proof}
            var _K9_=[0,_K8_(self,_K7_),action];
            function _K__(_Lb_){return curry(apply,_Lb_)}
            function _K$_(_La_){return symbol$5(_K__,_La_)}
            return caml_call1(js_proof_engine,_K$_(_K9_))}
          function _JW_(self,path)
           {var _K3_=0,ppx_lwt_0=return$0(_K3_);
            function _K4_(param)
             {function _K5_(x)
               {return caml_call1(caml_get_public_method(x,-416414723,47),x)}
              function _K6_(t14,t13,param){return t14.actions(t13)}
              return return$0(_K6_(self,path,_K5_))}
            return backtrace_bind
                    (function(exn)
                      {try
                        {throw exn}
                       catch(exn){exn = caml_wrap_exception(exn);return exn}},
                     ppx_lwt_0,
                     _K4_)}
          function _JX_(self,asource)
           {var _Kk_=typeof asource,match=caml_string_of_jsstring(_Kk_);
            if(caml_string_notequal(match,_vv_))
             {if(caml_string_notequal(match,_vw_))throw InvalidASource;
              var _Kl_=0,_Km_=[0,[0,-611587032,of_obj(asource)],_Kl_]}
            else
             {var
               _KA_=
                function(x)
                 {return caml_call1(caml_get_public_method(x,-955653804,50),x)},
               _KB_=function(t5,param){return t5.kind},
               _KC_=_KB_(asource,_KA_),
               match$0=as_string(InvalidASource,_KC_);
              if(caml_string_notequal(match$0,_vx_))
               if(caml_string_notequal(match$0,_vy_))
                {if(caml_string_notequal(match$0,_vz_))throw InvalidASource;
                 var
                  _KD_=
                   function(x)
                    {return caml_call1(caml_get_public_method(x,842117339,51),x)},
                  _KE_=function(t7,param){return t7.source},
                  _KF_=_KE_(asource,_KD_),
                  source=of_obj(_KF_),
                  _KG_=
                   function(x)
                    {return caml_call1(caml_get_public_method(x,301697678,52),x)},
                  _KH_=function(t8,param){return t8.destination},
                  _KI_=_KH_(asource,_KG_),
                  destination=of_opt(_KI_),
                  _KJ_=[0,[0,3406170,[0,source,destination]],0]}
               else
                var
                 _KK_=
                  function(x)
                   {return caml_call1
                            (caml_get_public_method(x,-900602459,53),x)},
                 _KL_=function(t6,param){return t6.path},
                 _KM_=_KL_(asource,_KK_),
                 path=of_obj(_KM_),
                 _KJ_=[0,[0,-611587032,path],0];
              else
               var
                _KN_=
                 function(x)
                  {return caml_call1
                           (caml_get_public_method(x,-900602459,54),x)},
                _KO_=function(t9,param){return t9.path},
                _KP_=_KO_(asource,_KN_),
                path$0=of_obj(_KP_),
                _KJ_=[0,[0,-611587032,path$0],[0,[0,3406170,[0,path$0,0]],0]];
              var _Km_=_KJ_}
            function _Kn_(x)
             {return caml_call1(caml_get_public_method(x,236648524,48),x)}
            function _Ko_(t10,param){return t10.selection}
            var _Kp_=_Ko_(asource,_Kn_),selection=of_array$0(_Kp_);
            function _Kq_(kind){return [0,kind,selection]}
            var asource$0=map$4(_Kq_,_Km_);
            function _Kr_(x)
             {return caml_call1(caml_get_public_method(x,-930093436,49),x)}
            function _Ks_(t11,param){return t11.proof}
            var _Kt_=_Ks_(self,_Kr_);
            function _Ku_(_K2_){return actions(_Kt_,_K2_)}
            function _Kv_(_K1_){return symbol$5(_Ku_,_K1_)}
            var _Kw_=map$4(_Kv_,asource$0),actions$0=flatten$0(_Kw_);
            function _Kx_(param)
             {var
               a=param[4],
               aui=param[3],
               ps=param[2],
               p=param[1],
               ps$0=map$4(p2p,ps);
              function _KQ_(_K0_){return caml_jsstring_of_string(_K0_)}
              var
               _KR_=map$4(_KQ_,ps$0),
               _KS_=of_list(_KR_),
               ps$1=caml_js_from_array(_KS_);
              if(3406170 <= aui[1])
               var
                match=aui[2],
                dst=match[2],
                src=match[1],
                _KT_=p2p(dst),
                _KU_=caml_jsstring_of_string(_KT_),
                _KV_=p2p(src),
                _KW_=caml_jsstring_of_string(_KV_),
                aui$0={"kind":"dnd","source":_KW_,"destination":_KU_};
              else
               var
                p$0=aui[2],
                _KY_=p2p(p$0),
                _KZ_=caml_jsstring_of_string(_KY_),
                aui$0={"kind":"click","target":_KZ_};
              var _KX_=caml_jsstring_of_string(p);
              return {"description":_KX_,
                      "highlight":ps$1,
                      "ui":aui$0,
                      "action":a}}
            var _Ky_=map$4(_Kx_,actions$0),_Kz_=of_list(_Ky_);
            return caml_js_from_array(_Kz_)}
          function _JY_(self,meta)
           {var _Kh_=to_option(meta);
            function _Ki_(x)
             {return caml_call1(caml_get_public_method(x,939361192,55),x)}
            function _Kj_(t3,param){return t3.handle}
            return set_meta(proof,_Kj_(self,_Ki_),_Kh_)}
          function _JZ_(self)
           {function _Ke_(x)
             {return caml_call1(caml_get_public_method(x,939361192,56),x)}
            function _Kf_(t2,param){return t2.handle}
            var _Kg_=_Kf_(self,_Ke_);
            return option(get_meta(proof,_Kg_))}
          function _J0_(self){var _Kd_=closed(proof);return ! ! _Kd_}
          function _J1_(self)
           {var
             subgoals=opened(proof),
             _Kb_=caml_call1(js_subgoal,self),
             subgoals$0=map$4(_Kb_,subgoals),
             _Kc_=of_list(subgoals$0);
            return caml_js_from_array(_Kc_)}
          var _J2_=0,_J3_=fresh$2(_J2_);
          return function(t22,t23,t24,t25,t26,t27,t28,t29,t30,t31,t32,param)
                   {var
                     _J4_=caml_js_wrap_meth_callback(t32),
                     _J5_=caml_js_wrap_meth_callback(t31),
                     _J6_=caml_js_wrap_meth_callback(t30),
                     _J7_=caml_js_wrap_meth_callback(t29),
                     _J8_=caml_js_wrap_meth_callback(t28),
                     _J9_=caml_js_wrap_meth_callback(t27),
                     _J__=caml_js_wrap_meth_callback(t26),
                     _J$_=caml_js_wrap_meth_callback(t25),
                     _Ka_=caml_js_wrap_meth_callback(t24);
                    return {"proof":t22,
                            "handle":t23,
                            "subgoals":_Ka_,
                            "closed":_J$_,
                            "getmeta":_J__,
                            "setmeta":_J9_,
                            "actions":_J8_,
                            "pactions":_J7_,
                            "apply":_J6_,
                            "loaddb":_J5_,
                            "getdb":_J4_}}
                  (proof,
                   _J3_,
                   _J1_,
                   _J0_,
                   _JZ_,
                   _JY_,
                   _JX_,
                   _JW_,
                   _JV_,
                   _JU_,
                   _JT_,
                   _JS_)});
      var _vA_=[0,0,0,0];
      caml_update_dummy
       (js_subgoal,
        function(parent,handle)
         {function _Ew_
           (self,
            parent,
            handle,
            fvars,
            pvars,
            tvars,
            context,
            conclusion,
            intro,
            elim,
            ivariants,
            cut,
            addlemma,
            addlocal,
            addalias,
            move_hyp,
            generalize,
            getmeta,
            setmeta,
            toascii,
            tostring)
           {if(! _vA_[1])
             {var
               _I$_=create_table(_vd_),
               _Ja_=new_variable(_I$_,_vB_),
               _Jb_=get_method_labels(_I$_,_u5_),
               _Jc_=_Jb_[1],
               _Jd_=_Jb_[2],
               _Je_=_Jb_[3],
               _Jf_=_Jb_[4],
               _Jg_=_Jb_[5],
               _Jh_=_Jb_[6],
               _Ji_=_Jb_[7],
               _Jj_=_Jb_[8],
               _Jk_=_Jb_[9],
               _Jl_=_Jb_[10],
               _Jm_=_Jb_[11],
               _Jn_=_Jb_[12],
               _Jo_=_Jb_[13],
               _Jp_=_Jb_[14],
               _Jq_=_Jb_[15],
               _Jr_=_Jb_[16],
               _Js_=_Jb_[17],
               _Jt_=_Jb_[18],
               _Ju_=_Jb_[19],
               _Jv_=_Jb_[20],
               _Jw_=
                function(self_2)
                 {var env=self_2[1 + _Ja_];return caml_call1(env[2],env[1])},
               _Jx_=
                function(self_2)
                 {var env=self_2[1 + _Ja_];return caml_call1(env[3],env[1])},
               _Jy_=
                function(self_2)
                 {var env=self_2[1 + _Ja_];return caml_call1(env[4],env[1])},
               _Jz_=
                function(self_2)
                 {var env=self_2[1 + _Ja_];return caml_call1(env[5],env[1])},
               _JA_=
                function(self_2)
                 {var env=self_2[1 + _Ja_];return caml_call1(env[6],env[1])},
               _JB_=
                function(self_2)
                 {var env=self_2[1 + _Ja_];return caml_call1(env[7],env[1])},
               _JC_=
                function(self_2)
                 {var env=self_2[1 + _Ja_];return caml_call1(env[8],env[1])},
               _JD_=
                function(self_2)
                 {var env=self_2[1 + _Ja_];return caml_call1(env[9],env[1])},
               _JE_=
                function(self_2)
                 {var env=self_2[1 + _Ja_];return caml_call1(env[10],env[1])},
               _JF_=
                function(self_2)
                 {var env=self_2[1 + _Ja_];return caml_call1(env[11],env[1])},
               _JG_=
                function(self_2)
                 {var env=self_2[1 + _Ja_];return caml_call1(env[12],env[1])},
               _JH_=
                function(self_2)
                 {var env=self_2[1 + _Ja_];return caml_call1(env[13],env[1])},
               _JI_=
                function(self_2)
                 {var env=self_2[1 + _Ja_];return caml_call1(env[14],env[1])},
               _JJ_=
                function(self_2)
                 {var env=self_2[1 + _Ja_];return caml_call1(env[15],env[1])},
               _JK_=
                function(self_2)
                 {var env=self_2[1 + _Ja_];return caml_call1(env[16],env[1])},
               _JL_=
                function(self_2)
                 {var env=self_2[1 + _Ja_];return caml_call1(env[17],env[1])},
               _JM_=
                function(self_2)
                 {var env=self_2[1 + _Ja_];return caml_call1(env[18],env[1])},
               _JN_=
                function(self_2)
                 {var env=self_2[1 + _Ja_];return caml_call1(env[19],env[1])},
               _JO_=function(self_2){var env=self_2[1 + _Ja_];return env[20]};
              set_methods
               (_I$_,
                [0,
                 _Jh_,
                 function(self_2){var env=self_2[1 + _Ja_];return env[21]},
                 _Jl_,
                 _JO_,
                 _Jo_,
                 _JN_,
                 _Jg_,
                 _JM_,
                 _Jc_,
                 _JL_,
                 _Jr_,
                 _JK_,
                 _Js_,
                 _JJ_,
                 _Jk_,
                 _JI_,
                 _Jp_,
                 _JH_,
                 _Jj_,
                 _JG_,
                 _Jq_,
                 _JF_,
                 _Ju_,
                 _JE_,
                 _Jt_,
                 _JD_,
                 _Jv_,
                 _JC_,
                 _Ji_,
                 _JB_,
                 _Jn_,
                 _JA_,
                 _Jm_,
                 _Jz_,
                 _Jf_,
                 _Jy_,
                 _Je_,
                 _Jx_,
                 _Jd_,
                 _Jw_]);
              var
               _JP_=
                function(_JQ_)
                 {var _JR_=create_object_opt(0,_I$_);
                  _JR_[1 + _Ja_] = _JQ_;
                  return _JR_};
              init_class(_I$_);
              _vA_[1] = _JP_}
            return caml_call1
                    (_vA_[1],
                     [0,
                      self,
                      tostring,
                      toascii,
                      setmeta,
                      getmeta,
                      generalize,
                      move_hyp,
                      addalias,
                      addlocal,
                      addlemma,
                      cut,
                      ivariants,
                      elim,
                      intro,
                      conclusion,
                      context,
                      tvars,
                      pvars,
                      fvars,
                      handle,
                      parent])}
          function _Ex_(self)
           {function _IP_(x)
             {return caml_call1(caml_get_public_method(x,427267567,57),x)}
            function _IQ_(t89,param){return t89.context()}
            var
             _IR_=_IQ_(self,_IP_),
             _IS_=caml_js_to_array(_IR_),
             _IT_=to_list(_IS_);
            function _IU_(h)
             {function _I8_(x)
               {return caml_call1(caml_get_public_method(x,64642188,58),x)}
              function _I9_(t90,param){return t90.tostring()}
              var _I__=_I9_(h,_I8_);
              return caml_string_of_jsstring(_I__)}
            function _IV_(_I7_){return map$4(_IU_,_I7_)}
            var hyps=_IV_(_IT_);
            function _IW_(x)
             {return caml_call1(caml_get_public_method(x,-726448417,59),x)}
            function _IX_(t91,param){return t91.conclusion()}
            var _IY_=_IX_(self,_IW_);
            function _IZ_(c)
             {function _I4_(x)
               {return caml_call1(caml_get_public_method(x,64642188,60),x)}
              function _I5_(t92,param){return t92.tostring()}
              var _I6_=_I5_(c,_I4_);
              return caml_string_of_jsstring(_I6_)}
            var concl=_IZ_(_IY_);
            function _I0_(_I3_){return _I3_}
            var
             to_string=to_string$8(_vE_,_vD_,_vC_,_I0_),
             _I1_=caml_call1(to_string,hyps),
             _I2_=caml_call2(sprintf(_vF_),_I1_,concl);
            return caml_jsstring_of_string(_I2_)}
          function _Ey_(self)
           {function _HU_(x)
             {return caml_call1(caml_get_public_method(x,153638674,61),x)}
            function _HV_(t81,param){return t81.fvars()}
            var
             _HW_=_HV_(self,_HU_),
             _HX_=caml_js_to_array(_HW_),
             _HY_=to_list(_HX_);
            function _HZ_(_IO_){return caml_string_of_jsstring(_IO_)}
            function _H0_(_IN_){return map$4(_HZ_,_IN_)}
            var funs=_H0_(_HY_);
            function _H1_(x)
             {return caml_call1(caml_get_public_method(x,-886430692,62),x)}
            function _H2_(t82,param){return t82.pvars()}
            var
             _H3_=_H2_(self,_H1_),
             _H4_=caml_js_to_array(_H3_),
             _H5_=to_list(_H4_);
            function _H6_(_IM_){return caml_string_of_jsstring(_IM_)}
            function _H7_(_IL_){return map$4(_H6_,_IL_)}
            var props=_H7_(_H5_);
            function _H8_(x)
             {return caml_call1(caml_get_public_method(x,415528480,63),x)}
            function _H9_(t83,param){return t83.tvars()}
            var
             _H__=_H9_(self,_H8_),
             _H$_=caml_js_to_array(_H__),
             _Ia_=to_list(_H$_);
            function _Ib_(v)
             {function _II_(x)
               {return caml_call1(caml_get_public_method(x,-544987658,64),x)}
              function _IJ_(t84,param){return t84.toascii()}
              var _IK_=_IJ_(v,_II_);
              return caml_string_of_jsstring(_IK_)}
            function _Ic_(_IH_){return map$4(_Ib_,_IH_)}
            var vars=_Ic_(_Ia_);
            function _Id_(x)
             {return caml_call1(caml_get_public_method(x,427267567,65),x)}
            function _Ie_(t85,param){return t85.context()}
            var
             _If_=_Ie_(self,_Id_),
             _Ig_=caml_js_to_array(_If_),
             _Ih_=to_list(_Ig_);
            function _Ii_(h)
             {function _IE_(x)
               {return caml_call1(caml_get_public_method(x,-544987658,66),x)}
              function _IF_(t86,param){return t86.toascii()}
              var _IG_=_IF_(h,_IE_);
              return caml_string_of_jsstring(_IG_)}
            function _Ij_(_ID_){return map$4(_Ii_,_ID_)}
            var hyps=_Ij_(_Ih_);
            function _Ik_(x)
             {return caml_call1(caml_get_public_method(x,-726448417,67),x)}
            function _Il_(t87,param){return t87.conclusion()}
            var _Im_=_Il_(self,_Ik_);
            function _In_(c)
             {function _IA_(x)
               {return caml_call1(caml_get_public_method(x,-544987658,68),x)}
              function _IB_(t88,param){return t88.toascii()}
              var _IC_=_IB_(c,_IA_);
              return caml_string_of_jsstring(_IC_)}
            var concl=_In_(_Im_);
            function _Io_(_Iz_){return _Iz_}
            var to_string=to_string$8(_vI_,_vH_,_vG_,_Io_);
            function _Ip_(s,l)
             {if(is_empty$1(s))
               return is_empty$2(l)?_vK_:caml_call1(to_string,l);
              if(is_empty$2(l))return s;
              var _Iy_=caml_call1(to_string,l);
              return cat(s,cat(_vL_,_Iy_))}
            function _Iq_(_Iw_,_Ix_){return fold(_Ip_,_Iw_,_Ix_)}
            function comma(_Iv_){return _Iq_(_vJ_,_Iv_)}
            var
             _Ir_=caml_call1(to_string,hyps),
             _Is_=[0,funs,[0,vars,[0,props,0]]],
             _It_=comma(_Is_),
             _Iu_=caml_call3(sprintf(_vM_),_It_,_Ir_,concl);
            return caml_jsstring_of_string(_Iu_)}
          function _Ez_(self,meta)
           {var _HO_=to_option(meta);
            function _HP_(x)
             {return caml_call1(caml_get_public_method(x,939361192,69),x)}
            function _HQ_(t79,param){return t79.handle}
            var _HR_=_HQ_(self,_HP_);
            function _HS_(x)
             {return caml_call1(caml_get_public_method(x,-930093436,70),x)}
            function _HT_(t78,param){return t78.proof}
            return set_meta(_HT_(parent,_HS_),_HR_,_HO_)}
          function _EA_(self)
           {function _HI_(x)
             {return caml_call1(caml_get_public_method(x,939361192,71),x)}
            function _HJ_(t77,param){return t77.handle}
            var _HK_=_HJ_(self,_HI_);
            function _HL_(x)
             {return caml_call1(caml_get_public_method(x,-930093436,72),x)}
            function _HM_(t76,param){return t76.proof}
            var _HN_=_HM_(parent,_HL_);
            return option(get_meta(_HN_,_HK_))}
          function _EB_(self,hid)
           {function doit(param)
             {function _HD_(x)
               {return caml_call1(caml_get_public_method(x,939361192,73),x)}
              function _HE_(t74,param){return t74.handle}
              var _HF_=_HE_(self,_HD_);
              function _HG_(x)
               {return caml_call1(caml_get_public_method(x,-930093436,74),x)}
              function _HH_(t73,param){return t73.proof}
              return generalize(hid,[0,_HH_(parent,_HG_),_HF_])}
            var _HA_=0;
            function _HB_(_HC_){return symbol$5(doit,_HC_)}
            return caml_call1(js_proof_engine,_HB_(_HA_))}
          function _EC_(self,from,before)
           {function doit(param)
             {function _Hu_(x)
               {return caml_call1(caml_get_public_method(x,939361192,75),x)}
              function _Hv_(t70,param){return t70.handle}
              var _Hw_=_Hv_(self,_Hu_);
              function _Hx_(x)
               {return caml_call1(caml_get_public_method(x,-930093436,76),x)}
              function _Hy_(t69,param){return t69.proof}
              var _Hz_=[0,_Hy_(parent,_Hx_),_Hw_];
              return move$0(from,to_option(before),_Hz_)}
            var _Hs_=0;
            return function(_Ht_){return symbol$5(doit,_Ht_)}(_Hs_)}
          function _ED_(self,expr)
           {function doit(param)
             {function _Hc_(x)
               {return caml_call1(caml_get_public_method(x,939361192,77),x)}
              function _Hd_(t65,param){return t65.handle}
              var _He_=_Hd_(self,_Hc_);
              function _Hf_(x)
               {return caml_call1(caml_get_public_method(x,-930093436,78),x)}
              function _Hg_(t64,param){return t64.proof}
              var
               _Hh_=_Hg_(parent,_Hf_),
               goal=byid$1(_Hh_,_He_),
               _Hi_=caml_string_of_jsstring(expr),
               expr$0=trim(_Hi_),
               _Hj_=from_string$1(expr$0),
               match=parse_nexpr(_Hj_),
               expr$1=match[2],
               name=match[1],
               _Hk_=goal[1],
               match$0=echeck(_Hk_,expr$1),
               ty=match$0[2],
               expr$2=match$0[1];
              function _Hl_(x)
               {return caml_call1(caml_get_public_method(x,939361192,79),x)}
              function _Hm_(t67,param){return t67.handle}
              var _Hn_=_Hm_(self,_Hl_);
              function _Ho_(x)
               {return caml_call1(caml_get_public_method(x,-930093436,80),x)}
              function _Hp_(t66,param){return t66.proof}
              var _Hq_=[0,_Hp_(parent,_Ho_),_Hn_],_Hr_=[0,expr$2];
              return add_local([0,unloc(name),ty,_Hr_],_Hq_)}
            var _G$_=0;
            function _Ha_(_Hb_){return symbol$5(doit,_Hb_)}
            return caml_call1(js_proof_engine,_Ha_(_G$_))}
          function _EE_(self,name,expr)
           {function doit(param)
             {function _GV_(x)
               {return caml_call1(caml_get_public_method(x,939361192,81),x)}
              function _GW_(t59,param){return t59.handle}
              var _GX_=_GW_(self,_GV_);
              function _GY_(x)
               {return caml_call1(caml_get_public_method(x,-930093436,82),x)}
              function _GZ_(t58,param){return t58.proof}
              var
               _G0_=_GZ_(parent,_GY_),
               goal=byid$1(_G0_,_GX_),
               _G1_=caml_string_of_jsstring(expr),
               expr$0=trim(_G1_),
               _G2_=from_string$1(expr$0),
               expr$1=parse_expr(_G2_),
               _G3_=goal[1],
               match=echeck(_G3_,expr$1),
               ty=match[2],
               expr$2=match[1];
              function _G4_(x)
               {return caml_call1(caml_get_public_method(x,939361192,83),x)}
              function _G5_(t61,param){return t61.handle}
              var _G6_=_G5_(self,_G4_);
              function _G7_(x)
               {return caml_call1(caml_get_public_method(x,-930093436,84),x)}
              function _G8_(t60,param){return t60.proof}
              var _G9_=[0,_G8_(parent,_G7_),_G6_],_G__=[0,expr$2];
              return add_local([0,caml_string_of_jsstring(name),ty,_G__],_G9_)}
            var _GS_=0;
            function _GT_(_GU_){return symbol$5(doit,_GU_)}
            return caml_call1(js_proof_engine,_GT_(_GS_))}
          function _EF_(self,name)
           {function doit(param)
             {var name$0=caml_string_of_jsstring(name);
              function _GJ_(x)
               {return caml_call1(caml_get_public_method(x,-930093436,85),x)}
              function _GK_(t54,param){return t54.proof}
              var
               _GL_=_GK_(parent,_GJ_),
               _GM_=db(_GL_),
               form=find$5(_GM_,name$0);
              function _GN_(x)
               {return caml_call1(caml_get_public_method(x,939361192,86),x)}
              function _GO_(t56,param){return t56.handle}
              var _GP_=_GO_(self,_GN_);
              function _GQ_(x)
               {return caml_call1(caml_get_public_method(x,-930093436,87),x)}
              function _GR_(t55,param){return t55.proof}
              return assume(form,[0,_GR_(parent,_GQ_),_GP_])}
            var _GG_=0;
            function _GH_(_GI_){return symbol$5(doit,_GI_)}
            return caml_call1(js_proof_engine,_GH_(_GG_))}
          function _EG_(self,form)
           {function doit(param)
             {function _Gs_(x)
               {return caml_call1(caml_get_public_method(x,939361192,88),x)}
              function _Gt_(t50,param){return t50.handle}
              var _Gu_=_Gt_(self,_Gs_);
              function _Gv_(x)
               {return caml_call1(caml_get_public_method(x,-930093436,89),x)}
              function _Gw_(t49,param){return t49.proof}
              var
               _Gx_=_Gw_(parent,_Gv_),
               goal=byid$1(_Gx_,_Gu_),
               _Gy_=caml_string_of_jsstring(form),
               form$0=trim(_Gy_),
               _Gz_=from_string$1(form$0),
               form$1=parse_form(_Gz_),
               _GA_=goal[1],
               form$2=check$1(_GA_,form$1);
              function _GB_(x)
               {return caml_call1(caml_get_public_method(x,939361192,90),x)}
              function _GC_(t52,param){return t52.handle}
              var _GD_=_GC_(self,_GB_);
              function _GE_(x)
               {return caml_call1(caml_get_public_method(x,-930093436,91),x)}
              function _GF_(t51,param){return t51.proof}
              return cut(form$2,[0,_GF_(parent,_GE_),_GD_])}
            var _Gp_=0;
            function _Gq_(_Gr_){return symbol$5(doit,_Gr_)}
            return caml_call1(js_proof_engine,_Gq_(_Gp_))}
          function _EH_(self)
           {function _Gh_(x)
             {return caml_call1(caml_get_public_method(x,-930093436,92),x)}
            function _Gi_(t48,param){return t48.proof}
            var _Gj_=[0,_Gi_(parent,_Gh_),handle];
            function _Gk_(_Go_){return symbol$5(ivariants,_Go_)}
            var aout=_Gk_(_Gj_);
            function _Gl_(_Gn_){return caml_jsstring_of_string(_Gn_)}
            var _Gm_=map$4(_Gl_,aout),aout$0=of_list(_Gm_);
            return caml_js_from_array(aout$0)}
          function _EI_(self,target)
           {function _F__(x)
             {return caml_call1(caml_get_public_method(x,-930093436,93),x)}
            function _F$_(t46,param){return t46.proof}
            var data=[0,target,[0,_F$_(parent,_F__),handle]];
            function _Ga_(eta)
             {var _Gf_=0;return function(_Gg_){return arg$0(_Gf_,eta,_Gg_)}}
            function _Gb_(_Ge_){return curry(_Ga_,_Ge_)}
            function _Gc_(_Gd_){return symbol$5(_Gb_,_Gd_)}
            return caml_call1(js_proof_engine,_Gc_(data))}
          function _EJ_(self,variant)
           {function _F2_(x)
             {return caml_call1(caml_get_public_method(x,-930093436,94),x)}
            function _F3_(t44,param){return t44.proof}
            var _F4_=[0,_F3_(parent,_F2_),handle],_F5_=[0,variant];
            function _F6_(_F9_){return intro(_F5_,_F9_)}
            function _F7_(_F8_){return symbol$5(_F6_,_F8_)}
            return caml_call1(js_proof_engine,_F7_(_F4_))}
          function _EK_(self)
           {function _FS_(x)
             {return caml_call1(caml_get_public_method(x,939361192,95),x)}
            function _FT_(t42,param){return t42.handle}
            var _FU_=_FT_(self,_FS_);
            function _FV_(x)
             {return caml_call1(caml_get_public_method(x,-930093436,96),x)}
            function _FW_(t41,param){return t41.proof}
            var
             _FX_=_FW_(parent,_FV_),
             goal=byid$1(_FX_,_FU_),
             _FY_=goal[3],
             _FZ_=67;
            function _F0_(x)
             {return caml_call1(caml_get_public_method(x,939361192,97),x)}
            function _F1_(t43,param){return t43.handle}
            return caml_call2(js_form,[0,_F1_(self,_F0_),_FZ_],_FY_)}
          function _EL_(self)
           {function _FH_(x)
             {return caml_call1(caml_get_public_method(x,939361192,98),x)}
            function _FI_(t40,param){return t40.handle}
            var _FJ_=_FI_(self,_FH_);
            function _FK_(x)
             {return caml_call1(caml_get_public_method(x,-930093436,99),x)}
            function _FL_(t39,param){return t39.proof}
            var
             _FM_=_FL_(parent,_FK_),
             goal=byid$1(_FM_,_FJ_),
             _FN_=goal[2],
             _FO_=to_list$1(_FN_),
             hyps=rev(_FO_);
            function _FP_(i,x){return caml_call2(js_hyps,self,[0,i,x])}
            var _FQ_=mapi(_FP_,hyps),_FR_=of_list(_FQ_);
            return caml_js_from_array(_FR_)}
          function _EM_(self)
           {function _Fy_(x)
             {return caml_call1(caml_get_public_method(x,939361192,100),x)}
            function _Fz_(t38,param){return t38.handle}
            var _FA_=_Fz_(self,_Fy_);
            function _FB_(x)
             {return caml_call1(caml_get_public_method(x,-930093436,101),x)}
            function _FC_(t37,param){return t37.proof}
            var
             _FD_=_FC_(parent,_FB_),
             goal=byid$1(_FD_,_FA_),
             _FE_=goal[1],
             tvars=to_list$0(_FE_);
            function _FF_(i,param)
             {var b=param[3],x=param[2],id=param[1];
              return caml_call2(js_tvar,self,[0,i,[0,ofint(id),x,b]])}
            var aout=mapi(_FF_,tvars),_FG_=of_list(aout);
            return caml_js_from_array(_FG_)}
          function _EN_(self)
           {function _Fl_(x)
             {return caml_call1(caml_get_public_method(x,939361192,102),x)}
            function _Fm_(t36,param){return t36.handle}
            var _Fn_=_Fm_(self,_Fl_);
            function _Fo_(x)
             {return caml_call1(caml_get_public_method(x,-930093436,103),x)}
            function _Fp_(t35,param){return t35.proof}
            var
             _Fq_=_Fp_(parent,_Fo_),
             goal=byid$1(_Fq_,_Fn_),
             _Fr_=goal[1],
             _Fs_=all(_Fr_),
             _Ft_=bindings(_Fs_),
             pvars=fst(_Ft_);
            function _Fu_(_Fx_){return caml_jsstring_of_string(_Fx_)}
            var _Fv_=map$4(_Fu_,pvars),_Fw_=of_list(_Fv_);
            return caml_js_from_array(_Fw_)}
          function _EO_(self)
           {function _E7_(x)
             {return caml_call1(caml_get_public_method(x,939361192,104),x)}
            function _E8_(t34,param){return t34.handle}
            var _E9_=_E8_(self,_E7_);
            function _E__(x)
             {return caml_call1(caml_get_public_method(x,-930093436,105),x)}
            function _E$_(t33,param){return t33.proof}
            var
             _Fa_=_E$_(parent,_E__),
             goal=byid$1(_Fa_,_E9_),
             _Fb_=goal[1],
             _Fc_=all$0(_Fb_),
             _Fd_=bindings(_Fc_);
            function _Fe_(param)
             {var
               match=param[2],
               res=match[2],
               ar=match[1],
               f=param[1],
               ar$0=caml_call1(to_string$8(_vP_,_vO_,_vN_,t_tostring),ar),
               res$0=t_tostring(res);
              return caml_call3(sprintf(_vQ_),f,ar$0,res$0)}
            function _Ff_(_Fk_){return map$4(_Fe_,_Fk_)}
            var fvars=_Ff_(_Fd_);
            function _Fg_(_Fj_){return caml_jsstring_of_string(_Fj_)}
            var _Fh_=map$4(_Fg_,fvars),_Fi_=of_list(_Fh_);
            return caml_js_from_array(_Fi_)}
          return function
                   (t93,
                    t94,
                    t95,
                    t96,
                    t97,
                    t98,
                    t99,
                    t100,
                    t101,
                    t102,
                    t103,
                    t104,
                    t105,
                    t106,
                    t107,
                    t108,
                    t109,
                    t110,
                    t111,
                    t112,
                    param)
                   {var
                     _EP_=caml_js_wrap_meth_callback(t112),
                     _EQ_=caml_js_wrap_meth_callback(t111),
                     _ER_=caml_js_wrap_meth_callback(t110),
                     _ES_=caml_js_wrap_meth_callback(t109),
                     _ET_=caml_js_wrap_meth_callback(t108),
                     _EU_=caml_js_wrap_meth_callback(t107),
                     _EV_=caml_js_wrap_meth_callback(t106),
                     _EW_=caml_js_wrap_meth_callback(t105),
                     _EX_=caml_js_wrap_meth_callback(t104),
                     _EY_=caml_js_wrap_meth_callback(t103),
                     _EZ_=caml_js_wrap_meth_callback(t102),
                     _E0_=caml_js_wrap_meth_callback(t101),
                     _E1_=caml_js_wrap_meth_callback(t100),
                     _E2_=caml_js_wrap_meth_callback(t99),
                     _E3_=caml_js_wrap_meth_callback(t98),
                     _E4_=caml_js_wrap_meth_callback(t97),
                     _E5_=caml_js_wrap_meth_callback(t96),
                     _E6_=caml_js_wrap_meth_callback(t95);
                    return {"parent":t93,
                            "handle":t94,
                            "fvars":_E6_,
                            "pvars":_E5_,
                            "tvars":_E4_,
                            "context":_E3_,
                            "conclusion":_E2_,
                            "intro":_E1_,
                            "elim":_E0_,
                            "ivariants":_EZ_,
                            "cut":_EY_,
                            "addlemma":_EX_,
                            "addlocal":_EW_,
                            "addalias":_EV_,
                            "move":_EU_,
                            "generalize":_ET_,
                            "getmeta":_ES_,
                            "setmeta":_ER_,
                            "toascii":_EQ_,
                            "tostring":_EP_}}
                  (parent,
                   handle,
                   _EO_,
                   _EN_,
                   _EM_,
                   _EL_,
                   _EK_,
                   _EJ_,
                   _EI_,
                   _EH_,
                   _EG_,
                   _EF_,
                   _EE_,
                   _ED_,
                   _EC_,
                   _EB_,
                   _EA_,
                   _Ez_,
                   _Ey_,
                   _Ex_,
                   _Ew_)});
      var _vR_=[0,0,0,0];
      caml_update_dummy
       (js_hyps,
        function(parent,param)
         {var match=param[2],hyp=match[2],handle=match[1],i=param[1];
          function _C7_
           (self,
            parent,
            handle,
            phandle,
            position,
            fresh,
            form,
            proof,
            html,
            mathml,
            tostring,
            toascii,
            getmeta,
            setmeta)
           {if(! _vR_[1])
             {var
               _D3_=create_table(shared$1),
               _D4_=new_variable(_D3_,_vS_),
               _D5_=get_method_labels(_D3_,_u$_),
               _D6_=_D5_[1],
               _D7_=_D5_[2],
               _D8_=_D5_[3],
               _D9_=_D5_[4],
               _D__=_D5_[5],
               _D$_=_D5_[6],
               _Ea_=_D5_[7],
               _Eb_=_D5_[8],
               _Ec_=_D5_[9],
               _Ed_=_D5_[10],
               _Ee_=_D5_[11],
               _Ef_=_D5_[12],
               _Eg_=_D5_[13],
               _Eh_=
                function(self_3)
                 {var env=self_3[1 + _D4_];return caml_call1(env[2],env[1])},
               _Ei_=
                function(self_3)
                 {var env=self_3[1 + _D4_];return caml_call1(env[3],env[1])},
               _Ej_=
                function(self_3)
                 {var env=self_3[1 + _D4_];return caml_call1(env[4],env[1])},
               _Ek_=
                function(self_3)
                 {var env=self_3[1 + _D4_];return caml_call1(env[5],env[1])},
               _El_=
                function(self_3)
                 {var env=self_3[1 + _D4_];return caml_call1(env[6],env[1])},
               _Em_=
                function(self_3)
                 {var env=self_3[1 + _D4_];return caml_call1(env[7],env[1])},
               _En_=function(self_3){var env=self_3[1 + _D4_];return env[8]},
               _Eo_=function(self_3){var env=self_3[1 + _D4_];return env[9]},
               _Ep_=function(self_3){var env=self_3[1 + _D4_];return env[10]},
               _Eq_=function(self_3){var env=self_3[1 + _D4_];return env[11]},
               _Er_=function(self_3){var env=self_3[1 + _D4_];return env[12]},
               _Es_=function(self_3){var env=self_3[1 + _D4_];return env[13]};
              set_methods
               (_D3_,
                [0,
                 _Ea_,
                 function(self_3){var env=self_3[1 + _D4_];return env[14]},
                 _Ed_,
                 _Es_,
                 _D$_,
                 _Er_,
                 _D__,
                 _Eq_,
                 _Ef_,
                 _Ep_,
                 _Eg_,
                 _Eo_,
                 _D9_,
                 _En_,
                 _Ec_,
                 _Em_,
                 _Eb_,
                 _El_,
                 _D6_,
                 _Ek_,
                 _D7_,
                 _Ej_,
                 _Ee_,
                 _Ei_,
                 _D8_,
                 _Eh_]);
              var
               _Et_=
                function(_Eu_)
                 {var _Ev_=create_object_opt(0,_D3_);
                  _Ev_[1 + _D4_] = _Eu_;
                  return _Ev_};
              init_class(_D3_);
              _vR_[1] = _Et_}
            return caml_call1
                    (_vR_[1],
                     [0,
                      self,
                      setmeta,
                      getmeta,
                      toascii,
                      tostring,
                      mathml,
                      html,
                      proof,
                      form,
                      fresh,
                      position,
                      phandle,
                      handle,
                      parent])}
          function _C8_(self,meta)
           {var _DU_=to_option(meta);
            function _DV_(x)
             {return caml_call1(caml_get_public_method(x,939361192,106),x)}
            function _DW_(t128,param){return t128.handle}
            var _DX_=_DW_(self,_DV_);
            function _DY_(x)
             {return caml_call1(caml_get_public_method(x,-930093436,107),x)}
            function _DZ_(x)
             {return caml_call1(caml_get_public_method(x,-930093436,108),x)}
            function _D0_(t126,param){return t126.proof}
            var _D1_=_D0_(self,_DZ_);
            function _D2_(t127,param){return t127.proof}
            return set_meta(_D2_(_D1_,_DY_),_DX_,_DU_)}
          function _C9_(self)
           {function _DL_(x)
             {return caml_call1(caml_get_public_method(x,939361192,109),x)}
            function _DM_(t125,param){return t125.handle}
            var _DN_=_DM_(self,_DL_);
            function _DO_(x)
             {return caml_call1(caml_get_public_method(x,-930093436,110),x)}
            function _DP_(x)
             {return caml_call1(caml_get_public_method(x,-930093436,111),x)}
            function _DQ_(t123,param){return t123.proof}
            var _DR_=_DQ_(self,_DP_);
            function _DS_(t124,param){return t124.proof}
            var _DT_=_DS_(_DR_,_DO_);
            return option(get_meta(_DT_,_DN_))}
          function _C__(self)
           {function _DH_(x)
             {return caml_call1(caml_get_public_method(x,-544987658,112),x)}
            function _DI_(x)
             {return caml_call1(caml_get_public_method(x,-1010802364,113),x)}
            function _DJ_(t121,param){return t121.form}
            var _DK_=_DJ_(self,_DI_);
            return function(t122,param){return t122.toascii()}(_DK_,_DH_)}
          function _C$_(self)
           {function _DD_(x)
             {return caml_call1(caml_get_public_method(x,64642188,114),x)}
            function _DE_(x)
             {return caml_call1(caml_get_public_method(x,-1010802364,115),x)}
            function _DF_(t119,param){return t119.form}
            var _DG_=_DF_(self,_DE_);
            return function(t120,param){return t120.tostring()}(_DG_,_DD_)}
          function _Da_(self)
           {function _Dz_(x)
             {return caml_call1(caml_get_public_method(x,1002480423,116),x)}
            function _DA_(x)
             {return caml_call1(caml_get_public_method(x,-1010802364,117),x)}
            function _DB_(t117,param){return t117.form}
            var _DC_=_DB_(self,_DA_);
            return function(t118,param){return t118.mathml()}(_DC_,_Dz_)}
          function _Db_(self)
           {function _Dv_(x)
             {return caml_call1(caml_get_public_method(x,-988375701,118),x)}
            function _Dw_(x)
             {return caml_call1(caml_get_public_method(x,-1010802364,119),x)}
            function _Dx_(t115,param){return t115.form}
            var _Dy_=_Dx_(self,_Dw_);
            return function(t116,param){return t116.html()}(_Dy_,_Dv_)}
          function _Dc_(x)
           {return caml_call1(caml_get_public_method(x,-310508246,120),x)}
          function _Dd_(t114,param){return t114.parent}
          var _De_=_Dd_(parent,_Dc_),_Df_=hyp[3],_Dg_=[0,72,handle];
          function _Dh_(x)
           {return caml_call1(caml_get_public_method(x,939361192,121),x)}
          function _Di_(t113,param){return t113.handle}
          var
           _Dj_=[0,_Di_(parent,_Dh_),_Dg_],
           _Dk_=caml_call2(js_form,_Dj_,_Df_),
           _Dl_=hyp[2] <= 1?1:0,
           _Dm_=! ! _Dl_,
           _Dn_=hyp[1],
           _Do_=option(_Dn_);
          return function
                   (t130,
                    t131,
                    t132,
                    t133,
                    t134,
                    t135,
                    t136,
                    t137,
                    t138,
                    t139,
                    t140,
                    t141,
                    t142,
                    param)
                   {var
                     _Dp_=caml_js_wrap_meth_callback(t142),
                     _Dq_=caml_js_wrap_meth_callback(t141),
                     _Dr_=caml_js_wrap_meth_callback(t140),
                     _Ds_=caml_js_wrap_meth_callback(t139),
                     _Dt_=caml_js_wrap_meth_callback(t138),
                     _Du_=caml_js_wrap_meth_callback(t137);
                    return {"parent":t130,
                            "handle":t131,
                            "phandle":t132,
                            "position":t133,
                            "fresh":t134,
                            "form":t135,
                            "proof":t136,
                            "html":_Du_,
                            "mathml":_Dt_,
                            "tostring":_Ds_,
                            "toascii":_Dr_,
                            "getmeta":_Dq_,
                            "setmeta":_Dp_}}
                  (parent,
                   handle,
                   _Do_,
                   i,
                   _Dm_,
                   _Dk_,
                   _De_,
                   _Db_,
                   _Da_,
                   _C$_,
                   _C__,
                   _C9_,
                   _C8_,
                   _C7_)});
      var _vT_=[0,0,0,0];
      caml_update_dummy
       (js_tvar,
        function(parent,param)
         {var
           _zU_=param[2],
           match=_zU_[3],
           b=match[2],
           ty=match[1],
           x=_zU_[2],
           handle=_zU_[1],
           i=param[1];
          function _zV_
           (self,
            parent,
            handle,
            position,
            name,
            type,
            body,
            proof,
            prefix,
            idhead,
            idbody,
            html,
            mathml,
            tostring,
            toascii,
            getmeta,
            setmeta)
           {if(! _vT_[1])
             {var
               _Cw_=create_table(_va_),
               _Cx_=new_variable(_Cw_,_vU_),
               _Cy_=get_method_labels(_Cw_,_u3_),
               _Cz_=_Cy_[1],
               _CA_=_Cy_[2],
               _CB_=_Cy_[3],
               _CC_=_Cy_[4],
               _CD_=_Cy_[5],
               _CE_=_Cy_[6],
               _CF_=_Cy_[7],
               _CG_=_Cy_[8],
               _CH_=_Cy_[9],
               _CI_=_Cy_[10],
               _CJ_=_Cy_[11],
               _CK_=_Cy_[12],
               _CL_=_Cy_[13],
               _CM_=_Cy_[14],
               _CN_=_Cy_[15],
               _CO_=_Cy_[16],
               _CP_=
                function(self_4)
                 {var env=self_4[1 + _Cx_];return caml_call1(env[2],env[1])},
               _CQ_=
                function(self_4)
                 {var env=self_4[1 + _Cx_];return caml_call1(env[3],env[1])},
               _CR_=
                function(self_4)
                 {var env=self_4[1 + _Cx_];return caml_call1(env[4],env[1])},
               _CS_=
                function(self_4)
                 {var env=self_4[1 + _Cx_];return caml_call1(env[5],env[1])},
               _CT_=
                function(self_4)
                 {var env=self_4[1 + _Cx_];return caml_call1(env[6],env[1])},
               _CU_=
                function(self_4)
                 {var env=self_4[1 + _Cx_];return caml_call1(env[7],env[1])},
               _CV_=
                function(self_4)
                 {var env=self_4[1 + _Cx_];return caml_call1(env[8],env[1])},
               _CW_=
                function(self_4)
                 {var env=self_4[1 + _Cx_];return caml_call1(env[9],env[1])},
               _CX_=
                function(self_4)
                 {var env=self_4[1 + _Cx_];return caml_call1(env[10],env[1])},
               _CY_=function(self_4){var env=self_4[1 + _Cx_];return env[11]},
               _CZ_=function(self_4){var env=self_4[1 + _Cx_];return env[12]},
               _C0_=function(self_4){var env=self_4[1 + _Cx_];return env[13]},
               _C1_=function(self_4){var env=self_4[1 + _Cx_];return env[14]},
               _C2_=function(self_4){var env=self_4[1 + _Cx_];return env[15]},
               _C3_=function(self_4){var env=self_4[1 + _Cx_];return env[16]};
              set_methods
               (_Cw_,
                [0,
                 _CG_,
                 function(self_4){var env=self_4[1 + _Cx_];return env[17]},
                 _CM_,
                 _C3_,
                 _CF_,
                 _C2_,
                 _CH_,
                 _C1_,
                 _Cz_,
                 _C0_,
                 _CO_,
                 _CZ_,
                 _CD_,
                 _CY_,
                 _CE_,
                 _CX_,
                 _CJ_,
                 _CW_,
                 _CK_,
                 _CV_,
                 _CL_,
                 _CU_,
                 _CI_,
                 _CT_,
                 _CA_,
                 _CS_,
                 _CB_,
                 _CR_,
                 _CN_,
                 _CQ_,
                 _CC_,
                 _CP_]);
              var
               _C4_=
                function(_C5_)
                 {var _C6_=create_object_opt(0,_Cw_);
                  _C6_[1 + _Cx_] = _C5_;
                  return _C6_};
              init_class(_Cw_);
              _vT_[1] = _C4_}
            return caml_call1
                    (_vT_[1],
                     [0,
                      self,
                      setmeta,
                      getmeta,
                      toascii,
                      tostring,
                      mathml,
                      html,
                      idbody,
                      idhead,
                      prefix,
                      proof,
                      body,
                      type,
                      name,
                      position,
                      handle,
                      parent])}
          function _zW_(self,meta)
           {var _Cn_=to_option(meta);
            function _Co_(x)
             {return caml_call1(caml_get_public_method(x,939361192,122),x)}
            function _Cp_(t161,param){return t161.handle}
            var _Cq_=_Cp_(self,_Co_);
            function _Cr_(x)
             {return caml_call1(caml_get_public_method(x,-930093436,123),x)}
            function _Cs_(x)
             {return caml_call1(caml_get_public_method(x,-930093436,124),x)}
            function _Ct_(t159,param){return t159.proof}
            var _Cu_=_Ct_(self,_Cs_);
            function _Cv_(t160,param){return t160.proof}
            return set_meta(_Cv_(_Cu_,_Cr_),_Cq_,_Cn_)}
          function _zX_(self)
           {function _Ce_(x)
             {return caml_call1(caml_get_public_method(x,939361192,125),x)}
            function _Cf_(t158,param){return t158.handle}
            var _Cg_=_Cf_(self,_Ce_);
            function _Ch_(x)
             {return caml_call1(caml_get_public_method(x,-930093436,126),x)}
            function _Ci_(x)
             {return caml_call1(caml_get_public_method(x,-930093436,127),x)}
            function _Cj_(t156,param){return t156.proof}
            var _Ck_=_Cj_(self,_Ci_);
            function _Cl_(t157,param){return t157.proof}
            var _Cm_=_Cl_(_Ck_,_Ch_);
            return option(get_meta(_Cm_,_Cg_))}
          function _zY_(self)
           {if(b)
             {var
               b$0=b[1],
               _B8_=e_toascii(b$0),
               _B9_=[0,x],
               _B__=e_tostring(_B9_),
               _B$_=caml_call2(sprintf$0(_vV_),_B__,_B8_);
              return caml_jsstring_of_string(_B$_)}
            var
             _Ca_=t_toascii(ty),
             _Cb_=[0,x],
             _Cc_=e_tostring(_Cb_),
             _Cd_=caml_call2(sprintf$0(_vW_),_Cc_,_Ca_);
            return caml_jsstring_of_string(_Cd_)}
          function _zZ_(self)
           {if(b)
             {var
               b$0=b[1],
               _BZ_=e_tostring(b$0),
               _B0_=t_tostring(ty),
               _B1_=[0,x],
               _B2_=e_tostring(_B1_),
               _B3_=caml_call3(sprintf$0(_vX_),_B2_,_B0_,_BZ_);
              return caml_jsstring_of_string(_B3_)}
            var
             _B4_=t_tostring(ty),
             _B5_=[0,x],
             _B6_=e_tostring(_B5_),
             _B7_=caml_call2(sprintf$0(_vY_),_B6_,_B4_);
            return caml_jsstring_of_string(_B7_)}
          function _z0_(self)
           {var _Bp_=0;
            if(b)
             var
              b$0=b[1],
              _Bq_=0,
              _Br_=
               function(x)
                {return caml_call1(caml_get_public_method(x,-794402819,128),x)},
              _Bs_=function(t155,param){return t155.idbody()},
              _Bt_=[0,[0,_Bs_(self,_Br_)]],
              _Bu_=[0,e_tomathml(_Bt_,b$0),_Bq_],
              _Bv_=0,
              _Bw_=[0,mo(_vZ_),_Bv_],
              _Bx_=append(_Bw_,_Bu_);
            else
             var _Bx_=0;
            var
             _By_=0,
             _Bz_=0,
             _BA_=[0,t_tomathml(ty),_Bz_],
             _BB_=0,
             _BC_=[0,mo(_v0_),_BB_],
             _BD_=append(_BC_,_BA_),
             _BE_=0,
             _BF_=[0,x],
             _BG_=e_tostring(_BF_),
             _BH_=of_latin1(_BG_),
             _BI_=[0,mi(_BH_),_BE_],
             _BJ_=append(_BI_,_BD_),
             _BK_=0;
            function _BL_(x)
             {return caml_call1(caml_get_public_method(x,-728363397,129),x)}
            function _BM_(t154,param){return t154.idhead()}
            var
             _BN_=_BM_(self,_BL_),
             _BO_=[0,[0,string_attrib(_v1_,_BN_),_BK_]],
             _BP_=[0,caml_call1(row(_BO_),_BJ_),_By_],
             _BQ_=append(_BP_,_Bx_),
             _BR_=0,
             _BS_=[0,caml_call1(row(_BR_),_BQ_),_Bp_],
             _BT_=0,
             dt=caml_call1(math(_BT_),_BS_),
             _BU_=0,
             _BV_=0,
             _BW_=0,
             _BX_=caml_call3(pp$1,_BW_,_BV_,_BU_),
             _BY_=caml_call2(asprintf(_v2_),_BX_,dt);
            return caml_jsstring_of_string(_BY_)}
          function _z1_(self)
           {var _AC_=0;
            if(b)
             var
              b$0=b[1],
              _AD_=0,
              _AE_=
               function(x)
                {return caml_call1(caml_get_public_method(x,-794402819,130),x)},
              _AF_=function(t153,param){return t153.idbody()},
              _AG_=[0,[0,_AF_(self,_AE_)]],
              _AH_=[0,e_tohtml(_AG_,b$0),_AD_],
              _AI_=0,
              _AJ_=0,
              _AK_=[0,pcdata(_v3_),_AJ_],
              _AL_=0,
              _AM_=[0,caml_call1(span(_AL_),_AK_),_AI_],
              _AN_=0,
              _AO_=0,
              _AP_=spaced$0(_AO_,_AN_,_AM_),
              _AQ_=append(_AP_,_AH_);
            else
             var _AQ_=0;
            var
             _AR_=0,
             _AS_=0,
             _AT_=[0,t_tohtml(ty),_AS_],
             _AU_=0,
             _AV_=0,
             _AW_=[0,pcdata(_v4_),_AV_],
             _AX_=0,
             _AY_=[0,caml_call1(span(_AX_),_AW_),_AU_],
             _AZ_=0,
             _A0_=0,
             _A1_=spaced$0(_A0_,_AZ_,_AY_),
             _A2_=append(_A1_,_AT_),
             _A3_=0,
             _A4_=0,
             _A5_=[0,x],
             _A6_=e_tostring(_A5_),
             _A7_=of_latin1(_A6_),
             _A8_=[0,pcdata(_A7_),_A4_],
             _A9_=0,
             _A__=[0,caml_call1(span(_A9_),_A8_),_A3_],
             _A$_=append(_A__,_A2_),
             _Ba_=0;
            function _Bb_(x)
             {return caml_call1(caml_get_public_method(x,-728363397,131),x)}
            function _Bc_(t152,param){return t152.idhead()}
            var
             _Bd_=_Bc_(self,_Bb_),
             _Be_=[0,[0,string_attrib(_v5_,_Bd_),_Ba_]],
             _Bf_=[0,caml_call1(span(_Be_),_A$_),_AR_],
             _Bg_=append(_Bf_,_AQ_),
             _Bh_=0,
             _Bi_=[0,caml_call1(span(_Bh_),_Bg_),_AC_],
             _Bj_=0,
             dt=caml_call1(span(_Bj_),_Bi_),
             _Bk_=0,
             _Bl_=0,
             _Bm_=0,
             _Bn_=caml_call3(pp$1,_Bm_,_Bl_,_Bk_),
             _Bo_=caml_call2(asprintf(_v6_),_Bn_,dt);
            return caml_jsstring_of_string(_Bo_)}
          function _z2_(self)
           {function _AA_(x)
             {return caml_call1(caml_get_public_method(x,783735186,132),x)}
            var _AB_=1;
            return function(t151,t150,param){return t151.prefix(t150)}
                    (self,_AB_,_AA_)}
          function _z3_(self)
           {function _Ay_(x)
             {return caml_call1(caml_get_public_method(x,783735186,133),x)}
            var _Az_=0;
            return function(t149,t148,param){return t149.prefix(t148)}
                    (self,_Az_,_Ay_)}
          function _z4_(self,b)
           {var _Al_=b?_v7_:_v$_;
            function _Am_(x)
             {return caml_call1(caml_get_public_method(x,939361192,134),x)}
            function _An_(t146,param){return t146.handle}
            var _Ao_=_An_(self,_Am_),_Ap_=toint(_Ao_),_Aq_=b?_v8_:_v__;
            function _Ar_(x)
             {return caml_call1(caml_get_public_method(x,939361192,135),x)}
            function _As_(x)
             {return caml_call1(caml_get_public_method(x,-310508246,136),x)}
            function _At_(t144,param){return t144.parent}
            var _Au_=_At_(self,_As_);
            function _Av_(t145,param){return t145.handle}
            var _Aw_=_Av_(_Au_,_Ar_),_Ax_=toint(_Aw_);
            return caml_call4(sprintf$0(_v9_),_Ax_,_Aq_,_Ap_,_Al_)}
          function _z5_(x)
           {return caml_call1(caml_get_public_method(x,-310508246,137),x)}
          function _z6_(t143,param){return t143.parent}
          var
           _z7_=_z6_(parent,_z5_),
           _z8_=map$3(js_expr,b),
           _z9_=option(_z8_),
           _z__=caml_call1(js_type,ty),
           _z$_=[0,x],
           _Aa_=e_tostring(_z$_),
           _Ab_=caml_jsstring_of_string(_Aa_);
          return function
                   (t163,
                    t164,
                    t165,
                    t166,
                    t167,
                    t168,
                    t169,
                    t170,
                    t171,
                    t172,
                    t173,
                    t174,
                    t175,
                    t176,
                    t177,
                    t178,
                    param)
                   {var
                     _Ac_=caml_js_wrap_meth_callback(t178),
                     _Ad_=caml_js_wrap_meth_callback(t177),
                     _Ae_=caml_js_wrap_meth_callback(t176),
                     _Af_=caml_js_wrap_meth_callback(t175),
                     _Ag_=caml_js_wrap_meth_callback(t174),
                     _Ah_=caml_js_wrap_meth_callback(t173),
                     _Ai_=caml_js_wrap_meth_callback(t172),
                     _Aj_=caml_js_wrap_meth_callback(t171),
                     _Ak_=caml_js_wrap_meth_callback(t170);
                    return {"parent":t163,
                            "handle":t164,
                            "position":t165,
                            "name":t166,
                            "type":t167,
                            "body":t168,
                            "proof":t169,
                            "prefix":_Ak_,
                            "idhead":_Aj_,
                            "idbody":_Ai_,
                            "html":_Ah_,
                            "mathml":_Ag_,
                            "tostring":_Af_,
                            "toascii":_Ae_,
                            "getmeta":_Ad_,
                            "setmeta":_Ac_}}
                  (parent,
                   handle,
                   i,
                   _Ab_,
                   _z__,
                   _z9_,
                   _z7_,
                   _z4_,
                   _z3_,
                   _z2_,
                   _z1_,
                   _z0_,
                   _zZ_,
                   _zY_,
                   _zX_,
                   _zW_,
                   _zV_)});
      var _wa_=[0,0,0,0];
      caml_update_dummy
       (js_form,
        function(source,form)
         {function _yT_
           (self,prefix,mathml,html,mathmltag,htmltag,tostring,toascii)
           {if(! _wa_[1])
             {var
               _zB_=create_table(_u__),
               _zC_=new_variable(_zB_,_wb_),
               _zD_=get_method_labels(_zB_,_u4_),
               _zE_=_zD_[1],
               _zF_=_zD_[2],
               _zG_=_zD_[3],
               _zH_=_zD_[4],
               _zI_=_zD_[5],
               _zJ_=_zD_[6],
               _zK_=_zD_[7],
               _zL_=
                function(self_5)
                 {var env=self_5[1 + _zC_];return caml_call1(env[2],env[1])},
               _zM_=
                function(self_5)
                 {var env=self_5[1 + _zC_];return caml_call1(env[3],env[1])},
               _zN_=
                function(self_5)
                 {var env=self_5[1 + _zC_];return caml_call1(env[4],env[1])},
               _zO_=
                function(self_5)
                 {var env=self_5[1 + _zC_];return caml_call1(env[5],env[1])},
               _zP_=
                function(self_5)
                 {var env=self_5[1 + _zC_];return caml_call1(env[6],env[1])},
               _zQ_=
                function(self_5)
                 {var env=self_5[1 + _zC_];return caml_call1(env[7],env[1])};
              set_methods
               (_zB_,
                [0,
                 _zG_,
                 function(self_5){var env=self_5[1 + _zC_];return env[8]},
                 _zI_,
                 _zQ_,
                 _zK_,
                 _zP_,
                 _zH_,
                 _zO_,
                 _zJ_,
                 _zN_,
                 _zE_,
                 _zM_,
                 _zF_,
                 _zL_]);
              var
               _zR_=
                function(_zS_)
                 {var _zT_=create_object_opt(0,_zB_);
                  _zT_[1 + _zC_] = _zS_;
                  return _zT_};
              init_class(_zB_);
              _wa_[1] = _zR_}
            return caml_call1
                    (_wa_[1],
                     [0,
                      self,
                      toascii,
                      tostring,
                      htmltag,
                      mathmltag,
                      html,
                      mathml,
                      prefix])}
          function _yU_(self)
           {var _zA_=f_toascii(form);return caml_jsstring_of_string(_zA_)}
          function _yV_(self)
           {var _zz_=f_tostring(form);return caml_jsstring_of_string(_zz_)}
          function _yW_(self,id)
           {if(id)
             var
              _zq_=
               function(x)
                {return caml_call1(caml_get_public_method(x,783735186,138),x)},
              _zr_=function(t185,param){return t185.prefix},
              prefix=[0,_zr_(self,_zq_)];
            else
             var prefix=0;
            var
             _zs_=[0,prefix],
             _zt_=f_tohtml(_zs_,form),
             _zu_=0,
             _zv_=0,
             _zw_=0,
             _zx_=caml_call3(pp$1,_zw_,_zv_,_zu_),
             _zy_=caml_call2(asprintf(_wc_),_zx_,_zt_);
            return caml_jsstring_of_string(_zy_)}
          function _yX_(self,id)
           {if(id)
             var
              _ze_=
               function(x)
                {return caml_call1(caml_get_public_method(x,783735186,139),x)},
              _zf_=function(t183,param){return t183.prefix},
              prefix=[0,_zf_(self,_ze_)];
            else
             var prefix=0;
            var
             _zg_=0,
             _zh_=[0,prefix],
             _zi_=[0,f_tomathml(_zh_,form),_zg_],
             _zj_=0,
             _zk_=caml_call1(math(_zj_),_zi_),
             _zl_=0,
             _zm_=0,
             _zn_=0,
             _zo_=caml_call3(pp$1,_zn_,_zm_,_zl_),
             _zp_=caml_call2(asprintf(_wd_),_zo_,_zk_);
            return caml_jsstring_of_string(_zp_)}
          function _yY_(self)
           {function _zc_(x)
             {return caml_call1(caml_get_public_method(x,-796476977,140),x)}
            var _zd_=1;
            return function(t182,t181,param){return t182.htmltag(t181)}
                    (self,_zd_,_zc_)}
          function _yZ_(self)
           {function _za_(x)
             {return caml_call1(caml_get_public_method(x,-198776429,141),x)}
            var _zb_=1;
            return function(t180,t179,param){return t180.mathmltag(t179)}
                    (self,_zb_,_za_)}
          var _y0_=source[2],_y1_=source[1];
          if(typeof _y0_ === "number")
           var _y2_=toint(_y1_),_y3_=caml_call1(sprintf$0(_we_),_y2_);
          else
           var
            i=_y0_[2],
            _y4_=toint(i),
            _y5_=toint(_y1_),
            _y3_=caml_call2(sprintf$0(_wf_),_y5_,_y4_);
          return function(t187,t188,t189,t190,t191,t192,t193,param)
                   {var
                     _y6_=caml_js_wrap_meth_callback(t193),
                     _y7_=caml_js_wrap_meth_callback(t192),
                     _y8_=caml_js_wrap_meth_callback(t191),
                     _y9_=caml_js_wrap_meth_callback(t190),
                     _y__=caml_js_wrap_meth_callback(t189),
                     _y$_=caml_js_wrap_meth_callback(t188);
                    return {"prefix":t187,
                            "mathml":_y$_,
                            "html":_y__,
                            "mathmltag":_y9_,
                            "htmltag":_y8_,
                            "tostring":_y7_,
                            "toascii":_y6_}}
                  (_y3_,_yZ_,_yY_,_yX_,_yW_,_yV_,_yU_,_yT_)});
      var _wg_=[0,0,0,0];
      caml_update_dummy
       (js_expr,
        function(expr)
         {function _x$_(self,mathml,html,mathmltag,htmltag,tostring)
           {if(! _wg_[1])
             {var
               _yE_=create_table(_vc_),
               _yF_=new_variable(_yE_,_wh_),
               _yG_=get_method_labels(_yE_,_vb_),
               _yH_=_yG_[1],
               _yI_=_yG_[2],
               _yJ_=_yG_[3],
               _yK_=_yG_[4],
               _yL_=_yG_[5],
               _yM_=
                function(self_6)
                 {var env=self_6[1 + _yF_];return caml_call1(env[2],env[1])},
               _yN_=
                function(self_6)
                 {var env=self_6[1 + _yF_];return caml_call1(env[3],env[1])},
               _yO_=
                function(self_6)
                 {var env=self_6[1 + _yF_];return caml_call1(env[4],env[1])},
               _yP_=
                function(self_6)
                 {var env=self_6[1 + _yF_];return caml_call1(env[5],env[1])};
              set_methods
               (_yE_,
                [0,
                 _yJ_,
                 function(self_6)
                  {var env=self_6[1 + _yF_];return caml_call1(env[6],env[1])},
                 _yL_,
                 _yP_,
                 _yI_,
                 _yO_,
                 _yK_,
                 _yN_,
                 _yH_,
                 _yM_]);
              var
               _yQ_=
                function(_yR_)
                 {var _yS_=create_object_opt(0,_yE_);
                  _yS_[1 + _yF_] = _yR_;
                  return _yS_};
              init_class(_yE_);
              _wg_[1] = _yQ_}
            return caml_call1
                    (_wg_[1],[0,self,tostring,htmltag,mathmltag,html,mathml])}
          function _ya_(self)
           {var _yD_=e_tostring(expr);return caml_jsstring_of_string(_yD_)}
          function _yb_(self)
           {var
             _yw_=0,
             _yx_=e_tohtml(_yw_,expr),
             _yy_=0,
             _yz_=0,
             _yA_=0,
             _yB_=caml_call3(pp$1,_yA_,_yz_,_yy_),
             _yC_=caml_call2(asprintf(_wi_),_yB_,_yx_);
            return caml_jsstring_of_string(_yC_)}
          function _yc_(self)
           {var
             _ym_=0,
             _yn_=0,
             _yo_=[0,e_tomathml(_yn_,expr),_ym_],
             _yp_=0,
             _yq_=caml_call1(math(_yp_),_yo_),
             _yr_=0,
             _ys_=0,
             _yt_=0,
             _yu_=caml_call3(pp$1,_yt_,_ys_,_yr_),
             _yv_=caml_call2(asprintf(_wj_),_yu_,_yq_);
            return caml_jsstring_of_string(_yv_)}
          function _yd_(self)
           {function _yl_(x)
             {return caml_call1(caml_get_public_method(x,-796476977,142),x)}
            return function(t195,param){return t195.htmltag()}(self,_yl_)}
          function _ye_(self)
           {function _yk_(x)
             {return caml_call1(caml_get_public_method(x,-198776429,143),x)}
            return function(t194,param){return t194.mathmltag()}(self,_yk_)}
          return function(t196,t197,t198,t199,t200,param)
                   {var
                     _yf_=caml_js_wrap_meth_callback(t200),
                     _yg_=caml_js_wrap_meth_callback(t199),
                     _yh_=caml_js_wrap_meth_callback(t198),
                     _yi_=caml_js_wrap_meth_callback(t197),
                     _yj_=caml_js_wrap_meth_callback(t196);
                    return {"mathml":_yj_,
                            "html":_yi_,
                            "mathmltag":_yh_,
                            "htmltag":_yg_,
                            "tostring":_yf_}}
                  (_ye_,_yd_,_yc_,_yb_,_ya_,_x$_)});
      var _wk_=[0,0,0,0];
      caml_update_dummy
       (js_type,
        function(ty)
         {function _xm_(self,rawmathml,rawhtml,rawstring,mathml,html,tostring)
           {if(! _wk_[1])
             {var
               _xU_=create_table(_ve_),
               _xV_=new_variable(_xU_,_wl_),
               _xW_=get_method_labels(_xU_,_u6_),
               _xX_=_xW_[1],
               _xY_=_xW_[2],
               _xZ_=_xW_[3],
               _x0_=_xW_[4],
               _x1_=_xW_[5],
               _x2_=_xW_[6],
               _x3_=
                function(self_7)
                 {var env=self_7[1 + _xV_];return caml_call1(env[2],env[1])},
               _x4_=
                function(self_7)
                 {var env=self_7[1 + _xV_];return caml_call1(env[3],env[1])},
               _x5_=
                function(self_7)
                 {var env=self_7[1 + _xV_];return caml_call1(env[4],env[1])},
               _x6_=
                function(self_7)
                 {var env=self_7[1 + _xV_];return caml_call1(env[5],env[1])},
               _x7_=
                function(self_7)
                 {var env=self_7[1 + _xV_];return caml_call1(env[6],env[1])};
              set_methods
               (_xU_,
                [0,
                 _xZ_,
                 function(self_7)
                  {var env=self_7[1 + _xV_];return caml_call1(env[7],env[1])},
                 _x0_,
                 _x7_,
                 _xY_,
                 _x6_,
                 _x1_,
                 _x5_,
                 _x2_,
                 _x4_,
                 _xX_,
                 _x3_]);
              var
               _x8_=
                function(_x9_)
                 {var _x__=create_object_opt(0,_xU_);
                  _x__[1 + _xV_] = _x9_;
                  return _x__};
              init_class(_xU_);
              _wk_[1] = _x8_}
            return caml_call1
                    (_wk_[1],
                     [0,self,tostring,html,mathml,rawstring,rawhtml,rawmathml])}
          function _xn_(self)
           {function _xR_(x)
             {return caml_call1(caml_get_public_method(x,21519545,144),x)}
            function _xS_(t203,param){return t203.rawstring()}
            var _xT_=_xS_(self,_xR_);
            return caml_jsstring_of_string(_xT_)}
          function _xo_(self)
           {function _xJ_(x)
             {return caml_call1(caml_get_public_method(x,384991059,145),x)}
            function _xK_(t202,param){return t202.rawhtml()}
            var
             _xL_=_xK_(self,_xJ_),
             _xM_=0,
             _xN_=0,
             _xO_=0,
             _xP_=caml_call3(pp$1,_xO_,_xN_,_xM_),
             _xQ_=caml_call2(asprintf(_wm_),_xP_,_xL_);
            return caml_jsstring_of_string(_xQ_)}
          function _xp_(self)
           {function _xB_(x)
             {return caml_call1(caml_get_public_method(x,735631119,146),x)}
            function _xC_(t201,param){return t201.rawmathml()}
            var
             _xD_=_xC_(self,_xB_),
             _xE_=0,
             _xF_=0,
             _xG_=0,
             _xH_=caml_call3(pp$1,_xG_,_xF_,_xE_),
             _xI_=caml_call2(asprintf(_wn_),_xH_,_xD_);
            return caml_jsstring_of_string(_xI_)}
          function _xq_(self){return t_tostring(ty)}
          function _xr_(self){return t_tohtml(ty)}
          function _xs_(self)
           {var _xz_=0,_xA_=[0,t_tomathml(ty),_xz_];
            return caml_call1(math(0),_xA_)}
          return function(t204,t205,t206,t207,t208,t209,param)
                   {var
                     _xt_=caml_js_wrap_meth_callback(t209),
                     _xu_=caml_js_wrap_meth_callback(t208),
                     _xv_=caml_js_wrap_meth_callback(t207),
                     _xw_=caml_js_wrap_meth_callback(t206),
                     _xx_=caml_js_wrap_meth_callback(t205),
                     _xy_=caml_js_wrap_meth_callback(t204);
                    return {"rawmathml":_xy_,
                            "rawhtml":_xx_,
                            "rawstring":_xw_,
                            "mathml":_xv_,
                            "html":_xu_,
                            "tostring":_xt_}}
                  (_xs_,_xr_,_xq_,_xp_,_xo_,_xn_,_xm_)});
      var
       _wo_=[0,0,0,0],
       export$1=
        function(name)
         {function _wM_(self,parse,parseToUnicode)
           {if(! _wo_[1])
             {var
               _xd_=create_table(_u7_),
               _xe_=new_variable(_xd_,_wp_),
               _xf_=get_method_labels(_xd_,_u7_),
               _xg_=_xf_[1],
               _xh_=_xf_[2],
               _xi_=
                function(self_8)
                 {var env=self_8[1 + _xe_];return caml_call1(env[2],env[1])};
              set_methods
               (_xd_,
                [0,
                 _xh_,
                 function(self_8)
                  {var env=self_8[1 + _xe_];return caml_call1(env[3],env[1])},
                 _xg_,
                 _xi_]);
              var
               _xj_=
                function(_xk_)
                 {var _xl_=create_object_opt(0,_xd_);
                  _xl_[1 + _xe_] = _xk_;
                  return _xl_};
              init_class(_xd_);
              _wo_[1] = _xj_}
            return caml_call1(_wo_[1],[0,self,parseToUnicode,parse])}
          function _wN_(param,x)
           {var _wY_=0;
            function _wZ_(param)
             {function _w__(x)
               {return caml_call1(caml_get_public_method(x,1042138122,147),x)}
              function _w$_(t211,param){return t211.input}
              var
               _xa_=_w$_(x,_w__),
               _xb_=caml_string_of_jsstring(_xa_),
               goal=trim(_xb_),
               _xc_=from_string$1(goal),
               goal$0=parse_goal(_xc_);
              return check$2(goal$0)}
            function _w0_(_w9_){return symbol$5(_wZ_,_w9_)}
            var
             match=_w0_(_wY_),
             goal=match[3],
             hyps=match[2],
             _w1_=f_tostring(goal);
            function _w2_(b)
             {return b | 0
                      ?caml_call1(to_string$8(_ws_,_wr_,_wq_,f_tostring),hyps)
                      :_wt_}
            function _w3_(param){return _wu_}
            function _w4_(x)
             {return caml_call1(caml_get_public_method(x,-971832799,148),x)}
            function _w5_(t212,param){return t212.printHyps}
            var
             _w6_=_w5_(x,_w4_),
             _w7_=case$1(_w6_,_w3_,_w2_),
             _w8_=caml_call2(sprintf(_wv_),_w7_,_w1_);
            return caml_jsstring_of_string(_w8_)}
          function _wO_(param,x)
           {var _wS_=0;
            function _wT_(param)
             {var
               _wW_=caml_string_of_jsstring(x),
               goal=trim(_wW_),
               _wX_=from_string$1(goal),
               goal$0=parse_goal(_wX_);
              return check$2(goal$0)}
            function _wU_(_wV_){return symbol$5(_wT_,_wV_)}
            var match=_wU_(_wS_),goal=match[3],hyps=match[2],env=match[1];
            return caml_call1(js_proof_engine,init$2(env,hyps,goal))}
          function _wP_(t214,t215,param)
           {var
             _wQ_=caml_js_wrap_meth_callback(t215),
             _wR_=caml_js_wrap_meth_callback(t214);
            return {"parse":_wR_,"parseToUnicode":_wQ_}}
          return export$0(name,_wP_(_wO_,_wN_,_wM_))};
      export$1(_ww_);
      var _wx_=0;
      do_at_exit(_wx_);
      return}}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJqc3Byb3Zlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJPYmplY3QiLCJnbG9iYWxUaGlzIiwidGhpcyIsImdldCIsIl9UXyIsImdsb2JhbCIsInNlbGYiLCJtb2R1bGUiLCJjYW1sX2FycmF5X2JsaXQiLCJhMSIsImkxIiwiYTIiLCJpMiIsImxlbiIsImoiLCJjYW1sX2FycmF5X2ZpbGwiLCJhcnJheSIsIm9mcyIsInYiLCJpIiwiY2FtbF9hcnJheV9zdWIiLCJhIiwiQXJyYXkiLCJjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMiLCJmIiwiU3RyaW5nIiwibnVsbCIsInMiLCJNYXRoIiwiY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IiwiYiIsImwiLCJjYW1sX2JsaXRfYnl0ZXMiLCJzMSIsInMyIiwiYzEiLCJjMiIsImNhbWxfYnl0ZXNfb2Zfc3RyaW5nIiwiY2FtbF9ibGl0X3N0cmluZyIsImMiLCJkIiwiZSIsImNhbWxfcmFpc2Vfd2l0aF9hcmciLCJ0YWciLCJhcmciLCJjYW1sX3N0cl9yZXBlYXQiLCJuIiwiciIsImNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMiLCJqc29vX2lzX2FzY2lpIiwiY2FtbF91dGYxNl9vZl91dGY4IiwidCIsIk1sQnl0ZXMiLCJjb250ZW50cyIsImxlbmd0aCIsImNvbnRlbnQiLCJjYW1sX2J5dGVzX29mX2pzYnl0ZXMiLCJjYW1sX3N0cmluZ19vZl9qc2J5dGVzIiwiY2FtbF9yYWlzZV93aXRoX3N0cmluZyIsIm1zZyIsImNhbWxfZ2xvYmFsX2RhdGEiLCJjYW1sX2ludmFsaWRfYXJndW1lbnQiLCJjYW1sX2J5dGVzX2JvdW5kX2Vycm9yIiwiY2FtbF9ieXRlc191bnNhZmVfZ2V0IiwiY2FtbF9ieXRlc19nZXQiLCJjYW1sX2J5dGVzX3Vuc2FmZV9zZXQiLCJjYW1sX2J5dGVzX3NldCIsImNhbWxfY2FsbF9nZW4iLCJhcmdzIiwiYXJnc0xlbiIsImV4dHJhX2FyZ3MiLCJhcmd1bWVudHMiLCJuYXJncyIsImNhbWxfYXJyYXlfYm91bmRfZXJyb3IiLCJjYW1sX2NoZWNrX2JvdW5kIiwiaW5kZXgiLCJjYW1sX2NsYXNzaWZ5X2Zsb2F0IiwieCIsImlzRmluaXRlIiwiaXNOYU4iLCJjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIiwibG9nMl9vayIsImpzb29fZmxvb3JfbG9nMiIsIkluZmluaXR5IiwiY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0IiwiZmxvYXQzMmEiLCJpbnQzMmEiLCJjYW1sX2ludDY0X29mZnNldCIsImNhbWxfcmFpc2VfY29uc3RhbnQiLCJjYW1sX3JhaXNlX3plcm9fZGl2aWRlIiwiTWxJbnQ2NCIsImxvIiwibWkiLCJoaSIsInhoaSIsImgiLCJzaWduIiwib2Zmc2V0IiwibW9kdWx1cyIsImRpdmlzb3IiLCJxdW90aWVudCIsInkiLCJxIiwiY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkiLCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQiLCJleHAiLCJrIiwicjMiLCJyMiIsInIxIiwiY2FtbF9pbnQ2NF90b19ieXRlcyIsImNhbWxfYmFfc2VyaWFsaXplIiwid3JpdGVyIiwiYmEiLCJzeiIsImNvbXBsZXgiLCJjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50Iiwia2luZCIsImNhbWxfYmFfY3JlYXRlX2J1ZmZlciIsInNpemUiLCJnIiwidmlldyIsImRhdGEiLCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMiLCJjYW1sX2ludDY0X29mX2J5dGVzIiwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIiwiTmFOIiwicmVzIiwiY2FtbF9iYV9nZXRfc2l6ZSIsImRpbXMiLCJuX2RpbXMiLCJjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSIsImNhbWxfaW50NjRfaGkzMiIsImNhbWxfaW50NjRfbG8zMiIsImNhbWxfYmFfY3VzdG9tX25hbWUiLCJNbF9CaWdhcnJheSIsImxheW91dCIsImJ1ZmZlciIsImltIiwicmUiLCJ0b3RhbCIsImsxIiwiazIiLCJNbF9CaWdhcnJheV9jXzFfMSIsImNhbWxfYmFfY3JlYXRlX3Vuc2FmZSIsInNpemVfcGVyX2VsZW1lbnQiLCJjYW1sX2ZhaWx3aXRoIiwiY2FtbF9iYV9kZXNlcmlhbGl6ZSIsInJlYWRlciIsIm5hbWUiLCJudW1fZGltcyIsInNpemVfZGltIiwic2l6ZV9kaW1faGkiLCJzaXplX2RpbV9sbyIsInNpeHR5IiwiaW50NjQiLCJjYW1sX2JhX2NvbXBhcmUiLCJjYW1sX211bCIsImNhbWxfaGFzaF9taXhfaW50IiwiY2FtbF9oYXNoX21peF9pbnQ2NCIsImNhbWxfaGFzaF9taXhfZmxvYXQiLCJ2MCIsImNhbWxfYmFfaGFzaCIsIm51bV9lbHRzIiwidyIsImNhbWxfaW50MzJfdW5tYXJzaGFsIiwiY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsIiwiY2FtbF9pbnQ2NF91bm1hcnNoYWwiLCJjYW1sX2ludDY0X21hcnNoYWwiLCJzaXplcyIsImNhbWxfaW50NjRfY29tcGFyZSIsImNhbWxfaW50NjRfaGFzaCIsImNhbWxfY3VzdG9tX29wcyIsImNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbSIsImNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbSIsIm51bSIsImN1c3RvbSIsInN3YXAiLCJjb21wIiwiY2FtbF9pc19tbF9ieXRlcyIsImNhbWxfaXNfbWxfc3RyaW5nIiwiY2FtbF9jb21wYXJlX3ZhbF90YWciLCJOdW1iZXIiLCJjYW1sX2ludF9jb21wYXJlIiwiY2FtbF9ieXRlc19jb21wYXJlIiwiY2FtbF9zdHJpbmdfY29tcGFyZSIsImNhbWxfY29tcGFyZV92YWwiLCJzdGFjayIsInRhZ19hIiwidGFnX2IiLCJjYW1sX2NvbXBhcmUiLCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSIsImNhbWxfY3JlYXRlX2J5dGVzIiwiY2FtbF9kaXYiLCJjYW1sX2VwaGVfa2V5X29mZnNldCIsImNhbWxfd2Vha19zZXQiLCJjYW1sX2VwaGVfc2V0X2tleSIsImNhbWxfZXBoZV91bnNldF9rZXkiLCJjYW1sX2VxdWFsIiwiY2FtbF9maWxsX2J5dGVzIiwiY2FtbF9maW5hbF9yZWdpc3RlciIsImNhbWxfZmxvYXRfb2Zfc3RyaW5nIiwibSIsIm0zIiwibWFudGlzc2EiLCJwYXJzZUludCIsImV4cG9uZW50IiwiY2FtbF9wYXJzZV9mb3JtYXQiLCJmbXQiLCJjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nIiwicmF3YnVmZmVyIiwiY2FtbF9mb3JtYXRfZmxvYXQiLCJ0b0ZpeGVkIiwiZHAiLCJwcmVjIiwicCIsImNhbWxfZm9ybWF0X2ludCIsImNhbWxfb29fbGFzdF9pZCIsImNhbWxfZnJlc2hfb29faWQiLCJjYW1sX2pzc3RyaW5nX29mX3N0cmluZyIsImZzX25vZGVfc3VwcG9ydGVkIiwibWFrZV9wYXRoX2lzX2Fic29sdXRlIiwicG9zaXgiLCJwYXRoIiwid2luMzIiLCJzcGxpdERldmljZVJlIiwicmVzdWx0IiwiZGV2aWNlIiwiaXNVbmMiLCJCb29sZWFuIiwicm9vdCIsInNlcCIsInBhdGhfaXNfYWJzb2x1dGUiLCJjYW1sX3RyYWlsaW5nX3NsYXNoIiwiY2FtbF9jdXJyZW50X2RpciIsImNhbWxfbWFrZV9wYXRoIiwiY29tcDAiLCJuY29tcCIsImNhbWxfdXRmOF9vZl91dGYxNiIsImNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmciLCJjYW1sX3N0cmluZ19vZl9qc3N0cmluZyIsInVuaXhfZXJyb3IiLCJtYWtlX3VuaXhfZXJyX2FyZ3MiLCJjb2RlIiwic3lzY2FsbCIsImVycm5vIiwidmFyaWFudCIsImNhbWxfbmFtZWRfdmFsdWVzIiwiY2FtbF9uYW1lZF92YWx1ZSIsIm5tIiwiY2FtbF9yYWlzZV93aXRoX2FyZ3MiLCJjYW1sX2J5dGVzX29mX2FycmF5IiwiY2FtbF9yYWlzZV9zeXNfZXJyb3IiLCJjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSIsImNhbWxfbWxfYnl0ZXNfbGVuZ3RoIiwiTWxGaWxlIiwiTWxGYWtlRmlsZSIsIm9sZCIsImJ1ZiIsInBvcyIsImNsZW4iLCJuZXdfc3RyIiwib2xkX2RhdGEiLCJNbEZha2VEZXZpY2UiLCJTeW1ib2wiLCJuYW1lX3NsYXNoIiwibW9kZSIsInJhaXNlX3VuaXgiLCJwYXJlbnQiLCJSZWdFeHAiLCJzZWVuIiwib2siLCJmaWxlIiwiYnl0ZXMiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX3N0cmluZ191bnNhZmVfZ2V0IiwiY2FtbF9hcnJheV9vZl9zdHJpbmciLCJjYW1sX2FycmF5X29mX2J5dGVzIiwiTWxOb2RlRmlsZSIsImZkIiwicmVxdWlyZSIsImVyciIsImJ1Zl9vZmZzZXQiLCJNbE5vZGVEZXZpY2UiLCJjb25zdHMiLCJrZXkiLCJvIiwianNfc3RhdHMiLCJ0b19kaXIiLCJ0YXJnZXQiLCJsaW5rIiwiZmlsZV9raW5kIiwiY2FtbF9nZXRfcm9vdCIsImNhbWxfcm9vdCIsImpzb29fbW91bnRfcG9pbnQiLCJyZXNvbHZlX2ZzX2RldmljZSIsImNhbWxfY3JlYXRlX2ZpbGUiLCJqc29vX2NyZWF0ZV9maWxlIiwiY2FtbF9mc19pbml0IiwidG1wIiwiY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UiLCJjYW1sX21ldGhvZF9jYWNoZSIsImNhbWxfZ2V0X3B1YmxpY19tZXRob2QiLCJvYmoiLCJjYWNoZWlkIiwibWV0aHMiLCJ1bmRlZmluZWQiLCJsaSIsImNhbWxfZ3JlYXRlcmVxdWFsIiwiY2FtbF9oYXNoX21peF9qc2J5dGVzIiwiY2FtbF9oYXNoX21peF9zdHJpbmciLCJjYW1sX2hhc2hfbWl4X2J5dGVzX2FyciIsImNhbWxfbWxfYnl0ZXNfY29udGVudCIsImNhbWxfaGFzaF9taXhfYnl0ZXMiLCJjYW1sX2hhc2hfbWl4X2ZpbmFsIiwiY2FtbF9oYXNoIiwiY291bnQiLCJsaW1pdCIsInNlZWQiLCJxdWV1ZSIsInJkIiwid3IiLCJoaCIsImNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0Iiwic3R5bGUiLCJleHBfc2lnbiIsInNpZ25fc3RyIiwiY3N0IiwieF9zdHIiLCJpZHgiLCJjYW1sX2ludDY0X2FkZCIsImNhbWxfaW50NjRfYW5kIiwiY2FtbF9pbnQ2NF9kaXYiLCJjYW1sX2ludDY0X2lzX3plcm8iLCJjYW1sX2ludDY0X29mX2ludDMyIiwiY2FtbF9pbnQ2NF90b19pbnQzMiIsImNhbWxfaW50NjRfaXNfbmVnYXRpdmUiLCJjYW1sX2ludDY0X25lZyIsImNhbWxfaW50NjRfZm9ybWF0Iiwid2Jhc2UiLCJjdnRibCIsImNhbWxfaW50NjRfbW9kIiwiY2FtbF9pbnQ2NF9tdWwiLCJjYW1sX2ludDY0X29mX2Zsb2F0IiwiY2FtbF9pbnQ2NF91bHQiLCJjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UiLCJiYXNlIiwiY2FtbF9wYXJzZV9kaWdpdCIsImNhbWxfaW50NjRfb2Zfc3RyaW5nIiwiYmFzZTY0IiwidGhyZXNob2xkIiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCIsImNhbWxfaW50NjRfc3ViIiwiY2FtbF9pbnQ2NF90b19mbG9hdCIsImNhbWxfaW50X29mX3N0cmluZyIsImNhbWxfanNfZnJvbV9hcnJheSIsImNhbWxfanNfZ2V0X2NvbnNvbGUiLCJjYW1sX2pzX29iamVjdCIsImNhbWxfanNfdG9fYXJyYXkiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayIsImNhbWxfbGVzc2VxdWFsIiwiY2FtbF9sZXNzdGhhbiIsImNhbWxfbGV4X2FycmF5IiwiY2FtbF9sZXhfZW5naW5lIiwidGJsIiwic3RhcnRfc3RhdGUiLCJsZXhidWYiLCJsZXhfYnVmZmVyIiwibGV4X2J1ZmZlcl9sZW4iLCJsZXhfc3RhcnRfcG9zIiwibGV4X2N1cnJfcG9zIiwibGV4X2xhc3RfcG9zIiwibGV4X2xhc3RfYWN0aW9uIiwibGV4X2VvZl9yZWFjaGVkIiwibGV4X2Jhc2UiLCJsZXhfYmFja3RyayIsImxleF9kZWZhdWx0IiwibGV4X3RyYW5zIiwibGV4X2NoZWNrIiwic3RhdGUiLCJiYWNrdHJrIiwiY2FtbF9tYWtlX3ZlY3QiLCJpbml0IiwiY2FtbF9zdHJpbmdfb2ZfYXJyYXkiLCJjYW1sX21kNV9ieXRlcyIsImFkZCIsInh4IiwiZmYiLCJnZyIsImlpIiwibWQ1IiwiY2FtbF9tZDVfc3RyaW5nIiwiY2FtbF9zeXNfY2xvc2UiLCJjYW1sX21sX2NoYW5uZWxzIiwiY2FtbF9tbF9mbHVzaCIsImNoYW5pZCIsImNoYW4iLCJvdXRwdXQiLCJjYW1sX21sX2Nsb3NlX2NoYW5uZWwiLCJjYW1sX21sX2RlYnVnX2luZm9fc3RhdHVzIiwiY2FtbF9tbF9yZWZpbGxfaW5wdXQiLCJzdHIiLCJzdHJfbGVuIiwiY2FtbF9tbF9pbnB1dCIsImwyIiwiY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0IiwiY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSIsImNhbWxfbWxfaW5wdXRfY2hhciIsImNhbWxfc3RkX291dHB1dCIsInNsZW4iLCJqc19wcmludF9zdGRlcnIiLCJqc19wcmludF9zdGRvdXQiLCJjYW1sX3N5c19vcGVuX2ludGVybmFsIiwiZmxhZ3MiLCJpbmZvIiwiY2FtbF9zeXNfb3BlbiIsIl9wZXJtcyIsImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luIiwicmVmaWxsIiwiZnMiLCJjaGFubmVsIiwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0IiwiY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdCIsImNhbWxfc3RyaW5nX29mX2J5dGVzIiwiY2FtbF9tbF9vdXRwdXRfYnl0ZXMiLCJzdHJpbmciLCJqc3N0cmluZyIsImlkIiwiY2FtbF9tbF9vdXRwdXQiLCJjYW1sX21sX291dHB1dF9jaGFyIiwiY2FtbF9tb2QiLCJjYW1sX25vdGVxdWFsIiwiY2FtbF9vYmpfYmxvY2siLCJjYW1sX29ial9tYWtlX2ZvcndhcmQiLCJjYW1sX29ial90YWciLCJGdW5jdGlvbiIsImNhbWxfcmVnaXN0ZXJfZ2xvYmFsIiwibmFtZV9vcHQiLCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlIiwiY2FtbF9zZXRfb29faWQiLCJjYW1sX2J5dGVzX2VxdWFsIiwiY2FtbF9zdHJpbmdfZXF1YWwiLCJjYW1sX3N0cmluZ19ib3VuZF9lcnJvciIsImNhbWxfc3RyaW5nX2dldCIsImNhbWxfc3RyaW5nX25vdGVxdWFsIiwiY2FtbF9hcmd2IiwibWFpbiIsImFyZ3YiLCJhcmdzMiIsImNhbWxfc3lzX2FyZ3YiLCJjYW1sX3N5c19jb25zdF9tYXhfd29zaXplIiwiY2FtbF9zeXNfZXhpdCIsIm9zX3R5cGUiLCJjYW1sX3N5c19nZXRfY29uZmlnIiwiY2FtbF9yYWlzZV9ub3RfZm91bmQiLCJjYW1sX3N5c19nZXRlbnYiLCJjYW1sX3N5c19yYW5kb21fc2VlZCIsImJ1ZmYiLCJub3ciLCJEYXRlIiwiY2FtbF90cmFtcG9saW5lIiwiY2FtbF90cmFtcG9saW5lX3JldHVybiIsImNhbWxfdXBkYXRlX2R1bW15IiwiY2FtbF93ZWFrX2JsaXQiLCJjYW1sX3dlYWtfY2hlY2siLCJjYW1sX3dlYWtfY3JlYXRlIiwiY2FtbF93ZWFrX2dldCIsImNhbWxfb2JqX2R1cCIsImNhbWxfd2Vha19nZXRfY29weSIsInoiLCJjYW1sX3JldHVybl9leG5fY29uc3RhbnQiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiTWxOYXQiLCJjcmVhdGVfbmF0IiwiYXJyIiwiaW5jcl9uYXQiLCJuYXQiLCJjYXJyeV9pbiIsImNhcnJ5Iiwic2VyaWFsaXplX25hdCIsImRlc2VyaWFsaXplX25hdCIsIm51bV9kaWdpdHNfbmF0IiwiY2FtbF9oYXNoX25hdCIsImluaXRpYWxpemVfbmF0Iiwic2V0X2RpZ2l0X25hdCIsImRpZ2l0Iiwic2V0X3RvX3plcm9fbmF0IiwidW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nIiwiY2FtbF9pc19zcGVjaWFsX2V4Y2VwdGlvbiIsImV4biIsImNhbWxfZm9ybWF0X2V4Y2VwdGlvbiIsImJ1Y2tldCIsInN0YXJ0IiwiY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb24iLCJoYW5kbGVyIiwiYXRfZXhpdCIsImNhbWxfc2V0dXBfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIiLCJvcmlnaW4iLCJldmVudCIsInplcm9fcG9zIiwic3ViX2Zvcm1hdCIsImZvcm1hdHRpbmdfbGl0IiwibG9jZm10IiwiY2FueSIsImVwc19leHByIiwiZHVtbXkkMyIsInplcm8kMyIsInYkMCIsImRlZmF1bHRfcmVkdWN0aW9uIiwiZXJyb3IiLCJhY3Rpb24iLCJsaHMiLCJnb3RvJDAiLCJscjBfaW5jb21pbmciLCJyaHMiLCJscjBfY29yZSIsImxyMF9pdGVtcyIsIm51bGxhYmxlIiwiZmlyc3QkMCIsImtleXdvcmRzIiwib2NhbWxfbGV4X3RhYmxlcyIsImVyYXNlX3JlbCIsInJlc3QiLCJyZXN0JDAiLCJyZXN0JDEiLCJyZXN0JDIiLCJyZXN0JDMiLCJyZXN0JDQiLCJyZXN0JDUiLCJyZXN0JDYiLCJyZXN0JDciLCJ0eSIsInJlc3QkOCIsInR5MSIsInJlc3QkOSIsInJlc3QkMTAiLCJyZXN0JDExIiwicmVzdCQxMiIsInJlc3QkMTMiLCJjb25jYXRfZm10dHkiLCJmbXR0eTEiLCJmbXR0eTIiLCJ0eTIiLCJjb25jYXRfZm10IiwiZm10MSIsImZtdDIiLCJwYWQiLCJwYWQkMCIsInBhZCQxIiwiaWNvbnYiLCJwcmVjJDAiLCJwYWQkMiIsImljb252JDAiLCJwcmVjJDEiLCJwYWQkMyIsImljb252JDEiLCJwcmVjJDIiLCJwYWQkNCIsImljb252JDIiLCJwcmVjJDMiLCJwYWQkNSIsImZjb252IiwicGFkJDYiLCJjaHIiLCJmbXR0eSIsInBhZCQ3IiwiZm10dHkkMCIsInBhZCQ4IiwicmVzdCQxNCIsInJlc3QkMTUiLCJyZXN0JDE2IiwiZm10aW5nX2xpdCIsInJlc3QkMTciLCJmbXRpbmdfZ2VuIiwicmVzdCQxOCIsInJlc3QkMTkiLCJjaGFyX3NldCIsIndpZHRoX29wdCIsInJlc3QkMjAiLCJjb3VudGVyIiwicmVzdCQyMSIsInJlc3QkMjIiLCJpZ24iLCJyZXN0JDIzIiwiYXJpdHkiLCJjdXIiLCJmYWlsd2l0aCIsImludmFsaWRfYXJnIiwibWluIiwibWF4IiwibG5vdCIsImwxIiwiY2hhcl9vZl9pbnQiLCJzdHJpbmdfb2ZfYm9vbCIsInZhbGlkX2Zsb2F0X2xleGVtIiwibG9vcCIsImkkMCIsImkkMSIsImFwcGVuZCIsInRsIiwiaGQiLCJzdGRpbiIsInN0ZG91dCIsInN0ZGVyciIsImZsdXNoX2FsbCIsIml0ZXIiLCJvdXRwdXRfc3RyaW5nIiwib2MiLCJvdXRwdXRfc3Vic3RyaW5nIiwiY2xvc2Vfb3V0IiwiaW5wdXQiLCJpYyIsInByZXJyX2NoYXIiLCJwcmVycl9zdHJpbmciLCJwcmVycl9lbmRsaW5lIiwiZXhpdF9mdW5jdGlvbiIsImZfeWV0X3RvX3J1biIsIm9sZF9leGl0IiwibmV3X2V4aXQkMCIsIm5ld19leGl0Iiwic3VjY2VzcyIsImRvX2F0X2V4aXQiLCJleGl0IiwicmV0Y29kZSIsImNsb3NlX2luIiwiaW5wdXRfY2hhciIsIm91dHB1dF9jaGFyIiwiZmx1c2giLCJpc19ibG9jayIsIm1heF9lcGhlX2xlbmd0aCIsInJhaXNlX3VuZGVmaW5lZCIsImZvcmNlX2xhenlfYmxvY2siLCJibGsiLCJjbG9zdXJlIiwibWFwIiwic2VxIiwibmV4dCIsImZvbGRfbGVmdCIsImFjYyIsImFjYyQwIiwic2VxJDAiLCJhY2MkMSIsInMkMCIsImxlbmd0aF9hdXgiLCJwYXJhbSQxIiwibnRoX29wdCIsIm50aF9hdXgiLCJsJDAiLCJuJDAiLCJsJDEiLCJuJDEiLCJyZXZfYXBwZW5kIiwibDEkMCIsImwyJDAiLCJsMSQxIiwibDIkMSIsInJldiIsIm1hcCQwIiwicm1hcF9mIiwiZm9sZCIsImFjY3UiLCJhY2N1JDAiLCJhY2N1JDEiLCJwYWlyIiwiZmluZCIsImF1eCIsInhzIiwiY21wIiwicmV2X21lcmdlIiwidDIiLCJoMiIsInQxIiwiaDEiLCJhY2N1JDIiLCJhY2N1JDMiLCJyZXZfbWVyZ2VfcmV2IiwicmV2X3NvcnQiLCJ4MiIsIngxIiwidGwkMSIsIngzIiwieDIkMCIsIngxJDAiLCJjJDAiLCJjJDEiLCJjJDIiLCJjJDMiLCJjJDQiLCJjJDUiLCJuMSIsIm4yIiwic29ydCIsInRsJDAiLCJtaW4kMCIsIm1heCQwIiwidG9fc3RyaW5nJDEiLCJvZnMxIiwib2ZzMiIsImVuc3VyZV9nZSIsInN1bV9sZW5ndGhzIiwic2VwbGVuIiwidW5zYWZlX2JsaXRzIiwiZHN0IiwiZXNjYXBlX2lmX25lZWRlZCIsImluZGV4X3JlYyIsImxpbSIsImNvbXBhcmUkMCIsInRvbGlzdCIsInJlcyQwIiwicmVzJDEiLCJsaXN0X2xlbmd0aCIsImZpbGwiLCJtYXhzb24iLCJpMzEiLCJ0cmlja2xlZG93biIsInRyaWNrbGUiLCJidWJibGVkb3duIiwiYnViYmxlIiwidHJpY2tsZXVwIiwiZmF0aGVyIiwiZSQwIiwiemVybyIsIm9uZSIsInN1Y2MiLCJwcmVkIiwiYWJzJDAiLCJvcHQiLCJzdGgiLCJ3aXRoX3Bvc2l0aW9ucyIsImxjcCIsImhlaWdodCIsImNyZWF0ZSIsImhsIiwiaCQwIiwiaHIiLCJiYWwiLCJsciIsImx2IiwibGwiLCJscnIiLCJscnYiLCJscmwiLCJyciIsInJ2IiwicmwiLCJybHIiLCJybHYiLCJybGwiLCJzaW5nbGV0b24iLCJhZGRfbWluX2VsZW1lbnQiLCJhZGRfbWF4X2VsZW1lbnQiLCJqb2luIiwicmgiLCJsaCIsIm1pbl9lbHQiLCJtaW5fZWx0X29wdCIsIm1heF9lbHQiLCJtYXhfZWx0X29wdCIsInJlbW92ZV9taW5fZWx0IiwiciQwIiwibWVyZ2UiLCJjb25jYXQiLCJzcGxpdCIsInByZXMiLCJwcmVzJDAiLCJlbXB0eSIsImlzX2VtcHR5IiwibWVtIiwicmVtb3ZlIiwidW5pb24iLCJ2MiIsInYxIiwicjIkMCIsInIxJDAiLCJpbnRlciIsInNwbGl0X2JpcyIsImRpc2pvaW50IiwiczEkMCIsInMyJDAiLCJzMiQxIiwiZGlmZiIsImNvbnNfZW51bSIsInMkMSIsImUkMSIsImNvbXBhcmVfYXV4IiwiZTEiLCJlMiIsImUxJDAiLCJlMiQwIiwiZTIkMSIsImUxJDEiLCJlMiQyIiwiZTEkMiIsImNvbXBhcmUiLCJlcXVhbCIsInN1YnNldCIsImZvcl9hbGwiLCJleGlzdHMiLCJmaWx0ZXIiLCJwdiIsInBhcnRpdGlvbiIsImxmIiwibHQiLCJyZiIsInJ0IiwiY2FyZGluYWwiLCJlbGVtZW50c19hdXgiLCJlbGVtZW50cyIsImZpbmRfZmlyc3RfYXV4IiwiZmluZF9maXJzdCIsImZpbmRfZmlyc3Rfb3B0X2F1eCIsImZpbmRfZmlyc3Rfb3B0IiwiZmluZF9sYXN0X2F1eCIsImZpbmRfbGFzdCIsImZpbmRfbGFzdF9vcHRfYXV4IiwiZmluZF9sYXN0X29wdCIsImZpbmRfb3B0IiwidHJ5X2pvaW4iLCJ0cnlfY29uY2F0IiwiZmlsdGVyX21hcCIsInYkMSIsIm9mX3NvcnRlZF9saXN0Iiwic3ViIiwibCQzIiwieDAiLCJsJDQiLCJ4MCQwIiwibCQ1IiwieDAkMSIsIm5sIiwibGVmdCIsIm1pZCIsImwkMiIsInJpZ2h0Iiwib2ZfbGlzdCIsIng0IiwiYWRkX3NlcSIsIm9mX3NlcSIsInNlcV9vZl9lbnVtIiwidG9fc2VxIiwic25vY19lbnVtIiwicmV2X3NlcV9vZl9lbnVtIiwidG9fcmV2X3NlcSIsInRvX3NlcV9mcm9tIiwibG93IiwibGQiLCJscmQiLCJybGQiLCJtaW5fYmluZGluZyIsIm1pbl9iaW5kaW5nX29wdCIsIm1heF9iaW5kaW5nIiwibWF4X2JpbmRpbmdfb3B0IiwicmVtb3ZlX21pbl9iaW5kaW5nIiwidXBkYXRlIiwiZGF0YSQwIiwiZCQwIiwibWFwaSIsIm0kMCIsImFkZF9taW5fYmluZGluZyIsImFkZF9tYXhfYmluZGluZyIsImNvbmNhdF9vcl9qb2luIiwiZDEiLCJkMiIsImQyJDAiLCJkMSQwIiwiZDIkMSIsImQxJDEiLCJwdmQiLCJmdmQiLCJtJDEiLCJtMSIsIm0yIiwiZXF1YWxfYXV4IiwiYmluZGluZ3NfYXV4IiwiYmluZGluZ3MiLCJjbGVhciIsInB1c2giLCJwb3AiLCJwb3Bfb3B0IiwidG9wIiwidG9wX29wdCIsIml0ZXIkMyIsImNyZWF0ZSQwIiwiY2xlYXIkMCIsImNlbGwiLCJwZWVrX29wdCIsInRha2UiLCJ0YWtlX29wdCIsImlzX2VtcHR5JDAiLCJyZXNpemUiLCJtb3JlIiwib2xkX3BvcyIsIm9sZF9sZW4iLCJuZXdfbGVuIiwibmV3X2J1ZmZlciIsIm5ld19wb3NpdGlvbiIsImNyZWF0ZV9jaGFyX3NldCIsImFkZF9pbl9jaGFyX3NldCIsInN0cl9pbmQiLCJtYXNrIiwiZnJlZXplX2NoYXJfc2V0IiwicmV2X2NoYXJfc2V0IiwiY2hhcl9zZXQkMCIsImlzX2luX2NoYXJfc2V0IiwicGFkX29mX3BhZF9vcHQiLCJwYWRfb3B0Iiwid2lkdGgiLCJwcmVjX29mX3ByZWNfb3B0IiwicHJlY19vcHQiLCJuZGVjIiwicGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IiwicGFkX29wdCQwIiwicGFkX29wdCQxIiwicGFkX29wdCQyIiwicGFkX29wdCQzIiwicGFkX29wdCQ0IiwicGFkX29wdCQ1IiwicGFkX29wdCQ2IiwicGFkX29wdCQ3IiwicGFkX29wdCQ4IiwiZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24iLCJidWZmZXJfY3JlYXRlIiwiaW5pdF9zaXplIiwiYnVmZmVyX2NoZWNrX3NpemUiLCJvdmVyaGVhZCIsIm1pbl9sZW4iLCJidWZmZXJfYWRkX2NoYXIiLCJidWZmZXJfYWRkX3N0cmluZyIsImJ1ZmZlcl9jb250ZW50cyIsImNoYXJfb2ZfaWNvbnYiLCJjaGFyX29mX2Zjb252IiwiY0YiLCJicHJpbnRfZmNvbnZfZmxhZyIsInN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCIsInN0ciQwIiwiYnByaW50X2ZtdHR5Iiwic3ViX2ZtdHR5Iiwic3ViX2ZtdHR5JDAiLCJzeW1tIiwidHJhbnMiLCJyZXN0MiIsInJlc3QyJDAiLCJyZXN0MiQxIiwicmVzdDIkMiIsInJlc3QyJDMiLCJyZXN0MiQ0IiwicmVzdDIkNSIsInJlc3QyJDYiLCJyZXN0MiQ3IiwidHkyJDAiLCJyZXN0MiQ4IiwidHkyMiIsInR5MjEiLCJmbXR0eV9yZWxfZGV0IiwiZjQiLCJmMiIsInJlc3QyJDkiLCJyZXN0MiQxMCIsInJlc3QyJDExIiwicmVzdDIkMTIiLCJyZXN0MiQxMyIsImRlIiwiZWQiLCJhZiIsImZhIiwiZGUkMCIsImVkJDAiLCJhZiQwIiwiZmEkMCIsImRlJDEiLCJlZCQxIiwiYWYkMSIsImZhJDEiLCJkZSQyIiwiZWQkMiIsImFmJDIiLCJmYSQyIiwiZGUkMyIsImVkJDMiLCJhZiQzIiwiZmEkMyIsImRlJDQiLCJlZCQ0IiwiYWYkNCIsImZhJDQiLCJkZSQ1IiwiZWQkNSIsImFmJDUiLCJmYSQ1IiwiZGUkNiIsImVkJDYiLCJhZiQ2IiwiZmEkNiIsImRlJDciLCJlZCQ3IiwiYWYkNyIsImZhJDciLCJkZSQ4IiwiZWQkOCIsImFmJDgiLCJmYSQ4IiwiamQiLCJkaiIsImdhIiwiYWciLCJkZSQ5IiwiZWQkOSIsImFmJDkiLCJmYSQ5IiwiZGUkMTAiLCJlZCQxMCIsImFmJDEwIiwiZmEkMTAiLCJkZSQxMSIsImVkJDExIiwiYWYkMTEiLCJmYSQxMSIsImRlJDEyIiwiZWQkMTIiLCJhZiQxMiIsImZhJDEyIiwiZGUkMTMiLCJlZCQxMyIsImFmJDEzIiwiZmEkMTMiLCJmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkiLCJmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IiwiZm10dHlfb2ZfY3VzdG9tIiwiYXJpdHkkMCIsImZtdHR5X29mX2ZtdCQwIiwiZm10dHlfb2ZfZm10IiwidHlfcmVzdCIsInByZWNfdHkiLCJ0eV9yZXN0JDAiLCJwcmVjX3R5JDAiLCJ0eV9yZXN0JDEiLCJwcmVjX3R5JDEiLCJ0eV9yZXN0JDIiLCJwcmVjX3R5JDIiLCJ0eV9yZXN0JDMiLCJwcmVjX3R5JDMiLCJmbXR0eSQxIiwiZm10dHkkMiIsImZtdHR5JDMiLCJ0eSQwIiwiZm10dHkkNCIsImZtdHR5X29mX2Zvcm1hdHRpbmdfZ2VuIiwiZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQiLCJmb3JtYXR0aW5nX2dlbiIsImZtdCQwIiwidHlwZV9wYWRkaW5nIiwicGFkdHkiLCJwYWR0eSQwIiwidHlwZV9wYWRwcmVjIiwidHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpIiwidHlwZV9mb3JtYXRfZ2VuIiwiZm10dHlfcmVzdCIsInN1Yl9mbXR0eV9yZXN0Iiwic3ViX2ZtdHR5X3Jlc3QkMCIsImZtdHR5X3Jlc3QkMCIsInN1Yl9mbXR0eV9yZXN0JDEiLCJmbXQkMSIsInN1Yl9mbXR0eV9yZXN0JDIiLCJmbXR0eV9yZXN0JDEiLCJzdWJfZm10dHlfcmVzdCQzIiwiZm10JDIiLCJzdWJfZm10dHlfcmVzdCQ0IiwiZm10dHlfcmVzdCQyIiwic3ViX2ZtdHR5X3Jlc3QkNSIsImZtdCQzIiwic3ViX2ZtdHR5X3Jlc3QkNiIsImZtdHR5X3Jlc3QkMyIsInN1Yl9mbXR0eV9yZXN0JDciLCJmbXQkNCIsInN1Yl9mbXR0eV9yZXN0JDgiLCJmbXR0eV9yZXN0JDQiLCJzdWJfZm10dHlfcmVzdCQ5IiwiZm10JDUiLCJzdWJfZm10dHlfcmVzdCQxMCIsImZtdHR5X3Jlc3QkNSIsInN1Yl9mbXR0eV9yZXN0JDExIiwiZm10JDYiLCJzdWJfZm10dHlfcmVzdCQxMiIsImZtdHR5X3Jlc3QkNiIsInN1Yl9mbXR0eV9yZXN0JDEzIiwiZm10JDciLCJzdWJfZm10dHlfcmVzdCQxNCIsImZtdHR5X3Jlc3QkNyIsInN1YjJfZm10dHkiLCJzdWJfZm10dHlfcmVzdCQxNSIsInN1YjJfZm10dHkkMCIsImZtdCQ4Iiwic3ViX2ZtdHR5X3Jlc3QkMTYiLCJmbXR0eV9yZXN0JDgiLCJzdWIyX2ZtdHR5JDEiLCJzdWIxX2ZtdHR5Iiwic3ViX2ZtdHR5X3Jlc3QkMTciLCJzdWIyX2ZtdHR5JDIiLCJzdWIxX2ZtdHR5JDAiLCJmbXQkOSIsInN1Yl9mbXR0eV9yZXN0JDE4IiwiZm10dHlfcmVzdCQ5Iiwic3ViX2ZtdHR5X3Jlc3QkMTkiLCJmbXQkMTAiLCJzdWJfZm10dHlfcmVzdCQyMCIsImZtdHR5X3Jlc3QkMTAiLCJzdWJfZm10dHlfcmVzdCQyMSIsImZtdCQxMSIsInN1Yl9mbXR0eV9yZXN0JDIyIiwiZm10dHlfcmVzdCQxMSIsInN1Yl9mbXR0eV9yZXN0JDIzIiwiZm10JDEyIiwic3ViX2ZtdHR5X3Jlc3QkMjQiLCJmbXR0eV9yZXN0JDEyIiwic3ViX2ZtdHR5X3Jlc3QkMjUiLCJmbXQkMTMiLCJzdWJfZm10dHlfcmVzdCQyNiIsImZtdF9yZXN0IiwiZm10X3Jlc3QkMCIsImZtdF9yZXN0JDEiLCJmbXRfcmVzdCQyIiwiZm10X3Jlc3QkMyIsImZtdF9yZXN0JDQiLCJmbXR0eSQ1IiwiZm10X3Jlc3QkNSIsInByZWMkNCIsImZtdHR5JDYiLCJmbXRfcmVzdCQ2IiwicHJlYyQ1IiwicHJlYyQ2IiwiZm10dHkkNyIsImZtdF9yZXN0JDciLCJwcmVjJDciLCJwcmVjJDgiLCJmbXR0eSQ4IiwiZm10X3Jlc3QkOCIsImZtdHR5JDkiLCJmbXRfcmVzdCQ5IiwiZm10dHkkMTAiLCJmbXRfcmVzdCQxMCIsImZtdHR5JDExIiwiZm10X3Jlc3QkMTEiLCJmbXR0eSQxMiIsImZtdF9yZXN0JDEyIiwiZm10dHkkMTMiLCJzdWJfZm10dHkxIiwiZm10X3Jlc3QkMTMiLCJzdWJfZm10dHkkMSIsImZtdHR5JDE0IiwiZm10JDE0IiwiZm10X3Jlc3QkMTQiLCJmbXR0eSQxNSIsImZtdCQxNSIsImZtdF9yZXN0JDE1IiwiZm10dHkkMTYiLCJmbXQkMTYiLCJmbXRfcmVzdCQxNiIsImZtdHR5JDE3IiwiZm10JDE3IiwiZm10X3Jlc3QkMTciLCJ0eXBlX2Zvcm1hdHRpbmdfZ2VuIiwiZm10dHlfcmVzdCQxMyIsImZtdF9yZXN0JDE4IiwiZm10dHkkMTgiLCJmbXQkMTgiLCJmbXR0eV9yZXN0JDE0IiwiZm10X3Jlc3QkMTkiLCJmbXR0eSQxOSIsImZtdCQxOSIsImZtdHR5X3Jlc3QkMTUiLCJmbXRfcmVzdCQyMCIsImZtdHR5JDIwIiwiZm10JDIwIiwidHlwZV9pZ25vcmVkX3BhcmFtIiwiZm10MCIsImZtdHR5MCIsImZtdHR5MyIsImZtdDMiLCJmbXQxJDAiLCJmbXR0eTIkMCIsImZtdDIkMCIsImZtdHR5MyQwIiwiZm10MyQwIiwidHlwZV9pZ25vcmVkX3BhcmFtX29uZSIsInR5cGVfZm9ybWF0IiwicmVjYXN0IiwiZml4X3BhZGRpbmciLCJ3aWR0aCQwIiwiZml4X2ludF9wcmVjaXNpb24iLCJzdHJpbmdfdG9fY2FtbF9zdHJpbmciLCJmb3JtYXRfb2ZfaWNvbnYiLCJmb3JtYXRfb2ZfaWNvbnZMIiwiZm9ybWF0X29mX2ljb252bCIsImZvcm1hdF9vZl9pY29udm4iLCJmb3JtYXRfb2ZfZmNvbnYiLCJzeW1iIiwidHJhbnNmb3JtX2ludF9hbHQiLCJkaWdpdHMiLCJwdXQiLCJjb252ZXJ0X2ludCIsImNvbnZlcnRfaW50MzIiLCJjb252ZXJ0X25hdGl2ZWludCIsImNvbnZlcnRfaW50NjQiLCJjb252ZXJ0X2Zsb2F0IiwiaGV4IiwiYWRkX2RvdF9pZl9uZWVkZWQiLCJpc192YWxpZCIsImNhbWxfc3BlY2lhbF92YWwiLCJmb3JtYXRfY2FtbF9jaGFyIiwic3RyaW5nX29mX2ZtdHR5IiwibWFrZV9wcmludGYkMCIsImskMCIsIm5ld19hY2MiLCJtYWtlX3ByaW50ZiIsIm1ha2VfcGFkZGluZyIsIm1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIiwibWFrZV9mbG9hdF9wYWRkaW5nX3ByZWNpc2lvbiIsImFjYyQyIiwiYWNjJDMiLCJhY2MkNCIsImskMyIsImthY2MiLCJrJDEiLCJrJDQiLCJrJDIiLCJtYWtlX2lnbm9yZWRfcGFyYW0iLCJtYWtlX2N1c3RvbSQwIiwibWFrZV9pbnZhbGlkX2FyZyIsIm1ha2VfZnJvbV9mbXR0eSQwIiwibWFrZV9mcm9tX2ZtdHR5IiwibWFrZV9jdXN0b20iLCJwJDAiLCJwJDEiLCJvdXRwdXRfYWNjIiwicCQyIiwicCQzIiwicCQ0Iiwic3RycHV0X2FjYyIsImZhaWx3aXRoX21lc3NhZ2UiLCJvcGVuX2JveF9vZl9zdHJpbmciLCJpbnZhbGlkX2JveCIsInBhcnNlX3NwYWNlcyIsInBhcnNlX2x3b3JkIiwiaiQwIiwiaiQxIiwicGFyc2VfaW50Iiwid3N0YXJ0Iiwid2VuZCIsImJveF9uYW1lIiwibnN0YXJ0IiwibmVuZCIsImluZGVudCIsImV4cF9lbmQiLCJib3hfdHlwZSIsIm1ha2VfcGFkZGluZ19mbXRfZWJiIiwibWFrZV9wcmVjaXNpb25fZm10X2ViYiIsIm1ha2VfcGFkcHJlY19mbXRfZWJiIiwiZm10X2ViYl9vZl9zdHJpbmciLCJsZWdhY3lfYmVoYXZpb3IiLCJmbGFnIiwibGVnYWN5X2JlaGF2aW9yJDAiLCJpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIiwidW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IiwiZW5kX2luZCIsImludmFsaWRfbm9ubnVsbF9jaGFyX3dpZHRoIiwiaW52YWxpZF9mb3JtYXRfd2l0aG91dCIsImV4cGVjdGVkX2NoYXJhY3RlciIsImV4cGVjdGVkIiwicmVhZCIsImFkZF9saXRlcmFsIiwibGl0X3N0YXJ0IiwicGFyc2VfcG9zaXRpdmUiLCJzdHJfaW5kJDAiLCJzdHJfaW5kJDEiLCJwYXJzZV9pbnRlZ2VyIiwibmV4dF9pbmQiLCJpbmNvbXBhdGlibGVfZmxhZyIsInBjdF9pbmQiLCJvcHRpb24iLCJzdWJmbXQiLCJjb21wdXRlX2Zsb2F0X2NvbnYiLCJwbHVzIiwiaGFzaCIsInNwYWNlIiwiY29tcHV0ZV9pbnRfY29udiIsInBsdXMkMCIsImhhc2gkMCIsInNwYWNlJDAiLCJjb3VudGVyX29mX2NoYXIiLCJpc19pbnRfYmFzZSIsInNlYXJjaF9zdWJmb3JtYXRfZW5kIiwic3ViX2VuZCIsInN0cl9pbmQkMiIsInN1Yl9lbmQkMCIsInN0cl9pbmQkMyIsInN1Yl9lbmQkMSIsInN0cl9pbmQkNCIsInN0cl9pbmQkNSIsInN1Yl9lbmQkMiIsInN0cl9pbmQkNiIsInN0cl9pbmQkNyIsInBhcnNlX2NoYXJfc2V0IiwiYWRkX2NoYXIiLCJhZGRfcmFuZ2UiLCJmYWlsX3NpbmdsZV9wZXJjZW50IiwicGFyc2VfY2hhcl9zZXRfY29udGVudCIsInBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIkMCIsInBhcnNlX2NoYXJfc2V0X2FmdGVyX21pbnVzIiwicGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciIsInBhcnNlX2NoYXJfc2V0X3N0YXJ0IiwicmV2ZXJzZSIsInJldmVyc2UkMCIsInBhcnNlX2FmdGVyX2F0IiwicGFyc2VfdGFnIiwicGFyc2UiLCJwYXJzZV9nb29kX2JyZWFrIiwicGFyc2VfbWFnaWNfc2l6ZSIsImlzX29wZW5fdGFnIiwiaW5kIiwic3ViX3N0ciIsInN1Yl9mbXQiLCJzdWJfZm9ybWF0JDAiLCJmb3JtYXR0aW5nJDAiLCJmb3JtYXR0aW5nIiwic3RyX2luZF8xIiwic3RyX2luZF8yIiwic3RyX2luZF8zIiwiZm9ybWF0dGluZ19saXQkMCIsInN0cl9pbmRfNCIsInN0cl9pbmRfNSIsInBhcnNlX3BhZGRpbmciLCJtaW51cyIsIm5ld19pbmQiLCJwYXJzZV9hZnRlcl9wYWRkaW5nIiwicGFyc2VfcHJlY2lzaW9uIiwicGFyc2VfY29udmVyc2lvbiIsInBhcnNlX2xpdGVyYWwiLCJwYXJzZV9hZnRlcl9wcmVjaXNpb24iLCJtaW51cyQwIiwicGFyc2VfY29udiIsInBhZHByZWMiLCJwbHVzX3VzZWQiLCJoYXNoX3VzZWQiLCJzcGFjZV91c2VkIiwiaWduX3VzZWQiLCJwYWRfdXNlZCIsInByZWNfdXNlZCIsImdldF9wbHVzIiwiZ2V0X2hhc2giLCJnZXRfc3BhY2UiLCJnZXRfaWduIiwiZ2V0X3BhZCIsImdldF9wcmVjIiwiZ2V0X3BhZHByZWMiLCJnZXRfaW50X3BhZCIsImNoZWNrX25vXzAiLCJvcHRfb2ZfcGFkIiwid2lkdGgkMSIsImdldF9wYWRfb3B0IiwiZ2V0X3BhZHByZWNfb3B0IiwiZ2V0X3ByZWNfb3B0IiwiZm10X3Jlc3VsdCIsImlnbm9yZWQkMiIsImNvdW50ZXIkMCIsImlnbm9yZWQkNiIsImlnbm9yZWQkNyIsImlnbm9yZWQkOSIsImNoYXJfZm9ybWF0Iiwic2Nhbl9mb3JtYXQiLCJmbXRfcmVzdCQyMSIsImZtdF9yZXN0JDIyIiwicGFkJDkiLCJmbXRfcmVzdCQyMyIsImlnbm9yZWQkMTAiLCJmbXRfcmVzdCQyNCIsInBhZCQxMCIsImZtdF9yZXN0JDI1Iiwic3ViX2ZtdCQwIiwiZm10X3Jlc3QkMjYiLCJpZ25vcmVkJDExIiwiaWdub3JlZCQzIiwiaWdub3JlZCQ1IiwiaWdub3JlZCQ4IiwiaWdub3JlZCQ0IiwiaWdub3JlZCIsImlnbm9yZWQkMCIsImlnbm9yZWQkMSIsInBsdXMkMSIsImlnbiQwIiwicGFyc2VfZm9ybWF0IiwicGFyc2VfaWduIiwicGFyc2VfZmxhZ3MiLCJzZXRfZmxhZyIsInJlYWRfZmxhZ3MiLCJiZWdfaW5kIiwiZm9ybWF0X29mX3N0cmluZ19mbXR0eSIsImtmcHJpbnRmIiwiZnByaW50ZiIsImVwcmludGYiLCJwcmludGVycyIsImZpZWxkIiwib3RoZXJfZmllbGRzIiwiZmllbGRzIiwidXNlX3ByaW50ZXJzIiwiY29udiIsInRvX3N0cmluZ19kZWZhdWx0IiwiY2hhciQwIiwibGluZSIsImNoYXIkMSIsImxpbmUkMCIsImZpbGUkMCIsImNoYXIkMiIsImxpbmUkMSIsImZpbGUkMSIsImNvbnN0cnVjdG9yIiwidG9fc3RyaW5nJDUiLCJjb252ZXJ0X3Jhd19iYWNrdHJhY2UiLCJidCIsImZvcm1hdF9iYWNrdHJhY2Vfc2xvdCIsInNsb3QiLCJpc19yYWlzZSIsInByaW50X2V4Y2VwdGlvbl9iYWNrdHJhY2UiLCJvdXRjaGFuIiwiYmFja3RyYWNlIiwicHJpbnRfcmF3X2JhY2t0cmFjZSIsInJhd19iYWNrdHJhY2UiLCJwcmludF9iYWNrdHJhY2UiLCJyZWdpc3Rlcl9wcmludGVyIiwiZm4iLCJvbGRfcHJpbnRlcnMiLCJuZXdfcHJpbnRlcnMiLCJlcnJvcnMiLCJkZWZhdWx0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW4iLCJzdGF0dXMiLCJlbXB0eV9iYWNrdHJhY2UiLCJ0cnlfZ2V0X3Jhd19iYWNrdHJhY2UiLCJoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uIiwiZGVidWdnZXJfaW5fdXNlIiwiZXhuJDAiLCJyYXdfYmFja3RyYWNlJDAiLCJoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uJDAiLCJuZXdfc3RhdGUiLCJmdWxsX2luaXQiLCJjb21iaW5lIiwiZXh0cmFjdCIsInNlZWQkMCIsIm1ha2UkMiIsIm1ha2Vfc2VsZl9pbml0IiwiYml0cyIsImN1cnZhbCIsIm5ld3ZhbCIsIm5ld3ZhbDMwIiwib25nb2luZ190cmF2ZXJzYWwiLCJmbGlwX29uZ29pbmdfdHJhdmVyc2FsIiwicGFyYW1zIiwicmFuZG9taXplZF9kZWZhdWx0IiwicHJuZyIsInBvd2VyXzJfYWJvdmUiLCJ4JDAiLCJ4JDEiLCJjcmVhdGUkMiIsImluaXRpYWxfc2l6ZSIsInJhbmRvbSIsImNsZWFyJDIiLCJyZXNldCQwIiwiY29weV9idWNrZXRsaXN0IiwiY29weSQwIiwibGVuZ3RoJDEiLCJpbnNlcnRfYWxsX2J1Y2tldHMiLCJpbmRleGZ1biIsImlucGxhY2UiLCJvZGF0YSIsIm5kYXRhIiwibnNpemUiLCJuZGF0YV90YWlsIiwiaW5zZXJ0X2J1Y2tldCIsImNlbGwkMSIsIm5pZHgiLCJtYXRjaCIsInJlc2l6ZSQwIiwib3NpemUiLCJpdGVyJDQiLCJkb19idWNrZXQiLCJvbGRfdHJhdiIsImZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQiLCJmaWx0ZXJfbWFwX2lucGxhY2UiLCJmb2xkJDAiLCJiJDAiLCJidWNrZXRfbGVuZ3RoIiwic3RhdHMiLCJtYmwiLCJoaXN0byIsInRibF9kYXRhIiwiYnVjayIsImJ1Y2skMCIsImJ1Y2skMSIsInRvX3NlcV9rZXlzIiwidG9fc2VxX3ZhbHVlcyIsImtleV9pbmRleCIsInJlbW92ZV9idWNrZXQiLCJmaW5kX3JlYyIsIm5leHQxIiwibmV4dDIiLCJrMyIsImQzIiwibmV4dDMiLCJmaW5kX3JlY19vcHQiLCJmaW5kX2FsbCIsImZpbmRfaW5fYnVja2V0IiwicmVwbGFjZV9idWNrZXQiLCJyZXBsYWNlIiwibWVtX2luX2J1Y2tldCIsInJlcGxhY2Vfc2VxIiwicmVzZXQiLCJjb3B5IiwiYWRkJDAiLCJ3ZWFrX2NyZWF0ZSIsImxlbmd0aCQyIiwicmFpc2VfaWZfaW52YWxpZF9vZmZzZXQiLCJzZXQiLCJnZXQkMCIsImdldF9jb3B5IiwiY2hlY2siLCJibGl0JDIiLCJvMSIsIm8yIiwiZW1wdHlidWNrZXQiLCJnZXRfaW5kZXgiLCJzeiQwIiwic3okMSIsImZvbGRfYnVja2V0IiwiaSQyIiwiaXRlcl9idWNrZXQiLCJpdGVyX3dlYWsiLCJjb3VudF9idWNrZXQiLCJuZXh0X3N6IiwicHJldl9zeiIsInRlc3Rfc2hyaW5rX2J1Y2tldCIsImhidWNrZXQiLCJwcmV2X2xlbiIsImxpdmUiLCJqJDIiLCJuZXdidWNrZXQiLCJhZGRfYXV4Iiwic2V0dGVyIiwiaGFzaGVzIiwibmV3c3oiLCJuZXdoYXNoZXMiLCJvbGRsZW4iLCJuZXdsZW4iLCJuZXd0IiwiYWRkX3dlYWsiLCJvYiIsIm9oIiwib2kiLCJuYiIsIm5pIiwiZmluZF9vciIsImlmbm90Zm91bmQiLCJpJDMiLCJmaW5kX3NoYWRvdyIsImlmZm91bmQiLCJpJDQiLCJsZW5zIiwidG90bGVuIiwidW5rbm93biIsImlzX2tub3duIiwicHBfZW5xdWV1ZSIsInRva2VuIiwicHBfY2xlYXJfcXVldWUiLCJwcF9pbmZpbml0eSIsInBwX291dHB1dF9zdHJpbmciLCJwcF9vdXRwdXRfbmV3bGluZSIsInBwX291dHB1dF9zcGFjZXMiLCJwcF9vdXRwdXRfaW5kZW50IiwiZm9ybWF0X3BwX3RleHQiLCJ0ZXh0IiwiZm9ybWF0X3N0cmluZyIsImJyZWFrX25ld19saW5lIiwiYWZ0ZXIiLCJiZWZvcmUiLCJyZWFsX2luZGVudCIsImJyZWFrX2xpbmUiLCJicmVha19zYW1lX2xpbmUiLCJwcF9mb3JjZV9icmVha19saW5lIiwicHBfc2tpcF90b2tlbiIsImZvcm1hdF9wcF90b2tlbiIsInRhYnMiLCJhZGRfdGFiIiwibHMiLCJ0YWdfbmFtZSIsIm1hcmtlciIsImJyZWFrcyIsImZpdHMiLCJvZmYiLCJvZmYkMCIsImluc2VydGlvbl9wb2ludCIsInRhYnMkMCIsImZpcnN0IiwidGFpbCIsImhlYWQiLCJ0YWIiLCJvZmYkMSIsImluc2VydGlvbl9wb2ludCQwIiwiYm94X3R5cGUkMCIsInRib3giLCJ0YWdfbmFtZSQwIiwibWFya2VyJDAiLCJhZHZhbmNlX2xlZnQiLCJwZW5kaW5nX2NvdW50Iiwic2l6ZSQwIiwiZW5xdWV1ZV9hZHZhbmNlIiwidG9rIiwiZW5xdWV1ZV9zdHJpbmdfYXMiLCJlbnF1ZXVlX3N0cmluZyIsImluaXRpYWxpemVfc2Nhbl9zdGFjayIsInF1ZXVlX2VsZW0iLCJzZXRfc2l6ZSIsImxlZnRfdG90YWwiLCJzY2FuX3B1c2giLCJlbGVtIiwicHBfb3Blbl9ib3hfZ2VuIiwiYnJfdHkiLCJwcF9vcGVuX3N5c19ib3giLCJwcF9yaW5pdCIsImNsZWFyX3RhZ19zdGFjayIsInBwX2ZsdXNoX3F1ZXVlIiwicHBfcHJpbnRfYXNfc2l6ZSIsImlzaXplIiwicHAiLCJkaXNwbGF5X25ld2xpbmUiLCJibGFua19saW5lIiwiZGlzcGxheV9pbmRlbnQiLCJkZWZhdWx0X3BwX21hcmtfb3Blbl90YWciLCJkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnIiwiZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZyIsImRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnIiwicHBfbWFrZV9mb3JtYXR0ZXIiLCJwcF9xdWV1ZSIsInN5c190b2siLCJzY2FuX3N0YWNrIiwicHBfbWFyZ2luIiwicHBfbWluX3NwYWNlX2xlZnQiLCJwcGYiLCJwcF9idWZmZXJfc2l6ZSIsInBwX21ha2VfYnVmZmVyIiwiZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciIsImxpc3QiLCJwcF92Iiwib3B0JDAiLCJwcF9zZXAiLCJ2cyIsIm9wdCQxIiwiY29tcHV0ZV90YWciLCJ0YWdfYWNjIiwib3V0cHV0X2Zvcm1hdHRpbmdfbGl0Iiwib3V0cHV0X2FjYyQwIiwiYnR5IiwiZiQwIiwicCQ1IiwicCQ2Iiwic3RycHV0X2FjYyQwIiwiZiQxIiwic2l6ZSQxIiwiZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVycyIsIm51bGxfY2hhciIsIm5leHRfY2hhciIsImliIiwicGVla19jaGFyIiwiY2hlY2tlZF9wZWVrX2NoYXIiLCJlbmRfb2ZfaW5wdXQiLCJlb2YiLCJjaGFyX2NvdW50IiwibGluZV9jb3VudCIsInJlc2V0X3Rva2VuIiwiaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIiLCJ0b2tlbl9zdHJpbmciLCJ0b2tlbl9idWZmZXIiLCJ0b2tlbl9jb3VudCIsInNraXBfY2hhciIsImlnbm9yZV9jaGFyIiwic3RvcmVfY2hhciIsImRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemUiLCJjcmVhdGUkMyIsImluYW1lIiwiZnJvbV9zdHJpbmckMCIsInNjYW5fcmFpc2VfYXRfZW5kIiwiZnJvbV9pYyIsInNjYW5fY2xvc2VfaWMiLCJiYWRfaW5wdXQiLCJiYWRfaW5wdXRfZXNjYXBlIiwiYmFkX3Rva2VuX2xlbmd0aCIsIm1lc3NhZ2UiLCJiYWRfZW5kX29mX2lucHV0IiwiYmFkX2Zsb2F0IiwiYmFkX2hleF9mbG9hdCIsImNoYXJhY3Rlcl9taXNtYXRjaF9lcnIiLCJjaSIsImNoYXJhY3Rlcl9taXNtYXRjaCIsInNraXBfd2hpdGVzIiwiY2hlY2tfdGhpc19jaGFyIiwiY2hlY2tfbmV3bGluZSIsImNoZWNrX2NoYXIiLCJ0b2tlbl9jaGFyIiwidG9rZW5fYm9vbCIsImludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIiwidG9rZW5faW50X2xpdGVyYWwiLCJ0b2tlbl9pbnQiLCJ0b2tlbl9mbG9hdCIsInRva2VuX25hdGl2ZWludCIsInRva2VuX2ludDMyIiwidG9rZW5faW50NjQiLCJzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciIsIndpZHRoJDIiLCJzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50Iiwic2Nhbl9kaWdpdF9zdGFyIiwiZGlnaXRwIiwic2Nhbl9kaWdpdHMiLCJzY2FuX2RpZ2l0X3BsdXMiLCJiYXNpcyIsImlzX2JpbmFyeV9kaWdpdCIsInNjYW5fYmluYXJ5X2ludCIsImlzX29jdGFsX2RpZ2l0Iiwic2Nhbl9vY3RhbF9pbnQiLCJpc19oZXhhX2RpZ2l0Iiwic2Nhbl9oZXhhZGVjaW1hbF9pbnQiLCJzY2FuX3NpZ24iLCJzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWwiLCJzY2FuX3Vuc2lnbmVkX2ludCIsInNjYW5fb3B0aW9uYWxseV9zaWduZWRfaW50Iiwic2Nhbl9pbnRfY29udmVyc2lvbiIsInNjYW5fZnJhY3Rpb25hbF9wYXJ0Iiwic2Nhbl9leHBvbmVudF9wYXJ0Iiwic2Nhbl9pbnRlZ2VyX3BhcnQiLCJzY2FuX2Zsb2F0IiwicHJlY2lzaW9uIiwicHJlY2lzaW9uJDAiLCJjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyIsImxvd2VyY2FzZSIsInNjYW5faGV4X2Zsb2F0Iiwid2lkdGgkMyIsIndpZHRoJDQiLCJ3aWR0aCQ1Iiwid2lkdGgkNiIsIndpZHRoJDEwIiwid2lkdGgkNyIsIndpZHRoJDgiLCJ3aWR0aCQ5Iiwic2Nhbl9jYW1sX2Zsb2F0X3Jlc3QiLCJ3aWR0aF9wcmVjaXNpb24iLCJmcmFjX3dpZHRoIiwic2Nhbl9jYW1sX2Zsb2F0Iiwic2Nhbl9zdHJpbmciLCJzdHAiLCJzY2FuX2NoYXIiLCJjaGFyX2Zvcl9iYWNrc2xhc2giLCJkZWNpbWFsX3ZhbHVlX29mX2NoYXIiLCJjaGFyX2Zvcl9kZWNpbWFsX2NvZGUiLCJjMCIsImhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIiLCJjaGFyX2Zvcl9oZXhhZGVjaW1hbF9jb2RlIiwiY2hlY2tfbmV4dF9jaGFyIiwiY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIiwiY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmciLCJzY2FuX2JhY2tzbGFzaF9jaGFyIiwiZ2V0X2RpZ2l0IiwiZ2V0X2RpZ2l0JDAiLCJjMSQwIiwiYzIkMCIsInNjYW5fY2FtbF9jaGFyIiwiZmluZF9zdG9wIiwiZmluZF9jaGFyIiwiZmluZF9zdGFydCIsInNjYW5fY2FtbF9zdHJpbmciLCJmaW5kX3N0b3AkMCIsInNjYW5fYmFja3NsYXNoIiwic2tpcF9zcGFjZXMiLCJza2lwX25ld2xpbmUiLCJzY2FuX2Jvb2wiLCJzY2FuX2NoYXJzX2luX2NoYXJfc2V0Iiwic2Nhbl9pbmRpYyIsInNjYW5fY2hhcnMiLCJzY2FuZl9iYWRfaW5wdXQiLCJnZXRfY291bnRlciIsIndpZHRoX29mX3BhZF9vcHQiLCJzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IiwiZm10aW5nIiwidGFrZV9mb3JtYXRfcmVhZGVycyQwIiwidGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyQwIiwiZm10JDIxIiwibmV3X2siLCJyZWFkZXJzX3Jlc3QiLCJ0YWtlX2Zvcm1hdF9yZWFkZXJzIiwiZm10JDIyIiwiZm10JDIzIiwiZm10JDI0IiwidGFrZV9pZ25vcmVkX2Zvcm1hdF9yZWFkZXJzIiwiZm10JDI1IiwidGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyIsIm1ha2Vfc2NhbmYiLCJyZWFkZXJzIiwic2NhbiQwIiwic3RyX3Jlc3QiLCJwYWRfcHJlY19zY2FuZiIsInNjYW4kMSIsInNjYW4kMiIsInNjYW4iLCJzY2FuJDMiLCJzY2FuJDQiLCJzY2FuJDUiLCJzY2FuJDYiLCJzY2FuJDciLCJzY2FuJDgiLCJtc2ckMCIsImZtdGluZ19saXQkMCIsInN0ciQxIiwic3RwJDAiLCJzJDIiLCJzdHJfcmVzdCQwIiwicmVzdCQyNCIsInJlc3QkMjUiLCJyZXN0JDI2IiwiYXJnX3Jlc3QiLCJ4JDIiLCJrc2NhbmYiLCJlZiIsImFwcGx5IiwiYXJncyQwIiwiZXhjIiwic3NjYW5mIiwicmVnaXN0ZXJfZXhjZXB0aW9uIiwiaW5pdGlhbF9vYmplY3Rfc2l6ZSIsInB1YmxpY19tZXRob2RfbGFiZWwiLCJjb21wYXJlJDQiLCJjb21wYXJlJDUiLCJjb21wYXJlJDYiLCJ0YWJsZV9jb3VudCIsImR1bW15X21ldCIsImZpdF9zaXplIiwibmV3X3RhYmxlIiwicHViX2xhYmVscyIsIm1ldGhvZHMiLCJyZXNpemUkMSIsIm5ld19zaXplIiwib2xkX3NpemUiLCJuZXdfYnVjayIsImxhYmVsIiwiZWxlbWVudCIsIm1ldGhvZF9jb3VudCIsImluc3RfdmFyX2NvdW50IiwibmV3X21ldGhvZCIsInRhYmxlIiwiZ2V0X21ldGhvZF9sYWJlbCIsImdldF9tZXRob2RfbGFiZWxzIiwibmFtZXMiLCJzZXRfbWV0aG9kIiwibmV3X3Nsb3QiLCJuZXdfdmFyaWFibGUiLCJjcmVhdGVfdGFibGUiLCJwdWJsaWNfbWV0aG9kcyIsInRhZ3MiLCJtZXQiLCJsYWIiLCJpbml0X2NsYXNzIiwibWFrZV9jbGFzcyIsInB1Yl9tZXRocyIsImNsYXNzX2luaXQiLCJlbnZfaW5pdCIsImNyZWF0ZV9vYmplY3Rfb3B0Iiwib2JqXzAiLCJnZXRfY29uc3QiLCJnZXRfdmFyIiwiZ2V0X2VudiIsImdldF9tZXRoIiwic2V0X3ZhciIsImFwcF9jb25zdCIsImFwcF92YXIiLCJhcHBfZW52IiwiYXBwX21ldGgiLCJhcHBfY29uc3RfY29uc3QiLCJhcHBfY29uc3RfdmFyIiwiYXBwX2NvbnN0X21ldGgiLCJhcHBfdmFyX2NvbnN0IiwiYXBwX21ldGhfY29uc3QiLCJhcHBfY29uc3RfZW52IiwiYXBwX2Vudl9jb25zdCIsIm1ldGhfYXBwX2NvbnN0IiwibWV0aF9hcHBfdmFyIiwibWV0aF9hcHBfZW52IiwibWV0aF9hcHBfbWV0aCIsInNlbmRfY29uc3QiLCJzZW5kX3ZhciIsInNlbmRfZW52Iiwic2VuZF9tZXRoIiwibmV3X2NhY2hlIiwibWV0aG9kX2ltcGwiLCJjbG8iLCJuJDIiLCJuJDMiLCJuJDQiLCJmJDIiLCJuJDUiLCJmJDMiLCJmJDQiLCJuJDYiLCJmJDUiLCJ4JDMiLCJuJDciLCJmJDYiLCJ4JDQiLCJuJDgiLCJmJDciLCJuJDkiLCJ4JDUiLCJmJDgiLCJlJDIiLCJuJDEwIiwieCQ2IiwiZiQ5IiwibiQxMSIsIngkNyIsIm4kMTIiLCJ4JDgiLCJuJDEzIiwibiQxNCIsImUkMyIsIm4kMTUiLCJtJDIiLCJ4JDkiLCJtJDMiLCJuJDE2IiwibSQ0IiwiZSQ0IiwibiQxNyIsIm0kNSIsIm4kMTgiLCJzZXRfbWV0aG9kcyIsInRyYWRpdGlvbmFsMnJldmlzZWQiLCJnZXRfcmF3X3Rva2VuIiwiZ2V0X3N0YXJ0cCIsImdldF9lbmRwIiwicGFyc2VyIiwibGV4ZXIiLCJsZXhlciQwIiwidHJhZGl0aW9uYWwycmV2aXNlZCQwIiwiZW5kcCIsInN0YXJ0cCIsIm51bWJlciIsInRva2VuMnRlcm1pbmFsIiwidG9rZW4ydmFsdWUiLCJlcnJvcl90ZXJtaW5hbCIsImVycm9yX3ZhbHVlIiwiZm9yZWFjaF90ZXJtaW5hbCIsInByb2R1Y3Rpb25faW5kZXgiLCJmaW5kX3Byb2R1Y3Rpb24iLCJnb3RvX250IiwiZ290b19wcm9kIiwibWF5YmVfZ290b19udCIsImlzX3N0YXJ0Iiwic2VtYW50aWNfYWN0aW9uIiwibWF5X3JlZHVjZSIsImxvZyIsImNoZWNrX2Zvcl9kZWZhdWx0X3JlZHVjdGlvbiIsImVudiIsImFubm91bmNlX3JlZHVjZSIsImNoZWNrX2Zvcl9lcnJvcl90b2tlbiIsInJ1biIsInBsZWFzZV9kaXNjYXJkIiwiZGlzY2FyZCIsInRyaXBsZSIsImVudiQwIiwic2hpZnQiLCJpbml0aWF0ZSIsInRlcm1pbmFsIiwidmFsdWUiLCJuZXdfZW52IiwiYWNjZXB0IiwicHJvZCIsInJlZHVjZSIsImN1cnJlbnQiLCJlcnJvcl9mYWlsIiwic3RyYXRlZ3kiLCJlcnJvcl9yZWR1Y2UiLCJlcnJvcl9zaGlmdCIsInBsZWFzZV9kaXNjYXJkJDAiLCJpbml0aWFsIiwib2ZmZXIiLCJyZXN1bWUiLCJjaGVja3BvaW50IiwiZW52JDEiLCJsZXhlcl9sZXhidWZfdG9fc3VwcGxpZXIiLCJjaGVja3BvaW50JDAiLCJjaGVja3BvaW50JDEiLCJjaGVja3BvaW50JDIiLCJvcHQkMiIsImVudHJ5IiwibG9vcF9oYW5kbGUiLCJzdWNjZWVkIiwiZmFpbCIsImlucHV0bmVlZGVkIiwibG9vcF9oYW5kbGVfdW5kbyIsInNoaWZ0cyIsImFjY2VwdGFibGUiLCJlbnYxIiwiZW52MiIsImN1cnJlbnRfc3RhdGVfbnVtYmVyIiwicG9zaXRpb25zIiwic3RhdGVfaGFzX2RlZmF1bHRfcmVkdWN0aW9uIiwiZW52X2hhc19kZWZhdWx0X3JlZHVjdGlvbiIsImZvcmNlX3JlZHVjdGlvbiIsImlucHV0X25lZWRlZCIsInBvcF9tYW55IiwiZ2V0MSIsImdldCQxIiwidW5mbGF0dGVuMSIsImRlY29kZSIsImRpc3BsYWNlbWVudCIsImdldGdldCIsImdldF9kaXNwbGFjZW1lbnQiLCJnZXRfZGF0YSIsInJlYWRfaW50ZXJ2YWxfdmlhIiwicmVhZF9yb3dfdmlhIiwiZ2V0X2VudHJ5Iiwibm9udGVybWluYWwiLCJyZWFkX3BhY2tlZF9saW5lYXJpemVkIiwiZGVjb2RlX3N5bWJvbCIsInN5bWJvbCIsInN5bWJvbCQwIiwibjJpIiwibnQiLCJhbnN3ZXIiLCJ0MmkiLCJjb21wYXJlX3Rlcm1pbmFscyIsImNvbXBhcmVfbm9udGVybWluYWxzIiwibnQxIiwibnQyIiwiY29tcGFyZV9zeW1ib2xzIiwic3ltYm9sMSIsInN5bWJvbDIiLCJjb21wYXJlX3Byb2R1Y3Rpb25zIiwicHJvZDEiLCJwcm9kMiIsImNvbXBhcmVfaXRlbXMiLCJpbmRleDIiLCJpbmRleDEiLCJpbmNvbWluZ19zeW1ib2wiLCJjb3JlIiwibG93X2JpdHMiLCJsb3dfbGltaXQiLCJleHBvcnQkMCIsIml0ZW1zIiwiZGVjb2RlX2Jvb2wiLCJ4Zmlyc3QiLCJ0JDAiLCJmb2xkaWoiLCJmb3JlYWNoX3Rlcm1pbmFsX2J1dF9lcnJvciIsImZlZWRfZmFpbHVyZSIsImZlZWRfbm9udGVybWluYWwiLCJzZW12Iiwic291cmNlIiwiZmVlZF90ZXJtaW5hbCIsImZlZWQiLCJub25fc3RhcnRfcHJvZHVjdGlvbiIsImRlZnJlZCIsIm5vZGVmcmVkIiwidW5tYXJzaGFsMiIsIm9wY29kZSIsInBhcmFtIiwicHJvZCQwIiwidGVybWluYWxzIiwicmVkdWNlX29yX2FjY2VwdCIsInByb2R1Y3Rpb25zIiwibG9va2FoZWFkX3Rva2VuIiwiaW5pdGlhdGluZ19lcnJvcl9oYW5kbGluZyIsInJlc3VtaW5nX2Vycm9yX2hhbmRsaW5nIiwiaGFuZGxpbmdfZXJyb3IiLCJlcXVhbCQyIiwiZXF1YWwkNCIsInRvX2ludCQwIiwiaW50ZXJzZWN0Iiwic3ltYm9sJDEiLCJkdW1teSQxIiwiaW5leGlzdGFudCIsImxldHRlciIsIm5vdF9sZXR0ZXIiLCJuZXdsaW5lIiwibGFzdG5ld2xpbmUiLCJzZWFyY2hfYm91bmRhcnkiLCJmcm9tX2NoYXIiLCJ1bmlvbiQwIiwiaW50ZXIkMCIsImRpZmYkMCIsInIkMSIsInNpbmdsZSIsImFkZCQ3IiwiZW1wdHkkMiIsIm1lbSQyIiwicmVtIiwiaGFzaF9yZWMiLCJpdGVyJDgiLCJvbmVfY2hhciIsImNvbXBhcmUkMTMiLCJ1IiwiZm9sZF9yaWdodCQyIiwiY3NpbmdsZSIsImlzX2VtcHR5JDMiLCJlcXVhbCQ1IiwiY29tcGFyZSQxNCIsImhhc2hfY29tYmluZSIsImVtcHR5JDMiLCJoYXNoX21hcmtzX29mZnNldCIsImhhc2gkMiIsIm1hcmtzIiwibWFya3Nfc2V0X2lkeCIsImNyZWF0ZV9pZHMiLCJta19leHByIiwiaWRzIiwiZGVmIiwiZW1wdHkkNCIsImFsdCIsInNlcSQxIiwiaXNfZXBzIiwiZXhwciIsImVwcyIsInJlcCIsInNlbSIsIm1hcmsiLCJwbWFyayIsImVyYXNlIiwicmVuYW1lIiwieSQwIiwiZXF1YWwkNiIsIm1hcmtzMiIsInIyJDEiLCJtYXJrczIkMCIsImhhc2gkMyIsIm1hcmtzJDAiLCJ0ZXhwIiwidHNlcSIsImR1bW15JDIiLCJoYXNoJDQiLCJjYXQiLCJkZXNjIiwibWskMCIsImNyZWF0ZSQ5IiwiZXF1YWwkNyIsImhhc2gkNSIsImNyZWF0ZV93b3JraW5nX2FyZWEiLCJpbmRleF9jb3VudCIsInJlc2V0X3RhYmxlIiwibWFya191c2VkX2luZGljZXMiLCJmaW5kX2ZyZWUiLCJpZHgkMCIsImlkeCQxIiwiZnJlZV9pbmRleCIsInRibF9yZWYiLCJyZW1vdmVfbWF0Y2hlcyIsInNwbGl0X2F0X21hdGNoX3JlYyIsInNwbGl0X2F0X21hdGNoIiwicmVtb3ZlX2R1cGxpY2F0ZXMiLCJwcmV2IiwicHJldiQwIiwicHJldiQxIiwicHJldiQyIiwiciQyIiwiciQzIiwicHJldiQzIiwiciQ0Iiwic2V0X2lkeCIsImZpbHRlcl9tYXJrcyIsImRlbHRhXzEkMCIsIm5leHRfY2F0IiwicHJldl9jYXQiLCJkZWx0YV8yJDAiLCJkZWx0YV8xIiwiZGVsdGFfc2VxJDAiLCJ5JDEiLCJraW5kJDAiLCJyZXBfa2luZCIsInkkMiIsInkkMyIsIm1hcmtzJDEiLCJjYXQkMCIsIm1hcmtzJDIiLCJkZWx0YV8yIiwiZGVsdGFfc2VxIiwiZGVsdGFfNCIsImRlbHRhXzMiLCJkZWx0YSIsInN0IiwiZXhwciQwIiwiZmxhdHRlbl9tYXRjaCIsIm1hIiwic3QkMCIsIm1ha2UkNSIsImZsYXR0ZW4kMSIsImNtIiwiY29sb3JfcmVwciIsInNwbGl0JDEiLCJwMSIsInAyIiwiaXRlciQ5IiwidW5rbm93biQwIiwiYnJlYWskMCIsImNhdGVnb3J5IiwiY29sb3IiLCJkdW1teV9uZXh0IiwidW5rbm93bl9zdGF0ZSIsIm1rX3N0YXRlIiwibmNvbCIsImJyZWFrX3N0YXRlIiwiZmluZF9zdGF0ZSIsImRlbHRhJDAiLCJ2YWxpZGF0ZSIsImxvb3AkMCIsImxvb3AyIiwicG9zJDAiLCJzdCQyIiwic3QkMSIsInBvcyQxIiwic3QkMyIsImxvb3Bfbm9fbWFyayIsImxhc3QiLCJmaW5hbCQwIiwiZmluZF9pbml0aWFsX3N0YXRlIiwiZ2V0X2NvbG9yIiwiaGFuZGxlX2xhc3RfbmV3bGluZSIsImdyb3VwcyIsInJlYWxfYyIsInNjYW5fc3RyIiwiaW5pdGlhbF9zdGF0ZSIsImluZm8kMCIsIm1hdGNoX3N0ciIsInBhcnRpYWwiLCJpbml0aWFsX2NhdCIsImZpbmFsX2NhdCIsInBtYXJrcyIsIm1rX3JlIiwiY29sb3JzIiwibmNvbG9yIiwibG5sIiwiZ3JvdXBfY291bnQiLCJjc2VxIiwiY2FkZCIsInRyYW5zX3NldCIsImNhY2hlIiwiaXNfY2hhcnNldCIsImN1cHBlciIsImNsb3dlciIsImNhbHBoYSIsImNkaWdpdCIsImNhbG51bSIsImN3b3JkIiwiY29sb3JpemUiLCJyZWdleHAiLCJyZWdleHAkMCIsInJlZ2V4cCQxIiwicmVnZXhwJDIiLCJlcXVhbCQ4IiwiZXFfbGlzdCIsImoyIiwieDIkMSIsImoxIiwieDEkMSIsIngyJDIiLCJzZW0yIiwieDEkMiIsInNlbTEiLCJ4MiQzIiwieDEkMyIsIngyJDQiLCJ4MSQ0IiwieDIkNSIsIngxJDUiLCJ4MiQ2IiwieDEkNiIsIngyJDciLCJ4MSQ3IiwibDIkMiIsImwxJDIiLCJ4MiQ4IiwieDIkOSIsIngxJDgiLCJ4MSQ5Iiwic2VxdWVuY2UiLCJtZXJnZV9zZXF1ZW5jZXMiLCJlbmZvcmNlX2tpbmQiLCJjciIsInRyYW5zX3NlcSIsImlnbl9ncm91cCIsImlnbl9jYXNlIiwiZ3JlZWR5IiwidHJhbnNsYXRlIiwiY3IkMCIsImtpbmQkMSIsImNyJDEiLCJtZXJnZWRfc2VxdWVuY2VzIiwia2luZCQyIiwia2luZCQzIiwiZ3JlZWR5JDEiLCJraW5kJDQiLCJjciQyIiwicGFyYW0kMiIsImtpbmQkNSIsImNyJDMiLCJraW5kJDYiLCJjciQ0IiwiY2FzZV9pbnNlbnMiLCJhc19zZXQiLCJoYW5kbGVfY2FzZSIsInIkNSIsInIkNiIsInIkNyIsInIkOCIsInIkOSIsInIkMTAiLCJyJDExIiwiciQxMiIsInIkMTMiLCJyJDE0IiwiciQxNSIsImNvbXBpbGVfMSIsIm5lZWRfbG5sIiwibmNvbG9yJDAiLCJhbmNob3JlZCIsInN0aCQwIiwiYWxsIiwic3Vic3RyIiwicmVwbGFjaW5nIiwiYnkiLCJmbWFwIiwibmlsIiwic2luZ2xldG9uJDMiLCJjb25zIiwiYXBwZW5kJDAiLCJpc19jb250cm9sIiwiYWRkX3Vuc2FmZV9jaGFyIiwiZW5jb2RlX3Vuc2FmZV9jaGFyIiwicmVfZW5kX2NvbW1lbnQiLCJlc2NhcGVfY29tbWVudCIsInBwX251bWJlciIsInZpbnQiLCJkaXYiLCJzdHJpbmdfb2ZfbnVtYmVyIiwicHBfbm9vcCIsIm9wZW5fYm94IiwiY2xvc2VfYm94Iiwic3AiLCJjdXQiLCJpc19lbXB0eXRhZyIsInBwX2VuY29kZSIsImVuY29kZSIsInBwX2F0dHJpYl92YWx1ZSIsInNsaXN0IiwicHBfYXR0cmliIiwicHBfYXR0cmlicyIsInBwX3RhZ19hbmRfYXR0cmlicyIsImF0dHJzIiwicHBfY2xvc2VkdGFnIiwicHBfZWx0cyIsInBwX2VsdCIsInBwX3RhZyIsImNoaWxkcmVuIiwiZWx0IiwidGV4dGUiLCJ0ZXh0ZSQwIiwidGV4dGUkMSIsInhoX2F0dHJzIiwieGhfdGFnbGlzdCIsInhoX2F0dHJzJDAiLCJuYW1lJDAiLCJzZXBhcmF0b3JfdG9fc3RyaW5nIiwiYXR0cmliX3ZhbHVlX3RvX3N0cmluZyIsImF0dHJpYl90b19zdHJpbmciLCJ4aF9wcmludF9hdHRycyIsImF0dHIiLCJ4aF9wcmludF9jbG9zZWR0YWciLCJ4aF9wcmludF90YWdsaXN0IiwidGFnbGlzdCIsInRhZ2xpc3QkMCIsInByaW50X25vZGVzIiwieGhfcHJpbnRfdGFnIiwicHJpbnRfbGlzdCIsImZvcmV0IiwiZjEiLCJtYWtlIiwidXJpX29mX3N0cmluZyIsInN0cmluZ19vZl91cmkiLCJhY29udGVudCIsImFuYW1lIiwiZmxvYXRfYXR0cmliIiwiaW50X2F0dHJpYiIsInN0cmluZ19hdHRyaWIiLCJzcGFjZV9zZXBfYXR0cmliIiwidmFsdWVzIiwiY29tbWFfc2VwX2F0dHJpYiIsImV2ZW50X2hhbmRsZXJfYXR0cmliIiwibW91c2VfZXZlbnRfaGFuZGxlcl9hdHRyaWIiLCJrZXlib2FyZF9ldmVudF9oYW5kbGVyX2F0dHJpYiIsInRvdWNoX2V2ZW50X2hhbmRsZXJfYXR0cmliIiwidXJpX2F0dHJpYiIsInVyaXNfYXR0cmliIiwiZW1wdHkkNSIsImNvbW1lbnQiLCJwY2RhdGEiLCJlbmNvZGVkcGNkYXRhIiwiZW50aXR5IiwicmVfZW5kX2NkYXRhIiwiZW5jb2RlZF9jZGF0YSIsImNkYXRhIiwiY2RhdGFfc2NyaXB0IiwiY2RhdGFfc3R5bGUiLCJsZWFmIiwibm9kZSIsInJlbW92ZSQzIiwiY3JlYXRlJDEwIiwiY29tcGFyZSQxNSIsInRvX3B1YmxpY19wcm9taXNlIiwidG9faW50ZXJuYWxfcHJvbWlzZSIsImlkZW50aWNhbCIsInVuZGVybHlpbmciLCJzZXRfcHJvbWlzZV9zdGF0ZSIsIm1heV9ub3dfYmVfcHJveHkiLCJjdXJyZW50X3N0b3JhZ2UiLCJjb25jYXRfcmVndWxhcl9jYWxsYmFja3MiLCJjb25jYXRfY2FuY2VsX2NhbGxiYWNrcyIsImNsZWFuX3VwX2NhbGxiYWNrX2NlbGxzIiwiY2FsbGJhY2tzIiwibWVyZ2VfY2FsbGJhY2tzIiwiZnJvbSIsImludG8iLCJyZWd1bGFyX2NhbGxiYWNrcyIsImNsZWFudXBzX2RlZmVycmVkIiwiY2xlYW51cHNfZGVmZXJyZWQkMSIsInJlZ3VsYXJfY2FsbGJhY2tzJDAiLCJjYW5jZWxfY2FsbGJhY2tzIiwiYWRkX3JlZ3VsYXJfY2FsbGJhY2tfbGlzdF9ub2RlIiwibm9kZSQwIiwiYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjIiwiaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvIiwicnVuX2NhbGxiYWNrcyIsInJ1bl9jYW5jZWxfY2FsbGJhY2tzIiwiaXRlcl9jYWxsYmFja19saXN0JDAiLCJmcyQwIiwiaXRlcl9saXN0IiwiZnMkMSIsImZzJDIiLCJzdG9yYWdlIiwiaXRlcl9jYWxsYmFja19saXN0IiwicnVuX3JlZ3VsYXJfY2FsbGJhY2tzIiwiaXNfY2FuY2VsZWQiLCJjdXJyZW50X2NhbGxiYWNrX25lc3RpbmdfZGVwdGgiLCJkZWZhdWx0X21heGltdW1fY2FsbGJhY2tfbmVzdGkiLCJkZWZlcnJlZF9jYWxsYmFja3MiLCJlbnRlcl9yZXNvbHV0aW9uX2xvb3AiLCJzdG9yYWdlX3NuYXBzaG90IiwibGVhdmVfcmVzb2x1dGlvbl9sb29wIiwicnVuX2luX3Jlc29sdXRpb25fbG9vcCIsInJ1bl9jYWxsYmFja3Nfb3JfZGVmZXJfdGhlbSIsImFsbG93X2RlZmVycmluZyIsIm1heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aCIsInNob3VsZF9kZWZlciIsInJlc29sdmUiLCJydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXQiLCJpZl9kZWZlcnJlZCIsInJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaSIsImRlZmVycmVkX3Jlc3VsdCIsImRlZmVycmVkX2NhbGxiYWNrIiwiaW1tZWRpYXRlX3Jlc3VsdCIsImRlZmVycmVkX3JlY29yZCIsInJldHVybiQwIiwibmV3X3BlbmRpbmciLCJob3dfdG9fY2FuY2VsIiwibWFrZV9pbnRvX3Byb3h5Iiwib3V0ZXJfcHJvbWlzZSIsInVzZXJfcHJvdmlkZWRfcHJvbWlzZSIsInBfY2FsbGJhY2tzIiwib3V0ZXJfY2FsbGJhY2tzIiwiYmFja3RyYWNlX2JpbmQiLCJhZGRfbG9jIiwiY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsIiwic2F2ZWRfc3RvcmFnZSIsImNhbGxiYWNrIiwicF9yZXN1bHQiLCJ5MiIsInkxIiwiY3YiLCJwdXNoJDAiLCJwcmUiLCJwb3N0IiwidmlzaXQiLCJwb3N0Zml4IiwiZm9sZF9jb21wb25lbnQiLCJpdGVyX2NvbXBvbmVudCIsInBvc3RmaXhfY29tcG9uZW50IiwiaGFzX2N5Y2xlX3VuZGlyZWN0ZWQiLCJpc19mYXRoZXIiLCJoYXNfY3ljbGUiLCJpdGVyJDAiLCJpdGVyX2NvbXBvbmVudCQwIiwicHJlZml4IiwiaGFzX2N5Y2xlJDAiLCJwcmVmaXhfY29tcG9uZW50Iiwic3RlcCIsImNsZWFuIiwiY3JlYXRlX2Zyb20iLCJmaW5kX2FuZF9yYWlzZSIsImlzX2RpcmVjdGVkIiwibmJfdmVydGV4IiwibmJfZWRnZXMiLCJvdXRfZGVncmVlIiwibWVtX3ZlcnRleCIsInVuc2FmZV9hZGRfdmVydGV4IiwidW5zYWZlX2FkZF9lZGdlIiwiYWRkX3ZlcnRleCIsIml0ZXJfdmVydGV4IiwiZm9sZF92ZXJ0ZXgiLCJpdGVyX3ByZWQiLCJmb2xkX3ByZWQiLCJpbl9kZWdyZWUiLCJpdGVyX3ByZWRfZSIsImZvbGRfcHJlZF9lIiwicHJlZF9lIiwic3JjIiwibWVtX2VkZ2UiLCJtZW1fZWRnZV9lIiwiZmluZF9lZGdlIiwiZmluZF9hbGxfZWRnZXMiLCJ1bnNhZmVfcmVtb3ZlX2VkZ2UiLCJ1bnNhZmVfcmVtb3ZlX2VkZ2VfZSIsInJlbW92ZV9lZGdlIiwicmVtb3ZlX2VkZ2VfZSIsIml0ZXJfc3VjYyIsImZvbGRfc3VjYyIsIml0ZXJfc3VjY19lIiwiZm9sZF9zdWNjX2UiLCJzdWNjX2UiLCJtYXBfdmVydGV4IiwiaXRlcl9lZGdlcyIsImZvbGRfZWRnZXMiLCJpdGVyX2VkZ2VzX2UiLCJmb2xkX2VkZ2VzX2UiLCJpdGVyX2VkZ2VzJDAiLCJmb2xkX2VkZ2VzJDAiLCJpdGVyX2VkZ2VzX2UkMCIsImZvbGRfZWRnZXNfZSQwIiwiaXRlcl9lZGdlcyQxIiwiZm9sZF9lZGdlcyQxIiwiaXRlcl9lZGdlc19lJDEiLCJmb2xkX2VkZ2VzX2UkMSIsInkzIiwidjIkMCIsInZlIiwidmUkMCIsIm1lbV92ZXJ0ZXgkMCIsInZlcnRleCIsIm91dF9zZXQiLCJpbl9zZXQiLCJnJDAiLCJvdXRfc2V0JDAiLCJpbl9zZXQkMCIsIm91dHNldCIsImRlbCIsImFkZF9lZGdlIiwiZyQxIiwiYWRkX2VkZ2VfZSIsInVuc2FmZV9hZGRfZWRnZV9lIiwiaXRlcl9wcmVkJDAiLCJmb2xkX3ByZWQkMCIsInByZWQkMCIsIml0ZXJfcHJlZF9lJDAiLCJmb2xkX3ByZWRfZSQwIiwicHJlZF9lJDAiLCJuYl92ZXJ0ZXgkMCIsInVuc2FmZV9hZGRfZWRnZSQwIiwidW5zYWZlX3JlbW92ZV9lZGdlJDAiLCJ1bnNhZmVfcmVtb3ZlX2VkZ2VfZSQwIiwiaXNfZGlyZWN0ZWQkMCIsInJlbW92ZV9lZGdlJDAiLCJyZW1vdmVfZWRnZV9lJDAiLCJvdXRfZGVncmVlJDAiLCJpbl9kZWdyZWUkMCIsIm5iX2VkZ2VzJDAiLCJzdWNjJDAiLCJtZW1fZWRnZSQwIiwibWVtX2VkZ2VfZSQwIiwiZmluZF9lZGdlJDAiLCJmaW5kX2FsbF9lZGdlcyQwIiwiaXRlcl92ZXJ0ZXgkMCIsImZvbGRfdmVydGV4JDAiLCJpdGVyX3N1Y2MkMCIsImZvbGRfc3VjYyQwIiwic3VjY19lJDAiLCJpdGVyX3N1Y2NfZSQwIiwiZm9sZF9zdWNjX2UkMCIsIm1hcF92ZXJ0ZXgkMCIsInJlbW92ZV92ZXJ0ZXgiLCJyYWlzZSIsInJldHVybiQxIiwiY2FzZSQwIiwidG9fb3B0aW9uIiwiY2FzZSQxIiwidG9fb3B0aW9uJDAiLCJvYmplY3RfY29uc3RydWN0b3IiLCJ0b19zdHJpbmckNyIsImV4cG9ydF9qcyIsImpzb29fZXhwb3J0cyIsImNvbnNvbGUiLCJqc19sb2ciLCJzbmRfbWFwIiwicGFpcl9tYXAiLCJzeW1ib2wkMiIsInN5bWJvbCQzIiwiY3VycnkiLCJ1bmN1cnJ5Iiwic3ltYm9sJDQiLCJmb2xkJDMiLCJmc3QiLCJzbmQiLCJwb3BfYXQiLCJqb2luJDIiLCJkb2l0IiwieHMkMCIsInhzJDEiLCJvZl9vcHRpb24iLCJwaXZvdGkiLCJwcmUkMCIsInByZSQxIiwicGl2b3QiLCJmaW5kX21hcF9vcHQiLCJpc19wcmVmaXgiLCJwciIsInByJDAiLCJwciQxIiwidG9fc3RyaW5nJDgiLCJwcmludCIsInN0aCQxIiwiZW1wdHkkNiIsImludmVyc2UiLCJhZGQkOCIsImZpbmQkNCIsImZpbmRfb3B0JDEiLCJjb2RvbWFpbiIsImNvdW50JDAiLCJmcmVzaCIsImdldCQ1IiwiY3JlYXRlJDExIiwiY2IiLCJzcGFjZWQiLCJzcGFuIiwic3BhY2VkJDAiLCJtYXRoIiwicm93IiwibW8iLCJtbiIsIm1ha2UkNiIsIm1rcG9zIiwib2ZfbGV4YnVmIiwibGIiLCJ1bmxvYyIsIm1rbG9jIiwibG9jIiwiYmluZCIsInJldHVybiQyIiwiY29uY2F0JDEiLCJjb25jYXRfbWFwJDAiLCJyZXR1cm4kMyIsImJpbmQkMCIsImVfdmFycyIsInRzIiwidGVybV9vZl9leHByIiwidGVybV9vZl9mb3JtIiwiZXhwcl9vZl90ZXJtIiwiZm9ybV9vZl90ZXJtIiwic3VjYyQzIiwiZW1wdHkkNyIsImVtcHR5JDgiLCJpbmRpY2VzIiwibGVudiIsImV4aXN0cyQyIiwiZW50ZXIiLCJwdXNoJDEiLCJzZyIsImdldCQ2IiwicHVzaCQyIiwiZ2V0JDciLCJhbGwkMCIsInB1c2gkMyIsImJvZHkiLCJiZHMiLCJnZXQkOCIsImV4aXN0cyQzIiwicHJpb19vZl9mb3JtIiwicHJpb19vZl9leHByIiwicHJpb19vZl90eXBlIiwicHJpb19vZl9vcCIsInByaW9fb2ZfZnVuIiwicHJpb19Ob3QiLCJwcmlvX0FuZCIsInByaW9fT3IiLCJwcmlvX0ltcCIsInByaW9fRXF1aXYiLCJvcCIsImxlZnRfYXNzb2MiLCJyaWdodF9hc3NvYyIsIm5vX2Fzc29jIiwiYXNzb2Nfb2Zfb3AiLCJhc3NvY19vZl9mdW4iLCJ1bmljb2RlX29mX29wIiwiYXNjaWlfb2Zfb3AiLCJmb3JfdHlwZSIsImlzX3ByIiwidDEkMCIsInQyJDAiLCJ0eWNvbiIsImZvcl9leHByIiwiZm9yX2Zvcm0iLCJhcmdzJDEiLCJsZyIsInRleHRfbGciLCJ0ZXh0X2ZzIiwiYmQiLCJiZCQwIiwidF90b2FzY2lpIiwiZV90b2FzY2lpIiwiZl90b2FzY2lpIiwiZm9yX3R5cGUkMCIsImVzIiwibnVtZXJhbCIsImZvcl9mb3JtJDAiLCJ0X3Rvc3RyaW5nIiwiZV90b3N0cmluZyIsImZfdG9zdHJpbmciLCJmb3JfdHlwZSQxIiwiYW91dCIsImZvcl9leHByJDAiLCJ0aGlzaWQiLCJpZCQwIiwieG1sIiwiZm9yX2Zvcm0kMSIsImZvcm0iLCJoZXhjb2RlIiwieG1sX2xnIiwieG1sX2ZzIiwiYW91dCQwIiwidF90b2h0bWwiLCJlX3RvaHRtbCIsImZfdG9odG1sIiwiZm9yX3R5cGUkMiIsImZvcl9leHByJDEiLCJ0aGlzaWQkMCIsImZvcl9mb3JtJDIiLCJ0X3RvbWF0aG1sIiwiZV90b21hdGhtbCIsImZfdG9tYXRobWwiLCJuYW1lX2NvdW50ZXJzIiwiZnJlc2gkMCIsImJhc2VuYW1lIiwiYmFzZW5hbWUkMCIsInB1c2gkNCIsImVudl92YXIiLCJlbnZfaGFuZGxlcyIsImdldCQ5IiwibW9kaWZ5JDEiLCJleGlzdHMkNCIsImdldGlkIiwiYnlpZCIsIm1hcCQ2IiwidG9fbGlzdCQwIiwiYnMiLCJldmFyX25hbWVfY291bnRlciIsImZyZXNoJDEiLCJlbXB0eSQ5IiwicHVzaCQ1IiwibGluZGV4IiwicmluZGV4IiwibGZpbmQiLCJlcXVhbCQ5IiwiZl9hbmQiLCJmX2ltcCIsImZfZmFsc2UiLCJmX3RydWUiLCJmX2FuZHMiLCJmbGF0dGVuX2Rpc2p1bmN0aW9ucyIsImRvaXQkMCIsImZsYXR0ZW5fY29uanVuY3Rpb25zIiwicGFyaXR5IiwiZXFfYWxpYXMiLCJ0Z3RfYSIsImIkMiIsInRndF9iJDAiLCJ0Z3RfYiIsImIkMSIsInR5JDEiLCJlcSQxIiwidHkkMiIsImJkcyQwIiwidHkxJDAiLCJ0eWIyIiwidHlhMiIsInR5YjEiLCJ0eWExIiwidHkyJDEiLCJiZHMkMSIsImVxIiwidF9lcXVhbCIsImVzMiIsImVfZXF1YWwiLCJhdXgkMCIsImYxJDAiLCJmMiQwIiwiZXMxIiwiZnMyIiwiZnMxIiwiZjIkMSIsImIyIiwiZjEkMSIsImIxIiwiZl9lcXVhbCIsImVxdWFsJDEwIiwiZV9zaGlmdCIsImluY3IiLCJmX3NoaWZ0Iiwic2hpZnRfdW5kZXIiLCJkaXJlY3Rfc3ViZm9ybXMiLCJkaXJlY3Rfc3ViZXhwcnMiLCJkaXJlY3Rfc3VidGVybXMiLCJtb2RpZnlfZGlyZWN0X3N1YmZvcm1zIiwibW9kaWZ5X2RpcmVjdF9zdWJleHBycyIsImVzJDAiLCJtb2RpZnlfZGlyZWN0X3N1YnRlcm1zIiwicmV3cml0ZSIsInJlZCIsImZjX2lzX2JvdW5kIiwiZmNfZXhpdCIsImZjX2ZpbGwiLCJjb25uIiwicnMiLCJlX3VubG9jIiwidHJlY2hlY2siLCJlaW5mZXIiLCJ4dHkiLCJmcmVzIiwiZmFyZ3MiLCJlcmVjaGVjayIsInNpZyIsInJlY2hlY2siLCJmb3JtJDAiLCJmb3JtcyIsInRjaGVjayIsImVjaGVjayIsImNoZWNrJDEiLCJhciIsImYyJDIiLCJmMSQyIiwiZjEkMyIsInh0eSQwIiwieHR5JDEiLCJ4dHkkMiIsImVtcHR5JDEwIiwiYXNsaXN0Iiwib2ZsaXN0IiwiZ2V0X3RhZyIsImZsZXgiLCJib3VuZCIsImZldGNoIiwiYWRkJDkiLCJwdXNoJDYiLCJpc19jb21wbGV0ZSIsImVfYXBwbHkxIiwidGciLCJmX2FwcGx5MSIsImZfaXRlciIsImZfYXBwbHkiLCJlX2Nsb3NlIiwiY2xvc2UkMCIsInRhZyQwIiwib2NjdXJzIiwib2NjdXJzX3VuZGVyIiwiZV91bmlmeSIsInZlbnYiLCJlcW5zIiwidW5pZnlfY29uZCIsInVuaWZ5X2JvZHkkMCIsInVuaWZ5X2JvZHkiLCJzdWJzdGl0dXRlX2NvbmQiLCJzdWJzdGl0dXRlX2JvZHkkMCIsInN1YnN0aXR1dGVfYm9keSIsImlzX2NvbnN0IiwidXMiLCJ5ZSIsInhlIiwiZl91bmlmeSIsInN1YmVxbnMiLCJjaGVja19lbnRyeSIsImFyJDAiLCJuYW1lJDEiLCJuYW1lJDIiLCJib2R5JDAiLCJuYW1lJDMiLCJuYW1lJDQiLCJlbnZfb2ZfZW50cmllcyIsImVudHJpZXMiLCJubXR5Iiwibm10eSQwIiwibm10eSQxIiwibm10eSQyIiwiY2hlY2skMiIsImhzIiwicHMiLCJtZW5oaXJfZW52IiwibWVuaGlyX3N0YWNrIiwibWVuaGlyX3N0YWNrJDAiLCJzdGFydHBvc190IiwibWVuaGlyX3MiLCJlbmRwb3NfMiIsImVuZHBvc18xIiwic3RhcnRwb3NfMSIsInN0YXJ0cG9zX2UiLCJzdGFydHBvc19wIiwic3RhcnRwb3NfZiIsImVuZHBvc194Iiwic3RhcnRwb3NfeCIsImVuZHBvc18zIiwiZW5kcG9zXzQiLCJlbmRwb3NfdCIsInN0YXJ0cG9zX3QxIiwiZW5kcG9zX3QyIiwiZW5kcG9zX3R5Iiwic3RhcnRwb3NfeHMiLCJlbmRwb3NfeHMiLCJzdGFydHBvcyIsImVuZHBvc19lIiwiZW5kcG9zX2YiLCJzdGFydHBvc19mMSIsImVuZHBvc19mMiIsInN0YXJ0cG9zX2UxIiwiZW5kcG9zX2UyIiwiZW5kcG9zX2JvZHkiLCJlbmRwb3NfeHR5IiwidHJhY2UiLCJ4bmV4cHIiLCJ4Z29hbCIsInhmb3JtIiwieGV4cHIiLCJsZXhfZXJyb3IiLCJtYWluJDAiLCJvY2FtbF9sZXhfbWFpbl9yZWMiLCJvY2FtbF9sZXhfc3RhdGUiLCJvY2FtbF9sZXhfc3RhdGUkMCIsIm9jYW1sX2xleF9zdGF0ZSQxIiwicGFyc2VyZnVuX2V4cHIiLCJwYXJzZXJmdW5fbmV4cHIiLCJwYXJzZXJmdW5fZm9ybSIsInBhcnNlcmZ1bl9nb2FsIiwiZnJvbV9zdHJpbmckMSIsInBhcnNlX2V4cHIiLCJwYXJzZV9uZXhwciIsInBhcnNlX2Zvcm0iLCJwYXJzZV9nb2FsIiwiZW1wdHkkMTEiLCJmaW5kJDUiLCJkYiIsImFkZCQxMCIsImZvcm0kMSIsImxvYWQiLCJsZW1tYXMiLCJhbGwkMSIsImZyZXNoJDIiLCJvZmludCIsInRvaW50IiwiZXEkMCIsImVtcHR5JDEyIiwiYnlpZCQwIiwiaHlwcyIsImFkZCQxMSIsInJlbW92ZSQ0IiwibW92ZSIsImh5cHMkMCIsImJlZm9yZSQwIiwiYnVtcCIsIm1hcCQ3IiwidG9fbGlzdCQxIiwibWtfaHlwIiwiZ2VuIiwiaW5pdCQyIiwiZ29hbCIsInVpZCIsImdfaHlwcyIsInByb29mIiwibG9hZGRiIiwiY2xvc2VkIiwib3BlbmVkIiwiYWZ0ZXIkMCIsImZvY3VzZWQiLCJieWlkJDEiLCJzZXRfbWV0YSIsIm1ldGEiLCJtZXRhJDAiLCJnZXRfbWV0YSIsImhwcm9ncmVzcyIsInBuIiwiZ19pZCIsInN1YiQwIiwic3ViJDEiLCJnbyIsImdyIiwiZGVwIiwieHByb2dyZXNzIiwiZm9yMSIsInNpZHMiLCJzZ3Byb2dyZXNzIiwiY29uY2wiLCJuZXdsYyIsInN1YmZvcjEiLCJoaWQiLCJoc3JjIiwibmV3aCIsImh5cHMkMSIsInNwcm9ncmVzcyIsInByb2dyZXNzIiwiaWRfdGFjIiwidGhlbl90YWMiLCJ0YXJnIiwiZG9pdCQxIiwicHJ1bmVfcHJlbWlzc2VzIiwiZG9pdCQyIiwicHJ1bmVfcHJlbWlzc2VzX2ZhIiwiaHkiLCJkb2l0JDMiLCJwcnVuZV9wcmVtaXNzZXNfZXgiLCJyZW1vdmVfZm9ybSIsImFkZF9sb2NhbCIsImdfZW52IiwiZ19lbnYkMCIsImdfZ29hbCIsImludHJvIiwicHRlcm0iLCJldHkiLCJnb2FsJDAiLCJnb2FsJDEiLCJmbCIsIm9yX2Ryb3AiLCJnbCIsImFuZF9kcm9wIiwiZ2xsIiwibmciLCJjb3JlX2VsaW0iLCJoeXAiLCJzdWJzIiwiZ19oeXBzJDAiLCJoeSQwIiwicGVyZm9ybSIsImluZHVjdGlvbiIsImJhc2VfY2FzZSIsImluZGgiLCJpbmRfY2FzZSIsIml2YXJpYW50cyIsImNvcmVfZm9yd2FyZCIsImhkc3QiLCJidWlsZF9kZXN0IiwibmYiLCJmb3J3YXJkIiwiYXNzdW1lIiwiZ2VuZXJhbGl6ZSIsIm1vdmUkMCIsImR1cGxpY2F0ZSIsInN1YmdvYWwiLCJjbG9zZV93aXRoX3VuaXQiLCJmb3JtX29mX2l0ZW0iLCJleHByX29mX2l0ZW0iLCJ3aGVyZSIsInRlcm1fb2ZfaXRlbSIsIml0IiwiZGlyZWN0X3N1YnRlcm0iLCJzdWJ0ZXJtIiwibW9kaWZ5X2RpcmVjdF9zdWJ0ZXJtIiwibW9kaWZ5X3N1YnRlcm0iLCJzdWJ0IiwicmV3cml0ZV9zdWJ0ZXJtX2FsbCIsInJld3JpdGVfc3VidGVybSIsInN1YmV4cHIiLCJyZWJ1aWxkX3BhdGhkIiwibWtfaXBhdGgiLCJjdHh0IiwiZHVtbXlfcGF0aCIsImNvbmNsX2lwYXRoIiwiYWxsX2h5cHNfaXBhdGhzIiwiZ19wcmVnb2FsIiwiYWxsX3ZhcnNfaXBhdGhzIiwiaGVhZHMiLCJhbGxfaXRlbXNfaXBhdGhzIiwicGtpbmRfY29kZXMiLCJzdHJpbmdfb2ZfcGtpbmQiLCJwa2luZF9vZl9zdHJpbmciLCJwMnAiLCJwcF9zdWIiLCJpcGF0aF9vZl9wYXRoIiwiaGFuZGxlIiwib2ZfaXBhdGgiLCJycCIsImh5ZCIsImhmIiwidF9pdGVtIiwiaXRlbSIsInBhcnQiLCJ0X2l0ZW0kMCIsIml0ZW0kMCIsImdvYWxfb2ZfaXBhdGgiLCJ0ZXJtX29mX2lwYXRoIiwiZW52X29mX2lwYXRoIiwidCQyIiwidCQxIiwiaXNfc3ViX3BhdGgiLCJyZXdyaXRlX2F0IiwicG5vZGUiLCJuZXdfaHlwIiwibmV3X2JvZHkiLCJuZXdfY29uY2wiLCJyZXdyaXRlJDAiLCJ0Z3QiLCJ0Z3QkMCIsInJld3JpdGVfaW4iLCJ0Z3RzIiwidGFjIiwidW5mb2xkIiwicmVkJDAiLCJ1bmZvbGRfYWxsIiwib3BwIiwiZGlyZWN0X3N1YmZvcm1fcG9sIiwic3VicCIsInN1YmYiLCJzdWJmJDAiLCJkaXJlY3Rfc3VidGVybV9wb2wiLCJzdWJmb3JtX3BvbCIsIm5lZ19jb3VudCIsInBvbF9vZl9pdGVtIiwicG9sX29mX2lwYXRoIiwicG9sIiwicG9sJDAiLCJpbnN0YW50aWF0ZSIsIndpdCIsInByaW50X2Nob2ljZSIsIndpdG5lc3MiLCJzaWRlIiwic2lkZSQwIiwid2l0bmVzcyQwIiwicHJpbnRfaXRyYWNlIiwiZWxpbV91bml0cyIsInByaW50X2xpbmthZ2UiLCJkbGluayIsInNfZHN0Iiwic19zcmMiLCJ0X3NyYyIsInN1Yl9zcmMiLCJpdGVtX3NyYyIsInRfZHN0Iiwic3ViX2RzdCIsIml0ZW1fZHN0Iiwid2VsbF9zY29wZWQiLCJjdHgiLCJpbnN0YW50aWFibGUiLCJsZW52JDAiLCJpbnZlcnRpYmxlIiwibm9fcHJpbyIsImludiIsImJhY2t3YXJkIiwiaXRyYWNlIiwibGlua2FnZSIsInJzdWIiLCJsc3ViIiwidHMyIiwidHMxIiwic3dpdGNoX3BvbCIsInN1YiQ2IiwiZnMkMyIsImZzJDQiLCJmaSQwIiwibGlua2FnZSQwIiwiY2hvaWNlIiwiaWN0eCIsInN1YiQ3Iiwic3ViJDgiLCJzdWIkOSIsInN1YiQxMCIsImZzJDUiLCJmcyQ2IiwiZmkkMSIsInN1YiQxMSIsImYxJDQiLCJzdWIkMTIiLCJmMSQ1IiwiZW52MiQwIiwiZjEkNiIsImgkMSIsInN1YiQyIiwiZmkiLCJmaiIsInN1YiQzIiwic3ViJDQiLCJlbnYxJDAiLCJzdWIkNSIsImNvbnQiLCJjdHgkMCIsIm5ld19zaWRlIiwibGlua2FnZSQxIiwiaWN0eCQwIiwiaCQyIiwiaXRyYWNlJDAiLCJzYyIsInN1YmMiLCJzaCIsInN1YmgiLCJoaWQkMCIsIml0cmFjZSQyIiwic3ViZ29hbCQwIiwiaXRyYWNlJDEiLCJyZW1vdmVfbm90aGluZyIsImEkMCIsImEkMSIsImEkMiIsInRfc3VicyIsImhscHJlZF9vZl9scHJlZCIsIm11bHQiLCJsbmsiLCJobHByZWRfbXVsdCIsImhscHJlZF9hZGQiLCJobHByZWRfaWZfZW1wdHkiLCJhY3Rpb25zIiwic2VhcmNoX2xpbmthY3Rpb25zIiwiZml4ZWRfc3JjcyIsImZpeGVkX2RzdHMiLCJobHAiLCJzdWJwYXRoIiwicXVlcnlfYWN0aW9ucyIsImRzdHMiLCJkc3RzJDAiLCJ0X3NyYyQwIiwidF9kc3QkMCIsInN1YnN0IiwiZGVwcyIsImZ2cyIsImFjeWNsaWMiLCJ0cmF2ZXJzZSIsInJubSIsImV4cyIsImRlcHMkMCIsInJubSQwIiwic3Vic3QkMCIsInRyYXZlcnNlJDAiLCJkcmV3cml0ZSIsImlzX2VxX29wZXJhbmQiLCJlcV9zdWIiLCJlcV9wYXRoIiwic2YxIiwic3AxIiwic3QxIiwic2YyIiwic3AyIiwic3QyIiwicm5tMiIsInJubTEiLCJlcTIiLCJlcTEiLCJzMSQxIiwiZ2V0X25hbWUiLCJzMSQyIiwiczIkMiIsImludHVpdGlvbmlzdGljX2xpbmsiLCJuZWdfY291bnQkMCIsImlzX2ZyZWVfZXhwciIsImluc3RhbnRpYXRlX2xpbmsiLCJzcmNzIiwidG9fZm9ybSIsInBfd2l0IiwicF9mb3JtIiwic3ViX3dpdCIsIml0ZW1fd2l0IiwiY3R4dF93aXQiLCJ3aXQkMCIsInR5X3dpdCIsInJld3JpdGVfbGluayIsInJld3JpdGVfZGF0YSIsImZvbGRfbGluayIsImZvbGRfZGF0YSIsImlzX2hlYWQiLCJzZWxlY3Rpb24iLCJzdG10IiwicHJvb2YkMCIsImdfaWQkMCIsImxwIiwibGlua2FjdGlvbnMiLCJkbmRfYWN0aW9ucyIsImRuZCIsInNyY3NlbCIsImRzdHNlbCIsImhscHJlZF9vbmx5X3NlbCIsInNyY3MkMCIsImZpeGVkX3NyY3MkMCIsImZpeGVkX2RzdHMkMCIsImFjdGlvbnMkMCIsImhnIiwicnAkMCIsImhnX3VuZm9sZCIsImhnX2ZvbGQiLCJycCQxIiwiaGckMCIsIml2IiwiYnYiLCJzdWJoZCIsInN1YmhkJDAiLCJzdWJoZCQxIiwic3ViaGQkMiIsInN1YnN0cyIsImRzdCQwIiwic3JjJDAiLCJ0Z3RzJDAiLCJ0Z3RzJDEiLCJ0cmFuc2xhdG9ycyIsInJlZ2lzdGVyIiwidHgiLCJ0cmFuc2xhdGUkMCIsImFzX3N0cmluZyIsInN5bWJvbCQ1Iiwib2Zfb2JqIiwib2ZfYXJyYXkkMCIsIm9mX29wdCIsImpzX3Byb29mX2VuZ2luZSIsImpzX3N1YmdvYWwiLCJqc19oeXBzIiwianNfdHZhciIsImpzX2Zvcm0iLCJqc19leHByIiwianNfdHlwZSIsInN1YmdvYWxzIiwiZ2V0bWV0YSIsInNldG1ldGEiLCJwYWN0aW9ucyIsImdldGRiIiwic2VsZl8xIiwic2VsZWN0aW9uJDAiLCJsZW1tYXMkMCIsInBweF9sd3RfMCIsImFzb3VyY2UiLCJkZXN0aW5hdGlvbiIsInBhdGgkMCIsImFzb3VyY2UkMCIsImF1aSIsInBzJDAiLCJwcyQxIiwiYXVpJDAiLCJzdWJnb2FscyQwIiwiZnZhcnMiLCJwdmFycyIsInR2YXJzIiwiY29udGV4dCIsImNvbmNsdXNpb24iLCJlbGltIiwiYWRkbGVtbWEiLCJhZGRsb2NhbCIsImFkZGFsaWFzIiwibW92ZV9oeXAiLCJ0b2FzY2lpIiwidG9zdHJpbmciLCJzZWxmXzIiLCJ0b19zdHJpbmciLCJmdW5zIiwicHJvcHMiLCJ2YXJzIiwiY29tbWEiLCJleHByJDEiLCJleHByJDIiLCJmb3JtJDIiLCJwaGFuZGxlIiwicG9zaXRpb24iLCJodG1sIiwibWF0aG1sIiwic2VsZl8zIiwidHlwZSIsImlkaGVhZCIsImlkYm9keSIsInNlbGZfNCIsImR0IiwibWF0aG1sdGFnIiwiaHRtbHRhZyIsInNlbGZfNSIsInNlbGZfNiIsInJhd21hdGhtbCIsInJhd2h0bWwiLCJyYXdzdHJpbmciLCJzZWxmXzciLCJleHBvcnQkMSIsInBhcnNlVG9Vbmljb2RlIiwic2VsZl84Il0sInNvdXJjZXMiOlsiIiwiL2J1aWx0aW4vK2FycmF5LmpzIiwiL2J1aWx0aW4vK21sQnl0ZXMuanMiLCIvYnVpbHRpbi8rZmFpbC5qcyIsIi9idWlsdGluLytzdGRsaWIuanMiLCIvYnVpbHRpbi8raWVlZV83NTQuanMiLCIvYnVpbHRpbi8raW50NjQuanMiLCIvYnVpbHRpbi8rYmlnYXJyYXkuanMiLCIvYnVpbHRpbi8raW50cy5qcyIsIi9idWlsdGluLytoYXNoLmpzIiwiL2J1aWx0aW4vK21hcnNoYWwuanMiLCIvYnVpbHRpbi8rY29tcGFyZS5qcyIsIi9idWlsdGluLytiYWNrdHJhY2UuanMiLCIvYnVpbHRpbi8rd2Vhay5qcyIsIi9idWlsdGluLytnYy5qcyIsIi9idWlsdGluLytmb3JtYXQuanMiLCIvYnVpbHRpbi8rb2JqLmpzIiwiL2J1aWx0aW4vK2ZzX25vZGUuanMiLCIvYnVpbHRpbi8rZnMuanMiLCIvYnVpbHRpbi8rdW5peC5qcyIsIi9idWlsdGluLytzeXMuanMiLCIvYnVpbHRpbi8rZnNfZmFrZS5qcyIsIi9idWlsdGluLytqc2xpYi5qcyIsIi9idWlsdGluLytqc2xpYl9qc19vZl9vY2FtbC5qcyIsIi9idWlsdGluLytsZXhpbmcuanMiLCIvYnVpbHRpbi8rbWQ1LmpzIiwiL2J1aWx0aW4vK2lvLmpzIiwiL2J1aWx0aW4vK25hdC5qcyIsIi9ob21lL3BhYmxvLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvbGV4aW5nLm1sIiwiL2hvbWUvcGFibG8vLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxGb3JtYXQubWwiLCIvaG9tZS9wYWJsby8ub3BhbS80LjE0LjAvbGliL29jYW1sL3ByaW50ZXhjLm1sIiwiL2hvbWUvcGFibG8vLm9wYW0vNC4xNC4wL2xpYi9yZS9jc2V0Lm1sIiwiL2hvbWUvcGFibG8vLm9wYW0vNC4xNC4wL2xpYi9yZS9hdXRvbWF0YS5tbCIsIi9kYXRhL1VzZXJzL3BhYmxvL2RhdGEvRG9jdW1lbnRzL1Njb2xhaXJlL0ZhYy9Eb2N0b3JhdC9hY3RlbWEvcGx1Z2luL2FjdGVtYS1kZXNrdG9wL3Byb3Zlci9fYnVpbGQvZGVmYXVsdC9saWJzL2VuZ2luZS9sb2NhdGlvbi5tbCIsIi9kYXRhL1VzZXJzL3BhYmxvL2RhdGEvRG9jdW1lbnRzL1Njb2xhaXJlL0ZhYy9Eb2N0b3JhdC9hY3RlbWEvcGx1Z2luL2FjdGVtYS1kZXNrdG9wL3Byb3Zlci9fYnVpbGQvZGVmYXVsdC9saWJzL2VuZ2luZS9mby5tbCIsIi9kYXRhL1VzZXJzL3BhYmxvL2RhdGEvRG9jdW1lbnRzL1Njb2xhaXJlL0ZhYy9Eb2N0b3JhdC9hY3RlbWEvcGx1Z2luL2FjdGVtYS1kZXNrdG9wL3Byb3Zlci9fYnVpbGQvZGVmYXVsdC9saWJzL2VuZ2luZS9wYXJzZXIubWwiLCIvZGF0YS9Vc2Vycy9wYWJsby9kYXRhL0RvY3VtZW50cy9TY29sYWlyZS9GYWMvRG9jdG9yYXQvYWN0ZW1hL3BsdWdpbi9hY3RlbWEtZGVza3RvcC9wcm92ZXIvX2J1aWxkL2RlZmF1bHQvbGlicy9lbmdpbmUvbGV4ZXIubWxsIiwiL2RhdGEvVXNlcnMvcGFibG8vZGF0YS9Eb2N1bWVudHMvU2NvbGFpcmUvRmFjL0RvY3RvcmF0L2FjdGVtYS9wbHVnaW4vYWN0ZW1hLWRlc2t0b3AvcHJvdmVyL19idWlsZC9kZWZhdWx0L2xpYnMvZW5naW5lL2xleGVyLm1sIiwiL2hvbWUvcGFibG8vLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MubWwiLCIvaG9tZS9wYWJsby8ub3BhbS80LjE0LjAvbGliL29jYW1sL2NhbWxpbnRlcm5hbEF0b21pYy5tbCIsIi9ob21lL3BhYmxvLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvc3RkbGliLm1sIiwiL2hvbWUvcGFibG8vLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9wZXJ2YXNpdmVzLm1sIiwiL2hvbWUvcGFibG8vLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9saXN0Lm1sIiwiL2hvbWUvcGFibG8vLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9vYmoubWwiLCIvaG9tZS9wYWJsby8ub3BhbS80LjE0LjAvbGliL29jYW1sL2NhbWxpbnRlcm5hbExhenkubWwiLCIvaG9tZS9wYWJsby8ub3BhbS80LjE0LjAvbGliL29jYW1sL3NlcS5tbCIsIi9ob21lL3BhYmxvLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvY2hhci5tbCIsIi9ob21lL3BhYmxvLy5vcGFtLzQuMTQuMC9saWIvdHl4bWwvZnVuY3Rvci94bWxfd3JhcC5tbCIsIi9ob21lL3BhYmxvLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvaW50Lm1sIiwiL2hvbWUvcGFibG8vLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9ieXRlcy5tbCIsIi9ob21lL3BhYmxvLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvc3RyaW5nLm1sIiwiL2hvbWUvcGFibG8vLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9hcnJheS5tbCIsIi9ob21lL3BhYmxvLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvaW50MzIubWwiLCIvaG9tZS9wYWJsby8ub3BhbS80LjE0LjAvbGliL29jYW1sL2ludDY0Lm1sIiwiL2hvbWUvcGFibG8vLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9uYXRpdmVpbnQubWwiLCIvaG9tZS9wYWJsby8ub3BhbS80LjE0LjAvbGliL29jYW1sL3NldC5tbCIsIi9ob21lL3BhYmxvLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvbWFwLm1sIiwiL2hvbWUvcGFibG8vLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9zdGFjay5tbCIsIi9ob21lL3BhYmxvLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvcXVldWUubWwiLCIvaG9tZS9wYWJsby8ub3BhbS80LjE0LjAvbGliL29jYW1sL2J1ZmZlci5tbCIsIi9ob21lL3BhYmxvLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvcHJpbnRmLm1sIiwiL2hvbWUvcGFibG8vLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9mdW4ubWwiLCIvaG9tZS9wYWJsby8ub3BhbS80LjE0LjAvbGliL29jYW1sL2RpZ2VzdC5tbCIsIi9ob21lL3BhYmxvLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvcmFuZG9tLm1sIiwiL2hvbWUvcGFibG8vLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9oYXNodGJsLm1sIiwiL2hvbWUvcGFibG8vLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC93ZWFrLm1sIiwiL2hvbWUvcGFibG8vLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9mb3JtYXQubWwiLCIvaG9tZS9wYWJsby8ub3BhbS80LjE0LjAvbGliL3JlL2ZtdC5tbCIsIi9ob21lL3BhYmxvLy5vcGFtLzQuMTQuMC9saWIvcmUvcG1hcmsubWwiLCIvaG9tZS9wYWJsby8ub3BhbS80LjE0LjAvbGliL29jYW1sL3NjYW5mLm1sIiwiL2hvbWUvcGFibG8vLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9jYWxsYmFjay5tbCIsIi9ob21lL3BhYmxvLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvY2FtbGludGVybmFsT08ubWwiLCIvaG9tZS9wYWJsby8ub3BhbS80LjE0LjAvbGliL29jYW1sL2ZpbGVuYW1lLm1sIiwiL2hvbWUvcGFibG8vLm9wYW0vNC4xNC4wL2xpYi9tZW5oaXJMaWIvbWVuaGlyTGliLm1sIiwiL2hvbWUvcGFibG8vLm9wYW0vNC4xNC4wL2xpYi9yZS9jYXRlZ29yeS5tbCIsIi9ob21lL3BhYmxvLy5vcGFtLzQuMTQuMC9saWIvcmUvY29yZS5tbCIsIi9ob21lL3BhYmxvLy5vcGFtLzQuMTQuMC9saWIvcmUvY29sb3JfbWFwLm1sIiwiL2hvbWUvcGFibG8vLm9wYW0vNC4xNC4wL2xpYi9yZS9ncm91cC5tbCIsIi9ob21lL3BhYmxvLy5vcGFtLzQuMTQuMC9saWIvdHl4bWwvZnVuY3Rvci94bWxfcHJpbnQubWwiLCIvaG9tZS9wYWJsby8ub3BhbS80LjE0LjAvbGliL3R5eG1sL3R5eG1sX3htbC5tbCIsIi9ob21lL3BhYmxvLy5vcGFtLzQuMTQuMC9saWIvbHd0L2x3dF9zZXF1ZW5jZS5tbCIsIi9ob21lL3BhYmxvLy5vcGFtLzQuMTQuMC9saWIvbHd0L2x3dC5tbCIsIi9ob21lL3BhYmxvLy5vcGFtLzQuMTQuMC9saWIvb2NhbWxncmFwaC91dGlsLm1sIiwiL2hvbWUvcGFibG8vLm9wYW0vNC4xNC4wL2xpYi9vY2FtbGdyYXBoL3RyYXZlcnNlLm1sIiwiL2hvbWUvcGFibG8vLm9wYW0vNC4xNC4wL2xpYi9vY2FtbGdyYXBoL2Jsb2Nrcy5tbCIsIi9ob21lL3BhYmxvLy5vcGFtLzQuMTQuMC9saWIvb2NhbWxncmFwaC9wZXJzaXN0ZW50Lm1sIiwiL2hvbWUvcGFibG8vLm9wYW0vNC4xNC4wL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9ydW50aW1lL2pzb29fcnVudGltZS5tbCIsIi9ob21lL3BhYmxvLy5vcGFtLzQuMTQuMC9saWIvanNfb2Zfb2NhbWwvanMubWwiLCIvaG9tZS9wYWJsby8ub3BhbS80LjE0LjAvbGliL2pzX29mX29jYW1sL2ZpcmVidWcubWwiLCIvZGF0YS9Vc2Vycy9wYWJsby9kYXRhL0RvY3VtZW50cy9TY29sYWlyZS9GYWMvRG9jdG9yYXQvYWN0ZW1hL3BsdWdpbi9hY3RlbWEtZGVza3RvcC9wcm92ZXIvX2J1aWxkL2RlZmF1bHQvbGlicy9lbmdpbmUvdXRpbHMubWwiLCIvZGF0YS9Vc2Vycy9wYWJsby9kYXRhL0RvY3VtZW50cy9TY29sYWlyZS9GYWMvRG9jdG9yYXQvYWN0ZW1hL3BsdWdpbi9hY3RlbWEtZGVza3RvcC9wcm92ZXIvX2J1aWxkL2RlZmF1bHQvbGlicy9lbmdpbmUvbW9uYWQubWwiLCIvZGF0YS9Vc2Vycy9wYWJsby9kYXRhL0RvY3VtZW50cy9TY29sYWlyZS9GYWMvRG9jdG9yYXQvYWN0ZW1hL3BsdWdpbi9hY3RlbWEtZGVza3RvcC9wcm92ZXIvX2J1aWxkL2RlZmF1bHQvbGlicy9lbmdpbmUvcGFyc2VyLm1seSIsIi9kYXRhL1VzZXJzL3BhYmxvL2RhdGEvRG9jdW1lbnRzL1Njb2xhaXJlL0ZhYy9Eb2N0b3JhdC9hY3RlbWEvcGx1Z2luL2FjdGVtYS1kZXNrdG9wL3Byb3Zlci9fYnVpbGQvZGVmYXVsdC9saWJzL2VuZ2luZS9pby5tbCIsIi9kYXRhL1VzZXJzL3BhYmxvL2RhdGEvRG9jdW1lbnRzL1Njb2xhaXJlL0ZhYy9Eb2N0b3JhdC9hY3RlbWEvcGx1Z2luL2FjdGVtYS1kZXNrdG9wL3Byb3Zlci9fYnVpbGQvZGVmYXVsdC9saWJzL2VuZ2luZS9sZW1tYURCLm1sIiwiL2RhdGEvVXNlcnMvcGFibG8vZGF0YS9Eb2N1bWVudHMvU2NvbGFpcmUvRmFjL0RvY3RvcmF0L2FjdGVtYS9wbHVnaW4vYWN0ZW1hLWRlc2t0b3AvcHJvdmVyL19idWlsZC9kZWZhdWx0L2xpYnMvZW5naW5lL3Byb29mLm1sIiwiL2RhdGEvVXNlcnMvcGFibG8vZGF0YS9Eb2N1bWVudHMvU2NvbGFpcmUvRmFjL0RvY3RvcmF0L2FjdGVtYS9wbHVnaW4vYWN0ZW1hLWRlc2t0b3AvcHJvdmVyL19idWlsZC9kZWZhdWx0L2xpYnMvZW5naW5lL2pzYXBpLm1sIiwiL2RhdGEvVXNlcnMvcGFibG8vZGF0YS9Eb2N1bWVudHMvU2NvbGFpcmUvRmFjL0RvY3RvcmF0L2FjdGVtYS9wbHVnaW4vYWN0ZW1hLWRlc2t0b3AvcHJvdmVyL19idWlsZC9kZWZhdWx0L3NyYy9qc3Byb3Zlci5tbCIsIi9ob21lL3BhYmxvLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvc3RkX2V4aXQubWwiXSwibWFwcGluZ3MiOiI7Q0FDQyxTQUFVQTtXQUNGQzs7OztLQUNMQztPQUNFO1FBQ0M7VUFBc0JGLDhDQUVoQkc7UUFDSEM7SUFFUixTQUFTRDtNQUNQLElBQUlFLE9BQVNILFFBQVFJO01BQ3JCRCxvQkFBb0JBO2FBQ2JMLG9CQUNULENBYkQ7R0FjQ0E7Ozs7O2FBZk9PLHVCQUF1QkEsa0JBQW1CTjtJQ3FEbkQsU0FBU08sZ0JBQWdCQyxHQUFJQyxHQUFJQyxHQUFJQyxHQUFJQztNQUN2QyxHQUFJRCxNQUFNRjtPQUFJLElBQ0QsSUFBRkksSUFBT0EsS0FBS0QsSUFBS0MsSUFBS0gsR0FBR0MsS0FBS0UsS0FBS0wsR0FBR0MsS0FBS0k7O09BQy9DLElBQ00sSUFBRkEsRUFBSUQsSUFBS0MsT0FBUUEsSUFBS0gsR0FBR0MsS0FBS0UsS0FBS0wsR0FBR0MsS0FBS0k7TUFFdEQsUUFDRjtJQTRCQSxTQUFTQyxnQkFBZ0JDLE1BQU9DLElBQUtKLElBQUtLO01BQ3hDLElBQVUsSUFBRkMsSUFBT0EsSUFBSU4sSUFBS00sSUFBSSxNQUNwQkYsTUFBSUUsU0FBT0QsRUFFbkIsUUFDRjtJQXpFQSxTQUFTRSxlQUFnQkMsRUFBR0YsRUFBR047TUFDN0IsSUFBSUYsT0FBU1cs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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUNPeUlGenFCO087b0NBQ0FDO087b0NBQ0FDO087Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dDR25JQTRCO2M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUIyQmlSQTJzQzttQkExQ0FEO21CQS9FQUo7Ozs7Ozs7Z0I7OztZQW9hQW1GOzs7OztpQjs7Ozs7Ozs7MEJBaFBBcEU7OztZQTlDQUw7OzBDOzs7Ozs7Ozs7VWpDdU5JLG1CO09KL2ZGcU4sc0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztjSStmRTtlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUE7cUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0JHcFhKbjhDO00sb0JBQ0FDO00sb0JBQ0FDO007Ozs7aUI4Qm9HQXN1QztpQkEvRUFKOzs7dUM7VUFvYUFtRjs7Ozs7ZTs7OztzQkFoUEFwRTs7O01BN0JBSjs7OztpQkF4RUFQO2lCQS9FQUo7Ozs7O1k7O1VBb2FBbUY7Ozs7O2U7Ozs7OztzQkFoUEFwRTs7O01BN0JBSjs7OztpQkF4RUFQO2lCQS9FQUo7Ozt1QztVQW9hQW1GOzs7OztlOzs7Ozs7Ozs7c0JBaFBBcEU7OztNQTdCQUo7Ozs7aUJBeEVBUDtpQkEvRUFKOzs7OztZOztVQW9hQW1GOzs7O2dDOzs7Ozs7c0JBaFBBcEU7OztNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0NuQnpUQTFuQztPOzs7NkJBREFELEtBQ0FDO087Ozs7Ozs7Ozs7OztXQURBRDtXQUNBQzsyQjtXQUVBQztXQUNBQztXQUNBQzs7Ozs7Ozs7Ozs7Ozs7Tzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7VWQ4ZEk7OztjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBQTswQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCSjlmRm5CO007Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QVNELGdCQWJXalY7WUFhWCxjQUpPNTRGO2NBQVksT0FBWkE7dUJBQ1Usc0M3RGxPbkI4b0YsWTZEd05Pa1A7MkJBWXlDO1lBQzlDLHFCQUxZLFdBQUU7WUFLZCxjQU5nQmoxRjtjQUFJLHlDQUFKQSxvQkFBYTtZQU03QiwwQjtZQU5BO3VCQVJrQkE7YUFRbEI7YUFEUTtZQU9zQjtVQTlCcEMsb0JBS2VBO1lBQ1g7O2NBQ3lCOzRDQUZkQTtlQUVFO2VBQ2MsbUJBRHJCNjFGO2VBQ087NkJBQVBxRCxPQUNjO1lBSEUsb0IsT0F2bUJ4QjRSO1lBMm1CRztZQUF1QixrQkF2bEJ0QkksZ0JBdWxCc0IsT0FKcEJwMUMsSUFBS20vQixLQUFNWSxNQUltQztVQVZ0RDs7Ozs7MEJBRFVyeEYsMEJBaUNOO01DcnNCRztNO01DZ0JEO2EiLCJzb3VyY2VzQ29udGVudCI6W251bGwsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gQXJyYXlcblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9zdWIgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9zdWIgKGEsIGksIGxlbikge1xuICB2YXIgYTIgPSBuZXcgQXJyYXkobGVuKzEpO1xuICBhMlswXT0wO1xuICBmb3IodmFyIGkyID0gMSwgaTE9IGkrMTsgaTIgPD0gbGVuOyBpMisrLGkxKysgKXtcbiAgICBhMltpMl09YVtpMV07XG4gIH1cbiAgcmV0dXJuIGEyO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2FwcGVuZCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X2FwcGVuZChhMSwgYTIpIHtcbiAgdmFyIGwxID0gYTEubGVuZ3RoLCBsMiA9IGEyLmxlbmd0aDtcbiAgdmFyIGwgPSBsMStsMi0xXG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBhWzBdID0gMDtcbiAgdmFyIGkgPSAxLGogPSAxO1xuICBmb3IoO2k8bDE7aSsrKSBhW2ldPWExW2ldO1xuICBmb3IoO2k8bDtpKyssaisrKSBhW2ldPWEyW2pdO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9jb25jYXQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9jb25jYXQobCkge1xuICB2YXIgYSA9IFswXTtcbiAgd2hpbGUgKGwgIT09IDApIHtcbiAgICB2YXIgYiA9IGxbMV07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBiLmxlbmd0aDsgaSsrKSBhLnB1c2goYltpXSk7XG4gICAgbCA9IGxbMl07XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYmxpdFxuZnVuY3Rpb24gY2FtbF9hcnJheV9ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgaWYgKGkyIDw9IGkxKSB7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gbGVuOyBqKyspIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGogPSBsZW47IGogPj0gMTsgai0tKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRhcnJheV9ibGl0XG5mdW5jdGlvbiBjYW1sX2Zsb2F0YXJyYXlfYmxpdChhMSwgaTEsIGEyLCBpMiwgbGVuKSB7XG4gIGlmIChpMiA8PSBpMSkge1xuICAgIGZvciAodmFyIGogPSAxOyBqIDw9IGxlbjsgaisrKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBqID0gbGVuOyBqID49IDE7IGotLSkgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH07XG4gIHJldHVybiAwO1xufVxuXG4vLy8vLy8vLy8vLy8vIFBlcnZhc2l2ZVxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9zZXQgKG11dGFibGUsIGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfc2V0IChhcnJheSwgaW5kZXgsIG5ld3ZhbCkge1xuICBpZiAoKGluZGV4IDwgMCkgfHwgKGluZGV4ID49IGFycmF5Lmxlbmd0aCAtIDEpKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIGFycmF5W2luZGV4KzFdPW5ld3ZhbDsgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfZ2V0IG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfZ2V0IChhcnJheSwgaW5kZXgpIHtcbiAgaWYgKChpbmRleCA8IDApIHx8IChpbmRleCA+PSBhcnJheS5sZW5ndGggLSAxKSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJyYXlbaW5kZXgrMV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfZmlsbFxuZnVuY3Rpb24gY2FtbF9hcnJheV9maWxsKGFycmF5LCBvZnMsIGxlbiwgdil7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgYXJyYXlbb2ZzK2krMV0gPSB2O1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NoZWNrX2JvdW5kIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2NoZWNrX2JvdW5kIChhcnJheSwgaW5kZXgpIHtcbiAgaWYgKGluZGV4ID4+PiAwID49IGFycmF5Lmxlbmd0aCAtIDEpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21ha2VfdmVjdCBjb25zdCAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9tYWtlX3ZlY3QgKGxlbiwgaW5pdCkge1xuICBpZiAobGVuIDwgMCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgbGVuID0gbGVuICsgMSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF09MDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IGluaXQ7XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21ha2VfZmxvYXRfdmVjdCBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX21ha2VfZmxvYXRfdmVjdChsZW4pe1xuICBpZiAobGVuIDwgMCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgbGVuID0gbGVuICsgMSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF09MjU0O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gMDtcbiAgcmV0dXJuIGJcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRhcnJheV9jcmVhdGUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9mbG9hdGFycmF5X2NyZWF0ZShsZW4pe1xuICBpZiAobGVuIDwgMCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgbGVuID0gbGVuICsgMSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF09MjU0O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gMDtcbiAgcmV0dXJuIGJcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMC0yMDE0IErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIEFuIE9DYW1sIHN0cmluZyBpcyBhbiBvYmplY3Qgd2l0aCB0aHJlZSBmaWVsZHM6XG4vLyAtIHRhZyAndCdcbi8vIC0gbGVuZ3RoICdsJ1xuLy8gLSBjb250ZW50cyAnYydcbi8vXG4vLyBUaGUgY29udGVudHMgb2YgdGhlIHN0cmluZyBjYW4gYmUgZWl0aGVyIGEgSmF2YVNjcmlwdCBhcnJheSBvclxuLy8gYSBKYXZhU2NyaXB0IHN0cmluZy4gVGhlIGxlbmd0aCBvZiB0aGlzIHN0cmluZyBjYW4gYmUgbGVzcyB0aGFuIHRoZVxuLy8gbGVuZ3RoIG9mIHRoZSBPQ2FtbCBzdHJpbmcuIEluIHRoaXMgY2FzZSwgcmVtYWluaW5nIGJ5dGVzIGFyZVxuLy8gYXNzdW1lZCB0byBiZSB6ZXJvZXMuIEFycmF5cyBhcmUgbXV0YWJsZSBidXQgY29uc3VtZXMgbW9yZSBtZW1vcnlcbi8vIHRoYW4gc3RyaW5ncy4gQSBjb21tb24gcGF0dGVybiBpcyB0byBzdGFydCBmcm9tIGFuIGVtcHR5IHN0cmluZyBhbmRcbi8vIHByb2dyZXNzaXZlbHkgZmlsbCBpdCBmcm9tIHRoZSBzdGFydC4gUGFydGlhbCBzdHJpbmdzIG1ha2VzIGl0XG4vLyBwb3NzaWJsZSB0byBpbXBsZW1lbnQgdGhpcyBlZmZpY2llbnRseS5cbi8vXG4vLyBXaGVuIGNvbnZlcnRpbmcgdG8gYW5kIGZyb20gVVRGLTE2LCB3ZSBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgdGhlXG4vLyBzdHJpbmcgaXMgY29tcG9zZWQgb25seSBvZiBBU0NJSSBjaGFyYWN0ZXJzIChpbiB3aGljaCBjYXNlLCBub1xuLy8gY29udmVyc2lvbiBuZWVkcyB0byBiZSBwZXJmb3JtZWQpIG9yIG5vdC5cbi8vXG4vLyBUaGUgc3RyaW5nIHRhZyBjYW4gdGh1cyB0YWtlIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuLy8gICBmdWxsIHN0cmluZyAgICAgQllURSB8IFVOS05PV046ICAgICAgMFxuLy8gICAgICAgICAgICAgICAgICAgQllURSB8IEFTQ0lJOiAgICAgICAgOVxuLy8gICAgICAgICAgICAgICAgICAgQllURSB8IE5PVF9BU0NJSTogICAgOFxuLy8gICBzdHJpbmcgcHJlZml4ICAgUEFSVElBTDogICAgICAgICAgICAgMlxuLy8gICBhcnJheSAgICAgICAgICAgQVJSQVk6ICAgICAgICAgICAgICAgNFxuLy9cbi8vIE9uZSBjYW4gdXNlIGJpdCBtYXNraW5nIHRvIGRpc2NyaW1pbmF0ZSB0aGVzZSBkaWZmZXJlbnQgY2FzZXM6XG4vLyAgIGtub3duX2VuY29kaW5nKHgpID0geCY4XG4vLyAgIGlzX2FzY2lpKHgpID0gICAgICAgeCYxXG4vLyAgIGtpbmQoeCkgPSAgICAgICAgICAgeCY2XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9zdHJfcmVwZWF0KG4sIHMpIHtcbiAgaWYobiA9PSAwKSByZXR1cm4gXCJcIjtcbiAgaWYgKHMucmVwZWF0KSB7cmV0dXJuIHMucmVwZWF0KG4pO30gLy8gRUNNQXNjcmlwdCA2IGFuZCBGaXJlZm94IDI0K1xuICB2YXIgciA9IFwiXCIsIGwgPSAwO1xuICBmb3IoOzspIHtcbiAgICBpZiAobiAmIDEpIHIgKz0gcztcbiAgICBuID4+PSAxO1xuICAgIGlmIChuID09IDApIHJldHVybiByO1xuICAgIHMgKz0gcztcbiAgICBsKys7XG4gICAgaWYgKGwgPT0gOSkge1xuICAgICAgcy5zbGljZSgwLDEpOyAvLyBmbGF0dGVuIHRoZSBzdHJpbmdcbiAgICAgIC8vIHRoZW4sIHRoZSBmbGF0dGVuaW5nIG9mIHRoZSB3aG9sZSBzdHJpbmcgd2lsbCBiZSBmYXN0ZXIsXG4gICAgICAvLyBhcyBpdCB3aWxsIGJlIGNvbXBvc2VkIG9mIGxhcmdlciBwaWVjZXNcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzXG4vL1dlYWtkZWZcbi8vIFByZSBFQ01BU2NyaXB0IDUsIFthcHBseV0gd291bGQgbm90IHN1cHBvcnQgYXJyYXktbGlrZSBvYmplY3QuXG4vLyBJbiBzdWNoIHNldHVwLCBUeXBlZF9hcnJheSB3b3VsZCBiZSBpbXBsZW1lbnRlZCBhcyBwb2x5ZmlsbCwgYW5kIFtmLmFwcGx5XSB3b3VsZFxuLy8gZmFpbCBoZXJlLiBNYXJrIHRoZSBwcmltaXRpdmUgYXMgV2Vha2RlZiwgc28gdGhhdCBwZW9wbGUgY2FuIG92ZXJyaWRlIGl0IGVhc2lseS5cbmZ1bmN0aW9uIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyAoYSwgaSwgbGVuKSB7XG4gIHZhciBmID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbiAgaWYgKGkgPT0gMCAmJiBsZW4gPD0gNDA5NiAmJiBsZW4gPT0gYS5sZW5ndGgpIHJldHVybiBmLmFwcGx5IChudWxsLCBhKTtcbiAgdmFyIHMgPSBcIlwiO1xuICBmb3IgKDsgMCA8IGxlbjsgaSArPSAxMDI0LGxlbi09MTAyNClcbiAgICBzICs9IGYuYXBwbHkgKG51bGwsIGEuc2xpY2UoaSxpICsgTWF0aC5taW4obGVuLCAxMDI0KSkpO1xuICByZXR1cm4gcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF91dGY4X29mX3V0ZjE2XG5mdW5jdGlvbiBjYW1sX3V0Zjhfb2ZfdXRmMTYocykge1xuICBmb3IgKHZhciBiID0gXCJcIiwgdCA9IGIsIGMsIGQsIGkgPSAwLCBsID0gcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyAoaiA8IGwpICYmIChjID0gcy5jaGFyQ29kZUF0KGopKSA8IDB4ODA7IGorKyk7XG4gICAgICBpZiAoaiAtIGkgPiA1MTIpIHsgdC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7IGIgKz0gcy5zbGljZShpLCBqKSB9XG4gICAgICBlbHNlIHQgKz0gcy5zbGljZShpLCBqKTtcbiAgICAgIGlmIChqID09IGwpIGJyZWFrO1xuICAgICAgaSA9IGo7XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGMwIHwgKGMgPj4gNikpO1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweGQ4MDAgfHwgYyA+PSAweGRmZmYpIHtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGUwIHwgKGMgPj4gMTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gNikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfSBlbHNlIGlmIChjID49IDB4ZGJmZiB8fCBpICsgMSA9PSBsIHx8XG4gICAgICAgICAgICAgICAoZCA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGQgPiAweGRmZmYpIHtcbiAgICAgIC8vIFVubWF0Y2hlZCBzdXJyb2dhdGUgcGFpciwgcmVwbGFjZWQgYnkgXFx1ZmZmZCAocmVwbGFjZW1lbnQgY2hhcmFjdGVyKVxuICAgICAgdCArPSBcIlxceGVmXFx4YmZcXHhiZFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBpKys7XG4gICAgICBjID0gKGMgPDwgMTApICsgZCAtIDB4MzVmZGMwMDtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGYwIHwgKGMgPj4gMTgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gMTIpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiA2KSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9XG4gICAgaWYgKHQubGVuZ3RoID4gMTAyNCkge3Quc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiO31cbiAgfVxuICByZXR1cm4gYit0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIGNhbWxfdXRmMTZfb2ZfdXRmOChzKSB7XG4gIGZvciAodmFyIGIgPSBcIlwiLCB0ID0gXCJcIiwgYywgYzEsIGMyLCB2LCBpID0gMCwgbCA9IHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYzEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMxIDwgMHg4MCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyAoaiA8IGwpICYmIChjMSA9IHMuY2hhckNvZGVBdChqKSkgPCAweDgwOyBqKyspO1xuICAgICAgaWYgKGogLSBpID4gNTEyKSB7IHQuc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiOyBiICs9IHMuc2xpY2UoaSwgaikgfVxuICAgICAgZWxzZSB0ICs9IHMuc2xpY2UoaSwgaik7XG4gICAgICBpZiAoaiA9PSBsKSBicmVhaztcbiAgICAgIGkgPSBqO1xuICAgIH1cbiAgICB2ID0gMTtcbiAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSkge1xuICAgICAgYyA9IGMyICsgKGMxIDw8IDYpO1xuICAgICAgaWYgKGMxIDwgMHhlMCkge1xuICAgICAgICB2ID0gYyAtIDB4MzA4MDtcbiAgICAgICAgaWYgKHYgPCAweDgwKSB2ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYgPSAyO1xuICAgICAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSkge1xuICAgICAgICAgIGMgPSBjMiArIChjIDw8IDYpO1xuICAgICAgICAgIGlmIChjMSA8IDB4ZjApIHtcbiAgICAgICAgICAgIHYgPSBjIC0gMHhlMjA4MDtcbiAgICAgICAgICAgIGlmICgodiA8IDB4ODAwKSB8fCAoKHYgPj0gMHhkN2ZmKSAmJiAodiA8IDB4ZTAwMCkpKSB2ID0gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdiA9IDM7XG4gICAgICAgICAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSAmJlxuICAgICAgICAgICAgICAgIChjMSA8IDB4ZjUpKSB7XG4gICAgICAgICAgICAgIHYgPSBjMiAtIDB4M2M4MjA4MCArIChjIDw8IDYpO1xuICAgICAgICAgICAgICBpZiAodiA8IDB4MTAwMDAgfHwgdiA+IDB4MTBmZmZmKSB2ID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHYgPCA0KSB7IC8vIEludmFsaWQgc2VxdWVuY2VcbiAgICAgIGkgLT0gdjtcbiAgICAgIHQgKz0gXCJcXHVmZmZkXCI7XG4gICAgfSBlbHNlIGlmICh2ID4gMHhmZmZmKVxuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDdjMCArICh2ID4+IDEwKSwgMHhkYzAwICsgKHYgJiAweDNGRikpXG4gICAgZWxzZVxuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHYpO1xuICAgIGlmICh0Lmxlbmd0aCA+IDEwMjQpIHt0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjt9XG4gIH1cbiAgcmV0dXJuIGIrdDtcbn1cblxuLy9Qcm92aWRlczoganNvb19pc19hc2NpaVxuZnVuY3Rpb24ganNvb19pc19hc2NpaSAocykge1xuICAvLyBUaGUgcmVndWxhciBleHByZXNzaW9uIGdldHMgYmV0dGVyIGF0IGFyb3VuZCB0aGlzIHBvaW50IGZvciBhbGwgYnJvd3NlcnNcbiAgaWYgKHMubGVuZ3RoIDwgMjQpIHtcbiAgICAvLyBTcGlkZXJtb25rZXkgZ2V0cyBtdWNoIHNsb3dlciB3aGVuIHMubGVuZ3RoID49IDI0IChvbiA2NCBiaXQgYXJjaHMpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSBpZiAocy5jaGFyQ29kZUF0KGkpID4gMTI3KSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZVxuICAgIHJldHVybiAhL1teXFx4MDAtXFx4N2ZdLy50ZXN0KHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHN3aXRjaCAocy50ICYgNikge1xuICBkZWZhdWx0OiAvKiBQQVJUSUFMICovXG4gICAgaWYgKGkgPj0gcy5jLmxlbmd0aCkgcmV0dXJuIDA7XG4gIGNhc2UgMDogLyogQllURVMgKi9cbiAgICByZXR1cm4gcy5jLmNoYXJDb2RlQXQoaSk7XG4gIGNhc2UgNDogLyogQVJSQVkgKi9cbiAgICByZXR1cm4gcy5jW2ldXG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSwgYykge1xuICAvLyBUaGUgT0NhbWwgY29tcGlsZXIgdXNlcyBDaGFyLnVuc2FmZV9jaHIgb24gaW50ZWdlcnMgbGFyZ2VyIHRoYW4gMjU1IVxuICBjICY9IDB4ZmY7XG4gIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykge1xuICAgIGlmIChpID09IHMuYy5sZW5ndGgpIHtcbiAgICAgIHMuYyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlIChjKTtcbiAgICAgIGlmIChpICsgMSA9PSBzLmwpIHMudCA9IDA7IC8qQllURVMgfCBVTktPV04qL1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheSAocyk7XG4gIH1cbiAgcy5jW2ldID0gYztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ib3VuZF9lcnJvciAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldCAocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDE2KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSAxKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDEpO1xuICByZXR1cm4gKGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQxNihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMSkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKTtcbiAgcmV0dXJuIChiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0MzIocyxpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSAtIDMpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMSksXG4gICAgICBiMyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAyKSxcbiAgICAgIGI0ID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDMpO1xuICByZXR1cm4gKGI0IDw8IDI0IHwgYjMgPDwgMTYgfCBiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0MzIocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDMpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMSksXG4gICAgICBiMyA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDIpLFxuICAgICAgYjQgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAzKTtcbiAgcmV0dXJuIChiNCA8PCAyNCB8IGIzIDw8IDE2IHwgYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDY0KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSA3KSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IG5ldyBBcnJheSg4KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKyl7XG4gICAgYVs3IC0gal0gPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgaik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQ2NChzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gNykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IG5ldyBBcnJheSg4KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKyl7XG4gICAgYVs3IC0gal0gPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyBqKTtcbiAgfVxuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQgKHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0IChzLCBpLCBjKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldCAocywgaSwgYykge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDE2KHMsaSxpMTYpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAxKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMiA9IDB4RkYgJiBpMTYgPj4gOCxcbiAgICAgIGIxID0gMHhGRiAmIGkxNjtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMCwgYjEpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAxLCBiMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDE2KHMsaSxpMTYpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0MTZcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDE2XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQxNihzLGksaTE2KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0MTYocyxpLGkxNik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQzMihzLGksaTMyKXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjQgPSAweEZGICYgaTMyID4+IDI0LFxuICAgICAgYjMgPSAweEZGICYgaTMyID4+IDE2LFxuICAgICAgYjIgPSAweEZGICYgaTMyID4+IDgsXG4gICAgICBiMSA9IDB4RkYgJiBpMzI7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDAsIGIxKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMSwgYjIpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAyLCBiMyk7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDMsIGI0KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MzIocyxpLGkzMil7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXQzMlwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0MzJcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDMyKHMsaSxpMzIpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQzMihzLGksaTMyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDY0KHMsaSxpNjQpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSA3KSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gY2FtbF9pbnQ2NF90b19ieXRlcyhpNjQpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgNyAtIGosIGFbal0pO1xuICB9XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDY0KHMsaSxpNjQpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0NjRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDY0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQ2NChzLGksaTY0KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0NjQocyxpLGk2NCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0IChzLCBpLCBjKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpLCBjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZ1xuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGY4X29mX3V0ZjE2LCBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nIChzKSB7XG4gIHZhciB0YWcgPSA5IC8qIEJZVEVTIHwgQVNDSUkgKi87XG4gIGlmICghanNvb19pc19hc2NpaShzKSlcbiAgICB0YWcgPSA4IC8qIEJZVEVTIHwgTk9UX0FTQ0lJICovLCBzID0gY2FtbF91dGY4X29mX3V0ZjE2KHMpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXModGFnLCBzLCBzLmxlbmd0aCk7XG59XG5cblxuLy9Qcm92aWRlczogTWxCeXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcywganNvb19pc19hc2NpaSwgY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBNbEJ5dGVzICh0YWcsIGNvbnRlbnRzLCBsZW5ndGgpIHtcbiAgdGhpcy50PXRhZzsgdGhpcy5jPWNvbnRlbnRzOyB0aGlzLmw9bGVuZ3RoO1xufVxuTWxCeXRlcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICBzd2l0Y2ggKHRoaXMudCkge1xuICBjYXNlIDk6IC8qQllURVMgfCBBU0NJSSovXG4gICAgcmV0dXJuIHRoaXMuYztcbiAgZGVmYXVsdDpcbiAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHRoaXMpO1xuICBjYXNlIDA6IC8qQllURVMgfCBVTktPV04qL1xuICAgIGlmIChqc29vX2lzX2FzY2lpKHRoaXMuYykpIHtcbiAgICAgIHRoaXMudCA9IDk7IC8qQllURVMgfCBBU0NJSSovXG4gICAgICByZXR1cm4gdGhpcy5jO1xuICAgIH1cbiAgICB0aGlzLnQgPSA4OyAvKkJZVEVTIHwgTk9UX0FTQ0lJKi9cbiAgY2FzZSA4OiAvKkJZVEVTIHwgTk9UX0FTQ0lJKi9cbiAgICByZXR1cm4gdGhpcy5jO1xuICB9XG59O1xuTWxCeXRlcy5wcm90b3R5cGUudG9VdGYxNiA9IGZ1bmN0aW9uICgpe1xuICB2YXIgciA9IHRoaXMudG9TdHJpbmcoKTtcbiAgaWYodGhpcy50ID09IDkpIHJldHVybiByXG4gIHJldHVybiBjYW1sX3V0ZjE2X29mX3V0Zjgocik7XG59XG5NbEJ5dGVzLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uICgpe1xuICB2YXIgY29udGVudCA9IHRoaXMudCA9PSA0ID8gdGhpcy5jLnNsaWNlKCkgOiB0aGlzLmM7XG4gIHJldHVybiBuZXcgTWxCeXRlcyh0aGlzLnQsY29udGVudCx0aGlzLmwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cl9yZXBlYXQsIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlc1xuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyAocykge1xuICAvKiBBc3N1bWVzIG5vdCBCWVRFUyAqL1xuICBpZiAocy50ID09IDIgLyogUEFSVElBTCAqLylcbiAgICBzLmMgKz0gY2FtbF9zdHJfcmVwZWF0KHMubCAtIHMuYy5sZW5ndGgsICdcXDAnKVxuICBlbHNlXG4gICAgcy5jID0gY2FtbF9zdWJhcnJheV90b19qc2J5dGVzIChzLmMsIDAsIHMuYy5sZW5ndGgpO1xuICBzLnQgPSAwOyAvKkJZVEVTIHwgVU5LT1dOKi9cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkgKHMpIHtcbiAgLyogQXNzdW1lcyBub3QgQVJSQVkgKi9cbiAgaWYoZ2xvYmFsVGhpcy5VaW50OEFycmF5KSB7XG4gICAgdmFyIGEgPSBuZXcgZ2xvYmFsVGhpcy5VaW50OEFycmF5KHMubCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGEgPSBuZXcgQXJyYXkocy5sKTtcbiAgfVxuICB2YXIgYiA9IHMuYywgbCA9IGIubGVuZ3RoLCBpID0gMDtcbiAgZm9yICg7IGkgPCBsOyBpKyspIGFbaV0gPSBiLmNoYXJDb2RlQXQoaSk7XG4gIGZvciAobCA9IHMubDsgaSA8IGw7IGkrKykgYVtpXSA9IDA7XG4gIHMuYyA9IGE7XG4gIHMudCA9IDQ7IC8qIEFSUkFZICovXG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X29mX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9hcnJheV9vZl9ieXRlcyAocykge1xuICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzKTtcbiAgcmV0dXJuIHMuYztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9vZl9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfb2Zfc3RyaW5nIChzKSB7XG4gIHZhciBsID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgdmFyIGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKykgYVtpXSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocyxpKTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9zdHJpbmcobGVuKSB7XG4gIGlmKGxlbiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0cmluZy5jcmVhdGVcIik7XG4gIHJldHVybiBuZXcgTWxCeXRlcyhsZW4/Mjo5LFwiXCIsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9jcmVhdGVfc3RyaW5nKGxlbikge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHJpbmcuY3JlYXRlXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9ieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlcyxjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2J5dGVzKGxlbikge1xuICBpZiAobGVuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQnl0ZXMuY3JlYXRlXCIpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXMobGVuPzI6OSxcIlwiLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2FycmF5IChhKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhhLDAsYS5sZW5ndGgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9hcnJheVxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9hcnJheSAoYSkge1xuICByZXR1cm4gbmV3IE1sQnl0ZXMoNCxhLGEubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19jb21wYXJlIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfY29tcGFyZShzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDwgczIuYyk/LTE6KHMxLmMgPiBzMi5jKT8xOjA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19lcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2VxdWFsKHMxLCBzMikge1xuICBpZihzMSA9PT0gczIpIHJldHVybiAxO1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPT0gczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19lcXVhbFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbm90ZXF1YWwoczEsIHMyKSB7IHJldHVybiAxLWNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMik7IH1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2VxdWFsXG5mdW5jdGlvbiBjYW1sX2J5dGVzX25vdGVxdWFsKHMxLCBzMikgeyByZXR1cm4gMS1jYW1sX2J5dGVzX2VxdWFsKHMxLCBzMik7IH1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19sZXNzZXF1YWwgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8PSBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW4gbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19sZXNzdGhhbihzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDwgczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMyLHMxKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ncmVhdGVyZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMixzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dyZWF0ZXJ0aGFuXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19sZXNzdGhhblxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19sZXNzdGhhbihzMiwgczEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dyZWF0ZXJ0aGFuXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3N0aGFuXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dyZWF0ZXJ0aGFuKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzdGhhbihzMiwgczEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbGxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyX3JlcGVhdCwgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2ZpbGxfYnl0ZXMocywgaSwgbCwgYykge1xuICBpZiAobCA+IDApIHtcbiAgICBpZiAoaSA9PSAwICYmIChsID49IHMubCB8fCAocy50ID09IDIgLyogUEFSVElBTCAqLyAmJiBsID49IHMuYy5sZW5ndGgpKSkge1xuICAgICAgaWYgKGMgPT0gMCkge1xuICAgICAgICBzLmMgPSBcIlwiO1xuICAgICAgICBzLnQgPSAyOyAvKiBQQVJUSUFMICovXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzLmMgPSBjYW1sX3N0cl9yZXBlYXQgKGwsIFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICBzLnQgPSAobCA9PSBzLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHMudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkocyk7XG4gICAgICBmb3IgKGwgKz0gaTsgaSA8IGw7IGkrKykgcy5jW2ldID0gYztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmlsbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfZmlsbF9ieXRlc1xudmFyIGNhbWxfZmlsbF9zdHJpbmcgPSBjYW1sX2ZpbGxfYnl0ZXNcblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMsIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9ibGl0X2J5dGVzKHMxLCBpMSwgczIsIGkyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgaWYgKChpMiA9PSAwKSAmJlxuICAgICAgKGxlbiA+PSBzMi5sIHx8IChzMi50ID09IDIgLyogUEFSVElBTCAqLyAmJiBsZW4gPj0gczIuYy5sZW5ndGgpKSkge1xuICAgIHMyLmMgPSAoczEudCA9PSA0IC8qIEFSUkFZICovKT9cbiAgICAgIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhzMS5jLCBpMSwgbGVuKTpcbiAgICAgIChpMSA9PSAwICYmIHMxLmMubGVuZ3RoID09IGxlbik/czEuYzpzMS5jLnN1YnN0cihpMSwgbGVuKTtcbiAgICBzMi50ID0gKHMyLmMubGVuZ3RoID09IHMyLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIGlmIChzMi50ID09IDIgLyogUEFSVElBTCAqLyAmJiBpMiA9PSBzMi5jLmxlbmd0aCkge1xuICAgIHMyLmMgKz0gKHMxLnQgPT0gNCAvKiBBUlJBWSAqLyk/XG4gICAgICBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMoczEuYywgaTEsIGxlbik6XG4gICAgICAoaTEgPT0gMCAmJiBzMS5jLmxlbmd0aCA9PSBsZW4pP3MxLmM6czEuYy5zdWJzdHIoaTEsIGxlbik7XG4gICAgczIudCA9IChzMi5jLmxlbmd0aCA9PSBzMi5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gIH0gZWxzZSB7XG4gICAgaWYgKHMyLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMyKTtcbiAgICB2YXIgYzEgPSBzMS5jLCBjMiA9IHMyLmM7XG4gICAgaWYgKHMxLnQgPT0gNCAvKiBBUlJBWSAqLykge1xuICAgICAgaWYgKGkyIDw9IGkxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGMyIFtpMiArIGldID0gYzEgW2kxICsgaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIGMyIFtpMiArIGldID0gYzEgW2kxICsgaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsID0gTWF0aC5taW4gKGxlbiwgYzEubGVuZ3RoIC0gaTEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIGMyIFtpMiArIGldID0gYzEuY2hhckNvZGVBdChpMSArIGkpO1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykgYzIgW2kyICsgaV0gPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ibGl0X3N0cmluZyhhLGIsYyxkLGUpIHtcbiAgY2FtbF9ibGl0X2J5dGVzKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGEpLGIsYyxkLGUpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tbF9ieXRlc19sZW5ndGgocykgeyByZXR1cm4gcy5sIH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHJldHVybiBzLmNoYXJDb2RlQXQoaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYykge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfdW5zYWZlX3NldFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSB7XG4gIHJldHVybiBzLmxlbmd0aFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19jb21wYXJlIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbXBhcmUoczEsIHMyKSB7XG4gIHJldHVybiAoczEgPCBzMik/LTE6KHMxID4gczIpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZXF1YWwgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKSB7XG4gIGlmKHMxID09PSBzMikgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWwgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMxLCBzMikge1xuICByZXR1cm4gKHMxIDw9IHMyKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMxLCBzMikge1xuICByZXR1cm4gKHMxIDwgczIpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMocykge1xuICAocy50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocy5jKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh4KSB7IHJldHVybiB4IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHgpIHsgcmV0dXJuIHggfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGYxNl9vZl91dGY4XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpIHtcbiAgaWYoanNvb19pc19hc2NpaShzKSlcbiAgICByZXR1cm4gcztcbiAgcmV0dXJuIGNhbWxfdXRmMTZfb2ZfdXRmOChzKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGY4X29mX3V0ZjE2LCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChzKSB7XG4gIGlmIChqc29vX2lzX2FzY2lpKHMpKVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpXG4gIGVsc2UgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF91dGY4X29mX3V0ZjE2KHMpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMocykgeyByZXR1cm4gbmV3IE1sQnl0ZXMoMCxzLHMubGVuZ3RoKTsgfVxuXG5cbi8vIFRoZSBzZWN0aW9uIGJlbG93IHNob3VsZCBiZSB1c2VkIHdoZW4gdXNlLWpzLXN0cmluZz1mYWxzZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX3NldChzLGksYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSB7XG4gIHJldHVybiBjYW1sX21sX2J5dGVzX2xlbmd0aChzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19jb21wYXJlXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2NvbXBhcmVcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbXBhcmUoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2NvbXBhcmUoczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2VxdWFsXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19lcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfZXF1YWwoczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzZXF1YWxcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzdGhhblxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzdGhhblxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMocykgeyByZXR1cm4gcyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3N0cmluZyhzKSB7IHJldHVybiBzIH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpIHsgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhzKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpIHtcbiAgKHMudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gIHJldHVybiBzLmMgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpe1xuICByZXR1cm4gcy50b1V0ZjE2KClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmdcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nKHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX2J5dGVzXG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2lzX21sX2J5dGVzKHMpIHtcbiAgcmV0dXJuIChzIGluc3RhbmNlb2YgTWxCeXRlcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfYnl0ZXNfY29udGVudFxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9tbF9ieXRlc19jb250ZW50KHMpIHtcbiAgc3dpdGNoIChzLnQgJiA2KSB7XG4gIGRlZmF1bHQ6IC8qIFBBUlRJQUwgKi9cbiAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgcmV0dXJuIHMuYztcbiAgY2FzZSA0OlxuICAgIHJldHVybiBzLmNcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX3N0cmluZ1xuLy9SZXF1aXJlczoganNvb19pc19hc2NpaVxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2lzX21sX3N0cmluZyhzKSB7XG4gIHJldHVybiAodHlwZW9mIHMgPT09IFwic3RyaW5nXCIgJiYgIS9bXlxceDAwLVxceGZmXS8udGVzdChzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2lzX21sX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2lzX21sX2J5dGVzKHMpO1xufVxuXG4vLyBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBkZXByZWNhdGVkXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcocykgeyByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV3X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9uZXdfc3RyaW5nIChzKSB7IHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdG9fanNfc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfdG9fanNfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc190b19zdHJpbmcgKHMpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHMpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9SYWlzZSBleGNlcHRpb25cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9jb25zdGFudCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JhaXNlX2NvbnN0YW50ICh0YWcpIHsgdGhyb3cgdGFnOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQgKHRhZykgeyByZXR1cm4gdGFnOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9hcmcgKHRhZywgYXJnKSB7IHRocm93IFswLCB0YWcsIGFyZ107IH1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV93aXRoX2FyZ3MgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9hcmdzICh0YWcsIGFyZ3MpIHsgdGhyb3cgWzAsIHRhZ10uY29uY2F0KGFyZ3MpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcgKHRhZywgbXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9hcmcgKHRhZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhtc2cpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mYWlsd2l0aCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ZhaWx3aXRoIChtc2cpIHtcbiAgaWYoIWNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSlcbiAgICBjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmU9WzI0OCxjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiRmFpbHVyZVwiKSwtM107XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlLCBtc2cpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2ludmFsaWRfYXJndW1lbnQgKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuSW52YWxpZF9hcmd1bWVudCwgbXNnKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5FbmRfb2ZfZmlsZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuRGl2aXNpb25fYnlfemVybyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vdF9mb3VuZCAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5Ob3RfZm91bmQpOyB9XG5cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NhbGxfZ2VuIChjb25zdCwgc2hhbGxvdylcbi8vV2Vha2RlZlxuZnVuY3Rpb24gY2FtbF9jYWxsX2dlbihmLCBhcmdzKSB7XG4gIGlmKGYuZnVuKVxuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYuZnVuLCBhcmdzKTtcbiAgLy9GSVhNRSwgY2FuIGhhcHBlbiB3aXRoIHRvbyBtYW55IGFyZ3VtZW50c1xuICBpZih0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZjtcbiAgdmFyIG4gPSBmLmxlbmd0aCB8IDA7XG4gIGlmKG4gPT09IDApIHJldHVybiBmLmFwcGx5KG51bGwsYXJncyk7XG4gIHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGggfCAwO1xuICB2YXIgZCA9IG4gLSBhcmdzTGVuIHwgMDtcbiAgaWYgKGQgPT0gMClcbiAgICByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKTtcbiAgZWxzZSBpZiAoZCA8IDApIHtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLmFwcGx5KG51bGwsYXJncy5zbGljZSgwLG4pKSxhcmdzLnNsaWNlKG4pKTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCl7XG4gICAgICB2YXIgZXh0cmFfYXJncyA9IChhcmd1bWVudHMubGVuZ3RoID09IDApPzE6YXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHZhciBuYXJncyA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCtleHRyYV9hcmdzKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrICkgbmFyZ3NbaV0gPSBhcmdzW2ldO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIG5hcmdzW2FyZ3MubGVuZ3RoK2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgbmFyZ3MpXG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmFtZWRfdmFsdWVzXG52YXIgY2FtbF9uYW1lZF92YWx1ZXMgPSB7fTtcblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZSAoY29uc3QsY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZShubSx2KSB7XG4gIGNhbWxfbmFtZWRfdmFsdWVzW2NhbWxfanNieXRlc19vZl9zdHJpbmcobm0pXSA9IHY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlc1xuZnVuY3Rpb24gY2FtbF9uYW1lZF92YWx1ZShubSkge1xuICByZXR1cm4gY2FtbF9uYW1lZF92YWx1ZXNbbm1dXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbnZhciBjYW1sX2dsb2JhbF9kYXRhID0gWzBdO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX2dsb2JhbCAoY29uc3QsIHNoYWxsb3csIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9nbG9iYWwgKG4sIHYsIG5hbWVfb3B0KSB7XG4gIGlmKG5hbWVfb3B0ICYmIGdsb2JhbFRoaXMudG9wbGV2ZWxSZWxvYylcbiAgICBuID0gZ2xvYmFsVGhpcy50b3BsZXZlbFJlbG9jKG5hbWVfb3B0KTtcbiAgY2FtbF9nbG9iYWxfZGF0YVtuICsgMV0gPSB2O1xuICBpZihuYW1lX29wdCkgY2FtbF9nbG9iYWxfZGF0YVtuYW1lX29wdF0gPSB2O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9nbG9iYWxfZGF0YSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2dldF9nbG9iYWxfZGF0YSAoKSB7IHJldHVybiBjYW1sX2dsb2JhbF9kYXRhOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfcHJpbnRhYmxlIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfaXNfcHJpbnRhYmxlKGMpIHsgcmV0dXJuICsoYyA+IDMxICYmIGMgPCAxMjcpOyB9XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczoganNvb19mbG9vcl9sb2cyXG52YXIgbG9nMl9vayA9IE1hdGgubG9nMiAmJiBNYXRoLmxvZzIoMS4xMjM1NTgyMDkyODg5NDc0RSszMDcpID09IDEwMjBcbmZ1bmN0aW9uIGpzb29fZmxvb3JfbG9nMih4KSB7XG4gIGlmKGxvZzJfb2spIHJldHVybiBNYXRoLmZsb29yKE1hdGgubG9nMih4KSlcbiAgdmFyIGkgPSAwO1xuICBpZiAoeCA9PSAwKSByZXR1cm4gLUluZmluaXR5O1xuICBpZih4Pj0xKSB7d2hpbGUgKHg+PTIpIHt4Lz0yOyBpKyt9IH1cbiAgZWxzZSB7d2hpbGUgKHggPCAxKSB7eCo9MjsgaS0tfSB9O1xuICByZXR1cm4gaTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzIsIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpXG5mdW5jdGlvbiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKHgpIHtcbiAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgIGlmIChpc05hTih4KSlcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgxLCAwLCAweDdmZjApO1xuICAgIGlmICh4ID4gMClcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgwLCAwLCAweDdmZjApXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDAsIDAsIDB4ZmZmMClcbiAgfVxuICB2YXIgc2lnbiA9ICh4PT0wICYmIDEveCA9PSAtSW5maW5pdHkpPzB4ODAwMDooeD49MCk/MDoweDgwMDA7XG4gIGlmIChzaWduKSB4ID0gLXg7XG4gIC8vIEludDY0LmJpdHNfb2ZfZmxvYXQgMS4xMjM1NTgyMDkyODg5NDc0RSszMDcgPSAweDdmYjAwMDAwMDAwMDAwMDBMXG4gIC8vIHVzaW5nIE1hdGguTE9HMkUqTWF0aC5sb2coeCkgaW4gcGxhY2Ugb2YgTWF0aC5sb2cyIHJlc3VsdCBpbiBwcmVjaXNpb24gbG9zdFxuICB2YXIgZXhwID0ganNvb19mbG9vcl9sb2cyKHgpICsgMTAyMztcbiAgaWYgKGV4cCA8PSAwKSB7XG4gICAgZXhwID0gMDtcbiAgICB4IC89IE1hdGgucG93KDIsLTEwMjYpO1xuICB9IGVsc2Uge1xuICAgIHggLz0gTWF0aC5wb3coMixleHAtMTAyNyk7XG4gICAgaWYgKHggPCAxNikge1xuICAgICAgeCAqPSAyOyBleHAgLT0xOyB9XG4gICAgaWYgKGV4cCA9PSAwKSB7XG4gICAgICB4IC89IDI7IH1cbiAgfVxuICB2YXIgayA9IE1hdGgucG93KDIsMjQpO1xuICB2YXIgcjMgPSB4fDA7XG4gIHggPSAoeCAtIHIzKSAqIGs7XG4gIHZhciByMiA9IHh8MDtcbiAgeCA9ICh4IC0gcjIpICogaztcbiAgdmFyIHIxID0geHwwO1xuICByMyA9IChyMyAmMHhmKSB8IHNpZ24gfCBleHAgPDwgNDtcbiAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKHIxLCByMiwgcjMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMlxuZnVuY3Rpb24gY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0ICh4KSB7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBnbG9iYWxUaGlzLkZsb2F0MzJBcnJheSgxKTtcbiAgZmxvYXQzMmFbMF0gPSB4O1xuICB2YXIgaW50MzJhID0gbmV3IGdsb2JhbFRoaXMuSW50MzJBcnJheShmbG9hdDMyYS5idWZmZXIpO1xuICByZXR1cm4gaW50MzJhWzBdIHwgMDtcbn1cblxuLy9GUCBsaXRlcmFscyBjYW4gYmUgd3JpdHRlbiB1c2luZyB0aGUgaGV4YWRlY2ltYWxcbi8vbm90YXRpb24gMHg8bWFudGlzc2EgaW4gaGV4PnA8ZXhwb25lbnQ+IGZyb20gSVNPIEM5OS5cbi8vaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpL2pzLWhleGZsb2F0L2Jsb2IvbWFzdGVyL2hleGZsb2F0LmpzXG4vL1Byb3ZpZGVzOiBjYW1sX2hleHN0cmluZ19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcsIGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQgKHgsIHByZWMsIHN0eWxlKSB7XG4gIGlmICghaXNGaW5pdGUoeCkpIHtcbiAgICBpZiAoaXNOYU4oeCkpIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhcIm5hblwiKTtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKCh4ID4gMCk/XCJpbmZpbml0eVwiOlwiLWluZmluaXR5XCIpO1xuICB9XG4gIHZhciBzaWduID0gKHg9PTAgJiYgMS94ID09IC1JbmZpbml0eSk/MTooeD49MCk/MDoxO1xuICBpZihzaWduKSB4ID0gLXg7XG4gIHZhciBleHAgPSAwO1xuICBpZiAoeCA9PSAwKSB7IH1cbiAgZWxzZSBpZiAoeCA8IDEpIHtcbiAgICB3aGlsZSAoeCA8IDEgJiYgZXhwID4gLTEwMjIpICB7IHggKj0gMjsgZXhwLS0gfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlICh4ID49IDIpIHsgeCAvPSAyOyBleHArKyB9XG4gIH1cbiAgdmFyIGV4cF9zaWduID0gZXhwIDwgMCA/ICcnIDogJysnO1xuICB2YXIgc2lnbl9zdHIgPSAnJztcbiAgaWYgKHNpZ24pIHNpZ25fc3RyID0gJy0nXG4gIGVsc2Uge1xuICAgIHN3aXRjaChzdHlsZSl7XG4gICAgY2FzZSA0MyAvKiAnKycgKi86IHNpZ25fc3RyID0gJysnOyBicmVhaztcbiAgICBjYXNlIDMyIC8qICcgJyAqLzogc2lnbl9zdHIgPSAnICc7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAocHJlYyA+PSAwICYmIHByZWMgPCAxMykge1xuICAgIC8qIElmIGEgcHJlY2lzaW9uIGlzIGdpdmVuLCBhbmQgaXMgc21hbGwsIHJvdW5kIG1hbnRpc3NhIGFjY29yZGluZ2x5ICovXG4gICAgdmFyIGNzdCA9IE1hdGgucG93KDIscHJlYyAqIDQpO1xuICAgIHggPSBNYXRoLnJvdW5kKHggKiBjc3QpIC8gY3N0O1xuICB9XG4gIHZhciB4X3N0ciA9IHgudG9TdHJpbmcoMTYpO1xuICBpZihwcmVjID49IDApe1xuICAgIHZhciBpZHggPSB4X3N0ci5pbmRleE9mKCcuJyk7XG4gICAgaWYoaWR4PDApIHtcbiAgICAgIHhfc3RyICs9ICcuJyArIGNhbWxfc3RyX3JlcGVhdChwcmVjLCAnMCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBzaXplID0gaWR4KzErcHJlYztcbiAgICAgIGlmKHhfc3RyLmxlbmd0aCA8IHNpemUpXG4gICAgICAgIHhfc3RyICs9IGNhbWxfc3RyX3JlcGVhdChzaXplIC0geF9zdHIubGVuZ3RoLCAnMCcpO1xuICAgICAgZWxzZVxuICAgICAgICB4X3N0ciA9IHhfc3RyLnN1YnN0cigwLHNpemUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKHNpZ25fc3RyICsgJzB4JyArIHhfc3RyICsgJ3AnICsgZXhwX3NpZ24gKyBleHAudG9TdHJpbmcoMTApKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgKHgpIHtcbiAgdmFyIGxvID0geC5sbztcbiAgdmFyIG1pID0geC5taTtcbiAgdmFyIGhpID0geC5oaTtcbiAgdmFyIGV4cCA9IChoaSAmIDB4N2ZmZikgPj4gNDtcbiAgaWYgKGV4cCA9PSAyMDQ3KSB7XG4gICAgaWYgKChsb3xtaXwoaGkmMHhmKSkgPT0gMClcbiAgICAgIHJldHVybiAoaGkgJiAweDgwMDApPygtSW5maW5pdHkpOkluZmluaXR5O1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBOYU47XG4gIH1cbiAgdmFyIGsgPSBNYXRoLnBvdygyLC0yNCk7XG4gIHZhciByZXMgPSAobG8qayttaSkqaysoaGkmMHhmKTtcbiAgaWYgKGV4cCA+IDApIHtcbiAgICByZXMgKz0gMTY7XG4gICAgcmVzICo9IE1hdGgucG93KDIsZXhwLTEwMjcpO1xuICB9IGVsc2VcbiAgICByZXMgKj0gTWF0aC5wb3coMiwtMTAyNik7XG4gIGlmIChoaSAmIDB4ODAwMCkgcmVzID0gLSByZXM7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV4dGFmdGVyX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9pbnQ2NF9hZGQsIGNhbWxfaW50NjRfc3ViLGNhbWxfaW50NjRfb2ZfaW50MzJcbmZ1bmN0aW9uIGNhbWxfbmV4dGFmdGVyX2Zsb2F0ICh4LHkpIHtcbiAgaWYoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHJldHVybiBOYU47XG4gIGlmKHg9PXkpIHJldHVybiB5O1xuICBpZih4PT0wKXtcbiAgICBpZih5IDwgMClcbiAgICAgIHJldHVybiAtTWF0aC5wb3coMiwgLTEwNzQpXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIE1hdGgucG93KDIsIC0xMDc0KVxuICB9XG4gIHZhciBiaXRzID0gY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHgpO1xuICB2YXIgb25lID0gY2FtbF9pbnQ2NF9vZl9pbnQzMigxKTtcbiAgaWYgKCh4PHkpID09ICh4PjApKVxuICAgIGJpdHMgPSBjYW1sX2ludDY0X2FkZChiaXRzLCBvbmUpXG4gIGVsc2VcbiAgICBiaXRzID0gY2FtbF9pbnQ2NF9zdWIoYml0cywgb25lKVxuICByZXR1cm4gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGJpdHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RydW5jX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX3RydW5jX2Zsb2F0KHgpe1xuICByZXR1cm4gTWF0aC50cnVuYyh4KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMgKHgpIHtcbiAgdmFyIGludDMyYSA9IG5ldyBnbG9iYWxUaGlzLkludDMyQXJyYXkoMSk7XG4gIGludDMyYVswXSA9IHg7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBnbG9iYWxUaGlzLkZsb2F0MzJBcnJheShpbnQzMmEuYnVmZmVyKTtcbiAgcmV0dXJuIGZsb2F0MzJhWzBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NsYXNzaWZ5X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NsYXNzaWZ5X2Zsb2F0ICh4KSB7XG4gIGlmIChpc0Zpbml0ZSAoeCkpIHtcbiAgICBpZiAoTWF0aC5hYnMoeCkgPj0gMi4yMjUwNzM4NTg1MDcyMDE0ZS0zMDgpIHJldHVybiAwO1xuICAgIGlmICh4ICE9IDApIHJldHVybiAxO1xuICAgIHJldHVybiAyO1xuICB9XG4gIHJldHVybiBpc05hTih4KT80OjM7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX21vZGZfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbW9kZl9mbG9hdCAoeCkge1xuICBpZiAoaXNGaW5pdGUgKHgpKSB7XG4gICAgdmFyIG5lZyA9ICgxL3gpIDwgMDtcbiAgICB4ID0gTWF0aC5hYnMoeCk7XG4gICAgdmFyIGkgPSBNYXRoLmZsb29yICh4KTtcbiAgICB2YXIgZiA9IHggLSBpO1xuICAgIGlmIChuZWcpIHsgaSA9IC1pOyBmID0gLWY7IH1cbiAgICByZXR1cm4gWzAsIGYsIGldO1xuICB9XG4gIGlmIChpc05hTiAoeCkpIHJldHVybiBbMCwgTmFOLCBOYU5dO1xuICByZXR1cm4gWzAsIDEveCwgeF07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2xkZXhwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xkZXhwX2Zsb2F0ICh4LGV4cCkge1xuICBleHAgfD0gMDtcbiAgaWYgKGV4cCA+IDEwMjMpIHtcbiAgICBleHAgLT0gMTAyMztcbiAgICB4ICo9IE1hdGgucG93KDIsIDEwMjMpO1xuICAgIGlmIChleHAgPiAxMDIzKSB7ICAvLyBpbiBjYXNlIHggaXMgc3Vibm9ybWFsXG4gICAgICBleHAgLT0gMTAyMztcbiAgICAgIHggKj0gTWF0aC5wb3coMiwgMTAyMyk7XG4gICAgfVxuICB9XG4gIGlmIChleHAgPCAtMTAyMykge1xuICAgIGV4cCArPSAxMDIzO1xuICAgIHggKj0gTWF0aC5wb3coMiwgLTEwMjMpO1xuICB9XG4gIHggKj0gTWF0aC5wb3coMiwgZXhwKTtcbiAgcmV0dXJuIHg7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ZyZXhwX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzJcbmZ1bmN0aW9uIGNhbWxfZnJleHBfZmxvYXQgKHgpIHtcbiAgaWYgKCh4ID09IDApIHx8ICFpc0Zpbml0ZSh4KSkgcmV0dXJuIFswLCB4LCAwXTtcbiAgdmFyIG5lZyA9IHggPCAwO1xuICBpZiAobmVnKSB4ID0gLSB4O1xuICB2YXIgZXhwID0gTWF0aC5tYXgoLTEwMjMsIGpzb29fZmxvb3JfbG9nMih4KSArIDEpO1xuICB4ICo9IE1hdGgucG93KDIsLWV4cCk7XG4gIHdoaWxlICh4IDwgMC41KSB7XG4gICAgeCAqPSAyO1xuICAgIGV4cC0tO1xuICB9XG4gIHdoaWxlICh4ID49IDEpIHtcbiAgICB4ICo9IDAuNTtcbiAgICBleHArKztcbiAgfVxuICBpZiAobmVnKSB4ID0gLSB4O1xuICByZXR1cm4gWzAsIHgsIGV4cF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfY29tcGFyZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9mbG9hdF9jb21wYXJlICh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSByZXR1cm4gMDtcbiAgaWYgKHggPCB5KSByZXR1cm4gLTE7XG4gIGlmICh4ID4geSkgcmV0dXJuIDE7XG4gIGlmICh4ID09PSB4KSByZXR1cm4gMTtcbiAgaWYgKHkgPT09IHkpIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29weXNpZ25fZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29weXNpZ25fZmxvYXQgKHgsIHkpIHtcbiAgaWYgKHkgPT0gMCkgeSA9IDEgLyB5O1xuICB4ID0gTWF0aC5hYnMoeCk7XG4gIHJldHVybiAoeSA8IDApPygteCk6eDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zaWduYml0X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3NpZ25iaXRfZmxvYXQoeCkge1xuICBpZiAoeCA9PSAwKSB4ID0gMSAvIHg7XG4gIHJldHVybiAoeCA8IDApPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9leHBtMV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9leHBtMV9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5leHBtMSh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9leHAyX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2V4cDJfZmxvYXQoeCkgeyByZXR1cm4gTWF0aC5wb3coMiwgeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMXBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMXBfZmxvYXQoeCkgeyByZXR1cm4gTWF0aC5sb2cxcCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9sb2cyX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzJfZmxvYXQoeCkgeyByZXR1cm4gTWF0aC5sb2cyKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2h5cG90X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2h5cG90X2Zsb2F0ICh4LCB5KSB7IHJldHVybiBNYXRoLmh5cG90KHgsIHkpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xvZzEwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzEwX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmxvZzEwKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2Nvc2hfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29zaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5jb3NoKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2Fjb3NoX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2Fjb3NoX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmFjb3NoKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3NpbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc2luaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5zaW5oKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2FzaW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2FzaW5oX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmFzaW5oKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3RhbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfdGFuaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC50YW5oKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2F0YW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2F0YW5oX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmF0YW5oKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3JvdW5kX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3JvdW5kX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2NicnRfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY2JydF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5jYnJ0KHgpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXJmX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2VyZl9mbG9hdCh4KSB7XG4gIHZhciBhMSA9IDAuMjU0ODI5NTkyO1xuICB2YXIgYTIgPSAtMC4yODQ0OTY3MzY7XG4gIHZhciBhMyA9IDEuNDIxNDEzNzQxO1xuICB2YXIgYTQgPSAtMS40NTMxNTIwMjc7XG4gIHZhciBhNSA9IDEuMDYxNDA1NDI5O1xuICB2YXIgcCA9IDAuMzI3NTkxMTtcblxuICB2YXIgc2lnbiA9IDE7XG4gIGlmICh4IDwgMCkge1xuICAgIHNpZ24gPSAtMTtcbiAgfVxuICB4ID0gTWF0aC5hYnMoeCk7XG4gIHZhciB0ID0gMS4wIC8gKDEuMCArIHAgKiB4KTtcbiAgdmFyIHkgPSAxLjAgLSAoKCgoYTUgKiB0ICsgYTQpICogdCArIGEzKSAqIHQgKyBhMikgKiB0ICsgYTEpICogdCAqIE1hdGguZXhwKC14ICogeCk7XG5cbiAgcmV0dXJuIHNpZ24gKiB5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VyZmNfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfZXJmX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2VyZmNfZmxvYXQoeCkge1xuICByZXR1cm4gMSAtIGNhbWxfZXJmX2Zsb2F0KHgpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZm1hX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZtYV9mbG9hdCh4LCB5LCB6KSB7XG4gIHZhciBTUExJVCA9IE1hdGgucG93KDIsIDI3KSArIDE7XG4gIHZhciBNSU5fVkFMVUUgPSBNYXRoLnBvdygyLCAtMTAyMik7XG4gIHZhciBFUFNJTE9OID0gTWF0aC5wb3coMiwgLTUyKTtcbiAgdmFyIEMgPSA0MTY7XG4gIHZhciBBID0gTWF0aC5wb3coMiwgK0MpO1xuICB2YXIgQiA9IE1hdGgucG93KDIsIC1DKTtcblxuICBmdW5jdGlvbiBtdWx0aXBseSAoYSwgYikge1xuICAgIHZhciBhdCA9IFNQTElUICogYTtcbiAgICB2YXIgYWhpID0gYXQgLSAoYXQgLSBhKTtcbiAgICB2YXIgYWxvID0gYSAtIGFoaTtcbiAgICB2YXIgYnQgPSBTUExJVCAqIGI7XG4gICAgdmFyIGJoaSA9IGJ0IC0gKGJ0IC0gYik7XG4gICAgdmFyIGJsbyA9IGIgLSBiaGk7XG4gICAgdmFyIHAgPSBhICogYjtcbiAgICB2YXIgZSA9ICgoYWhpICogYmhpIC0gcCkgKyBhaGkgKiBibG8gKyBhbG8gKiBiaGkpICsgYWxvICogYmxvO1xuICAgIHJldHVybiB7XG4gICAgICBwOiBwLFxuICAgICAgZTogZVxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gYWRkIChhLCBiKSB7XG4gICAgdmFyIHMgPSBhICsgYjtcbiAgICB2YXIgdiA9IHMgLSBhO1xuICAgIHZhciBlID0gKGEgLSAocyAtIHYpKSArIChiIC0gdik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHM6IHMsXG4gICAgICBlOiBlXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBhZGp1c3QgKHgsIHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCAmJiB5ICE9PSAwICYmIFNQTElUICogeCAtIChTUExJVCAqIHggLSB4KSA9PT0geCA/IHggKiAoMSArICh4IDwgMCA/IC0xIDogKzEpICogKHkgPCAwID8gLTEgOiArMSkgKiBFUFNJTE9OKSA6IHg7XG4gIH07XG5cbiAgaWYgKHggPT09IDAgfHwgeCAhPT0geCB8fCB4ID09PSArMSAvIDAgfHwgeCA9PT0gLTEgLyAwIHx8XG4gICAgICB5ID09PSAwIHx8IHkgIT09IHkgfHwgeSA9PT0gKzEgLyAwIHx8IHkgPT09IC0xIC8gMCkge1xuICAgIHJldHVybiB4ICogeSArIHo7XG4gIH1cbiAgaWYgKHogPT09IDApIHtcbiAgICByZXR1cm4geCAqIHk7XG4gIH1cbiAgaWYgKHogIT09IHogfHwgeiA9PT0gKzEgLyAwIHx8IHogPT09IC0xIC8gMCkge1xuICAgIHJldHVybiB6O1xuICB9XG5cbiAgdmFyIHNjYWxlID0gMTtcbiAgd2hpbGUgKE1hdGguYWJzKHgpID4gQSkge1xuICAgIHNjYWxlICo9IEE7XG4gICAgeCAqPSBCO1xuICB9XG4gIHdoaWxlIChNYXRoLmFicyh5KSA+IEEpIHtcbiAgICBzY2FsZSAqPSBBO1xuICAgIHkgKj0gQjtcbiAgfVxuICBpZiAoc2NhbGUgPT09IDEgLyAwKSB7XG4gICAgcmV0dXJuIHggKiB5ICogc2NhbGU7XG4gIH1cbiAgd2hpbGUgKE1hdGguYWJzKHgpIDwgQikge1xuICAgIHNjYWxlICo9IEI7XG4gICAgeCAqPSBBO1xuICB9XG4gIHdoaWxlIChNYXRoLmFicyh5KSA8IEIpIHtcbiAgICBzY2FsZSAqPSBCO1xuICAgIHkgKj0gQTtcbiAgfVxuICBpZiAoc2NhbGUgPT09IDApIHtcbiAgICByZXR1cm4gejtcbiAgfVxuXG4gIHZhciB4cyA9IHg7XG4gIHZhciB5cyA9IHk7XG4gIHZhciB6cyA9IHogLyBzY2FsZTtcblxuICBpZiAoTWF0aC5hYnMoenMpID4gTWF0aC5hYnMoeHMgKiB5cykgKiA0IC8gRVBTSUxPTikge1xuICAgIHJldHVybiB6O1xuICB9XG4gIGlmIChNYXRoLmFicyh6cykgPCBNYXRoLmFicyh4cyAqIHlzKSAqIEVQU0lMT04gLyA0ICogRVBTSUxPTiAvIDQpIHtcbiAgICB6cyA9ICh6IDwgMCA/IC0xIDogKzEpICogTUlOX1ZBTFVFO1xuICB9XG5cbiAgdmFyIHh5ID0gbXVsdGlwbHkoeHMsIHlzKTtcbiAgdmFyIHMgPSBhZGQoeHkucCwgenMpO1xuICB2YXIgdSA9IGFkZCh4eS5lLCBzLmUpO1xuICB2YXIgaSA9IGFkZChzLnMsIHUucyk7XG5cbiAgdmFyIGYgPSBpLnMgKyBhZGp1c3QoaS5lLCB1LmUpO1xuICBpZiAoZiA9PT0gMCkge1xuICAgIHJldHVybiBmO1xuICB9XG5cbiAgdmFyIGZzID0gZiAqIHNjYWxlO1xuICBpZiAoTWF0aC5hYnMoZnMpID4gTUlOX1ZBTFVFKSB7XG4gICAgcmV0dXJuIGZzO1xuICB9XG5cbiAgLy8gSXQgaXMgcG9zc2libGUgdGhhdCB0aGVyZSB3YXMgZXh0cmEgcm91bmRpbmcgZm9yIGEgZGVub3JtYWxpemVkIHZhbHVlLlxuICByZXR1cm4gZnMgKyBhZGp1c3QoZiAtIGZzIC8gc2NhbGUsIGkuZSkgKiBzY2FsZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9mbG9hdCAoZm10LCB4KSB7XG4gIGZ1bmN0aW9uIHRvRml4ZWQoeCxkcCkge1xuICAgIGlmIChNYXRoLmFicyh4KSA8IDEuMCkge1xuICAgICAgcmV0dXJuIHgudG9GaXhlZChkcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlID0gcGFyc2VJbnQoeC50b1N0cmluZygpLnNwbGl0KCcrJylbMV0pO1xuICAgICAgaWYgKGUgPiAyMCkge1xuICAgICAgICBlIC09IDIwO1xuICAgICAgICB4IC89IE1hdGgucG93KDEwLGUpO1xuICAgICAgICB4ICs9IChuZXcgQXJyYXkoZSsxKSkuam9pbignMCcpO1xuICAgICAgICBpZihkcCA+IDApIHtcbiAgICAgICAgICB4ID0geCArICcuJyArIChuZXcgQXJyYXkoZHArMSkpLmpvaW4oJzAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICAgIH1cbiAgICAgIGVsc2UgcmV0dXJuIHgudG9GaXhlZChkcClcbiAgICB9XG4gIH1cbiAgdmFyIHMsIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICB2YXIgcHJlYyA9IChmLnByZWMgPCAwKT82OmYucHJlYztcbiAgaWYgKHggPCAwIHx8ICh4ID09IDAgJiYgMS94ID09IC1JbmZpbml0eSkpIHsgZi5zaWduID0gLTE7IHggPSAteDsgfVxuICBpZiAoaXNOYU4oeCkpIHsgcyA9IFwibmFuXCI7IGYuZmlsbGVyID0gJyAnOyB9XG4gIGVsc2UgaWYgKCFpc0Zpbml0ZSh4KSkgeyBzID0gXCJpbmZcIjsgZi5maWxsZXIgPSAnICc7IH1cbiAgZWxzZVxuICAgIHN3aXRjaCAoZi5jb252KSB7XG4gICAgY2FzZSAnZSc6XG4gICAgICB2YXIgcyA9IHgudG9FeHBvbmVudGlhbChwcmVjKTtcbiAgICAgIC8vIGV4cG9uZW50IHNob3VsZCBiZSBhdCBsZWFzdCB0d28gZGlnaXRzXG4gICAgICB2YXIgaSA9IHMubGVuZ3RoO1xuICAgICAgaWYgKHMuY2hhckF0KGkgLSAzKSA9PSAnZScpXG4gICAgICAgIHMgPSBzLnNsaWNlICgwLCBpIC0gMSkgKyAnMCcgKyBzLnNsaWNlIChpIC0gMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmJzpcbiAgICAgIHMgPSB0b0ZpeGVkKHgsIHByZWMpOyBicmVhaztcbiAgICBjYXNlICdnJzpcbiAgICAgIHByZWMgPSBwcmVjP3ByZWM6MTtcbiAgICAgIHMgPSB4LnRvRXhwb25lbnRpYWwocHJlYyAtIDEpO1xuICAgICAgdmFyIGogPSBzLmluZGV4T2YoJ2UnKTtcbiAgICAgIHZhciBleHAgPSArcy5zbGljZShqICsgMSk7XG4gICAgICBpZiAoZXhwIDwgLTQgfHwgeCA+PSAxZTIxIHx8IHgudG9GaXhlZCgwKS5sZW5ndGggPiBwcmVjKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgdmFyIGkgPSBqIC0gMTsgd2hpbGUgKHMuY2hhckF0KGkpID09ICcwJykgaS0tO1xuICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gJy4nKSBpLS07XG4gICAgICAgIHMgPSBzLnNsaWNlKDAsIGkgKyAxKSArIHMuc2xpY2Uoaik7XG4gICAgICAgIGkgPSBzLmxlbmd0aDtcbiAgICAgICAgaWYgKHMuY2hhckF0KGkgLSAzKSA9PSAnZScpXG4gICAgICAgICAgcyA9IHMuc2xpY2UgKDAsIGkgLSAxKSArICcwJyArIHMuc2xpY2UgKGkgLSAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcCA9IHByZWM7XG4gICAgICAgIGlmIChleHAgPCAwKSB7IHAgLT0gZXhwICsgMTsgcyA9IHgudG9GaXhlZChwKTsgfVxuICAgICAgICBlbHNlIHdoaWxlIChzID0geC50b0ZpeGVkKHApLCBzLmxlbmd0aCA+IHByZWMgKyAxKSBwLS07XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xuICAgICAgICAgIHZhciBpID0gcy5sZW5ndGggLSAxOyB3aGlsZSAocy5jaGFyQXQoaSkgPT0gJzAnKSBpLS07XG4gICAgICAgICAgaWYgKHMuY2hhckF0KGkpID09ICcuJykgaS0tO1xuICAgICAgICAgIHMgPSBzLnNsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9vZl9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9mbG9hdF9vZl9zdHJpbmcocykge1xuICB2YXIgcmVzO1xuICBzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKVxuICByZXMgPSArcztcbiAgaWYgKChzLmxlbmd0aCA+IDApICYmIChyZXMgPT09IHJlcykpIHJldHVybiByZXM7XG4gIHMgPSBzLnJlcGxhY2UoL18vZyxcIlwiKTtcbiAgcmVzID0gK3M7XG4gIGlmICgoKHMubGVuZ3RoID4gMCkgJiYgKHJlcyA9PT0gcmVzKSkgfHwgL15bKy1dP25hbiQvaS50ZXN0KHMpKSByZXR1cm4gcmVzO1xuICB2YXIgbSA9IC9eICooWystXT8pMHgoWzAtOWEtZl0rKVxcLj8oWzAtOWEtZl0qKShwKFsrLV0/WzAtOV0rKSk/L2kuZXhlYyhzKTtcbiAgLy8gICAgICAgICAgMSAgICAgICAgMiAgICAgICAgICAgICAzICAgICAgICAgICA1XG4gIGlmKG0pe1xuICAgIHZhciBtMyA9IG1bM10ucmVwbGFjZSgvMCskLywnJyk7XG4gICAgdmFyIG1hbnRpc3NhID0gcGFyc2VJbnQobVsxXSArIG1bMl0gKyBtMywgMTYpO1xuICAgIHZhciBleHBvbmVudCA9IChtWzVdfDApIC0gNCptMy5sZW5ndGg7XG4gICAgcmVzID0gbWFudGlzc2EgKiBNYXRoLnBvdygyLCBleHBvbmVudCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZigvXlxcKz9pbmYoaW5pdHkpPyQvaS50ZXN0KHMpKSByZXR1cm4gSW5maW5pdHk7XG4gIGlmKC9eLWluZihpbml0eSk/JC9pLnRlc3QocykpIHJldHVybiAtSW5maW5pdHk7XG4gIGNhbWxfZmFpbHdpdGgoXCJmbG9hdF9vZl9zdHJpbmdcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZmZzZXRcbnZhciBjYW1sX2ludDY0X29mZnNldCA9IE1hdGgucG93KDIsIC0yNCk7XG5cbi8vUHJvdmlkZXM6IE1sSW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0LCBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBNbEludDY0IChsbyxtaSxoaSkge1xuICB0aGlzLmxvID0gbG8gJiAweGZmZmZmZjtcbiAgdGhpcy5taSA9IG1pICYgMHhmZmZmZmY7XG4gIHRoaXMuaGkgPSBoaSAmIDB4ZmZmZjtcbn1cbk1sSW50NjQucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gXCJfalwiXG5NbEludDY0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sbyx0aGlzLm1pLHRoaXMuaGkpO1xufVxuXG5NbEludDY0LnByb3RvdHlwZS51Y29tcGFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gIGlmICh0aGlzLmhpID4geC5oaSkgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmhpIDwgeC5oaSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5taSA+IHgubWkpIHJldHVybiAxO1xuICBpZiAodGhpcy5taSA8IHgubWkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubG8gPiB4LmxvKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubG8gPCB4LmxvKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBoaSA9IHRoaXMuaGkgPDwgMTY7XG4gIHZhciB4aGkgPSB4LmhpIDw8IDE2O1xuICBpZiAoaGkgPiB4aGkpIHJldHVybiAxO1xuICBpZiAoaGkgPCB4aGkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubWkgPiB4Lm1pKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubWkgPCB4Lm1pKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLmxvID4geC5sbykgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmxvIDwgeC5sbykgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxvID0gLSB0aGlzLmxvO1xuICB2YXIgbWkgPSAtIHRoaXMubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSAtIHRoaXMuaGkgKyAobWkgPj4gMjQpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbG8gPSB0aGlzLmxvICsgeC5sbztcbiAgdmFyIG1pID0gdGhpcy5taSArIHgubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSB0aGlzLmhpICsgeC5oaSArIChtaSA+PiAyNCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gLSB4LmxvO1xuICB2YXIgbWkgPSB0aGlzLm1pIC0geC5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IHRoaXMuaGkgLSB4LmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGxvID0gdGhpcy5sbyAqIHgubG87XG4gIHZhciBtaSA9ICgobG8gKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArIHRoaXMubWkgKiB4LmxvICsgdGhpcy5sbyAqIHgubWk7XG4gIHZhciBoaSA9ICgobWkgKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArIHRoaXMuaGkgKiB4LmxvICsgdGhpcy5taSAqIHgubWkgKyB0aGlzLmxvICogeC5oaTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMubG98dGhpcy5taXx0aGlzLmhpKSA9PSAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAodGhpcy5oaSA8PCAxNikgPCAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG8gJiB4LmxvLCB0aGlzLm1pICYgeC5taSwgdGhpcy5oaSAmIHguaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sb3x4LmxvLCB0aGlzLm1pfHgubWksIHRoaXMuaGl8eC5oaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sb154LmxvLCB0aGlzLm1pXngubWksIHRoaXMuaGleeC5oaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9sZWZ0ID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHRoaXM7XG4gIGlmIChzIDwgMjQpIHtcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKHRoaXMubG8gPDwgcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLm1pIDw8IHMpIHwgKHRoaXMubG8gPj4gKDI0IC0gcykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuaGkgPDwgcykgfCAodGhpcy5taSA+PiAoMjQgLSBzKSkpO1xuICB9XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0ICgwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sbyA8PCAocyAtIDI0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLm1pIDw8IChzIC0gMjQpKSB8ICh0aGlzLmxvID4+ICg0OCAtIHMpKSk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCgwLCAwLCB0aGlzLmxvIDw8IChzIC0gNDgpKVxufVxuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfcmlnaHRfdW5zaWduZWQgPSBmdW5jdGlvbiAocykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKHMgPCAyNClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubG8gPj4gcykgfCAodGhpcy5taSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5taSA+PiBzKSB8ICh0aGlzLmhpIDw8ICgyNCAtIHMpKSxcbiAgICAgICh0aGlzLmhpID4+IHMpKTtcbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubWkgPj4gKHMgLSAyNCkpIHwgKHRoaXMuaGkgPDwgKDQ4IC0gcykpLFxuICAgICAgKHRoaXMuaGkgPj4gKHMgLSAyNCkpLFxuICAgICAgMCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCAodGhpcy5oaSA+PiAocyAtIDQ4KSwgMCwgMCk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9yaWdodCA9IGZ1bmN0aW9uIChzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB0aGlzO1xuICB2YXIgaCA9ICh0aGlzLmhpIDw8IDE2KSA+PiAxNjtcbiAgaWYgKHMgPCAyNClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubG8gPj4gcykgfCAodGhpcy5taSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5taSA+PiBzKSB8IChoIDw8ICgyNCAtIHMpKSxcbiAgICAgICgodGhpcy5oaSA8PCAxNikgPj4gcykgPj4+IDE2KTtcbiAgdmFyIHNpZ24gPSAodGhpcy5oaSA8PCAxNikgPj4gMzE7XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLm1pID4+IChzIC0gMjQpKSB8ICh0aGlzLmhpIDw8ICg0OCAtIHMpKSxcbiAgICAgICh0aGlzLmhpIDw8IDE2KSA+PiAocyAtIDI0KSA+PiAxNixcbiAgICAgIHNpZ24gJiAweGZmZmYpO1xuICByZXR1cm4gbmV3IE1sSW50NjQgKCh0aGlzLmhpIDw8IDE2KSA+PiAocyAtIDMyKSwgc2lnbiwgc2lnbik7XG59XG5NbEludDY0LnByb3RvdHlwZS5sc2wxID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhpID0gKHRoaXMuaGkgPDwgMSkgfCAodGhpcy5taSA+PiAyMyk7XG4gIHRoaXMubWkgPSAoKHRoaXMubWkgPDwgMSkgfCAodGhpcy5sbyA+PiAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMubG8gPSAodGhpcy5sbyA8PCAxKSAmIDB4ZmZmZmZmO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubHNyMSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5sbyA9ICgodGhpcy5sbyA+Pj4gMSkgfCAodGhpcy5taSA8PCAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMubWkgPSAoKHRoaXMubWkgPj4+IDEpIHwgKHRoaXMuaGkgPDwgMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLmhpID0gdGhpcy5oaSA+Pj4gMTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnVkaXZtb2QgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIG1vZHVsdXMgPSB0aGlzLmNvcHkoKTtcbiAgdmFyIGRpdmlzb3IgPSB4LmNvcHkoKTtcbiAgdmFyIHF1b3RpZW50ID0gbmV3IE1sSW50NjQoMCwwLDApO1xuICB3aGlsZSAobW9kdWx1cy51Y29tcGFyZShkaXZpc29yKSA+IDApIHtcbiAgICBvZmZzZXQrKztcbiAgICBkaXZpc29yLmxzbDEoKTtcbiAgfVxuICB3aGlsZSAob2Zmc2V0ID49IDApIHtcbiAgICBvZmZzZXQgLS07XG4gICAgcXVvdGllbnQubHNsMSgpO1xuICAgIGlmIChtb2R1bHVzLnVjb21wYXJlKGRpdmlzb3IpID49IDApIHtcbiAgICAgIHF1b3RpZW50LmxvICsrO1xuICAgICAgbW9kdWx1cyA9IG1vZHVsdXMuc3ViKGRpdmlzb3IpO1xuICAgIH1cbiAgICBkaXZpc29yLmxzcjEoKTtcbiAgfVxuICByZXR1cm4geyBxdW90aWVudCA6IHF1b3RpZW50LCBtb2R1bHVzIDogbW9kdWx1cyB9O1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gKHkpXG57XG4gIHZhciB4ID0gdGhpcztcbiAgaWYgKHkuaXNaZXJvKCkpIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHZhciBzaWduID0geC5oaSBeIHkuaGk7XG4gIGlmICh4LmhpICYgMHg4MDAwKSB4ID0geC5uZWcoKTtcbiAgaWYgKHkuaGkgJiAweDgwMDApIHkgPSB5Lm5lZygpO1xuICB2YXIgcSA9IHgudWRpdm1vZCh5KS5xdW90aWVudDtcbiAgaWYgKHNpZ24gJiAweDgwMDApIHEgPSBxLm5lZygpO1xuICByZXR1cm4gcTtcbn1cbk1sSW50NjQucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uICh5KVxue1xuICB2YXIgeCA9IHRoaXM7XG4gIGlmICh5LmlzWmVybygpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICB2YXIgc2lnbiA9IHguaGk7XG4gIGlmICh4LmhpICYgMHg4MDAwKSB4ID0geC5uZWcoKTtcbiAgaWYgKHkuaGkgJiAweDgwMDApIHkgPSB5Lm5lZygpO1xuICB2YXIgciA9IHgudWRpdm1vZCh5KS5tb2R1bHVzO1xuICBpZiAoc2lnbiAmIDB4ODAwMCkgciA9IHIubmVnKCk7XG4gIHJldHVybiByO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxvIHwgKHRoaXMubWkgPDwgMjQpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9GbG9hdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICgodGhpcy5oaSA8PCAxNikgKiBNYXRoLnBvdygyLCAzMikgKyB0aGlzLm1pICogTWF0aC5wb3coMiwgMjQpKSArIHRoaXMubG87XG59XG5NbEludDY0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW3RoaXMuaGkgPj4gOCxcbiAgICAgICAgICB0aGlzLmhpICYgMHhmZixcbiAgICAgICAgICB0aGlzLm1pID4+IDE2LFxuICAgICAgICAgICh0aGlzLm1pID4+IDgpICYgMHhmZixcbiAgICAgICAgICB0aGlzLm1pICYgMHhmZixcbiAgICAgICAgICB0aGlzLmxvID4+IDE2LFxuICAgICAgICAgICh0aGlzLmxvID4+IDgpICYgMHhmZixcbiAgICAgICAgICB0aGlzLmxvICYgMHhmZl07XG59XG5NbEludDY0LnByb3RvdHlwZS5sbzMyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sbyB8ICgodGhpcy5taSAmIDB4ZmYpIDw8IDI0KTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmhpMzIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoKHRoaXMubWkgPj4+IDgpICYgMHhmZmZmKSB8ICh0aGlzLmhpIDw8IDE2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF91bHQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdWx0KHgseSkgeyByZXR1cm4geC51Y29tcGFyZSh5KSA8IDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jb21wYXJlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NvbXBhcmUoeCx5LCB0b3RhbCkgeyByZXR1cm4geC5jb21wYXJlKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9uZWcgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbmVnICh4KSB7IHJldHVybiB4Lm5lZygpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9hZGQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYWRkICh4LCB5KSB7IHJldHVybiB4LmFkZCh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc3ViIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3N1YiAoeCwgeSkgeyByZXR1cm4geC5zdWIoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X211bCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbXVsKHgseSkgeyByZXR1cm4geC5tdWwoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX3plcm8gY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaXNfemVybyh4KSB7IHJldHVybiAreC5pc1plcm8oKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlKHgpIHsgcmV0dXJuICt4LmlzTmVnKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9hbmQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYW5kICh4LCB5KSB7IHJldHVybiB4LmFuZCh5KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29yIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29yICh4LCB5KSB7IHJldHVybiB4Lm9yKHkpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfeG9yIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3hvciAoeCwgeSkgeyByZXR1cm4geC54b3IoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfbGVmdCAoeCwgcykgeyByZXR1cm4geC5zaGlmdF9sZWZ0KHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCAoeCwgcykgeyByZXR1cm4geC5zaGlmdF9yaWdodF91bnNpZ25lZChzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfcmlnaHQgKHgsIHMpIHsgcmV0dXJuIHguc2hpZnRfcmlnaHQocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2RpdiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9kaXYgKHgsIHkpIHsgcmV0dXJuIHguZGl2KHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tb2QgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbW9kICh4LCB5KSB7IHJldHVybiB4Lm1vZCh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfaW50MzIgKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHggJiAweGZmZmZmZiwgKHggPj4gMjQpICYgMHhmZmZmZmYsICh4ID4+IDMxKSAmIDB4ZmZmZilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19pbnQzMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19pbnQzMiAoeCkgeyByZXR1cm4geC50b0ludCgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19mbG9hdCAoeCkgeyByZXR1cm4geC50b0Zsb2F0ICgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXQsIE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfZmxvYXQgKHgpIHtcbiAgaWYgKHggPCAwKSB4ID0gTWF0aC5jZWlsKHgpO1xuICByZXR1cm4gbmV3IE1sSW50NjQoXG4gICAgeCAmIDB4ZmZmZmZmLFxuICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0KSAmIDB4ZmZmZmZmLFxuICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0ICogY2FtbF9pbnQ2NF9vZmZzZXQpICYgMHhmZmZmKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9mb3JtYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlLCBjYW1sX2ludDY0X25lZ1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiwgY2FtbF9pbnQ2NF90b19pbnQzMlxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc196ZXJvLCBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZm9ybWF0IChmbXQsIHgpIHtcbiAgdmFyIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICBpZiAoZi5zaWduZWRjb252ICYmIGNhbWxfaW50NjRfaXNfbmVnYXRpdmUoeCkpIHtcbiAgICBmLnNpZ24gPSAtMTsgeCA9IGNhbWxfaW50NjRfbmVnKHgpO1xuICB9XG4gIHZhciBidWZmZXIgPSBcIlwiO1xuICB2YXIgd2Jhc2UgPSBjYW1sX2ludDY0X29mX2ludDMyKGYuYmFzZSk7XG4gIHZhciBjdnRibCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICBkbyB7XG4gICAgdmFyIHAgPSB4LnVkaXZtb2Qod2Jhc2UpO1xuICAgIHggPSBwLnF1b3RpZW50O1xuICAgIGJ1ZmZlciA9IGN2dGJsLmNoYXJBdChjYW1sX2ludDY0X3RvX2ludDMyKHAubW9kdWx1cykpICsgYnVmZmVyO1xuICB9IHdoaWxlICghIGNhbWxfaW50NjRfaXNfemVybyh4KSk7XG4gIGlmIChmLnByZWMgPj0gMCkge1xuICAgIGYuZmlsbGVyID0gJyAnO1xuICAgIHZhciBuID0gZi5wcmVjIC0gYnVmZmVyLmxlbmd0aDtcbiAgICBpZiAobiA+IDApIGJ1ZmZlciA9IGNhbWxfc3RyX3JlcGVhdCAobiwgJzAnKSArIGJ1ZmZlcjtcbiAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBidWZmZXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX3BhcnNlX2RpZ2l0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2ludDMyLCBjYW1sX2ludDY0X3VsdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9hZGQsIGNhbWxfaW50NjRfbXVsLCBjYW1sX2ludDY0X25lZ1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2Zfc3RyaW5nKHMpIHtcbiAgdmFyIHIgPSBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpO1xuICB2YXIgaSA9IHJbMF0sIHNpZ24gPSByWzFdLCBiYXNlID0gclsyXTtcbiAgdmFyIGJhc2U2NCA9IGNhbWxfaW50NjRfb2ZfaW50MzIoYmFzZSk7XG4gIHZhciB0aHJlc2hvbGQgPVxuICAgICAgbmV3IE1sSW50NjQoMHhmZmZmZmYsIDB4ZmZmZmZmZiwgMHhmZmZmKS51ZGl2bW9kKGJhc2U2NCkucXVvdGllbnQ7XG4gIHZhciBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gIGZvciAoOzspIHtcbiAgICBpKys7XG4gICAgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gICAgaWYgKGMgPT0gOTUpIGNvbnRpbnVlO1xuICAgIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICAgIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGJyZWFrO1xuICAgIC8qIERldGVjdCBvdmVyZmxvdyBpbiBtdWx0aXBsaWNhdGlvbiBiYXNlICogcmVzICovXG4gICAgaWYgKGNhbWxfaW50NjRfdWx0KHRocmVzaG9sZCwgcmVzKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gICAgZCA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gICAgcmVzID0gY2FtbF9pbnQ2NF9hZGQoY2FtbF9pbnQ2NF9tdWwoYmFzZTY0LCByZXMpLCBkKTtcbiAgICAvKiBEZXRlY3Qgb3ZlcmZsb3cgaW4gYWRkaXRpb24gKGJhc2UgKiByZXMpICsgZCAqL1xuICAgIGlmIChjYW1sX2ludDY0X3VsdChyZXMsIGQpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICBpZiAoYmFzZSA9PSAxMCAmJiBjYW1sX2ludDY0X3VsdChuZXcgTWxJbnQ2NCgwLCAwLCAweDgwMDApLCByZXMpKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICBpZiAoc2lnbiA8IDApIHJlcyA9IGNhbWxfaW50NjRfbmVnKHJlcyk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaShsbywgbWksIGhpKXtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkobG8sIGhpKXtcbiAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICBsbyAmIDB4ZmZmZmZmLFxuICAgICgobG8gPj4+IDI0KSAmIDB4ZmYpIHwgKChoaSAmIDB4ZmZmZikgPDwgOCksXG4gICAgKGhpID4+PiAxNikgJiAweGZmZmYpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9sbzMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2xvMzIodil7IHJldHVybiB2LmxvMzIoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaGkzMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9oaTMyKHYpeyByZXR1cm4gdi5oaTMyKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2J5dGVzKGEpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGFbN10gPDwgMCB8IChhWzZdIDw8IDgpIHwgKGFbNV0gPDwgMTYpLFxuICAgICAgICAgICAgICAgICAgICAgYVs0XSA8PCAwIHwgKGFbM10gPDwgOCkgfCAoYVsyXSA8PCAxNiksXG4gICAgICAgICAgICAgICAgICAgICBhWzFdIDw8IDAgfCAoYVswXSA8PCA4KSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2J5dGVzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2J5dGVzKHgpIHsgcmV0dXJuIHgudG9BcnJheSgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9oYXNoIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2hhc2godil7XG4gIHJldHVybiAodi5sbzMyKCkpIF4gKHYuaGkzMigpKVxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmQsIEFuZHkgUmF5XG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4vL1xuLy8gQmlnYXJyYXkuXG4vL1xuLy8gLSBhbGwgYmlnYXJyYXkgdHlwZXMgaW5jbHVkaW5nIEludDY0IGFuZCBDb21wbGV4LlxuLy8gLSBmb3J0cmFuICsgYyBsYXlvdXRzXG4vLyAtIHN1Yi9zbGljZS9yZXNoYXBlXG4vLyAtIHJldGFpbiBmYXN0IHBhdGggZm9yIDFkIGFycmF5IGFjY2Vzc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2luaXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYmFfaW5pdCgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSB7XG4gIHZhciBuX2RpbXMgPSBkaW1zLmxlbmd0aDtcbiAgdmFyIHNpemUgPSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5fZGltczsgaSsrKSB7XG4gICAgaWYgKGRpbXNbaV0gPCAwKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuY3JlYXRlOiBuZWdhdGl2ZSBkaW1lbnNpb25cIik7XG4gICAgc2l6ZSA9IHNpemUgKiBkaW1zW2ldO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpe1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgNzogY2FzZSAxMDogY2FzZSAxMTogcmV0dXJuIDI7XG4gIGRlZmF1bHQ6IHJldHVybiAxO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgc2l6ZSl7XG4gIHZhciBnID0gZ2xvYmFsVGhpcztcbiAgdmFyIHZpZXc7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSAwOiAgdmlldyA9IGcuRmxvYXQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxOiAgdmlldyA9IGcuRmxvYXQ2NEFycmF5OyBicmVhaztcbiAgY2FzZSAyOiAgdmlldyA9IGcuSW50OEFycmF5OyBicmVhaztcbiAgY2FzZSAzOiAgdmlldyA9IGcuVWludDhBcnJheTsgYnJlYWs7XG4gIGNhc2UgNDogIHZpZXcgPSBnLkludDE2QXJyYXk7IGJyZWFrO1xuICBjYXNlIDU6ICB2aWV3ID0gZy5VaW50MTZBcnJheTsgYnJlYWs7XG4gIGNhc2UgNjogIHZpZXcgPSBnLkludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDc6ICB2aWV3ID0gZy5JbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA4OiAgdmlldyA9IGcuSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgOTogIHZpZXcgPSBnLkludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDEwOiB2aWV3ID0gZy5GbG9hdDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDExOiB2aWV3ID0gZy5GbG9hdDY0QXJyYXk7IGJyZWFrO1xuICBjYXNlIDEyOiB2aWV3ID0gZy5VaW50OEFycmF5OyBicmVhaztcbiAgfVxuICBpZiAoIXZpZXcpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmNyZWF0ZTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgdmFyIGRhdGEgPSBuZXcgdmlldyhzaXplICogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1ZlcnNpb246IDwgNC4xMVxudmFyIGNhbWxfYmFfY3VzdG9tX25hbWUgPSBcIl9iaWdhcnJheVwiXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vVmVyc2lvbjogPj0gNC4xMVxudmFyIGNhbWxfYmFfY3VzdG9tX25hbWUgPSBcIl9iaWdhcnIwMlwiXG5cbi8vUHJvdmlkZXM6IE1sX0JpZ2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpLCBjYW1sX2ludDY0X2hpMzIsIGNhbWxfaW50NjRfbG8zMlxuZnVuY3Rpb24gTWxfQmlnYXJyYXkgKGtpbmQsIGxheW91dCwgZGltcywgYnVmZmVyKSB7XG5cbiAgdGhpcy5raW5kICAgPSBraW5kIDtcbiAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gIHRoaXMuZGltcyAgID0gZGltcztcbiAgdGhpcy5kYXRhID0gYnVmZmVyO1xufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuY2FtbF9jdXN0b20gPSBjYW1sX2JhX2N1c3RvbV9uYW1lO1xuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKGFyZykge1xuICB2YXIgb2ZzID0gMDtcbiAgaWYodHlwZW9mIGFyZyA9PT0gXCJudW1iZXJcIikgYXJnID0gW2FyZ107XG4gIGlmICghIChhcmcgaW5zdGFuY2VvZiBBcnJheSkpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImJpZ2FycmF5LmpzOiBpbnZhbGlkIG9mZnNldFwiKTtcbiAgaWYgKHRoaXMuZGltcy5sZW5ndGggIT0gYXJnLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5nZXQvc2V0OiBiYWQgbnVtYmVyIG9mIGRpbWVuc2lvbnNcIik7XG4gIGlmKHRoaXMubGF5b3V0ID09IDAgLyogY19sYXlvdXQgKi8pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFyZ1tpXSA8IDAgfHwgYXJnW2ldID49IHRoaXMuZGltc1tpXSlcbiAgICAgICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICAgICAgb2ZzID0gKG9mcyAqIHRoaXMuZGltc1tpXSkgKyBhcmdbaV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmRpbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChhcmdbaV0gPCAxIHx8IGFyZ1tpXSA+IHRoaXMuZGltc1tpXSl7XG4gICAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIG9mcyA9IChvZnMgKiB0aGlzLmRpbXNbaV0pICsgKGFyZ1tpXSAtIDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2ZzO1xufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mcykge1xuICBzd2l0Y2godGhpcy5raW5kKXtcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgdmFyIGwgPSB0aGlzLmRhdGFbb2ZzICogMiArIDBdO1xuICAgIHZhciBoID0gdGhpcy5kYXRhW29mcyAqIDIgKyAxXTtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkobCxoKTtcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHZhciByID0gdGhpcy5kYXRhW29mcyAqIDIgKyAwXTtcbiAgICB2YXIgaSA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMV07XG4gICAgcmV0dXJuIFsyNTQsIHIsIGldO1xuICBkZWZhdWx0OlxuICAgIHJldHVybiB0aGlzLmRhdGFbb2ZzXVxuICB9XG59XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2ZzLHYpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMF0gPSBjYW1sX2ludDY0X2xvMzIodik7XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAxXSA9IGNhbWxfaW50NjRfaGkzMih2KTtcbiAgICBicmVhaztcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMF0gPSB2WzFdO1xuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMV0gPSB2WzJdO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRoaXMuZGF0YVtvZnNdID0gdjtcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gMFxufVxuXG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHYpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHZhciBhID0gY2FtbF9pbnQ2NF9sbzMyKHYpO1xuICAgIHZhciBiID0gY2FtbF9pbnQ2NF9oaTMyKHYpO1xuICAgIGlmKGEgPT0gYil7XG4gICAgICB0aGlzLmRhdGEuZmlsbChhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpPHRoaXMuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZGF0YVtpXSA9IChpJTIgPT0gMCkgPyBhIDogYjtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB2YXIgaW0gPSB2WzFdO1xuICAgIHZhciByZSA9IHZbMl07XG4gICAgaWYoaW0gPT0gcmUpe1xuICAgICAgdGhpcy5kYXRhLmZpbGwoaW0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGk8dGhpcy5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5kYXRhW2ldID0gKGklMiA9PSAwKSA/IGltIDogcmU7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRoaXMuZGF0YS5maWxsKHYpO1xuICAgIGJyZWFrO1xuICB9XG59XG5cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYiwgdG90YWwpIHtcbiAgaWYgKHRoaXMubGF5b3V0ICE9IGIubGF5b3V0IHx8IHRoaXMua2luZCAhPSBiLmtpbmQpIHtcbiAgICB2YXIgazEgPSB0aGlzLmtpbmQgfCAodGhpcy5sYXlvdXQgPDwgOCk7XG4gICAgdmFyIGsyID0gICAgYi5raW5kIHwgKGIubGF5b3V0IDw8IDgpO1xuICAgIHJldHVybiBrMiAtIGsxO1xuICB9XG4gIGlmICh0aGlzLmRpbXMubGVuZ3RoICE9IGIuZGltcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYi5kaW1zLmxlbmd0aCAtIHRoaXMuZGltcy5sZW5ndGg7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgaWYgKHRoaXMuZGltc1tpXSAhPSBiLmRpbXNbaV0pXG4gICAgICByZXR1cm4gKHRoaXMuZGltc1tpXSA8IGIuZGltc1tpXSkgPyAtMSA6IDE7XG4gIHN3aXRjaCAodGhpcy5raW5kKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICBjYXNlIDEwOlxuICBjYXNlIDExOlxuICAgIC8vIEZsb2F0c1xuICAgIHZhciB4LCB5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICB4ID0gdGhpcy5kYXRhW2ldO1xuICAgICAgeSA9IGIuZGF0YVtpXTtcbiAgICAgIGlmICh4IDwgeSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHggPiB5KVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGlmICh4ICE9IHkpIHtcbiAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgaWYgKHggPT0geCkgcmV0dXJuIDE7XG4gICAgICAgIGlmICh5ID09IHkpIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSs9Mikge1xuICAgICAgLy8gQ2hlY2sgaGlnaGVzdCBiaXRzIGZpcnN0XG4gICAgICBpZiAodGhpcy5kYXRhW2krMV0gPCBiLmRhdGFbaSsxXSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHRoaXMuZGF0YVtpKzFdID4gYi5kYXRhW2krMV0pXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgaWYgKCh0aGlzLmRhdGFbaV0gPj4+IDApIDwgKGIuZGF0YVtpXSA+Pj4gMCkpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICgodGhpcy5kYXRhW2ldID4+PiAwKSA+IChiLmRhdGFbaV0gPj4+IDApKVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMjpcbiAgY2FzZSAzOlxuICBjYXNlIDQ6XG4gIGNhc2UgNTpcbiAgY2FzZSA2OlxuICBjYXNlIDg6XG4gIGNhc2UgOTpcbiAgY2FzZSAxMjpcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuZGF0YVtpXSA8IGIuZGF0YVtpXSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHRoaXMuZGF0YVtpXSA+IGIuZGF0YVtpXSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBNbF9CaWdhcnJheV9jXzFfMVxuLy9SZXF1aXJlczogTWxfQmlnYXJyYXksIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gTWxfQmlnYXJyYXlfY18xXzEoa2luZCwgbGF5b3V0LCBkaW1zLCBidWZmZXIpIHtcbiAgdGhpcy5raW5kICAgPSBraW5kIDtcbiAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gIHRoaXMuZGltcyAgID0gZGltcztcbiAgdGhpcy5kYXRhICAgPSBidWZmZXI7XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZSA9IG5ldyBNbF9CaWdhcnJheSgpXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKGFyZykge1xuICBpZih0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKXtcbiAgICBpZigoYXJnIGluc3RhbmNlb2YgQXJyYXkpICYmIGFyZy5sZW5ndGggPT0gMSlcbiAgICAgIGFyZyA9IGFyZ1swXTtcbiAgICBlbHNlIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIk1sX0JpZ2FycmF5X2NfMV8xLm9mZnNldFwiKTtcbiAgfVxuICBpZiAoYXJnIDwgMCB8fCBhcmcgPj0gdGhpcy5kaW1zWzBdKVxuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGFyZztcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZnMpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YVtvZnNdO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9mcyx2KSB7XG4gIHRoaXMuZGF0YVtvZnNdID0gdjtcbiAgcmV0dXJuIDBcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodikge1xuICB0aGlzLmRhdGEuZmlsbCh2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jb21wYXJlXG5mdW5jdGlvbiBjYW1sX2JhX2NvbXBhcmUoYSxiLHRvdGFsKXtcbiAgcmV0dXJuIGEuY29tcGFyZShiLHRvdGFsKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbi8vUmVxdWlyZXM6IE1sX0JpZ2FycmF5LCBNbF9CaWdhcnJheV9jXzFfMSwgY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKXtcbiAgdmFyIHNpemVfcGVyX2VsZW1lbnQgPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpO1xuICBpZihjYW1sX2JhX2dldF9zaXplKGRpbXMpICogc2l6ZV9wZXJfZWxlbWVudCAhPSBkYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImxlbmd0aCBkb2Vzbid0IG1hdGNoIGRpbXNcIik7XG4gIH1cbiAgaWYobGF5b3V0ID09IDAgJiYgLy8gY19sYXlvdXRcbiAgICAgZGltcy5sZW5ndGggPT0gMSAmJiAvLyBBcnJheTFcbiAgICAgc2l6ZV9wZXJfZWxlbWVudCA9PSAxKSAvLyAxLXRvLTEgbWFwcGluZ1xuICAgIHJldHVybiBuZXcgTWxfQmlnYXJyYXlfY18xXzEoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbiAgcmV0dXJuIG5ldyBNbF9CaWdhcnJheShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuXG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV9idWZmZXJcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlKGtpbmQsIGxheW91dCwgZGltc19tbCkge1xuICB2YXIgZGltcyA9IGNhbWxfanNfZnJvbV9hcnJheShkaW1zX21sKTtcbiAgdmFyIGRhdGEgPSBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGNhbWxfYmFfY2hhbmdlX2xheW91dChiYSwgbGF5b3V0KSB7XG4gIGlmKGJhLmxheW91dCA9PSBsYXlvdXQpIHJldHVybiBiYTtcbiAgdmFyIG5ld19kaW1zID0gW11cbiAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIG5ld19kaW1zW2ldID0gYmEuZGltc1tiYS5kaW1zLmxlbmd0aCAtIGkgLSAxXTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBsYXlvdXQsIG5ld19kaW1zLCBiYS5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9raW5kXG5mdW5jdGlvbiBjYW1sX2JhX2tpbmQoYmEpIHtcbiAgcmV0dXJuIGJhLmtpbmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbGF5b3V0XG5mdW5jdGlvbiBjYW1sX2JhX2xheW91dChiYSkge1xuICByZXR1cm4gYmEubGF5b3V0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX251bV9kaW1zXG5mdW5jdGlvbiBjYW1sX2JhX251bV9kaW1zKGJhKSB7XG4gIHJldHVybiBiYS5kaW1zLmxlbmd0aDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1cbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9kaW0oYmEsIGkpIHtcbiAgaWYgKGkgPCAwIHx8IGkgPj0gYmEuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuZGltXCIpO1xuICByZXR1cm4gYmEuZGltc1tpXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fMVxuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzEoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAwKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fMlxuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzIoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fM1xuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzMoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfZ2VuZXJpY1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9nZW5lcmljKGJhLCBpKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoY2FtbF9qc19mcm9tX2FycmF5KGkpKTtcbiAgcmV0dXJuIGJhLmdldChvZnMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDE2KGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMSA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcyArIDEpO1xuICByZXR1cm4gKGIxIHwgKGIyIDw8IDgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQzMihiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDMgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyswKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcysxKTtcbiAgdmFyIGIzID0gYmEuZ2V0KG9mcysyKTtcbiAgdmFyIGI0ID0gYmEuZ2V0KG9mcyszKTtcbiAgcmV0dXJuICggKGIxIDw8IDApICB8XG4gICAgICAgICAgIChiMiA8PCA4KSAgfFxuICAgICAgICAgICAoYjMgPDwgMTYpIHxcbiAgICAgICAgICAgKGI0IDw8IDI0KSApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDY0KGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgNyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKzApO1xuICB2YXIgYjIgPSBiYS5nZXQob2ZzKzEpO1xuICB2YXIgYjMgPSBiYS5nZXQob2ZzKzIpO1xuICB2YXIgYjQgPSBiYS5nZXQob2ZzKzMpO1xuICB2YXIgYjUgPSBiYS5nZXQob2ZzKzQpO1xuICB2YXIgYjYgPSBiYS5nZXQob2ZzKzUpO1xuICB2YXIgYjcgPSBiYS5nZXQob2ZzKzYpO1xuICB2YXIgYjggPSBiYS5nZXQob2ZzKzcpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhbYjgsYjcsYjYsYjUsYjQsYjMsYjIsYjFdKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMShiYSwgaTApIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoaTApKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfMlxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMihiYSwgaTAsIGkxKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KFtpMCxpMV0pKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfM1xuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMyhiYSwgaTAsIGkxLCBpMikge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChbaTAsaTEsaTJdKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0X2dlbmVyaWNcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfZ2VuZXJpYyhiYSwgaSwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KGNhbWxfanNfZnJvbV9hcnJheShpKSksIHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDE2KGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMSA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBiYS5zZXQob2ZzKzAsICB2ICAgICAgICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzEsICh2ID4+PiA4KSAmIDB4ZmYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQzMihiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDMgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYmEuc2V0KG9mcyswLCAgdiAgICAgICAgICYgMHhmZik7XG4gIGJhLnNldChvZnMrMSwgKHYgPj4+IDgpICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzIsICh2ID4+PiAxNikgJiAweGZmKTtcbiAgYmEuc2V0KG9mcyszLCAodiA+Pj4gMjQpICYgMHhmZik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDY0KGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgNyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgdiA9IGNhbWxfaW50NjRfdG9fYnl0ZXModik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCA4OyBpKyspIGJhLnNldChvZnMraSwgdls3LWldKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfMVxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMShiYSwgaTAsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChpMCksIHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8yXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8yKGJhLCBpMCwgaTEsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChbaTAsaTFdKSwgdik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8zXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8zKGJhLCBpMCwgaTEsIGkyLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoW2kwLGkxLGkyXSksIHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9maWxsXG5mdW5jdGlvbiBjYW1sX2JhX2ZpbGwoYmEsIHYpIHtcbiAgYmEuZmlsbCh2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2JsaXQoc3JjLCBkc3QpIHtcbiAgaWYgKGRzdC5kaW1zLmxlbmd0aCAhPSBzcmMuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuYmxpdDogZGltZW5zaW9uIG1pc21hdGNoXCIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRzdC5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIGlmIChkc3QuZGltc1tpXSAhPSBzcmMuZGltc1tpXSlcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmJsaXQ6IGRpbWVuc2lvbiBtaXNtYXRjaFwiKTtcbiAgZHN0LmRhdGEuc2V0KHNyYy5kYXRhKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc3ViXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9zdWIoYmEsIG9mcywgbGVuKSB7XG4gIHZhciBjaGFuZ2VkX2RpbTtcbiAgdmFyIG11bCA9IDE7XG4gIGlmIChiYS5sYXlvdXQgPT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICAgIG11bCA9IG11bCAqIGJhLmRpbXNbaV07XG4gICAgY2hhbmdlZF9kaW0gPSAwO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgKGJhLmRpbXMubGVuZ3RoIC0gMSk7IGkrKylcbiAgICAgIG11bCA9IG11bCAqIGJhLmRpbXNbaV07XG4gICAgY2hhbmdlZF9kaW0gPSBiYS5kaW1zLmxlbmd0aCAtIDE7XG4gICAgb2ZzID0gb2ZzIC0gMTtcbiAgfVxuICBpZiAob2ZzIDwgMCB8fCBsZW4gPCAwIHx8IChvZnMgKyBsZW4pID4gYmEuZGltc1tjaGFuZ2VkX2RpbV0pe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnN1YjogYmFkIHN1Yi1hcnJheVwiKTtcbiAgfVxuICB2YXIgbmV3X2RpbXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIG5ld19kaW1zW2ldID0gYmEuZGltc1tpXTtcbiAgbmV3X2RpbXNbY2hhbmdlZF9kaW1dID0gbGVuO1xuICBtdWwgKj0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChiYS5raW5kKTtcbiAgdmFyIG5ld19kYXRhID0gYmEuZGF0YS5zdWJhcnJheShvZnMgKiBtdWwsIChvZnMgKyBsZW4pICogbXVsKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIG5ld19kaW1zLCBuZXdfZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2xpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfc2xpY2UoYmEsIHZpbmQpIHtcbiAgdmluZCA9IGNhbWxfanNfZnJvbV9hcnJheSh2aW5kKTtcbiAgdmFyIG51bV9pbmRzID0gdmluZC5sZW5ndGg7XG4gIHZhciBpbmRleCA9IFtdO1xuICB2YXIgc3ViX2RpbXMgPSBbXTtcbiAgdmFyIG9mcztcblxuICBpZiAobnVtX2luZHMgPiBiYS5kaW1zLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5zbGljZTogdG9vIG1hbnkgaW5kaWNlc1wiKTtcblxuICAvLyBDb21wdXRlIG9mZnNldCBhbmQgY2hlY2sgYm91bmRzXG4gIGlmIChiYS5sYXlvdXQgPT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2ldID0gdmluZFtpXTtcbiAgICBmb3IgKDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgICBpbmRleFtpXSA9IDA7XG4gICAgc3ViX2RpbXMgPSBiYS5kaW1zLnNsaWNlKG51bV9pbmRzKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzICsgaV0gPSB2aW5kW2ldO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGggLSBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSAxO1xuICAgIHN1Yl9kaW1zID0gYmEuZGltcy5zbGljZSgwLCBiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzKTtcbiAgfVxuICBvZnMgPSBiYS5vZmZzZXQoaW5kZXgpO1xuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoc3ViX2RpbXMpO1xuICB2YXIgc2l6ZV9wZXJfZWxlbWVudCA9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoYmEua2luZCk7XG4gIHZhciBuZXdfZGF0YSA9IGJhLmRhdGEuc3ViYXJyYXkob2ZzICogc2l6ZV9wZXJfZWxlbWVudCwgKG9mcyArIHNpemUpICogc2l6ZV9wZXJfZWxlbWVudCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBzdWJfZGltcywgbmV3X2RhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3Jlc2hhcGVcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfYmFfZ2V0X3NpemVcbmZ1bmN0aW9uIGNhbWxfYmFfcmVzaGFwZShiYSwgdmluZCkge1xuICB2aW5kID0gY2FtbF9qc19mcm9tX2FycmF5KHZpbmQpO1xuICB2YXIgbmV3X2RpbSA9IFtdO1xuICB2YXIgbnVtX2RpbXMgPSB2aW5kLmxlbmd0aDtcblxuICBpZiAobnVtX2RpbXMgPCAwIHx8IG51bV9kaW1zID4gMTYpe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IGJhZCBudW1iZXIgb2YgZGltZW5zaW9uc1wiKTtcbiAgfVxuICB2YXIgbnVtX2VsdHMgPSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIHtcbiAgICBuZXdfZGltW2ldID0gdmluZFtpXTtcbiAgICBpZiAobmV3X2RpbVtpXSA8IDApXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBuZWdhdGl2ZSBkaW1lbnNpb25cIik7XG4gICAgbnVtX2VsdHMgPSBudW1fZWx0cyAqIG5ld19kaW1baV07XG4gIH1cblxuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoYmEuZGltcyk7XG4gIC8vIENoZWNrIHRoYXQgc2l6ZXMgYWdyZWVcbiAgaWYgKG51bV9lbHRzICE9IHNpemUpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogc2l6ZSBtaXNtYXRjaFwiKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIG5ld19kaW0sIGJhLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NlcmlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2ludDY0X3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfYmFfc2VyaWFsaXplKHdyaXRlciwgYmEsIHN6KSB7XG4gIHdyaXRlci53cml0ZSgzMiwgYmEuZGltcy5sZW5ndGgpO1xuICB3cml0ZXIud3JpdGUoMzIsIChiYS5raW5kIHwgKGJhLmxheW91dCA8PCA4KSkpO1xuICBpZihiYS5jYW1sX2N1c3RvbSA9PSBcIl9iaWdhcnIwMlwiKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZihiYS5kaW1zW2ldIDwgMHhmZmZmKVxuICAgICAgICB3cml0ZXIud3JpdGUoMTYsIGJhLmRpbXNbaV0pO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHdyaXRlci53cml0ZSgxNiwgMHhmZmZmKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKDMyLCAwKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kaW1zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIGVsc2VcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykgd3JpdGVyLndyaXRlKDMyLGJhLmRpbXNbaV0pXG4gIHN3aXRjaChiYS5raW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSg4LCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMTYsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIHdyaXRlci53cml0ZSg4LDApO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6ICAvLyBJbnQzMkFycmF5IChpbnQ2NClcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGJhLmdldChpKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoYmEuZ2V0KGkpKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGJhLmdldChpKSk7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGIpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBqID0gYmEuZ2V0KGkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoalsxXSkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoalsyXSkpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBjb21wbGV4ID0gYmEuZ2V0KGkpO1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChjb21wbGV4WzFdKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoY29tcGxleFsyXSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHN6WzBdID0gKDQgKyBiYS5kaW1zLmxlbmd0aCkgKiA0O1xuICBzelsxXSA9ICg0ICsgYmEuZGltcy5sZW5ndGgpICogODtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kZXNlcmlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzLCBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c1xuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG5mdW5jdGlvbiBjYW1sX2JhX2Rlc2VyaWFsaXplKHJlYWRlciwgc3osIG5hbWUpe1xuICB2YXIgbnVtX2RpbXMgPSByZWFkZXIucmVhZDMycygpO1xuICBpZiAobnVtX2RpbXMgPCAwIHx8IG51bV9kaW1zID4gMTYpXG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB3cm9uZyBudW1iZXIgb2YgYmlnYXJyYXkgZGltZW5zaW9uc1wiKTtcbiAgdmFyIHRhZyA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIHZhciBraW5kID0gdGFnICYgMHhmZlxuICB2YXIgbGF5b3V0ID0gKHRhZyA+PiA4KSAmIDE7XG4gIHZhciBkaW1zID0gW11cbiAgaWYobmFtZSA9PSBcIl9iaWdhcnIwMlwiKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykge1xuICAgICAgdmFyIHNpemVfZGltID0gcmVhZGVyLnJlYWQxNnUoKTtcbiAgICAgIGlmKHNpemVfZGltID09IDB4ZmZmZil7XG4gICAgICAgIHZhciBzaXplX2RpbV9oaSA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgIHZhciBzaXplX2RpbV9sbyA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgIGlmKHNpemVfZGltX2hpICE9IDApXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBiaWdhcnJheSBkaW1lbnNpb24gb3ZlcmZsb3cgaW4gMzJiaXRcIik7XG4gICAgICAgIHNpemVfZGltID0gc2l6ZV9kaW1fbG87XG4gICAgICB9XG4gICAgICBkaW1zLnB1c2goc2l6ZV9kaW0pO1xuICAgIH1cbiAgZWxzZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykgZGltcy5wdXNoKHJlYWRlci5yZWFkMzJ1KCkpO1xuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoZGltcyk7XG4gIHZhciBkYXRhID0gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIHNpemUpO1xuICB2YXIgYmEgPSBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbiAgc3dpdGNoKGtpbmQpe1xuICBjYXNlIDI6ICAvL0ludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkOHMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQxNnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQxNnUoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICB2YXIgc2l4dHkgPSByZWFkZXIucmVhZDh1KCk7XG4gICAgaWYoc2l4dHkpIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogY2Fubm90IHJlYWQgYmlnYXJyYXkgd2l0aCA2NC1iaXQgT0NhbWwgaW50c1wiKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA3OiAvLyAoaW50NjQpXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIGludDY0ID0gY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KTtcbiAgICAgIGJhLnNldChpLGludDY0KTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBmID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgYmEuc2V0KGksZik7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIHZhciBmID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgYmEuc2V0KGksZik7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIHZhciByZSA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIHZhciBpbSA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIGJhLnNldChpLFsyNTQscmUsaW1dKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciByZSA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBpbSA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGJhLnNldChpLFsyNTQscmUsaW1dKTtcbiAgICB9XG4gICAgYnJlYWtcbiAgfVxuICBzelswXSA9ICg0ICsgbnVtX2RpbXMpICogNDtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xufVxuXG4vL0RlcHJlY2F0ZWRcbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX2Zyb21cbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV9mcm9tKGRhdGExLCBkYXRhMiwganN0eXAsIGtpbmQsIGxheW91dCwgZGltcyl7XG4gIGlmKGRhdGEyIHx8IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCkgPT0gMil7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iYV9jcmVhdGVfZnJvbTogdXNlIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcIik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGExKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9oYXNoIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2hhc2hfbWl4X2ludCwgY2FtbF9oYXNoX21peF9mbG9hdFxuZnVuY3Rpb24gY2FtbF9iYV9oYXNoKGJhKXtcbiAgdmFyIG51bV9lbHRzID0gY2FtbF9iYV9nZXRfc2l6ZShiYS5kaW1zKTtcbiAgdmFyIGggPSAwO1xuICBzd2l0Y2goYmEua2luZCl7XG4gIGNhc2UgMjogIC8vSW50OEFycmF5XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBpZihudW1fZWx0cyA+IDI1NikgbnVtX2VsdHMgPSAyNTY7XG4gICAgdmFyIHcgPSAwLCBpID0wO1xuICAgIGZvcihpID0gMDsgaSArIDQgPD0gYmEuZGF0YS5sZW5ndGg7IGkrPTQpe1xuICAgICAgdyA9IGJhLmRhdGFbaSswXSB8IChiYS5kYXRhW2krMV0gPDwgOCkgfCAoYmEuZGF0YVtpKzJdIDw8IDE2KSB8IChiYS5kYXRhW2krM10gPDwgMjQpO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsdyk7XG4gICAgfVxuICAgIHcgPSAwO1xuICAgIHN3aXRjaCAobnVtX2VsdHMgJiAzKSB7XG4gICAgY2FzZSAzOiB3ICA9IGJhLmRhdGFbaSsyXSA8PCAxNjsgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlIDI6IHcgfD0gYmEuZGF0YVtpKzFdIDw8IDg7ICAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgMTogdyB8PSBiYS5kYXRhW2krMF07XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgaWYobnVtX2VsdHMgPiAxMjgpIG51bV9lbHRzID0gMTI4O1xuICAgIHZhciB3ID0gMCwgaSA9MDtcbiAgICBmb3IoaSA9IDA7IGkgKyAyIDw9IGJhLmRhdGEubGVuZ3RoOyBpKz0yKXtcbiAgICAgIHcgPSBiYS5kYXRhW2krMF0gfCAoYmEuZGF0YVtpKzFdIDw8IDE2KTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLHcpO1xuICAgIH1cbiAgICBpZiAoKG51bV9lbHRzICYgMSkgIT0gMClcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDc6ICAvLyBJbnQzMkFycmF5IChpbnQ2NClcbiAgICBpZiAobnVtX2VsdHMgPiAzMikgbnVtX2VsdHMgPSAzMjtcbiAgICBudW1fZWx0cyAqPSAyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICBudW1fZWx0cyAqPTI7IC8qIGZhbGx0aHJvdWdoICovXG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfZmxvYXQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIG51bV9lbHRzICo9MjsgLyogZmFsbHRocm91Z2ggKi9cbiAgY2FzZSAxOiAgLy8gRmxvYXQ2NEFycmF5XG4gICAgaWYgKG51bV9lbHRzID4gMzIpIG51bV9lbHRzID0gMzI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV90b190eXBlZF9hcnJheSBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5KGJhKXtcbiAgcmV0dXJuIGJhLmRhdGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSh0YSl7XG4gIHZhciBnID0gZ2xvYmFsVGhpcztcbiAgdmFyIGtpbmQ7XG4gIGlmICh0YSBpbnN0YW5jZW9mIGcuRmxvYXQzMkFycmF5KSBraW5kID0gMDtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkZsb2F0NjRBcnJheSkga2luZCA9IDE7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5JbnQ4QXJyYXkpIGtpbmQgPSAyO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuVWludDhBcnJheSkga2luZCA9IDM7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5JbnQxNkFycmF5KSBraW5kID0gNDtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLlVpbnQxNkFycmF5KSBraW5kID0gNTtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkludDMyQXJyYXkpIGtpbmQgPSA2O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuVWludDMyQXJyYXkpIGtpbmQgPSA2O1xuICBlbHNlIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgcmV0dXJuIGtpbmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5KHRhKXtcbiAgdmFyIGtpbmQgPSBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkodGEpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9pbnQgY29uc3QgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nLCBjYW1sX3N0cl9yZXBlYXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2ludChmbXQsIGkpIHtcbiAgaWYgKGNhbWxfanNieXRlc19vZl9zdHJpbmcoZm10KSA9PSBcIiVkXCIpIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIraSk7XG4gIHZhciBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgaWYgKGkgPCAwKSB7IGlmIChmLnNpZ25lZGNvbnYpIHsgZi5zaWduID0gLTE7IGkgPSAtaTsgfSBlbHNlIGkgPj4+PSAwOyB9XG4gIHZhciBzID0gaS50b1N0cmluZyhmLmJhc2UpO1xuICBpZiAoZi5wcmVjID49IDApIHtcbiAgICBmLmZpbGxlciA9ICcgJztcbiAgICB2YXIgbiA9IGYucHJlYyAtIHMubGVuZ3RoO1xuICAgIGlmIChuID4gMCkgcyA9IGNhbWxfc3RyX3JlcGVhdCAobiwgJzAnKSArIHM7XG4gIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpIHtcbiAgdmFyIGkgPSAwLCBsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyksIGJhc2UgPSAxMCwgc2lnbiA9IDE7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgc3dpdGNoIChjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsaSkpIHtcbiAgICBjYXNlIDQ1OiBpKys7IHNpZ24gPSAtMTsgYnJlYWs7XG4gICAgY2FzZSA0MzogaSsrOyBzaWduID0gMTsgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChpICsgMSA8IGxlbiAmJiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpID09IDQ4KVxuICAgIHN3aXRjaCAoY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpICsgMSkpIHtcbiAgICBjYXNlIDEyMDogY2FzZSA4ODogYmFzZSA9IDE2OyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgMTExOiBjYXNlIDc5OiBiYXNlID0gIDg7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAgOTg6IGNhc2UgNjY6IGJhc2UgPSAgMjsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlIDExNzogY2FzZSA4NTogaSArPSAyOyBicmVhaztcbiAgICB9XG4gIHJldHVybiBbaSwgc2lnbiwgYmFzZV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZGlnaXRcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZGlnaXQoYykge1xuICBpZiAoYyA+PSA0OCAmJiBjIDw9IDU3KSAgcmV0dXJuIGMgLSA0ODtcbiAgaWYgKGMgPj0gNjUgJiYgYyA8PSA5MCkgIHJldHVybiBjIC0gNTU7XG4gIGlmIChjID49IDk3ICYmIGMgPD0gMTIyKSByZXR1cm4gYyAtIDg3O1xuICByZXR1cm4gLTE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50X29mX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSwgY2FtbF9wYXJzZV9kaWdpdCwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9pbnRfb2Zfc3RyaW5nIChzKSB7XG4gIHZhciByID0gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKTtcbiAgdmFyIGkgPSByWzBdLCBzaWduID0gclsxXSwgYmFzZSA9IHJbMl07XG4gIHZhciBsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyk7XG4gIHZhciB0aHJlc2hvbGQgPSAtMSA+Pj4gMDtcbiAgdmFyIGMgPSAoaSA8IGxlbik/Y2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTowO1xuICB2YXIgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB2YXIgcmVzID0gZDtcbiAgZm9yIChpKys7aTxsZW47aSsrKSB7XG4gICAgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gICAgaWYgKGMgPT0gOTUpIGNvbnRpbnVlO1xuICAgIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICAgIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGJyZWFrO1xuICAgIHJlcyA9IGJhc2UgKiByZXMgKyBkO1xuICAgIGlmIChyZXMgPiB0aHJlc2hvbGQpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB9XG4gIGlmIChpICE9IGxlbikgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIC8vIEZvciBiYXNlIGRpZmZlcmVudCBmcm9tIDEwLCB3ZSBleHBlY3QgYW4gdW5zaWduZWQgcmVwcmVzZW50YXRpb24sXG4gIC8vIGhlbmNlIGFueSB2YWx1ZSBvZiAncmVzJyAobGVzcyB0aGFuICd0aHJlc2hvbGQnKSBpcyBhY2NlcHRhYmxlLlxuICAvLyBCdXQgd2UgaGF2ZSB0byBjb252ZXJ0IHRoZSByZXN1bHQgYmFjayB0byBhIHNpZ25lZCBpbnRlZ2VyLlxuICByZXMgPSBzaWduICogcmVzO1xuICBpZiAoKGJhc2UgPT0gMTApICYmICgocmVzIHwgMCkgIT0gcmVzKSlcbiAgICAvKiBTaWduZWQgcmVwcmVzZW50YXRpb24gZXhwZWN0ZWQsIGFsbG93IC0yXihuYml0cy0xKSB0byAyXihuYml0cy0xKSAtIDEgKi9cbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgcmV0dXJuIHJlcyB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbXVsIGNvbnN0XG5mdW5jdGlvbiBjYW1sX211bChhLGIpe1xuICByZXR1cm4gTWF0aC5pbXVsKGEsYik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZGl2XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBjYW1sX2Rpdih4LHkpIHtcbiAgaWYgKHkgPT0gMCkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgcmV0dXJuICh4L3kpfDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbW9kXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBjYW1sX21vZCh4LHkpIHtcbiAgaWYgKHkgPT0gMCkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgcmV0dXJuIHgleTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ic3dhcDE2XG5mdW5jdGlvbiBjYW1sX2Jzd2FwMTYoeCkge1xuICByZXR1cm4gKCgoKHggJiAweDAwRkYpIDw8IDgpIHxcbiAgICAgICAgICAgKCh4ICYgMHhGRjAwKSA+PiA4KSkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9ic3dhcFxuZnVuY3Rpb24gY2FtbF9pbnQzMl9ic3dhcCh4KSB7XG4gIHJldHVybiAoKCh4ICYgMHgwMDAwMDBGRikgPDwgMjQpIHxcbiAgICAgICAgICAoKHggJiAweDAwMDBGRjAwKSA8PCA4KSB8XG4gICAgICAgICAgKCh4ICYgMHgwMEZGMDAwMCkgPj4+IDgpIHxcbiAgICAgICAgICAoKHggJiAweEZGMDAwMDAwKSA+Pj4gMjQpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYnN3YXBcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYnN3YXAoeCkge1xuICB2YXIgeSA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoeCk7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKFt5WzddLCB5WzZdLCB5WzVdLCB5WzRdLCB5WzNdLCB5WzJdLCB5WzFdLCB5WzBdXSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEhhc2h0YmxcblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX3VuaXZfcGFyYW0gbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfY29udGVudFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2hhc2hfdW5pdl9wYXJhbSAoY291bnQsIGxpbWl0LCBvYmopIHtcbiAgdmFyIGhhc2hfYWNjdSA9IDA7XG4gIGZ1bmN0aW9uIGhhc2hfYXV4IChvYmopIHtcbiAgICBsaW1pdCAtLTtcbiAgICBpZiAoY291bnQgPCAwIHx8IGxpbWl0IDwgMCkgcmV0dXJuO1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSAmJiBvYmpbMF0gPT09IChvYmpbMF18MCkpIHtcbiAgICAgIHN3aXRjaCAob2JqWzBdKSB7XG4gICAgICBjYXNlIDI0ODpcbiAgICAgICAgLy8gT2JqZWN0XG4gICAgICAgIGNvdW50IC0tO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBvYmpbMl0pIHwgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MDpcbiAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICBsaW1pdCsrOyBoYXNoX2F1eChvYmopOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvdW50IC0tO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBvYmpbMF0pIHwgMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IG9iai5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSBoYXNoX2F1eCAob2JqW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMob2JqKSkge1xuICAgICAgY291bnQgLS07XG4gICAgICB2YXIgY29udGVudCA9IGNhbWxfbWxfYnl0ZXNfY29udGVudChvYmopO1xuICAgICAgaWYodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcblx0Zm9yICh2YXIgYiA9IGNvbnRlbnQsIGwgPSBiLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYi5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgICB9IGVsc2UgeyAvKiBBUlJBWSAqL1xuICAgICAgICBmb3IgKHZhciBhID0gY29udGVudCwgbCA9IGEubGVuZ3RoLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBhW2ldKSB8IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyhvYmopKSB7XG4gICAgICB2YXIganNieXRlcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcob2JqKTtcbiAgICAgIGZvciAodmFyIGIgPSBqc2J5dGVzLCBsID0ganNieXRlcy5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBiLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGZvciAodmFyIGIgPSBvYmosIGwgPSBvYmoubGVuZ3RoLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYi5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgfSBlbHNlIGlmIChvYmogPT09IChvYmp8MCkpIHtcbiAgICAgIC8vIEludGVnZXJcbiAgICAgIGNvdW50IC0tO1xuICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgb2JqKSB8IDA7XG4gICAgfSBlbHNlIGlmIChvYmogPT09ICtvYmopIHtcbiAgICAgIC8vIEZsb2F0XG4gICAgICBjb3VudC0tO1xuICAgICAgdmFyIHAgPSBjYW1sX2ludDY0X3RvX2J5dGVzIChjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKG9iaikpO1xuICAgICAgZm9yICh2YXIgaSA9IDc7IGkgPj0gMDsgaS0tKSBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBwW2ldKSB8IDA7XG4gICAgfSBlbHNlIGlmKG9iaiAmJiBvYmouY2FtbF9jdXN0b20pIHtcbiAgICAgIGlmKGNhbWxfY3VzdG9tX29wc1tvYmouY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1tvYmouY2FtbF9jdXN0b21dLmhhc2gpIHtcbiAgICAgICAgdmFyIGggPSBjYW1sX2N1c3RvbV9vcHNbb2JqLmNhbWxfY3VzdG9tXS5oYXNoKG9iaikgfCAwO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBoKSB8IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhc2hfYXV4IChvYmopO1xuICByZXR1cm4gaGFzaF9hY2N1ICYgMHgzRkZGRkZGRjtcbn1cblxuLy9mdW5jdGlvbiBST1RMMzIoeCxuKSB7IHJldHVybiAoKHggPDwgbikgfCAoeCA+Pj4gKDMyLW4pKSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfaW50XG4vL1JlcXVpcmVzOiBjYW1sX211bFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9pbnQoaCxkKSB7XG4gIGQgPSBjYW1sX211bChkLCAweGNjOWUyZDUxfDApO1xuICBkID0gKChkIDw8IDE1KSB8IChkID4+PiAoMzItMTUpKSk7IC8vIFJPVEwzMihkLCAxNSk7XG4gIGQgPSBjYW1sX211bChkLCAweDFiODczNTkzKTtcbiAgaCBePSBkO1xuICBoID0gKChoIDw8IDEzKSB8IChoID4+PiAoMzItMTMpKSk7ICAgLy9ST1RMMzIoaCwgMTMpO1xuICByZXR1cm4gKCgoaCArIChoIDw8IDIpKXwwKSArICgweGU2NTQ2YjY0fDApKXwwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2ZpbmFsXG4vL1JlcXVpcmVzOiBjYW1sX211bFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9maW5hbChoKSB7XG4gIGggXj0gaCA+Pj4gMTY7XG4gIGggPSBjYW1sX211bCAoaCwgMHg4NWViY2E2YnwwKTtcbiAgaCBePSBoID4+PiAxMztcbiAgaCA9IGNhbWxfbXVsIChoLCAweGMyYjJhZTM1fDApO1xuICBoIF49IGggPj4+IDE2O1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9mbG9hdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2hhc2hfbWl4X2ludDY0XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2Zsb2F0IChoLCB2MCkge1xuICByZXR1cm4gY2FtbF9oYXNoX21peF9pbnQ2NChoLCBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKHYwKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2ludDY0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9sbzMyLCBjYW1sX2ludDY0X2hpMzJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfaW50NjQgKGgsIHYpIHtcbiAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGNhbWxfaW50NjRfbG8zMih2KSk7XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBjYW1sX2ludDY0X2hpMzIodikpO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsIHMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoLCBpLCB3O1xuICBmb3IgKGkgPSAwOyBpICsgNCA8PSBsZW47IGkgKz0gNCkge1xuICAgIHcgPSBzLmNoYXJDb2RlQXQoaSlcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDgpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSsyKSA8PCAxNilcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzMpIDw8IDI0KTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIH1cbiAgdyA9IDA7XG4gIHN3aXRjaCAobGVuICYgMykge1xuICBjYXNlIDM6IHcgID0gcy5jaGFyQ29kZUF0KGkrMikgPDwgMTY7XG4gIGNhc2UgMjogdyB8PSBzLmNoYXJDb2RlQXQoaSsxKSA8PCA4O1xuICBjYXNlIDE6XG4gICAgdyB8PSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICBkZWZhdWx0OlxuICB9XG4gIGggXj0gbGVuO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9ieXRlc19hcnJcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FycihoLCBzKSB7XG4gIHZhciBsZW4gPSBzLmxlbmd0aCwgaSwgdztcbiAgZm9yIChpID0gMDsgaSArIDQgPD0gbGVuOyBpICs9IDQpIHtcbiAgICB3ID0gc1tpXVxuICAgICAgfCAoc1tpKzFdIDw8IDgpXG4gICAgICB8IChzW2krMl0gPDwgMTYpXG4gICAgICB8IChzW2krM10gPDwgMjQpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgfVxuICB3ID0gMDtcbiAgc3dpdGNoIChsZW4gJiAzKSB7XG4gIGNhc2UgMzogdyAgPSBzW2krMl0gPDwgMTY7XG4gIGNhc2UgMjogdyB8PSBzW2krMV0gPDwgODtcbiAgY2FzZSAxOiB3IHw9IHNbaV07XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICBkZWZhdWx0OlxuICB9XG4gIGggXj0gbGVuO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19jb250ZW50XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2J5dGVzKGgsIHYpIHtcbiAgdmFyIGNvbnRlbnQgPSBjYW1sX21sX2J5dGVzX2NvbnRlbnQodik7XG4gIGlmKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgY29udGVudClcbiAgZWxzZSAvKiBBUlJBWSAqL1xuICAgIHJldHVybiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FycihoLCBjb250ZW50KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9zdHJpbmcoaCwgdikge1xuICByZXR1cm4gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsIGNhbWxfanNieXRlc19vZl9zdHJpbmcodikpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnQsIGNhbWxfaGFzaF9taXhfZmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfZmxvYXQsIGNhbWxfaGFzaF9taXhfc3RyaW5nLCBjYW1sX2hhc2hfbWl4X2J5dGVzLCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9oYXNoIChjb3VudCwgbGltaXQsIHNlZWQsIG9iaikge1xuICB2YXIgcXVldWUsIHJkLCB3ciwgc3osIG51bSwgaCwgdiwgaSwgbGVuO1xuICBzeiA9IGxpbWl0O1xuICBpZiAoc3ogPCAwIHx8IHN6ID4gMjU2KSBzeiA9IDI1NjtcbiAgbnVtID0gY291bnQ7XG4gIGggPSBzZWVkO1xuICBxdWV1ZSA9IFtvYmpdOyByZCA9IDA7IHdyID0gMTtcbiAgd2hpbGUgKHJkIDwgd3IgJiYgbnVtID4gMCkge1xuICAgIHYgPSBxdWV1ZVtyZCsrXTtcbiAgICBpZiAodiAmJiB2LmNhbWxfY3VzdG9tKXtcbiAgICAgIGlmKGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCkge1xuICAgICAgICB2YXIgaGggPSBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCh2KTtcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50IChoLCBoaCk7XG4gICAgICAgIG51bSAtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5ICYmIHZbMF0gPT09ICh2WzBdfDApKSB7XG4gICAgICBzd2l0Y2ggKHZbMF0pIHtcbiAgICAgIGNhc2UgMjQ4OlxuICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHZbMl0pO1xuICAgICAgICBudW0tLTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MDpcbiAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICBxdWV1ZVstLXJkXSA9IHZbMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIHRhZyA9ICgodi5sZW5ndGggLSAxKSA8PCAxMCkgfCB2WzBdO1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdGFnKTtcbiAgICAgICAgZm9yIChpID0gMSwgbGVuID0gdi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICh3ciA+PSBzeikgYnJlYWs7XG4gICAgICAgICAgcXVldWVbd3IrK10gPSB2W2ldO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh2KSkge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfYnl0ZXMoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh2KSkge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsdilcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh2ID09PSAodnwwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHYrdisxKTtcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gK3YpIHtcbiAgICAgIC8vIEZsb2F0XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLHYpO1xuICAgICAgbnVtLS07XG4gICAgfVxuICB9XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpO1xuICByZXR1cm4gaCAmIDB4M0ZGRkZGRkY7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2NvbnN0YW50c1xudmFyIGNhbWxfbWFyc2hhbF9jb25zdGFudHMgPSB7XG4gIFBSRUZJWF9TTUFMTF9CTE9DSzogICAgICAgICAweDgwLFxuICBQUkVGSVhfU01BTExfSU5UOiAgICAgICAgICAgMHg0MCxcbiAgUFJFRklYX1NNQUxMX1NUUklORzogICAgICAgIDB4MjAsXG4gIENPREVfSU5UODogICAgICAgICAgICAgICAgICAweDAwLFxuICBDT0RFX0lOVDE2OiAgICAgICAgICAgICAgICAgMHgwMSxcbiAgQ09ERV9JTlQzMjogICAgICAgICAgICAgICAgIDB4MDIsXG4gIENPREVfSU5UNjQ6ICAgICAgICAgICAgICAgICAweDAzLFxuICBDT0RFX1NIQVJFRDg6ICAgICAgICAgICAgICAgMHgwNCxcbiAgQ09ERV9TSEFSRUQxNjogICAgICAgICAgICAgIDB4MDUsXG4gIENPREVfU0hBUkVEMzI6ICAgICAgICAgICAgICAweDA2LFxuICBDT0RFX0JMT0NLMzI6ICAgICAgICAgICAgICAgMHgwOCxcbiAgQ09ERV9CTE9DSzY0OiAgICAgICAgICAgICAgIDB4MTMsXG4gIENPREVfU1RSSU5HODogICAgICAgICAgICAgICAweDA5LFxuICBDT0RFX1NUUklORzMyOiAgICAgICAgICAgICAgMHgwQSxcbiAgQ09ERV9ET1VCTEVfQklHOiAgICAgICAgICAgIDB4MEIsXG4gIENPREVfRE9VQkxFX0xJVFRMRTogICAgICAgICAweDBDLFxuICBDT0RFX0RPVUJMRV9BUlJBWThfQklHOiAgICAgMHgwRCxcbiAgQ09ERV9ET1VCTEVfQVJSQVk4X0xJVFRMRTogIDB4MEUsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfQklHOiAgICAweDBGLFxuICBDT0RFX0RPVUJMRV9BUlJBWTMyX0xJVFRMRTogMHgwNyxcbiAgQ09ERV9DT0RFUE9JTlRFUjogICAgICAgICAgIDB4MTAsXG4gIENPREVfSU5GSVhQT0lOVEVSOiAgICAgICAgICAweDExLFxuICBDT0RFX0NVU1RPTTogICAgICAgICAgICAgICAgMHgxMixcbiAgQ09ERV9DVVNUT01fTEVOOiAgICAgICAgICAgIDB4MTgsXG4gIENPREVfQ1VTVE9NX0ZJWEVEOiAgICAgICAgICAweDE5XG59XG5cblxuLy9Qcm92aWRlczogTWxTdHJpbmdSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIE1sU3RyaW5nUmVhZGVyIChzLCBpKSB7IHRoaXMucyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7IHRoaXMuaSA9IGk7IH1cbk1sU3RyaW5nUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgcmVhZDh1OmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucy5jaGFyQ29kZUF0KHRoaXMuaSsrKTsgfSxcbiAgcmVhZDhzOmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucy5jaGFyQ29kZUF0KHRoaXMuaSsrKSA8PCAyNCA+PiAyNDsgfSxcbiAgcmVhZDE2dTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSArIDEpXG4gIH0sXG4gIHJlYWQxNnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAocy5jaGFyQ29kZUF0KGkpIDw8IDI0ID4+IDE2KSB8IHMuY2hhckNvZGVBdChpICsgMSk7XG4gIH0sXG4gIHJlYWQzMnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoKHMuY2hhckNvZGVBdChpKSA8PCAyNCkgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgMTYpIHxcbiAgICAgICAgICAgIChzLmNoYXJDb2RlQXQoaSsyKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpKzMpKSA+Pj4gMDtcbiAgfSxcbiAgcmVhZDMyczpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgMjQpIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDE2KSB8XG4gICAgICAocy5jaGFyQ29kZUF0KGkrMikgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSszKTtcbiAgfSxcbiAgcmVhZHN0cjpmdW5jdGlvbiAobGVuKSB7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh0aGlzLnMuc3Vic3RyaW5nKGksIGkgKyBsZW4pKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBCaWdTdHJpbmdSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5LCBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBCaWdTdHJpbmdSZWFkZXIgKGJzLCBpKSB7IHRoaXMucyA9IGJzOyB0aGlzLmkgPSBpOyB9XG5CaWdTdHJpbmdSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6ZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsdGhpcy5pKyspOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsdGhpcy5pKyspIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSA8PCA4KSB8IGNhbWxfYmFfZ2V0XzEocyxpICsgMSlcbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgPDwgMjQgPj4gMTYpIHwgY2FtbF9iYV9nZXRfMShzLGkgKyAxKTtcbiAgfSxcbiAgcmVhZDMydTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgoY2FtbF9iYV9nZXRfMShzLGkpICAgPDwgMjQpIHwgKGNhbWxfYmFfZ2V0XzEocyxpKzEpIDw8IDE2KSB8XG4gICAgICAgICAgICAoY2FtbF9iYV9nZXRfMShzLGkrMikgPDwgOCkgIHwgY2FtbF9iYV9nZXRfMShzLGkrMykgICAgICAgICApID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSAgIDw8IDI0KSB8IChjYW1sX2JhX2dldF8xKHMsaSsxKSA8PCAxNikgfFxuICAgICAgKGNhbWxfYmFfZ2V0XzEocyxpKzIpIDw8IDgpICB8IGNhbWxfYmFfZ2V0XzEocyxpKzMpO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB2YXIgYXJyID0gbmV3IEFycmF5KGxlbilcbiAgICBmb3IodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspe1xuICAgICAgYXJyW2pdID0gY2FtbF9iYV9nZXRfMSh0aGlzLnMsIGkraik7XG4gICAgfVxuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KGFycik7XG4gIH1cbn1cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9mbG9hdF9vZl9ieXRlcyAoYSkge1xuICByZXR1cm4gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIChjYW1sX2ludDY0X29mX2J5dGVzIChhKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogTWxTdHJpbmdSZWFkZXIsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXJcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcocyxvZnMpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBNbFN0cmluZ1JlYWRlciAocywgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBNbFN0cmluZ1JlYWRlciwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlciwgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyhzLG9mcykge1xuICB2YXIgcmVhZGVyID0gbmV3IE1sU3RyaW5nUmVhZGVyIChjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSwgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgc2l6ZVswXSA9IDg7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzICh0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X21hcnNoYWwod3JpdGVyLCB2LCBzaXplcykge1xuICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMgKHYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgd3JpdGVyLndyaXRlICg4LCBiW2ldKTtcbiAgc2l6ZXNbMF0gPSA4OyBzaXplc1sxXSA9IDg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfdW5tYXJzaGFsXG5mdW5jdGlvbiBjYW1sX2ludDMyX3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICBzaXplWzBdID0gNDtcbiAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICBzd2l0Y2ggKHJlYWRlci5yZWFkOHUgKCkpIHtcbiAgY2FzZSAxOlxuICAgIHNpemVbMF0gPSA0O1xuICAgIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbiAgY2FzZSAyOlxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogbmF0aXZlIGludGVnZXIgdmFsdWUgdG9vIGxhcmdlXCIpO1xuICBkZWZhdWx0OiBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGlsbC1mb3JtZWQgbmF0aXZlIGludGVnZXJcIik7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3VubWFyc2hhbCwgY2FtbF9pbnQ2NF9tYXJzaGFsLCBjYW1sX2ludDY0X2NvbXBhcmUsIGNhbWxfaW50NjRfaGFzaFxuLy9SZXF1aXJlczogY2FtbF9pbnQzMl91bm1hcnNoYWwsIGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9iYV9zZXJpYWxpemUsIGNhbWxfYmFfZGVzZXJpYWxpemUsIGNhbWxfYmFfY29tcGFyZSwgY2FtbF9iYV9oYXNoXG52YXIgY2FtbF9jdXN0b21fb3BzID1cbiAgICB7XCJfalwiOiB7XG4gICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfaW50NjRfdW5tYXJzaGFsLFxuICAgICAgc2VyaWFsaXplICA6IGNhbWxfaW50NjRfbWFyc2hhbCxcbiAgICAgIGZpeGVkX2xlbmd0aCA6IDgsXG4gICAgICBjb21wYXJlIDogY2FtbF9pbnQ2NF9jb21wYXJlLFxuICAgICAgaGFzaCA6IGNhbWxfaW50NjRfaGFzaFxuICAgIH0sXG4gICAgIFwiX2lcIjoge1xuICAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9pbnQzMl91bm1hcnNoYWwsXG4gICAgICAgZml4ZWRfbGVuZ3RoIDogNCxcbiAgICAgfSxcbiAgICAgXCJfblwiOiB7XG4gICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWwsXG4gICAgICAgZml4ZWRfbGVuZ3RoIDogNCxcbiAgICAgfSxcbiAgICAgXCJfYmlnYXJyYXlcIjp7XG4gICAgICAgZGVzZXJpYWxpemUgOiAoZnVuY3Rpb24gKHJlYWRlciwgc3opIHtyZXR1cm4gY2FtbF9iYV9kZXNlcmlhbGl6ZSAocmVhZGVyLHN6LFwiX2JpZ2FycmF5XCIpfSksXG4gICAgICAgc2VyaWFsaXplIDogY2FtbF9iYV9zZXJpYWxpemUsXG4gICAgICAgY29tcGFyZSA6IGNhbWxfYmFfY29tcGFyZSxcbiAgICAgICBoYXNoOiBjYW1sX2JhX2hhc2gsXG4gICAgIH0sXG4gICAgIFwiX2JpZ2FycjAyXCI6e1xuICAgICAgIGRlc2VyaWFsaXplIDogKGZ1bmN0aW9uIChyZWFkZXIsIHN6KSB7cmV0dXJuIGNhbWxfYmFfZGVzZXJpYWxpemUgKHJlYWRlcixzeixcIl9iaWdhcnIwMlwiKX0pLFxuICAgICAgIHNlcmlhbGl6ZSA6IGNhbWxfYmFfc2VyaWFsaXplLFxuICAgICAgIGNvbXBhcmUgOiBjYW1sX2JhX2NvbXBhcmUsXG4gICAgICAgaGFzaDogY2FtbF9iYV9oYXNoLFxuICAgICB9XG4gICAgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXMsIGNhbWxfY3VzdG9tX29wc1xuXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKSB7XG4gIHZhciBfbWFnaWMgPSByZWFkZXIucmVhZDMydSAoKVxuICB2YXIgX2Jsb2NrX2xlbiA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgbnVtX29iamVjdHMgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIF9zaXplXzMyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBfc2l6ZV82NCA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGludGVybl9vYmpfdGFibGUgPSAobnVtX29iamVjdHMgPiAwKT9bXTpudWxsO1xuICB2YXIgb2JqX2NvdW50ZXIgPSAwO1xuICBmdW5jdGlvbiBpbnRlcm5fcmVjICgpIHtcbiAgICB2YXIgY29kZSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgaWYgKGNvZGUgPj0gMHg0MCAvKmNzdC5QUkVGSVhfU01BTExfSU5UKi8pIHtcbiAgICAgIGlmIChjb2RlID49IDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8pIHtcbiAgICAgICAgdmFyIHRhZyA9IGNvZGUgJiAweEY7XG4gICAgICAgIHZhciBzaXplID0gKGNvZGUgPj4gNCkgJiAweDc7XG4gICAgICAgIHZhciB2ID0gW3RhZ107XG4gICAgICAgIGlmIChzaXplID09IDApIHJldHVybiB2O1xuICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiAoY29kZSAmIDB4M0YpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29kZSA+PSAweDIwLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyAqLykge1xuICAgICAgICB2YXIgbGVuID0gY29kZSAmIDB4MUY7XG4gICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2goY29kZSkge1xuICAgICAgICBjYXNlIDB4MDA6IC8vY3N0LkNPREVfSU5UODpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQ4cyAoKTtcbiAgICAgICAgY2FzZSAweDAxOiAvL2NzdC5DT0RFX0lOVDE2OlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDE2cyAoKTtcbiAgICAgICAgY2FzZSAweDAyOiAvL2NzdC5DT0RFX0lOVDMyOlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbiAgICAgICAgY2FzZSAweDAzOiAvL2NzdC5DT0RFX0lOVDY0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaW50ZWdlciB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwNDogLy9jc3QuQ09ERV9TSEFSRUQ4OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyIC0gb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA1OiAvL2NzdC5DT0RFX1NIQVJFRDE2OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDE2dSAoKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlciAtIG9mZnNldF07XG4gICAgICAgIGNhc2UgMHgwNjogLy9jc3QuQ09ERV9TSEFSRUQzMjpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIgLSBvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDg6IC8vY3N0LkNPREVfQkxPQ0szMjpcbiAgICAgICAgICB2YXIgaGVhZGVyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgdmFyIHRhZyA9IGhlYWRlciAmIDB4RkY7XG4gICAgICAgICAgdmFyIHNpemUgPSBoZWFkZXIgPj4gMTA7XG4gICAgICAgICAgdmFyIHYgPSBbdGFnXTtcbiAgICAgICAgICBpZiAoc2l6ZSA9PSAwKSByZXR1cm4gdjtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDEzOiAvL2NzdC5DT0RFX0JMT0NLNjQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogZGF0YSBibG9jayB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwOTogLy9jc3QuQ09ERV9TVFJJTkc4OlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQTogLy9jc3QuQ09ERV9TVFJJTkczMjpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBDOiAvL2NzdC5DT0RFX0RPVUJMRV9MSVRUTEU6XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCA4O2krKykgdFs3IC0gaV0gPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHZhciB2ID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEI6IC8vY3N0LkNPREVfRE9VQkxFX0JJRzpcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IDg7aSsrKSB0W2ldID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICB2YXIgdiA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBFOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWThfTElUVExFOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEQ6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZOF9CSUc6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdiBbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwNzogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVkzMl9MSVRUTEU6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEY6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZMzJfQklHOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHYgW2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MTA6IC8vY3N0LkNPREVfQ09ERVBPSU5URVI6XG4gICAgICAgIGNhc2UgMHgxMTogLy9jc3QuQ09ERV9JTkZJWFBPSU5URVI6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogY29kZSBwb2ludGVyXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MTI6IC8vY3N0LkNPREVfQ1VTVE9NOlxuICAgICAgICBjYXNlIDB4MTg6IC8vY3N0LkNPREVfQ1VTVE9NX0xFTjpcbiAgICAgICAgY2FzZSAweDE5OiAvL2NzdC5DT0RFX0NVU1RPTV9GSVhFRDpcbiAgICAgICAgICB2YXIgYywgcyA9IFwiXCI7XG4gICAgICAgICAgd2hpbGUgKChjID0gcmVhZGVyLnJlYWQ4dSAoKSkgIT0gMCkgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlIChjKTtcbiAgICAgICAgICB2YXIgb3BzID0gY2FtbF9jdXN0b21fb3BzW3NdO1xuICAgICAgICAgIHZhciBleHBlY3RlZF9zaXplO1xuICAgICAgICAgIGlmKCFvcHMpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHVua25vd24gY3VzdG9tIGJsb2NrIGlkZW50aWZpZXJcIik7XG4gICAgICAgICAgc3dpdGNoKGNvZGUpe1xuICAgICAgICAgIGNhc2UgMHgxMjogLy8gY3N0LkNPREVfQ1VTVE9NIChkZXByZWNhdGVkKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDE5OiAvLyBjc3QuQ09ERV9DVVNUT01fRklYRURcbiAgICAgICAgICAgIGlmKCFvcHMuZml4ZWRfbGVuZ3RoKVxuICAgICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGV4cGVjdGVkIGEgZml4ZWQtc2l6ZSBjdXN0b20gYmxvY2tcIik7XG4gICAgICAgICAgICBleHBlY3RlZF9zaXplID0gb3BzLmZpeGVkX2xlbmd0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMHgxODogLy8gY3N0LkNPREVfQ1VTVE9NX0xFTlxuICAgICAgICAgICAgZXhwZWN0ZWRfc2l6ZSA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgICAgICAgICAgLy8gU2tpcCBzaXplNjRcbiAgICAgICAgICAgIHJlYWRlci5yZWFkMzJzKCk7IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9sZF9wb3MgPSByZWFkZXIuaTtcbiAgICAgICAgICB2YXIgc2l6ZSA9IFswXTtcbiAgICAgICAgICB2YXIgdiA9IG9wcy5kZXNlcmlhbGl6ZShyZWFkZXIsIHNpemUpO1xuICAgICAgICAgIGlmKGV4cGVjdGVkX3NpemUgIT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIGlmKGV4cGVjdGVkX3NpemUgIT0gc2l6ZVswXSlcbiAgICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbmNvcnJlY3QgbGVuZ3RoIG9mIHNlcmlhbGl6ZWQgY3VzdG9tIGJsb2NrXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogaWxsLWZvcm1lZCBtZXNzYWdlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciByZXMgPSBpbnRlcm5fcmVjICgpO1xuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIHZhciBzaXplID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZCA9IHYubGVuZ3RoO1xuICAgIGlmIChkIDwgc2l6ZSkgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICB2W2RdID0gaW50ZXJuX3JlYyAoKTtcbiAgfVxuICBpZiAodHlwZW9mIG9mcyE9XCJudW1iZXJcIikgb2ZzWzBdID0gcmVhZGVyLmk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX21hcnNoYWxfZGF0YV9zaXplIChzLCBvZnMpIHtcbiAgZnVuY3Rpb24gZ2V0MzIocyxpKSB7XG4gICAgcmV0dXJuIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSkgPDwgMjQpIHxcbiAgICAgIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDEpIDw8IDE2KSB8XG4gICAgICAoY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkgKyAyKSA8PCA4KSB8XG4gICAgICBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDMpO1xuICB9XG4gIGlmIChnZXQzMihzLCBvZnMpICE9ICgweDg0OTVBNkJFfDApKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJNYXJzaGFsLmRhdGFfc2l6ZTogYmFkIG9iamVjdFwiKTtcbiAgcmV0dXJuIChnZXQzMihzLCBvZnMgKyA0KSk7XG59XG5cbi8vUHJvdmlkZXM6IE1sT2JqZWN0VGFibGVcbnZhciBNbE9iamVjdFRhYmxlO1xuaWYgKHR5cGVvZiBnbG9iYWxUaGlzLldlYWtNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gIE1sT2JqZWN0VGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBwb2x5ZmlsbCAodXNpbmcgbGluZWFyIHNlYXJjaCkgKi9cbiAgICBmdW5jdGlvbiBOYWl2ZUxvb2t1cChvYmpzKSB7IHRoaXMub2JqcyA9IG9ianM7IH1cbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24odikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMub2Jqc1tpXSA9PT0gdikgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfTtcbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBEbyBub3RoaW5nIGhlcmUuIFtNbE9iamVjdFRhYmxlLnN0b3JlXSB3aWxsIHB1c2ggdG8gW3RoaXMub2Jqc10gZGlyZWN0bHkuXG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBNbE9iamVjdFRhYmxlKCkge1xuICAgICAgdGhpcy5vYmpzID0gW107IHRoaXMubG9va3VwID0gbmV3IE5haXZlTG9va3VwKHRoaXMub2Jqcyk7XG4gICAgfTtcbiAgfSgpO1xufVxuZWxzZSB7XG4gIE1sT2JqZWN0VGFibGUgPSBmdW5jdGlvbiBNbE9iamVjdFRhYmxlKCkge1xuICAgIHRoaXMub2JqcyA9IFtdOyB0aGlzLmxvb2t1cCA9IG5ldyBnbG9iYWxUaGlzLldlYWtNYXAoKTtcbiAgfTtcbn1cblxuTWxPYmplY3RUYWJsZS5wcm90b3R5cGUuc3RvcmUgPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMubG9va3VwLnNldCh2LCB0aGlzLm9ianMubGVuZ3RoKTtcbiAgdGhpcy5vYmpzLnB1c2godik7XG59XG5cbk1sT2JqZWN0VGFibGUucHJvdG90eXBlLnJlY2FsbCA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIGkgPSB0aGlzLmxvb2t1cC5nZXQodik7XG4gIHJldHVybiAoaSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkIDogdGhpcy5vYmpzLmxlbmd0aCAtIGk7ICAgLyogaW5kZXggaXMgcmVsYXRpdmUgKi9cbn1cblxuLy9Qcm92aWRlczogY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGVcbi8vVmVyc2lvbjogPj0gNC4wOFxudmFyIGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlID0gZmFsc2VcblxuLy9Qcm92aWRlczogY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGVcbi8vVmVyc2lvbjogPCA0LjA4XG52YXIgY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUgPSB0cnVlXG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0XG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzLCBjYW1sX21sX2J5dGVzX2xlbmd0aCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBNbE9iamVjdFRhYmxlLCBjYW1sX2xpc3RfdG9fanNfYXJyYXksIGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlLCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCxjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG52YXIgY2FtbF9vdXRwdXRfdmFsID0gZnVuY3Rpb24gKCl7XG4gIGZ1bmN0aW9uIFdyaXRlciAoKSB7IHRoaXMuY2h1bmsgPSBbXTsgfVxuICBXcml0ZXIucHJvdG90eXBlID0ge1xuICAgIGNodW5rX2lkeDoyMCwgYmxvY2tfbGVuOjAsIG9ial9jb3VudGVyOjAsIHNpemVfMzI6MCwgc2l6ZV82NDowLFxuICAgIHdyaXRlOmZ1bmN0aW9uIChzaXplLCB2YWx1ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfYXQ6ZnVuY3Rpb24gKHBvcywgc2l6ZSwgdmFsdWUpIHtcbiAgICAgIHZhciBwb3MgPSBwb3M7XG4gICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIDg7aSA+PSAwO2kgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1twb3MrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfY29kZTpmdW5jdGlvbiAoc2l6ZSwgY29kZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSBjb2RlO1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfc2hhcmVkOmZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgIGlmIChvZmZzZXQgPCAoMSA8PCA4KSkgdGhpcy53cml0ZV9jb2RlKDgsIDB4MDQgLypjc3QuQ09ERV9TSEFSRUQ4Ki8sIG9mZnNldCk7XG4gICAgICBlbHNlIGlmIChvZmZzZXQgPCAoMSA8PCAxNikpIHRoaXMud3JpdGVfY29kZSgxNiwgMHgwNSAvKmNzdC5DT0RFX1NIQVJFRDE2Ki8sIG9mZnNldCk7XG4gICAgICBlbHNlIHRoaXMud3JpdGVfY29kZSgzMiwgMHgwNiAvKmNzdC5DT0RFX1NIQVJFRDMyKi8sIG9mZnNldCk7XG4gICAgfSxcbiAgICBwb3M6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jaHVua19pZHggfSxcbiAgICBmaW5hbGl6ZTpmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmJsb2NrX2xlbiA9IHRoaXMuY2h1bmtfaWR4IC0gMjA7XG4gICAgICB0aGlzLmNodW5rX2lkeCA9IDA7XG4gICAgICB0aGlzLndyaXRlICgzMiwgMHg4NDk1QTZCRSk7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5ibG9ja19sZW4pO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMub2JqX2NvdW50ZXIpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuc2l6ZV8zMik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5zaXplXzY0KTtcbiAgICAgIHJldHVybiB0aGlzLmNodW5rO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKHYsIGZsYWdzKSB7XG4gICAgZmxhZ3MgPSBjYW1sX2xpc3RfdG9fanNfYXJyYXkoZmxhZ3MpO1xuXG4gICAgdmFyIG5vX3NoYXJpbmcgPSAoZmxhZ3MuaW5kZXhPZigwIC8qTWFyc2hhbC5Ob19zaGFyaW5nKi8pICE9PSAtMSksXG4gICAgICAgIGNsb3N1cmVzID0gIChmbGFncy5pbmRleE9mKDEgLypNYXJzaGFsLkNsb3N1cmVzKi8pICE9PSAtMSk7XG4gICAgLyogTWFyc2hhbC5Db21wYXRfMzIgaXMgcmVkdW5kYW50IHNpbmNlIGludGVnZXJzIGFyZSAzMi1iaXQgYW55d2F5ICovXG5cbiAgICBpZiAoY2xvc3VyZXMpXG4gICAgICBnbG9iYWxUaGlzLmNvbnNvbGUud2FybihcImluIGNhbWxfb3V0cHV0X3ZhbDogZmxhZyBNYXJzaGFsLkNsb3N1cmVzIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuXG4gICAgdmFyIHdyaXRlciA9IG5ldyBXcml0ZXIgKCk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIGludGVybl9vYmpfdGFibGUgPSBub19zaGFyaW5nID8gbnVsbCA6IG5ldyBNbE9iamVjdFRhYmxlKCk7XG5cbiAgICBmdW5jdGlvbiBtZW1vKHYpIHtcbiAgICAgIGlmIChub19zaGFyaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgZXhpc3Rpbmdfb2Zmc2V0ID0gaW50ZXJuX29ial90YWJsZS5yZWNhbGwodik7XG4gICAgICBpZiAoZXhpc3Rpbmdfb2Zmc2V0KSB7IHdyaXRlci53cml0ZV9zaGFyZWQoZXhpc3Rpbmdfb2Zmc2V0KTsgcmV0dXJuIHRydWU7IH1cbiAgICAgIGVsc2UgeyBpbnRlcm5fb2JqX3RhYmxlLnN0b3JlKHYpOyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlcm5fcmVjICh2KSB7XG4gICAgICBpZiAodi5jYW1sX2N1c3RvbSkge1xuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbmFtZSA9IHYuY2FtbF9jdXN0b207XG4gICAgICAgIHZhciBvcHMgPSBjYW1sX2N1c3RvbV9vcHNbbmFtZV07XG4gICAgICAgIHZhciBzel8zMl82NCA9IFswLDBdO1xuICAgICAgICBpZighb3BzLnNlcmlhbGl6ZSlcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChDdXN0b20pXCIpO1xuICAgICAgICBpZihjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSkge1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxMiAvKmNzdC5DT0RFX0NVU1RPTSovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIG9wcy5zZXJpYWxpemUod3JpdGVyLCB2LCBzel8zMl82NCk7XG4gICAgICAgIH0gZWxzZSBpZihvcHMuZml4ZWRfbGVuZ3RoID09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDE4IC8qY3N0LkNPREVfQ1VTVE9NX0xFTiovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIHZhciBoZWFkZXJfcG9zID0gd3JpdGVyLnBvcyAoKTtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zLCAzMiwgc3pfMzJfNjRbMF0pO1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zICsgNCwgMzIsIDApOyAvLyB6ZXJvXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2F0KGhlYWRlcl9wb3MgKyA4LCAzMiwgc3pfMzJfNjRbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxOSAvKmNzdC5DT0RFX0NVU1RPTV9GSVhFRCovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIHZhciBvbGRfcG9zID0gd3JpdGVyLnBvcygpO1xuICAgICAgICAgIG9wcy5zZXJpYWxpemUod3JpdGVyLCB2LCBzel8zMl82NCk7XG4gICAgICAgICAgaWYgKG9wcy5maXhlZF9sZW5ndGggIT0gd3JpdGVyLnBvcygpIC0gb2xkX3BvcylcbiAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGluY29ycmVjdCBmaXhlZCBzaXplcyBzcGVjaWZpZWQgYnkgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSAyICsgKChzel8zMl82NFswXSArIDMpID4+IDIpO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAyICsgKChzel8zMl82NFsxXSArIDcpID4+IDMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5ICYmIHZbMF0gPT09ICh2WzBdfDApKSB7XG4gICAgICAgIGlmICh2WzBdID09IDI1MSkge1xuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChBYnN0cmFjdClcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYubGVuZ3RoID4gMSAmJiBtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIGlmICh2WzBdIDwgMTYgJiYgdi5sZW5ndGggLSAxIDwgOClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8gKyB2WzBdICsgKCh2Lmxlbmd0aCAtIDEpPDw0KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwOCAvKmNzdC5DT0RFX0JMT0NLMzIqLywgKCh2Lmxlbmd0aC0xKSA8PCAxMCkgfCB2WzBdKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gdi5sZW5ndGg7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IHYubGVuZ3RoO1xuICAgICAgICBpZiAodi5sZW5ndGggPiAxKSBzdGFjay5wdXNoICh2LCAxKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh2KSkge1xuICAgICAgICBpZighKGNhbWxfaXNfbWxfYnl0ZXMoY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKSkpKSB7XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogW0J5dGVzLnRdIGNhbm5vdCBzYWZlbHkgYmUgbWFyc2hhbGVkIHdpdGggWy0tZW5hYmxlIHVzZS1qcy1zdHJpbmddXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIHZhciBsZW4gPSBjYW1sX21sX2J5dGVzX2xlbmd0aCh2KTtcbiAgICAgICAgaWYgKGxlbiA8IDB4MjApXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDIwIC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcqLyArIGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA8IDB4MTAwKVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICg4LCAweDA5Lypjc3QuQ09ERV9TVFJJTkc4Ki8sIGxlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoMzIsIDB4MEEgLypjc3QuQ09ERV9TVFJJTkczMiovLCBsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGVuO2krKylcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCh2LGkpKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMSArICgoKGxlbiArIDQpIC8gNCl8MCk7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDEgKyAoKChsZW4gKyA4KSAvIDgpfDApO1xuICAgICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh2KSkge1xuICAgICAgICB2YXIgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHYpO1xuICAgICAgICBpZiAobGVuIDwgMHgyMClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MjAgLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyovICsgbGVuKTtcbiAgICAgICAgZWxzZSBpZiAobGVuIDwgMHgxMDApXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDgsIDB4MDkvKmNzdC5DT0RFX1NUUklORzgqLywgbGVuKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICgzMiwgMHgwQSAvKmNzdC5DT0RFX1NUUklORzMyKi8sIGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCBsZW47aSsrKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldCh2LGkpKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMSArICgoKGxlbiArIDQpIC8gNCl8MCk7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDEgKyAoKChsZW4gKyA4KSAvIDgpfDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHYgIT0gKHZ8MCkpe1xuICAgICAgICAgIHZhciB0eXBlX29mX3YgPSB0eXBlb2YgdjtcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIElmIGEgZmxvYXQgaGFwcGVucyB0byBiZSBhbiBpbnRlZ2VyIGl0IGlzIHNlcmlhbGl6ZWQgYXMgYW4gaW50ZWdlclxuICAgICAgICAgIC8vIChKc19vZl9vY2FtbCBjYW5ub3QgdGVsbCB3aGV0aGVyIHRoZSB0eXBlIG9mIGFuIGludGVnZXIgbnVtYmVyIGlzXG4gICAgICAgICAgLy8gZmxvYXQgb3IgaW50ZWdlci4pIFRoaXMgY2FuIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGNyYXNoZXMgd2hlblxuICAgICAgICAgIC8vIHVubWFyc2hhbGxpbmcgdXNpbmcgdGhlIHN0YW5kYXJkIHJ1bnRpbWUuIEl0IHNlZW1zIGJldHRlciB0b1xuICAgICAgICAgIC8vIHN5c3RlbWF0aWNhbGx5IGZhaWwgb24gbWFyc2hhbGxpbmcuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAgICAgICAgICBpZih0eXBlX29mX3YgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoXCIrdHlwZV9vZl92K1wiKVwiKTtcbiAgICAgICAgICAvLyAgICAgICAgICB2YXIgdCA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHYpKTtcbiAgICAgICAgICAvLyAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MEIgLypjc3QuQ09ERV9ET1VCTEVfQklHKi8pO1xuICAgICAgICAgIC8vICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGk8ODsgaSsrKXt3cml0ZXIud3JpdGUoOCx0W2ldKX1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID49IDAgJiYgdiA8IDB4NDApIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDBYNDAgLypjc3QuUFJFRklYX1NNQUxMX0lOVCovICsgdik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHYgPj0gLSgxIDw8IDcpICYmIHYgPCAoMSA8PCA3KSlcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDgsIDB4MDAgLypjc3QuQ09ERV9JTlQ4Ki8sIHYpO1xuICAgICAgICAgIGVsc2UgaWYgKHYgPj0gLSgxIDw8IDE1KSAmJiB2IDwgKDEgPDwgMTUpKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMTYsIDB4MDEgLypjc3QuQ09ERV9JTlQxNiovLCB2KTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwMiAvKmNzdC5DT0RFX0lOVDMyKi8sIHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGV4dGVybl9yZWMgKHYpO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgaSA9IHN0YWNrLnBvcCAoKTtcbiAgICAgIHZhciB2ID0gc3RhY2sucG9wICgpO1xuICAgICAgaWYgKGkgKyAxIDwgdi5sZW5ndGgpIHN0YWNrLnB1c2ggKHYsIGkgKyAxKTtcbiAgICAgIGV4dGVybl9yZWMgKHZbaV0pO1xuICAgIH1cbiAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgd3JpdGVyLm9ial9jb3VudGVyID0gaW50ZXJuX29ial90YWJsZS5vYmpzLmxlbmd0aDtcbiAgICB3cml0ZXIuZmluYWxpemUoKTtcbiAgICByZXR1cm4gd3JpdGVyLmNodW5rO1xuICB9XG59ICgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX3N0cmluZ19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nICh2LCBmbGFncykge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkgKGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX2J5dGVzX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyAodiwgZmxhZ3MpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfYXJyYXkgKGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfZmFpbHdpdGgsIGNhbWxfYmxpdF9ieXRlc1xuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyIChzLCBvZnMsIGxlbiwgdiwgZmxhZ3MpIHtcbiAgdmFyIHQgPSBjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKTtcbiAgaWYgKHQubGVuZ3RoID4gbGVuKSBjYW1sX2ZhaWx3aXRoIChcIk1hcnNoYWwudG9fYnVmZmVyOiBidWZmZXIgb3ZlcmZsb3dcIik7XG4gIGNhbWxfYmxpdF9ieXRlcyh0LCAwLCBzLCBvZnMsIHQubGVuZ3RoKTtcbiAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWxfdGFnKGEpe1xuICBpZiAodHlwZW9mIGEgPT09IFwibnVtYmVyXCIpIHJldHVybiAxMDAwOyAvLyBpbnRfdGFnICh3ZSB1c2UgaXQgZm9yIGFsbCBudW1iZXJzKVxuICBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKGEpKSByZXR1cm4gMjUyOyAvLyBzdHJpbmdfdGFnXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKGEpKSByZXR1cm4gMTI1MjsgLy8gb2NhbWwgc3RyaW5nIChpZiBkaWZmZXJlbnQgZnJvbSBieXRlcylcbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIEFycmF5ICYmIGFbMF0gPT09IChhWzBdPj4+MCkgJiYgYVswXSA8PSAyNTUpIHtcbiAgICAvLyBMb29rIGxpa2UgYW4gb2NhbWwgYmxvY2tcbiAgICB2YXIgdGFnID0gYVswXSB8IDA7XG4gICAgLy8gaWdub3JlIGRvdWJsZV9hcnJheV90YWcgYmVjYXVzZSB3ZSBjYW5ub3QgYWNjdXJhdGVseSBzZXRcbiAgICAvLyB0aGlzIHRhZyB3aGVuIHdlIGNyZWF0ZSBhbiBhcnJheSBvZiBmbG9hdC5cbiAgICByZXR1cm4gKHRhZyA9PSAyNTQpPzA6dGFnXG4gIH1cbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIFN0cmluZykgcmV0dXJuIDEyNTIwOyAvLyBqYXZhc2NyaXB0IHN0cmluZywgbGlrZSBzdHJpbmdfdGFnICgyNTIpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpIHJldHVybiAxMjUyMDsgLy8gamF2YXNjcmlwdCBzdHJpbmcsIGxpa2Ugc3RyaW5nX3RhZyAoMjUyKVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgTnVtYmVyKSByZXR1cm4gMTAwMDsgLy8gaW50X3RhZyAod2UgdXNlIGl0IGZvciBhbGwgbnVtYmVycylcbiAgZWxzZSBpZiAoYSAmJiBhLmNhbWxfY3VzdG9tKSByZXR1cm4gMTI1NTsgLy8gbGlrZSBjdXN0b21fdGFnICgyNTUpXG4gIGVsc2UgaWYgKGEgJiYgYS5jb21wYXJlKSByZXR1cm4gMTI1NjsgLy8gbGlrZSBjdXN0b21fdGFnICgyNTUpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIDEyNDc7IC8vIGxpa2UgY2xvc3VyZV90YWcgKDI0NylcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJzeW1ib2xcIikgcmV0dXJuIDEyNTE7XG4gIHJldHVybiAxMDAxOyAvL291dF9vZl9oZWFwX3RhZ1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX29wc1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGEpe1xuICByZXR1cm4gY2FtbF9jdXN0b21fb3BzW2EuY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1thLmNhbWxfY3VzdG9tXS5jb21wYXJlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbVxuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tKG51bSwgY3VzdG9tLCBzd2FwLCB0b3RhbCkge1xuICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShjdXN0b20pO1xuICBpZihjb21wKSB7XG4gICAgdmFyIHggPSAoc3dhcCA+IDApP2NvbXAoY3VzdG9tLG51bSx0b3RhbCk6Y29tcChudW0sY3VzdG9tLHRvdGFsKTtcbiAgICBpZih0b3RhbCAmJiB4ICE9IHgpIHJldHVybiBzd2FwOyAvLyB0b3RhbCAmJiBuYW5cbiAgICBpZigreCAhPSAreCkgcmV0dXJuICt4OyAvLyBuYW5cbiAgICBpZigoeCB8IDApICE9IDApIHJldHVybiAoeCB8IDApOyAvLyAhbmFuXG4gIH1cbiAgcmV0dXJuIHN3YXBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbCAoY29uc3QsIGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfaW50X2NvbXBhcmUsIGNhbWxfc3RyaW5nX2NvbXBhcmUsIGNhbWxfYnl0ZXNfY29tcGFyZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20sIGNhbWxfY29tcGFyZV92YWxfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWwgKGEsIGIsIHRvdGFsKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICBmb3IoOzspIHtcbiAgICBpZiAoISh0b3RhbCAmJiBhID09PSBiKSkge1xuICAgICAgdmFyIHRhZ19hID0gY2FtbF9jb21wYXJlX3ZhbF90YWcoYSk7XG4gICAgICAvLyBmb3J3YXJkX3RhZyA/XG4gICAgICBpZih0YWdfYSA9PSAyNTApIHsgYSA9IGFbMV07IGNvbnRpbnVlIH1cblxuICAgICAgdmFyIHRhZ19iID0gY2FtbF9jb21wYXJlX3ZhbF90YWcoYik7XG4gICAgICAvLyBmb3J3YXJkX3RhZyA/XG4gICAgICBpZih0YWdfYiA9PSAyNTApIHsgYiA9IGJbMV07IGNvbnRpbnVlIH1cblxuICAgICAgLy8gdGFncyBhcmUgZGlmZmVyZW50XG4gICAgICBpZih0YWdfYSAhPT0gdGFnX2IpIHtcbiAgICAgICAgaWYodGFnX2EgPT0gMTAwMCkge1xuICAgICAgICAgIGlmKHRhZ19iID09IDEyNTUpIHsgLy9pbW1lZGlhdGUgY2FuIGNvbXBhcmUgYWdhaW5zdCBjdXN0b21cbiAgICAgICAgICAgIHJldHVybiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20oYSwgYiwgLTEsIHRvdGFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgIH1cbiAgICAgICAgaWYodGFnX2IgPT0gMTAwMCkge1xuICAgICAgICAgIGlmKHRhZ19hID09IDEyNTUpIHsgLy9pbW1lZGlhdGUgY2FuIGNvbXBhcmUgYWdhaW5zdCBjdXN0b21cbiAgICAgICAgICAgIHJldHVybiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20oYiwgYSwgMSwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGFnX2EgPCB0YWdfYik/LTE6MTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCh0YWdfYSl7XG4gICAgICAgIC8vIDI0NjogTGF6eV90YWcgaGFuZGxlZCBiZWxsb3dcbiAgICAgIGNhc2UgMjQ3OiAvLyBDbG9zdXJlX3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI0ODogLy8gT2JqZWN0XG4gICAgICAgIHZhciB4ID0gY2FtbF9pbnRfY29tcGFyZShhWzJdLCBiWzJdKTtcbiAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuICh4IHwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNDk6IC8vIEluZml4XG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjUwOiAvLyBGb3J3YXJkIHRhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuLCBoYW5kbGVkIGFib3ZlXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRm9yd2FyZF90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUxOiAvL0Fic3RyYWN0XG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBhYnN0cmFjdCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MjogLy8gT0NhbWwgYnl0ZXNcbiAgICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICB2YXIgeCA9IGNhbWxfYnl0ZXNfY29tcGFyZShhLCBiKTtcbiAgICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MzogLy8gRG91YmxlX3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRG91YmxlX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTQ6IC8vIERvdWJsZV9hcnJheV90YWdcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlbiwgaGFuZGxlZCBhYm92ZVxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IERvdWJsZV9hcnJheV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNTU6IC8vIEN1c3RvbV90YWdcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBDdXN0b21fdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNDc6IC8vIEZ1bmN0aW9uXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjU1OiAvLyBDdXN0b21cbiAgICAgICAgdmFyIGNvbXAgPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYSk7XG4gICAgICAgIGlmKGNvbXAgIT0gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGIpKXtcbiAgICAgICAgICByZXR1cm4gKGEuY2FtbF9jdXN0b208Yi5jYW1sX2N1c3RvbSk/LTE6MTtcbiAgICAgICAgfVxuICAgICAgICBpZighY29tcClcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBhYnN0cmFjdCB2YWx1ZVwiKTtcbiAgICAgICAgdmFyIHggPSBjb21wKGEsYix0b3RhbCk7XG4gICAgICAgIGlmKHggIT0geCl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIFVOT1JERVJFRFxuICAgICAgICAgIHJldHVybiB0b3RhbD8tMTp4O1xuICAgICAgICB9XG4gICAgICAgIGlmKHggIT09ICh4fDApKXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuICh4IHwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjU2OiAvLyBjb21wYXJlIGZ1bmN0aW9uXG4gICAgICAgIHZhciB4ID0gYS5jb21wYXJlKGIsdG90YWwpO1xuICAgICAgICBpZih4ICE9IHgpIHsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgVU5PUkRFUkVEXG4gICAgICAgICAgcmV0dXJuIHRvdGFsPy0xOng7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCAhPT0gKHh8MCkpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCByZXR1cm4gdmFsdWVcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEwMDA6IC8vIE51bWJlclxuICAgICAgICBhID0gK2E7XG4gICAgICAgIGIgPSArYjtcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwMTogLy8gVGhlIHJlc3RcbiAgICAgICAgLy8gSGVyZSB3ZSBjYW4gYmUgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAgICAgLy8gMS4gSmF2YVNjcmlwdCBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy8gMi4gSmF2YVNjcmlwdCBvYmplY3QgdGhhdCBjYW4gYmUgY29lcmNlZCB0byBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy8gMy4gSmF2YVNjcmlwdCBvYmplY3QgdGhhbiBjYW5ub3QgYmUgY29lcmNlZCB0byBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gKDMpIHdpbGwgcmFpc2UgYSBbVHlwZUVycm9yXVxuICAgICAgICAvLyAoMikgd2lsbCBjb2VyY2UgdG8gcHJpbWl0aXZlIHR5cGVzIHVzaW5nIFt2YWx1ZU9mXSBvciBbdG9TdHJpbmddXG4gICAgICAgIC8vICgyKSBhbmQgKDMpLCBhZnRlciBldmVudHVhbCBjb2VyY2lvblxuICAgICAgICAvLyAtIGlmIGEgYW5kIGIgYXJlIHN0cmluZ3MsIGFwcGx5IGxleGljb2dyYXBoaWMgY29tcGFyaXNvblxuICAgICAgICAvLyAtIGlmIGEgb3IgYiBhcmUgbm90IHN0cmluZ3MsIGNvbnZlcnQgYSBhbmQgYiB0byBudW1iZXJcbiAgICAgICAgLy8gICBhbmQgYXBwbHkgc3RhbmRhcmQgY29tcGFyaXNvblxuICAgICAgICAvL1xuICAgICAgICAvLyBFeGNlcHRpb246IGAhPWAgd2lsbCBub3QgY29lcmNlL2NvbnZlcnQgaWYgYm90aCBhIGFuZCBiIGFyZSBvYmplY3RzXG4gICAgICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICBpZiAoYSAhPSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICBpZiAoYSA9PSBhKSByZXR1cm4gMTtcbiAgICAgICAgICBpZiAoYiA9PSBiKSByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTE6IC8vIEphdmFTY3JpcHQgU3ltYm9sLCBubyBvcmRlcmluZy5cbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTI6IC8vIG9jYW1sIHN0cmluZ3NcbiAgICAgICAgdmFyIGEgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGEpO1xuICAgICAgICB2YXIgYiA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoYik7XG4gICAgICAgIGlmKGEgIT09IGIpIHtcbiAgICAgICAgICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MjA6IC8vIGphdmFzY3JpcHQgc3RyaW5nc1xuICAgICAgICB2YXIgYSA9IGEudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGIgPSBiLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmKGEgIT09IGIpIHtcbiAgICAgICAgICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjQ2OiAvLyBMYXp5X3RhZ1xuICAgICAgY2FzZSAyNTQ6IC8vIERvdWJsZV9hcnJheVxuICAgICAgZGVmYXVsdDogLy8gQmxvY2sgd2l0aCBvdGhlciB0YWdcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gKGEubGVuZ3RoIDwgYi5sZW5ndGgpPy0xOjE7XG4gICAgICAgIGlmIChhLmxlbmd0aCA+IDEpIHN0YWNrLnB1c2goYSwgYiwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhY2subGVuZ3RoID09IDApIHJldHVybiAwO1xuICAgIHZhciBpID0gc3RhY2sucG9wKCk7XG4gICAgYiA9IHN0YWNrLnBvcCgpO1xuICAgIGEgPSBzdGFjay5wb3AoKTtcbiAgICBpZiAoaSArIDEgPCBhLmxlbmd0aCkgc3RhY2sucHVzaChhLCBiLCBpICsgMSk7XG4gICAgYSA9IGFbaV07XG4gICAgYiA9IGJbaV07XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9jb21wYXJlIChhLCBiKSB7IHJldHVybiBjYW1sX2NvbXBhcmVfdmFsIChhLCBiLCB0cnVlKTsgfVxuLy9Qcm92aWRlczogY2FtbF9pbnRfY29tcGFyZSBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2ludF9jb21wYXJlIChhLCBiKSB7XG4gIGlmIChhIDwgYikgcmV0dXJuICgtMSk7IGlmIChhID09IGIpIHJldHVybiAwOyByZXR1cm4gMTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9lcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPT0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ub3RlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgIT0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JlYXRlcmVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZ3JlYXRlcmVxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA+PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ncmVhdGVydGhhbiBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2dyZWF0ZXJ0aGFuICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA+IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xlc3NlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2xlc3NlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPD0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbGVzc3RoYW4gbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9sZXNzdGhhbiAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPCAwKTsgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9kZWJ1Z19pbmZvX3N0YXR1cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9tbF9kZWJ1Z19pbmZvX3N0YXR1cyAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2JhY2t0cmFjZV9zdGF0dXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYmFja3RyYWNlX3N0YXR1cyAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSAoKSB7IHJldHVybiBbMF07IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmVjb3JkX2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9yZWNvcmRfYmFja3RyYWNlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSAoKSB7IHJldHVybiBbMF07IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGgoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90XG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90KCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdCAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlX3Nsb3Q6IGluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2UoZXhuLCBidCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2sgKCkgeyByZXR1cm4gWzBdOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3QoKXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3RcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gV2VhayBBUEksIGJ1dCB3aXRob3V0IHRoZSB3ZWFrIHNlbWFudGljc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxudmFyIGNhbWxfZXBoZV9rZXlfb2Zmc2V0ID0gM1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbnZhciBjYW1sX2VwaGVfZGF0YV9vZmZzZXQgPSAyXG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19jcmVhdGUgKG4pIHtcbiAgaWYgKG4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5jcmVhdGVcIik7XG4gIHZhciB4ID0gWzI1MSxcImNhbWxfZXBoZV9saXN0X2hlYWRcIl07XG4gIHgubGVuZ3RoID0gY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBuO1xuICByZXR1cm4geDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX3NldFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXQsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX3NldCh4LCBpLCB2KSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5zZXRcIik7XG4gIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSA9IHY7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2dldFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXQsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX2dldCh4LCBpKSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5nZXRfa2V5XCIpO1xuICByZXR1cm4gKHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpIF09PT11bmRlZmluZWQpPzA6eFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldO1xufVxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2dldF9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfZ2V0LGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX29ial9kdXAsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX2dldF9jb3B5KHgsIGkpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLmdldF9jb3B5XCIpO1xuICB2YXIgeSA9IGNhbWxfd2Vha19nZXQoeCwgaSk7XG4gIGlmICh5ID09PSAwKSByZXR1cm4geTtcbiAgdmFyIHogPSB5WzFdO1xuICBpZiAoeiBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gWzAsIGNhbWxfb2JqX2R1cCh6KV07XG4gIHJldHVybiB5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfY2hlY2sgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfd2Vha19jaGVjayh4LCBpKSB7XG4gIGlmKHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSE9PXVuZGVmaW5lZCAmJiB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gIT09MClcbiAgICByZXR1cm4gMTtcbiAgZWxzZVxuICAgIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxuZnVuY3Rpb24gY2FtbF93ZWFrX2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICAvLyBtaW51cyBvbmUgYmVjYXVzZSBjYW1sX2FycmF5X2JsaXQgd29ya3Mgb24gb2NhbWwgYXJyYXlcbiAgY2FtbF9hcnJheV9ibGl0KGExLCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkxIC0gMSxcbiAgICAgICAgICAgICAgICAgIGEyLCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkyIC0gMSxcbiAgICAgICAgICAgICAgICAgIGxlbik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfY3JlYXRlXG52YXIgY2FtbF9lcGhlX2NyZWF0ZSA9IGNhbWxfd2Vha19jcmVhdGVcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfYmxpdFxudmFyIGNhbWxfZXBoZV9ibGl0X2tleSA9IGNhbWxfd2Vha19ibGl0XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfZ2V0XG52YXIgY2FtbF9lcGhlX2dldF9rZXkgPSBjYW1sX3dlYWtfZ2V0XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfa2V5X2NvcHlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19nZXRfY29weVxudmFyIGNhbWxfZXBoZV9nZXRfa2V5X2NvcHkgPSBjYW1sX3dlYWtfZ2V0X2NvcHlcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NoZWNrX2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2NoZWNrXG52YXIgY2FtbF9lcGhlX2NoZWNrX2tleSA9IGNhbWxfd2Vha19jaGVja1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfc2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX3NldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3NldF9rZXkoeCwgaSwgdikge1xuICByZXR1cm4gY2FtbF93ZWFrX3NldCh4LCBpLCBbMCwgdl0pXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV91bnNldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19zZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV91bnNldF9rZXkoeCwgaSkge1xuICByZXR1cm4gY2FtbF93ZWFrX3NldCh4LCBpLCAwKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfYmxpdF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9ibGl0X2RhdGEoc3JjLCBkc3Qpe1xuICBkc3RbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IHNyY1tjYW1sX2VwaGVfZGF0YV9vZmZzZXRdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfZGF0YSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gWzAsIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX2R1cFxuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9kYXRhX2NvcHkoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIFswLCBjYW1sX29ial9kdXAoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdKV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9zZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfc2V0X2RhdGEoeCwgZGF0YSl7XG4gIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IGRhdGE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfdW5zZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfdW5zZXRfZGF0YSh4LCBkYXRhKXtcbiAgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gdW5kZWZpbmVkO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NoZWNrX2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuZnVuY3Rpb24gY2FtbF9lcGhlX2NoZWNrX2RhdGEoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIDE7XG59XG4iLCJcblxuLy9Qcm92aWRlczogY2FtbF9nY19taW5vclxuZnVuY3Rpb24gY2FtbF9nY19taW5vcigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWFqb3JcbmZ1bmN0aW9uIGNhbWxfZ2NfbWFqb3IoKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2Z1bGxfbWFqb3JcbmZ1bmN0aW9uIGNhbWxfZ2NfZnVsbF9tYWpvcigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfY29tcGFjdGlvblxuZnVuY3Rpb24gY2FtbF9nY19jb21wYWN0aW9uKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19jb3VudGVyc1xuZnVuY3Rpb24gY2FtbF9nY19jb3VudGVycygpIHsgcmV0dXJuIFsyNTQsMCwwLDBdIH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfcXVpY2tfc3RhdFxuZnVuY3Rpb24gY2FtbF9nY19xdWlja19zdGF0KCl7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXVxufVxuLy9Qcm92aWRlczogY2FtbF9nY19zdGF0XG5mdW5jdGlvbiBjYW1sX2djX3N0YXQoKSB7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX3NldFxuZnVuY3Rpb24gY2FtbF9nY19zZXQoX2NvbnRyb2wpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfZ2V0XG5mdW5jdGlvbiBjYW1sX2djX2dldCgpe1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc2V0XG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc2V0KF9jb250cm9sKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlZ2lzdGVyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlZ2lzdGVyICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWxlYXNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlbGVhc2UgKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc3RhcnRcbmZ1bmN0aW9uIGNhbWxfbWVtcHJvZl9zdGFydChyYXRlLHN0YWNrX3NpemUsdHJhY2tlcil7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc3RvcFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3N0b3AodW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ldmVudGxvZ19yZXN1bWVcbmZ1bmN0aW9uIGNhbWxfZXZlbnRsb2dfcmVzdW1lKHVuaXQpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9ldmVudGxvZ19wYXVzZVxuZnVuY3Rpb24gY2FtbF9ldmVudGxvZ19wYXVzZSh1bml0KSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfaHVnZV9mYWxsYmFja19jb3VudFxuZnVuY3Rpb24gY2FtbF9nY19odWdlX2ZhbGxiYWNrX2NvdW50KHVuaXQpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nY19tYWpvcl9zbGljZVxuZnVuY3Rpb24gY2FtbF9nY19tYWpvcl9zbGljZSh3b3JrKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWlub3Jfd29yZHNcbmZ1bmN0aW9uIGNhbWxfZ2NfbWlub3Jfd29yZHModW5pdCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9taW5vcl9mcmVlXG5mdW5jdGlvbiBjYW1sX2dldF9taW5vcl9mcmVlKHVuaXQpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfbWFqb3JfYnVja2V0XG5mdW5jdGlvbiBjYW1sX2dldF9tYWpvcl9idWNrZXQobikgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9tYWpvcl9jcmVkaXRcbmZ1bmN0aW9uIGNhbWxfZ2V0X21ham9yX2NyZWRpdChuKSB7IHJldHVybiAwOyB9XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEZvcm1hdFxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2Zvcm1hdFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2Zvcm1hdCAoZm10KSB7XG4gIGZtdCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoZm10KTtcbiAgdmFyIGxlbiA9IGZtdC5sZW5ndGg7XG4gIGlmIChsZW4gPiAzMSkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZm9ybWF0X2ludDogZm9ybWF0IHRvbyBsb25nXCIpO1xuICB2YXIgZiA9XG4gICAgICB7IGp1c3RpZnk6JysnLCBzaWduc3R5bGU6Jy0nLCBmaWxsZXI6JyAnLCBhbHRlcm5hdGU6ZmFsc2UsXG4gICAgICAgIGJhc2U6MCwgc2lnbmVkY29udjpmYWxzZSwgd2lkdGg6MCwgdXBwZXJjYXNlOmZhbHNlLFxuICAgICAgICBzaWduOjEsIHByZWM6LTEsIGNvbnY6J2YnIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYyA9IGZtdC5jaGFyQXQoaSk7XG4gICAgc3dpdGNoIChjKSB7XG4gICAgY2FzZSAnLSc6XG4gICAgICBmLmp1c3RpZnkgPSAnLSc7IGJyZWFrO1xuICAgIGNhc2UgJysnOiBjYXNlICcgJzpcbiAgICAgIGYuc2lnbnN0eWxlID0gYzsgYnJlYWs7XG4gICAgY2FzZSAnMCc6XG4gICAgICBmLmZpbGxlciA9ICcwJzsgYnJlYWs7XG4gICAgY2FzZSAnIyc6XG4gICAgICBmLmFsdGVybmF0ZSA9IHRydWU7IGJyZWFrO1xuICAgIGNhc2UgJzEnOiBjYXNlICcyJzogY2FzZSAnMyc6IGNhc2UgJzQnOiBjYXNlICc1JzpcbiAgICBjYXNlICc2JzogY2FzZSAnNyc6IGNhc2UgJzgnOiBjYXNlICc5JzpcbiAgICAgIGYud2lkdGggPSAwO1xuICAgICAgd2hpbGUgKGM9Zm10LmNoYXJDb2RlQXQoaSkgLSA0OCwgYyA+PSAwICYmIGMgPD0gOSkge1xuICAgICAgICBmLndpZHRoID0gZi53aWR0aCAqIDEwICsgYzsgaSsrXG4gICAgICB9XG4gICAgICBpLS07XG4gICAgICBicmVhaztcbiAgICBjYXNlICcuJzpcbiAgICAgIGYucHJlYyA9IDA7XG4gICAgICBpKys7XG4gICAgICB3aGlsZSAoYz1mbXQuY2hhckNvZGVBdChpKSAtIDQ4LCBjID49IDAgJiYgYyA8PSA5KSB7XG4gICAgICAgIGYucHJlYyA9IGYucHJlYyAqIDEwICsgYzsgaSsrXG4gICAgICB9XG4gICAgICBpLS07XG4gICAgY2FzZSAnZCc6IGNhc2UgJ2knOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlICd1JzpcbiAgICAgIGYuYmFzZSA9IDEwOyBicmVhaztcbiAgICBjYXNlICd4JzpcbiAgICAgIGYuYmFzZSA9IDE2OyBicmVhaztcbiAgICBjYXNlICdYJzpcbiAgICAgIGYuYmFzZSA9IDE2OyBmLnVwcGVyY2FzZSA9IHRydWU7IGJyZWFrO1xuICAgIGNhc2UgJ28nOlxuICAgICAgZi5iYXNlID0gODsgYnJlYWs7XG4gICAgY2FzZSAnZSc6IGNhc2UgJ2YnOiBjYXNlICdnJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IGYuY29udiA9IGM7IGJyZWFrO1xuICAgIGNhc2UgJ0UnOiBjYXNlICdGJzogY2FzZSAnRyc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyBmLnVwcGVyY2FzZSA9IHRydWU7XG4gICAgICBmLmNvbnYgPSBjLnRvTG93ZXJDYXNlICgpOyBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcmF3YnVmZmVyKSB7XG4gIGlmIChmLnVwcGVyY2FzZSkgcmF3YnVmZmVyID0gcmF3YnVmZmVyLnRvVXBwZXJDYXNlKCk7XG4gIHZhciBsZW4gPSByYXdidWZmZXIubGVuZ3RoO1xuICAvKiBBZGp1c3QgbGVuIHRvIHJlZmxlY3QgYWRkaXRpb25hbCBjaGFycyAoc2lnbiwgZXRjKSAqL1xuICBpZiAoZi5zaWduZWRjb252ICYmIChmLnNpZ24gPCAwIHx8IGYuc2lnbnN0eWxlICE9ICctJykpIGxlbisrO1xuICBpZiAoZi5hbHRlcm5hdGUpIHtcbiAgICBpZiAoZi5iYXNlID09IDgpIGxlbiArPSAxO1xuICAgIGlmIChmLmJhc2UgPT0gMTYpIGxlbiArPSAyO1xuICB9XG4gIC8qIERvIHRoZSBmb3JtYXR0aW5nICovXG4gIHZhciBidWZmZXIgPSBcIlwiO1xuICBpZiAoZi5qdXN0aWZ5ID09ICcrJyAmJiBmLmZpbGxlciA9PSAnICcpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcgJztcbiAgaWYgKGYuc2lnbmVkY29udikge1xuICAgIGlmIChmLnNpZ24gPCAwKSBidWZmZXIgKz0gJy0nO1xuICAgIGVsc2UgaWYgKGYuc2lnbnN0eWxlICE9ICctJykgYnVmZmVyICs9IGYuc2lnbnN0eWxlO1xuICB9XG4gIGlmIChmLmFsdGVybmF0ZSAmJiBmLmJhc2UgPT0gOCkgYnVmZmVyICs9ICcwJztcbiAgaWYgKGYuYWx0ZXJuYXRlICYmIGYuYmFzZSA9PSAxNikgYnVmZmVyICs9IFwiMHhcIjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnKycgJiYgZi5maWxsZXIgPT0gJzAnKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnMCc7XG4gIGJ1ZmZlciArPSByYXdidWZmZXI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJy0nKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnICc7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGJ1ZmZlcik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VwZGF0ZV9kdW1teVxuZnVuY3Rpb24gY2FtbF91cGRhdGVfZHVtbXkgKHgsIHkpIHtcbiAgaWYoIHR5cGVvZiB5PT09XCJmdW5jdGlvblwiICkgeyB4LmZ1biA9IHk7IHJldHVybiAwOyB9XG4gIGlmKCB5LmZ1biApIHsgeC5mdW4gPSB5LmZ1bjsgcmV0dXJuIDA7IH1cbiAgdmFyIGkgPSB5Lmxlbmd0aDsgd2hpbGUgKGktLSkgeFtpXSA9IHlbaV07IHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9pc19ibG9jayBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9pc19ibG9jayAoeCkgeyByZXR1cm4gKyh4IGluc3RhbmNlb2YgQXJyYXkpOyB9XG5cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzLCBjYW1sX2lzX21sX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9vYmpfdGFnICh4KSB7XG4gIGlmICgoeCBpbnN0YW5jZW9mIEFycmF5KSAmJiB4WzBdID09ICh4WzBdID4+PiAwKSlcbiAgICByZXR1cm4geFswXVxuICBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKHgpKVxuICAgIHJldHVybiAyNTJcbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcoeCkpXG4gICAgcmV0dXJuIDI1MlxuICBlbHNlIGlmICgoeCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB8fCB0eXBlb2YgeCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIDI0N1xuICBlbHNlIGlmICh4ICYmIHguY2FtbF9jdXN0b20pXG4gICAgcmV0dXJuIDI1NVxuICBlbHNlXG4gICAgcmV0dXJuIDEwMDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfc2V0X3RhZyAobXV0YWJsZSwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9zZXRfdGFnICh4LCB0YWcpIHsgeFswXSA9IHRhZzsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2Jsb2NrIGNvbnN0IChjb25zdCxjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2Jsb2NrICh0YWcsIHNpemUpIHtcbiAgdmFyIG8gPSBuZXcgQXJyYXkoc2l6ZSsxKTtcbiAgb1swXT10YWc7XG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IHNpemU7IGkrKykgb1tpXSA9IDA7XG4gIHJldHVybiBvO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial93aXRoX3RhZ1xuZnVuY3Rpb24gY2FtbF9vYmpfd2l0aF90YWcodGFnLHgpIHtcbiAgdmFyIGwgPSB4Lmxlbmd0aDtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGFbMF0gPSB0YWc7XG4gIGZvcih2YXIgaSA9IDE7IGkgPCBsOyBpKysgKSBhW2ldID0geFtpXTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2R1cCBtdXRhYmxlIChjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2R1cCAoeCkge1xuICB2YXIgbCA9IHgubGVuZ3RoO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKyApIGFbaV0gPSB4W2ldO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfdHJ1bmNhdGUgKG11dGFibGUsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX29ial90cnVuY2F0ZSAoeCwgcykge1xuICBpZiAoczw9MCB8fCBzICsgMSA+IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJPYmoudHJ1bmNhdGVcIik7XG4gIGlmICh4Lmxlbmd0aCAhPSBzICsgMSkgeC5sZW5ndGggPSBzICsgMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX21ha2VfZm9yd2FyZFxuZnVuY3Rpb24gY2FtbF9vYmpfbWFrZV9mb3J3YXJkIChiLHYpIHtcbiAgYlswXT0yNTA7XG4gIGJbMV09djtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sYXp5X21ha2VfZm9yd2FyZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2xhenlfbWFrZV9mb3J3YXJkICh2KSB7IHJldHVybiBbMjUwLCB2XTsgfVxuXG4vLy8vLy8vLy8vLy8vIENhbWxpbnRlcm5hbE9PXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9wdWJsaWNfbWV0aG9kIGNvbnN0XG52YXIgY2FtbF9tZXRob2RfY2FjaGUgPSBbXTtcbmZ1bmN0aW9uIGNhbWxfZ2V0X3B1YmxpY19tZXRob2QgKG9iaiwgdGFnLCBjYWNoZWlkKSB7XG4gIHZhciBtZXRocyA9IG9ialsxXTtcbiAgdmFyIG9mcyA9IGNhbWxfbWV0aG9kX2NhY2hlW2NhY2hlaWRdO1xuICBpZiAob2ZzID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFycmF5IGlzIG5vdCBzcGFyc2VcbiAgICBmb3IgKHZhciBpID0gY2FtbF9tZXRob2RfY2FjaGUubGVuZ3RoOyBpIDwgY2FjaGVpZDsgaSsrKVxuICAgICAgY2FtbF9tZXRob2RfY2FjaGVbaV0gPSAwO1xuICB9IGVsc2UgaWYgKG1ldGhzW29mc10gPT09IHRhZykge1xuICAgIHJldHVybiBtZXRoc1tvZnMgLSAxXTtcbiAgfVxuICB2YXIgbGkgPSAzLCBoaSA9IG1ldGhzWzFdICogMiArIDEsIG1pO1xuICB3aGlsZSAobGkgPCBoaSkge1xuICAgIG1pID0gKChsaStoaSkgPj4gMSkgfCAxO1xuICAgIGlmICh0YWcgPCBtZXRoc1ttaSsxXSkgaGkgPSBtaS0yO1xuICAgIGVsc2UgbGkgPSBtaTtcbiAgfVxuICBjYW1sX21ldGhvZF9jYWNoZVtjYWNoZWlkXSA9IGxpICsgMTtcbiAgLyogcmV0dXJuIDAgaWYgdGFnIGlzIG5vdCB0aGVyZSAqL1xuICByZXR1cm4gKHRhZyA9PSBtZXRoc1tsaSsxXSA/IG1ldGhzW2xpXSA6IDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29vX2xhc3RfaWRcbnZhciBjYW1sX29vX2xhc3RfaWQgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9vb19pZFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX3NldF9vb19pZCAoYikge1xuICBiWzJdPWNhbWxfb29fbGFzdF9pZCsrO1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mcmVzaF9vb19pZCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX2ZyZXNoX29vX2lkKCkge1xuICByZXR1cm4gY2FtbF9vb19sYXN0X2lkKys7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3Jhd19maWVsZFxuZnVuY3Rpb24gY2FtbF9vYmpfcmF3X2ZpZWxkKG8saSkgeyByZXR1cm4gb1tpKzFdIH1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfc2V0X3Jhd19maWVsZFxuZnVuY3Rpb24gY2FtbF9vYmpfc2V0X3Jhd19maWVsZChvLGksdikgeyByZXR1cm4gb1tpKzFdID0gdiB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3JlYWNoYWJsZV93b3Jkc1xuZnVuY3Rpb24gY2FtbF9vYmpfcmVhY2hhYmxlX3dvcmRzKG8pIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfYWRkX29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9vYmpfYWRkX29mZnNldCh2LG9mZnNldCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiT2JqLmFkZF9vZmZzZXQgaXMgbm90IHN1cHBvcnRlZFwiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGZzX25vZGVfc3VwcG9ydGVkXG5mdW5jdGlvbiBmc19ub2RlX3N1cHBvcnRlZCAoKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGdsb2JhbFRoaXMucHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICYmIHR5cGVvZiBnbG9iYWxUaGlzLnByb2Nlc3MudmVyc2lvbnMgIT09ICd1bmRlZmluZWQnXG4gICAgICAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5wcm9jZXNzLnZlcnNpb25zLm5vZGUgIT09ICd1bmRlZmluZWQnKVxufVxuLy9Qcm92aWRlczogZnNfbm9kZV9zdXBwb3J0ZWRcbi8vSWY6IGJyb3dzZXJcbmZ1bmN0aW9uIGZzX25vZGVfc3VwcG9ydGVkICgpIHtcbiAgcmV0dXJuIGZhbHNlXG59XG5cblxuLy9Qcm92aWRlczogTWxOb2RlRGV2aWNlXG4vL1JlcXVpcmVzOiBNbE5vZGVGaWxlLCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9yYWlzZV93aXRoX2FyZ3Ncbi8vUmVxdWlyZXM6IG1ha2VfdW5peF9lcnJfYXJncywgY2FtbF9uYW1lZF92YWx1ZSwgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbmZ1bmN0aW9uIE1sTm9kZURldmljZShyb290KSB7XG4gIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICB0aGlzLnJvb3QgPSByb290O1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5ubSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuICh0aGlzLnJvb3QgKyBuYW1lKTtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSk/MTowO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5ta2RpciA9IGZ1bmN0aW9uKG5hbWUsIG1vZGUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLm1rZGlyU3luYyh0aGlzLm5tKG5hbWUpLHttb2RlOm1vZGV9KTtcbiAgICByZXR1cm4gMFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJtZGlyID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHRoaXMuZnMucm1kaXJTeW5jKHRoaXMubm0obmFtZSkpO1xuICAgIHJldHVybiAwXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5yZWFkZGlyU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5pc19kaXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuc3RhdFN5bmModGhpcy5ubShuYW1lKSkuaXNEaXJlY3RvcnkoKT8xOjA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdmFyIGIgPSB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSk/MTowO1xuICAgIHRoaXMuZnMudW5saW5rU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgICByZXR1cm4gYjtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obmFtZSwgZiwgcmFpc2VfdW5peCkge1xuICB2YXIgY29uc3RzID0gcmVxdWlyZSgnY29uc3RhbnRzJyk7XG4gIHZhciByZXMgPSAwO1xuICBmb3IodmFyIGtleSBpbiBmKXtcbiAgICBzd2l0Y2goa2V5KXtcbiAgICBjYXNlIFwicmRvbmx5XCIgIDogcmVzIHw9IGNvbnN0cy5PX1JET05MWTsgYnJlYWs7XG4gICAgY2FzZSBcIndyb25seVwiICA6IHJlcyB8PSBjb25zdHMuT19XUk9OTFk7IGJyZWFrO1xuICAgIGNhc2UgXCJhcHBlbmRcIiAgOlxuICAgICAgcmVzIHw9IGNvbnN0cy5PX1dST05MWSB8IGNvbnN0cy5PX0FQUEVORDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjcmVhdGVcIiAgIDogcmVzIHw9IGNvbnN0cy5PX0NSRUFUOyAgICBicmVhaztcbiAgICBjYXNlIFwidHJ1bmNhdGVcIiA6IHJlcyB8PSBjb25zdHMuT19UUlVOQzsgICAgYnJlYWs7XG4gICAgY2FzZSBcImV4Y2xcIiAgICAgOiByZXMgfD0gY29uc3RzLk9fRVhDTDsgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJiaW5hcnlcIiAgIDogcmVzIHw9IGNvbnN0cy5PX0JJTkFSWTsgICBicmVhaztcbiAgICBjYXNlIFwidGV4dFwiICAgICA6IHJlcyB8PSBjb25zdHMuT19URVhUOyAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm5vbmJsb2NrXCIgOiByZXMgfD0gY29uc3RzLk9fTk9OQkxPQ0s7IGJyZWFrO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIHZhciBmZCA9IHRoaXMuZnMub3BlblN5bmModGhpcy5ubShuYW1lKSwgcmVzKTtcbiAgICByZXR1cm4gbmV3IE1sTm9kZUZpbGUoZmQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVuYW1lID0gZnVuY3Rpb24obywgbiwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHRoaXMuZnMucmVuYW1lU3luYyh0aGlzLm5tKG8pLCB0aGlzLm5tKG4pKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5zdGF0ID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHZhciBqc19zdGF0cyA9IHRoaXMuZnMuc3RhdFN5bmModGhpcy5ubShuYW1lKSk7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHNfZnJvbV9qcyhqc19zdGF0cyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUubHN0YXQgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdmFyIGpzX3N0YXRzID0gdGhpcy5mcy5sc3RhdFN5bmModGhpcy5ubShuYW1lKSk7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHNfZnJvbV9qcyhqc19zdGF0cyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuc3ltbGluayA9IGZ1bmN0aW9uKHRvX2RpciwgdGFyZ2V0LCBwYXRoLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5zeW1saW5rU3luYyh0aGlzLm5tKHRhcmdldCksIHRoaXMubm0ocGF0aCksIHRvX2RpciA/ICdkaXInIDogJ2ZpbGUnKTtcbiAgICByZXR1cm4gMDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZWFkbGluayA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgbGluayA9IHRoaXMuZnMucmVhZGxpbmtTeW5jKHRoaXMubm0obmFtZSksICd1dGY4Jyk7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGxpbmspO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJhaXNlX25vZGVqc19lcnJvciA9IGZ1bmN0aW9uKGVyciwgcmFpc2VfdW5peCkge1xuICB2YXIgdW5peF9lcnJvciA9IGNhbWxfbmFtZWRfdmFsdWUoXCJVbml4LlVuaXhfZXJyb3JcIik7XG4gIGlmIChyYWlzZV91bml4ICYmIHVuaXhfZXJyb3IpIHtcbiAgICB2YXIgYXJncyA9IG1ha2VfdW5peF9lcnJfYXJncyhlcnIuY29kZSwgZXJyLnN5c2NhbGwsIGVyci5wYXRoLCBlcnIuZXJybm8pO1xuICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5zdGF0c19mcm9tX2pzID0gZnVuY3Rpb24oanNfc3RhdHMpIHtcbiAgLyogPT09VW5peC5maWxlX2tpbmQ9PT1cbiAgICogdHlwZSBmaWxlX2tpbmQgPVxuICAgKiAgICAgU19SRUcgICAgICAgICAgICAgICAgICAgICAgICgqKiBSZWd1bGFyIGZpbGUgKilcbiAgICogICB8IFNfRElSICAgICAgICAgICAgICAgICAgICAgICAoKiogRGlyZWN0b3J5ICopXG4gICAqICAgfCBTX0NIUiAgICAgICAgICAgICAgICAgICAgICAgKCoqIENoYXJhY3RlciBkZXZpY2UgKilcbiAgICogICB8IFNfQkxLICAgICAgICAgICAgICAgICAgICAgICAoKiogQmxvY2sgZGV2aWNlICopXG4gICAqICAgfCBTX0xOSyAgICAgICAgICAgICAgICAgICAgICAgKCoqIFN5bWJvbGljIGxpbmsgKilcbiAgICogICB8IFNfRklGTyAgICAgICAgICAgICAgICAgICAgICAoKiogTmFtZWQgcGlwZSAqKVxuICAgKiAgIHwgU19TT0NLICAgICAgICAgICAgICAgICAgICAgICgqKiBTb2NrZXQgKilcbiAgICovXG4gIHZhciBmaWxlX2tpbmQ7XG4gIGlmIChqc19zdGF0cy5pc0ZpbGUoKSkge1xuICAgIGZpbGVfa2luZCA9IDA7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgIGZpbGVfa2luZCA9IDE7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNDaGFyYWN0ZXJEZXZpY2UoKSkge1xuICAgIGZpbGVfa2luZCA9IDI7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNCbG9ja0RldmljZSgpKSB7XG4gICAgZmlsZV9raW5kID0gMztcbiAgfSBlbHNlIGlmIChqc19zdGF0cy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgZmlsZV9raW5kID0gNDtcbiAgfSBlbHNlIGlmIChqc19zdGF0cy5pc0ZJRk8oKSkge1xuICAgIGZpbGVfa2luZCA9IDU7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNTb2NrZXQoKSkge1xuICAgIGZpbGVfa2luZCA9IDY7XG4gIH1cbiAgLyogPT09VW5peC5zdGF0cz09PVxuICAgKiB0eXBlIHN0YXRzID1cbiAgICogIHsgc3RfZGV2IDogaW50OyAgICAgICAgICAgICAgICgqKiBEZXZpY2UgbnVtYmVyICopXG4gICAqICAgIHN0X2lubyA6IGludDsgICAgICAgICAgICAgICAoKiogSW5vZGUgbnVtYmVyICopXG4gICAqICAgIHN0X2tpbmQgOiBmaWxlX2tpbmQ7ICAgICAgICAoKiogS2luZCBvZiB0aGUgZmlsZSAqKVxuICAgKiAgICBzdF9wZXJtIDogZmlsZV9wZXJtOyAgICAgICAgKCoqIEFjY2VzcyByaWdodHMgKilcbiAgICogICAgc3RfbmxpbmsgOiBpbnQ7ICAgICAgICAgICAgICgqKiBOdW1iZXIgb2YgbGlua3MgKilcbiAgICogICAgc3RfdWlkIDogaW50OyAgICAgICAgICAgICAgICgqKiBVc2VyIGlkIG9mIHRoZSBvd25lciAqKVxuICAgKiAgICBzdF9naWQgOiBpbnQ7ICAgICAgICAgICAgICAgKCoqIEdyb3VwIElEIG9mIHRoZSBmaWxlJ3MgZ3JvdXAgKilcbiAgICogICAgc3RfcmRldiA6IGludDsgICAgICAgICAgICAgICgqKiBEZXZpY2UgSUQgKGlmIHNwZWNpYWwgZmlsZSkgKilcbiAgICogICAgc3Rfc2l6ZSA6IGludDsgICAgICAgICAgICAgICgqKiBTaXplIGluIGJ5dGVzICopXG4gICAqICAgIHN0X2F0aW1lIDogZmxvYXQ7ICAgICAgICAgICAoKiogTGFzdCBhY2Nlc3MgdGltZSAqKVxuICAgKiAgICBzdF9tdGltZSA6IGZsb2F0OyAgICAgICAgICAgKCoqIExhc3QgbW9kaWZpY2F0aW9uIHRpbWUgKilcbiAgICogICAgc3RfY3RpbWUgOiBmbG9hdDsgICAgICAgICAgICgqKiBMYXN0IHN0YXR1cyBjaGFuZ2UgdGltZSAqKVxuICAgKiAgfVxuICAgKi9cbiAgcmV0dXJuIEJMT0NLKFxuICAgIDAsXG4gICAganNfc3RhdHMuZGV2LFxuICAgIGpzX3N0YXRzLmlubyxcbiAgICBmaWxlX2tpbmQsXG4gICAganNfc3RhdHMubW9kZSxcbiAgICBqc19zdGF0cy5ubGluayxcbiAgICBqc19zdGF0cy51aWQsXG4gICAganNfc3RhdHMuZ2lkLFxuICAgIGpzX3N0YXRzLnJkZXYsXG4gICAganNfc3RhdHMuc2l6ZSxcbiAgICBqc19zdGF0cy5hdGltZU1zLFxuICAgIGpzX3N0YXRzLm10aW1lTXMsXG4gICAganNfc3RhdHMuY3RpbWVNc1xuICApO1xufVxuXG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxOb2RlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sTm9kZURldmljZVxuLy9JZjogYnJvd3NlclxuZnVuY3Rpb24gTWxOb2RlRGV2aWNlKCkge1xufVxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVGaWxlXG4vL1JlcXVpcmVzOiBNbEZpbGUsIGNhbWxfYXJyYXlfb2Zfc3RyaW5nLCBjYW1sX2FycmF5X29mX2J5dGVzLCBjYW1sX2J5dGVzX3NldCwgY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIE1sTm9kZUZpbGUoZmQpe1xuICB0aGlzLmZzID0gcmVxdWlyZSgnZnMnKTtcbiAgdGhpcy5mZCA9IGZkO1xufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUgPSBuZXcgTWxGaWxlICgpO1xuXG5NbE5vZGVGaWxlLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGxlbil7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5mdHJ1bmNhdGVTeW5jKHRoaXMuZmQsbGVufDApXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLmZzdGF0U3luYyh0aGlzLmZkKS5zaXplO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ob2Zmc2V0LGJ1ZixidWZfb2Zmc2V0LGxlbil7XG4gIHZhciBhID0gY2FtbF9hcnJheV9vZl9zdHJpbmcoYnVmKTtcbiAgaWYoISAoYSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuVWludDhBcnJheSkpXG4gICAgYSA9IG5ldyBnbG9iYWxUaGlzLlVpbnQ4QXJyYXkoYSk7XG4gIHZhciBidWZmZXIgPSBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGEpO1xuICB0cnkge1xuICAgIHRoaXMuZnMud3JpdGVTeW5jKHRoaXMuZmQsIGJ1ZmZlciwgYnVmX29mZnNldCwgbGVuLCBvZmZzZXQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24ob2Zmc2V0LGJ1ZixidWZfb2Zmc2V0LGxlbil7XG4gIHZhciBhID0gY2FtbF9hcnJheV9vZl9ieXRlcyhidWYpO1xuICBpZighIChhIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5VaW50OEFycmF5KSlcbiAgICBhID0gbmV3IGdsb2JhbFRoaXMuVWludDhBcnJheShhKTtcbiAgdmFyIGJ1ZmZlciA9IGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYSk7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5yZWFkU3luYyh0aGlzLmZkLCBidWZmZXIsIGJ1Zl9vZmZzZXQsIGxlbiwgb2Zmc2V0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgY2FtbF9ieXRlc19zZXQoYnVmLGJ1Zl9vZmZzZXQgKyBpLGJ1ZmZlcltidWZfb2Zmc2V0K2ldKTtcbiAgfVxuICByZXR1cm4gMFxufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUucmVhZF9vbmUgPSBmdW5jdGlvbihvZmZzZXQpe1xuICB2YXIgYSA9IG5ldyBnbG9iYWxUaGlzLlVpbnQ4QXJyYXkoMSk7XG4gIHZhciBidWZmZXIgPSBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGEpO1xuICB0cnkge1xuICAgIHRoaXMuZnMucmVhZFN5bmModGhpcy5mZCwgYnVmZmVyLCAwLCAxLCBvZmZzZXQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclswXTtcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKXtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLmNsb3NlU3luYyh0aGlzLmZkKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5cbk1sTm9kZUZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxOb2RlRmlsZTtcblxuLy9Qcm92aWRlczogTWxOb2RlRmlsZVxuLy9JZjogYnJvd3NlclxuZnVuY3Rpb24gTWxOb2RlRmlsZSgpe1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBEdW1teSBmaWxlc3lzdGVtXG5cbi8vUHJvdmlkZXM6IGNhbWxfdHJhaWxpbmdfc2xhc2hcbmZ1bmN0aW9uIGNhbWxfdHJhaWxpbmdfc2xhc2gobmFtZSl7XG4gIHJldHVybiAobmFtZS5zbGljZSgtMSkgIT09IFwiL1wiKSA/IChuYW1lICsgXCIvXCIpIDogbmFtZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jdXJyZW50X2RpclxuLy9SZXF1aXJlczogY2FtbF90cmFpbGluZ19zbGFzaCwgZnNfbm9kZV9zdXBwb3J0ZWRcbmlmKGZzX25vZGVfc3VwcG9ydGVkICgpICYmIGdsb2JhbFRoaXMucHJvY2VzcyAmJiBnbG9iYWxUaGlzLnByb2Nlc3MuY3dkKVxuICB2YXIgY2FtbF9jdXJyZW50X2RpciA9IGdsb2JhbFRoaXMucHJvY2Vzcy5jd2QoKS5yZXBsYWNlKC9cXFxcL2csJy8nKTtcbmVsc2VcbiAgdmFyIGNhbWxfY3VycmVudF9kaXIgPSAgXCIvc3RhdGljXCI7XG5jYW1sX2N1cnJlbnRfZGlyID0gY2FtbF90cmFpbGluZ19zbGFzaChjYW1sX2N1cnJlbnRfZGlyKTtcblxuLy9Qcm92aWRlczogY2FtbF9nZXRfcm9vdFxuLy9SZXF1aXJlczogcGF0aF9pc19hYnNvbHV0ZVxuZnVuY3Rpb24gY2FtbF9nZXRfcm9vdChwYXRoKXtcbiAgdmFyIHggPSBwYXRoX2lzX2Fic29sdXRlKHBhdGgpO1xuICBpZiAoIXgpIHJldHVybjtcbiAgcmV0dXJuIHhbMF0gKyBcIi9cIn1cblxuLy9Qcm92aWRlczogY2FtbF9yb290XG4vL1JlcXVpcmVzOiBjYW1sX2dldF9yb290LCBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX2ZhaWx3aXRoXG52YXIgY2FtbF9yb290ID0gY2FtbF9nZXRfcm9vdChjYW1sX2N1cnJlbnRfZGlyKSB8fCBjYW1sX2ZhaWx3aXRoKFwidW5hYmxlIHRvIGNvbXB1dGUgY2FtbF9yb290XCIpO1xuXG5cbi8vUHJvdmlkZXM6IE1sRmlsZVxuZnVuY3Rpb24gTWxGaWxlKCl7ICB9XG5cbi8vUHJvdmlkZXM6IHBhdGhfaXNfYWJzb2x1dGVcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkXG5mdW5jdGlvbiBtYWtlX3BhdGhfaXNfYWJzb2x1dGUoKSB7XG4gIGZ1bmN0aW9uIHBvc2l4KHBhdGgpIHtcbiAgICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcvJykgcmV0dXJuIFtcIlwiLCBwYXRoLnN1YnN0cmluZygxKV07XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZnVuY3Rpb24gd2luMzIocGF0aCkge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2IzZmNjMjQ1ZmIyNTUzOTkwOWVmMWQ1ZWFhMDFkYmY5MmUxNjg2MzMvbGliL3BhdGguanMjTDU2XG4gICAgdmFyIHNwbGl0RGV2aWNlUmUgPSAvXihbYS16QS1aXTp8W1xcXFwvXXsyfVteXFxcXC9dK1tcXFxcL10rW15cXFxcL10rKT8oW1xcXFwvXSk/KFtcXHNcXFNdKj8pJC87XG4gICAgdmFyIHJlc3VsdCA9IHNwbGl0RGV2aWNlUmUuZXhlYyhwYXRoKTtcbiAgICB2YXIgZGV2aWNlID0gcmVzdWx0WzFdIHx8ICcnO1xuICAgIHZhciBpc1VuYyA9IEJvb2xlYW4oZGV2aWNlICYmIGRldmljZS5jaGFyQXQoMSkgIT09ICc6Jyk7XG5cbiAgICAvLyBVTkMgcGF0aHMgYXJlIGFsd2F5cyBhYnNvbHV0ZVxuICAgIGlmIChCb29sZWFuKHJlc3VsdFsyXSB8fCBpc1VuYykpIHtcbiAgICAgIHZhciByb290ID0gKHJlc3VsdFsxXSB8fCAnJyk7XG4gICAgICB2YXIgc2VwID0gKHJlc3VsdFsyXSB8fCAnJyk7XG4gICAgICByZXR1cm4gW3Jvb3QsIHBhdGguc3Vic3RyaW5nKHJvb3QubGVuZ3RoICsgc2VwLmxlbmd0aCldXG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZihmc19ub2RlX3N1cHBvcnRlZCAoKSAmJiBnbG9iYWxUaGlzLnByb2Nlc3MgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzLnBsYXRmb3JtKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMucHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHdpbjMyIDogcG9zaXg7XG4gIH1cbiAgZWxzZSByZXR1cm4gcG9zaXhcbn1cbnZhciBwYXRoX2lzX2Fic29sdXRlID0gbWFrZV9wYXRoX2lzX2Fic29sdXRlKCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV9wYXRoXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZywgcGF0aF9pc19hYnNvbHV0ZVxuZnVuY3Rpb24gY2FtbF9tYWtlX3BhdGggKG5hbWUpIHtcbiAgbmFtZT1jYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgaWYoICFwYXRoX2lzX2Fic29sdXRlKG5hbWUpIClcbiAgICBuYW1lID0gY2FtbF9jdXJyZW50X2RpciArIG5hbWU7XG4gIHZhciBjb21wMCA9IHBhdGhfaXNfYWJzb2x1dGUobmFtZSk7XG4gIHZhciBjb21wID0gY29tcDBbMV0uc3BsaXQoXCIvXCIpO1xuICB2YXIgbmNvbXAgPSBbXVxuICBmb3IodmFyIGkgPSAwOyBpPGNvbXAubGVuZ3RoOyBpKyspe1xuICAgIHN3aXRjaChjb21wW2ldKXtcbiAgICBjYXNlIFwiLi5cIjogaWYobmNvbXAubGVuZ3RoPjEpIG5jb21wLnBvcCgpOyBicmVhaztcbiAgICBjYXNlIFwiLlwiOiBicmVhaztcbiAgICBkZWZhdWx0OiBuY29tcC5wdXNoKGNvbXBbaV0pO2JyZWFrXG4gICAgfVxuICB9XG4gIG5jb21wLnVuc2hpZnQoY29tcDBbMF0pO1xuICBuY29tcC5vcmlnID0gbmFtZTtcbiAgcmV0dXJuIG5jb21wO1xufVxuXG4vL1Byb3ZpZGVzOmpzb29fbW91bnRfcG9pbnRcbi8vUmVxdWlyZXM6IE1sRmFrZURldmljZSwgTWxOb2RlRGV2aWNlLCBjYW1sX3Jvb3QsIGZzX25vZGVfc3VwcG9ydGVkXG52YXIganNvb19tb3VudF9wb2ludCA9IFtdXG5pZiAoZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290LGRldmljZTpuZXcgTWxOb2RlRGV2aWNlKGNhbWxfcm9vdCl9KTtcbn0gZWxzZSB7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpjYW1sX3Jvb3QsZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UoY2FtbF9yb290KX0pO1xufVxuanNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOlwiL3N0YXRpYy9cIiwgZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UoXCIvc3RhdGljL1wiKX0pO1xuXG4vL1Byb3ZpZGVzOmNhbWxfbGlzdF9tb3VudF9wb2ludFxuLy9SZXF1aXJlczoganNvb19tb3VudF9wb2ludCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9saXN0X21vdW50X3BvaW50KCl7XG4gIHZhciBwcmV2ID0gMFxuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKyl7XG4gICAgdmFyIG9sZCA9IHByZXY7XG4gICAgcHJldiA9IFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGpzb29fbW91bnRfcG9pbnRbaV0ucGF0aCksIG9sZF1cbiAgfVxuICByZXR1cm4gcHJldjtcbn1cblxuLy9Qcm92aWRlczogcmVzb2x2ZV9mc19kZXZpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfbWFrZV9wYXRoLCBqc29vX21vdW50X3BvaW50LCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9nZXRfcm9vdCwgTWxOb2RlRGV2aWNlLCBjYW1sX3RyYWlsaW5nX3NsYXNoLCBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSl7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gcGF0aC5qb2luKFwiL1wiKTtcbiAgdmFyIG5hbWVfc2xhc2ggPSBjYW1sX3RyYWlsaW5nX3NsYXNoKG5hbWUpO1xuICB2YXIgcmVzO1xuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtID0ganNvb19tb3VudF9wb2ludFtpXTtcbiAgICBpZihuYW1lX3NsYXNoLnNlYXJjaChtLnBhdGgpID09IDBcbiAgICAgICAmJiAoIXJlcyB8fCByZXMucGF0aC5sZW5ndGggPCBtLnBhdGgubGVuZ3RoKSlcbiAgICAgIHJlcyA9IHtwYXRoOm0ucGF0aCxkZXZpY2U6bS5kZXZpY2UscmVzdDpuYW1lLnN1YnN0cmluZyhtLnBhdGgubGVuZ3RoLG5hbWUubGVuZ3RoKX07XG4gIH1cbiAgaWYoICFyZXMgJiYgZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICAgIHZhciByb290ID0gY2FtbF9nZXRfcm9vdChuYW1lKTtcbiAgICBpZiAocm9vdCAmJiByb290Lm1hdGNoKC9eW2EtekEtWl06XFwvJC8pKXtcbiAgICAgIHZhciBtID0ge3BhdGg6cm9vdCxkZXZpY2U6bmV3IE1sTm9kZURldmljZShyb290KX07XG4gICAgICBqc29vX21vdW50X3BvaW50LnB1c2gobSk7XG4gICAgICByZXMgPSB7cGF0aDptLnBhdGgsZGV2aWNlOm0uZGV2aWNlLHJlc3Q6bmFtZS5zdWJzdHJpbmcobS5wYXRoLmxlbmd0aCxuYW1lLmxlbmd0aCl9O1xuICAgIH1cbiAgfVxuICBpZiggcmVzICkgcmV0dXJuIHJlcztcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJubyBkZXZpY2UgZm91bmQgZm9yIFwiICsgbmFtZV9zbGFzaCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbW91bnRfYXV0b2xvYWRcbi8vUmVxdWlyZXM6IE1sRmFrZURldmljZSwgY2FtbF9tYWtlX3BhdGgsIGpzb29fbW91bnRfcG9pbnQsIGNhbWxfdHJhaWxpbmdfc2xhc2hcbmZ1bmN0aW9uIGNhbWxfbW91bnRfYXV0b2xvYWQobmFtZSxmKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBjYW1sX3RyYWlsaW5nX3NsYXNoKHBhdGguam9pbihcIi9cIikpO1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6bmFtZSxkZXZpY2U6bmV3IE1sRmFrZURldmljZShuYW1lLGYpfSlcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5tb3VudFxuLy9SZXF1aXJlczoganNvb19tb3VudF9wb2ludCwgY2FtbF9tYWtlX3BhdGgsIGNhbWxfdHJhaWxpbmdfc2xhc2hcbmZ1bmN0aW9uIGNhbWxfdW5tb3VudChuYW1lKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBjYW1sX3RyYWlsaW5nX3NsYXNoKHBhdGguam9pbihcIi9cIikpO1xuICB2YXIgaWR4ID0gLTE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKVxuICAgIGlmKGpzb29fbW91bnRfcG9pbnRbaV0ucGF0aCA9PSBuYW1lKSBpZHggPSBpO1xuICBpZihpZHggPiAtMSkganNvb19tb3VudF9wb2ludC5zcGxpY2UoaWR4LDEpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRjd2Rcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXIsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldGN3ZCgpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF9jdXJyZW50X2Rpcik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NoZGlyXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfdHJhaWxpbmdfc2xhc2gsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX2NoZGlyKGRpcikge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKGRpcik7XG4gIGlmKHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpKSB7XG4gICAgaWYocm9vdC5yZXN0KSBjYW1sX2N1cnJlbnRfZGlyID0gY2FtbF90cmFpbGluZ19zbGFzaChyb290LnBhdGggKyByb290LnJlc3QpO1xuICAgIGVsc2UgY2FtbF9jdXJyZW50X2RpciA9IHJvb3QucGF0aDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGRpcikpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUobmFtZSl7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChuYW1lICsgXCI6IE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm90X2FfZGlyXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub3RfYV9kaXIobmFtZSl7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChuYW1lICsgXCI6IE5vdCBhIGRpcmVjdG9yeVwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZmlsZV9leGlzdHNcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19maWxlX2V4aXN0cyAobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICByZXR1cm4gcm9vdC5kZXZpY2UuZXhpc3RzKHJvb3QucmVzdCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9hX2RpciwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5KG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgYSA9IHJvb3QuZGV2aWNlLnJlYWRkaXIocm9vdC5yZXN0KTtcbiAgdmFyIGwgPSBuZXcgQXJyYXkoYS5sZW5ndGggKyAxKTtcbiAgbFswXSA9IDA7XG4gIGZvcih2YXIgaT0wO2k8YS5sZW5ndGg7aSsrKVxuICAgIGxbaSsxXSA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoYVtpXSk7XG4gIHJldHVybiBsO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZW1vdmVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfcmVtb3ZlKG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgb2sgPSByb290LmRldmljZS51bmxpbmsocm9vdC5yZXN0KTtcbiAgaWYob2sgPT0gMCkgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19pc19kaXJlY3Rvcnlcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19pc19kaXJlY3RvcnkobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBhID0gcm9vdC5kZXZpY2UuaXNfZGlyKHJvb3QucmVzdCk7XG4gIHJldHVybiBhPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVuYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcmVuYW1lKG8sbil7XG4gIHZhciBvX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShvKTtcbiAgdmFyIG5fcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG4pO1xuICBpZihvX3Jvb3QuZGV2aWNlICE9IG5fcm9vdC5kZXZpY2UpXG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3lzX3JlbmFtZTogY2Fubm90IG1vdmUgZmlsZSBiZXR3ZWVuIHR3byBmaWxlc3lzdGVtXCIpO1xuICBpZighb19yb290LmRldmljZS5yZW5hbWUpXG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3lzX3JlbmFtZTogbm8gaW1wbGVtZW50ZWRcIik7XG4gIG9fcm9vdC5kZXZpY2UucmVuYW1lKG9fcm9vdC5yZXN0LCBuX3Jvb3QucmVzdCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX21rZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfc3lzX21rZGlyKG5hbWUsIHBlcm0pe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICByb290LmRldmljZS5ta2Rpcihyb290LnJlc3QscGVybSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19ybWRpclxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX3JhaXNlX25vdF9hX2RpclxuZnVuY3Rpb24gY2FtbF9zeXNfcm1kaXIobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHJvb3QuZGV2aWNlLnJtZGlyKHJvb3QucmVzdCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX21hcF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2JhX21hcF9maWxlKHZmZCwga2luZCwgbGF5b3V0LCBzaGFyZWQsIGRpbXMsIHBvcykge1xuICAvLyB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW3ZmZF07XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2JhX21hcF9maWxlIG5vdCBpbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZVxuLy9SZXF1aXJlczogY2FtbF9iYV9tYXBfZmlsZVxuZnVuY3Rpb24gY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZShhcmd2LGFyZ24pe1xuICByZXR1cm4gY2FtbF9iYV9tYXBfZmlsZShhcmd2WzBdLGFyZ3ZbMV0sYXJndlsyXSxhcmd2WzNdLGFyZ3ZbNF0sYXJndls1XSk7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29fY3JlYXRlX2ZpbGVfZXh0ZXJuXG5mdW5jdGlvbiBqc29vX2NyZWF0ZV9maWxlX2V4dGVybihuYW1lLGNvbnRlbnQpe1xuICBpZihnbG9iYWxUaGlzLmpzb29fY3JlYXRlX2ZpbGUpXG4gICAgZ2xvYmFsVGhpcy5qc29vX2NyZWF0ZV9maWxlKG5hbWUsY29udGVudCk7XG4gIGVsc2Uge1xuICAgIGlmKCFnbG9iYWxUaGlzLmNhbWxfZnNfdG1wKSBnbG9iYWxUaGlzLmNhbWxfZnNfdG1wID0gW107XG4gICAgZ2xvYmFsVGhpcy5jYW1sX2ZzX3RtcC5wdXNoKHtuYW1lOm5hbWUsY29udGVudDpjb250ZW50fSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZnNfaW5pdFxuLy9SZXF1aXJlczoganNvb19jcmVhdGVfZmlsZVxuZnVuY3Rpb24gY2FtbF9mc19pbml0ICgpe1xuICB2YXIgdG1wPWdsb2JhbFRoaXMuY2FtbF9mc190bXBcbiAgaWYodG1wKXtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgaSsrKXtcbiAgICAgIGpzb29fY3JlYXRlX2ZpbGUodG1wW2ldLm5hbWUsdG1wW2ldLmNvbnRlbnQpO1xuICAgIH1cbiAgfVxuICBnbG9iYWxUaGlzLmpzb29fY3JlYXRlX2ZpbGUgPSBqc29vX2NyZWF0ZV9maWxlO1xuICBnbG9iYWxUaGlzLmNhbWxfZnNfdG1wID0gW107XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9jcmVhdGVfZmlsZShuYW1lLGNvbnRlbnQpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYoISByb290LmRldmljZS5yZWdpc3RlcikgY2FtbF9mYWlsd2l0aChcImNhbm5vdCByZWdpc3RlciBmaWxlXCIpO1xuICByb290LmRldmljZS5yZWdpc3Rlcihyb290LnJlc3QsY29udGVudCk7XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGpzb29fY3JlYXRlX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2ZpbGUsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGpzb29fY3JlYXRlX2ZpbGUobmFtZSxjb250ZW50KSB7XG4gIHZhciBuYW1lID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhuYW1lKTtcbiAgdmFyIGNvbnRlbnQgPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNvbnRlbnQpO1xuICByZXR1cm4gY2FtbF9jcmVhdGVfZmlsZShuYW1lLCBjb250ZW50KTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlYWRfZmlsZV9jb250ZW50XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yZWFkX2ZpbGVfY29udGVudCAobmFtZSkge1xuICB2YXIgbmFtZSA9ICh0eXBlb2YgbmFtZSA9PSBcInN0cmluZ1wiKT9jYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpOm5hbWU7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmKHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpKSB7XG4gICAgdmFyIGZpbGUgPSByb290LmRldmljZS5vcGVuKHJvb3QucmVzdCx7cmRvbmx5OjF9KTtcbiAgICB2YXIgbGVuICA9IGZpbGUubGVuZ3RoKCk7XG4gICAgdmFyIGJ1ZiAgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgIGZpbGUucmVhZCgwLGJ1ZiwwLGxlbik7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2J5dGVzKGJ1ZilcbiAgfVxuICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpKTtcbn1cbiIsIi8vUHJvdmlkZXM6IHVuaXhfZ2V0dGltZW9mZGF5XG5mdW5jdGlvbiB1bml4X2dldHRpbWVvZmRheSAoKSB7XG4gIHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC8gMTAwMDtcbn1cblxuLy9Qcm92aWRlczogdW5peF90aW1lXG4vL1JlcXVpcmVzOiB1bml4X2dldHRpbWVvZmRheVxuZnVuY3Rpb24gdW5peF90aW1lICgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IodW5peF9nZXR0aW1lb2ZkYXkgKCkpO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X2dtdGltZVxuZnVuY3Rpb24gdW5peF9nbXRpbWUgKHQpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSAodCAqIDEwMDApO1xuICB2YXIgZF9udW0gPSBkLmdldFRpbWUoKTtcbiAgdmFyIGphbnVhcnlmaXJzdCA9IChuZXcgRGF0ZShEYXRlLlVUQyhkLmdldFVUQ0Z1bGxZZWFyKCksIDAsIDEpKSkuZ2V0VGltZSgpO1xuICB2YXIgZG95ID0gTWF0aC5mbG9vcigoZF9udW0gLSBqYW51YXJ5Zmlyc3QpIC8gODY0MDAwMDApO1xuICByZXR1cm4gQkxPQ0soMCwgZC5nZXRVVENTZWNvbmRzKCksIGQuZ2V0VVRDTWludXRlcygpLCBkLmdldFVUQ0hvdXJzKCksXG4gICAgICAgICAgICAgICBkLmdldFVUQ0RhdGUoKSwgZC5nZXRVVENNb250aCgpLCBkLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTAwLFxuICAgICAgICAgICAgICAgZC5nZXRVVENEYXkoKSwgZG95LFxuICAgICAgICAgICAgICAgZmFsc2UgfCAwIC8qIGZvciBVVEMgZGF5bGlnaHQgc2F2aW5ncyB0aW1lIGlzIGZhbHNlICovKVxufVxuXG4vL1Byb3ZpZGVzOiB1bml4X2xvY2FsdGltZVxuZnVuY3Rpb24gdW5peF9sb2NhbHRpbWUgKHQpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSAodCAqIDEwMDApO1xuICB2YXIgZF9udW0gPSBkLmdldFRpbWUoKTtcbiAgdmFyIGphbnVhcnlmaXJzdCA9IChuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDAsIDEpKS5nZXRUaW1lKCk7XG4gIHZhciBkb3kgPSBNYXRoLmZsb29yKChkX251bSAtIGphbnVhcnlmaXJzdCkgLyA4NjQwMDAwMCk7XG4gIHZhciBqYW4gPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICB2YXIganVsID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCA2LCAxKTtcbiAgdmFyIHN0ZFRpbWV6b25lT2Zmc2V0ID0gTWF0aC5tYXgoamFuLmdldFRpbWV6b25lT2Zmc2V0KCksIGp1bC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgcmV0dXJuIEJMT0NLKDAsIGQuZ2V0U2Vjb25kcygpLCBkLmdldE1pbnV0ZXMoKSwgZC5nZXRIb3VycygpLFxuICAgICAgICAgICAgICAgZC5nZXREYXRlKCksIGQuZ2V0TW9udGgoKSwgZC5nZXRGdWxsWWVhcigpIC0gMTkwMCxcbiAgICAgICAgICAgICAgIGQuZ2V0RGF5KCksIGRveSxcbiAgICAgICAgICAgICAgIChkLmdldFRpbWV6b25lT2Zmc2V0KCkgPCBzdGRUaW1lem9uZU9mZnNldCkgfCAwIC8qIGRheWxpZ2h0IHNhdmluZ3MgdGltZSAgZmllbGQuICovKVxufVxuXG4vL1Byb3ZpZGVzOiB1bml4X21rdGltZVxuLy9SZXF1aXJlczogdW5peF9sb2NhbHRpbWVcbmZ1bmN0aW9uIHVuaXhfbWt0aW1lKHRtKXtcbiAgdmFyIGQgPSAobmV3IERhdGUodG1bNl0rMTkwMCx0bVs1XSx0bVs0XSx0bVszXSx0bVsyXSx0bVsxXSkpLmdldFRpbWUoKTtcbiAgdmFyIHQgPSBNYXRoLmZsb29yKGQgLyAxMDAwKTtcbiAgdmFyIHRtMiA9IHVuaXhfbG9jYWx0aW1lKHQpO1xuICByZXR1cm4gQkxPQ0soMCx0LHRtMik7XG59XG5cbi8vUHJvdmlkZXM6IHdpbl9zdGFydHVwIGNvbnN0XG5mdW5jdGlvbiB3aW5fc3RhcnR1cCgpIHt9XG5cbi8vUHJvdmlkZXM6IHdpbl9jbGVhbnVwIGNvbnN0XG5mdW5jdGlvbiB3aW5fY2xlYW51cCgpIHt9XG5cbi8vUHJvdmlkZXM6IHdpbl9oYW5kbGVfZmQgY29uc3RcbmZ1bmN0aW9uIHdpbl9oYW5kbGVfZmQoeCkge3JldHVybiB4O31cblxuLy9Qcm92aWRlczogdW5peF9pc2F0dHlcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkXG5mdW5jdGlvbiB1bml4X2lzYXR0eShmaWxlRGVzY3JpcHRvcikge1xuICBpZihmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gICAgdmFyIHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xuICAgIHJldHVybiB0dHkuaXNhdHR5KGZpbGVEZXNjcmlwdG9yKT8xOjA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogbWFrZV91bml4X2Vycl9hcmdzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xudmFyIHVuaXhfZXJyb3IgPSBbXG4gIC8qID09PVVuaXguZXJyb3I9PT1cbiAgICpcbiAgICogVGhpcyBhcnJheSBpcyBpbiBvcmRlciBvZiB0aGUgdmFyaWFudCBpbiBPQ2FtbFxuICAgKi9cbiAgXCJFMkJJR1wiLCBcIkVBQ0NFU1wiLCBcIkVBR0FJTlwiLCBcIkVCQURGXCIsIFwiRUJVU1lcIiwgXCJFQ0hJTERcIiwgXCJFREVBRExLXCIsIFwiRURPTVwiLFxuICBcIkVFWElTVFwiLCBcIkVGQVVMVFwiLCBcIkVGQklHXCIsIFwiRUlOVFJcIiwgXCJFSU5WQUxcIiwgXCJFSU9cIiwgXCJFSVNESVJcIiwgXCJFTUZJTEVcIixcbiAgXCJFTUxJTktcIiwgXCJFTkFNRVRPT0xPTkdcIiwgXCJFTkZJTEVcIiwgXCJFTk9ERVZcIiwgXCJFTk9FTlRcIiwgXCJFTk9FWEVDXCIsIFwiRU5PTENLXCIsXG4gIFwiRU5PTUVNXCIsIFwiRU5PU1BDXCIsIFwiRU5PU1lTXCIsIFwiRU5PVERJUlwiLCBcIkVOT1RFTVBUWVwiLCBcIkVOT1RUWVwiLCBcIkVOWElPXCIsXG4gIFwiRVBFUk1cIiwgXCJFUElQRVwiLCBcIkVSQU5HRVwiLCBcIkVST0ZTXCIsIFwiRVNQSVBFXCIsIFwiRVNSQ0hcIiwgXCJFWERFVlwiLCBcIkVXT1VMREJMT0NLXCIsXG4gIFwiRUlOUFJPR1JFU1NcIiwgXCJFQUxSRUFEWVwiLCBcIkVOT1RTT0NLXCIsIFwiRURFU1RBRERSUkVRXCIsIFwiRU1TR1NJWkVcIixcbiAgXCJFUFJPVE9UWVBFXCIsIFwiRU5PUFJPVE9PUFRcIiwgXCJFUFJPVE9OT1NVUFBPUlRcIiwgXCJFU09DS1ROT1NVUFBPUlRcIixcbiAgXCJFT1BOT1RTVVBQXCIsIFwiRVBGTk9TVVBQT1JUXCIsIFwiRUFGTk9TVVBQT1JUXCIsIFwiRUFERFJJTlVTRVwiLCBcIkVBRERSTk9UQVZBSUxcIixcbiAgXCJFTkVURE9XTlwiLCBcIkVORVRVTlJFQUNIXCIsIFwiRU5FVFJFU0VUXCIsIFwiRUNPTk5BQk9SVEVEXCIsIFwiRUNPTk5SRVNFVFwiLCBcIkVOT0JVRlNcIixcbiAgXCJFSVNDT05OXCIsIFwiRU5PVENPTk5cIiwgXCJFU0hVVERPV05cIiwgXCJFVE9PTUFOWVJFRlNcIiwgXCJFVElNRURPVVRcIiwgXCJFQ09OTlJFRlVTRURcIixcbiAgXCJFSE9TVERPV05cIiwgXCJFSE9TVFVOUkVBQ0hcIiwgXCJFTE9PUFwiLCBcIkVPVkVSRkxPV1wiXG5dO1xuZnVuY3Rpb24gbWFrZV91bml4X2Vycl9hcmdzKGNvZGUsIHN5c2NhbGwsIHBhdGgsIGVycm5vKSB7XG4gIHZhciB2YXJpYW50ID0gdW5peF9lcnJvci5pbmRleE9mKGNvZGUpO1xuICBpZiAodmFyaWFudCA8IDApIHtcbiAgICAvLyBEZWZhdWx0IGlmIHVuZGVmaW5lZFxuICAgIGlmIChlcnJubyA9PSBudWxsKSB7XG4gICAgICBlcnJubyA9IC05OTk5XG4gICAgfVxuICAgIC8vIElmIG5vbmUgb2YgdGhlIGFib3ZlIHZhcmlhbnRzLCBmYWxsYmFjayB0byBFVU5LTk9XTkVSUihpbnQpXG4gICAgdmFyaWFudCA9IEJMT0NLKDAsIGVycm5vKTtcbiAgfVxuICB2YXIgYXJncyA9IFtcbiAgICB2YXJpYW50LFxuICAgIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHN5c2NhbGwgfHwgXCJcIiksXG4gICAgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocGF0aCB8fCBcIlwiKVxuICBdO1xuICByZXR1cm4gYXJncztcbn1cblxuLy9Qcm92aWRlczogdW5peF9zdGF0XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gdW5peF9zdGF0KG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5zdGF0KSB7XG4gICAgY2FtbF9mYWlsd2l0aChcInVuaXhfc3RhdDogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5zdGF0KHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogdW5peF9zdGF0XzY0XG4vL1JlcXVpcmVzOiB1bml4X3N0YXRcbnZhciB1bml4X3N0YXRfNjQgPSB1bml4X3N0YXQ7XG5cbi8vUHJvdmlkZXM6IHVuaXhfbHN0YXRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiB1bml4X2xzdGF0KG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5sc3RhdCkge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJ1bml4X2xzdGF0OiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLmxzdGF0KHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogdW5peF9sc3RhdF82NFxuLy9SZXF1aXJlczogdW5peF9sc3RhdFxudmFyIHVuaXhfbHN0YXRfNjQgPSB1bml4X2xzdGF0O1xuXG4vL1Byb3ZpZGVzOiB1bml4X21rZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gdW5peF9ta2RpcihuYW1lLCBwZXJtKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UubWtkaXIpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwidW5peF9ta2Rpcjogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5ta2Rpcihyb290LnJlc3QsIHBlcm0sIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfcm1kaXJcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiB1bml4X3JtZGlyKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5ybWRpcikge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJ1bml4X3JtZGlyOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLnJtZGlyKHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogdW5peF9zeW1saW5rXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gdW5peF9zeW1saW5rKHRvX2Rpciwgc3JjLCBkc3QpIHtcbiAgdmFyIHNyY19yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uoc3JjKTtcbiAgdmFyIGRzdF9yb290ID0gcmVzb2x2ZV9mc19kZXZpY2UoZHN0KTtcbiAgaWYoc3JjX3Jvb3QuZGV2aWNlICE9IGRzdF9yb290LmRldmljZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwidW5peF9zeW1saW5rOiBjYW5ub3Qgc3ltbGluayBiZXR3ZWVuIHR3byBmaWxlc3lzdGVtc1wiKTtcbiAgaWYgKCFzcmNfcm9vdC5kZXZpY2Uuc3ltbGluaykge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJ1bml4X3N5bWxpbms6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gc3JjX3Jvb3QuZGV2aWNlLnN5bWxpbmsodG9fZGlyLCBzcmNfcm9vdC5yZXN0LCBkc3Rfcm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X3JlYWRsaW5rXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gdW5peF9yZWFkbGluayhuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UucmVhZGxpbmspIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwidW5peF9yZWFkbGluazogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5yZWFkbGluayhyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfdW5saW5rXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gdW5peF91bmxpbmsobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLnVubGluaykge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJ1bml4X3VubGluazogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS51bmxpbmsocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X2dldHVpZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbmZ1bmN0aW9uIHVuaXhfZ2V0dWlkKHVuaXQpIHtcbiAgaWYoZ2xvYmFsVGhpcy5wcm9jZXNzICYmIGdsb2JhbFRoaXMucHJvY2Vzcy5nZXR1aWQpe1xuICAgIHJldHVybiBnbG9iYWxUaGlzLnByb2Nlc3MuZ2V0dWlkKCk7XG4gIH1cbiAgY2FtbF9yYWlzZV9ub3RfZm91bmQoKTtcbn1cblxuLy9Qcm92aWRlczogdW5peF9nZXRwd3VpZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbmZ1bmN0aW9uIHVuaXhfZ2V0cHd1aWQodW5pdCkge1xuICBjYW1sX3JhaXNlX25vdF9mb3VuZCgpXG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfaGFzX3N5bWxpbmtcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkXG5mdW5jdGlvbiB1bml4X2hhc19zeW1saW5rKHVuaXQpIHtcbiAgcmV0dXJuIGZzX25vZGVfc3VwcG9ydGVkKCk/MTowXG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIFN5c1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3N5c19lcnJvciAobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5TeXNfZXJyb3IsIG1zZyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2V4aXRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9zeXNfZXhpdCAoY29kZSkge1xuICB2YXIgZyA9IGdsb2JhbFRoaXM7XG4gIGlmKGcucXVpdCkgZy5xdWl0KGNvZGUpO1xuICAvL25vZGVqc1xuICBpZihnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLmV4aXQpXG4gICAgZy5wcm9jZXNzLmV4aXQoY29kZSk7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkZ1bmN0aW9uICdleGl0JyBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb24oZXhuKXtcbiAgc3dpdGNoKGV4blsyXSkge1xuICBjYXNlIC04OiAvLyBNYXRjaF9mYWlsdXJlXG4gIGNhc2UgLTExOiAvLyBBc3NlcnRfZmFpbHVyZVxuICBjYXNlIC0xMjogLy8gVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGVcbiAgICByZXR1cm4gMTtcbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9leGNlcHRpb25cbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2V4Y2VwdGlvbihleG4pe1xuICB2YXIgciA9IFwiXCI7XG4gIGlmKGV4blswXSA9PSAwKSB7XG4gICAgciArPSBleG5bMV1bMV07XG4gICAgaWYoZXhuLmxlbmd0aCA9PSAzICYmIGV4blsyXVswXSA9PSAwICYmIGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb24oZXhuWzFdKSkge1xuXG4gICAgICB2YXIgYnVja2V0ID0gZXhuWzJdO1xuICAgICAgdmFyIHN0YXJ0ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gMlxuICAgICAgdmFyIGJ1Y2tldCA9IGV4bjtcbiAgICB9XG4gICAgciArPSBcIihcIjtcbiAgICBmb3IodmFyIGkgPSBzdGFydDsgaSA8IGJ1Y2tldC5sZW5ndGg7IGkgKyspe1xuICAgICAgaWYoaSA+IHN0YXJ0KSByKz1cIiwgXCI7XG4gICAgICB2YXIgdiA9IGJ1Y2tldFtpXVxuICAgICAgaWYodHlwZW9mIHYgPT0gXCJudW1iZXJcIilcbiAgICAgICAgcis9IHYudG9TdHJpbmcoKTtcbiAgICAgIGVsc2UgaWYodiBpbnN0YW5jZW9mIE1sQnl0ZXMpe1xuICAgICAgICByKz0gJ1wiJyArIHYudG9TdHJpbmcoKSArICdcIic7XG4gICAgICB9XG4gICAgICBlbHNlIGlmKHR5cGVvZiB2ID09IFwic3RyaW5nXCIpe1xuICAgICAgICByKz0gJ1wiJyArIHYudG9TdHJpbmcoKSArICdcIic7XG4gICAgICB9XG4gICAgICBlbHNlIHIgKz0gXCJfXCI7XG4gICAgfVxuICAgIHIgKz0gXCIpXCJcbiAgfSBlbHNlIGlmIChleG5bMF0gPT0gMjQ4KXtcbiAgICByICs9IGV4blsxXVxuICB9XG4gIHJldHVybiByXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX2Zvcm1hdF9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uKGVycil7XG4gIGlmKGVyciBpbnN0YW5jZW9mIEFycmF5ICYmIChlcnJbMF0gPT0gMCB8fCBlcnJbMF0gPT0gMjQ4KSkge1xuICAgIHZhciBoYW5kbGVyID0gY2FtbF9uYW1lZF92YWx1ZShcIlByaW50ZXhjLmhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cIik7XG4gICAgaWYoaGFuZGxlcikgaGFuZGxlcihlcnIsZmFsc2UpO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIG1zZyA9IGNhbWxfZm9ybWF0X2V4Y2VwdGlvbihlcnIpO1xuICAgICAgdmFyIGF0X2V4aXQgPSBjYW1sX25hbWVkX3ZhbHVlKFwiUGVydmFzaXZlcy5kb19hdF9leGl0XCIpO1xuICAgICAgaWYoYXRfZXhpdCkgeyBhdF9leGl0KDApIH1cbiAgICAgIGdsb2JhbFRoaXMuY29uc29sZS5lcnJvcihcIkZhdGFsIGVycm9yOiBleGNlcHRpb24gXCIgKyBtc2cgKyBcIlxcblwiKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9zdGF0aWNfZW52XG5mdW5jdGlvbiBjYW1sX3NldF9zdGF0aWNfZW52KGssdil7XG4gIGlmKCFnbG9iYWxUaGlzLmpzb29fc3RhdGljX2VudilcbiAgICBnbG9iYWxUaGlzLmpzb29fc3RhdGljX2VudiA9IHt9XG4gIGdsb2JhbFRoaXMuanNvb19zdGF0aWNfZW52W2tdID0gdjtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRlbnYgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0ZW52IChuYW1lKSB7XG4gIHZhciBnID0gZ2xvYmFsVGhpcztcbiAgdmFyIG4gPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgLy9ub2RlanMgZW52XG4gIGlmKGcucHJvY2Vzc1xuICAgICAmJiBnLnByb2Nlc3MuZW52XG4gICAgICYmIGcucHJvY2Vzcy5lbnZbbl0gIT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhnLnByb2Nlc3MuZW52W25dKTtcbiAgaWYoZ2xvYmFsVGhpcy5qc29vX3N0YXRpY19lbnZcbiAgICAgJiYgZ2xvYmFsVGhpcy5qc29vX3N0YXRpY19lbnZbbl0pXG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGdsb2JhbFRoaXMuanNvb19zdGF0aWNfZW52W25dKVxuICBjYW1sX3JhaXNlX25vdF9mb3VuZCAoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdW5zYWZlX2dldGVudlxuLy9SZXF1aXJlczogY2FtbF9zeXNfZ2V0ZW52XG5mdW5jdGlvbiBjYW1sX3N5c191bnNhZmVfZ2V0ZW52KG5hbWUpe1xuICByZXR1cm4gY2FtbF9zeXNfZ2V0ZW52IChuYW1lKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xudmFyIGNhbWxfYXJndiA9ICgoZnVuY3Rpb24gKCkge1xuICB2YXIgZyA9IGdsb2JhbFRoaXM7XG4gIHZhciBtYWluID0gXCJhLm91dFwiO1xuICB2YXIgYXJncyA9IFtdXG5cbiAgaWYoZy5wcm9jZXNzXG4gICAgICYmIGcucHJvY2Vzcy5hcmd2XG4gICAgICYmIGcucHJvY2Vzcy5hcmd2Lmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgYXJndiA9IGcucHJvY2Vzcy5hcmd2XG4gICAgLy9ub2RlanNcbiAgICBtYWluID0gYXJndlsxXTtcbiAgICBhcmdzID0gYXJndi5zbGljZSgyKTtcbiAgfVxuXG4gIHZhciBwID0gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcobWFpbik7XG4gIHZhciBhcmdzMiA9IFswLCBwXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspXG4gICAgYXJnczIucHVzaChjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhhcmdzW2ldKSk7XG4gIHJldHVybiBhcmdzMjtcbn0pKCkpXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhlY3V0YWJsZV9uYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbnZhciBjYW1sX2V4ZWN1dGFibGVfbmFtZSA9IGNhbWxfYXJndlsxXVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfYXJndiAoYSkge1xuICByZXR1cm4gWzAsIGNhbWxfYXJndlsxXSwgY2FtbF9hcmd2XTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19hcmd2IChhKSB7XG4gIHJldHVybiBjYW1sX2FyZ3Y7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX21vZGlmeV9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX21vZGlmeV9hcmd2KGFyZyl7XG4gIGNhbWxfYXJndiA9IGFyZztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZSBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9leGVjdXRhYmxlX25hbWVcbmZ1bmN0aW9uIGNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZShhKXtcbiAgcmV0dXJuIGNhbWxfZXhlY3V0YWJsZV9uYW1lXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmQoY21kKXtcbiAgdmFyIGNtZCA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGNtZCk7XG4gIGlmICh0eXBlb2YgcmVxdWlyZSAhPSBcInVuZGVmaW5lZFwiXG4gICAgICAmJiByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJylcbiAgICAgICYmIHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYykge1xuICAgIHRyeSB7cmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jKGNtZCx7c3RkaW86ICdpbmhlcml0J30pOyByZXR1cm4gMH1cbiAgICBjYXRjaCAoZSkge3JldHVybiAxfVxuICB9XG4gIGVsc2UgcmV0dXJuIDEyNztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdGltZSBtdXRhYmxlXG52YXIgY2FtbF9pbml0aWFsX3RpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpICogMC4wMDE7XG5mdW5jdGlvbiBjYW1sX3N5c190aW1lICgpIHtcbiAgdmFyIG5vdyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIHJldHVybiBub3cgKiAwLjAwMSAtIGNhbWxfaW5pdGlhbF90aW1lO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW5cbi8vUmVxdWlyZXM6IGNhbWxfc3lzX3RpbWVcbmZ1bmN0aW9uIGNhbWxfc3lzX3RpbWVfaW5jbHVkZV9jaGlsZHJlbihiKSB7XG4gIHJldHVybiBjYW1sX3N5c190aW1lKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JhbmRvbV9zZWVkIG11dGFibGVcbi8vVGhlIGZ1bmN0aW9uIG5lZWRzIHRvIHJldHVybiBhbiBhcnJheSBzaW5jZSBPQ2FtbCA0LjAuLi5cbmZ1bmN0aW9uIGNhbWxfc3lzX3JhbmRvbV9zZWVkICgpIHtcbiAgaWYoZ2xvYmFsVGhpcy5jcnlwdG8pIHtcbiAgICBpZih0eXBlb2YgZ2xvYmFsVGhpcy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKXtcbiAgICAgIC8vIFdlYmJyb3dzZXJzXG4gICAgICB2YXIgYSA9IG5ldyBnbG9iYWxUaGlzLlVpbnQzMkFycmF5KDEpO1xuICAgICAgZ2xvYmFsVGhpcy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGEpO1xuICAgICAgcmV0dXJuIFswLGFbMF1dO1xuICAgIH0gZWxzZSBpZihnbG9iYWxUaGlzLmNyeXB0by5yYW5kb21CeXRlcyA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAvLyBOb2RlanNcbiAgICAgIHZhciBidWZmID0gZ2xvYmFsVGhpcy5jcnlwdG8ucmFuZG9tQnl0ZXMoNCk7XG4gICAgICB2YXIgYSA9IG5ldyBnbG9iYWxUaGlzLlVpbnQzMkFycmF5KGJ1ZmYpO1xuICAgICAgcmV0dXJuIFswLGFbMF1dO1xuICAgIH1cbiAgfVxuICB2YXIgbm93ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgdmFyIHggPSBub3deMHhmZmZmZmZmZipNYXRoLnJhbmRvbSgpO1xuICByZXR1cm4gWzAseF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF93b3JkX3NpemUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSAoKSB7IHJldHVybiAzMjsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfaW50X3NpemUgKCkgeyByZXR1cm4gMzI7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSBjb25zdFxuLy8gbWF4X2ludCAvIDQgc28gdGhhdCB0aGUgZm9sbG93aW5nIGRvZXMgbm90IG92ZXJmbG93XG4vL2xldCBtYXhfc3RyaW5nX2xlbmd0aCA9IHdvcmRfc2l6ZSAvIDggKiBtYXhfYXJyYXlfbGVuZ3RoIC0gMTs7XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9tYXhfd29zaXplICgpIHsgcmV0dXJuICgweDdGRkZGRkZGLzQpIHwgMDt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IGNvbnN0XG4vL1JlcXVpcmVzOiBvc190eXBlXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCAoKSB7IHJldHVybiBvc190eXBlID09IFwiVW5peFwiID8gMSA6IDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiBjb25zdFxuLy9SZXF1aXJlczogb3NfdHlwZVxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyICgpIHsgcmV0dXJuIG9zX3R5cGUgPT0gXCJXaW4zMlwiID8gMSA6IDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gY29uc3Rcbi8vUmVxdWlyZXM6IG9zX3R5cGVcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gKCkgeyByZXR1cm4gb3NfdHlwZSA9PSBcIkN5Z3dpblwiID8gMSA6IDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUgKCkge1xuICByZXR1cm4gWzAsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJqc19vZl9vY2FtbFwiKV07XG59XG5cbi8vUHJvdmlkZXM6IG9zX3R5cGVcbnZhciBvc190eXBlID0gKGdsb2JhbFRoaXMucHJvY2VzcyAmJlxuICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5wcm9jZXNzLnBsYXRmb3JtICYmXG4gICAgICAgICAgICAgICBnbG9iYWxUaGlzLnByb2Nlc3MucGxhdGZvcm0gPT0gXCJ3aW4zMlwiKSA/IFwiQ3lnd2luXCIgOiBcIlVuaXhcIjtcblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfY29uZmlnIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBvc190eXBlXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfY29uZmlnICgpIHtcbiAgcmV0dXJuIFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG9zX3R5cGUpLCAzMiwgMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzYXR0eVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNhdHR5KF9jaGFuKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfdmFyaWFudFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3ZhcmlhbnQoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfcGFyYW1ldGVyc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3BhcmFtZXRlcnMoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyKCl7cmV0dXJuIDB9XG5cbi8vUHJvdmlkZXM6IHVuaXhfaW5ldF9hZGRyX29mX3N0cmluZ1xuZnVuY3Rpb24gdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nICgpIHtyZXR1cm4gMDt9XG5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbnZhciBjYW1sX3J1bnRpbWVfd2FybmluZ3MgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzXG4vL1JlcXVpcmVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbmZ1bmN0aW9uIGNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MgKGJvb2wpIHtcbiAgY2FtbF9ydW50aW1lX3dhcm5pbmdzID0gYm9vbDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkXG4vL1JlcXVpcmVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbmZ1bmN0aW9uIGNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkIChfdW5pdCkge1xuICByZXR1cm4gY2FtbF9ydW50aW1lX3dhcm5pbmdzO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3BhY2V0aW1lX2VuYWJsZWQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9zcGFjZXRpbWVfZW5hYmxlZChfdW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfbmFrZWRfcG9pbnRlcnNfY2hlY2tlZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9uYWtlZF9wb2ludGVyc19jaGVja2VkKF91bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZShfY2hhbm5lbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiU3BhY2V0aW1lIHByb2ZpbGluZyBvbmx5IHdvcmtzIGZvciBuYXRpdmUgY29kZVwiKTtcbn1cblxuLy9BbHdheXNcbi8vUmVxdWlyZXM6IGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX3NldHVwX3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyKCkge1xuICB2YXIgZyA9IGdsb2JhbFRoaXM7XG4gIGlmKGcucHJvY2VzcyAmJiBnLnByb2Nlc3Mub24pIHtcbiAgICBnLnByb2Nlc3Mub24oJ3VuY2F1Z2h0RXhjZXB0aW9uJywgZnVuY3Rpb24gKGVyciwgb3JpZ2luKSB7XG4gICAgICBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbihlcnIpO1xuICAgICAgZy5wcm9jZXNzLmV4aXQgKDIpO1xuICAgIH0pXG4gIH1cbiAgZWxzZSBpZihnLmFkZEV2ZW50TGlzdGVuZXIpe1xuICAgIGcuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbihldmVudCl7XG4gICAgICBpZihldmVudC5lcnJvcil7XG4gICAgICAgIGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uKGV2ZW50LmVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY2FtbF9zZXR1cF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlcigpO1xuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogTWxGYWtlRGV2aWNlXG4vL1JlcXVpcmVzOiBNbEZha2VGaWxlLCBjYW1sX2NyZWF0ZV9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9hcnJheSwgY2FtbF9ieXRlc19vZl9zdHJpbmcsIGNhbWxfYnl0ZXNfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9pc19tbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfcmFpc2Vfd2l0aF9hcmdzLCBjYW1sX25hbWVkX3ZhbHVlc1xuLy9SZXF1aXJlczogbWFrZV91bml4X2Vycl9hcmdzXG5mdW5jdGlvbiBNbEZha2VEZXZpY2UgKHJvb3QsIGYpIHtcbiAgdGhpcy5jb250ZW50PXt9O1xuICB0aGlzLnJvb3QgPSByb290O1xuICB0aGlzLmxvb2t1cEZ1biA9IGY7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm5tID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gKHRoaXMucm9vdCArIG5hbWUpO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5jcmVhdGVfZGlyX2lmX25lZWRlZCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGNvbXAgPSBuYW1lLnNwbGl0KFwiL1wiKTtcbiAgdmFyIHJlcyA9IFwiXCI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBjb21wLmxlbmd0aCAtIDE7IGkrKyl7XG4gICAgcmVzICs9IGNvbXBbaV0gKyBcIi9cIjtcbiAgICBpZih0aGlzLmNvbnRlbnRbcmVzXSkgY29udGludWU7XG4gICAgdGhpcy5jb250ZW50W3Jlc10gPSBTeW1ib2woXCJkaXJlY3RvcnlcIik7XG4gIH1cbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuc2xhc2ggPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIC9cXC8kLy50ZXN0KG5hbWUpP25hbWU6KG5hbWUgKyBcIi9cIik7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYoIXRoaXMuY29udGVudFtuYW1lXSAmJiB0aGlzLmxvb2t1cEZ1bikge1xuICAgIHZhciByZXMgPSB0aGlzLmxvb2t1cEZ1bihjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHRoaXMucm9vdCksIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMobmFtZSkpO1xuICAgIGlmKHJlcyAhPT0gMCkge1xuICAgICAgdGhpcy5jcmVhdGVfZGlyX2lmX25lZWRlZChuYW1lKTtcbiAgICAgIHRoaXMuY29udGVudFtuYW1lXT1uZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX3N0cmluZyhyZXNbMV0pKTtcbiAgICB9XG4gIH1cbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICAvLyBUaGUgcm9vdCBvZiB0aGUgZGV2aWNlIGV4aXN0c1xuICBpZihuYW1lID09IFwiXCIpIHJldHVybiAxO1xuICAvLyBDaGVjayBpZiBhIGRpcmVjdG9yeSBleGlzdHNcbiAgdmFyIG5hbWVfc2xhc2ggPSB0aGlzLnNsYXNoKG5hbWUpO1xuICBpZih0aGlzLmNvbnRlbnRbbmFtZV9zbGFzaF0pIHJldHVybiAxO1xuICAvLyBDaGVjayBpZiBhIGZpbGUgZXhpc3RzXG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVdPzE6MDtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUubWtkaXIgPSBmdW5jdGlvbihuYW1lLG1vZGUsIHJhaXNlX3VuaXgpIHtcbiAgdmFyIHVuaXhfZXJyb3IgPSByYWlzZV91bml4ICYmIGNhbWxfbmFtZWRfdmFsdWUoJ1VuaXguVW5peF9lcnJvcicpO1xuICBpZih0aGlzLmV4aXN0cyhuYW1lKSkge1xuICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFRVhJU1RcIiwgXCJta2RpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBGaWxlIGV4aXN0c1wiKTtcbiAgICB9XG4gIH1cbiAgdmFyIHBhcmVudCA9IC9eKC4qKVxcL1teL10rLy5leGVjKG5hbWUpO1xuICBwYXJlbnQgPSAocGFyZW50ICYmIHBhcmVudFsxXSkgfHwgJyc7XG4gIGlmKCF0aGlzLmV4aXN0cyhwYXJlbnQpKXtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PRU5UXCIsIFwibWtkaXJcIiwgdGhpcy5ubShwYXJlbnQpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IocGFyZW50ICsgXCI6IE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcIik7XG4gICAgfVxuICB9XG4gIGlmKCF0aGlzLmlzX2RpcihwYXJlbnQpKXtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PVERJUlwiLCBcIm1rZGlyXCIsIHRoaXMubm0ocGFyZW50KSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHBhcmVudCArIFwiOiBOb3QgYSBkaXJlY3RvcnlcIik7XG4gICAgfVxuICB9XG4gIHRoaXMuY3JlYXRlX2Rpcl9pZl9uZWVkZWQodGhpcy5zbGFzaChuYW1lKSk7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnJtZGlyID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB2YXIgdW5peF9lcnJvciA9IHJhaXNlX3VuaXggJiYgY2FtbF9uYW1lZF92YWx1ZSgnVW5peC5Vbml4X2Vycm9yJyk7XG4gIHZhciBuYW1lX3NsYXNoID0gKG5hbWUgPT0gXCJcIik/XCJcIjoodGhpcy5zbGFzaChuYW1lKSk7XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKylcIik7XG4gIGlmKCF0aGlzLmV4aXN0cyhuYW1lKSkge1xuICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFTk9FTlRcIiwgXCJybWRpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xuICAgIH1cbiAgfVxuICBpZighdGhpcy5pc19kaXIobmFtZSkpIHtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PVERJUlwiLCBcInJtZGlyXCIsIHRoaXMubm0obmFtZSkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lICsgXCI6IE5vdCBhIGRpcmVjdG9yeVwiKTtcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIGlmKG4ubWF0Y2gocikpIHtcbiAgICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVOT1RFTVBUWVwiLCBcInJtZGlyXCIsIHRoaXMubm0obmFtZSkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIjogRGlyZWN0b3J5IG5vdCBlbXB0eVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGVsZXRlIHRoaXMuY29udGVudFtuYW1lX3NsYXNoXTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSA9PSBcIlwiKT9cIlwiOih0aGlzLnNsYXNoKG5hbWUpKTtcbiAgaWYoIXRoaXMuZXhpc3RzKG5hbWUpKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xuICB9XG4gIGlmKCF0aGlzLmlzX2RpcihuYW1lKSkge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogTm90IGEgZGlyZWN0b3J5XCIpO1xuICB9XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKylcIik7XG4gIHZhciBzZWVuID0ge31cbiAgdmFyIGEgPSBbXTtcbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIHZhciBtID0gbi5tYXRjaChyKTtcbiAgICBpZihtICYmICFzZWVuW21bMV1dKSB7c2VlblttWzFdXSA9IHRydWU7IGEucHVzaChtWzFdKX1cbiAgfVxuICByZXR1cm4gYTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICBpZihuYW1lID09IFwiXCIpICByZXR1cm4gdHJ1ZTtcbiAgdmFyIG5hbWVfc2xhc2ggPSB0aGlzLnNsYXNoKG5hbWUpO1xuICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVfc2xhc2hdPzE6MDtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgb2sgPSB0aGlzLmNvbnRlbnRbbmFtZV0/dHJ1ZTpmYWxzZTtcbiAgZGVsZXRlIHRoaXMuY29udGVudFtuYW1lXTtcbiAgcmV0dXJuIG9rO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obmFtZSwgZikge1xuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICBpZiAodGhpcy5jb250ZW50W25hbWVdKSB7XG4gICAgaWYgKHRoaXMuaXNfZGlyKG5hbWUpKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBpcyBhIGRpcmVjdG9yeVwiKTtcbiAgICBpZiAoZi5jcmVhdGUgJiYgZi5leGNsKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuICAgIHZhciBmaWxlID0gdGhpcy5jb250ZW50W25hbWVdO1xuICAgIGlmKGYudHJ1bmNhdGUpIGZpbGUudHJ1bmNhdGUoKTtcbiAgICByZXR1cm4gZmlsZTtcbiAgfSBlbHNlIGlmIChmLmNyZWF0ZSkge1xuICAgIHRoaXMuY3JlYXRlX2Rpcl9pZl9uZWVkZWQobmFtZSk7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpO1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUgKHRoaXMubm0obmFtZSkpO1xuICB9XG59XG5cbk1sRmFrZURldmljZS5wcm90b3R5cGUucmVnaXN0ZXI9IGZ1bmN0aW9uIChuYW1lLGNvbnRlbnQpe1xuICB2YXIgZmlsZTtcbiAgaWYodGhpcy5jb250ZW50W25hbWVdKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuICBpZihjYW1sX2lzX21sX2J5dGVzKGNvbnRlbnQpKVxuICAgIGZpbGUgPSBuZXcgTWxGYWtlRmlsZShjb250ZW50KTtcbiAgaWYoY2FtbF9pc19tbF9zdHJpbmcoY29udGVudCkpXG4gICAgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGNvbnRlbnQpKTtcbiAgZWxzZSBpZihjb250ZW50IGluc3RhbmNlb2YgQXJyYXkpXG4gICAgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2ZfYXJyYXkoY29udGVudCkpO1xuICBlbHNlIGlmKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKVxuICAgIGZpbGUgPSBuZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX2pzYnl0ZXMoY29udGVudCkpO1xuICBlbHNlIGlmKGNvbnRlbnQudG9TdHJpbmcpIHtcbiAgICB2YXIgYnl0ZXMgPSBjYW1sX2J5dGVzX29mX3N0cmluZyhjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhjb250ZW50LnRvU3RyaW5nKCkpKTtcbiAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoYnl0ZXMpO1xuICB9XG4gIGlmKGZpbGUpe1xuICAgIHRoaXMuY3JlYXRlX2Rpcl9pZl9uZWVkZWQobmFtZSk7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gZmlsZTtcbiAgfVxuICBlbHNlIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IHJlZ2lzdGVyaW5nIGZpbGUgd2l0aCBpbnZhbGlkIGNvbnRlbnQgdHlwZVwiKTtcbn1cblxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sRmFrZURldmljZVxuXG4vL1Byb3ZpZGVzOiBNbEZha2VGaWxlXG4vL1JlcXVpcmVzOiBNbEZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX21sX2J5dGVzX2xlbmd0aCwgY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2JsaXRfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2dldFxuZnVuY3Rpb24gTWxGYWtlRmlsZShjb250ZW50KXtcbiAgdGhpcy5kYXRhID0gY29udGVudDtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlID0gbmV3IE1sRmlsZSAoKTtcbk1sRmFrZUZpbGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24obGVuKXtcbiAgdmFyIG9sZCA9IHRoaXMuZGF0YTtcbiAgdGhpcy5kYXRhID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVufDApO1xuICBjYW1sX2JsaXRfYnl0ZXMob2xkLCAwLCB0aGlzLmRhdGEsIDAsIGxlbik7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYW1sX21sX2J5dGVzX2xlbmd0aCh0aGlzLmRhdGEpO1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvZmZzZXQsYnVmLHBvcyxsZW4pe1xuICB2YXIgY2xlbiA9IHRoaXMubGVuZ3RoKCk7XG4gIGlmKG9mZnNldCArIGxlbiA+PSBjbGVuKSB7XG4gICAgdmFyIG5ld19zdHIgPSBjYW1sX2NyZWF0ZV9ieXRlcyhvZmZzZXQgKyBsZW4pO1xuICAgIHZhciBvbGRfZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB0aGlzLmRhdGEgPSBuZXdfc3RyO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhvbGRfZGF0YSwgMCwgdGhpcy5kYXRhLCAwLCBjbGVuKTtcbiAgfVxuICBjYW1sX2JsaXRfc3RyaW5nKGJ1ZiwgcG9zLCB0aGlzLmRhdGEsIG9mZnNldCwgbGVuKTtcbiAgcmV0dXJuIDBcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihvZmZzZXQsYnVmLHBvcyxsZW4pe1xuICB2YXIgY2xlbiA9IHRoaXMubGVuZ3RoKCk7XG4gIGNhbWxfYmxpdF9ieXRlcyh0aGlzLmRhdGEsIG9mZnNldCwgYnVmLCBwb3MsIGxlbik7XG4gIHJldHVybiAwXG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5yZWFkX29uZSA9IGZ1bmN0aW9uKG9mZnNldCl7XG4gIHJldHVybiBjYW1sX2J5dGVzX2dldCh0aGlzLmRhdGEsIG9mZnNldCk7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCl7XG5cbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxGYWtlRmlsZVxuIiwiLy8gSnNfb2Zfb2NhbWwgbGlicmFyeVxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEpzbGliXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfcHVyZV9leHByIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2pzX3B1cmVfZXhwciAoZikgeyByZXR1cm4gZigpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfc2V0IChtdXRhYmxlLCBjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3NldChvLGYsdikgeyBvW2ZdPXY7cmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2dldCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2dldChvLGYpIHsgcmV0dXJuIG9bZl07IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZGVsZXRlIChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZGVsZXRlKG8sZikgeyBkZWxldGUgb1tmXTsgcmV0dXJuIDB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaW5zdGFuY2VvZiAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19pbnN0YW5jZW9mKG8sYykgeyByZXR1cm4gKG8gaW5zdGFuY2VvZiBjKSA/IDEgOiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdHlwZW9mIChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdHlwZW9mKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9XG5cbi8vUHJvdmlkZXM6Y2FtbF90cmFtcG9saW5lXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmUocmVzKSB7XG4gIHZhciBjID0gMTtcbiAgd2hpbGUocmVzICYmIHJlcy5qb29fdHJhbXApe1xuICAgIHJlcyA9IHJlcy5qb29fdHJhbXAuYXBwbHkobnVsbCwgcmVzLmpvb19hcmdzKTtcbiAgICBjKys7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczpjYW1sX3RyYW1wb2xpbmVfcmV0dXJuXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmVfcmV0dXJuKGYsYXJncykge1xuICByZXR1cm4ge2pvb190cmFtcDpmLGpvb19hcmdzOmFyZ3N9O1xufVxuXG4vL1Byb3ZpZGVzOiBqc19wcmludF9zdGRvdXQgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBqc19wcmludF9zdGRvdXQocykge1xuICB2YXIgcyA9IGNhbWxfdXRmMTZfb2ZfdXRmOChzKTtcbiAgdmFyIGcgPSBnbG9iYWxUaGlzO1xuICBpZiAoZy5wcm9jZXNzICYmIGcucHJvY2Vzcy5zdGRvdXQgJiYgZy5wcm9jZXNzLnN0ZG91dC53cml0ZSkge1xuICAgIGcucHJvY2Vzcy5zdGRvdXQud3JpdGUocylcbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgb3V0cHV0IHRoZSBsYXN0IFxcbiBpZiBwcmVzZW50XG4gICAgLy8gYXMgY29uc29sZSBsb2dnaW5nIGRpc3BsYXkgYSBuZXdsaW5lIGF0IHRoZSBlbmRcbiAgICBpZihzLmNoYXJDb2RlQXQocy5sZW5ndGggLSAxKSA9PSAxMClcbiAgICAgIHMgPSBzLnN1YnN0cigwLHMubGVuZ3RoIC0gMSApO1xuICAgIHZhciB2ID0gZy5jb25zb2xlO1xuICAgIHYgICYmIHYubG9nICYmIHYubG9nKHMpO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBqc19wcmludF9zdGRlcnIgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBqc19wcmludF9zdGRlcnIocykge1xuICB2YXIgcyA9IGNhbWxfdXRmMTZfb2ZfdXRmOChzKTtcbiAgdmFyIGcgPSBnbG9iYWxUaGlzO1xuICBpZiAoZy5wcm9jZXNzICYmIGcucHJvY2Vzcy5zdGRvdXQgJiYgZy5wcm9jZXNzLnN0ZG91dC53cml0ZSkge1xuICAgIGcucHJvY2Vzcy5zdGRlcnIud3JpdGUocylcbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgb3V0cHV0IHRoZSBsYXN0IFxcbiBpZiBwcmVzZW50XG4gICAgLy8gYXMgY29uc29sZSBsb2dnaW5nIGRpc3BsYXkgYSBuZXdsaW5lIGF0IHRoZSBlbmRcbiAgICBpZihzLmNoYXJDb2RlQXQocy5sZW5ndGggLSAxKSA9PSAxMClcbiAgICAgIHMgPSBzLnN1YnN0cigwLHMubGVuZ3RoIC0gMSApO1xuICAgIHZhciB2ID0gZy5jb25zb2xlO1xuICAgIHYgJiYgdi5lcnJvciAmJiB2LmVycm9yKHMpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfanNcbmZ1bmN0aW9uIGNhbWxfaXNfanMoKSB7XG4gIHJldHVybiAxO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dyYXBfZXhjZXB0aW9uIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcsY2FtbF9uYW1lZF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50XG5mdW5jdGlvbiBjYW1sX3dyYXBfZXhjZXB0aW9uKGUpIHtcbiAgaWYoZSBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gZTtcbiAgLy9TdGFja19vdmVyZmxvdzogY2hyb21lLCBzYWZhcmlcbiAgaWYoZ2xvYmFsVGhpcy5SYW5nZUVycm9yXG4gICAgICYmIGUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLlJhbmdlRXJyb3JcbiAgICAgJiYgZS5tZXNzYWdlXG4gICAgICYmIGUubWVzc2FnZS5tYXRjaCgvbWF4aW11bSBjYWxsIHN0YWNrL2kpKVxuICAgIHJldHVybiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5TdGFja19vdmVyZmxvdyk7XG4gIC8vU3RhY2tfb3ZlcmZsb3c6IGZpcmVmb3hcbiAgaWYoZ2xvYmFsVGhpcy5JbnRlcm5hbEVycm9yXG4gICAgICYmIGUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkludGVybmFsRXJyb3JcbiAgICAgJiYgZS5tZXNzYWdlXG4gICAgICYmIGUubWVzc2FnZS5tYXRjaCgvdG9vIG11Y2ggcmVjdXJzaW9uL2kpKVxuICAgIHJldHVybiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5TdGFja19vdmVyZmxvdyk7XG4gIC8vV3JhcCBFcnJvciBpbiBKcy5FcnJvciBleGNlcHRpb25cbiAgaWYoZSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuRXJyb3IgJiYgY2FtbF9uYW1lZF92YWx1ZShcImpzRXJyb3JcIikpXG4gICAgcmV0dXJuIFswLGNhbWxfbmFtZWRfdmFsdWUoXCJqc0Vycm9yXCIpLGVdO1xuICAvL2ZhbGxiYWNrOiB3cmFwcGVkIGluIEZhaWx1cmVcbiAgcmV0dXJuIFswLGNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSxjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoU3RyaW5nKGUpKV07XG59XG5cbi8vIEV4cGVyaW1lbnRhbFxuLy9Qcm92aWRlczogY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlKGV4biwgZm9yY2UpIHtcbiAgLy9uZXZlciByZXJhaXNlIGZvciBjb25zdGFudCBleG5cbiAgaWYoIWV4bi5qc19lcnJvciB8fCBmb3JjZSB8fCBleG5bMF0gPT0gMjQ4KSBleG4uanNfZXJyb3IgPSBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcIkpzIGV4Y2VwdGlvbiBjb250YWluaW5nIGJhY2t0cmFjZVwiKTtcbiAgcmV0dXJuIGV4bjtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Vycm9yX29wdGlvbl9vZl9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfanNfZXJyb3Jfb3B0aW9uX29mX2V4Y2VwdGlvbihleG4pIHtcbiAgaWYoZXhuLmpzX2Vycm9yKSB7IHJldHVybiBbMCwgZXhuLmpzX2Vycm9yXTsgfVxuICByZXR1cm4gMDtcbn1cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9ib29sIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9ib29sKHgpIHsgcmV0dXJuICEheDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc190b19ib29sIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYm9vbCh4KSB7IHJldHVybiAreDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2Zsb2F0IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9mbG9hdCh4KSB7IHJldHVybiB4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2Zsb2F0IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdG9fZmxvYXQoeCkgeyByZXR1cm4geDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fYXJyYXkgbXV0YWJsZSAoc2hhbGxvdylcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9hcnJheShhKSB7XG4gIHJldHVybiBhLnNsaWNlKDEpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc190b19hcnJheSBtdXRhYmxlIChzaGFsbG93KVxuZnVuY3Rpb24gY2FtbF9qc190b19hcnJheShhKSB7XG4gIHZhciBsZW4gPSBhLmxlbmd0aDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKzEpO1xuICBiWzBdID0gMDtcbiAgZm9yKHZhciBpPTA7aTxsZW47aSsrKSBiW2krMV0gPSBhW2ldO1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9saXN0X29mX2pzX2FycmF5IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfbGlzdF9vZl9qc19hcnJheShhKXtcbiAgdmFyIGwgPSAwO1xuICBmb3IodmFyIGk9YS5sZW5ndGggLSAxOyBpPj0wOyBpLS0pe1xuICAgIHZhciBlID0gYVtpXTtcbiAgICBsID0gWzAsZSxsXTtcbiAgfVxuICByZXR1cm4gbFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xpc3RfdG9fanNfYXJyYXkgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9saXN0X3RvX2pzX2FycmF5KGwpe1xuICB2YXIgYSA9IFtdO1xuICBmb3IoOyBsICE9PSAwOyBsID0gbFsyXSkge1xuICAgIGEucHVzaChsWzFdKTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc192YXIgbXV0YWJsZSAoY29uc3QpXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX3Zhcih4KSB7XG4gIHZhciB4ID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoeCk7XG4gIC8vQ2hlY2tzIHRoYXQgeCBoYXMgdGhlIGZvcm0gaWRlbnRbLmlkZW50XSpcbiAgaWYoIXgubWF0Y2goL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSooXFwuW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKSokLykpe1xuICAgIGpzX3ByaW50X3N0ZGVycihcImNhbWxfanNfdmFyOiBcXFwiXCIgKyB4ICsgXCJcXFwiIGlzIG5vdCBhIHZhbGlkIEphdmFTY3JpcHQgdmFyaWFibGUuIGNvbnRpbnVpbmcgLi5cIik7XG4gICAgLy9nbG9iYWxUaGlzLmNvbnNvbGUuZXJyb3IoXCJKcy5VbnNhZmUuZXZhbF9zdHJpbmdcIilcbiAgfVxuICByZXR1cm4gZXZhbCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfY2FsbCAoY29uc3QsIG11dGFibGUsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfY2FsbChmLCBvLCBhcmdzKSB7IHJldHVybiBmLmFwcGx5KG8sIGNhbWxfanNfZnJvbV9hcnJheShhcmdzKSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnVuX2NhbGwgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX2Z1bl9jYWxsKGYsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDE6IHJldHVybiBmKCk7XG4gIGNhc2UgMjogcmV0dXJuIGYgKGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBmIChhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIGNhc2UgODogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdLGFbN10pO1xuICB9XG4gIHJldHVybiBmLmFwcGx5KG51bGwsIGNhbWxfanNfZnJvbV9hcnJheShhKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX21ldGhfY2FsbCAobXV0YWJsZSwgY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX21ldGhfY2FsbChvLCBmLCBhcmdzKSB7XG4gIHJldHVybiBvW2NhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGYpXS5hcHBseShvLCBjYW1sX2pzX2Zyb21fYXJyYXkoYXJncykpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19uZXcgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX25ldyhjLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAxOiByZXR1cm4gbmV3IGM7XG4gIGNhc2UgMjogcmV0dXJuIG5ldyBjIChhWzFdKTtcbiAgY2FzZSAzOiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdKTtcbiAgY2FzZSA2OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIGNhc2UgODogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSxhWzddKTtcbiAgfVxuICBmdW5jdGlvbiBGKCkgeyByZXR1cm4gYy5hcHBseSh0aGlzLCBjYW1sX2pzX2Zyb21fYXJyYXkoYSkpOyB9XG4gIEYucHJvdG90eXBlID0gYy5wcm90b3R5cGU7XG4gIHJldHVybiBuZXcgRjtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfb2pzX25ld19hcnIgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX29qc19uZXdfYXJyKGMsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDA6IHJldHVybiBuZXcgYztcbiAgY2FzZSAxOiByZXR1cm4gbmV3IGMgKGFbMF0pO1xuICBjYXNlIDI6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdKTtcbiAgY2FzZSAzOiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdKTtcbiAgY2FzZSA2OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICB9XG4gIGZ1bmN0aW9uIEYoKSB7IHJldHVybiBjLmFwcGx5KHRoaXMsIGEpOyB9XG4gIEYucHJvdG90eXBlID0gYy5wcm90b3R5cGU7XG4gIHJldHVybiBuZXcgRjtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFjayBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2soZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmKGxlbiA+IDApe1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgW3VuZGVmaW5lZF0pO1xuICAgIH1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBbYXJnc10pO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0KGFyaXR5LCBmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmKG4gPT0gYXJpdHkgJiYgZi5sZW5ndGggPT0gYXJpdHkpIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJpdHkpO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoLCBhcml0eSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpO1xuICB9O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2sgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2soZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbiArIDEpO1xuICAgIGFyZ3NbMF0gPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaSsxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLGFyZ3MpO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZixbdGhpcyxhcmdzXSk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0KGFyaXR5LCBmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJpdHkgKyAxKTtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCwgYXJpdHkpXG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpO1xuICB9O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZShmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpOyB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2VxdWFscyBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2VxdWFscyAoeCwgeSkgeyByZXR1cm4gKyh4ID09IHkpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXZhbF9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfZXZhbF9zdHJpbmcgKHMpIHtyZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V4cHIgKGNvbnN0KVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19leHByKHMpIHtcbiAganNfcHJpbnRfc3RkZXJyKFwiY2FtbF9qc19leHByOiBmYWxsYmFjayB0byBydW50aW1lIGV2YWx1YXRpb25cXG5cIik7XG4gIHJldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcHVyZV9qc19leHByIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyclxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcHVyZV9qc19leHByIChzKXtcbiAganNfcHJpbnRfc3RkZXJyKFwiY2FtbF9wdXJlX2pzX2V4cHI6IGZhbGxiYWNrIHRvIHJ1bnRpbWUgZXZhbHVhdGlvblxcblwiKTtcbiAgcmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO31cblxuLy9Qcm92aWRlczogY2FtbF9qc19vYmplY3QgKG9iamVjdF9saXRlcmFsKVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfb2JqZWN0IChhKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gYVtpXTtcbiAgICBvW2NhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHBbMV0pXSA9IHBbMl07XG4gIH1cbiAgcmV0dXJuIG87XG59XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWI6IGNvZGUgc3BlY2lmaWMgdG8gSnNfb2Zfb2NhbWxcblxuLy9Qcm92aWRlczogY2FtbF9qc19vbl9pZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19vbl9pZSAoKSB7XG4gIHZhciB1YSA9XG4gICAgICBnbG9iYWxUaGlzLm5hdmlnYXRvcj9nbG9iYWxUaGlzLm5hdmlnYXRvci51c2VyQWdlbnQ6XCJcIjtcbiAgcmV0dXJuIHVhLmluZGV4T2YoXCJNU0lFXCIpICE9IC0xICYmIHVhLmluZGV4T2YoXCJPcGVyYVwiKSAhPSAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2h0bWxfZXNjYXBlIGNvbnN0IChjb25zdClcbnZhciBjYW1sX2pzX3JlZ2V4cHMgPSB7IGFtcDovJi9nLCBsdDovPC9nLCBxdW90Oi9cXFwiL2csIGFsbDovWyY8XFxcIl0vIH07XG5mdW5jdGlvbiBjYW1sX2pzX2h0bWxfZXNjYXBlIChzKSB7XG4gIGlmICghY2FtbF9qc19yZWdleHBzLmFsbC50ZXN0KHMpKSByZXR1cm4gcztcbiAgcmV0dXJuIHMucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMuYW1wLCBcIiZhbXA7XCIpXG4gICAgLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLmx0LCBcIiZsdDtcIilcbiAgICAucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMucXVvdCwgXCImcXVvdDtcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaHRtbF9lbnRpdGllc1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VudGl0aWVzKHMpIHtcbiAgdmFyIGVudGl0eSA9IC9eJiM/WzAtOWEtekEtWl0rOyQvXG4gIGlmKHMubWF0Y2goZW50aXR5KSlcbiAge1xuICAgIHZhciBzdHIsIHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgdGVtcC5pbm5lckhUTUw9IHM7XG4gICAgc3RyPSB0ZW1wLnRleHRDb250ZW50IHx8IHRlbXAuaW5uZXJUZXh0O1xuICAgIHRlbXA9bnVsbDtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGVsc2Uge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJJbnZhbGlkIGVudGl0eSBcIiArIHMpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0X2NvbnNvbGUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfZ2V0X2NvbnNvbGUgKCkge1xuICB2YXIgYyA9IGdsb2JhbFRoaXMuY29uc29sZT9nbG9iYWxUaGlzLmNvbnNvbGU6e307XG4gIHZhciBtID0gW1wibG9nXCIsIFwiZGVidWdcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCIsIFwiYXNzZXJ0XCIsIFwiZGlyXCIsIFwiZGlyeG1sXCIsXG4gICAgICAgICAgIFwidHJhY2VcIiwgXCJncm91cFwiLCBcImdyb3VwQ29sbGFwc2VkXCIsIFwiZ3JvdXBFbmRcIiwgXCJ0aW1lXCIsIFwidGltZUVuZFwiXTtcbiAgZnVuY3Rpb24gZiAoKSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIGlmICghY1ttW2ldXSkgY1ttW2ldXT1mO1xuICByZXR1cm4gYztcbn1cblxuLy9Qcm92aWRlczogY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vV2Vha2RlZlxuZnVuY3Rpb24gY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGUodW5pdCl7XG4gIHZhciBnID0gZ2xvYmFsVGhpcztcbiAgaWYodHlwZW9mIGcuWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnLlhNTEh0dHBSZXF1ZXN0IH0gY2F0Y2ggKGUpIHsgfTtcbiAgfVxuICBpZih0eXBlb2YgZy5hY3RpdmVYT2JqZWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7IHJldHVybiBuZXcgZy5hY3RpdmVYT2JqZWN0KFwiTXN4bWwyLlhNTEhUVFBcIikgfSBjYXRjaChlKXsgfTtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGcuYWN0aXZlWE9iamVjdChcIk1zeG1sMy5YTUxIVFRQXCIpIH0gY2F0Y2goZSl7IH07XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnLmFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKSB9IGNhdGNoKGUpeyB9O1xuICB9XG4gIGNhbWxfZmFpbHdpdGgoXCJDYW5ub3QgY3JlYXRlIGEgWE1MSHR0cFJlcXVlc3RcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvbihleG4pIHtcbiAgaWYoZXhuLmpzX2Vycm9yKSB7IHJldHVybiBleG4uanNfZXJyb3I7IH1cbiAgcmV0dXJuIG51bGw7XG59XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdGl2ZSBDYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICovXG4vKiAgZW4gQXV0b21hdGlxdWUuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkICAgICovXG4vKiAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UsIHdpdGggICAgICovXG4vKiAgdGhlIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIGZpbGUgLi4vTElDRU5TRS4gICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qICRJZDogbGV4aW5nLmMgNjA0NSAyMDA0LTAxLTAxIDE2OjQyOjQzWiBkb2xpZ2V6ICQgKi9cblxuLyogVGhlIHRhYmxlLWRyaXZlbiBhdXRvbWF0b24gZm9yIGxleGVycyBnZW5lcmF0ZWQgYnkgY2FtbGxleC4gKi9cblxuLy9Qcm92aWRlczogY2FtbF9sZXhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbGV4X2FycmF5KHMpIHtcbiAgcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7XG4gIHZhciBsID0gcy5sZW5ndGggLyAyO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgYVtpXSA9IChzLmNoYXJDb2RlQXQoMiAqIGkpIHwgKHMuY2hhckNvZGVBdCgyICogaSArIDEpIDw8IDgpKSA8PCAxNiA+PiAxNjtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGV4X2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9sZXhfYXJyYXksIGNhbWxfYXJyYXlfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbGV4X2VuZ2luZSh0YmwsIHN0YXJ0X3N0YXRlLCBsZXhidWYpIHtcbiAgdmFyIGxleF9idWZmZXIgPSAyO1xuICB2YXIgbGV4X2J1ZmZlcl9sZW4gPSAzO1xuICB2YXIgbGV4X3N0YXJ0X3BvcyA9IDU7XG4gIHZhciBsZXhfY3Vycl9wb3MgPSA2O1xuICB2YXIgbGV4X2xhc3RfcG9zID0gNztcbiAgdmFyIGxleF9sYXN0X2FjdGlvbiA9IDg7XG4gIHZhciBsZXhfZW9mX3JlYWNoZWQgPSA5O1xuICB2YXIgbGV4X2Jhc2UgPSAxO1xuICB2YXIgbGV4X2JhY2t0cmsgPSAyO1xuICB2YXIgbGV4X2RlZmF1bHQgPSAzO1xuICB2YXIgbGV4X3RyYW5zID0gNDtcbiAgdmFyIGxleF9jaGVjayA9IDU7XG5cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHQpIHtcbiAgICB0YmwubGV4X2Jhc2UgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya10pO1xuICAgIHRibC5sZXhfY2hlY2sgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrXSk7XG4gICAgdGJsLmxleF90cmFucyA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNdKTtcbiAgICB0YmwubGV4X2RlZmF1bHQgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0XSk7XG4gIH1cblxuICB2YXIgYywgc3RhdGUgPSBzdGFydF9zdGF0ZTtcblxuICB2YXIgYnVmZmVyID0gY2FtbF9hcnJheV9vZl9ieXRlcyhsZXhidWZbbGV4X2J1ZmZlcl0pO1xuXG4gIGlmIChzdGF0ZSA+PSAwKSB7XG4gICAgLyogRmlyc3QgZW50cnkgKi9cbiAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfc3RhcnRfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgLyogUmVlbnRyeSBhZnRlciByZWZpbGwgKi9cbiAgICBzdGF0ZSA9IC1zdGF0ZSAtIDE7XG4gIH1cbiAgZm9yKDs7KSB7XG4gICAgLyogTG9va3VwIGJhc2UgYWRkcmVzcyBvciBhY3Rpb24gbnVtYmVyIGZvciBjdXJyZW50IHN0YXRlICovXG4gICAgdmFyIGJhc2UgPSB0YmwubGV4X2Jhc2Vbc3RhdGVdO1xuICAgIGlmIChiYXNlIDwgMCkgcmV0dXJuIC1iYXNlLTE7XG4gICAgLyogU2VlIGlmIGl0J3MgYSBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICB2YXIgYmFja3RyayA9IHRibC5sZXhfYmFja3Rya1tzdGF0ZV07XG4gICAgaWYgKGJhY2t0cmsgPj0gMCkge1xuICAgICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gYmFja3RyaztcbiAgICB9XG4gICAgLyogU2VlIGlmIHdlIG5lZWQgYSByZWZpbGwgKi9cbiAgICBpZiAobGV4YnVmW2xleF9jdXJyX3Bvc10gPj0gbGV4YnVmW2xleF9idWZmZXJfbGVuXSl7XG4gICAgICBpZiAobGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPT0gMClcbiAgICAgICAgcmV0dXJuIC1zdGF0ZSAtIDE7XG4gICAgICBlbHNlXG4gICAgICAgIGMgPSAyNTY7XG4gICAgfWVsc2V7XG4gICAgICAvKiBSZWFkIG5leHQgaW5wdXQgY2hhciAqL1xuICAgICAgYyA9IGJ1ZmZlcltsZXhidWZbbGV4X2N1cnJfcG9zXV07XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSArKztcbiAgICB9XG4gICAgLyogRGV0ZXJtaW5lIG5leHQgc3RhdGUgKi9cbiAgICBpZiAodGJsLmxleF9jaGVja1tiYXNlICsgY10gPT0gc3RhdGUpXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfdHJhbnNbYmFzZSArIGNdO1xuICAgIGVsc2VcbiAgICAgIHN0YXRlID0gdGJsLmxleF9kZWZhdWx0W3N0YXRlXTtcbiAgICAvKiBJZiBubyB0cmFuc2l0aW9uIG9uIHRoaXMgY2hhciwgcmV0dXJuIHRvIGxhc3QgYmFja3RyYWNrIHBvaW50ICovXG4gICAgaWYgKHN0YXRlIDwgMCkge1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gPSBsZXhidWZbbGV4X2xhc3RfcG9zXTtcbiAgICAgIGlmIChsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9PSAtMSlcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImxleGluZzogZW1wdHkgdG9rZW5cIik7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXTtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIEVyYXNlIHRoZSBFT0YgY29uZGl0aW9uIG9ubHkgaWYgdGhlIEVPRiBwc2V1ZG8tY2hhcmFjdGVyIHdhc1xuICAgICAgICAgY29uc3VtZWQgYnkgdGhlIGF1dG9tYXRvbiAoaS5lLiB0aGVyZSB3YXMgbm8gYmFja3RyYWNrIGFib3ZlKVxuICAgICAgKi9cbiAgICAgIGlmIChjID09IDI1NikgbGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPSAwO1xuICAgIH1cbiAgfVxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBOZXcgbGV4ZXIgZW5naW5lLCB3aXRoIG1lbW9yeSBvZiBwb3NpdGlvbnMgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV3X2xleF9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfbGV4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2xleF9ydW5fbWVtKHMsIGksIG1lbSwgY3Vycl9wb3MpIHtcbiAgZm9yICg7Oykge1xuICAgIHZhciBkc3QgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoZHN0ID09IDB4ZmYpIHJldHVybjtcbiAgICB2YXIgc3JjID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKHNyYyA9PSAweGZmKVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IGN1cnJfcG9zO1xuICAgIGVsc2VcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBtZW0gW3NyYyArIDFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbWxfbGV4X3J1bl90YWcocywgaSwgbWVtKSB7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZHN0ID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKGRzdCA9PSAweGZmKSByZXR1cm4gO1xuICAgIHZhciBzcmMgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoc3JjID09IDB4ZmYpXG4gICAgICBtZW0gW2RzdCArIDFdID0gLTE7XG4gICAgZWxzZVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IG1lbSBbc3JjICsgMV07XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FtbF9uZXdfbGV4X2VuZ2luZSh0YmwsIHN0YXJ0X3N0YXRlLCBsZXhidWYpIHtcbiAgdmFyIGxleF9idWZmZXIgPSAyO1xuICB2YXIgbGV4X2J1ZmZlcl9sZW4gPSAzO1xuICB2YXIgbGV4X3N0YXJ0X3BvcyA9IDU7XG4gIHZhciBsZXhfY3Vycl9wb3MgPSA2O1xuICB2YXIgbGV4X2xhc3RfcG9zID0gNztcbiAgdmFyIGxleF9sYXN0X2FjdGlvbiA9IDg7XG4gIHZhciBsZXhfZW9mX3JlYWNoZWQgPSA5O1xuICB2YXIgbGV4X21lbSA9IDEwO1xuICB2YXIgbGV4X2Jhc2UgPSAxO1xuICB2YXIgbGV4X2JhY2t0cmsgPSAyO1xuICB2YXIgbGV4X2RlZmF1bHQgPSAzO1xuICB2YXIgbGV4X3RyYW5zID0gNDtcbiAgdmFyIGxleF9jaGVjayA9IDU7XG4gIHZhciBsZXhfYmFzZV9jb2RlID0gNjtcbiAgdmFyIGxleF9iYWNrdHJrX2NvZGUgPSA3O1xuICB2YXIgbGV4X2RlZmF1bHRfY29kZSA9IDg7XG4gIHZhciBsZXhfdHJhbnNfY29kZSA9IDk7XG4gIHZhciBsZXhfY2hlY2tfY29kZSA9IDEwO1xuICB2YXIgbGV4X2NvZGUgPSAxMTtcblxuICBpZiAoIXRibC5sZXhfZGVmYXVsdCkge1xuICAgIHRibC5sZXhfYmFzZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VdKTtcbiAgICB0YmwubGV4X2JhY2t0cmsgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrXSk7XG4gICAgdGJsLmxleF9jaGVjayA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tdKTtcbiAgICB0YmwubGV4X3RyYW5zID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc10pO1xuICAgIHRibC5sZXhfZGVmYXVsdCA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRdKTtcbiAgfVxuICBpZiAoIXRibC5sZXhfZGVmYXVsdF9jb2RlKSB7XG4gICAgdGJsLmxleF9iYXNlX2NvZGUgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlX2NvZGVdKTtcbiAgICB0YmwubGV4X2JhY2t0cmtfY29kZSA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtfY29kZV0pO1xuICAgIHRibC5sZXhfY2hlY2tfY29kZSA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tfY29kZV0pO1xuICAgIHRibC5sZXhfdHJhbnNfY29kZSA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNfY29kZV0pO1xuICAgIHRibC5sZXhfZGVmYXVsdF9jb2RlID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF9jb2RlXSk7XG4gIH1cbiAgaWYgKHRibC5sZXhfY29kZSA9PSBudWxsKSB0YmwubGV4X2NvZGUgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHRibFtsZXhfY29kZV0pO1xuXG4gIHZhciBjLCBzdGF0ZSA9IHN0YXJ0X3N0YXRlO1xuXG4gIHZhciBidWZmZXIgPSBjYW1sX2FycmF5X29mX2J5dGVzKGxleGJ1ZltsZXhfYnVmZmVyXSk7XG5cbiAgaWYgKHN0YXRlID49IDApIHtcbiAgICAvKiBGaXJzdCBlbnRyeSAqL1xuICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9zdGFydF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICAvKiBSZWVudHJ5IGFmdGVyIHJlZmlsbCAqL1xuICAgIHN0YXRlID0gLXN0YXRlIC0gMTtcbiAgfVxuICBmb3IoOzspIHtcbiAgICAvKiBMb29rdXAgYmFzZSBhZGRyZXNzIG9yIGFjdGlvbiBudW1iZXIgZm9yIGN1cnJlbnQgc3RhdGUgKi9cbiAgICB2YXIgYmFzZSA9IHRibC5sZXhfYmFzZVtzdGF0ZV07XG4gICAgaWYgKGJhc2UgPCAwKSB7XG4gICAgICB2YXIgcGNfb2ZmID0gdGJsLmxleF9iYXNlX2NvZGVbc3RhdGVdO1xuICAgICAgY2FtbF9sZXhfcnVuX3RhZyh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dKTtcbiAgICAgIHJldHVybiAtYmFzZS0xO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgaXQncyBhIGJhY2t0cmFjayBwb2ludCAqL1xuICAgIHZhciBiYWNrdHJrID0gdGJsLmxleF9iYWNrdHJrW3N0YXRlXTtcbiAgICBpZiAoYmFja3RyayA+PSAwKSB7XG4gICAgICB2YXIgcGNfb2ZmID0gdGJsLmxleF9iYWNrdHJrX2NvZGVbc3RhdGVdO1xuICAgICAgY2FtbF9sZXhfcnVuX3RhZyh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dKTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IGJhY2t0cms7XG4gICAgfVxuICAgIC8qIFNlZSBpZiB3ZSBuZWVkIGEgcmVmaWxsICovXG4gICAgaWYgKGxleGJ1ZltsZXhfY3Vycl9wb3NdID49IGxleGJ1ZltsZXhfYnVmZmVyX2xlbl0pe1xuICAgICAgaWYgKGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID09IDApXG4gICAgICAgIHJldHVybiAtc3RhdGUgLSAxO1xuICAgICAgZWxzZVxuICAgICAgICBjID0gMjU2O1xuICAgIH1lbHNle1xuICAgICAgLyogUmVhZCBuZXh0IGlucHV0IGNoYXIgKi9cbiAgICAgIGMgPSBidWZmZXJbbGV4YnVmW2xleF9jdXJyX3Bvc11dO1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gKys7XG4gICAgfVxuICAgIC8qIERldGVybWluZSBuZXh0IHN0YXRlICovXG4gICAgdmFyIHBzdGF0ZSA9IHN0YXRlIDtcbiAgICBpZiAodGJsLmxleF9jaGVja1tiYXNlICsgY10gPT0gc3RhdGUpXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfdHJhbnNbYmFzZSArIGNdO1xuICAgIGVsc2VcbiAgICAgIHN0YXRlID0gdGJsLmxleF9kZWZhdWx0W3N0YXRlXTtcbiAgICAvKiBJZiBubyB0cmFuc2l0aW9uIG9uIHRoaXMgY2hhciwgcmV0dXJuIHRvIGxhc3QgYmFja3RyYWNrIHBvaW50ICovXG4gICAgaWYgKHN0YXRlIDwgMCkge1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gPSBsZXhidWZbbGV4X2xhc3RfcG9zXTtcbiAgICAgIGlmIChsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9PSAtMSlcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImxleGluZzogZW1wdHkgdG9rZW5cIik7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXTtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIElmIHNvbWUgdHJhbnNpdGlvbiwgZ2V0IGFuZCBwZXJmb3JtIG1lbW9yeSBtb3ZlcyAqL1xuICAgICAgdmFyIGJhc2VfY29kZSA9IHRibC5sZXhfYmFzZV9jb2RlW3BzdGF0ZV0sIHBjX29mZjtcbiAgICAgIGlmICh0YmwubGV4X2NoZWNrX2NvZGVbYmFzZV9jb2RlICsgY10gPT0gcHN0YXRlKVxuICAgICAgICBwY19vZmYgPSB0YmwubGV4X3RyYW5zX2NvZGVbYmFzZV9jb2RlICsgY107XG4gICAgICBlbHNlXG4gICAgICAgIHBjX29mZiA9IHRibC5sZXhfZGVmYXVsdF9jb2RlW3BzdGF0ZV07XG4gICAgICBpZiAocGNfb2ZmID4gMClcbiAgICAgICAgY2FtbF9sZXhfcnVuX21lbVxuICAgICAgKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0sIGxleGJ1ZltsZXhfY3Vycl9wb3NdKTtcbiAgICAgIC8qIEVyYXNlIHRoZSBFT0YgY29uZGl0aW9uIG9ubHkgaWYgdGhlIEVPRiBwc2V1ZG8tY2hhcmFjdGVyIHdhc1xuICAgICAgICAgY29uc3VtZWQgYnkgdGhlIGF1dG9tYXRvbiAoaS5lLiB0aGVyZSB3YXMgbm8gYmFja3RyYWNrIGFib3ZlKVxuICAgICAgKi9cbiAgICAgIGlmIChjID09IDI1NikgbGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPSAwO1xuICAgIH1cbiAgfVxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfY2hhblxuLy9SZXF1aXJlczogY2FtbF9tZDVfc3RyaW5nLCBjYW1sX3N0cmluZ19vZl9hcnJheSxjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWQ1X2NoYW4oY2hhbmlkLGxlbil7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgY2hhbl9sZW4gPSBjaGFuLmZpbGUubGVuZ3RoKCk7XG4gIGlmKGxlbjwwKSBsZW4gPSBjaGFuX2xlbiAtIGNoYW4ub2Zmc2V0O1xuICBpZihjaGFuLm9mZnNldCArIGxlbiA+IGNoYW5fbGVuKSBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIHZhciBidWYgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCxidWYsMCxsZW4pO1xuICByZXR1cm4gY2FtbF9tZDVfc3RyaW5nKGNhbWxfc3RyaW5nX29mX2J5dGVzKGJ1ZiksMCxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX21kNV9ieXRlc1xuZnVuY3Rpb24gY2FtbF9tZDVfc3RyaW5nKHMsIG9mcywgbGVuKSB7XG4gIHJldHVybiBjYW1sX21kNV9ieXRlcyhjYW1sX2J5dGVzX29mX3N0cmluZyhzKSxvZnMsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5LCBjYW1sX21sX2J5dGVzX2NvbnRlbnRcbnZhciBjYW1sX21kNV9ieXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gYWRkICh4LCB5KSB7IHJldHVybiAoeCArIHkpIHwgMDsgfVxuICBmdW5jdGlvbiB4eChxLGEsYix4LHMsdCkge1xuICAgIGEgPSBhZGQoYWRkKGEsIHEpLCBhZGQoeCwgdCkpO1xuICAgIHJldHVybiBhZGQoKGEgPDwgcykgfCAoYSA+Pj4gKDMyIC0gcykpLCBiKTtcbiAgfVxuICBmdW5jdGlvbiBmZihhLGIsYyxkLHgscyx0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBnZyhhLGIsYyxkLHgscyx0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBoaChhLGIsYyxkLHgscyx0KSB7IHJldHVybiB4eChiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpOyB9XG4gIGZ1bmN0aW9uIGlpKGEsYixjLGQseCxzLHQpIHsgcmV0dXJuIHh4KGMgXiAoYiB8ICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTsgfVxuXG4gIGZ1bmN0aW9uIG1kNShidWZmZXIsIGxlbmd0aCkge1xuICAgIHZhciBpID0gbGVuZ3RoO1xuICAgIGJ1ZmZlcltpID4+IDJdIHw9IDB4ODAgPDwgKDggKiAoaSAmIDMpKTtcbiAgICBmb3IgKGkgPSAoaSAmIH4weDMpICsgODsoaSAmIDB4M0YpIDwgNjAgO2kgKz0gNClcbiAgICAgIGJ1ZmZlclsoaSA+PiAyKSAtIDFdID0gMDtcbiAgICBidWZmZXJbKGkgPj4gMikgLTFdID0gbGVuZ3RoIDw8IDM7XG4gICAgYnVmZmVyW2kgPj4gMl0gPSAobGVuZ3RoID4+IDI5KSAmIDB4MUZGRkZGRkY7XG5cbiAgICB2YXIgdyA9IFsweDY3NDUyMzAxLCAweEVGQ0RBQjg5LCAweDk4QkFEQ0ZFLCAweDEwMzI1NDc2XTtcblxuICAgIGZvcihpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgIHZhciBhID0gd1swXSwgYiA9IHdbMV0sIGMgPSB3WzJdLCBkID0gd1szXTtcblxuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAwXSwgNywgMHhENzZBQTQ3OCk7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krIDFdLCAxMiwgMHhFOEM3Qjc1Nik7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krIDJdLCAxNywgMHgyNDIwNzBEQik7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krIDNdLCAyMiwgMHhDMUJEQ0VFRSk7XG4gICAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyW2krIDRdLCA3LCAweEY1N0MwRkFGKTtcbiAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbaSsgNV0sIDEyLCAweDQ3ODdDNjJBKTtcbiAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbaSsgNl0sIDE3LCAweEE4MzA0NjEzKTtcbiAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbaSsgN10sIDIyLCAweEZENDY5NTAxKTtcbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsgOF0sIDcsIDB4Njk4MDk4RDgpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA5XSwgMTIsIDB4OEI0NEY3QUYpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzEwXSwgMTcsIDB4RkZGRjVCQjEpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzExXSwgMjIsIDB4ODk1Q0Q3QkUpO1xuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKzEyXSwgNywgMHg2QjkwMTEyMik7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krMTNdLCAxMiwgMHhGRDk4NzE5Myk7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krMTRdLCAxNywgMHhBNjc5NDM4RSk7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krMTVdLCAyMiwgMHg0OUI0MDgyMSk7XG5cbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsgMV0sIDUsIDB4RjYxRTI1NjIpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA2XSwgOSwgMHhDMDQwQjM0MCk7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krMTFdLCAxNCwgMHgyNjVFNUE1MSk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krIDBdLCAyMCwgMHhFOUI2QzdBQSk7XG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krIDVdLCA1LCAweEQ2MkYxMDVEKTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsxMF0sIDksIDB4MDI0NDE0NTMpO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE1XSwgMTQsIDB4RDhBMUU2ODEpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyA0XSwgMjAsIDB4RTdEM0ZCQzgpO1xuICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA5XSwgNSwgMHgyMUUxQ0RFNik7XG4gICAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyW2krMTRdLCA5LCAweEMzMzcwN0Q2KTtcbiAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbaSsgM10sIDE0LCAweEY0RDUwRDg3KTtcbiAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbaSsgOF0sIDIwLCAweDQ1NUExNEVEKTtcbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsxM10sIDUsIDB4QTlFM0U5MDUpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAyXSwgOSwgMHhGQ0VGQTNGOCk7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krIDddLCAxNCwgMHg2NzZGMDJEOSk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krMTJdLCAyMCwgMHg4RDJBNEM4QSk7XG5cbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgNV0sIDQsIDB4RkZGQTM5NDIpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA4XSwgMTEsIDB4ODc3MUY2ODEpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzExXSwgMTYsIDB4NkQ5RDYxMjIpO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzE0XSwgMjMsIDB4RkRFNTM4MEMpO1xuICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAxXSwgNCwgMHhBNEJFRUE0NCk7XG4gICAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyW2krIDRdLCAxMSwgMHg0QkRFQ0ZBOSk7XG4gICAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyW2krIDddLCAxNiwgMHhGNkJCNEI2MCk7XG4gICAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyW2krMTBdLCAyMywgMHhCRUJGQkM3MCk7XG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krMTNdLCA0LCAweDI4OUI3RUM2KTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsgMF0sIDExLCAweEVBQTEyN0ZBKTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsgM10sIDE2LCAweEQ0RUYzMDg1KTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsgNl0sIDIzLCAweDA0ODgxRDA1KTtcbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgOV0sIDQsIDB4RDlENEQwMzkpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzEyXSwgMTEsIDB4RTZEQjk5RTUpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE1XSwgMTYsIDB4MUZBMjdDRjgpO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAyXSwgMjMsIDB4QzRBQzU2NjUpO1xuXG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krIDBdLCA2LCAweEY0MjkyMjQ0KTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsgN10sIDEwLCAweDQzMkFGRjk3KTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsxNF0sIDE1LCAweEFCOTQyM0E3KTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgNV0sIDIxLCAweEZDOTNBMDM5KTtcbiAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbaSsxMl0sIDYsIDB4NjU1QjU5QzMpO1xuICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAzXSwgMTAsIDB4OEYwQ0NDOTIpO1xuICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzEwXSwgMTUsIDB4RkZFRkY0N0QpO1xuICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAxXSwgMjEsIDB4ODU4NDVERDEpO1xuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA4XSwgNiwgMHg2RkE4N0U0Rik7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krMTVdLCAxMCwgMHhGRTJDRTZFMCk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krIDZdLCAxNSwgMHhBMzAxNDMxNCk7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krMTNdLCAyMSwgMHg0RTA4MTFBMSk7XG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krIDRdLCA2LCAweEY3NTM3RTgyKTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsxMV0sIDEwLCAweEJEM0FGMjM1KTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsgMl0sIDE1LCAweDJBRDdEMkJCKTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgOV0sIDIxLCAweEVCODZEMzkxKTtcblxuICAgICAgd1swXSA9IGFkZChhLCB3WzBdKTtcbiAgICAgIHdbMV0gPSBhZGQoYiwgd1sxXSk7XG4gICAgICB3WzJdID0gYWRkKGMsIHdbMl0pO1xuICAgICAgd1szXSA9IGFkZChkLCB3WzNdKTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IG5ldyBBcnJheSgxNik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICAgICAgdFtpICogNCArIGpdID0gKHdbaV0gPj4gKDggKiBqKSkgJiAweEZGO1xuICAgIHJldHVybiB0O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzLCBvZnMsIGxlbikge1xuICAgIC8vIEZJWDogbWF5YmUgd2Ugc2hvdWxkIHBlcmZvcm0gdGhlIGNvbXB1dGF0aW9uIGJ5IGNodW5rIG9mIDY0IGJ5dGVzXG4gICAgLy8gYXMgaW4gaHR0cDovL3d3dy5teWVyc2RhaWx5Lm9yZy9qb3NlcGgvamF2YXNjcmlwdC9tZDUuanNcbiAgICB2YXIgYnVmID0gW107XG4gICAgdmFyIGNvbnRlbnQgPSBjYW1sX21sX2J5dGVzX2NvbnRlbnQocyk7XG4gICAgaWYodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpe1xuICAgICAgdmFyIGIgPSBjb250ZW50O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgICAgdmFyIGogPSBpICsgb2ZzO1xuICAgICAgICBidWZbaT4+Ml0gPVxuICAgICAgICAgIGIuY2hhckNvZGVBdChqKSB8IChiLmNoYXJDb2RlQXQoaisxKSA8PCA4KSB8XG4gICAgICAgICAgKGIuY2hhckNvZGVBdChqKzIpIDw8IDE2KSB8IChiLmNoYXJDb2RlQXQoaiszKSA8PCAyNCk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBidWZbaT4+Ml0gfD0gYi5jaGFyQ29kZUF0KGkgKyBvZnMpIDw8ICg4ICogKGkgJiAzKSk7XG4gICAgfSBlbHNlIHsgLyogQVJSQVkgKi9cbiAgICAgIHZhciBhID0gY29udGVudDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICAgIHZhciBqID0gaSArIG9mcztcbiAgICAgICAgYnVmW2k+PjJdID0gYVtqXSB8IChhW2orMV0gPDwgOCkgfCAoYVtqKzJdIDw8IDE2KSB8IChhW2orM10gPDwgMjQpO1xuICAgICAgfVxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykgYnVmW2k+PjJdIHw9IGFbaSArIG9mc10gPDwgKDggKiAoaSAmIDMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KG1kNShidWYsIGxlbikpO1xuICB9XG59ICgpO1xuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBJb1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jbG9zZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9zeXNfY2xvc2UoZmQpIHtcbiAgZGVsZXRlIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2ZkXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RkX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX3N0ZF9vdXRwdXQoY2hhbmlkLHMpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIHN0ciA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocyk7XG4gIHZhciBzbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHN0cik7XG4gIGNoYW4uZmlsZS53cml0ZShjaGFuLm9mZnNldCwgc3RyLCAwLCBzbGVuKTtcbiAgY2hhbi5vZmZzZXQgKz0gc2xlbjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX29wZW5cbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX2dsb2JhbF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcyxNbEZha2VGaWxlXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnIsIGpzX3ByaW50X3N0ZG91dFxuLy9SZXF1aXJlczogY2FtbF9zdGRfb3V0cHV0XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChpZHgsb3V0cHV0LGZpbGUsZmxhZ3MpIHtcbiAgaWYoY2FtbF9nbG9iYWxfZGF0YS5mZHMgPT09IHVuZGVmaW5lZCkgY2FtbF9nbG9iYWxfZGF0YS5mZHMgPSBuZXcgQXJyYXkoKTtcbiAgZmxhZ3M9ZmxhZ3M/ZmxhZ3M6e307XG4gIHZhciBpbmZvID0ge307XG4gIGluZm8uZmlsZSA9IGZpbGU7XG4gIGluZm8ub2Zmc2V0ID0gZmxhZ3MuYXBwZW5kP2ZpbGUubGVuZ3RoKCk6MDtcbiAgaW5mby5mbGFncyA9IGZsYWdzO1xuICBpbmZvLm91dHB1dCA9IG91dHB1dDtcbiAgY2FtbF9nbG9iYWxfZGF0YS5mZHNbaWR4XSA9IGluZm87XG4gIGlmKCFjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4IHx8IGlkeCA+IGNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHgpXG4gICAgY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeCA9IGlkeDtcbiAgcmV0dXJuIGlkeDtcbn1cbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW4gKG5hbWUsIGZsYWdzLCBfcGVybXMpIHtcbiAgdmFyIGYgPSB7fTtcbiAgd2hpbGUoZmxhZ3Mpe1xuICAgIHN3aXRjaChmbGFnc1sxXSl7XG4gICAgY2FzZSAwOiBmLnJkb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAxOiBmLndyb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAyOiBmLmFwcGVuZCA9IDE7YnJlYWs7XG4gICAgY2FzZSAzOiBmLmNyZWF0ZSA9IDE7YnJlYWs7XG4gICAgY2FzZSA0OiBmLnRydW5jYXRlID0gMTticmVhaztcbiAgICBjYXNlIDU6IGYuZXhjbCA9IDE7IGJyZWFrO1xuICAgIGNhc2UgNjogZi5iaW5hcnkgPSAxO2JyZWFrO1xuICAgIGNhc2UgNzogZi50ZXh0ID0gMTticmVhaztcbiAgICBjYXNlIDg6IGYubm9uYmxvY2sgPSAxO2JyZWFrO1xuICAgIH1cbiAgICBmbGFncz1mbGFnc1syXTtcbiAgfVxuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3QsZik7XG4gIHZhciBpZHggPSBjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4P2NhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHg6MDtcbiAgcmV0dXJuIGNhbWxfc3lzX29wZW5faW50ZXJuYWwgKGlkeCsxLGNhbWxfc3RkX291dHB1dCxmaWxlLGYpO1xufVxuY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCgwLGNhbWxfc3RkX291dHB1dCwgbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpKTsgLy9zdGRpblxuY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCgxLGpzX3ByaW50X3N0ZG91dCwgbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpKTsgLy9zdGRvdXRcbmNhbWxfc3lzX29wZW5faW50ZXJuYWwoMixqc19wcmludF9zdGRlcnIsIG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKSk7IC8vc3RkZXJyXG5cblxuLy8gb2NhbWwgQ2hhbm5lbHNcblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX25hbWUoKSB7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbHNcbnZhciBjYW1sX21sX2NoYW5uZWxzID0gbmV3IEFycmF5KCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3QgKCkge1xuICB2YXIgbCA9IDA7XG4gIGZvcih2YXIgYyA9IDA7IGMgPCBjYW1sX21sX2NoYW5uZWxzLmxlbmd0aDsgYysrKXtcbiAgICBpZihjYW1sX21sX2NoYW5uZWxzW2NdICYmIGNhbWxfbWxfY2hhbm5lbHNbY10ub3BlbmVkICYmIGNhbWxfbWxfY2hhbm5lbHNbY10ub3V0KVxuICAgICAgbD1bMCxjYW1sX21sX2NoYW5uZWxzW2NdLmZkLGxdO1xuICB9XG4gIHJldHVybiBsO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9nbG9iYWxfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dCAoZmQpIHtcbiAgdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tmZF07XG4gIGlmKGRhdGEuZmxhZ3MucmRvbmx5KSBjYW1sX3JhaXNlX3N5c19lcnJvcihcImZkIFwiKyBmZCArIFwiIGlzIHJlYWRvbmx5XCIpO1xuICB2YXIgY2hhbm5lbCA9IHtcbiAgICBmaWxlOmRhdGEuZmlsZSxcbiAgICBvZmZzZXQ6ZGF0YS5vZmZzZXQsXG4gICAgZmQ6ZmQsXG4gICAgb3BlbmVkOnRydWUsXG4gICAgb3V0OnRydWUsXG4gICAgYnVmZmVyOlwiXCJcbiAgfTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFubmVsLmZkXT1jaGFubmVsO1xuICByZXR1cm4gY2hhbm5lbC5mZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5cbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsY2FtbF9zeXNfb3BlbixjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuLy9SZXF1aXJlczogZnNfbm9kZV9zdXBwb3J0ZWQsIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbiAoZmQpICB7XG4gIHZhciBkYXRhID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbZmRdO1xuICBpZihkYXRhLmZsYWdzLndyb25seSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJmZCBcIisgZmQgKyBcIiBpcyB3cml0ZW9ubHlcIik7XG4gIHZhciByZWZpbGwgPSBudWxsO1xuICBpZihmZCA9PSAwICYmIGZzX25vZGVfc3VwcG9ydGVkKCkpe1xuICAgIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gICAgcmVmaWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGZzLnJlYWRGaWxlU3luYygwLCAndXRmOCcpKX07XG4gIH1cbiAgdmFyIGNoYW5uZWwgPSB7XG4gICAgZmlsZTpkYXRhLmZpbGUsXG4gICAgb2Zmc2V0OmRhdGEub2Zmc2V0LFxuICAgIGZkOmZkLFxuICAgIG9wZW5lZDp0cnVlLFxuICAgIG91dDogZmFsc2UsXG4gICAgcmVmaWxsOnJlZmlsbFxuICB9O1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5uZWwuZmRdPWNoYW5uZWw7XG4gIHJldHVybiBjaGFubmVsLmZkO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX2NoYW5uZWxfZGVzY3JpcHRvcihjaGFuaWQpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNoYW4uZmQ7XG59XG5cbi8vUHJvdmlkZXM6IHdpbl9maWxlZGVzY3Jfb2ZfY2hhbm5lbFxuLy9SZXF1aXJlczogY2FtbF9jaGFubmVsX2Rlc2NyaXB0b3JcbnZhciB3aW5fZmlsZWRlc2NyX29mX2NoYW5uZWwgPSBjYW1sX2NoYW5uZWxfZGVzY3JpcHRvclxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9iaW5hcnlfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZXRfYmluYXJ5X21vZGUoY2hhbmlkLG1vZGUpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXTtcbiAgZGF0YS5mbGFncy50ZXh0ID0gIW1vZGVcbiAgZGF0YS5mbGFncy5iaW5hcnkgPSBtb2RlXG4gIHJldHVybiAwO1xufVxuXG4vL0lucHV0IGZyb20gaW5fY2hhbm5lbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2Nsb3NlX2NoYW5uZWxcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsIGNhbWxfbWxfY2hhbm5lbHNcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX2Nsb3NlXG5mdW5jdGlvbiBjYW1sX21sX2Nsb3NlX2NoYW5uZWwgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICBjaGFuLm9wZW5lZCA9IGZhbHNlO1xuICBjaGFuLmZpbGUuY2xvc2UoKTtcbiAgY2FtbF9zeXNfY2xvc2UoY2hhbi5mZClcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2NoYW5uZWxfc2l6ZShjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHJldHVybiBjaGFuLmZpbGUubGVuZ3RoKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0KGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoY2hhbi5maWxlLmxlbmd0aCAoKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX291dHB1dChjaGFuaWQsZikge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF0ub3V0cHV0ID0gZjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbChjaGFuaWQsZikge1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ucmVmaWxsID0gZjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfbWxfcmVmaWxsX2lucHV0IChjaGFuKSB7XG4gIHZhciBzdHIgPSBjaGFuLnJlZmlsbCgpO1xuICB2YXIgc3RyX2xlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzdHIpO1xuICBpZiAoc3RyX2xlbiA9PSAwKSBjaGFuLnJlZmlsbCA9IG51bGw7XG4gIGNoYW4uZmlsZS53cml0ZShjaGFuLmZpbGUubGVuZ3RoKCksIHN0ciwgMCwgc3RyX2xlbik7XG4gIHJldHVybiBzdHJfbGVuO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsID09IG51bGwpIHJldHVybjtcbiAgaWYgKGNoYW4uZmlsZS5sZW5ndGgoKSAhPSBjaGFuLm9mZnNldCkgcmV0dXJuO1xuICBjYW1sX21sX3JlZmlsbF9pbnB1dCAoY2hhbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0IChjaGFuaWQsIHMsIGksIGwpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBsMiA9IGNoYW4uZmlsZS5sZW5ndGgoKSAtIGNoYW4ub2Zmc2V0O1xuICBpZiAobDIgPT0gMCAmJiBjaGFuLnJlZmlsbCAhPSBudWxsKSBsMiA9IGNhbWxfbWxfcmVmaWxsX2lucHV0KGNoYW4pO1xuICBpZiAobDIgPCBsKSBsID0gbDI7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LCBzLCBpLCBsKTtcbiAgY2hhbi5vZmZzZXQgKz0gbDtcbiAgcmV0dXJuIGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcywgY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWUgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcblxuICB2YXIgYnVmID0gY2FtbF9jcmVhdGVfYnl0ZXMoOCk7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LGJ1ZiwwLDgpO1xuXG4gIC8vIEhlYWRlciBpcyAyMCBieXRlc1xuICB2YXIgbGVuID0gY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSAoYnVmLCAwKSArIDIwO1xuXG4gIHZhciBidWYgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCxidWYsMCxsZW4pO1xuXG4gIHZhciBvZmZzZXQgPSBbMF07XG4gIHZhciByZXMgPSBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMoYnVmLCBvZmZzZXQpO1xuICBjaGFuLm9mZnNldCA9IGNoYW4ub2Zmc2V0ICsgb2Zmc2V0WzBdO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9jaGFyIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dChjaGFuaWQpO1xuICBpZiAoY2hhbi5vZmZzZXQgPj0gY2hhbi5maWxlLmxlbmd0aCgpKVxuICAgIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgdmFyIHJlcyA9IGNoYW4uZmlsZS5yZWFkX29uZShjaGFuLm9mZnNldCk7XG4gIGNoYW4ub2Zmc2V0Kys7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9pbnQgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGZpbGUgPSBjaGFuLmZpbGU7XG4gIHdoaWxlICgoY2hhbi5vZmZzZXQgKyAzKSA+PSBmaWxlLmxlbmd0aCgpKSB7XG4gICAgdmFyIGwgPSBjYW1sX21sX3JlZmlsbF9pbnB1dChjaGFuKTtcbiAgICBpZiAobCA9PSAwKSBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIH1cbiAgdmFyIG8gPSBjaGFuLm9mZnNldDtcbiAgdmFyIHIgPShmaWxlLnJlYWRfb25lKG8gICkgPDwgMjQpXG4gICAgICB8ICAoZmlsZS5yZWFkX29uZShvKzEpIDw8IDE2KVxuICAgICAgfCAgKGZpbGUucmVhZF9vbmUobysyKSA8PCA4KVxuICAgICAgfCAgKGZpbGUucmVhZF9vbmUobyszKSk7XG4gIGNoYW4ub2Zmc2V0Kz00O1xuICByZXR1cm4gcjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX2luXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX2luKGNoYW5pZCxwb3Mpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsICE9IG51bGwpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiSWxsZWdhbCBzZWVrXCIpO1xuICBjaGFuLm9mZnNldCA9IHBvcztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19pbl82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19mbG9hdCwgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19pbl82NChjaGFuaWQscG9zKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmIChjaGFuLnJlZmlsbCAhPSBudWxsKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIklsbGVnYWwgc2Vla1wiKTtcbiAgY2hhbi5vZmZzZXQgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19pblxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9wb3NfaW4oY2hhbmlkKSB7cmV0dXJuIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXR9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX2luXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19pbl82NChjaGFuaWQpIHtyZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdChjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0KX1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmVcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmUoY2hhbmlkKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dChjaGFuaWQpO1xuICB2YXIgcCA9IGNoYW4ub2Zmc2V0O1xuICB2YXIgbGVuID0gY2hhbi5maWxlLmxlbmd0aCgpO1xuICBpZihwID49IGxlbikgeyByZXR1cm4gMDt9XG4gIHdoaWxlKHRydWUpIHtcbiAgICBpZihwID49IGxlbikgcmV0dXJuIC0gKHAgLSBjaGFuLm9mZnNldCk7XG4gICAgaWYoY2hhbi5maWxlLnJlYWRfb25lKHApID09IDEwKSByZXR1cm4gcCAtIGNoYW4ub2Zmc2V0ICsgMTtcbiAgICBwKys7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9mbHVzaFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYoISBjaGFuLm9wZW5lZCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJDYW5ub3QgZmx1c2ggYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgaWYoIWNoYW4uYnVmZmVyIHx8IGNoYW4uYnVmZmVyID09IFwiXCIpIHJldHVybiAwO1xuICBpZihjaGFuLmZkXG4gICAgICYmIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdXG4gICAgICYmIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdLm91dHB1dCkge1xuICAgIHZhciBvdXRwdXQgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXS5vdXRwdXQ7XG4gICAgc3dpdGNoKG91dHB1dC5sZW5ndGgpe1xuICAgIGNhc2UgMjogb3V0cHV0KGNoYW5pZCxjaGFuLmJ1ZmZlcik7YnJlYWs7XG4gICAgZGVmYXVsdDogb3V0cHV0KGNoYW4uYnVmZmVyKVxuICAgIH07XG4gIH1cbiAgY2hhbi5idWZmZXIgPSBcIlwiO1xuICByZXR1cm4gMDtcbn1cblxuLy9vdXRwdXQgdG8gb3V0X2NoYW5uZWxcblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsY2FtbF9tbF9ieXRlc19sZW5ndGhcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZighIGNoYW4ub3BlbmVkKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIkNhbm5vdCBvdXRwdXQgdG8gYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgdmFyIGJ5dGVzO1xuICBpZihvZmZzZXQgPT0gMCAmJiBjYW1sX21sX2J5dGVzX2xlbmd0aChidWZmZXIpID09IGxlbilcbiAgICBieXRlcyA9IGJ1ZmZlcjtcbiAgZWxzZSB7XG4gICAgYnl0ZXMgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhidWZmZXIsb2Zmc2V0LGJ5dGVzLDAsbGVuKTtcbiAgfVxuICB2YXIgc3RyaW5nID0gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMoYnl0ZXMpO1xuICB2YXIganNzdHJpbmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHN0cmluZyk7XG4gIHZhciBpZCA9IGpzc3RyaW5nLmxhc3RJbmRleE9mKFwiXFxuXCIpO1xuICBpZihpZCA8IDApXG4gICAgY2hhbi5idWZmZXIrPWpzc3RyaW5nO1xuICBlbHNlIHtcbiAgICBjaGFuLmJ1ZmZlcis9anNzdHJpbmcuc3Vic3RyKDAsaWQrMSk7XG4gICAgY2FtbF9tbF9mbHVzaCAoY2hhbmlkKTtcbiAgICBjaGFuLmJ1ZmZlciArPSBqc3N0cmluZy5zdWJzdHIoaWQrMSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dF9ieXRlcywgY2FtbF9ieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxidWZmZXIsb2Zmc2V0LGxlbil7XG4gIHJldHVybiBjYW1sX21sX291dHB1dF9ieXRlcyhjaGFuaWQsY2FtbF9ieXRlc19vZl9zdHJpbmcoYnVmZmVyKSxvZmZzZXQsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfY2hhclxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2NoYXIgKGNoYW5pZCxjKSB7XG4gIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCwxKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcsIGNhbWxfbWxfb3V0cHV0LGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWUgKGNoYW5pZCx2LGZsYWdzKSB7XG4gIHZhciBzID0gY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nKHYsIGZsYWdzKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCxjYW1sX21sX3N0cmluZ19sZW5ndGgocykpO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfb3V0KGNoYW5pZCxwb3Mpe1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQgPSBwb3M7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfb3V0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0LCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfb3V0XzY0KGNoYW5pZCxwb3Mpe1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dChjaGFuaWQpIHtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICByZXR1cm4gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dF82NChjaGFuaWQpIHtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdCAoY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2ludFxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9pbnQgKGNoYW5pZCxpKSB7XG4gIHZhciBhcnIgPSBbKGk+PjI0KSAmIDB4RkYsKGk+PjE2KSAmIDB4RkYsKGk+PjgpICYgMHhGRixpICYgMHhGRiBdO1xuICB2YXIgcyA9IGNhbWxfc3RyaW5nX29mX2FycmF5KGFycik7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxzLDAsNCk7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaXNfYnVmZmVyZWRcbmZ1bmN0aW9uIGNhbWxfbWxfaXNfYnVmZmVyZWQoYykgeyByZXR1cm4gMSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2J1ZmZlcmVkXG5mdW5jdGlvbiBjYW1sX21sX3NldF9idWZmZXJlZChjLHYpIHsgcmV0dXJuIDAgfVxuIiwiLy9Qcm92aWRlczogaW5pdGlhbGl6ZV9uYXRcbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogc2VyaWFsaXplX25hdCwgZGVzZXJpYWxpemVfbmF0LCBjYW1sX2hhc2hfbmF0XG5mdW5jdGlvbiBpbml0aWFsaXplX25hdCgpIHtcbiAgY2FtbF9jdXN0b21fb3BzW1wiX25hdFwiXSA9XG4gICAgeyBkZXNlcmlhbGl6ZSA6IGRlc2VyaWFsaXplX25hdCxcbiAgICAgIHNlcmlhbGl6ZSA6IHNlcmlhbGl6ZV9uYXQsXG4gICAgICBoYXNoIDogY2FtbF9oYXNoX25hdFxuICAgIH1cbn1cblxuLy9Qcm92aWRlczogTWxOYXRcbmZ1bmN0aW9uIE1sTmF0KHgpe1xuICB0aGlzLmRhdGEgPSBuZXcgZ2xvYmFsVGhpcy5JbnQzMkFycmF5KHgpO1xuICAvLyBsZW5ndGhfbmF0IGlzbid0IGV4dGVybmFsLCBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhlIE9iai5zaXplXG4gIC8vIHdvcmsgb3V0IHJpZ2h0LiBUaGUgKzIgdG8gYXJyYXkgbGVuZ3RoIHNlZW1zIHRvIHdvcmsuXG4gIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aCArIDJcbn1cblxuTWxOYXQucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gXCJfbmF0XCI7XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9uYXRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50LCBudW1fZGlnaXRzX25hdFxuZnVuY3Rpb24gY2FtbF9oYXNoX25hdCh4KSB7XG4gIHZhciBsZW4gPSBudW1fZGlnaXRzX25hdCh4LCAwLCB4LmRhdGEubGVuZ3RoKTtcbiAgdmFyIGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHguZGF0YVtpXSk7XG4gIH1cbiAgcmV0dXJuIGg7XG59XG5cblxuLy9Qcm92aWRlczogbmF0X29mX2FycmF5XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gbmF0X29mX2FycmF5KGwpe1xuICByZXR1cm4gbmV3IE1sTmF0KGwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjcmVhdGVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gY3JlYXRlX25hdChzaXplKSB7XG4gIHZhciBhcnIgPSBuZXcgTWxOYXQoc2l6ZSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBhcnIuZGF0YVtpXSA9IC0xO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbi8vUHJvdmlkZXM6IHNldF90b196ZXJvX25hdFxuZnVuY3Rpb24gc2V0X3RvX3plcm9fbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gMDtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmxpdF9uYXRcbmZ1bmN0aW9uIGJsaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IG5hdDIuZGF0YVtvZnMyK2ldO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0XG5mdW5jdGlvbiBzZXRfZGlnaXRfbmF0KG5hdCwgb2ZzLCBkaWdpdCkge1xuICBuYXQuZGF0YVtvZnNdID0gZGlnaXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBudGhfZGlnaXRfbmF0XG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0KG5hdCwgb2ZzKSB7XG4gIHJldHVybiBuYXQuZGF0YVtvZnNdO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0X25hdGl2ZVxuZnVuY3Rpb24gc2V0X2RpZ2l0X25hdF9uYXRpdmUobmF0LCBvZnMsIGRpZ2l0KSB7XG4gIG5hdC5kYXRhW29mc10gPSBkaWdpdDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG50aF9kaWdpdF9uYXRfbmF0aXZlXG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0X25hdGl2ZShuYXQsIG9mcykge1xuICByZXR1cm4gbmF0LmRhdGFbb2ZzXTtcbn1cblxuLy9Qcm92aWRlczogbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIG51bV9kaWdpdHNfbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZihuYXQuZGF0YVtvZnMraV0gIT0gMCkgcmV0dXJuIGkrMTtcbiAgfVxuICByZXR1cm4gMTsgLy8gMCBjb3VudHMgYXMgMSBkaWdpdFxufVxuXG4vL1Byb3ZpZGVzOiBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXRcbmZ1bmN0aW9uIG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdChuYXQsIG9mcykge1xuICB2YXIgYSA9IG5hdC5kYXRhW29mc107XG4gIHZhciBiID0gMDtcbiAgaWYoYSAmIDB4RkZGRjAwMDApIHsgYiArPTE2OyBhID4+Pj0xNjsgfVxuICBpZihhICYgMHhGRjAwKSAgICAgeyBiICs9IDg7IGEgPj4+PSA4OyB9XG4gIGlmKGEgJiAweEYwKSAgICAgICB7IGIgKz0gNDsgYSA+Pj49IDQ7IH1cbiAgaWYoYSAmIDEyKSAgICAgICAgIHsgYiArPSAyOyBhID4+Pj0gMjsgfVxuICBpZihhICYgMikgICAgICAgICAgeyBiICs9IDE7IGEgPj4+PSAxOyB9XG4gIGlmKGEgJiAxKSAgICAgICAgICB7IGIgKz0gMTsgfVxuICByZXR1cm4gMzIgLSBiO1xufVxuXG4vL1Byb3ZpZGVzOiBpc19kaWdpdF9pbnRcbmZ1bmN0aW9uIGlzX2RpZ2l0X2ludChuYXQsIG9mcykge1xuICBpZiAobmF0LmRhdGFbb2ZzXSA+PSAwKSByZXR1cm4gMVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfemVyb1xuZnVuY3Rpb24gaXNfZGlnaXRfemVybyhuYXQsIG9mcykge1xuICBpZihuYXQuZGF0YVtvZnNdID09IDApIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfb2RkXG5mdW5jdGlvbiBpc19kaWdpdF9vZGQobmF0LCBvZnMpIHtcbiAgaWYobmF0LmRhdGFbb2ZzXSAmIDEpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaW5jcl9uYXRcbmZ1bmN0aW9uIGluY3JfbmF0KG5hdCwgb2ZzLCBsZW4sIGNhcnJ5X2luKSB7XG4gIHZhciBjYXJyeSA9IGNhcnJ5X2luO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQuZGF0YVtvZnMraV0gPj4+IDApICsgY2Fycnk7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gKHggfCAwKTtcbiAgICBpZih4ID09ICh4ID4+PiAwKSkge1xuICAgICAgY2FycnkgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcnJ5ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhcnJ5O1xufVxuXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IGFkZF9uYXRcbi8vUmVxdWlyZXM6IGluY3JfbmF0XG5mdW5jdGlvbiBhZGRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIGNhcnJ5X2luKSB7XG4gIHZhciBjYXJyeSA9IGNhcnJ5X2luO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApICsgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSArIGNhcnJ5O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geFxuICAgIGlmKHggPT0gKHggPj4+IDApKSB7XG4gICAgICBjYXJyeSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcnJ5ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluY3JfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCBjYXJyeSk7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBsZW1lbnRfbmF0XG5mdW5jdGlvbiBjb21wbGVtZW50X25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdC5kYXRhW29mcytpXSA9ICgtMSA+Pj4gMCkgLSAobmF0LmRhdGFbb2ZzK2ldID4+PiAwKTtcbiAgfVxufVxuXG4vLyBvY2FtbCBmbGlwcyBjYXJyeV9pblxuLy9Qcm92aWRlczogZGVjcl9uYXRcbmZ1bmN0aW9uIGRlY3JfbmF0KG5hdCwgb2ZzLCBsZW4sIGNhcnJ5X2luKSB7XG4gIHZhciBib3Jyb3cgPSAoY2FycnlfaW4gPT0gMSkgPyAwIDogMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0LmRhdGFbb2ZzK2ldID4+PjApIC0gYm9ycm93O1xuICAgIG5hdC5kYXRhW29mcytpXSA9IHg7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgYm9ycm93ID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3Jyb3cgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKGJvcnJvdyA9PSAxKSA/IDAgOiAxO1xufVxuXG4vLyBvY2FtbCBmbGlwcyBjYXJyeV9pblxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBzdWJfbmF0XG4vL1JlcXVpcmVzOiBkZWNyX25hdFxuZnVuY3Rpb24gc3ViX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBjYXJyeV9pbikge1xuICB2YXIgYm9ycm93ID0gKGNhcnJ5X2luID09IDEpID8gMCA6IDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4yOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgLSAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApIC0gYm9ycm93O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geDtcbiAgICBpZiAoeCA+PSAwKSB7XG4gICAgICBib3Jyb3cgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3Jyb3cgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVjcl9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIChib3Jyb3c9PTEpPzA6MSk7XG59XG5cbi8vIG5hdDEgKz0gbmF0MiAqIG5hdDNbb2ZzM11cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogbXVsdF9kaWdpdF9uYXRcbi8vUmVxdWlyZXM6IGFkZF9uYXQsIG5hdF9vZl9hcnJheVxuZnVuY3Rpb24gbXVsdF9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMykge1xuICB2YXIgY2FycnkgPSAwO1xuICB2YXIgYSA9IChuYXQzLmRhdGFbb2ZzM10gPj4+IDApO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHgxID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSArIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKiAoYSAmIDB4MDAwMEZGRkYpICsgY2Fycnk7XG4gICAgdmFyIHgyID0gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAqIChhID4+PiAxNik7XG4gICAgY2FycnkgPSBNYXRoLmZsb29yKHgyLzY1NTM2KTtcbiAgICB2YXIgeDMgPSB4MSArICh4MiAlIDY1NTM2KSAqIDY1NTM2O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geDM7XG4gICAgY2FycnkgKz0gTWF0aC5mbG9vcih4My80Mjk0OTY3Mjk2KTtcbiAgfVxuXG4gIGlmKGxlbjIgPCBsZW4xICYmIGNhcnJ5KSB7XG4gICAgcmV0dXJuIGFkZF9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIG5hdF9vZl9hcnJheShbY2FycnldKSwgMCwgMSwgMCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNhcnJ5O1xuICB9XG59XG5cbi8vIG5hdDEgKz0gbmF0MiAqIG5hdDNcbi8vIGxlbjEgPj0gbGVuMiArIGxlbjMuXG4vL1Byb3ZpZGVzOiBtdWx0X25hdFxuLy9SZXF1aXJlczogbXVsdF9kaWdpdF9uYXRcbmZ1bmN0aW9uIG11bHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMsIGxlbjMpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjM7IGkrKykge1xuICAgIGNhcnJ5ICs9IG11bHRfZGlnaXRfbmF0KG5hdDEsIG9mczEraSwgbGVuMS1pLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzK2kpO1xuICB9XG4gIHJldHVybiBjYXJyeTtcbn1cblxuLy8gbmF0MSA9IDIgKiBuYXQxICsgbmF0MiAqIG5hdDJcbi8vIGxlbjEgPj0gMiAqIGxlbjJcbi8vUHJvdmlkZXM6IHNxdWFyZV9uYXRcbi8vUmVxdWlyZXM6IG11bHRfbmF0LCBhZGRfbmF0XG5mdW5jdGlvbiBzcXVhcmVfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgY2FycnkgKz0gYWRkX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQxLCBvZnMxLCBsZW4xLCAwKTtcbiAgY2FycnkgKz0gbXVsdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Miwgb2ZzMiwgbGVuMik7XG4gIHJldHVybiBjYXJyeTtcbn1cblxuXG4vLyAwIDw9IHNoaWZ0IDwgMzJcbi8vUHJvdmlkZXM6IHNoaWZ0X2xlZnRfbmF0XG5mdW5jdGlvbiBzaGlmdF9sZWZ0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBuYml0cykge1xuICBpZihuYml0cyA9PSAwKSB7XG4gICAgbmF0Mi5kYXRhW29mczJdID0gMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgd3JhcCA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4xOyBpKyspIHtcbiAgICB2YXIgYSA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCk7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSAoYSA8PCBuYml0cykgfCB3cmFwO1xuICAgIHdyYXAgPSBhID4+PiAoMzIgLSBuYml0cyk7XG4gIH1cbiAgbmF0Mi5kYXRhW29mczJdID0gd3JhcDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIEFzc3VtaW5nIGMgPiBhLCByZXR1cm5zIFtxdW90aWVudCwgcmVtYWluZGVyXSBvZiAoYTw8MzIgKyBiKS9jXG4vL1Byb3ZpZGVzOiBkaXZfaGVscGVyXG5mdW5jdGlvbiBkaXZfaGVscGVyKGEsIGIsIGMpIHtcbiAgdmFyIHggPSBhICogNjU1MzYgKyAoYj4+PjE2KTtcbiAgdmFyIHkgPSBNYXRoLmZsb29yKHgvYykgKiA2NTUzNjtcbiAgdmFyIHogPSAoeCAlIGMpICogNjU1MzY7XG4gIHZhciB3ID0geiArIChiICYgMHgwMDAwRkZGRik7XG4gIHJldHVybiBbeSArIE1hdGguZmxvb3Iody9jKSwgdyAlIGNdO1xufVxuXG4vLyBuYXQxW29mczErbGVuXSA8IG5hdDJbb2ZzMl1cbi8vUHJvdmlkZXM6IGRpdl9kaWdpdF9uYXRcbi8vUmVxdWlyZXM6IGRpdl9oZWxwZXJcbmZ1bmN0aW9uIGRpdl9kaWdpdF9uYXQobmF0cSwgb2ZzcSwgbmF0ciwgb2ZzciwgbmF0MSwgb2ZzMSwgbGVuLCBuYXQyLCBvZnMyKSB7XG4gIHZhciByZW0gPSAobmF0MS5kYXRhW29mczErbGVuLTFdID4+PjApO1xuICAvLyBuYXRxW29mc3ErbGVuLTFdIGlzIGd1YXJhbnRlZWQgdG8gYmUgemVybyAoZHVlIHRvIHRoZSBNU0QgcmVxdWlyZW1lbnQpLFxuICAvLyBhbmQgc2hvdWxkIG5vdCBiZSB3cml0dGVuIHRvLlxuICBmb3IodmFyIGkgPSBsZW4tMjsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgeCA9IGRpdl9oZWxwZXIocmVtLCAobmF0MS5kYXRhW29mczEraV0gPj4+IDApLCAobmF0Mi5kYXRhW29mczJdID4+PiAwKSk7XG4gICAgbmF0cS5kYXRhW29mc3EraV0gPSB4WzBdO1xuICAgIHJlbSA9IHhbMV07XG4gIH1cbiAgbmF0ci5kYXRhW29mc3JdID0gcmVtO1xuICByZXR1cm4gMDtcbn1cblxuLy8gbmF0MVtuYXQyOl0gOj0gbmF0MSAvIG5hdDJcbi8vIG5hdDFbOm5hdDJdIDo9IG5hdDEgJSBuYXQyXG4vLyBsZW4xID4gbGVuMiwgbmF0MltvZnMyK2xlbjItMV0gPiBuYXQxW29mczErbGVuMS0xXVxuLy9Qcm92aWRlczogZGl2X25hdFxuLy9SZXF1aXJlczogZGl2X2RpZ2l0X25hdCwgZGl2X2hlbHBlciwgbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0LCBzaGlmdF9sZWZ0X25hdCwgc2hpZnRfcmlnaHRfbmF0LCBjcmVhdGVfbmF0LCBzZXRfdG9femVyb19uYXQsIG11bHRfZGlnaXRfbmF0LCBzdWJfbmF0LCBjb21wYXJlX25hdCwgbmF0X29mX2FycmF5XG5mdW5jdGlvbiBkaXZfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgaWYobGVuMiA9PSAxKSB7XG4gICAgZGl2X2RpZ2l0X25hdChuYXQxLCBvZnMxKzEsIG5hdDEsIG9mczEsIG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIpO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHMgPSBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQobmF0Miwgb2ZzMitsZW4yLTEpO1xuICBzaGlmdF9sZWZ0X25hdChuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7XG4gIHNoaWZ0X2xlZnRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTtcblxuICB2YXIgZCA9IChuYXQyLmRhdGFbb2ZzMitsZW4yLTFdID4+PiAwKSArIDE7XG4gIHZhciBhID0gY3JlYXRlX25hdChsZW4yKzEpO1xuICBmb3IgKHZhciBpID0gbGVuMSAtIDE7IGkgPj0gbGVuMjsgaS0tKSB7XG4gICAgLy8gRGVjZW50IGxvd2VyIGJvdW5kIG9uIHF1b1xuICAgIHZhciBxdW8gPSBkID09IDQyOTQ5NjcyOTYgPyAobmF0MS5kYXRhW29mczEraV0gPj4+IDApIDogZGl2X2hlbHBlcigobmF0MS5kYXRhW29mczEraV0gPj4+IDApLCAobmF0MS5kYXRhW29mczEraS0xXSA+Pj4wKSwgZClbMF07XG4gICAgc2V0X3RvX3plcm9fbmF0KGEsIDAsIGxlbjIrMSk7XG4gICAgbXVsdF9kaWdpdF9uYXQoYSwgMCwgbGVuMisxLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoW3F1b10pLCAwKTtcbiAgICBzdWJfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yKzEsIGEsIDAsIGxlbjIrMSwgMSk7XG5cbiAgICB3aGlsZSAobmF0MS5kYXRhW29mczEraV0gIT0gMCB8fCBjb21wYXJlX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMiwgbmF0Miwgb2ZzMiwgbGVuMikgPj0gMCkge1xuICAgICAgcXVvID0gcXVvICsgMTtcbiAgICAgIHN1Yl9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIrMSwgbmF0Miwgb2ZzMiwgbGVuMiwgMSk7XG4gICAgfVxuXG4gICAgbmF0MS5kYXRhW29mczEraV0gPSBxdW87XG4gIH1cblxuICBzaGlmdF9yaWdodF9uYXQobmF0MSwgb2ZzMSwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpOyAvLyBzaGlmdCByZW1haW5kZXJcbiAgc2hpZnRfcmlnaHRfbmF0KG5hdDIsIG9mczIsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTsgLy8gcmVzdG9yZVxuICByZXR1cm4gMDtcbn1cblxuXG4vLyAwIDw9IHNoaWZ0IDwgMzJcbi8vUHJvdmlkZXM6IHNoaWZ0X3JpZ2h0X25hdFxuZnVuY3Rpb24gc2hpZnRfcmlnaHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIG5iaXRzKSB7XG4gIGlmKG5iaXRzID09IDApIHtcbiAgICBuYXQyLmRhdGFbb2ZzMl0gPSAwO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciB3cmFwID0gMDtcbiAgZm9yKHZhciBpID0gbGVuMS0xOyBpID49IDA7IGktLSkge1xuICAgIHZhciBhID0gbmF0MS5kYXRhW29mczEraV0gPj4+IDA7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSAoYSA+Pj4gbmJpdHMpIHwgd3JhcDtcbiAgICB3cmFwID0gYSA8PCAoMzIgLSBuYml0cyk7XG4gIH1cbiAgbmF0Mi5kYXRhW29mczJdID0gd3JhcDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBhcmVfZGlnaXRzX25hdFxuZnVuY3Rpb24gY29tcGFyZV9kaWdpdHNfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgaWYobmF0MS5kYXRhW29mczFdID4gbmF0Mi5kYXRhW29mczJdKSByZXR1cm4gMTtcbiAgaWYobmF0MS5kYXRhW29mczFdIDwgbmF0Mi5kYXRhW29mczJdKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX25hdFxuLy9SZXF1aXJlczogbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgdmFyIGEgPSBudW1fZGlnaXRzX25hdChuYXQxLCBvZnMxLCBsZW4xKTtcbiAgdmFyIGIgPSBudW1fZGlnaXRzX25hdChuYXQyLCBvZnMyLCBsZW4yKTtcbiAgaWYoYSA+IGIpIHJldHVybiAxO1xuICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICBmb3IodmFyIGkgPSBsZW4xIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA+IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkpIHJldHVybiAxO1xuICAgIGlmICgobmF0MS5kYXRhW29mczEraV0gPj4+IDApIDwgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSkgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX25hdF9yZWFsXG4vL1JlcXVpcmVzOiBjb21wYXJlX25hdFxuZnVuY3Rpb24gY29tcGFyZV9uYXRfcmVhbChuYXQxLG5hdDIpe1xuICByZXR1cm4gY29tcGFyZV9uYXQobmF0MSwwLG5hdDEuZGF0YS5sZW5ndGgsbmF0MiwwLG5hdDIuZGF0YS5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBsYW5kX2RpZ2l0X25hdFxuZnVuY3Rpb24gbGFuZF9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gJj0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbG9yX2RpZ2l0X25hdFxuZnVuY3Rpb24gbG9yX2RpZ2l0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIG5hdDEuZGF0YVtvZnMxXSB8PSBuYXQyLmRhdGFbb2ZzMl07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBseG9yX2RpZ2l0X25hdFxuZnVuY3Rpb24gbHhvcl9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gXj0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBzZXJpYWxpemVfbmF0XG5mdW5jdGlvbiBzZXJpYWxpemVfbmF0KHdyaXRlciwgbmF0LCBzeil7XG4gIHZhciBsZW4gPSBuYXQuZGF0YS5sZW5ndGg7XG4gIHdyaXRlci53cml0ZSgzMiwgbGVuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICB3cml0ZXIud3JpdGUoMzIsIG5hdC5kYXRhW2ldKTtcbiAgfVxuICBzelswXSA9IGxlbiAqIDQ7XG4gIHN6WzFdID0gbGVuICogODtcbn1cblxuLy9Qcm92aWRlczogZGVzZXJpYWxpemVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gZGVzZXJpYWxpemVfbmF0KHJlYWRlciwgc3ope1xuICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgdmFyIG5hdCA9IG5ldyBNbE5hdChsZW4pO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIG5hdC5kYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgfVxuICBzelswXSA9IGxlbiAqIDQ7XG4gIHJldHVybiBuYXQ7XG59XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBsZXhlcnMgZ2VuZXJhdGVkIGJ5IGNhbWxsZXggKilcblxudHlwZSBwb3NpdGlvbiA9IHtcbiAgcG9zX2ZuYW1lIDogc3RyaW5nO1xuICBwb3NfbG51bSA6IGludDtcbiAgcG9zX2JvbCA6IGludDtcbiAgcG9zX2NudW0gOiBpbnQ7XG59XG5cbmxldCBkdW1teV9wb3MgPSB7XG4gIHBvc19mbmFtZSA9IFwiXCI7XG4gIHBvc19sbnVtID0gMDtcbiAgcG9zX2JvbCA9IDA7XG4gIHBvc19jbnVtID0gLTE7XG59XG5cbnR5cGUgbGV4YnVmID1cbiAgeyByZWZpbGxfYnVmZiA6IGxleGJ1ZiAtPiB1bml0O1xuICAgIG11dGFibGUgbGV4X2J1ZmZlciA6IGJ5dGVzO1xuICAgIG11dGFibGUgbGV4X2J1ZmZlcl9sZW4gOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfYWJzX3BvcyA6IGludDtcbiAgICBtdXRhYmxlIGxleF9zdGFydF9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfY3Vycl9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfbGFzdF9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfbGFzdF9hY3Rpb24gOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfZW9mX3JlYWNoZWQgOiBib29sO1xuICAgIG11dGFibGUgbGV4X21lbSA6IGludCBhcnJheTtcbiAgICBtdXRhYmxlIGxleF9zdGFydF9wIDogcG9zaXRpb247XG4gICAgbXV0YWJsZSBsZXhfY3Vycl9wIDogcG9zaXRpb247XG4gIH1cblxudHlwZSBsZXhfdGFibGVzID1cbiAgeyBsZXhfYmFzZTogc3RyaW5nO1xuICAgIGxleF9iYWNrdHJrOiBzdHJpbmc7XG4gICAgbGV4X2RlZmF1bHQ6IHN0cmluZztcbiAgICBsZXhfdHJhbnM6IHN0cmluZztcbiAgICBsZXhfY2hlY2s6IHN0cmluZztcbiAgICBsZXhfYmFzZV9jb2RlIDogc3RyaW5nO1xuICAgIGxleF9iYWNrdHJrX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2RlZmF1bHRfY29kZSA6IHN0cmluZztcbiAgICBsZXhfdHJhbnNfY29kZSA6IHN0cmluZztcbiAgICBsZXhfY2hlY2tfY29kZSA6IHN0cmluZztcbiAgICBsZXhfY29kZTogc3RyaW5nO31cblxuZXh0ZXJuYWwgY19lbmdpbmUgOiBsZXhfdGFibGVzIC0+IGludCAtPiBsZXhidWYgLT4gaW50ID0gXCJjYW1sX2xleF9lbmdpbmVcIlxuZXh0ZXJuYWwgY19uZXdfZW5naW5lIDogbGV4X3RhYmxlcyAtPiBpbnQgLT4gbGV4YnVmIC0+IGludFxuICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX25ld19sZXhfZW5naW5lXCJcblxubGV0IGVuZ2luZSB0Ymwgc3RhdGUgYnVmID1cbiAgbGV0IHJlc3VsdCA9IGNfZW5naW5lIHRibCBzdGF0ZSBidWYgaW5cbiAgaWYgcmVzdWx0ID49IDAgJiYgYnVmLmxleF9jdXJyX3AgIT0gZHVtbXlfcG9zIHRoZW4gYmVnaW5cbiAgICBidWYubGV4X3N0YXJ0X3AgPC0gYnVmLmxleF9jdXJyX3A7XG4gICAgYnVmLmxleF9jdXJyX3AgPC0ge2J1Zi5sZXhfY3Vycl9wXG4gICAgICAgICAgICAgICAgICAgICAgIHdpdGggcG9zX2NudW0gPSBidWYubGV4X2Fic19wb3MgKyBidWYubGV4X2N1cnJfcG9zfTtcbiAgZW5kO1xuICByZXN1bHRcblxuXG5sZXQgbmV3X2VuZ2luZSB0Ymwgc3RhdGUgYnVmID1cbiAgbGV0IHJlc3VsdCA9IGNfbmV3X2VuZ2luZSB0Ymwgc3RhdGUgYnVmIGluXG4gIGlmIHJlc3VsdCA+PSAwICYmIGJ1Zi5sZXhfY3Vycl9wICE9IGR1bW15X3BvcyB0aGVuIGJlZ2luXG4gICAgYnVmLmxleF9zdGFydF9wIDwtIGJ1Zi5sZXhfY3Vycl9wO1xuICAgIGJ1Zi5sZXhfY3Vycl9wIDwtIHtidWYubGV4X2N1cnJfcFxuICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHBvc19jbnVtID0gYnVmLmxleF9hYnNfcG9zICsgYnVmLmxleF9jdXJyX3Bvc307XG4gIGVuZDtcbiAgcmVzdWx0XG5cbmxldCBsZXhfcmVmaWxsIHJlYWRfZnVuIGF1eF9idWZmZXIgbGV4YnVmID1cbiAgbGV0IHJlYWQgPVxuICAgIHJlYWRfZnVuIGF1eF9idWZmZXIgKEJ5dGVzLmxlbmd0aCBhdXhfYnVmZmVyKSBpblxuICBsZXQgbiA9XG4gICAgaWYgcmVhZCA+IDBcbiAgICB0aGVuIHJlYWRcbiAgICBlbHNlIChsZXhidWYubGV4X2VvZl9yZWFjaGVkIDwtIHRydWU7IDApIGluXG4gICgqIEN1cnJlbnQgc3RhdGUgb2YgdGhlIGJ1ZmZlcjpcbiAgICAgICAgPC0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tPlxuICAgICAgICB8ICBqdW5rIHwgICAgICB2YWxpZCBkYXRhICAgICB8ICAganVuayAgICB8XG4gICAgICAgIF4gICAgICAgXiAgICAgICAgICAgICAgICAgICAgIF4gICAgICAgICAgIF5cbiAgICAgICAgMCAgICBzdGFydF9wb3MgICAgICAgICAgICAgYnVmZmVyX2VuZCAgICBCeXRlcy5sZW5ndGggYnVmZmVyXG4gICopXG4gIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiArIG4gPiBCeXRlcy5sZW5ndGggbGV4YnVmLmxleF9idWZmZXIgdGhlbiBiZWdpblxuICAgICgqIFRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyICopXG4gICAgaWYgbGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MgKyBuXG4gICAgICAgPD0gQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyXG4gICAgdGhlbiBiZWdpblxuICAgICAgKCogQnV0IHRoZXJlIGlzIGVub3VnaCBzcGFjZSBpZiB3ZSByZWNsYWltIHRoZSBqdW5rIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgIG9mIHRoZSBidWZmZXIgKilcbiAgICAgIEJ5dGVzLmJsaXQgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3NcbiAgICAgICAgICAgICAgICAgIGxleGJ1Zi5sZXhfYnVmZmVyIDBcbiAgICAgICAgICAgICAgICAgIChsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3BvcylcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgKCogV2UgbXVzdCBncm93IHRoZSBidWZmZXIuICBEb3VibGluZyBpdHMgc2l6ZSB3aWxsIHByb3ZpZGUgZW5vdWdoXG4gICAgICAgICBzcGFjZSBzaW5jZSBuIDw9IFN0cmluZy5sZW5ndGggYXV4X2J1ZmZlciA8PSBTdHJpbmcubGVuZ3RoIGJ1ZmZlci5cbiAgICAgICAgIFdhdGNoIG91dCBmb3Igc3RyaW5nIGxlbmd0aCBvdmVyZmxvdywgdGhvdWdoLiAqKVxuICAgICAgbGV0IG5ld2xlbiA9XG4gICAgICAgIEludC5taW4gKDIgKiBCeXRlcy5sZW5ndGggbGV4YnVmLmxleF9idWZmZXIpIFN5cy5tYXhfc3RyaW5nX2xlbmd0aCBpblxuICAgICAgaWYgbGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MgKyBuID4gbmV3bGVuXG4gICAgICB0aGVuIGZhaWx3aXRoIFwiTGV4aW5nLmxleF9yZWZpbGw6IGNhbm5vdCBncm93IGJ1ZmZlclwiO1xuICAgICAgbGV0IG5ld2J1ZiA9IEJ5dGVzLmNyZWF0ZSBuZXdsZW4gaW5cbiAgICAgICgqIENvcHkgdGhlIHZhbGlkIGRhdGEgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV3IGJ1ZmZlciAqKVxuICAgICAgQnl0ZXMuYmxpdCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X3N0YXJ0X3Bvc1xuICAgICAgICAgICAgICAgICAgbmV3YnVmIDBcbiAgICAgICAgICAgICAgICAgIChsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3Bvcyk7XG4gICAgICBsZXhidWYubGV4X2J1ZmZlciA8LSBuZXdidWZcbiAgICBlbmQ7XG4gICAgKCogUmVhbGxvY2F0aW9uIG9yIG5vdCwgd2UgaGF2ZSBzaGlmdGVkIHRoZSBkYXRhIGxlZnQgYnlcbiAgICAgICBzdGFydF9wb3MgY2hhcmFjdGVyczsgdXBkYXRlIHRoZSBwb3NpdGlvbnMgKilcbiAgICBsZXQgcyA9IGxleGJ1Zi5sZXhfc3RhcnRfcG9zIGluXG4gICAgbGV4YnVmLmxleF9hYnNfcG9zIDwtIGxleGJ1Zi5sZXhfYWJzX3BvcyArIHM7XG4gICAgbGV4YnVmLmxleF9jdXJyX3BvcyA8LSBsZXhidWYubGV4X2N1cnJfcG9zIC0gcztcbiAgICBsZXhidWYubGV4X3N0YXJ0X3BvcyA8LSAwO1xuICAgIGxleGJ1Zi5sZXhfbGFzdF9wb3MgPC0gbGV4YnVmLmxleF9sYXN0X3BvcyAtIHM7XG4gICAgbGV4YnVmLmxleF9idWZmZXJfbGVuIDwtIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIHMgO1xuICAgIGxldCB0ID0gbGV4YnVmLmxleF9tZW0gaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHQtMSBkb1xuICAgICAgbGV0IHYgPSB0LihpKSBpblxuICAgICAgaWYgdiA+PSAwIHRoZW5cbiAgICAgICAgdC4oaSkgPC0gdi1zXG4gICAgZG9uZVxuICBlbmQ7XG4gICgqIFRoZXJlIGlzIG5vdyBlbm91Z2ggc3BhY2UgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyICopXG4gIEJ5dGVzLmJsaXQgYXV4X2J1ZmZlciAwIGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiBuO1xuICBsZXhidWYubGV4X2J1ZmZlcl9sZW4gPC0gbGV4YnVmLmxleF9idWZmZXJfbGVuICsgblxuXG5sZXQgemVyb19wb3MgPSB7XG4gIHBvc19mbmFtZSA9IFwiXCI7XG4gIHBvc19sbnVtID0gMTtcbiAgcG9zX2JvbCA9IDA7XG4gIHBvc19jbnVtID0gMDtcbn1cblxubGV0IGZyb21fZnVuY3Rpb24gPyh3aXRoX3Bvc2l0aW9ucyA9IHRydWUpIGYgPVxuICB7IHJlZmlsbF9idWZmID0gbGV4X3JlZmlsbCBmIChCeXRlcy5jcmVhdGUgNTEyKTtcbiAgICBsZXhfYnVmZmVyID0gQnl0ZXMuY3JlYXRlIDEwMjQ7XG4gICAgbGV4X2J1ZmZlcl9sZW4gPSAwO1xuICAgIGxleF9hYnNfcG9zID0gMDtcbiAgICBsZXhfc3RhcnRfcG9zID0gMDtcbiAgICBsZXhfY3Vycl9wb3MgPSAwO1xuICAgIGxleF9sYXN0X3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfYWN0aW9uID0gMDtcbiAgICBsZXhfbWVtID0gW3x8XTtcbiAgICBsZXhfZW9mX3JlYWNoZWQgPSBmYWxzZTtcbiAgICBsZXhfc3RhcnRfcCA9IGlmIHdpdGhfcG9zaXRpb25zIHRoZW4gemVyb19wb3MgZWxzZSBkdW1teV9wb3M7XG4gICAgbGV4X2N1cnJfcCA9IGlmIHdpdGhfcG9zaXRpb25zIHRoZW4gemVyb19wb3MgZWxzZSBkdW1teV9wb3M7XG4gIH1cblxubGV0IGZyb21fY2hhbm5lbCA/d2l0aF9wb3NpdGlvbnMgaWMgPVxuICBmcm9tX2Z1bmN0aW9uID93aXRoX3Bvc2l0aW9ucyAoZnVuIGJ1ZiBuIC0+IGlucHV0IGljIGJ1ZiAwIG4pXG5cbmxldCBmcm9tX3N0cmluZyA/KHdpdGhfcG9zaXRpb25zID0gdHJ1ZSkgcyA9XG4gIHsgcmVmaWxsX2J1ZmYgPSAoZnVuIGxleGJ1ZiAtPiBsZXhidWYubGV4X2VvZl9yZWFjaGVkIDwtIHRydWUpO1xuICAgIGxleF9idWZmZXIgPSBCeXRlcy5vZl9zdHJpbmcgczsgKCogaGF2ZSB0byBtYWtlIGEgY29weSBmb3IgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB1bnNhZmUtc3RyaW5nIG1vZGUgKilcbiAgICBsZXhfYnVmZmVyX2xlbiA9IFN0cmluZy5sZW5ndGggcztcbiAgICBsZXhfYWJzX3BvcyA9IDA7XG4gICAgbGV4X3N0YXJ0X3BvcyA9IDA7XG4gICAgbGV4X2N1cnJfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9wb3MgPSAwO1xuICAgIGxleF9sYXN0X2FjdGlvbiA9IDA7XG4gICAgbGV4X21lbSA9IFt8fF07XG4gICAgbGV4X2VvZl9yZWFjaGVkID0gdHJ1ZTtcbiAgICBsZXhfc3RhcnRfcCA9IGlmIHdpdGhfcG9zaXRpb25zIHRoZW4gemVyb19wb3MgZWxzZSBkdW1teV9wb3M7XG4gICAgbGV4X2N1cnJfcCA9IGlmIHdpdGhfcG9zaXRpb25zIHRoZW4gemVyb19wb3MgZWxzZSBkdW1teV9wb3M7XG4gIH1cblxubGV0IHNldF9wb3NpdGlvbiBsZXhidWYgcG9zaXRpb24gPVxuICBsZXhidWYubGV4X2N1cnJfcCAgPC0ge3Bvc2l0aW9uIHdpdGggcG9zX2ZuYW1lID0gbGV4YnVmLmxleF9jdXJyX3AucG9zX2ZuYW1lfTtcbiAgbGV4YnVmLmxleF9hYnNfcG9zIDwtIHBvc2l0aW9uLnBvc19jbnVtXG5cbmxldCBzZXRfZmlsZW5hbWUgbGV4YnVmIGZuYW1lID1cbiAgbGV4YnVmLmxleF9jdXJyX3AgPC0ge2xleGJ1Zi5sZXhfY3Vycl9wIHdpdGggcG9zX2ZuYW1lID0gZm5hbWV9XG5cbmxldCB3aXRoX3Bvc2l0aW9ucyBsZXhidWYgPSBsZXhidWYubGV4X2N1cnJfcCAhPSBkdW1teV9wb3NcblxubGV0IGxleGVtZSBsZXhidWYgPVxuICBsZXQgbGVuID0gbGV4YnVmLmxleF9jdXJyX3BvcyAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zIGluXG4gIEJ5dGVzLnN1Yl9zdHJpbmcgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3MgbGVuXG5cbmxldCBzdWJfbGV4ZW1lIGxleGJ1ZiBpMSBpMiA9XG4gIGxldCBsZW4gPSBpMi1pMSBpblxuICBCeXRlcy5zdWJfc3RyaW5nIGxleGJ1Zi5sZXhfYnVmZmVyIGkxIGxlblxuXG5sZXQgc3ViX2xleGVtZV9vcHQgbGV4YnVmIGkxIGkyID1cbiAgaWYgaTEgPj0gMCB0aGVuIGJlZ2luXG4gICAgbGV0IGxlbiA9IGkyLWkxIGluXG4gICAgU29tZSAoQnl0ZXMuc3ViX3N0cmluZyBsZXhidWYubGV4X2J1ZmZlciBpMSBsZW4pXG4gIGVuZCBlbHNlIGJlZ2luXG4gICAgTm9uZVxuICBlbmRcblxubGV0IHN1Yl9sZXhlbWVfY2hhciBsZXhidWYgaSA9IEJ5dGVzLmdldCBsZXhidWYubGV4X2J1ZmZlciBpXG5cbmxldCBzdWJfbGV4ZW1lX2NoYXJfb3B0IGxleGJ1ZiBpID1cbiAgaWYgaSA+PSAwIHRoZW5cbiAgICBTb21lIChCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgaSlcbiAgZWxzZVxuICAgIE5vbmVcblxuXG5sZXQgbGV4ZW1lX2NoYXIgbGV4YnVmIGkgPVxuICBCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgKGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgaSlcblxubGV0IGxleGVtZV9zdGFydCBsZXhidWYgPSBsZXhidWYubGV4X3N0YXJ0X3AucG9zX2NudW1cbmxldCBsZXhlbWVfZW5kIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfY3Vycl9wLnBvc19jbnVtXG5cbmxldCBsZXhlbWVfc3RhcnRfcCBsZXhidWYgPSBsZXhidWYubGV4X3N0YXJ0X3BcbmxldCBsZXhlbWVfZW5kX3AgbGV4YnVmID0gbGV4YnVmLmxleF9jdXJyX3BcblxubGV0IG5ld19saW5lIGxleGJ1ZiA9XG4gIGxldCBsY3AgPSBsZXhidWYubGV4X2N1cnJfcCBpblxuICBpZiBsY3AgIT0gZHVtbXlfcG9zIHRoZW5cbiAgICBsZXhidWYubGV4X2N1cnJfcCA8LVxuICAgICAgeyBsY3Agd2l0aFxuICAgICAgICBwb3NfbG51bSA9IGxjcC5wb3NfbG51bSArIDE7XG4gICAgICAgIHBvc19ib2wgPSBsY3AucG9zX2NudW07XG4gICAgICB9XG5cblxuXG4oKiBEaXNjYXJkIGRhdGEgbGVmdCBpbiBsZXhlciBidWZmZXIuICopXG5cbmxldCBmbHVzaF9pbnB1dCBsYiA9XG4gIGxiLmxleF9jdXJyX3BvcyA8LSAwO1xuICBsYi5sZXhfYWJzX3BvcyA8LSAwO1xuICBsZXQgbGNwID0gbGIubGV4X2N1cnJfcCBpblxuICBpZiBsY3AgIT0gZHVtbXlfcG9zIHRoZW5cbiAgICBsYi5sZXhfY3Vycl9wIDwtIHt6ZXJvX3BvcyB3aXRoIHBvc19mbmFtZSA9IGxjcC5wb3NfZm5hbWV9O1xuICBsYi5sZXhfYnVmZmVyX2xlbiA8LSAwO1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgIEJlbm9pdCBWYXVnb24sIEVOU1RBICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAoKiBUb29scyB0byBtYW5pcHVsYXRlIHNjYW5uaW5nIHNldCBvZiBjaGFycyAoc2VlICVbLi4uXSkgKilcblxudHlwZSBtdXRhYmxlX2NoYXJfc2V0ID0gYnl0ZXNcblxuKCogQ3JlYXRlIGEgZnJlc2gsIGVtcHR5LCBtdXRhYmxlIGNoYXIgc2V0LiAqKVxubGV0IGNyZWF0ZV9jaGFyX3NldCAoKSA9IEJ5dGVzLm1ha2UgMzIgJ1xcMDAwJ1xuXG4oKiBBZGQgYSBjaGFyIGluIGEgbXV0YWJsZSBjaGFyIHNldC4gKilcbmxldCBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyA9XG4gIGxldCBpbmQgPSBpbnRfb2ZfY2hhciBjIGluXG4gIGxldCBzdHJfaW5kID0gaW5kIGxzciAzIGFuZCBtYXNrID0gMSBsc2wgKGluZCBsYW5kIDBiMTExKSBpblxuICBCeXRlcy5zZXQgY2hhcl9zZXQgc3RyX2luZFxuICAgIChjaGFyX29mX2ludCAoaW50X29mX2NoYXIgKEJ5dGVzLmdldCBjaGFyX3NldCBzdHJfaW5kKSBsb3IgbWFzaykpXG5cbmxldCBmcmVlemVfY2hhcl9zZXQgY2hhcl9zZXQgPVxuICBCeXRlcy50b19zdHJpbmcgY2hhcl9zZXRcblxuKCogQ29tcHV0ZSB0aGUgY29tcGxlbWVudCBvZiBhIGNoYXIgc2V0LiAqKVxubGV0IHJldl9jaGFyX3NldCBjaGFyX3NldCA9XG4gIGxldCBjaGFyX3NldCcgPSBjcmVhdGVfY2hhcl9zZXQgKCkgaW5cbiAgZm9yIGkgPSAwIHRvIDMxIGRvXG4gICAgQnl0ZXMuc2V0IGNoYXJfc2V0JyBpXG4gICAgICAoY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIChTdHJpbmcuZ2V0IGNoYXJfc2V0IGkpIGx4b3IgMHhGRikpO1xuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGNoYXJfc2V0J1xuXG4oKiBSZXR1cm4gdHJ1ZSBpZiBhIGBjJyBpcyBpbiBgY2hhcl9zZXQnLiAqKVxubGV0IGlzX2luX2NoYXJfc2V0IGNoYXJfc2V0IGMgPVxuICBsZXQgaW5kID0gaW50X29mX2NoYXIgYyBpblxuICBsZXQgc3RyX2luZCA9IGluZCBsc3IgMyBhbmQgbWFzayA9IDEgbHNsIChpbmQgbGFuZCAwYjExMSkgaW5cbiAgKGludF9vZl9jaGFyIChTdHJpbmcuZ2V0IGNoYXJfc2V0IHN0cl9pbmQpIGxhbmQgbWFzaykgPD4gMFxuXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgKCogSWdub3JlZCBwYXJhbSBjb252ZXJzaW9uICopXG5cbigqIEdBRFQgdXNlZCB0byBhYnN0cmFjdCBhbiBleGlzdGVudGlhbCB0eXBlIHBhcmFtZXRlci4gKilcbigqIFNlZSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYXJhbV9mb3JtYXRfZWJiID0gUGFyYW1fZm9ybWF0X0VCQiA6XG4gICAgKCd4IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYXJhbV9mb3JtYXRfZWJiXG5cbigqIENvbXB1dGUgYSBwYWRkaW5nIGFzc29jaWF0ZWQgdG8gYSBwYWRfb3B0aW9uIChzZWUgXCIlXzQyZFwiKS4gKilcbmxldCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0ID0gbWF0Y2ggcGFkX29wdCB3aXRoXG4gIHwgTm9uZSAtPiBOb19wYWRkaW5nXG4gIHwgU29tZSB3aWR0aCAtPiBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKVxuXG4oKiBDb21wdXRlIGEgcHJlY2lzaW9uIGFzc29jaWF0ZWQgdG8gYSBwcmVjX29wdGlvbiAoc2VlIFwiJV8uNDJmXCIpLiAqKVxubGV0IHByZWNfb2ZfcHJlY19vcHQgcHJlY19vcHQgPSBtYXRjaCBwcmVjX29wdCB3aXRoXG4gIHwgTm9uZSAtPiBOb19wcmVjaXNpb25cbiAgfCBTb21lIG5kZWMgLT4gTGl0X3ByZWNpc2lvbiBuZGVjXG5cbigqIFR1cm4gYW4gaWdub3JlZCBwYXJhbSBpbnRvIGl0cyBlcXVpdmFsZW50IG5vdC1pZ25vcmVkIGZvcm1hdCBub2RlLiAqKVxuKCogVXNlZCBmb3IgZm9ybWF0IHByZXR0eS1wcmludGluZyBhbmQgU2NhbmYuICopXG5sZXQgcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IDogdHlwZSBhIGIgYyBkIGUgZiB4IHkgLlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBpZ25vcmVkIC0+ICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBwYXJhbV9mb3JtYXRfZWJiID1cbmZ1biBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2hhciBmbXQpXG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDYW1sX2NoYXIgZm10KVxuICB8IElnbm9yZWRfc3RyaW5nIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTdHJpbmcgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEludCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2ludDMyIChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoSW50MzIgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChOYXRpdmVpbnQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQ2NCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEludDY0IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfZmxvYXQgKHBhZF9vcHQsIHByZWNfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChGbG9hdCAoKEZsb2F0X2ZsYWdfLCBGbG9hdF9mKSxcbiAgICAgICAgICAgICAgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgcHJlY19vZl9wcmVjX29wdCBwcmVjX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2Jvb2wgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEJvb2wgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgZm10KSlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHkpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIGZtdCkpXG4gIHwgSWdub3JlZF9yZWFkZXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChSZWFkZXIgZm10KVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXQpKVxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10KSlcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9uZXh0X2NoYXIgZm10KVxuXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUeXBlcyAqKVxuXG50eXBlICgnYiwgJ2MpIGFjY19mb3JtYXR0aW5nX2dlbiA9XG4gIHwgQWNjX29wZW5fdGFnIG9mICgnYiwgJ2MpIGFjY1xuICB8IEFjY19vcGVuX2JveCBvZiAoJ2IsICdjKSBhY2NcblxuKCogUmV2ZXJzZWQgbGlzdCBvZiBwcmludGluZyBhdG9tcy4gKilcbigqIFVzZWQgdG8gYWNjdW11bGF0ZSBwcmludGYgYXJndW1lbnRzLiAqKVxuYW5kICgnYiwgJ2MpIGFjYyA9XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IG9mICgnYiwgJ2MpIGFjYyAqIGZvcm1hdHRpbmdfbGl0XG4gICAgICAoKiBTcGVjaWFsIGZtdHRpbmcgKGJveCkgKilcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gb2YgKCdiLCAnYykgYWNjICogKCdiLCAnYykgYWNjX2Zvcm1hdHRpbmdfZ2VuXG4gICAgICAoKiBTcGVjaWFsIGZtdHRpbmcgKGJveCkgKilcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nICAgICAoKiBMaXRlcmFsIHN0cmluZyAqKVxuICB8IEFjY19jaGFyX2xpdGVyYWwgICBvZiAoJ2IsICdjKSBhY2MgKiBjaGFyICAgICAgICgqIExpdGVyYWwgY2hhciAqKVxuICB8IEFjY19kYXRhX3N0cmluZyAgICBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmcgICAgICgqIEdlbmVyYXRlZCBzdHJpbmcgKilcbiAgfCBBY2NfZGF0YV9jaGFyICAgICAgb2YgKCdiLCAnYykgYWNjICogY2hhciAgICAgICAoKiBHZW5lcmF0ZWQgY2hhciAqKVxuICB8IEFjY19kZWxheSAgICAgICAgICBvZiAoJ2IsICdjKSBhY2MgKiAoJ2IgLT4gJ2MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBEZWxheWVkIHByaW50aW5nICglYSwgJXQpICopXG4gIHwgQWNjX2ZsdXNoICAgICAgICAgIG9mICgnYiwgJ2MpIGFjYyAgICAgICAgICAgICAgKCogRmx1c2ggKilcbiAgfCBBY2NfaW52YWxpZF9hcmcgICAgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nXG4gICAgICAoKiBSYWlzZSBJbnZhbGlkX2FyZ3VtZW50IG1zZyAqKVxuICB8IEVuZF9vZl9hY2NcblxuKCogTGlzdCBvZiBoZXRlcm9nZW5lb3VzIHZhbHVlcy4gKilcbigqIFVzZWQgdG8gYWNjdW11bGF0ZSBzY2FuZiBjYWxsYmFjayBhcmd1bWVudHMuICopXG50eXBlICgnYSwgJ2IpIGhldGVyX2xpc3QgPVxuICB8IENvbnMgOiAnYyAqICgnYSwgJ2IpIGhldGVyX2xpc3QgLT4gKCdjIC0+ICdhLCAnYikgaGV0ZXJfbGlzdFxuICB8IE5pbCA6ICgnYiwgJ2IpIGhldGVyX2xpc3RcblxuKCogRXhpc3RlbnRpYWwgQmxhY2sgQm94ZXMuICopXG4oKiBVc2VkIHRvIGFic3RyYWN0IHNvbWUgZXhpc3RlbnRpYWwgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nIGFuZCBhbiBmbXR0eS4gKilcbigqIFNlZSB0aGUgdHlwZV9wYWRkaW5nIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkZGluZ19mbXR0eV9lYmIgPSBQYWRkaW5nX2ZtdHR5X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZGRpbmdfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXR0eS4gKilcbigqIFNlZSB0aGUgdHlwZV9wYWRwcmVjIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkcHJlY19mbXR0eV9lYmIgPSBQYWRwcmVjX2ZtdHR5X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICd6KSBwcmVjaXNpb24gKiAoJ3osICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZHByZWNfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcgYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3BhZGRpbmdfZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdlLCAnZikgcGFkZGluZ19mbXRfZWJiID0gUGFkZGluZ19mbXRfRUJCIDpcbiAgICAgKF8sICd4IC0+ICdhKSBwYWRkaW5nICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2UsICdmKSBwYWRkaW5nX2ZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wcmVjaXNpb25fZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdlLCAnZikgcHJlY2lzaW9uX2ZtdF9lYmIgPSBQcmVjaXNpb25fZm10X0VCQiA6XG4gICAgIChfLCAneCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2UsICdmKSBwcmVjaXNpb25fZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nLCBhIHByZWNpc2lvbiBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcGFkcHJlY19mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ3AsICdiLCAnYywgJ2UsICdmKSBwYWRwcmVjX2ZtdF9lYmIgPSBQYWRwcmVjX2ZtdF9FQkIgOlxuICAgICAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCAncCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3AsICdiLCAnYywgJ2UsICdmKSBwYWRwcmVjX2ZtdF9lYmJcblxuKCogQWJzdHJhY3QgdGhlICdhIGFuZCAnZCBwYXJhbWV0ZXJzIG9mIGFuIGZtdC4gKilcbigqIE91dHB1dCB0eXBlIG9mIHRoZSBmb3JtYXQgcGFyc2luZyBmdW5jdGlvbi4gKilcbnR5cGUgKCdiLCAnYywgJ2UsICdmKSBmbXRfZWJiID0gRm10X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCdiLCAnYywgJ2UsICdmKSBmbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhbiBmbXR0eSBhbmQgYW4gZm10LiAqKVxuKCogU2VlIHRoZSB0eXBlX2Zvcm1hdF9nZW4gZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRfZm10dHlfZWJiID0gRm10X2ZtdHR5X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBmbXQgKlxuICAgICAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGFuIGZtdHR5IGFuZCBhbiBmbXQuICopXG4oKiBTZWUgdGhlIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfZm10X2ViYiA9IEZtdHR5X2ZtdF9FQkIgOlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICd5LCAneCkgZm10dHkgKlxuICAgICAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10X2ZtdHR5X2ViYiAtPlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfZm10X2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgZm10dHkgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIGZvcm1hdCB0eXBlcy4gKilcbnR5cGUgZm10dHlfZWJiID0gRm10dHlfRUJCIDogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+IGZtdHR5X2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgcGFkZGluZyB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgcGFkZGluZ3MuICopXG50eXBlIHBhZGRpbmdfZWJiID0gUGFkZGluZ19FQkIgOiAoJ2EsICdiKSBwYWRkaW5nIC0+IHBhZGRpbmdfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBwcmVjaXNpb24gdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIHByZWNpc2lvbnMuICopXG50eXBlIHByZWNpc2lvbl9lYmIgPSBQcmVjaXNpb25fRUJCIDogKCdhLCAnYikgcHJlY2lzaW9uIC0+IHByZWNpc2lvbl9lYmJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBDb25zdGFudHMgKilcblxuKCogRGVmYXVsdCBwcmVjaXNpb24gZm9yIGZsb2F0IHByaW50aW5nLiAqKVxubGV0IGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252ID1cbiAgbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgfCBGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfRyB8IEZsb2F0X2ggfCBGbG9hdF9IXG4gIHwgRmxvYXRfQ0YgLT4gLTZcbiAgKCogRm9yICVoICVIIGFuZCAlI0YgZm9ybWF0cywgYSBuZWdhdGl2ZSBwcmVjaXNpb24gbWVhbnMgXCJhcyBtYW55IGRpZ2l0cyBhc1xuICAgICBuZWNlc3NhcnlcIi4gIEZvciB0aGUgb3RoZXIgRlAgZm9ybWF0cywgd2UgdGFrZSB0aGUgYWJzb2x1dGUgdmFsdWVcbiAgICAgb2YgdGhlIHByZWNpc2lvbiwgaGVuY2UgNiBkaWdpdHMgYnkgZGVmYXVsdC4gKilcbiAgfCBGbG9hdF9GIC0+IDEyXG4gICgqIERlZmF1bHQgcHJlY2lzaW9uIGZvciBPQ2FtbCBmbG9hdCBwcmludGluZyAoJUYpLiAqKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEV4dGVybmFscyAqKVxuXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQ6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQ6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDMyOiBzdHJpbmcgLT4gaW50MzIgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2ludDMyX2Zvcm1hdFwiXG5leHRlcm5hbCBmb3JtYXRfbmF0aXZlaW50OiBzdHJpbmcgLT4gbmF0aXZlaW50IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9uYXRpdmVpbnRfZm9ybWF0XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQ2NDogc3RyaW5nIC0+IGludDY0IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9pbnQ2NF9mb3JtYXRcIlxuZXh0ZXJuYWwgaGV4c3RyaW5nX29mX2Zsb2F0OiBmbG9hdCAtPiBpbnQgLT4gY2hhciAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0XCJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICgqIFRvb2xzIHRvIHByZXR0eS1wcmludCBmb3JtYXRzICopXG5cbigqIFR5cGUgb2YgZXh0ZW5zaWJsZSBjaGFyYWN0ZXIgYnVmZmVycy4gKilcbnR5cGUgYnVmZmVyID0ge1xuICBtdXRhYmxlIGluZCA6IGludDtcbiAgbXV0YWJsZSBieXRlcyA6IGJ5dGVzO1xufVxuXG4oKiBDcmVhdGUgYSBmcmVzaCBidWZmZXIuICopXG5sZXQgYnVmZmVyX2NyZWF0ZSBpbml0X3NpemUgPSB7IGluZCA9IDA7IGJ5dGVzID0gQnl0ZXMuY3JlYXRlIGluaXRfc2l6ZSB9XG5cbigqIENoZWNrIHNpemUgb2YgdGhlIGJ1ZmZlciBhbmQgZ3JvdyBpdCBpZiBuZWVkZWQuICopXG5sZXQgYnVmZmVyX2NoZWNrX3NpemUgYnVmIG92ZXJoZWFkID1cbiAgbGV0IGxlbiA9IEJ5dGVzLmxlbmd0aCBidWYuYnl0ZXMgaW5cbiAgbGV0IG1pbl9sZW4gPSBidWYuaW5kICsgb3ZlcmhlYWQgaW5cbiAgaWYgbWluX2xlbiA+IGxlbiB0aGVuIChcbiAgICBsZXQgbmV3X2xlbiA9IEludC5tYXggKGxlbiAqIDIpIG1pbl9sZW4gaW5cbiAgICBsZXQgbmV3X3N0ciA9IEJ5dGVzLmNyZWF0ZSBuZXdfbGVuIGluXG4gICAgQnl0ZXMuYmxpdCBidWYuYnl0ZXMgMCBuZXdfc3RyIDAgbGVuO1xuICAgIGJ1Zi5ieXRlcyA8LSBuZXdfc3RyO1xuICApXG5cbigqIEFkZCB0aGUgY2hhcmFjdGVyIGBjJyB0byB0aGUgYnVmZmVyIGBidWYnLiAqKVxubGV0IGJ1ZmZlcl9hZGRfY2hhciBidWYgYyA9XG4gIGJ1ZmZlcl9jaGVja19zaXplIGJ1ZiAxO1xuICBCeXRlcy5zZXQgYnVmLmJ5dGVzIGJ1Zi5pbmQgYztcbiAgYnVmLmluZCA8LSBidWYuaW5kICsgMVxuXG4oKiBBZGQgdGhlIHN0cmluZyBgcycgdG8gdGhlIGJ1ZmZlciBgYnVmJy4gKilcbmxldCBidWZmZXJfYWRkX3N0cmluZyBidWYgcyA9XG4gIGxldCBzdHJfbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGJ1ZmZlcl9jaGVja19zaXplIGJ1ZiBzdHJfbGVuO1xuICBTdHJpbmcuYmxpdCBzIDAgYnVmLmJ5dGVzIGJ1Zi5pbmQgc3RyX2xlbjtcbiAgYnVmLmluZCA8LSBidWYuaW5kICsgc3RyX2xlblxuXG4oKiBHZXQgdGhlIGNvbnRlbnQgb2YgdGhlIGJ1ZmZlci4gKilcbmxldCBidWZmZXJfY29udGVudHMgYnVmID1cbiAgQnl0ZXMuc3ViX3N0cmluZyBidWYuYnl0ZXMgMCBidWYuaW5kXG5cbigqKiopXG5cbigqIENvbnZlcnQgYW4gaW50ZWdlciBjb252ZXJzaW9uIHRvIGNoYXIuICopXG5sZXQgY2hhcl9vZl9pY29udiBpY29udiA9IG1hdGNoIGljb252IHdpdGhcbiAgfCBJbnRfZCB8IEludF9wZCB8IEludF9zZCB8IEludF9DZCAtPiAnZCcgfCBJbnRfaSB8IEludF9waSB8IEludF9zaVxuICB8IEludF9DaSAtPiAnaScgfCBJbnRfeCB8IEludF9DeCAtPiAneCcgfCBJbnRfWCB8IEludF9DWCAtPiAnWCcgfCBJbnRfb1xuICB8IEludF9DbyAtPiAnbycgfCBJbnRfdSB8IEludF9DdSAtPiAndSdcblxuKCogQ29udmVydCBhIGZsb2F0IGNvbnZlcnNpb24gdG8gY2hhci4gKilcbigqIGBjRicgd2lsbCBiZSAnRicgZm9yIGRpc3BsYXlpbmcgZm9ybWF0IGFuZCAnZycgdG8gY2FsbCBsaWJjIHByaW50ZiAqKVxubGV0IGNoYXJfb2ZfZmNvbnYgPyhjRj0nRicpIGZjb252ID0gbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgfCBGbG9hdF9mIC0+ICdmJyB8IEZsb2F0X2UgLT4gJ2UnXG4gIHwgRmxvYXRfRSAtPiAnRScgfCBGbG9hdF9nIC0+ICdnJ1xuICB8IEZsb2F0X0cgLT4gJ0cnIHwgRmxvYXRfRiAtPiBjRlxuICB8IEZsb2F0X2ggLT4gJ2gnIHwgRmxvYXRfSCAtPiAnSCdcbiAgfCBGbG9hdF9DRiAtPiAnRidcblxuXG4oKiBDb252ZXJ0IGEgc2Nhbm5pbmcgY291bnRlciB0byBjaGFyLiAqKVxubGV0IGNoYXJfb2ZfY291bnRlciBjb3VudGVyID0gbWF0Y2ggY291bnRlciB3aXRoXG4gIHwgTGluZV9jb3VudGVyICAtPiAnbCdcbiAgfCBDaGFyX2NvdW50ZXIgIC0+ICduJ1xuICB8IFRva2VuX2NvdW50ZXIgLT4gJ04nXG5cbigqKiopXG5cbigqIFByaW50IGEgY2hhcl9zZXQgaW4gYSBidWZmZXIgd2l0aCB0aGUgT0NhbWwgZm9ybWF0IGxleGljYWwgY29udmVudGlvbi4gKilcbmxldCBicHJpbnRfY2hhcl9zZXQgYnVmIGNoYXJfc2V0ID1cbiAgbGV0IHJlYyBwcmludF9zdGFydCBzZXQgPVxuICAgIGxldCBpc19hbG9uZSBjID1cbiAgICAgIGxldCBiZWZvcmUsIGFmdGVyID0gQ2hhci4oY2hyIChjb2RlIGMgLSAxKSwgY2hyIChjb2RlIGMgKyAxKSkgaW5cbiAgICAgIGlzX2luX2NoYXJfc2V0IHNldCBjXG4gICAgICAmJiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCBiZWZvcmUgJiYgaXNfaW5fY2hhcl9zZXQgc2V0IGFmdGVyKSBpblxuICAgIGlmIGlzX2Fsb25lICddJyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ10nO1xuICAgIHByaW50X291dCBzZXQgMTtcbiAgICBpZiBpc19hbG9uZSAnLScgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICctJztcbiAgYW5kIHByaW50X291dCBzZXQgaSA9XG4gICAgaWYgaSA8IDI1NiB0aGVuXG4gICAgICBpZiBpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGkpIHRoZW4gcHJpbnRfZmlyc3Qgc2V0IGlcbiAgICAgIGVsc2UgcHJpbnRfb3V0IHNldCAoaSArIDEpXG4gIGFuZCBwcmludF9maXJzdCBzZXQgaSA9XG4gICAgbWF0Y2ggY2hhcl9vZl9pbnQgaSB3aXRoXG4gICAgfCAnXFwyNTUnIC0+IHByaW50X2NoYXIgYnVmIDI1NTtcbiAgICB8ICddJyB8ICctJyAtPiBwcmludF9vdXQgc2V0IChpICsgMSk7XG4gICAgfCBfIC0+IHByaW50X3NlY29uZCBzZXQgKGkgKyAxKTtcbiAgYW5kIHByaW50X3NlY29uZCBzZXQgaSA9XG4gICAgaWYgaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCBpKSB0aGVuXG4gICAgICBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICAgIHwgJ1xcMjU1JyAtPlxuICAgICAgICBwcmludF9jaGFyIGJ1ZiAyNTQ7XG4gICAgICAgIHByaW50X2NoYXIgYnVmIDI1NTtcbiAgICAgIHwgJ10nIHwgJy0nIHdoZW4gbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IChpICsgMSkpKSAtPlxuICAgICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgICBwcmludF9vdXQgc2V0IChpICsgMSk7XG4gICAgICB8IF8gd2hlbiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgKGkgKyAxKSkpIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICAgIHByaW50X2NoYXIgYnVmIGk7XG4gICAgICAgIHByaW50X291dCBzZXQgKGkgKyAyKTtcbiAgICAgIHwgXyAtPlxuICAgICAgICBwcmludF9pbiBzZXQgKGkgLSAxKSAoaSArIDIpO1xuICAgIGVsc2UgKFxuICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgIHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICApXG4gIGFuZCBwcmludF9pbiBzZXQgaSBqID1cbiAgICBpZiBqID0gMjU2IHx8IG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCBqKSkgdGhlbiAoXG4gICAgICBwcmludF9jaGFyIGJ1ZiBpO1xuICAgICAgcHJpbnRfY2hhciBidWYgKGludF9vZl9jaGFyICctJyk7XG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaiAtIDEpO1xuICAgICAgaWYgaiA8IDI1NiB0aGVuIHByaW50X291dCBzZXQgKGogKyAxKTtcbiAgICApIGVsc2VcbiAgICAgIHByaW50X2luIHNldCBpIChqICsgMSk7XG4gIGFuZCBwcmludF9jaGFyIGJ1ZiBpID0gbWF0Y2ggY2hhcl9vZl9pbnQgaSB3aXRoXG4gICAgfCAnJScgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICAgIHwgJ0AnIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICdAJztcbiAgICB8IGMgICAtPiBidWZmZXJfYWRkX2NoYXIgYnVmIGM7XG4gIGluXG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ1snO1xuICBwcmludF9zdGFydCAoXG4gICAgaWYgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgJ1xcMDAwJ1xuICAgIHRoZW4gKCBidWZmZXJfYWRkX2NoYXIgYnVmICdeJzsgcmV2X2NoYXJfc2V0IGNoYXJfc2V0IClcbiAgICBlbHNlIGNoYXJfc2V0XG4gICk7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ10nXG5cbigqKiopXG5cbigqIFByaW50IGEgcGFkdHkgaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wYWR0eSBidWYgcGFkdHkgPSBtYXRjaCBwYWR0eSB3aXRoXG4gIHwgTGVmdCAgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLSdcbiAgfCBSaWdodCAtPiAoKVxuICB8IFplcm9zIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJzAnXG5cbigqIFByaW50IHRoZSAnXycgb2YgYW4gaWdub3JlZCBmbGFnIGlmIG5lZWRlZC4gKilcbmxldCBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZyA9XG4gIGlmIGlnbl9mbGFnIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXydcblxuKCoqKilcblxubGV0IGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0ID0gbWF0Y2ggcGFkX29wdCB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgd2lkdGggLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIHdpZHRoKVxuXG4oKioqKVxuXG4oKiBQcmludCBwYWRkaW5nIGluIGEgYnVmZmVyIHdpdGggdGhlIGZvcm1hdC1saWtlIHN5bnRheC4gKilcbmxldCBicHJpbnRfcGFkZGluZyA6IHR5cGUgYSBiIC4gYnVmZmVyIC0+IChhLCBiKSBwYWRkaW5nIC0+IHVuaXQgPVxuZnVuIGJ1ZiBwYWQgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nIC0+ICgpXG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCBuKSAtPlxuICAgIGJwcmludF9wYWR0eSBidWYgcGFkdHk7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIG4pO1xuICB8IEFyZ19wYWRkaW5nIHBhZHR5IC0+XG4gICAgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eTtcbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcqJ1xuXG4oKiBQcmludCBwcmVjaXNpb24gaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wcmVjaXNpb24gOiB0eXBlIGEgYiAuIGJ1ZmZlciAtPiAoYSwgYikgcHJlY2lzaW9uIC0+IHVuaXQgPVxuICBmdW4gYnVmIHByZWMgLT4gbWF0Y2ggcHJlYyB3aXRoXG4gIHwgTm9fcHJlY2lzaW9uIC0+ICgpXG4gIHwgTGl0X3ByZWNpc2lvbiBuIC0+XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLic7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIG4pO1xuICB8IEFyZ19wcmVjaXNpb24gLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIuKlwiXG5cbigqKiopXG5cbigqIFByaW50IHRoZSBvcHRpb25hbCAnKycsICcgJyBvciAnIycgYXNzb2NpYXRlZCB0byBhbiBpbnQgY29udmVyc2lvbi4gKilcbmxldCBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnYgPSBtYXRjaCBpY29udiB3aXRoXG4gIHwgSW50X3BkIHwgSW50X3BpIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJysnXG4gIHwgSW50X3NkIHwgSW50X3NpIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyAnXG4gIHwgSW50X0N4IHwgSW50X0NYIHwgSW50X0NvIHwgSW50X0NkIHwgSW50X0NpIHwgSW50X0N1IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcjJ1xuICB8IEludF9kIHwgSW50X2kgfCBJbnRfeCB8IEludF9YIHwgSW50X28gfCBJbnRfdSAtPiAoKVxuXG4oKiBQcmludCBhbiBjb21wbGV0ZSBpbnQgZm9ybWF0IGluIGEgYnVmZmVyIChleDogXCIlMy4qZFwiKS4gKilcbmxldCBicHJpbnRfaW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgPVxuICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gIGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udjtcbiAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDtcbiAgYnByaW50X3ByZWNpc2lvbiBidWYgcHJlYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9pY29udiBpY29udilcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBpbnQzMiwgbmF0aXZlaW50IG9yIGludDY0IGZvcm1hdCBpbiBhIGJ1ZmZlci4gKilcbmxldCBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2ljb252X2ZsYWcgYnVmIGljb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIGM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpXG5cbigqKiopXG5cbigqIFByaW50IHRoZSBvcHRpb25hbCAnKycsICcgJyBhbmQvb3IgJyMnIGFzc29jaWF0ZWQgdG8gYSBmbG9hdCBjb252ZXJzaW9uLiAqKVxubGV0IGJwcmludF9mY29udl9mbGFnIGJ1ZiBmY29udiA9XG4gIGJlZ2luIG1hdGNoIGZzdCBmY29udiB3aXRoXG4gIHwgRmxvYXRfZmxhZ19wIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJysnXG4gIHwgRmxvYXRfZmxhZ19zIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyAnXG4gIHwgRmxvYXRfZmxhZ18gLT4gKCkgZW5kO1xuICBtYXRjaCBzbmQgZmNvbnYgd2l0aFxuICB8IEZsb2F0X0NGIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyMnXG4gIHwgRmxvYXRfZiB8IEZsb2F0X2UgfCBGbG9hdF9FIHwgRmxvYXRfZyB8IEZsb2F0X0dcbiAgfCBGbG9hdF9GIHwgRmxvYXRfaCB8IEZsb2F0X0ggLT4gKClcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmbG9hdCBmb3JtYXQgaW4gYSBidWZmZXIgKGV4OiBcIiUrKi4zZlwiKS4gKilcbmxldCBicHJpbnRfZmxvYXRfZm10IGJ1ZiBpZ25fZmxhZyBmY29udiBwYWQgcHJlYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2Zjb252IGZjb252KVxuXG4oKiBDb21wdXRlIHRoZSBsaXRlcmFsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIEZvcm1hdHRpbmdfbGl0LiAqKVxuKCogVXNlZCBieSBQcmludGYgYW5kIFNjYW5mIHdoZXJlIGZvcm1hdHRpbmcgaXMgbm90IGludGVycHJldGVkLiAqKVxubGV0IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmb3JtYXR0aW5nX2xpdCA9IG1hdGNoIGZvcm1hdHRpbmdfbGl0IHdpdGhcbiAgfCBDbG9zZV9ib3ggICAgICAgICAgICAtPiBcIkBdXCJcbiAgfCBDbG9zZV90YWcgICAgICAgICAgICAtPiBcIkB9XCJcbiAgfCBCcmVhayAoc3RyLCBfLCBfKSAgICAtPiBzdHJcbiAgfCBGRmx1c2ggICAgICAgICAgICAgICAtPiBcIkA/XCJcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAtPiBcIkBcXG5cIlxuICB8IEZsdXNoX25ld2xpbmUgICAgICAgIC0+IFwiQC5cIlxuICB8IE1hZ2ljX3NpemUgKHN0ciwgXykgIC0+IHN0clxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgIC0+IFwiQEBcIlxuICB8IEVzY2FwZWRfcGVyY2VudCAgICAgIC0+IFwiQCVcIlxuICB8IFNjYW5faW5kaWMgYyAtPiBcIkBcIiBeIChTdHJpbmcubWFrZSAxIGMpXG5cbigqKiopXG5cbigqIFByaW50IGEgbGl0ZXJhbCBjaGFyIGluIGEgYnVmZmVyLCBlc2NhcGUgJyUnIGJ5IFwiJSVcIi4gKilcbmxldCBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBjaHIgPSBtYXRjaCBjaHIgd2l0aFxuICB8ICclJyAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlJVwiXG4gIHwgXyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmIGNoclxuXG4oKiBQcmludCBhIGxpdGVyYWwgc3RyaW5nIGluIGEgYnVmZmVyLCBlc2NhcGUgYWxsICclJyBieSBcIiUlXCIuICopXG5sZXQgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBzdHIgPVxuICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzdHIgLSAxIGRvXG4gICAgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgc3RyLltpXVxuICBkb25lXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBwcmV0dHktcHJpbnRpbmcgKilcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmb3JtYXQgdHlwZSAoYW4gZm10dHkpIGluIGEgYnVmZmVyLiAqKVxubGV0IHJlYyBicHJpbnRfZm10dHkgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCBpIGogayBsIC5cbiAgICBidWZmZXIgLT4gKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwpIGZtdHR5X3JlbCAtPiB1bml0ID1cbmZ1biBidWYgZm10dHkgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IENoYXJfdHkgcmVzdCAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVjXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXNcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlaVwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludDMyX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVsaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJW5pXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlTGlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEZsb2F0X3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVmXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQm9vbF90eSByZXN0ICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJUJcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBBbHBoYV90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlYVwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFRoZXRhX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV0XCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQW55X3R5IHJlc3QgICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJT9cIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBSZWFkZXJfdHkgcmVzdCAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlclwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVfclwiO1xuICAgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcblxuICB8IEZvcm1hdF9hcmdfdHkgKHN1Yl9mbXR0eSwgcmVzdCkgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIle1wiOyBicHJpbnRfZm10dHkgYnVmIHN1Yl9mbXR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlfVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgRm9ybWF0X3N1YnN0X3R5IChzdWJfZm10dHksIF8sIHJlc3QpIC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJShcIjsgYnByaW50X2ZtdHR5IGJ1ZiBzdWJfZm10dHk7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgRW5kX29mX2ZtdHR5IC0+ICgpXG5cbigqKiopXG5cbmxldCByZWMgaW50X29mX2N1c3RvbV9hcml0eSA6IHR5cGUgYSBiIGMgLlxuICAoYSwgYiwgYykgY3VzdG9tX2FyaXR5IC0+IGludCA9XG4gIGZ1bmN0aW9uXG4gIHwgQ3VzdG9tX3plcm8gLT4gMFxuICB8IEN1c3RvbV9zdWNjIHggLT4gMSArIGludF9vZl9jdXN0b21fYXJpdHkgeFxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZvcm1hdCBpbiBhIGJ1ZmZlci4gKilcbmxldCBicHJpbnRfZm10IGJ1ZiBmbXQgPVxuICBsZXQgcmVjIGZtdGl0ZXIgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYm9vbCAtPiB1bml0ID1cbiAgZnVuIGZtdCBpZ25fZmxhZyAtPiBtYXRjaCBmbXQgd2l0aFxuICAgIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdzJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdTJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2ludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ2wnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICduJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICdMJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2Zsb2F0X2ZtdCBidWYgaWduX2ZsYWcgZmNvbnYgcGFkIHByZWM7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IENoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnYyc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdDJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnQic7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBBbHBoYSByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdhJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgVGhldGEgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAndCc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpIC0+XG4gICAgICBmb3IgX2kgPSAxIHRvIGludF9vZl9jdXN0b21fYXJpdHkgYXJpdHkgZG9cbiAgICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICc/JztcbiAgICAgIGRvbmU7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBSZWFkZXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAncic7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZsdXNoIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUhXCI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIHN0cjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcbiAgICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgICAgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgY2hyO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuXG4gICAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0OyBidWZmZXJfYWRkX2NoYXIgYnVmICd7JztcbiAgICAgIGJwcmludF9mbXR0eSBidWYgZm10dHk7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICd9JztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgcGFkX29wdDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKCc7XG4gICAgICBicHJpbnRfZm10dHkgYnVmIGZtdHR5OyBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKSc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgd2lkdGhfb3B0OyBicHJpbnRfY2hhcl9zZXQgYnVmIGNoYXJfc2V0O1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfY291bnRlciBjb3VudGVyKTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgXCIwY1wiOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICAgIGxldCBQYXJhbV9mb3JtYXRfRUJCIGZtdCcgPSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3QgaW5cbiAgICAgIGZtdGl0ZXIgZm10JyB0cnVlO1xuXG4gICAgfCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgKHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0KTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcbiAgICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggZm10aW5nX2dlbiB3aXRoXG4gICAgICB8IE9wZW5fdGFnIChGb3JtYXQgKF8sIHN0cikpIC0+XG4gICAgICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIkB7XCI7IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBzdHJcbiAgICAgIHwgT3Blbl9ib3ggKEZvcm1hdCAoXywgc3RyKSkgLT5cbiAgICAgICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiQFtcIjsgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIHN0clxuICAgICAgZW5kO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuXG4gICAgfCBFbmRfb2ZfZm9ybWF0IC0+ICgpXG5cbiAgaW4gZm10aXRlciBmbXQgZmFsc2VcblxuKCoqKilcblxuKCogQ29udmVydCBhIGZvcm1hdCB0byBzdHJpbmcuICopXG5sZXQgc3RyaW5nX29mX2ZtdCBmbXQgPVxuICBsZXQgYnVmID0gYnVmZmVyX2NyZWF0ZSAxNiBpblxuICBicHJpbnRfZm10IGJ1ZiBmbXQ7XG4gIGJ1ZmZlcl9jb250ZW50cyBidWZcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVHlwZSBleHRyYWN0aW9uICopXG5cbnR5cGUgKF8sIF8pIGVxID0gUmVmbCA6ICgnYSwgJ2EpIGVxXG5cbigqIEludmFyaWFudDogdGhpcyBmdW5jdGlvbiBpcyB0aGUgaWRlbnRpdHkgb24gdmFsdWVzLlxuXG4gICBJbiBwYXJ0aWN1bGFyLCBpZiAodHkxLCB0eTIpIGhhdmUgZXF1YWwgdmFsdWVzLCB0aGVuXG4gICAodHJhbnMgKHN5bW0gdHkxKSB0eTIpIHJlc3BlY3RzIHRoZSAndHJhbnMnIHByZWNvbmRpdGlvbi4gKilcbmxldCByZWMgc3ltbSA6IHR5cGUgYTEgYjEgYzEgZDEgZTEgZjEgYTIgYjIgYzIgZDIgZTIgZjIgLlxuICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4tPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMixcbiAgICBhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXR0eV9yZWxcbj0gZnVuY3Rpb25cbiAgfCBDaGFyX3R5IHJlc3QgLT4gQ2hhcl90eSAoc3ltbSByZXN0KVxuICB8IEludF90eSByZXN0IC0+IEludF90eSAoc3ltbSByZXN0KVxuICB8IEludDMyX3R5IHJlc3QgLT4gSW50MzJfdHkgKHN5bW0gcmVzdClcbiAgfCBJbnQ2NF90eSByZXN0IC0+IEludDY0X3R5IChzeW1tIHJlc3QpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT4gTmF0aXZlaW50X3R5IChzeW1tIHJlc3QpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPiBGbG9hdF90eSAoc3ltbSByZXN0KVxuICB8IEJvb2xfdHkgcmVzdCAtPiBCb29sX3R5IChzeW1tIHJlc3QpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT4gU3RyaW5nX3R5IChzeW1tIHJlc3QpXG4gIHwgVGhldGFfdHkgcmVzdCAtPiBUaGV0YV90eSAoc3ltbSByZXN0KVxuICB8IEFscGhhX3R5IHJlc3QgLT4gQWxwaGFfdHkgKHN5bW0gcmVzdClcbiAgfCBBbnlfdHkgcmVzdCAtPiBBbnlfdHkgKHN5bW0gcmVzdClcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPiBSZWFkZXJfdHkgKHN5bW0gcmVzdClcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+IElnbm9yZWRfcmVhZGVyX3R5IChzeW1tIHJlc3QpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIHN5bW0gcmVzdClcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkyLCB0eTEsIHN5bW0gcmVzdClcbiAgfCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG5cbmxldCByZWMgZm10dHlfcmVsX2RldCA6IHR5cGUgYTEgYiBjIGQxIGUxIGYxIGEyIGQyIGUyIGYyIC5cbiAgKGExLCBiLCBjLCBkMSwgZTEsIGYxLFxuICAgYTIsIGIsIGMsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbCAtPlxuICAgICgoZjEsIGYyKSBlcSAtPiAoYTEsIGEyKSBlcSlcbiAgKiAoKGExLCBhMikgZXEgLT4gKGYxLCBmMikgZXEpXG4gICogKChlMSwgZTIpIGVxIC0+IChkMSwgZDIpIGVxKVxuICAqICgoZDEsIGQyKSBlcSAtPiAoZTEsIGUyKSBlcSlcbj0gZnVuY3Rpb25cbiAgfCBFbmRfb2ZfZm10dHkgLT5cbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbClcbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgSW50MzJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnQ2NF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuXG4gIHwgVGhldGFfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBBbHBoYV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IFJlYWRlcl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGVkIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZGUgUmVmbCBpbiBSZWZsKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG4gIHwgRm9ybWF0X2FyZ190eSAoX3R5LCByZXN0KSAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgbGV0IGFnLCBnYSwgZGosIGpkID0gZm10dHlfcmVsX2RldCB0eSBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gbGV0IFJlZmwgPSBhZyBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGdhIFJlZmwgaW4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGVkIFJlZmwgaW4gbGV0IFJlZmwgPSBkaiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGpkIFJlZmwgaW4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG5cbigqIFByZWNvbmRpdGlvbjogd2UgYXNzdW1lIHRoYXQgdGhlIHR3byBmbXR0eV9yZWwgYXJndW1lbnRzIGhhdmUgZXF1YWxcbiAgIHZhbHVlcyAoYXQgcG9zc2libHkgZGlzdGluY3QgdHlwZXMpOyB0aGlzIGludmFyaWFudCBjb21lcyBmcm9tIHRoZSB3YXlcbiAgIGZtdHR5X3JlbCB3aXRuZXNzZXMgYXJlIHByb2R1Y2VkIGJ5IHRoZSB0eXBlLWNoZWNrZXJcblxuICAgVGhlIGNvZGUgYmVsb3cgdXNlcyAoYXNzZXJ0IGZhbHNlKSB3aGVuIHRoaXMgYXNzdW1wdGlvbiBpcyBicm9rZW4uIFRoZVxuICAgY29kZSBwYXR0ZXJuIGlzIHRoZSBmb2xsb3dpbmc6XG5cbiAgICAgfCBGb28geCwgRm9vIHkgLT5cbiAgICAgICAoKiBjYXNlIHdoZXJlIGluZGVlZCBib3RoIHZhbHVlc1xuICAgICAgICAgIHN0YXJ0IHdpdGggY29uc3RydWN0b3IgRm9vICopXG4gICAgIHwgRm9vIF8sIF9cbiAgICAgfCBfLCBGb28gXyAtPlxuICAgICAgICgqIGRpZmZlcmVudCBoZWFkIGNvbnN0cnVjdG9yczogYnJva2VuIHByZWNvbmRpdGlvbiAqKVxuICAgICAgIGFzc2VydCBmYWxzZVxuKilcbmFuZCB0cmFucyA6IHR5cGVcbiAgYTEgYjEgYzEgZDEgZTEgZjFcbiAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgYTMgYjMgYzMgZDMgZTMgZjNcbi5cbiAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbFxuLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIsXG4gICAgYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHlfcmVsXG4tPiAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eV9yZWxcbj0gZnVuIHR5MSB0eTIgLT4gbWF0Y2ggdHkxLCB0eTIgd2l0aFxuICB8IENoYXJfdHkgcmVzdDEsIENoYXJfdHkgcmVzdDIgLT4gQ2hhcl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgU3RyaW5nX3R5IHJlc3QxLCBTdHJpbmdfdHkgcmVzdDIgLT4gU3RyaW5nX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBCb29sX3R5IHJlc3QxLCBCb29sX3R5IHJlc3QyIC0+IEJvb2xfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludF90eSByZXN0MSwgSW50X3R5IHJlc3QyIC0+IEludF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50MzJfdHkgcmVzdDEsIEludDMyX3R5IHJlc3QyIC0+IEludDMyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnQ2NF90eSByZXN0MSwgSW50NjRfdHkgcmVzdDIgLT4gSW50NjRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IE5hdGl2ZWludF90eSByZXN0MSwgTmF0aXZlaW50X3R5IHJlc3QyIC0+IE5hdGl2ZWludF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRmxvYXRfdHkgcmVzdDEsIEZsb2F0X3R5IHJlc3QyIC0+IEZsb2F0X3R5ICh0cmFucyByZXN0MSByZXN0MilcblxuICB8IEFscGhhX3R5IHJlc3QxLCBBbHBoYV90eSByZXN0MiAtPiBBbHBoYV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQWxwaGFfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBBbHBoYV90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgVGhldGFfdHkgcmVzdDEsIFRoZXRhX3R5IHJlc3QyIC0+IFRoZXRhX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBUaGV0YV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIFRoZXRhX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBBbnlfdHkgcmVzdDEsIEFueV90eSByZXN0MiAtPiBBbnlfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEFueV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEFueV90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgUmVhZGVyX3R5IHJlc3QxLCBSZWFkZXJfdHkgcmVzdDIgLT4gUmVhZGVyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBSZWFkZXJfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBSZWFkZXJfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QxLCBJZ25vcmVkX3JlYWRlcl90eSByZXN0MiAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIElnbm9yZWRfcmVhZGVyX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBGb3JtYXRfYXJnX3R5ICh0eTEsIHJlc3QxKSwgRm9ybWF0X2FyZ190eSAodHkyLCByZXN0MikgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0cmFucyB0eTEgdHkyLCB0cmFucyByZXN0MSByZXN0MilcbiAgfCBGb3JtYXRfYXJnX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRm9ybWF0X2FyZ190eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTExLCB0eTEyLCByZXN0MSksXG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTIxLCB0eTIyLCByZXN0MikgLT5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEyKSB0eTIxIGluXG4gICAgbGV0IF8sIGYyLCBfLCBmNCA9IGZtdHR5X3JlbF9kZXQgdHkgaW5cbiAgICBsZXQgUmVmbCA9IGYyIFJlZmwgaW5cbiAgICBsZXQgUmVmbCA9IGY0IFJlZmwgaW5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MTEsIHR5MjIsIHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZvcm1hdF9zdWJzdF90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEZvcm1hdF9zdWJzdF90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgRW5kX29mX2ZtdHR5LCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG4gIHwgRW5kX29mX2ZtdHR5LCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEVuZF9vZl9mbXR0eSAtPiBhc3NlcnQgZmFsc2VcblxubGV0IHJlYyBmbXR0eV9vZl9mb3JtYXR0aW5nX2dlbiA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm9ybWF0dGluZ19nZW4gLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGZvcm1hdHRpbmdfZ2VuIC0+IG1hdGNoIGZvcm1hdHRpbmdfZ2VuIHdpdGhcbiAgfCBPcGVuX3RhZyAoRm9ybWF0IChmbXQsIF8pKSAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgT3Blbl9ib3ggKEZvcm1hdCAoZm10LCBfKSkgLT4gZm10dHlfb2ZfZm10IGZtdFxuXG4oKiBFeHRyYWN0IHRoZSB0eXBlIHJlcHJlc2VudGF0aW9uIChhbiBmbXR0eSkgb2YgYSBmb3JtYXQuICopXG5hbmQgZm10dHlfb2ZfZm10IDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBmbXR0eSAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgKFN0cmluZ190eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgKFN0cmluZ190eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuXG4gIHwgSW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBJbnQzMiAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChJbnQzMl90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBOYXRpdmVpbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoTmF0aXZlaW50X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEludDY0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludDY0X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEZsb2F0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEZsb2F0X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuXG4gIHwgQ2hhciByZXN0ICAgICAgICAgICAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQ2FtbF9jaGFyIHJlc3QgICAgICAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQm9vbCAocGFkLCByZXN0KSAgICAgICAgICAgLT5cbiAgICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIChCb29sX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG4gIHwgQWxwaGEgcmVzdCAgICAgICAgICAgICAgICAgLT4gQWxwaGFfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFRoZXRhIHJlc3QgICAgICAgICAgICAgICAgIC0+IFRoZXRhX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBDdXN0b20gKGFyaXR5LCBfLCByZXN0KSAgICAtPiBmbXR0eV9vZl9jdXN0b20gYXJpdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFJlYWRlciByZXN0ICAgICAgICAgICAgICAgIC0+IFJlYWRlcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG5cbiAgfCBGb3JtYXRfYXJnIChfLCB0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0IChfLCB0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5LCB0eSwgZm10dHlfb2ZfZm10IHJlc3QpXG5cbiAgfCBGbHVzaCByZXN0ICAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IFN0cmluZ19saXRlcmFsIChfLCByZXN0KSAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG4gIHwgQ2hhcl9saXRlcmFsIChfLCByZXN0KSAgICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+IFN0cmluZ190eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgLT4gSW50X3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBTY2FuX25leHRfY2hhciByZXN0ICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpICAtPiBmbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCBpZ24gcmVzdFxuICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIHJlc3QpICAtPlxuICAgIGNvbmNhdF9mbXR0eSAoZm10dHlfb2ZfZm9ybWF0dGluZ19nZW4gZm10aW5nX2dlbikgKGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRW5kX29mX2Zvcm1hdCAgICAgICAgICAgICAgLT4gRW5kX29mX2ZtdHR5XG5cbmFuZCBmbXR0eV9vZl9jdXN0b20gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gIChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICh5LCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gYXJpdHkgZm10dHkgLT4gbWF0Y2ggYXJpdHkgd2l0aFxuICB8IEN1c3RvbV96ZXJvIC0+IGZtdHR5XG4gIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT4gQW55X3R5IChmbXR0eV9vZl9jdXN0b20gYXJpdHkgZm10dHkpXG5cbigqIEV4dHJhY3QgdGhlIGZtdHR5IG9mIGFuIGlnbm9yZWQgcGFyYW1ldGVyIGZvbGxvd2VkIGJ5IHRoZSByZXN0IG9mXG4gICB0aGUgZm9ybWF0LiAqKVxuYW5kIGZtdHR5X29mX2lnbm9yZWRfZm9ybWF0IDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBpZ25vcmVkIC0+XG4gICAgKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfaW50IChfLCBfKSAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfaW50MzIgKF8sIF8pICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfbmF0aXZlaW50IChfLCBfKSAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfaW50NjQgKF8sIF8pICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfZmxvYXQgKF8sIF8pICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyBfICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChfLCBmbXR0eSkgLT4gY29uY2F0X2ZtdHR5IGZtdHR5IChmbXR0eV9vZl9mbXQgZm10KVxuICB8IElnbm9yZWRfcmVhZGVyICAgICAgICAgICAgICAgICAgLT4gSWdub3JlZF9yZWFkZXJfdHkgKGZtdHR5X29mX2ZtdCBmbXQpXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG5cbigqIEFkZCBhbiBJbnRfdHkgbm9kZSBpZiBwYWRkaW5nIGlzIHRha2VuIGFzIGFuIGV4dHJhIGFyZ3VtZW50IChleDogXCIlKnNcIikuICopXG5hbmQgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSA6IHR5cGUgeCBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIGEpIHBhZGRpbmcgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+ICh4LCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG4gIGZ1biBwYWQgZm10dHkgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgICB8IE5vX3BhZGRpbmcgICAgLT4gZm10dHlcbiAgICB8IExpdF9wYWRkaW5nIF8gLT4gZm10dHlcbiAgICB8IEFyZ19wYWRkaW5nIF8gLT4gSW50X3R5IGZtdHR5XG5cbigqIEFkZCBhbiBJbnRfdHkgbm9kZSBpZiBwcmVjaXNpb24gaXMgdGFrZW4gYXMgYW4gZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUuKmZcIikuKilcbmFuZCBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgOiB0eXBlIHggYSBiIGMgZCBlIGYgLlxuICAgICh4LCBhKSBwcmVjaXNpb24gLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+ICh4LCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG4gIGZ1biBwcmVjIGZtdHR5IC0+IG1hdGNoIHByZWMgd2l0aFxuICAgIHwgTm9fcHJlY2lzaW9uICAgIC0+IGZtdHR5XG4gICAgfCBMaXRfcHJlY2lzaW9uIF8gLT4gZm10dHlcbiAgICB8IEFyZ19wcmVjaXNpb24gICAtPiBJbnRfdHkgZm10dHlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgdHlwaW5nICopXG5cbigqIEV4Y2VwdGlvbiByYWlzZWQgd2hlbiBhIGZvcm1hdCBkb2VzIG5vdCBtYXRjaCBhIGdpdmVuIGZvcm1hdCB0eXBlLiAqKVxuZXhjZXB0aW9uIFR5cGVfbWlzbWF0Y2hcblxuKCogVHlwZSBhIHBhZGRpbmcuICopXG4oKiBUYWtlIGFuIEludF90eSBmcm9tIHRoZSBmbXR0eSBpZiB0aGUgaW50ZWdlciBzaG91bGQgYmUga2VwdCBhcyBhcmd1bWVudC4gKilcbigqIFJhaXNlIFR5cGVfbWlzbWF0Y2ggaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IHR5cGVfcGFkZGluZyA6IHR5cGUgYSBiIGMgZCBlIGYgeCB5IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBwYWRkaW5nX2ZtdHR5X2ViYiA9XG5mdW4gcGFkIGZtdHR5IC0+IG1hdGNoIHBhZCwgZm10dHkgd2l0aFxuICB8IE5vX3BhZGRpbmcsIF8gLT4gUGFkZGluZ19mbXR0eV9FQkIgKE5vX3BhZGRpbmcsIGZtdHR5KVxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIF8gLT4gUGFkZGluZ19mbXR0eV9FQkIgKExpdF9wYWRkaW5nIChwYWR0eSx3KSxmbXR0eSlcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgSW50X3R5IHJlc3QgLT4gUGFkZGluZ19mbXR0eV9FQkIgKEFyZ19wYWRkaW5nIHBhZHR5LHJlc3QpXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIENvbnZlcnQgYSAodXBhZGRpbmcsIHVwcmVjaXNpb24pIHRvIGEgKHBhZGRpbmcsIHByZWNpc2lvbikuICopXG4oKiBUYWtlIG9uZSBvciB0d28gSW50X3R5IGZyb20gdGhlIGZtdHR5IGlmIG5lZWRlZC4gKilcbigqIFJhaXNlIFR5cGVfbWlzbWF0Y2ggaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IHR5cGVfcGFkcHJlYyA6IHR5cGUgYSBiIGMgZCBlIGYgeCB5IHogLlxuICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeikgcHJlY2lzaW9uIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBwYWRwcmVjX2ZtdHR5X2ViYiA9XG5mdW4gcGFkIHByZWMgZm10dHkgLT4gbWF0Y2ggcHJlYywgdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gIHwgTm9fcHJlY2lzaW9uLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIE5vX3ByZWNpc2lvbiwgcmVzdClcbiAgfCBMaXRfcHJlY2lzaW9uIHAsIFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIHJlc3QpIC0+XG4gICAgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgTGl0X3ByZWNpc2lvbiBwLCByZXN0KVxuICB8IEFyZ19wcmVjaXNpb24sIFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIEludF90eSByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIEFyZ19wcmVjaXNpb24sIHJlc3QpXG4gIHwgXywgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuKCogVHlwZSBhIGZvcm1hdCBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG4oKiBJZiB0eXBpbmcgc3VjY2VlZCwgZ2VuZXJhdGUgYSBjb3B5IG9mIHRoZSBmb3JtYXQgd2l0aCB0aGUgc2FtZVxuICAgIHR5cGUgcGFyYW1ldGVycyBhcyB0aGUgZm10dHkuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCByZWMgdHlwZV9mb3JtYXQgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjIgIC5cbiAgICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdFxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdFxuPSBmdW4gZm10IGZtdHR5IC0+IG1hdGNoIHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkgd2l0aFxuICB8IEZtdF9mbXR0eV9FQkIgKGZtdCcsIEVuZF9vZl9mbXR0eSkgLT4gZm10J1xuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG5hbmQgdHlwZV9mb3JtYXRfZ2VuIDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRfZm10dHlfZWJiXG49IGZ1biBmbXQgZm10dHkgLT4gbWF0Y2ggZm10LCBmbXR0eSB3aXRoXG4gIHwgQ2hhciBmbXRfcmVzdCwgQ2hhcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKENoYXIgZm10JywgZm10dHknKVxuICB8IENhbWxfY2hhciBmbXRfcmVzdCwgQ2hhcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKENhbWxfY2hhciBmbXQnLCBmbXR0eScpXG4gIHwgU3RyaW5nIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBTdHJpbmdfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKFN0cmluZyAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBTdHJpbmdfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKENhbWxfc3RyaW5nIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50MzJfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEludDMyIChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgTmF0aXZlaW50X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludDY0X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgRmxvYXRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEJvb2wgKHBhZCwgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIEJvb2xfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEJvb2wgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBGbHVzaCBmbXRfcmVzdCwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGbHVzaCBmbXQnLCBmbXR0eScpXG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU3RyaW5nX2xpdGVyYWwgKHN0ciwgZm10JyksIGZtdHR5JylcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKENoYXJfbGl0ZXJhbCAoY2hyLCBmbXQnKSwgZm10dHknKVxuXG4gIHwgRm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5LCBmbXRfcmVzdCksXG4gICAgRm9ybWF0X2FyZ190eSAoc3ViX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgc3ViX2ZtdHR5IDw+IEZtdHR5X0VCQiBzdWJfZm10dHknIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5JywgZm10JyksIGZtdHR5JylcbiAgfCBGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpLFxuICAgIEZvcm1hdF9zdWJzdF90eSAoc3ViX2ZtdHR5MSwgX3N1Yl9mbXR0eTIsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWJfZm10dHkxKSB0aGVuXG4gICAgICByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID1cbiAgICAgIHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCAoZXJhc2VfcmVsIGZtdHR5X3Jlc3QpXG4gICAgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eTEsIGZtdCcpLCBmbXR0eScpXG4gICgqIFByaW50ZiBhbmQgRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBBbHBoYSBmbXRfcmVzdCwgQWxwaGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChBbHBoYSBmbXQnLCBmbXR0eScpXG4gIHwgVGhldGEgZm10X3Jlc3QsIFRoZXRhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoVGhldGEgZm10JywgZm10dHknKVxuXG4gICgqIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCBmbXQnKSwgZm10dHknKVxuICB8IEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nX2dlbiwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgdHlwZV9mb3JtYXR0aW5nX2dlbiBmb3JtYXR0aW5nX2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0XG5cbiAgKCogU2NhbmYgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IFJlYWRlciBmbXRfcmVzdCwgUmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoUmVhZGVyIGZtdCcsIGZtdHR5JylcbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXRfcmVzdCksIFN0cmluZ190eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGZtdCcpLCBmbXR0eScpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpLCBJbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXQnKSwgZm10dHknKVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICB0eXBlX2lnbm9yZWRfcGFyYW0gaWduIHJlc3QgZm10dHlfcmVzdFxuXG4gIHwgRW5kX29mX2Zvcm1hdCwgZm10dHlfcmVzdCAtPiBGbXRfZm10dHlfRUJCIChFbmRfb2ZfZm9ybWF0LCBmbXR0eV9yZXN0KVxuXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbmFuZCB0eXBlX2Zvcm1hdHRpbmdfZ2VuIDogdHlwZSBhMSBhMyBiMSBiMyBjMSBjMyBkMSBkMyBlMSBlMiBlMyBmMSBmMiBmMyAuXG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZvcm1hdHRpbmdfZ2VuIC0+XG4gICAgKGYxLCBiMSwgYzEsIGUxLCBlMiwgZjIpIGZtdCAtPlxuICAgIChhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eSAtPlxuICAgIChhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXRfZm10dHlfZWJiID1cbmZ1biBmb3JtYXR0aW5nX2dlbiBmbXQwIGZtdHR5MCAtPiBtYXRjaCBmb3JtYXR0aW5nX2dlbiB3aXRoXG4gIHwgT3Blbl90YWcgKEZvcm1hdCAoZm10MSwgc3RyKSkgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MiwgZm10dHkyKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQxIGZtdHR5MCBpblxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQzLCBmbXR0eTMpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDAgZm10dHkyIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdDIsIHN0cikpLCBmbXQzKSwgZm10dHkzKVxuICB8IE9wZW5fYm94IChGb3JtYXQgKGZtdDEsIHN0cikpIC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDIsIGZtdHR5MikgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MSBmbXR0eTAgaW5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MywgZm10dHkzKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQwIGZtdHR5MiBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQyLCBzdHIpKSwgZm10MyksIGZtdHR5MylcblxuKCogVHlwZSBhbiBJZ25vcmVkX3BhcmFtIG5vZGUgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuYW5kIHR5cGVfaWdub3JlZF9wYXJhbSA6IHR5cGUgcCBxIHggeSB6IHQgdSB2IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgeSwgeiwgdCwgcSwgcCkgaWdub3JlZCAtPlxuICAgIChwLCB5LCB6LCBxLCB1LCB2KSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10X2ZtdHR5X2ViYiA9XG5mdW4gaWduIGZtdCBmbXR0eSAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfaW50IF8gICAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfaW50MzIgXyAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfbmF0aXZlaW50IF8gICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfaW50NjQgXyAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZmxvYXQgXyAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5KSAtPlxuICAgIHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgKElnbm9yZWRfZm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5KSkgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eSkgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5JywgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSkgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5IGZtdCBmbXR0eSBpblxuICAgIEZtdF9mbXR0eV9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbXQnKSxcbiAgICAgICAgICAgICAgICAgICBmbXR0eScpXG4gIHwgSWdub3JlZF9yZWFkZXIgLT4gKFxuICAgIG1hdGNoIGZtdHR5IHdpdGhcbiAgICB8IElnbm9yZWRfcmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX3JlYWRlciwgZm10JyksIGZtdHR5JylcbiAgICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG5cbmFuZCB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIDogdHlwZSBhMSBhMiBiMSBiMiBjMSBjMiBkMSBkMiBlMSBlMiBmMSBmMiAuXG4gICAgKGEyLCBiMiwgYzIsIGQyLCBkMiwgYTIpIGlnbm9yZWQgLT5cbiAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10IC0+XG4gICAgKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5IC0+XG4gICAgKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdF9mbXR0eV9lYmJcbj0gZnVuIGlnbiBmbXQgZm10dHkgLT5cbiAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5IGluXG4gIEZtdF9mbXR0eV9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbiwgZm10JyksIGZtdHR5JylcblxuKCogVHlwaW5nIG9mIHRoZSBjb21wbGV4IGNhc2U6IFwiJV8oLi4uJSlcIi4gKilcbmFuZCB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiA6IHR5cGUgdyB4IHkgeiBwIHMgdCB1IGEgYiBjIGQgZSBmIC5cbiAgICAodywgeCwgeSwgeiwgcywgcCkgZm10dHkgLT5cbiAgICAocCwgeCwgeSwgcywgdCwgdSkgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eV9mbXRfZWJiID1cbmZ1biBzdWJfZm10dHkgZm10IGZtdHR5IC0+IG1hdGNoIHN1Yl9mbXR0eSwgZm10dHkgd2l0aFxuICB8IENoYXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQ2hhcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgU3RyaW5nX3R5IHN1Yl9mbXR0eV9yZXN0LCBTdHJpbmdfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoU3RyaW5nX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJbnRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEludDMyX3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnQzMl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJbnQzMl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgTmF0aXZlaW50X3R5IHN1Yl9mbXR0eV9yZXN0LCBOYXRpdmVpbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoTmF0aXZlaW50X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnQ2NF90eSBzdWJfZm10dHlfcmVzdCwgSW50NjRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50NjRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEZsb2F0X3R5IHN1Yl9mbXR0eV9yZXN0LCBGbG9hdF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGbG9hdF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgQm9vbF90eSBzdWJfZm10dHlfcmVzdCwgQm9vbF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChCb29sX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBBbHBoYV90eSBzdWJfZm10dHlfcmVzdCwgQWxwaGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQWxwaGFfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFRoZXRhX3R5IHN1Yl9mbXR0eV9yZXN0LCBUaGV0YV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChUaGV0YV90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgUmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0LCBSZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoUmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBzdWJfZm10dHlfcmVzdCwgSWdub3JlZF9yZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSWdub3JlZF9yZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuXG4gIHwgRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eSwgc3ViX2ZtdHR5X3Jlc3QpLFxuICAgIEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHknLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiBzdWIyX2ZtdHR5IDw+IEZtdHR5X0VCQiBzdWIyX2ZtdHR5JyB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5Jywgc3ViX2ZtdHR5X3Jlc3QnKSwgZm10JylcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHksICBzdWIyX2ZtdHR5LCAgc3ViX2ZtdHR5X3Jlc3QpLFxuICAgIEZvcm1hdF9zdWJzdF90eSAoc3ViMV9mbXR0eScsIHN1YjJfZm10dHknLCBmbXR0eV9yZXN0KSAtPlxuICAgICgqIFRPRE8gZGVmaW5lIEZtdHR5X3JlbF9FQkIgdG8gcmVtb3ZlIHRob3NlIGVyYXNlX3JlbCAqKVxuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjFfZm10dHkpIDw+IEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjFfZm10dHknKVxuICAgIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIyX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIyX2ZtdHR5JylcbiAgICB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IHN1Yl9mbXR0eScgPSB0cmFucyAoc3ltbSBzdWIxX2ZtdHR5Jykgc3ViMl9mbXR0eScgaW5cbiAgICBsZXQgXywgZjIsIF8sIGY0ID0gZm10dHlfcmVsX2RldCBzdWJfZm10dHknIGluXG4gICAgbGV0IFJlZmwgPSBmMiBSZWZsIGluXG4gICAgbGV0IFJlZmwgPSBmNCBSZWZsIGluXG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gKGVyYXNlX3JlbCBzdWJfZm10dHlfcmVzdCkgZm10IGZtdHR5X3Jlc3RcbiAgICBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEZvcm1hdF9zdWJzdF90eSAoc3ViMV9mbXR0eScsIHN1YjJfZm10dHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltbSBzdWJfZm10dHlfcmVzdCcpLFxuICAgICAgICAgICAgICAgICAgIGZtdCcpXG4gIHwgRW5kX29mX2ZtdHR5LCBmbXR0eSAtPlxuICAgIEZtdHR5X2ZtdF9FQkIgKEVuZF9vZl9mbXR0eSwgdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSlcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuKCogVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiBgcmVjYXN0YCBpcyBhIGJpdCBkaXNhcHBvaW50aW5nLiBUaGVcbiAgIGludmFyaWFudCBwcm92aWRlZCBieSB0aGUgdHlwZSBhcmUgdmVyeSBzdHJvbmc6IHRoZSBpbnB1dCBmb3JtYXQnc1xuICAgdHlwZSBpcyBpbiByZWxhdGlvbiB0byB0aGUgb3V0cHV0IHR5cGUncyBhcyB3aXRuZXNzZWQgYnkgdGhlXG4gICBmbXR0eV9yZWwgYXJndW1lbnQuIE9uZSB3b3VsZCBhdCBmaXJzdCBleHBlY3QgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgdG90YWwsIGFuZCBpbXBsZW1lbnRhYmxlIGJ5IGV4aGF1c3RpdmUgcGF0dGVybiBtYXRjaGluZy4gSW5zdGVhZCxcbiAgIHdlIHJldXNlIHRoZSBoaWdobHkgcGFydGlhbCBhbmQgbXVjaCBsZXNzIHdlbGwtZGVmaW5lZCBmdW5jdGlvblxuICAgYHR5cGVfZm9ybWF0YCB0aGF0IGhhcyBsb3N0IGFsbCBrbm93bGVkZ2Ugb2YgdGhlIGNvcnJlc3BvbmRlbmNlXG4gICBiZXR3ZWVuIHRoZSBhcmd1bWVudCdzIHR5cGVzLlxuXG4gICBCZXNpZGVzIHRoZSBmYWN0IHRoYXQgdGhpcyBmdW5jdGlvbiByZXVzZXMgYSBsb3Qgb2YgdGhlXG4gICBgdHlwZV9mb3JtYXRgIGxvZ2ljIChlZy46IHNlZWluZyBJbnRfdHkgaW4gdGhlIGZtdHR5IHBhcmFtZXRlciBkb2VzXG4gICBub3QgbGV0IHlvdSBtYXRjaCBvbiBJbnQgb25seSwgYXMgeW91IG1heSBpbiBmYWN0IGhhdmUgRmxvYXRcbiAgIChBcmdfcGFkZGluZywgLi4uKSAoXCIlLipkXCIpIGJlZ2lubmluZyB3aXRoIGFuIEludF90eSksIGl0IGlzIGFsc29cbiAgIGEgcGFydGlhbCBmdW5jdGlvbiwgYmVjYXVzZSB0aGUgdHlwaW5nIGluZm9ybWF0aW9uIGluIGEgZm9ybWF0IGlzXG4gICBub3QgcXVpdGUgZW5vdWdoIHRvIHJlY29uc3RydWN0IGl0IHVuYW1iaWd1b3VzbHkuIEZvciBleGFtcGxlLCB0aGVcbiAgIGZvcm1hdCB0eXBlcyBvZiBcIiVkJV9yXCIgYW5kIFwiJV9yJWRcIiBoYXZlIHRoZSBzYW1lIGZvcm1hdDZcbiAgIHBhcmFtZXRlcnMsIGJ1dCB0aGV5IGFyZSBub3QgYXQgYWxsIGV4Y2hhbmdlYWJsZSwgYW5kIHB1dHRpbmcgb25lXG4gICBpbiBwbGFjZSBvZiB0aGUgb3RoZXIgbXVzdCByZXN1bHQgaW4gYSBkeW5hbWljIGZhaWx1cmUuXG5cbiAgIEdpdmVuIHRoYXQ6XG4gICAtIHdlJ2QgaGF2ZSB0byBkdXBsaWNhdGUgYSBsb3Qgb2Ygbm9uLXRyaXZpYWwgdHlwaW5nIGxvZ2ljIGZyb20gdHlwZV9mb3JtYXRcbiAgIC0gdGhpcyB3b3VsZG4ndCBldmVuIGVsaW1pbmF0ZSAoYWxsKSB0aGUgZHluYW1pYyBmYWlsdXJlc1xuICAgd2UgZGVjaWRlZCB0byBqdXN0IHJldXNlIHR5cGVfZm9ybWF0IGRpcmVjdGx5IGZvciBub3cuXG4qKVxubGV0IHJlY2FzdCA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMlxuICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdFxuPSBmdW4gZm10IGZtdHR5IC0+XG4gIHR5cGVfZm9ybWF0IGZtdCAoZXJhc2VfcmVsIChzeW1tIGZtdHR5KSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUHJpbnRpbmcgdG9vbHMgKilcblxuKCogQWRkIHBhZGRpbmcgc3BhY2VzIGFyb3VuZCBhIHN0cmluZy4gKilcbmxldCBmaXhfcGFkZGluZyBwYWR0eSB3aWR0aCBzdHIgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHdpZHRoLCBwYWR0eSA9XG4gICAgYWJzIHdpZHRoLFxuICAgICgqIHdoaWxlIGxpdGVyYWwgcGFkZGluZyB3aWR0aHMgYXJlIGFsd2F5cyBub24tbmVnYXRpdmUsXG4gICAgICAgZHluYW1pY2FsbHktc2V0IHdpZHRocyAoQXJnX3BhZGRpbmcsIGVnLiAlKmQpIG1heSBiZSBuZWdhdGl2ZTtcbiAgICAgICB3ZSBpbnRlcnByZXQgdGhvc2UgYXMgc3BlY2lmeWluZyBhIHBhZGRpbmctdG8tdGhlLWxlZnQ7IHRoaXNcbiAgICAgICBtZWFucyB0aGF0ICcwJyBtYXkgZ2V0IGRyb3BwZWQgZXZlbiBpZiBpdCB3YXMgZXhwbGljaXRseSBzZXQsXG4gICAgICAgYnV0OlxuICAgICAgIC0gdGhpcyBpcyB3aGF0IHRoZSBsZWdhY3kgaW1wbGVtZW50YXRpb24gZG9lcywgYW5kXG4gICAgICAgICB3ZSBwcmVzZXJ2ZSBjb21wYXRpYmlsaXR5IGlmIHBvc3NpYmxlXG4gICAgICAgLSB3ZSBjb3VsZCBvbmx5IHNpZ25hbCB0aGlzIGlzc3VlIGJ5IGZhaWxpbmcgYXQgcnVudGltZSxcbiAgICAgICAgIHdoaWNoIGlzIG5vdCB2ZXJ5IG5pY2UuLi4gKilcbiAgICBpZiB3aWR0aCA8IDAgdGhlbiBMZWZ0IGVsc2UgcGFkdHkgaW5cbiAgaWYgd2lkdGggPD0gbGVuIHRoZW4gc3RyIGVsc2VcbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSB3aWR0aCAoaWYgcGFkdHkgPSBaZXJvcyB0aGVuICcwJyBlbHNlICcgJykgaW5cbiAgICBiZWdpbiBtYXRjaCBwYWR0eSB3aXRoXG4gICAgfCBMZWZ0ICAtPiBTdHJpbmcuYmxpdCBzdHIgMCByZXMgMCBsZW5cbiAgICB8IFJpZ2h0IC0+IFN0cmluZy5ibGl0IHN0ciAwIHJlcyAod2lkdGggLSBsZW4pIGxlblxuICAgIHwgWmVyb3Mgd2hlbiBsZW4gPiAwICYmIChzdHIuWzBdID0gJysnIHx8IHN0ci5bMF0gPSAnLScgfHwgc3RyLlswXSA9ICcgJykgLT5cbiAgICAgIEJ5dGVzLnNldCByZXMgMCBzdHIuWzBdO1xuICAgICAgU3RyaW5nLmJsaXQgc3RyIDEgcmVzICh3aWR0aCAtIGxlbiArIDEpIChsZW4gLSAxKVxuICAgIHwgWmVyb3Mgd2hlbiBsZW4gPiAxICYmIHN0ci5bMF0gPSAnMCcgJiYgKHN0ci5bMV0gPSAneCcgfHwgc3RyLlsxXSA9ICdYJykgLT5cbiAgICAgIEJ5dGVzLnNldCByZXMgMSBzdHIuWzFdO1xuICAgICAgU3RyaW5nLmJsaXQgc3RyIDIgcmVzICh3aWR0aCAtIGxlbiArIDIpIChsZW4gLSAyKVxuICAgIHwgWmVyb3MgLT5cbiAgICAgIFN0cmluZy5ibGl0IHN0ciAwIHJlcyAod2lkdGggLSBsZW4pIGxlblxuICAgIGVuZDtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBBZGQgJzAnIHBhZGRpbmcgdG8gaW50LCBpbnQzMiwgbmF0aXZlaW50IG9yIGludDY0IHN0cmluZyByZXByZXNlbnRhdGlvbi4gKilcbmxldCBmaXhfaW50X3ByZWNpc2lvbiBwcmVjIHN0ciA9XG4gIGxldCBwcmVjID0gYWJzIHByZWMgaW5cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIG1hdGNoIHN0ci5bMF0gd2l0aFxuICB8ICgnKycgfCAnLScgfCAnICcpIGFzIGMgd2hlbiBwcmVjICsgMSA+IGxlbiAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIChwcmVjICsgMSkgJzAnIGluXG4gICAgQnl0ZXMuc2V0IHJlcyAwIGM7XG4gICAgU3RyaW5nLmJsaXQgc3RyIDEgcmVzIChwcmVjIC0gbGVuICsgMikgKGxlbiAtIDEpO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgJzAnIHdoZW4gcHJlYyArIDIgPiBsZW4gJiYgbGVuID4gMSAmJiAoc3RyLlsxXSA9ICd4JyB8fCBzdHIuWzFdID0gJ1gnKSAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIChwcmVjICsgMikgJzAnIGluXG4gICAgQnl0ZXMuc2V0IHJlcyAxIHN0ci5bMV07XG4gICAgU3RyaW5nLmJsaXQgc3RyIDIgcmVzIChwcmVjIC0gbGVuICsgNCkgKGxlbiAtIDIpO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgJzAnIC4uICc5JyB8ICdhJyAuLiAnZicgfCAnQScgLi4gJ0YnIHdoZW4gcHJlYyA+IGxlbiAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIHByZWMgJzAnIGluXG4gICAgU3RyaW5nLmJsaXQgc3RyIDAgcmVzIChwcmVjIC0gbGVuKSBsZW47XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgfCBfIC0+XG4gICAgc3RyXG5cbigqIEVzY2FwZSBhIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIE9DYW1sIGxleGluZyBjb252ZW50aW9uLiAqKVxubGV0IHN0cmluZ190b19jYW1sX3N0cmluZyBzdHIgPVxuICBsZXQgc3RyID0gU3RyaW5nLmVzY2FwZWQgc3RyIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKGwgKyAyKSAnXFxcIicgaW5cbiAgU3RyaW5nLnVuc2FmZV9ibGl0IHN0ciAwIHJlcyAxIGw7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbigqIEdlbmVyYXRlIHRoZSBmb3JtYXRfaW50L2ludDMyL25hdGl2ZWludC9pbnQ2NCBmaXJzdCBhcmd1bWVudFxuICAgZnJvbSBhbiBpbnRfY29udi4gKilcbmxldCBmb3JtYXRfb2ZfaWNvbnYgPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJWRcIiB8IEludF9wZCAtPiBcIiUrZFwiIHwgSW50X3NkIC0+IFwiJSBkXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVpXCIgfCBJbnRfcGkgLT4gXCIlK2lcIiB8IEludF9zaSAtPiBcIiUgaVwiXG4gIHwgSW50X3ggLT4gXCIleFwiIHwgSW50X0N4IC0+IFwiJSN4XCJcbiAgfCBJbnRfWCAtPiBcIiVYXCIgfCBJbnRfQ1ggLT4gXCIlI1hcIlxuICB8IEludF9vIC0+IFwiJW9cIiB8IEludF9DbyAtPiBcIiUjb1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIldVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZMID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVMZFwiIHwgSW50X3BkIC0+IFwiJStMZFwiIHwgSW50X3NkIC0+IFwiJSBMZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlTGlcIiB8IEludF9waSAtPiBcIiUrTGlcIiB8IEludF9zaSAtPiBcIiUgTGlcIlxuICB8IEludF94IC0+IFwiJUx4XCIgfCBJbnRfQ3ggLT4gXCIlI0x4XCJcbiAgfCBJbnRfWCAtPiBcIiVMWFwiIHwgSW50X0NYIC0+IFwiJSNMWFwiXG4gIHwgSW50X28gLT4gXCIlTG9cIiB8IEludF9DbyAtPiBcIiUjTG9cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJUx1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udmwgPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJWxkXCIgfCBJbnRfcGQgLT4gXCIlK2xkXCIgfCBJbnRfc2QgLT4gXCIlIGxkXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVsaVwiIHwgSW50X3BpIC0+IFwiJStsaVwiIHwgSW50X3NpIC0+IFwiJSBsaVwiXG4gIHwgSW50X3ggLT4gXCIlbHhcIiB8IEludF9DeCAtPiBcIiUjbHhcIlxuICB8IEludF9YIC0+IFwiJWxYXCIgfCBJbnRfQ1ggLT4gXCIlI2xYXCJcbiAgfCBJbnRfbyAtPiBcIiVsb1wiIHwgSW50X0NvIC0+IFwiJSNsb1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIlbHVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252biA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlbmRcIiB8IEludF9wZCAtPiBcIiUrbmRcIiB8IEludF9zZCAtPiBcIiUgbmRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJW5pXCIgfCBJbnRfcGkgLT4gXCIlK25pXCIgfCBJbnRfc2kgLT4gXCIlIG5pXCJcbiAgfCBJbnRfeCAtPiBcIiVueFwiIHwgSW50X0N4IC0+IFwiJSNueFwiXG4gIHwgSW50X1ggLT4gXCIlblhcIiB8IEludF9DWCAtPiBcIiUjblhcIlxuICB8IEludF9vIC0+IFwiJW5vXCIgfCBJbnRfQ28gLT4gXCIlI25vXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiVudVwiXG5cbigqIEdlbmVyYXRlIHRoZSBmb3JtYXRfZmxvYXQgZmlyc3QgYXJndW1lbnQgZnJvbSBhIGZsb2F0X2NvbnYuICopXG5sZXQgZm9ybWF0X29mX2Zjb252IGZjb252IHByZWMgPVxuICAgIGxldCBwcmVjID0gYWJzIHByZWMgaW5cbiAgICBsZXQgc3ltYiA9IGNoYXJfb2ZfZmNvbnYgfmNGOidnJyBmY29udiBpblxuICAgIGxldCBidWYgPSBidWZmZXJfY3JlYXRlIDE2IGluXG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252O1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy4nO1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoSW50LnRvX3N0cmluZyBwcmVjKTtcbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmIHN5bWI7XG4gICAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG5sZXQgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgcyA9XG4gIG1hdGNoIGljb252IHdpdGhcbiAgfCBJbnRfQ2QgfCBJbnRfQ2kgfCBJbnRfQ3UgLT5cbiAgICBsZXQgZGlnaXRzID1cbiAgICAgIGxldCBuID0gcmVmIDAgaW5cbiAgICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgICAgIG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICAgIHwgJzAnLi4nOScgLT4gaW5jciBuXG4gICAgICAgIHwgXyAtPiAoKVxuICAgICAgZG9uZTtcbiAgICAgICFuXG4gICAgaW5cbiAgICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIChTdHJpbmcubGVuZ3RoIHMgKyAoZGlnaXRzIC0gMSkgLyAzKSBpblxuICAgIGxldCBwb3MgPSByZWYgMCBpblxuICAgIGxldCBwdXQgYyA9IEJ5dGVzLnNldCBidWYgIXBvcyBjOyBpbmNyIHBvcyBpblxuICAgIGxldCBsZWZ0ID0gcmVmICgoZGlnaXRzIC0gMSkgbW9kIDMgKyAxKSBpblxuICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgICBtYXRjaCBTdHJpbmcudW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgfCAnMCcuLic5JyBhcyBjIC0+XG4gICAgICAgICAgaWYgIWxlZnQgPSAwIHRoZW4gKHB1dCAnXyc7IGxlZnQgOj0gMyk7IGRlY3IgbGVmdDsgcHV0IGNcbiAgICAgIHwgYyAtPiBwdXQgY1xuICAgIGRvbmU7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBidWZcbiAgfCBfIC0+IHNcblxuKCogQ29udmVydCBhbiBpbnRlZ2VyIHRvIGEgc3RyaW5nIGFjY29yZGluZyB0byBhIGNvbnZlcnNpb24uICopXG5sZXQgY29udmVydF9pbnQgaWNvbnYgbiA9XG4gIHRyYW5zZm9ybV9pbnRfYWx0IGljb252IChmb3JtYXRfaW50IChmb3JtYXRfb2ZfaWNvbnYgaWNvbnYpIG4pXG5sZXQgY29udmVydF9pbnQzMiBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9pbnQzMiAoZm9ybWF0X29mX2ljb252bCBpY29udikgbilcbmxldCBjb252ZXJ0X25hdGl2ZWludCBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9uYXRpdmVpbnQgKGZvcm1hdF9vZl9pY29udm4gaWNvbnYpIG4pXG5sZXQgY29udmVydF9pbnQ2NCBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9pbnQ2NCAoZm9ybWF0X29mX2ljb252TCBpY29udikgbilcblxuKCogQ29udmVydCBhIGZsb2F0IHRvIHN0cmluZy4gKilcbigqIEZpeCBzcGVjaWFsIGNhc2Ugb2YgXCJPQ2FtbCBmbG9hdCBmb3JtYXRcIi4gKilcbmxldCBjb252ZXJ0X2Zsb2F0IGZjb252IHByZWMgeCA9XG4gIGxldCBoZXggKCkgPVxuICAgIGxldCBzaWduID1cbiAgICAgIG1hdGNoIGZzdCBmY29udiB3aXRoXG4gICAgICB8IEZsb2F0X2ZsYWdfcCAtPiAnKydcbiAgICAgIHwgRmxvYXRfZmxhZ19zIC0+ICcgJ1xuICAgICAgfCBfIC0+ICctJyBpblxuICAgIGhleHN0cmluZ19vZl9mbG9hdCB4IHByZWMgc2lnbiBpblxuICBsZXQgYWRkX2RvdF9pZl9uZWVkZWQgc3RyID1cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgICBsZXQgcmVjIGlzX3ZhbGlkIGkgPVxuICAgICAgaWYgaSA9IGxlbiB0aGVuIGZhbHNlIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltpXSB3aXRoXG4gICAgICAgIHwgJy4nIHwgJ2UnIHwgJ0UnIC0+IHRydWVcbiAgICAgICAgfCBfIC0+IGlzX3ZhbGlkIChpICsgMSkgaW5cbiAgICBpZiBpc192YWxpZCAwIHRoZW4gc3RyIGVsc2Ugc3RyIF4gXCIuXCIgaW5cbiAgbGV0IGNhbWxfc3BlY2lhbF92YWwgc3RyID0gbWF0Y2ggY2xhc3NpZnlfZmxvYXQgeCB3aXRoXG4gICAgfCBGUF9ub3JtYWwgfCBGUF9zdWJub3JtYWwgfCBGUF96ZXJvIC0+IHN0clxuICAgIHwgRlBfaW5maW5pdGUgLT4gaWYgeCA8IDAuMCB0aGVuIFwibmVnX2luZmluaXR5XCIgZWxzZSBcImluZmluaXR5XCJcbiAgICB8IEZQX25hbiAtPiBcIm5hblwiIGluXG4gIG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfaCAtPiBoZXggKClcbiAgfCBGbG9hdF9IIC0+IFN0cmluZy51cHBlcmNhc2VfYXNjaWkgKGhleCAoKSlcbiAgfCBGbG9hdF9DRiAtPiBjYW1sX3NwZWNpYWxfdmFsIChoZXggKCkpXG4gIHwgRmxvYXRfRiAtPlxuICAgIGxldCBzdHIgPSBmb3JtYXRfZmxvYXQgKGZvcm1hdF9vZl9mY29udiBmY29udiBwcmVjKSB4IGluXG4gICAgY2FtbF9zcGVjaWFsX3ZhbCAoYWRkX2RvdF9pZl9uZWVkZWQgc3RyKVxuICB8IEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRSB8IEZsb2F0X2cgfCBGbG9hdF9HIC0+XG4gICAgZm9ybWF0X2Zsb2F0IChmb3JtYXRfb2ZfZmNvbnYgZmNvbnYgcHJlYykgeFxuXG4oKiBDb252ZXJ0IGEgY2hhciB0byBhIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIE9DYW1sIGxleGljYWwgY29udmVudGlvbi4gKilcbmxldCBmb3JtYXRfY2FtbF9jaGFyIGMgPVxuICBsZXQgc3RyID0gQ2hhci5lc2NhcGVkIGMgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgcmVzID0gQnl0ZXMubWFrZSAobCArIDIpICdcXCcnIGluXG4gIFN0cmluZy51bnNhZmVfYmxpdCBzdHIgMCByZXMgMSBsO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBDb252ZXJ0IGEgZm9ybWF0IHR5cGUgdG8gc3RyaW5nICopXG5sZXQgc3RyaW5nX29mX2ZtdHR5IGZtdHR5ID1cbiAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTtcbiAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgKCogR2VuZXJpYyBwcmludGluZyBmdW5jdGlvbiAqKVxuXG4oKiBNYWtlIGEgZ2VuZXJpYyBwcmludGluZyBmdW5jdGlvbi4gKilcbigqIFVzZWQgdG8gZ2VuZXJhdGUgUHJpbnRmIGFuZCBGb3JtYXQgcHJpbnRpbmcgZnVuY3Rpb25zLiAqKVxuKCogUGFyYW1ldGVyczpcbiAgICAgazogYSBjb250aW51YXRpb24gZmluYWxseSBhcHBsaWVkIHRvIHRoZSBvdXRwdXQgc3RyZWFtIGFuZCB0aGUgYWNjdW11bGF0b3IuXG4gICAgIG86IHRoZSBvdXRwdXQgc3RyZWFtIChzZWUgaywgJWEgYW5kICV0KS5cbiAgICAgYWNjOiByZXYgbGlzdCBvZiBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzaCwgZm9ybWF0dGluZywgLi4uKS5cbiAgICAgZm10OiB0aGUgZm9ybWF0LiAqKVxubGV0IHJlYyBtYWtlX3ByaW50ZiA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICB8IENoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX2NoYXIgKGFjYywgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICBmdW4gYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZm9ybWF0X2NhbWxfY2hhciBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBtYWtlX3BhZGRpbmcgayBhY2MgcmVzdCBwYWQgKGZ1biBzdHIgLT4gc3RyKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgYWNjIHJlc3QgcGFkIHN0cmluZ190b19jYW1sX3N0cmluZ1xuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50IGljb252XG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludDMyIGljb252XG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9uYXRpdmVpbnQgaWNvbnZcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50NjQgaWNvbnZcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2Zsb2F0X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgZmNvbnZcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgYWNjIHJlc3QgcGFkIHN0cmluZ19vZl9ib29sXG4gIHwgQWxwaGEgcmVzdCAtPlxuICAgIGZ1biBmIHggLT4gbWFrZV9wcmludGYgayAoQWNjX2RlbGF5IChhY2MsIGZ1biBvIC0+IGYgbyB4KSkgcmVzdFxuICB8IFRoZXRhIHJlc3QgLT5cbiAgICBmdW4gZiAtPiBtYWtlX3ByaW50ZiBrIChBY2NfZGVsYXkgKGFjYywgZikpIHJlc3RcbiAgfCBDdXN0b20gKGFyaXR5LCBmLCByZXN0KSAtPlxuICAgIG1ha2VfY3VzdG9tIGsgYWNjIHJlc3QgYXJpdHkgKGYgKCkpXG4gIHwgUmVhZGVyIF8gLT5cbiAgICAoKiBUaGlzIGNhc2UgaXMgaW1wb3NzaWJsZSwgYnkgdHlwaW5nIG9mIGZvcm1hdHMuICopXG4gICAgKCogSW5kZWVkLCBzaW5jZSBwcmludGYgYW5kIGNvLiB0YWtlIGEgZm9ybWF0NCBhcyBhcmd1bWVudCwgdGhlICdkIGFuZCAnZVxuICAgICAgIHR5cGUgcGFyYW1ldGVycyBvZiBmbXQgYXJlIG9idmlvdXNseSBlcXVhbHMuIFRoZSBSZWFkZXIgaXMgdGhlXG4gICAgICAgb25seSBjb25zdHJ1Y3RvciB3aGljaCB0b3VjaCAnZCBhbmQgJ2UgdHlwZSBwYXJhbWV0ZXJzIG9mIHRoZSBmb3JtYXRcbiAgICAgICB0eXBlLCBpdCBhZGRzIGFuICgtPikgdG8gdGhlICdkIHBhcmFtZXRlcnMuIENvbnNlcXVlbnRseSwgYSBmb3JtYXQ0XG4gICAgICAgY2Fubm90IGNvbnRhaW4gYSBSZWFkZXIgbm9kZSwgZXhjZXB0IGluIHRoZSBzdWItZm9ybWF0IGFzc29jaWF0ZWQgdG9cbiAgICAgICBhbiAley4uLiV9LiBJdCdzIG5vdCBhIHByb2JsZW0gYmVjYXVzZSBtYWtlX3ByaW50ZiBkbyBub3QgY2FsbFxuICAgICAgIGl0c2VsZiByZWN1cnNpdmVseSBvbiB0aGUgc3ViLWZvcm1hdCBhc3NvY2lhdGVkIHRvICV7Li4uJX0uICopXG4gICAgYXNzZXJ0IGZhbHNlXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mbHVzaCBhY2MpIHJlc3RcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX3N0cmluZ19saXRlcmFsIChhY2MsIHN0cikpIHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2NfY2hhcl9saXRlcmFsIChhY2MsIGNocikpIHJlc3RcblxuICB8IEZvcm1hdF9hcmcgKF8sIHN1Yl9mbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgdHkgPSBzdHJpbmdfb2ZfZm10dHkgc3ViX2ZtdHR5IGluXG4gICAgKGZ1biBzdHIgLT5cbiAgICAgIGlnbm9yZSBzdHI7XG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgdHkpKSByZXN0KVxuICB8IEZvcm1hdF9zdWJzdCAoXywgZm10dHksIHJlc3QpIC0+XG4gICAgZnVuIChGb3JtYXQgKGZtdCwgXykpIC0+IG1ha2VfcHJpbnRmIGsgYWNjXG4gICAgICAoY29uY2F0X2ZtdCAocmVjYXN0IGZtdCBmbXR0eSkgcmVzdClcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+XG4gICAgbGV0IG5ld19hY2MgPSBBY2NfaW52YWxpZF9hcmcgKGFjYywgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVbXCIpIGluXG4gICAgZnVuIF8gLT4gbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAtPlxuICAgICgqIFRoaXMgY2FzZSBzaG91bGQgYmUgcmVmdXNlZCBmb3IgUHJpbnRmLiAqKVxuICAgICgqIEFjY2VwdGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiAqKVxuICAgICgqIEludGVycHJldCAlbCwgJW4gYW5kICVMIGFzICV1LiAqKVxuICAgIGZ1biBuIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmb3JtYXRfaW50IFwiJXVcIiBuKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgZnVuIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfY2hhciAoYWNjLCBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgbWFrZV9pZ25vcmVkX3BhcmFtIGsgYWNjIGlnbiByZXN0XG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2NfZm9ybWF0dGluZ19saXQgKGFjYywgZm10aW5nX2xpdCkpIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGxldCBrJyBrYWNjID1cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mb3JtYXR0aW5nX2dlbiAoYWNjLCBBY2Nfb3Blbl90YWcga2FjYykpIHJlc3QgaW5cbiAgICBtYWtlX3ByaW50ZiBrJyBFbmRfb2ZfYWNjIGZtdCdcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGxldCBrJyBrYWNjID1cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mb3JtYXR0aW5nX2dlbiAoYWNjLCBBY2Nfb3Blbl9ib3gga2FjYykpIHJlc3QgaW5cbiAgICBtYWtlX3ByaW50ZiBrJyBFbmRfb2ZfYWNjIGZtdCdcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBrIGFjY1xuXG4oKiBEZWxheSB0aGUgZXJyb3IgKEludmFsaWRfYXJndW1lbnQgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVfXCIpLiAqKVxuKCogR2VuZXJhdGUgZnVuY3Rpb25zIHRvIHRha2UgcmVtYWluaW5nIGFyZ3VtZW50cyAoYWZ0ZXIgdGhlIFwiJV9cIikuICopXG5hbmQgbWFrZV9pZ25vcmVkX3BhcmFtIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfbmF0aXZlaW50IChfLCBfKSAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgZm10dHkgZm10XG4gIHwgSWdub3JlZF9yZWFkZXIgICAgICAgICAgICAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcblxuXG4oKiBTcGVjaWFsIGNhc2Ugb2YgcHJpbnRmIFwiJV8oXCIuICopXG5hbmQgbWFrZV9mcm9tX2ZtdHR5IDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgZm10dHkgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGZtdHR5IGZtdCAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0ICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgSW50X3R5IHJlc3QgICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgSW50NjRfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgQm9vbF90eSByZXN0ICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgQWxwaGFfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBUaGV0YV90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBBbnlfdHkgcmVzdCAgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBSZWFkZXJfdHkgXyAgICAgICAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBfICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBGb3JtYXRfYXJnX3R5IChfLCByZXN0KSAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBFbmRfb2ZfZm10dHkgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgKGNvbmNhdF9mbXR0eSB0eSByZXN0KSBmbXRcblxuKCogSW5zZXJ0IGFuIEFjY19pbnZhbGlkX2FyZyBpbiB0aGUgYWNjdW11bGF0b3IgYW5kIGNvbnRpbnVlIHRvIGdlbmVyYXRlXG4gICBjbG9zdXJlcyB0byBnZXQgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMuICopXG5hbmQgbWFrZV9pbnZhbGlkX2FyZyA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGZtdCAtPlxuICBtYWtlX3ByaW50ZiBrIChBY2NfaW52YWxpZF9hcmcgKGFjYywgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVfXCIpKSBmbXRcblxuKCogRml4IHBhZGRpbmcsIHRha2UgaXQgYXMgYW4gZXh0cmEgaW50ZWdlciBhcmd1bWVudCBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9wYWRkaW5nIDogdHlwZSB4IHogYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHogLT4gYSkgcGFkZGluZyAtPiAoeiAtPiBzdHJpbmcpIC0+IHggPVxuICBmdW4gayBhY2MgZm10IHBhZCB0cmFucyAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgdHJhbnMgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHdpZHRoKSAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmaXhfcGFkZGluZyBwYWR0eSB3aWR0aCAodHJhbnMgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHkgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyBmbXRcblxuKCogRml4IHBhZGRpbmcgYW5kIHByZWNpc2lvbiBmb3IgaW50LCBpbnQzMiwgbmF0aXZlaW50IG9yIGludDY0LiAqKVxuKCogVGFrZSBvbmUgb3IgdHdvIGV4dHJhIGludGVnZXIgYXJndW1lbnRzIGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiA6IHR5cGUgeCB5IHogYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+IChpbnRfY29udiAtPiB6IC0+IHN0cmluZykgLT5cbiAgICBpbnRfY29udiAtPiB4ID1cbiAgZnVuIGsgYWNjIGZtdCBwYWQgcHJlYyB0cmFucyBpY29udiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gdHJhbnMgaWNvbnYgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuXG4oKiBDb252ZXJ0IGEgZmxvYXQsIGZpeCBwYWRkaW5nIGFuZCBwcmVjaXNpb24gaWYgbmVlZGVkLiAqKVxuKCogVGFrZSB0aGUgZmxvYXQgYXJndW1lbnQgYW5kIG9uZSBvciB0d28gZXh0cmEgaW50ZWdlciBhcmd1bWVudHMgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfZmxvYXRfcGFkZGluZ19wcmVjaXNpb24gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgZmxvYXQgLT4gYSkgcHJlY2lzaW9uIC0+IGZsb2F0X2NvbnYgLT4geCA9XG4gIGZ1biBrIGFjYyBmbXQgcGFkIHByZWMgZmNvbnYgLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgfCBOb19wYWRkaW5nLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgKGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252KSB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiBwIHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgKGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252KSB4IGluXG4gICAgICBsZXQgc3RyJyA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgc3RyIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyJykpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgKGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252KSB4IGluXG4gICAgICBsZXQgc3RyJyA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgc3RyIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyJykpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbmFuZCBtYWtlX2N1c3RvbSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gIChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4geCAtPiB5ID1cbiAgZnVuIGsgYWNjIHJlc3QgYXJpdHkgZiAtPiBtYXRjaCBhcml0eSB3aXRoXG4gIHwgQ3VzdG9tX3plcm8gLT4gbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIGYpKSByZXN0XG4gIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbWFrZV9jdXN0b20gayBhY2MgcmVzdCBhcml0eSAoZiB4KVxuXG5sZXQgY29uc3QgeCBfID0geFxuXG5sZXQgcmVjIG1ha2VfaXByaW50ZiA6IHR5cGUgYSBiIGMgZCBlIGYgc3RhdGUuXG4gIChzdGF0ZSAtPiBmKSAtPiBzdGF0ZSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuICBmdW4gayBvIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICAgIHwgQ2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBDYW1sX3N0cmluZyAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfc3RyaW5nIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9zdHJpbmcgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IEludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgSW50MzIgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IE5hdGl2ZWludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgSW50NjQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEZsb2F0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBCb29sIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQm9vbCAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEJvb2wgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IEFscGhhIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgVGhldGEgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfY3VzdG9tX2FyaXR5IGsgbyByZXN0IGFyaXR5XG4gICAgfCBSZWFkZXIgXyAtPlxuICAgICAgICAoKiBUaGlzIGNhc2UgaXMgaW1wb3NzaWJsZSwgYnkgdHlwaW5nIG9mIGZvcm1hdHMuICBTZWUgdGhlXG4gICAgICAgICAgIG5vdGUgaW4gdGhlIGNvcnJlc3BvbmRpbmcgY2FzZSBmb3IgbWFrZV9wcmludGYuICopXG4gICAgICAgIGFzc2VydCBmYWxzZVxuICAgIHwgRmx1c2ggcmVzdCAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IFN0cmluZ19saXRlcmFsIChfLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBGb3JtYXRfYXJnIChfLCBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgICAgZnVuIChGb3JtYXQgKGZtdCwgXykpIC0+XG4gICAgICAgICAgbWFrZV9pcHJpbnRmIGsgb1xuICAgICAgICAgICAgKGNvbmNhdF9mbXQgKHJlY2FzdCBmbXQgZm10dHkpIHJlc3QpXG4gICAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pZ25vcmVkX3BhcmFtIChmdW4gXyAtPiBrIG8pIChFbmRfb2ZfYWNjKSBpZ24gcmVzdFxuICAgIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIChmdW4ga29jIC0+IG1ha2VfaXByaW50ZiBrIGtvYyByZXN0KSBvIGZtdCdcbiAgICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiAoZnVuIGtvYyAtPiBtYWtlX2lwcmludGYgayBrb2MgcmVzdCkgbyBmbXQnXG4gICAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgICAgIGsgb1xuYW5kIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIDpcbiAgdHlwZSB4IHkgeiBhIGIgYyBkIGUgZiBzdGF0ZS5cbiAgKHN0YXRlIC0+IGYpIC0+IHN0YXRlIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+IHggPVxuICBmdW4gayBvIGZtdCBwYWQgcHJlYyAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAgICwgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IE5vX3BhZGRpbmcgICAsIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBOb19wYWRkaW5nICAgLCBBcmdfcHJlY2lzaW9uICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTGl0X3BhZGRpbmcgXywgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IExpdF9wYWRkaW5nIF8sIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpKVxuYW5kIGZuX29mX2N1c3RvbV9hcml0eSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIHN0YXRlLlxuICAoc3RhdGUgLT4gZikgLT5cbiAgc3RhdGUgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IHkgPVxuICBmdW4gayBvIGZtdCAtPiBmdW5jdGlvblxuICAgIHwgQ3VzdG9tX3plcm8gLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyBmbXRcbiAgICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+XG4gICAgICAgIGNvbnN0IChmbl9vZl9jdXN0b21fYXJpdHkgayBvIGZtdCBhcml0eSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQ29udGludWF0aW9ucyBmb3IgbWFrZV9wcmludGYgKilcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhbiBvdXRwdXRfc3RyZWFtLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgb3V0cHV0X2FjYyBvIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIHM7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIFwiQHtcIjsgb3V0cHV0X2FjYyBvIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIFwiQFtcIjsgb3V0cHV0X2FjYyBvIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIHNcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X2NoYXIgbyBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBmIG9cbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IGZsdXNoIG9cbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gb3V0cHV0X2FjYyBvIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIGJ1ZnB1dF9hY2MgYiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQHtcIjsgYnVmcHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkBbXCI7IGJ1ZnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IGJ1ZnB1dF9hY2MgYiBwOyBmIGJcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gYnVmcHV0X2FjYyBiIHA7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IGJ1ZnB1dF9hY2MgYiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYSBidWZmZXIuICopXG4oKiBEaWZmZXIgZnJvbSBidWZwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiAlYSBhbmQgJXQuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBzdHJwdXRfYWNjIGIgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHM7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkB7XCI7IHN0cnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAW1wiOyBzdHJwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHNcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9jaGFyIGIgY1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiAoZiAoKSlcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gc3RycHV0X2FjYyBiIHA7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IHN0cnB1dF9hY2MgYiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEVycm9yIG1hbmFnZW1lbnQgKilcblxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBwcmV0dHktcHJpbnRlZCBlcnJvciBtZXNzYWdlLiAqKVxubGV0IGZhaWx3aXRoX21lc3NhZ2UgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAyNTYgaW5cbiAgbGV0IGsgYWNjID0gc3RycHV0X2FjYyBidWYgYWNjOyBmYWlsd2l0aCAoQnVmZmVyLmNvbnRlbnRzIGJ1ZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdHRpbmcgdG9vbHMgKilcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhbiBvcGVuIGJsb2NrIGRlc2NyaXB0aW9uIChpbmRlbnQsIGJsb2NrX3R5cGUpICopXG5sZXQgb3Blbl9ib3hfb2Zfc3RyaW5nIHN0ciA9XG4gIGlmIHN0ciA9IFwiXCIgdGhlbiAoMCwgUHBfYm94KSBlbHNlXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgbGV0IGludmFsaWRfYm94ICgpID0gZmFpbHdpdGhfbWVzc2FnZSBcImludmFsaWQgYm94IGRlc2NyaXB0aW9uICVTXCIgc3RyIGluXG4gICAgbGV0IHJlYyBwYXJzZV9zcGFjZXMgaSA9XG4gICAgICBpZiBpID0gbGVuIHRoZW4gaSBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5baV0gd2l0aFxuICAgICAgICB8ICcgJyB8ICdcXHQnIC0+IHBhcnNlX3NwYWNlcyAoaSArIDEpXG4gICAgICAgIHwgXyAtPiBpXG4gICAgYW5kIHBhcnNlX2x3b3JkIGkgaiA9XG4gICAgICBpZiBqID0gbGVuIHRoZW4gaiBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5bal0gd2l0aFxuICAgICAgICB8ICdhJyAuLiAneicgLT4gcGFyc2VfbHdvcmQgaSAoaiArIDEpXG4gICAgICAgIHwgXyAtPiBqXG4gICAgYW5kIHBhcnNlX2ludCBpIGogPVxuICAgICAgaWYgaiA9IGxlbiB0aGVuIGogZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2pdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IHBhcnNlX2ludCBpIChqICsgMSlcbiAgICAgICAgfCBfIC0+IGogaW5cbiAgICBsZXQgd3N0YXJ0ID0gcGFyc2Vfc3BhY2VzIDAgaW5cbiAgICBsZXQgd2VuZCA9IHBhcnNlX2x3b3JkIHdzdGFydCB3c3RhcnQgaW5cbiAgICBsZXQgYm94X25hbWUgPSBTdHJpbmcuc3ViIHN0ciB3c3RhcnQgKHdlbmQgLSB3c3RhcnQpIGluXG4gICAgbGV0IG5zdGFydCA9IHBhcnNlX3NwYWNlcyB3ZW5kIGluXG4gICAgbGV0IG5lbmQgPSBwYXJzZV9pbnQgbnN0YXJ0IG5zdGFydCBpblxuICAgIGxldCBpbmRlbnQgPVxuICAgICAgaWYgbnN0YXJ0ID0gbmVuZCB0aGVuIDAgZWxzZVxuICAgICAgICB0cnkgaW50X29mX3N0cmluZyAoU3RyaW5nLnN1YiBzdHIgbnN0YXJ0IChuZW5kIC0gbnN0YXJ0KSlcbiAgICAgICAgd2l0aCBGYWlsdXJlIF8gLT4gaW52YWxpZF9ib3ggKCkgaW5cbiAgICBsZXQgZXhwX2VuZCA9IHBhcnNlX3NwYWNlcyBuZW5kIGluXG4gICAgaWYgZXhwX2VuZCA8PiBsZW4gdGhlbiBpbnZhbGlkX2JveCAoKTtcbiAgICBsZXQgYm94X3R5cGUgPSBtYXRjaCBib3hfbmFtZSB3aXRoXG4gICAgICB8IFwiXCIgfCBcImJcIiAtPiBQcF9ib3hcbiAgICAgIHwgXCJoXCIgICAgICAtPiBQcF9oYm94XG4gICAgICB8IFwidlwiICAgICAgLT4gUHBfdmJveFxuICAgICAgfCBcImh2XCIgICAgIC0+IFBwX2h2Ym94XG4gICAgICB8IFwiaG92XCIgICAgLT4gUHBfaG92Ym94XG4gICAgICB8IF8gICAgICAgIC0+IGludmFsaWRfYm94ICgpIGluXG4gICAgKGluZGVudCwgYm94X3R5cGUpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUGFyc2luZyB0b29scyAqKVxuXG4oKiBDcmVhdGUgYSBwYWRkaW5nX2ZtdF9lYmIgZnJvbSBhIHBhZGRpbmcgYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcGFkZGluZyB0byBkaXNqb2luIHRoZSB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnQgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3BhZGRpbmdfZm10X2ViYiA6IHR5cGUgeCB5IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgICAoXywgXywgXywgXywgXykgcGFkZGluZ19mbXRfZWJiID1cbmZ1biBwYWQgZm10IC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAgICAgICAgIC0+IFBhZGRpbmdfZm10X0VCQiAoTm9fcGFkZGluZywgZm10KVxuICB8IExpdF9wYWRkaW5nIChzLCB3KSAtPiBQYWRkaW5nX2ZtdF9FQkIgKExpdF9wYWRkaW5nIChzLCB3KSwgZm10KVxuICB8IEFyZ19wYWRkaW5nIHMgICAgICAtPiBQYWRkaW5nX2ZtdF9FQkIgKEFyZ19wYWRkaW5nIHMsIGZtdClcblxuKCogQ3JlYXRlIGEgcHJlY2lzaW9uX2ZtdF9lYmIgZnJvbSBhIHByZWNpc2lvbiBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwcmVjaXNpb24gdG8gZGlzam9pbiB0aGUgdHlwZSBwYXJhbWV0ZXJzIG9mIGFyZ3VtZW50IGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wcmVjaXNpb25fZm10X2ViYiA6IHR5cGUgeCB5IC5cbiAgICAoeCwgeSkgcHJlY2lzaW9uIC0+IChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAgIChfLCBfLCBfLCBfLCBfKSBwcmVjaXNpb25fZm10X2ViYiA9XG5mdW4gcHJlYyBmbXQgLT4gbWF0Y2ggcHJlYyB3aXRoXG4gIHwgTm9fcHJlY2lzaW9uICAgIC0+IFByZWNpc2lvbl9mbXRfRUJCIChOb19wcmVjaXNpb24sIGZtdClcbiAgfCBMaXRfcHJlY2lzaW9uIHAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKExpdF9wcmVjaXNpb24gcCwgZm10KVxuICB8IEFyZ19wcmVjaXNpb24gICAtPiBQcmVjaXNpb25fZm10X0VCQiAoQXJnX3ByZWNpc2lvbiwgZm10KVxuXG4oKiBDcmVhdGUgYSBwYWRwcmVjX2ZtdF9lYmIgZnJvbSBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHBhZGRpbmcgYW5kIHRoZSBwcmVjaXNpb24gdG8gZGlzam9pbiB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnRzXG4gICBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcGFkcHJlY19mbXRfZWJiIDogdHlwZSB4IHkgeiB0IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeiwgdCkgcHJlY2lzaW9uIC0+XG4gICAgKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgIChfLCBfLCBfLCBfLCBfKSBwYWRwcmVjX2ZtdF9lYmIgPVxuZnVuIHBhZCBwcmVjIGZtdCAtPlxuICBsZXQgUHJlY2lzaW9uX2ZtdF9FQkIgKHByZWMsIGZtdCcpID0gbWFrZV9wcmVjaXNpb25fZm10X2ViYiBwcmVjIGZtdCBpblxuICBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgICAgICAgICAtPiBQYWRwcmVjX2ZtdF9FQkIgKE5vX3BhZGRpbmcsIHByZWMsIGZtdCcpXG4gIHwgTGl0X3BhZGRpbmcgKHMsIHcpIC0+IFBhZHByZWNfZm10X0VCQiAoTGl0X3BhZGRpbmcgKHMsIHcpLCBwcmVjLCBmbXQnKVxuICB8IEFyZ19wYWRkaW5nIHMgICAgICAtPiBQYWRwcmVjX2ZtdF9FQkIgKEFyZ19wYWRkaW5nIHMsIHByZWMsIGZtdCcpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBwYXJzaW5nICopXG5cbigqIFBhcnNlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIGZvcm1hdCBhbmQgY3JlYXRlIGEgZm10X2ViYi4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSBpbiBjYXNlIG9mIGludmFsaWQgZm9ybWF0LiAqKVxubGV0IGZtdF9lYmJfb2Zfc3RyaW5nID9sZWdhY3lfYmVoYXZpb3Igc3RyID1cbiAgKCogUGFyYW1ldGVycyBuYW1pbmcgY29udmVudGlvbjogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gbGl0X3N0YXJ0OiBzdGFydCBvZiB0aGUgbGl0ZXJhbCBzZXF1ZW5jZS4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBzdHJfaW5kOiBjdXJyZW50IGluZGV4IGluIHRoZSBzdHJpbmcuICAgICAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIGVuZF9pbmQ6IGVuZCBvZiB0aGUgY3VycmVudCAoc3ViLSlmb3JtYXQuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gcGN0X2luZDogaW5kZXggb2YgdGhlICclJyBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICopXG4gICgqICAgLSB6ZXJvOiAgaXMgdGhlICcwJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIG1pbnVzOiBpcyB0aGUgJy0nIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gcGx1czogIGlzIHRoZSAnKycgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBoYXNoOiAgaXMgdGhlICcjJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHNwYWNlOiBpcyB0aGUgJyAnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gaWduOiAgIGlzIHRoZSAnXycgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBwYWQ6IHBhZGRpbmcgb2YgdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHByZWM6IHByZWNpc2lvbiBvZiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gc3ltYjogY2hhciByZXByZXNlbnRpbmcgdGhlIGNvbnZlcnNpb24gKCdjJywgJ3MnLCAnZCcsIC4uLikuICopXG4gICgqICAgLSBjaGFyX3NldDogc2V0IG9mIGNoYXJhY3RlcnMgYXMgYml0bWFwIChzZWUgc2NhbmYgJVsuLi5dKS4gICAgKilcblxuICBsZXQgbGVnYWN5X2JlaGF2aW9yID0gbWF0Y2ggbGVnYWN5X2JlaGF2aW9yIHdpdGhcbiAgICB8IFNvbWUgZmxhZyAtPiBmbGFnXG4gICAgfCBOb25lIC0+IHRydWVcbiAgKCogIFdoZW4gdGhpcyBmbGFnIGlzIGVuYWJsZWQsIHRoZSBmb3JtYXQgcGFyc2VyIHRyaWVzIHRvIGJlaGF2ZSBhc1xuICAgICAgdGhlIDw0LjAyIGltcGxlbWVudGF0aW9ucywgaW4gcGFydGljdWxhciBpdCBpZ25vcmVzIG1vc3QgYmVuaW5lXG4gICAgICBub25zZW5zaWNhbCBmb3JtYXQuIFdoZW4gdGhlIGZsYWcgaXMgZGlzYWJsZWQsIGl0IHdpbGwgcmVqZWN0IGFueVxuICAgICAgZm9ybWF0IHRoYXQgaXMgbm90IGFjY2VwdGVkIGJ5IHRoZSBzcGVjaWZpY2F0aW9uLlxuXG4gICAgICBBIHR5cGljYWwgZXhhbXBsZSB3b3VsZCBiZSBcIiUrIGRcIjogc3BlY2lmeWluZyBib3RoICcrJyAoaWYgdGhlXG4gICAgICBudW1iZXIgaXMgcG9zaXRpdmUsIHBhZCB3aXRoIGEgJysnIHRvIGdldCB0aGUgc2FtZSB3aWR0aCBhc1xuICAgICAgbmVnYXRpdmUgbnVtYmVycykgYW5kICcgJyAoaWYgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSwgcGFkIHdpdGhcbiAgICAgIGEgc3BhY2UpIGRvZXMgbm90IG1ha2Ugc2Vuc2UsIGJ1dCB0aGUgbGVnYWN5ICg8IDQuMDIpXG4gICAgICBpbXBsZW1lbnRhdGlvbiB3YXMgaGFwcHkgdG8ganVzdCBpZ25vcmUgdGhlIHNwYWNlLlxuICAqKVxuICBpblxuXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZS4gKilcbiAgbGV0IGludmFsaWRfZm9ybWF0X21lc3NhZ2Ugc3RyX2luZCBtc2cgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICVzXCJcbiAgICAgIHN0ciBzdHJfaW5kIG1zZ1xuICBpblxuXG4gICgqIFVzZWQgd2hlbiB0aGUgZW5kIG9mIHRoZSBmb3JtYXQgKG9yIHRoZSBjdXJyZW50IHN1Yi1mb3JtYXQpIHdhcyBlbmNvdW50ZXJlZFxuICAgICAgdW5leHBlY3RlZGx5LiAqKVxuICBsZXQgdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQgPVxuICAgIGludmFsaWRfZm9ybWF0X21lc3NhZ2UgZW5kX2luZFxuICAgICAgXCJ1bmV4cGVjdGVkIGVuZCBvZiBmb3JtYXRcIlxuICBpblxuXG4gICgqIFVzZWQgZm9yICUwYzogbm8gb3RoZXIgd2lkdGhzIGFyZSBpbXBsZW1lbnRlZCAqKVxuICBsZXQgaW52YWxpZF9ub25udWxsX2NoYXJfd2lkdGggc3RyX2luZCA9XG4gICAgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBzdHJfaW5kXG4gICAgICBcIm5vbi16ZXJvIHdpZHRocyBhcmUgdW5zdXBwb3J0ZWQgZm9yICVjIGNvbnZlcnNpb25zXCJcbiAgaW5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGFuIG9wdGlvbiBkZXBlbmRlbmN5XG4gICAgIHByb2JsZW0uICopXG4gIGxldCBpbnZhbGlkX2Zvcm1hdF93aXRob3V0IHN0cl9pbmQgYyBzID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCAnJWMnIHdpdGhvdXQgJXNcIlxuICAgICAgc3RyIHN0cl9pbmQgYyBzXG4gIGluXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGFuIHVuZXhwZWN0ZWRcbiAgICAgY2hhcmFjdGVyLiAqKVxuICBsZXQgZXhwZWN0ZWRfY2hhcmFjdGVyIHN0cl9pbmQgZXhwZWN0ZWQgcmVhZCA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCAlcyBleHBlY3RlZCwgcmVhZCAlQ1wiXG4gICAgICBzdHIgc3RyX2luZCBleHBlY3RlZCByZWFkXG4gIGluXG5cbiAgKCogUGFyc2UgdGhlIHN0cmluZyBmcm9tIGJlZ19pbmQgKGluY2x1ZGVkKSB0byBlbmRfaW5kIChleGNsdWRlZCkuICopXG4gIGxldCByZWMgcGFyc2UgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gYmVnX2luZCBlbmRfaW5kIC0+IHBhcnNlX2xpdGVyYWwgYmVnX2luZCBiZWdfaW5kIGVuZF9pbmRcblxuICAoKiBSZWFkIGxpdGVyYWwgY2hhcmFjdGVycyB1cCB0byAnJScgb3IgJ0AnIHNwZWNpYWwgY2hhcmFjdGVycy4gKilcbiAgYW5kIHBhcnNlX2xpdGVyYWwgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGxpdF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIGFkZF9saXRlcmFsIGxpdF9zdGFydCBzdHJfaW5kIEVuZF9vZl9mb3JtYXQgZWxzZVxuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICclJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlX2Zvcm1hdCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgZm10X3Jlc3RcbiAgICAgIHwgJ0AnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2VfYWZ0ZXJfYXQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIGFkZF9saXRlcmFsIGxpdF9zdGFydCBzdHJfaW5kIGZtdF9yZXN0XG4gICAgICB8IF8gLT5cbiAgICAgICAgcGFyc2VfbGl0ZXJhbCBsaXRfc3RhcnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG5cbiAgKCogUGFyc2UgYSBmb3JtYXQgYWZ0ZXIgJyUnICopXG4gIGFuZCBwYXJzZV9mb3JtYXQgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBlbmRfaW5kIC0+IHBhcnNlX2lnbiBwY3RfaW5kIChwY3RfaW5kICsgMSkgZW5kX2luZFxuXG4gIGFuZCBwYXJzZV9pZ24gOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ18nIC0+IHBhcnNlX2ZsYWdzIHBjdF9pbmQgKHN0cl9pbmQrMSkgZW5kX2luZCB0cnVlXG4gICAgICB8IF8gLT4gcGFyc2VfZmxhZ3MgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgZmFsc2VcblxuICBhbmQgcGFyc2VfZmxhZ3MgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmJcbiAgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgaWduIC0+XG4gICAgbGV0IHplcm8gPSByZWYgZmFsc2UgYW5kIG1pbnVzID0gcmVmIGZhbHNlXG4gICAgYW5kIHBsdXMgPSByZWYgZmFsc2UgYW5kIHNwYWNlID0gcmVmIGZhbHNlXG4gICAgYW5kIGhhc2ggPSByZWYgZmFsc2UgaW5cbiAgICBsZXQgc2V0X2ZsYWcgc3RyX2luZCBmbGFnID1cbiAgICAgICgqIGluIGxlZ2FjeSBtb2RlLCBkdXBsaWNhdGUgZmxhZ3MgYXJlIGFjY2VwdGVkICopXG4gICAgICBpZiAhZmxhZyAmJiBub3QgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIGR1cGxpY2F0ZSBmbGFnICVDXCJcbiAgICAgICAgICBzdHIgc3RyX2luZCBzdHIuW3N0cl9pbmRdO1xuICAgICAgZmxhZyA6PSB0cnVlO1xuICAgIGluXG4gICAgbGV0IHJlYyByZWFkX2ZsYWdzIHN0cl9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnMCcgLT4gc2V0X2ZsYWcgc3RyX2luZCB6ZXJvOyAgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICctJyAtPiBzZXRfZmxhZyBzdHJfaW5kIG1pbnVzOyByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJysnIC0+IHNldF9mbGFnIHN0cl9pbmQgcGx1czsgIHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnIycgLT4gc2V0X2ZsYWcgc3RyX2luZCBoYXNoOyByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJyAnIC0+IHNldF9mbGFnIHN0cl9pbmQgc3BhY2U7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCBfIC0+XG4gICAgICAgIHBhcnNlX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmRcbiAgICAgICAgICAhemVybyAhbWludXMgIXBsdXMgIWhhc2ggIXNwYWNlIGlnblxuICAgICAgZW5kXG4gICAgaW5cbiAgICByZWFkX2ZsYWdzIHN0cl9pbmRcblxuICAoKiBUcnkgdG8gcmVhZCBhIGRpZ2l0YWwgb3IgYSAnKicgcGFkZGluZy4gKilcbiAgYW5kIHBhcnNlX3BhZGRpbmcgOiB0eXBlIGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCB6ZXJvIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGxldCBwYWR0eSA9IG1hdGNoIHplcm8sIG1pbnVzIHdpdGhcbiAgICAgIHwgZmFsc2UsIGZhbHNlIC0+IFJpZ2h0XG4gICAgICB8IGZhbHNlLCB0cnVlICAtPiBMZWZ0XG4gICAgICB8ICB0cnVlLCBmYWxzZSAtPiBaZXJvc1xuICAgICAgfCAgdHJ1ZSwgdHJ1ZSAgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGVmdFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnLScgXCIwXCIgaW5cbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgLT5cbiAgICAgIGxldCBuZXdfaW5kLCB3aWR0aCA9IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwIGluXG4gICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgbmV3X2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgKExpdF9wYWRkaW5nIChwYWR0eSwgd2lkdGgpKVxuICAgIHwgJyonIC0+XG4gICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZVxuICAgICAgICBpZ24gKEFyZ19wYWRkaW5nIHBhZHR5KVxuICAgIHwgXyAtPlxuICAgICAgYmVnaW4gbWF0Y2ggcGFkdHkgd2l0aFxuICAgICAgfCBMZWZ0ICAtPlxuICAgICAgICBpZiBub3QgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgICBpbnZhbGlkX2Zvcm1hdF93aXRob3V0IChzdHJfaW5kIC0gMSkgJy0nIFwicGFkZGluZ1wiO1xuICAgICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICBOb19wYWRkaW5nXG4gICAgICB8IFplcm9zIC0+XG4gICAgICAgICAoKiBhICcwJyBwYWRkaW5nIGluZGljYXRpb24gbm90IGZvbGxvd2VkIGJ5IGFueXRoaW5nIHNob3VsZFxuICAgICAgICAgICBiZSBpbnRlcnByZXRlZCBhcyBhIFJpZ2h0IHBhZGRpbmcgb2Ygd2lkdGggMC4gVGhpcyBpcyB1c2VkXG4gICAgICAgICAgIGJ5IHNjYW5uaW5nIGNvbnZlcnNpb25zICUwcyBhbmQgJTBjICopXG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIChMaXRfcGFkZGluZyAoUmlnaHQsIDApKVxuICAgICAgfCBSaWdodCAtPlxuICAgICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICBOb19wYWRkaW5nXG4gICAgICBlbmRcblxuICAoKiBJcyBwcmVjaXNpb24gZGVmaW5lZD8gKilcbiAgYW5kIHBhcnNlX2FmdGVyX3BhZGRpbmcgOiB0eXBlIHggZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoeCwgXykgcGFkZGluZyAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnLicgLT5cbiAgICAgIHBhcnNlX3ByZWNpc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIHBhZFxuICAgIHwgc3ltYiAtPlxuICAgICAgcGFyc2VfY29udmVyc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZFxuICAgICAgICBOb19wcmVjaXNpb24gcGFkIHN5bWJcblxuICAoKiBSZWFkIHRoZSBkaWdpdGFsIG9yICcqJyBwcmVjaXNpb24uICopXG4gIGFuZCBwYXJzZV9wcmVjaXNpb24gOiB0eXBlIHggZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoeCwgXykgcGFkZGluZyAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhcnNlX2xpdGVyYWwgbWludXMgc3RyX2luZCA9XG4gICAgICBsZXQgbmV3X2luZCwgcHJlYyA9IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwIGluXG4gICAgICBwYXJzZV9hZnRlcl9wcmVjaXNpb24gcGN0X2luZCBuZXdfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICBwYWQgKExpdF9wcmVjaXNpb24gcHJlYykgaW5cbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgLT4gcGFyc2VfbGl0ZXJhbCBtaW51cyBzdHJfaW5kXG4gICAgfCAoJysnIHwgJy0nKSBhcyBzeW1iIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+XG4gICAgICAoKiBMZWdhY3kgbW9kZSB3b3VsZCBhY2NlcHQgYW5kIGlnbm9yZSAnKycgb3IgJy0nIGJlZm9yZSB0aGVcbiAgICAgICAgIGludGVnZXIgZGVzY3JpYmluZyB0aGUgZGVzaXJlZCBwcmVjaXNpb247IG5vdGUgdGhhdCB0aGlzXG4gICAgICAgICBjYW5ub3QgaGFwcGVuIGZvciBwYWRkaW5nIHdpZHRoLCBhcyAnKycgYW5kICctJyBhbHJlYWR5IGhhdmVcbiAgICAgICAgIGEgc2VtYW50aWNzIHRoZXJlLlxuXG4gICAgICAgICBUaGF0IHNhaWQsIHRoZSBpZGVhIChzdXBwb3J0ZWQgYnkgdGhpcyB0d2VhaykgdGhhdCB3aWR0aCBhbmRcbiAgICAgICAgIHByZWNpc2lvbiBsaXRlcmFscyBhcmUgXCJpbnRlZ2VyIGxpdGVyYWxzXCIgaW4gdGhlIE9DYW1sIHNlbnNlIGlzXG4gICAgICAgICBzdGlsbCBibGF0YW50bHkgd3JvbmcsIGFzIDEyM180NTYgb3IgMHhGRiBhcmUgcmVqZWN0ZWQuICopXG4gICAgICBwYXJzZV9saXRlcmFsIChtaW51cyB8fCBzeW1iID0gJy0nKSAoc3RyX2luZCArIDEpXG4gICAgfCAnKicgLT5cbiAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2VcbiAgICAgICAgaWduIHBhZCBBcmdfcHJlY2lzaW9uXG4gICAgfCBfIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAoKiBub3RlIHRoYXQgbGVnYWN5IGltcGxlbWVudGF0aW9uIGRpZCBub3QgaWdub3JlICcuJyB3aXRob3V0XG4gICAgICAgICAgIGEgbnVtYmVyIChhcyBpdCBkb2VzIGZvciBwYWRkaW5nIGluZGljYXRpb25zKSwgYnV0XG4gICAgICAgICAgIGludGVycHJldHMgaXQgYXMgJy4wJyAqKVxuICAgICAgICBwYXJzZV9hZnRlcl9wcmVjaXNpb24gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIHBhZCAoTGl0X3ByZWNpc2lvbiAwKVxuICAgICAgZWxzZVxuICAgICAgICBpbnZhbGlkX2Zvcm1hdF93aXRob3V0IChzdHJfaW5kIC0gMSkgJy4nIFwicHJlY2lzaW9uXCJcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgY29udmVyc2lvbi4gKilcbiAgYW5kIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiA6IHR5cGUgeCB5IHogdCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCB5KSBwYWRkaW5nIC0+ICh6LCB0KSBwcmVjaXNpb24gLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgcHJlYyAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhcnNlX2NvbnYgKHR5cGUgdSkgKHR5cGUgdikgKHBhZHByZWMgOiAodSwgdikgcGFkZGluZykgPVxuICAgICAgcGFyc2VfY29udmVyc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZFxuICAgICAgICBwcmVjIHBhZHByZWMgc3RyLltzdHJfaW5kXSBpblxuICAgICgqIGluIGxlZ2FjeSBtb2RlLCBzb21lIGZvcm1hdHMgKCVzIGFuZCAlUykgYWNjZXB0IGEgd2VpcmQgbWl4IG9mXG4gICAgICAgcGFkZGluZyBhbmQgcHJlY2lzaW9uLCB3aGljaCBpcyBtZXJnZWQgYXMgYSBzaW5nbGUgcGFkZGluZ1xuICAgICAgIGluZm9ybWF0aW9uLiBGb3IgZXhhbXBsZSwgaW4gJS4xMHMgdGhlIHByZWNpc2lvbiBpcyBpbXBsaWNpdGx5XG4gICAgICAgdW5kZXJzdG9vZCBhcyBwYWRkaW5nICUxMHMsIGJ1dCB0aGUgbGVmdC1wYWRkaW5nIGNvbXBvbmVudCBtYXlcbiAgICAgICBiZSBzcGVjaWZpZWQgZWl0aGVyIGFzIGEgbGVmdCBwYWRkaW5nIG9yIGEgbmVnYXRpdmUgcHJlY2lzaW9uOlxuICAgICAgICUtLjNzIGFuZCAlLi0zcyBhcmUgZXF1aXZhbGVudCB0byAlLTNzICopXG4gICAgbWF0Y2ggcGFkIHdpdGhcbiAgICB8IE5vX3BhZGRpbmcgLT4gKFxuICAgICAgbWF0Y2ggbWludXMsIHByZWMgd2l0aFxuICAgICAgICB8IF8sIE5vX3ByZWNpc2lvbiAtPiBwYXJzZV9jb252IE5vX3BhZGRpbmdcbiAgICAgICAgfCBmYWxzZSwgTGl0X3ByZWNpc2lvbiBuIC0+IHBhcnNlX2NvbnYgKExpdF9wYWRkaW5nIChSaWdodCwgbikpXG4gICAgICAgIHwgdHJ1ZSwgTGl0X3ByZWNpc2lvbiBuIC0+IHBhcnNlX2NvbnYgKExpdF9wYWRkaW5nIChMZWZ0LCBuKSlcbiAgICAgICAgfCBmYWxzZSwgQXJnX3ByZWNpc2lvbiAtPiBwYXJzZV9jb252IChBcmdfcGFkZGluZyBSaWdodClcbiAgICAgICAgfCB0cnVlLCBBcmdfcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgKEFyZ19wYWRkaW5nIExlZnQpXG4gICAgKVxuICAgIHwgcGFkIC0+IHBhcnNlX2NvbnYgcGFkXG5cbiAgKCogQ2FzZSBhbmFseXNpcyBvbiBjb252ZXJzaW9uLiAqKVxuICBhbmQgcGFyc2VfY29udmVyc2lvbiA6IHR5cGUgeCB5IHogdCB1IHYgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gKHgsIHkpIHBhZGRpbmcgLT5cbiAgICAgICAgKHosIHQpIHByZWNpc2lvbiAtPiAodSwgdikgcGFkZGluZyAtPiBjaGFyIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIHByZWMgcGFkcHJlYyBzeW1iIC0+XG4gICAgKCogRmxhZ3MgdXNlZCB0byBjaGVjayBvcHRpb24gdXNhZ2VzL2NvbXBhdGliaWxpdGllcy4gKilcbiAgICBsZXQgcGx1c191c2VkICA9IHJlZiBmYWxzZSBhbmQgaGFzaF91c2VkID0gcmVmIGZhbHNlXG4gICAgYW5kIHNwYWNlX3VzZWQgPSByZWYgZmFsc2UgYW5kIGlnbl91c2VkICAgPSByZWYgZmFsc2VcbiAgICBhbmQgcGFkX3VzZWQgICA9IHJlZiBmYWxzZSBhbmQgcHJlY191c2VkICA9IHJlZiBmYWxzZSBpblxuXG4gICAgKCogQWNjZXNzIHRvIG9wdGlvbnMsIHVwZGF0ZSBmbGFncy4gKilcbiAgICBsZXQgZ2V0X3BsdXMgICAgKCkgPSBwbHVzX3VzZWQgIDo9IHRydWU7IHBsdXNcbiAgICBhbmQgZ2V0X2hhc2ggICAoKSA9IGhhc2hfdXNlZCA6PSB0cnVlOyBoYXNoXG4gICAgYW5kIGdldF9zcGFjZSAgICgpID0gc3BhY2VfdXNlZCA6PSB0cnVlOyBzcGFjZVxuICAgIGFuZCBnZXRfaWduICAgICAoKSA9IGlnbl91c2VkICAgOj0gdHJ1ZTsgaWduXG4gICAgYW5kIGdldF9wYWQgICAgICgpID0gcGFkX3VzZWQgICA6PSB0cnVlOyBwYWRcbiAgICBhbmQgZ2V0X3ByZWMgICAgKCkgPSBwcmVjX3VzZWQgIDo9IHRydWU7IHByZWNcbiAgICBhbmQgZ2V0X3BhZHByZWMgKCkgPSBwYWRfdXNlZCAgIDo9IHRydWU7IHBhZHByZWMgaW5cblxuICAgIGxldCBnZXRfaW50X3BhZCAoKSA6ICh4LHkpIHBhZGRpbmcgPVxuICAgICAgKCogJTUuM2QgaXMgYWNjZXB0ZWQgYW5kIG1lYW5pbmdmdWw6IHBhZCB0byBsZW5ndGggNSB3aXRoXG4gICAgICAgICBzcGFjZXMsIGJ1dCBmaXJzdCBwYWQgd2l0aCB6ZXJvcyB1cHRvIGxlbmd0aCAzICgwLXBhZGRpbmdcbiAgICAgICAgIGlzIHRoZSBpbnRlcnByZXRhdGlvbiBvZiBcInByZWNpc2lvblwiIGZvciBpbnRlZ2VyIGZvcm1hdHMpLlxuXG4gICAgICAgICAlMDUuM2QgaXMgcmVkdW5kYW50OiBwYWQgdG8gbGVuZ3RoIDUgKndpdGggemVyb3MqLCBidXRcbiAgICAgICAgIGZpcnN0IHBhZCB3aXRoIHplcm9zLi4uIFRvIGFkZCBpbnN1bHQgdG8gdGhlIGluanVyeSwgdGhlXG4gICAgICAgICBsZWdhY3kgaW1wbGVtZW50YXRpb24gaWdub3JlcyB0aGUgMC1wYWRkaW5nIGluZGljYXRpb24gYW5kXG4gICAgICAgICBkb2VzIHRoZSA1IHBhZGRpbmcgd2l0aCBzcGFjZXMgaW5zdGVhZC4gV2UgcmV1c2UgdGhpc1xuICAgICAgICAgaW50ZXJwcmV0YXRpb24gZm9yIGNvbXBhdGliaWxpdHksIGJ1dCBzdGF0aWNhbGx5IHJlamVjdCB0aGlzXG4gICAgICAgICBmb3JtYXQgd2hlbiB0aGUgbGVnYWN5IG1vZGUgaXMgZGlzYWJsZWQsIHRvIHByb3RlY3Qgc3RyaWN0XG4gICAgICAgICB1c2VycyBmcm9tIHRoaXMgY29ybmVyIGNhc2UuICopXG4gICAgICAgbWF0Y2ggZ2V0X3BhZCAoKSwgZ2V0X3ByZWMgKCkgd2l0aFxuICAgICAgICAgfCBwYWQsIE5vX3ByZWNpc2lvbiAtPiBwYWRcbiAgICAgICAgIHwgTm9fcGFkZGluZywgXyAgICAgLT4gTm9fcGFkZGluZ1xuICAgICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIG4pLCBfIC0+XG4gICAgICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIExpdF9wYWRkaW5nIChSaWdodCwgbilcbiAgICAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJzAnIFwicHJlY2lzaW9uXCJcbiAgICAgICAgIHwgQXJnX3BhZGRpbmcgWmVyb3MsIF8gLT5cbiAgICAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gQXJnX3BhZGRpbmcgUmlnaHRcbiAgICAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJzAnIFwicHJlY2lzaW9uXCJcbiAgICAgICAgIHwgTGl0X3BhZGRpbmcgXyBhcyBwYWQsIF8gLT4gcGFkXG4gICAgICAgICB8IEFyZ19wYWRkaW5nIF8gYXMgcGFkLCBfIC0+IHBhZCBpblxuXG4gICAgKCogQ2hlY2sgdGhhdCBwYWR0eSA8PiBaZXJvcy4gKilcbiAgICBsZXQgY2hlY2tfbm9fMCBzeW1iICh0eXBlIGEgYikgKHBhZCA6IChhLCBiKSBwYWRkaW5nKSA6IChhLGIpIHBhZGRpbmcgPVxuICAgICAgbWF0Y2ggcGFkIHdpdGhcbiAgICAgIHwgTm9fcGFkZGluZyAtPiBwYWRcbiAgICAgIHwgTGl0X3BhZGRpbmcgKChMZWZ0IHwgUmlnaHQpLCBfKSAtPiBwYWRcbiAgICAgIHwgQXJnX3BhZGRpbmcgKExlZnQgfCBSaWdodCkgLT4gcGFkXG4gICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIExpdF9wYWRkaW5nIChSaWdodCwgd2lkdGgpXG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCIwXCJcbiAgICAgIHwgQXJnX3BhZGRpbmcgWmVyb3MgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gQXJnX3BhZGRpbmcgUmlnaHRcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIjBcIlxuICAgIGluXG5cbiAgICAoKiBHZXQgcGFkZGluZyBhcyBhIHBhZF9vcHRpb24gKHNlZSBcIiVfXCIsIFwiJXtcIiwgXCIlKFwiIGFuZCBcIiVbXCIpLlxuICAgICAgIChubyBuZWVkIGZvciBsZWdhY3kgbW9kZSB0d2Vha2luZywgdGhvc2Ugd2VyZSByZWplY3RlZCBieSB0aGVcbiAgICAgICBsZWdhY3kgcGFyc2VyIGFzIHdlbGwpICopXG4gICAgbGV0IG9wdF9vZl9wYWQgYyAodHlwZSBhKSAodHlwZSBiKSAocGFkIDogKGEsIGIpIHBhZGRpbmcpID0gbWF0Y2ggcGFkIHdpdGhcbiAgICAgIHwgTm9fcGFkZGluZyAtPiBOb25lXG4gICAgICB8IExpdF9wYWRkaW5nIChSaWdodCwgd2lkdGgpIC0+IFNvbWUgd2lkdGhcbiAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gU29tZSB3aWR0aFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBjIFwiJzAnXCJcbiAgICAgIHwgTGl0X3BhZGRpbmcgKExlZnQsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBTb21lIHdpZHRoXG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIGMgXCInLSdcIlxuICAgICAgfCBBcmdfcGFkZGluZyBfIC0+IGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBjIFwiJyonXCJcbiAgICBpblxuICAgIGxldCBnZXRfcGFkX29wdCBjID0gb3B0X29mX3BhZCBjIChnZXRfcGFkICgpKSBpblxuICAgIGxldCBnZXRfcGFkcHJlY19vcHQgYyA9IG9wdF9vZl9wYWQgYyAoZ2V0X3BhZHByZWMgKCkpIGluXG5cbiAgICAoKiBHZXQgcHJlY2lzaW9uIGFzIGEgcHJlY19vcHRpb24gKHNlZSBcIiVfZlwiKS5cbiAgICAgICAobm8gbmVlZCBmb3IgbGVnYWN5IG1vZGUgdHdlYWtpbmcsIHRob3NlIHdlcmUgcmVqZWN0ZWQgYnkgdGhlXG4gICAgICAgbGVnYWN5IHBhcnNlciBhcyB3ZWxsKSAqKVxuICAgIGxldCBnZXRfcHJlY19vcHQgKCkgPSBtYXRjaCBnZXRfcHJlYyAoKSB3aXRoXG4gICAgICB8IE5vX3ByZWNpc2lvbiAgICAgICAtPiBOb25lXG4gICAgICB8IExpdF9wcmVjaXNpb24gbmRlYyAtPiBTb21lIG5kZWNcbiAgICAgIHwgQXJnX3ByZWNpc2lvbiAgICAgIC0+IGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnXycgXCInKidcIlxuICAgIGluXG5cbiAgICBsZXQgZm10X3Jlc3VsdCA9IG1hdGNoIHN5bWIgd2l0aFxuICAgIHwgJywnIC0+XG4gICAgICBwYXJzZSBzdHJfaW5kIGVuZF9pbmRcbiAgICB8ICdjJyAtPlxuICAgICAgbGV0IGNoYXJfZm9ybWF0IGZtdF9yZXN0ID0gKCogJWMgKilcbiAgICAgICAgaWYgZ2V0X2lnbiAoKVxuICAgICAgICB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfY2hhciwgZm10X3Jlc3QpKVxuICAgICAgICBlbHNlIEZtdF9FQkIgKENoYXIgZm10X3Jlc3QpXG4gICAgICBpblxuICAgICAgbGV0IHNjYW5fZm9ybWF0IGZtdF9yZXN0ID0gKCogJTBjICopXG4gICAgICAgIGlmIGdldF9pZ24gKClcbiAgICAgICAgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX3NjYW5fbmV4dF9jaGFyLCBmbXRfcmVzdCkpXG4gICAgICAgIGVsc2UgRm10X0VCQiAoU2Nhbl9uZXh0X2NoYXIgZm10X3Jlc3QpXG4gICAgICBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGJlZ2luIG1hdGNoIGdldF9wYWRfb3B0ICdjJyB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBjaGFyX2Zvcm1hdCBmbXRfcmVzdFxuICAgICAgICB8IFNvbWUgMCAtPiBzY2FuX2Zvcm1hdCBmbXRfcmVzdFxuICAgICAgICB8IFNvbWUgX24gLT5cbiAgICAgICAgICAgaWYgbm90IGxlZ2FjeV9iZWhhdmlvclxuICAgICAgICAgICB0aGVuIGludmFsaWRfbm9ubnVsbF9jaGFyX3dpZHRoIHN0cl9pbmRcbiAgICAgICAgICAgZWxzZSAoKiBsZWdhY3kgaWdub3JlcyAlYyB3aWR0aHMgKikgY2hhcl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgIGVuZFxuICAgIHwgJ0MnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfY2FtbF9jaGFyLGZtdF9yZXN0KSlcbiAgICAgIGVsc2UgRm10X0VCQiAoQ2FtbF9jaGFyIGZtdF9yZXN0KVxuICAgIHwgJ3MnIC0+XG4gICAgICBsZXQgcGFkID0gY2hlY2tfbm9fMCBzeW1iIChnZXRfcGFkcHJlYyAoKSkgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3N0cmluZyAoZ2V0X3BhZHByZWNfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkZGluZ19mbXRfRUJCIChwYWQnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZGRpbmdfZm10X2ViYiBwYWQgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoU3RyaW5nIChwYWQnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ1MnIC0+XG4gICAgICBsZXQgcGFkID0gY2hlY2tfbm9fMCBzeW1iIChnZXRfcGFkcHJlYyAoKSkgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2NhbWxfc3RyaW5nIChnZXRfcGFkcHJlY19vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRkaW5nX2ZtdF9FQkIgKHBhZCcsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkZGluZ19mbXRfZWJiIHBhZCBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChDYW1sX3N0cmluZyAocGFkJywgZm10X3Jlc3QnKSlcbiAgICB8ICdkJyB8ICdpJyB8ICd4JyB8ICdYJyB8ICdvJyB8ICd1JyAtPlxuICAgICAgbGV0IGljb252ID0gY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpXG4gICAgICAgIChnZXRfc3BhY2UgKCkpIHN5bWIgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2ludCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ04nIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgbGV0IGNvdW50ZXIgPSBUb2tlbl9jb3VudGVyIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgY291bnRlciBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdF9yZXN0KSlcbiAgICB8ICdsJyB8ICduJyB8ICdMJyB3aGVuIHN0cl9pbmQ9ZW5kX2luZCB8fCBub3QgKGlzX2ludF9iYXNlIHN0ci5bc3RyX2luZF0pIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgbGV0IGNvdW50ZXIgPSBjb3VudGVyX29mX2NoYXIgc3ltYiBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIGNvdW50ZXIgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXRfcmVzdCkpXG4gICAgfCAnbCcgLT5cbiAgICAgIGxldCBpY29udiA9XG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCAoc3RyX2luZCArIDEpIChnZXRfcGx1cyAoKSkgKGdldF9oYXNoICgpKVxuICAgICAgICAgIChnZXRfc3BhY2UgKCkpIHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2ludDMyIChpY29udiwgZ2V0X3BhZF9vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X2ludF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoSW50MzIgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICduJyAtPlxuICAgICAgbGV0IGljb252ID1cbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIChzdHJfaW5kICsgMSkgKGdldF9wbHVzICgpKVxuICAgICAgICAgIChnZXRfaGFzaCAoKSkgKGdldF9zcGFjZSAoKSkgc3RyLltzdHJfaW5kXSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfbmF0aXZlaW50IChpY29udiwgZ2V0X3BhZF9vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X2ludF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoTmF0aXZlaW50IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnTCcgLT5cbiAgICAgIGxldCBpY29udiA9XG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCAoc3RyX2luZCArIDEpIChnZXRfcGx1cyAoKSkgKGdldF9oYXNoICgpKVxuICAgICAgICAgIChnZXRfc3BhY2UgKCkpIHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2ludDY0IChpY29udiwgZ2V0X3BhZF9vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X2ludF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoSW50NjQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdmJyB8ICdlJyB8ICdFJyB8ICdnJyB8ICdHJyB8ICdGJyB8ICdoJyB8ICdIJyAtPlxuICAgICAgbGV0IGZjb252ID1cbiAgICAgICAgY29tcHV0ZV9mbG9hdF9jb252IHBjdF9pbmQgc3RyX2luZFxuICAgICAgICAgIChnZXRfcGx1cyAoKSkgKGdldF9oYXNoICgpKSAoZ2V0X3NwYWNlICgpKSBzeW1iIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9mbG9hdCAoZ2V0X3BhZF9vcHQgJ18nLCBnZXRfcHJlY19vcHQgKCkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEZsb2F0IChmY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnYicgfCAnQicgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfYm9vbCAoZ2V0X3BhZHByZWNfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkZGluZ19mbXRfRUJCIChwYWQnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZGRpbmdfZm10X2ViYiBwYWQgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoQm9vbCAocGFkJywgZm10X3Jlc3QnKSlcbiAgICB8ICdhJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEFscGhhIGZtdF9yZXN0KVxuICAgIHwgJ3QnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoVGhldGEgZm10X3Jlc3QpXG4gICAgfCAncicgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9yZWFkZXIsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2UgRm10X0VCQiAoUmVhZGVyIGZtdF9yZXN0KVxuICAgIHwgJyEnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoRmx1c2ggZm10X3Jlc3QpXG4gICAgfCAoJyUnIHwgJ0AnKSBhcyBjIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoQ2hhcl9saXRlcmFsIChjLCBmbXRfcmVzdCkpXG4gICAgfCAneycgLT5cbiAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgc3RyX2luZCBlbmRfaW5kICd9JyBpblxuICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgc3ViX2VuZCBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3ViX2VuZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgIGxldCBzdWJfZm10dHkgPSBmbXR0eV9vZl9mbXQgc3ViX2ZtdCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9mb3JtYXRfYXJnIChnZXRfcGFkX29wdCAnXycsIHN1Yl9mbXR0eSkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChGb3JtYXRfYXJnIChnZXRfcGFkX29wdCAneycsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpKVxuICAgIHwgJygnIC0+XG4gICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCAnKScgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBzdWJfZm10ID0gcGFyc2Ugc3RyX2luZCBzdWJfZW5kIGluXG4gICAgICBsZXQgc3ViX2ZtdHR5ID0gZm10dHlfb2ZfZm10IHN1Yl9mbXQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZm9ybWF0X3N1YnN0IChnZXRfcGFkX29wdCAnXycsIHN1Yl9mbXR0eSkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChGb3JtYXRfc3Vic3QgKGdldF9wYWRfb3B0ICcoJywgc3ViX2ZtdHR5LCBmbXRfcmVzdCkpXG4gICAgfCAnWycgLT5cbiAgICAgIGxldCBuZXh0X2luZCwgY2hhcl9zZXQgPSBwYXJzZV9jaGFyX3NldCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgbmV4dF9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zY2FuX2NoYXJfc2V0IChnZXRfcGFkX29wdCAnXycsIGNoYXJfc2V0KSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKFNjYW5fY2hhcl9zZXQgKGdldF9wYWRfb3B0ICdbJywgY2hhcl9zZXQsIGZtdF9yZXN0KSlcbiAgICB8ICctJyB8ICcrJyB8ICcjJyB8ICcgJyB8ICdfJyAtPlxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgZmxhZyAlQyBpcyBvbmx5IGFsbG93ZWQgYWZ0ZXIgdGhlICclJScsIGJlZm9yZSBwYWRkaW5nIGFuZCBwcmVjaXNpb25cIlxuICAgICAgICBzdHIgcGN0X2luZCBzeW1iXG4gICAgfCBfIC0+XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIFxcXG4gICAgICAgICBpbnZhbGlkIGNvbnZlcnNpb24gXFxcIiUlJWNcXFwiXCIgc3RyIChzdHJfaW5kIC0gMSkgc3ltYlxuICAgIGluXG4gICAgKCogQ2hlY2sgZm9yIHVudXNlZCBvcHRpb25zLCBhbmQgcmVqZWN0IHRoZW0gYXMgaW5jb21wYXRpYmxlLlxuXG4gICAgICAgU3VjaCBjaGVja3MgbmVlZCB0byBiZSBkaXNhYmxlZCBpbiBsZWdhY3kgbW9kZSwgYXMgdGhlIGxlZ2FjeVxuICAgICAgIHBhcnNlciBzaWxlbnRseSBpZ25vcmVkIGluY29tcGF0aWJsZSBmbGFncy4gKilcbiAgICBpZiBub3QgbGVnYWN5X2JlaGF2aW9yIHRoZW4gYmVnaW5cbiAgICBpZiBub3QgIXBsdXNfdXNlZCAmJiBwbHVzIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJysnXCI7XG4gICAgaWYgbm90ICFoYXNoX3VzZWQgJiYgaGFzaCB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicjJ1wiO1xuICAgIGlmIG5vdCAhc3BhY2VfdXNlZCAmJiBzcGFjZSB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicgJ1wiO1xuICAgIGlmIG5vdCAhcGFkX3VzZWQgICYmIFBhZGRpbmdfRUJCIHBhZCA8PiBQYWRkaW5nX0VCQiBOb19wYWRkaW5nIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiYHBhZGRpbmcnXCI7XG4gICAgaWYgbm90ICFwcmVjX3VzZWQgJiYgUHJlY2lzaW9uX0VCQiBwcmVjIDw+IFByZWNpc2lvbl9FQkIgTm9fcHJlY2lzaW9uIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAoaWYgaWduIHRoZW4gJ18nIGVsc2Ugc3ltYilcbiAgICAgICAgXCJgcHJlY2lzaW9uJ1wiO1xuICAgIGlmIGlnbiAmJiBwbHVzIHRoZW4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICdfJyBcIicrJ1wiO1xuICAgIGVuZDtcbiAgICAoKiB0aGlzIGxhc3QgdGVzdCBtdXN0IG5vdCBiZSBkaXNhYmxlZCBpbiBsZWdhY3kgbW9kZSxcbiAgICAgICBhcyBpZ25vcmluZyBpdCB3b3VsZCB0eXBpY2FsbHkgcmVzdWx0IGluIGEgZGlmZmVyZW50IHR5cGluZ1xuICAgICAgIHRoYW4gd2hhdCB0aGUgbGVnYWN5IHBhcnNlciB1c2VkICopXG4gICAgaWYgbm90ICFpZ25fdXNlZCAmJiBpZ24gdGhlblxuICAgICAgYmVnaW4gbWF0Y2ggc3ltYiB3aXRoXG4gICAgICAgICgqIGFyZ3VtZW50LWxlc3MgZm9ybWF0cyBjYW4gc2FmZWx5IGJlIGlnbm9yZWQgaW4gbGVnYWN5IG1vZGUgKilcbiAgICAgICAgfCAoJ0AnIHwgJyUnIHwgJyEnIHwgJywnKSB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiAoKVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIidfJ1wiXG4gICAgICBlbmQ7XG4gICAgZm10X3Jlc3VsdFxuXG4gICgqIFBhcnNlIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24gKGFmdGVyICdAJykuICopXG4gIGFuZCBwYXJzZV9hZnRlcl9hdCA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoJ0AnLCBFbmRfb2ZfZm9ybWF0KSlcbiAgICBlbHNlXG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ1snIC0+XG4gICAgICAgIHBhcnNlX3RhZyBmYWxzZSAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChDbG9zZV9ib3gsIGZtdF9yZXN0KSlcbiAgICAgIHwgJ3snIC0+XG4gICAgICAgIHBhcnNlX3RhZyB0cnVlIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnfScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKENsb3NlX3RhZywgZm10X3Jlc3QpKVxuICAgICAgfCAnLCcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEJyZWFrIChcIkAsXCIsIDAsIDApLCBmbXRfcmVzdCkpXG4gICAgICB8ICcgJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQnJlYWsgKFwiQCBcIiwgMSwgMCksIGZtdF9yZXN0KSlcbiAgICAgIHwgJzsnIC0+XG4gICAgICAgIHBhcnNlX2dvb2RfYnJlYWsgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICc/JyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRkZsdXNoLCBmbXRfcmVzdCkpXG4gICAgICB8ICdcXG4nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChGb3JjZV9uZXdsaW5lLCBmbXRfcmVzdCkpXG4gICAgICB8ICcuJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRmx1c2hfbmV3bGluZSwgZm10X3Jlc3QpKVxuICAgICAgfCAnPCcgLT5cbiAgICAgICAgcGFyc2VfbWFnaWNfc2l6ZSAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJ0AnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChFc2NhcGVkX2F0LCBmbXRfcmVzdCkpXG4gICAgICB8ICclJyB3aGVuIHN0cl9pbmQgKyAxIDwgZW5kX2luZCAmJiBzdHIuW3N0cl9pbmQgKyAxXSA9ICclJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMikgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRXNjYXBlZF9wZXJjZW50LCBmbXRfcmVzdCkpXG4gICAgICB8ICclJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKCdAJywgZm10X3Jlc3QpKVxuICAgICAgfCBjIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChTY2FuX2luZGljIGMsIGZtdF9yZXN0KSlcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgb3B0aW9uYWwgPG5hbWU+IGFmdGVyIFwiQHtcIiBvciBcIkBbXCIuICopXG4gIGFuZCBwYXJzZV90YWcgOiB0eXBlIGUgZiAuIGJvb2wgLT4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBpc19vcGVuX3RhZyBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICB0cnlcbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICc8JyAtPlxuICAgICAgICBsZXQgaW5kID0gU3RyaW5nLmluZGV4X2Zyb20gc3RyIChzdHJfaW5kICsgMSkgJz4nIGluXG4gICAgICAgIGlmIGluZCA+PSBlbmRfaW5kIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgICBsZXQgc3ViX3N0ciA9IFN0cmluZy5zdWIgc3RyIHN0cl9pbmQgKGluZCAtIHN0cl9pbmQgKyAxKSBpblxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChpbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIGxldCBGbXRfRUJCIHN1Yl9mbXQgPSBwYXJzZSBzdHJfaW5kIChpbmQgKyAxKSBpblxuICAgICAgICBsZXQgc3ViX2Zvcm1hdCA9IEZvcm1hdCAoc3ViX2ZtdCwgc3ViX3N0cikgaW5cbiAgICAgICAgbGV0IGZvcm1hdHRpbmcgPVxuICAgICAgICAgIGlmIGlzX29wZW5fdGFnIHRoZW4gT3Blbl90YWcgc3ViX2Zvcm1hdCBlbHNlIE9wZW5fYm94IHN1Yl9mb3JtYXQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmcsIGZtdF9yZXN0KSlcbiAgICAgIHwgXyAtPlxuICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBzdWJfZm9ybWF0ID0gRm9ybWF0IChFbmRfb2ZfZm9ybWF0LCBcIlwiKSBpblxuICAgICAgbGV0IGZvcm1hdHRpbmcgPVxuICAgICAgICBpZiBpc19vcGVuX3RhZyB0aGVuIE9wZW5fdGFnIHN1Yl9mb3JtYXQgZWxzZSBPcGVuX2JveCBzdWJfZm9ybWF0IGluXG4gICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2dlbiAoZm9ybWF0dGluZywgZm10X3Jlc3QpKVxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBvcHRpb25hbCA8d2lkdGggb2Zmc2V0PiBhZnRlciBcIkA7XCIuICopXG4gIGFuZCBwYXJzZV9nb29kX2JyZWFrIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGxldCBuZXh0X2luZCwgZm9ybWF0dGluZ19saXQgPVxuICAgICAgdHJ5XG4gICAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHx8IHN0ci5bc3RyX2luZF0gPD4gJzwnIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgICBsZXQgc3RyX2luZF8xID0gcGFyc2Vfc3BhY2VzIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBtYXRjaCBzdHIuW3N0cl9pbmRfMV0gd2l0aFxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT4gKFxuICAgICAgICAgIGxldCBzdHJfaW5kXzIsIHdpZHRoID0gcGFyc2VfaW50ZWdlciBzdHJfaW5kXzEgZW5kX2luZCBpblxuICAgICAgICAgICAgbGV0IHN0cl9pbmRfMyA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzIgZW5kX2luZCBpblxuICAgICAgICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXzNdIHdpdGhcbiAgICAgICAgICAgICAgfCAnPicgLT5cbiAgICAgICAgICAgICAgICBsZXQgcyA9IFN0cmluZy5zdWIgc3RyIChzdHJfaW5kLTIpIChzdHJfaW5kXzMtc3RyX2luZCszKSBpblxuICAgICAgICAgICAgICAgIHN0cl9pbmRfMyArIDEsIEJyZWFrIChzLCB3aWR0aCwgMClcbiAgICAgICAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+XG4gICAgICAgICAgICAgICAgbGV0IHN0cl9pbmRfNCwgb2Zmc2V0ID0gcGFyc2VfaW50ZWdlciBzdHJfaW5kXzMgZW5kX2luZCBpblxuICAgICAgICAgICAgICAgIGxldCBzdHJfaW5kXzUgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF80IGVuZF9pbmQgaW5cbiAgICAgICAgICAgICAgICBpZiBzdHIuW3N0cl9pbmRfNV0gPD4gJz4nIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgICAgICAgICAgIGxldCBzID0gU3RyaW5nLnN1YiBzdHIgKHN0cl9pbmQtMikgKHN0cl9pbmRfNS1zdHJfaW5kKzMpIGluXG4gICAgICAgICAgICAgICAgc3RyX2luZF81ICsgMSwgQnJlYWsgKHMsIHdpZHRoLCBvZmZzZXQpXG4gICAgICAgICAgICAgIHwgXyAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgKVxuICAgICAgICB8IF8gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB3aXRoIE5vdF9mb3VuZCB8IEZhaWx1cmUgXyAtPlxuICAgICAgICBzdHJfaW5kLCBCcmVhayAoXCJAO1wiLCAxLCAwKVxuICAgIGluXG4gICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBuZXh0X2luZCBlbmRfaW5kIGluXG4gICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCBmbXRfcmVzdCkpXG5cbiAgKCogUGFyc2UgdGhlIHNpemUgaW4gYSA8bj4uICopXG4gIGFuZCBwYXJzZV9tYWdpY19zaXplIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIG1hdGNoXG4gICAgICB0cnlcbiAgICAgICAgbGV0IHN0cl9pbmRfMSA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXzFdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+XG4gICAgICAgICAgbGV0IHN0cl9pbmRfMiwgc2l6ZSA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8xIGVuZF9pbmQgaW5cbiAgICAgICAgICBsZXQgc3RyX2luZF8zID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfMiBlbmRfaW5kIGluXG4gICAgICAgICAgaWYgc3RyLltzdHJfaW5kXzNdIDw+ICc+JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgICBsZXQgcyA9IFN0cmluZy5zdWIgc3RyIChzdHJfaW5kIC0gMikgKHN0cl9pbmRfMyAtIHN0cl9pbmQgKyAzKSBpblxuICAgICAgICAgIFNvbWUgKHN0cl9pbmRfMyArIDEsIE1hZ2ljX3NpemUgKHMsIHNpemUpKVxuICAgICAgICB8IF8gLT4gTm9uZVxuICAgICAgd2l0aCBOb3RfZm91bmQgfCBGYWlsdXJlIF8gLT5cbiAgICAgICAgTm9uZVxuICAgIHdpdGhcbiAgICB8IFNvbWUgKG5leHRfaW5kLCBmb3JtYXR0aW5nX2xpdCkgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgbmV4dF9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCBmbXRfcmVzdCkpXG4gICAgfCBOb25lIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKFNjYW5faW5kaWMgJzwnLCBmbXRfcmVzdCkpXG5cbiAgKCogUGFyc2UgYW5kIGNvbnN0cnVjdCBhIGNoYXIgc2V0LiAqKVxuICBhbmQgcGFyc2VfY2hhcl9zZXQgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuXG4gICAgbGV0IGNoYXJfc2V0ID0gY3JlYXRlX2NoYXJfc2V0ICgpIGluXG4gICAgbGV0IGFkZF9jaGFyIGMgPVxuICAgICAgYWRkX2luX2NoYXJfc2V0IGNoYXJfc2V0IGM7XG4gICAgaW5cbiAgICBsZXQgYWRkX3JhbmdlIGMgYycgPVxuICAgICAgZm9yIGkgPSBpbnRfb2ZfY2hhciBjIHRvIGludF9vZl9jaGFyIGMnIGRvXG4gICAgICAgIGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCAoY2hhcl9vZl9pbnQgaSk7XG4gICAgICBkb25lO1xuICAgIGluXG5cbiAgICBsZXQgZmFpbF9zaW5nbGVfcGVyY2VudCBzdHJfaW5kID1cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogJyUlJyBhbG9uZSBpcyBub3QgYWNjZXB0ZWQgaW4gY2hhcmFjdGVyIHNldHMsIFxcXG4gICAgICAgICB1c2UgJSUlJSBpbnN0ZWFkIGF0IHBvc2l0aW9uICVkLlwiIHN0ciBzdHJfaW5kXG4gICAgaW5cblxuICAgICgqIFBhcnNlIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBjaGFyIHNldC4gKilcbiAgICBsZXQgcmVjIHBhcnNlX2NoYXJfc2V0X3N0YXJ0IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbGV0IGMgPSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjXG5cbiAgICAoKiBQYXJzZSB0aGUgY29udGVudCBvZiBhIGNoYXIgc2V0IHVudGlsIHRoZSBmaXJzdCAnXScuICopXG4gICAgYW5kIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgc3RyX2luZCBlbmRfaW5kID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICctJyAtPlxuICAgICAgICBhZGRfY2hhciAnLSc7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8IGMgLT5cbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICAgKCogVGVzdCBmb3IgcmFuZ2UgaW4gY2hhciBzZXQuICopXG4gICAgYW5kIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgc3RyX2luZCBlbmRfaW5kIGMgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXScgLT5cbiAgICAgICAgYWRkX2NoYXIgYztcbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJy0nIC0+XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX21pbnVzIChzdHJfaW5kICsgMSkgZW5kX2luZCBjXG4gICAgICB8ICgnJScgfCAnQCcpIGFzIGMnIHdoZW4gYyA9ICclJyAtPlxuICAgICAgICBhZGRfY2hhciBjJztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgYycgLT5cbiAgICAgICAgaWYgYyA9ICclJyB0aGVuIGZhaWxfc2luZ2xlX3BlcmNlbnQgc3RyX2luZDtcbiAgICAgICAgKCogbm90ZSB0aGF0ICdAJyBhbG9uZSBpcyBhY2NlcHRlZCwgYXMgZG9uZSBieSB0aGUgbGVnYWN5XG4gICAgICAgICAgIGltcGxlbWVudGF0aW9uOyB0aGUgZG9jdW1lbnRhdGlvbiBzcGVjaWZpY2FsbHkgcmVxdWlyZXMgJUBcbiAgICAgICAgICAgc28gd2UgY291bGQgd2FybiBvbiB0aGF0ICopXG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGMnXG5cbiAgICAoKiBNYW5hZ2UgcmFuZ2UgaW4gY2hhciBzZXQgKGV4Y2VwdCBpZiB0aGUgJy0nIHRoZSBsYXN0IGNoYXIgYmVmb3JlICddJykgKilcbiAgICBhbmQgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfbWludXMgc3RyX2luZCBlbmRfaW5kIGMgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXScgLT5cbiAgICAgICAgYWRkX2NoYXIgYztcbiAgICAgICAgYWRkX2NoYXIgJy0nO1xuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnJScgLT5cbiAgICAgICAgaWYgc3RyX2luZCArIDEgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDFdIHdpdGhcbiAgICAgICAgICB8ICgnJScgfCAnQCcpIGFzIGMnIC0+XG4gICAgICAgICAgICBhZGRfcmFuZ2UgYyBjJztcbiAgICAgICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kXG4gICAgICAgICAgfCBfIC0+IGZhaWxfc2luZ2xlX3BlcmNlbnQgc3RyX2luZFxuICAgICAgICBlbmRcbiAgICAgIHwgYycgLT5cbiAgICAgICAgYWRkX3JhbmdlIGMgYyc7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgaW5cbiAgICBsZXQgc3RyX2luZCwgcmV2ZXJzZSA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICAgIHwgJ14nIC0+IHN0cl9pbmQgKyAxLCB0cnVlXG4gICAgICAgIHwgXyAtPiBzdHJfaW5kLCBmYWxzZSBpblxuICAgIGxldCBuZXh0X2luZCA9IHBhcnNlX2NoYXJfc2V0X3N0YXJ0IHN0cl9pbmQgZW5kX2luZCBpblxuICAgIGxldCBjaGFyX3NldCA9IGZyZWV6ZV9jaGFyX3NldCBjaGFyX3NldCBpblxuICAgIG5leHRfaW5kLCAoaWYgcmV2ZXJzZSB0aGVuIHJldl9jaGFyX3NldCBjaGFyX3NldCBlbHNlIGNoYXJfc2V0KVxuXG4gICgqIENvbnN1bWUgYWxsIG5leHQgc3BhY2VzLCByYWlzZSBhbiBGYWlsdXJlIGlmIGVuZF9pbmQgaXMgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX3NwYWNlcyBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgaWYgc3RyLltzdHJfaW5kXSA9ICcgJyB0aGVuIHBhcnNlX3NwYWNlcyAoc3RyX2luZCArIDEpIGVuZF9pbmQgZWxzZSBzdHJfaW5kXG5cbiAgKCogUmVhZCBhIHBvc2l0aXZlIGludGVnZXIgZnJvbSB0aGUgc3RyaW5nLCByYWlzZSBhIEZhaWx1cmUgaWYgZW5kX2luZCBpc1xuICAgICByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIGFjYyA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBhY2MgKiAxMCArIChpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJzAnKSBpblxuICAgICAgaWYgbmV3X2FjYyA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuXG4gICAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBpbnRlZ2VyICVkIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbGltaXQgJWRcIlxuICAgICAgICAgIHN0ciBuZXdfYWNjIFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgICAgZWxzZVxuICAgICAgICBwYXJzZV9wb3NpdGl2ZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgbmV3X2FjY1xuICAgIHwgXyAtPiBzdHJfaW5kLCBhY2NcblxuICAoKiBSZWFkIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgaW50ZWdlciBmcm9tIHRoZSBzdHJpbmcsIHJhaXNlIGEgRmFpbHVyZVxuICAgICBpZiBlbmRfaW5kIGlzIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9pbnRlZ2VyIHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgLT4gcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIDBcbiAgICB8ICctJyAtPiAoXG4gICAgICBpZiBzdHJfaW5kICsgMSA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZCArIDFdIHdpdGhcbiAgICAgIHwgJzAnIC4uICc5JyAtPlxuICAgICAgICBsZXQgbmV4dF9pbmQsIG4gPSBwYXJzZV9wb3NpdGl2ZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgMCBpblxuICAgICAgICBuZXh0X2luZCwgLW5cbiAgICAgIHwgYyAtPlxuICAgICAgICBleHBlY3RlZF9jaGFyYWN0ZXIgKHN0cl9pbmQgKyAxKSBcImRpZ2l0XCIgY1xuICAgIClcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogQWRkIGEgbGl0ZXJhbCB0byBhIGZvcm1hdCBmcm9tIGEgbGl0ZXJhbCBjaGFyYWN0ZXIgc3ViLXNlcXVlbmNlLiAqKVxuICBhbmQgYWRkX2xpdGVyYWwgOiB0eXBlIGEgZCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiAoYSwgXywgXywgZCwgZSwgZikgZm10IC0+XG4gICAgICAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBsaXRfc3RhcnQgc3RyX2luZCBmbXQgLT4gbWF0Y2ggc3RyX2luZCAtIGxpdF9zdGFydCB3aXRoXG4gICAgfCAwICAgIC0+IEZtdF9FQkIgZm10XG4gICAgfCAxICAgIC0+IEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoc3RyLltsaXRfc3RhcnRdLCBmbXQpKVxuICAgIHwgc2l6ZSAtPiBGbXRfRUJCIChTdHJpbmdfbGl0ZXJhbCAoU3RyaW5nLnN1YiBzdHIgbGl0X3N0YXJ0IHNpemUsIGZtdCkpXG5cbiAgKCogU2VhcmNoIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgc3ViLWZvcm1hdFxuICAgICAoaS5lLiB0aGUgY29ycmVzcG9uZGluZyBcIiV9XCIgb3IgXCIlKVwiKSAqKVxuICBhbmQgc2VhcmNoX3N1YmZvcm1hdF9lbmQgc3RyX2luZCBlbmRfaW5kIGMgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogdW5jbG9zZWQgc3ViLWZvcm1hdCwgXFxcbiAgICAgICAgIGV4cGVjdGVkIFxcXCIlJSVjXFxcIiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkXCIgc3RyIGMgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICclJyAtPlxuICAgICAgaWYgc3RyX2luZCArIDEgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBpZiBzdHIuW3N0cl9pbmQgKyAxXSA9IGMgdGhlbiAoKiBFbmQgb2YgZm9ybWF0IGZvdW5kICopIHN0cl9pbmQgZWxzZVxuICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICAgIHwgJ18nIC0+XG4gICAgICAgICAgKCogU2VhcmNoIGZvciBcIiVfKFwiIG9yIFwiJV97XCIuICopXG4gICAgICAgICAgaWYgc3RyX2luZCArIDIgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMl0gd2l0aFxuICAgICAgICAgIHwgJ3snIC0+XG4gICAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCAnfScgaW5cbiAgICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgICAgfCAnKCcgLT5cbiAgICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAzKSBlbmRfaW5kICcpJyBpblxuICAgICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgICB8IF8gLT4gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAzKSBlbmRfaW5kIGNcbiAgICAgICAgICBlbmRcbiAgICAgICAgfCAneycgLT5cbiAgICAgICAgICAoKiAley4uLiV9IHN1Yi1mb3JtYXQgZm91bmQuICopXG4gICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDIpIGVuZF9pbmQgJ30nIGluXG4gICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgfCAnKCcgLT5cbiAgICAgICAgICAoKiAlKC4uLiUpIHN1Yi1mb3JtYXQgZm91bmQuICopXG4gICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDIpIGVuZF9pbmQgJyknIGluXG4gICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgfCAnfScgLT5cbiAgICAgICAgICAoKiBFcnJvcjogJSguLi4lfS4gKilcbiAgICAgICAgICBleHBlY3RlZF9jaGFyYWN0ZXIgKHN0cl9pbmQgKyAxKSBcImNoYXJhY3RlciAnKSdcIiAnfSdcbiAgICAgICAgfCAnKScgLT5cbiAgICAgICAgICAoKiBFcnJvcjogJXsuLi4lKS4gKilcbiAgICAgICAgICBleHBlY3RlZF9jaGFyYWN0ZXIgKHN0cl9pbmQgKyAxKSBcImNoYXJhY3RlciAnfSdcIiAnKSdcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgZW5kXG4gICAgfCBfIC0+IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBjXG5cbiAgKCogQ2hlY2sgaWYgc3ltYiBpcyBhIHZhbGlkIGludCBjb252ZXJzaW9uIGFmdGVyIFwiJWxcIiwgXCIlblwiIG9yIFwiJUxcIiAqKVxuICBhbmQgaXNfaW50X2Jhc2Ugc3ltYiA9IG1hdGNoIHN5bWIgd2l0aFxuICAgIHwgJ2QnIHwgJ2knIHwgJ3gnIHwgJ1gnIHwgJ28nIHwgJ3UnIC0+IHRydWVcbiAgICB8IF8gLT4gZmFsc2VcblxuICAoKiBDb252ZXJ0IGEgY2hhciAobCwgbiBvciBMKSB0byBpdHMgYXNzb2NpYXRlZCBjb3VudGVyLiAqKVxuICBhbmQgY291bnRlcl9vZl9jaGFyIHN5bWIgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICdsJyAtPiBMaW5lX2NvdW50ZXIgIHwgJ24nIC0+IENoYXJfY291bnRlclxuICAgIHwgJ0wnIC0+IFRva2VuX2NvdW50ZXIgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICgqIENvbnZlcnQgKHBsdXMsIHN5bWIpIHRvIGl0cyBhc3NvY2lhdGVkIGludF9jb252LiAqKVxuICBhbmQgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIHNwYWNlIHN5bWIgPVxuICAgIG1hdGNoIHBsdXMsIGhhc2gsIHNwYWNlLCBzeW1iIHdpdGhcbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICdkJyAtPiBJbnRfZCAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnaScgLT4gSW50X2lcbiAgICB8IGZhbHNlLCBmYWxzZSwgIHRydWUsICdkJyAtPiBJbnRfc2QgfCBmYWxzZSwgZmFsc2UsICB0cnVlLCAnaScgLT4gSW50X3NpXG4gICAgfCAgdHJ1ZSwgZmFsc2UsIGZhbHNlLCAnZCcgLT4gSW50X3BkIHwgIHRydWUsIGZhbHNlLCBmYWxzZSwgJ2knIC0+IEludF9waVxuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ3gnIC0+IEludF94ICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICdYJyAtPiBJbnRfWFxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ3gnIC0+IEludF9DeCB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdYJyAtPiBJbnRfQ1hcbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICdvJyAtPiBJbnRfb1xuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ28nIC0+IEludF9Db1xuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ3UnIC0+IEludF91XG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnZCcgLT4gSW50X0NkXG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnaScgLT4gSW50X0NpXG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAndScgLT4gSW50X0N1XG4gICAgfCBfLCB0cnVlLCBfLCAneCcgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT4gSW50X0N4XG4gICAgfCBfLCB0cnVlLCBfLCAnWCcgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT4gSW50X0NYXG4gICAgfCBfLCB0cnVlLCBfLCAnbycgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT4gSW50X0NvXG4gICAgfCBfLCB0cnVlLCBfLCAoJ2QnIHwgJ2knIHwgJ3UnKSAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgZmFsc2Ugc3BhY2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicjJ1wiXG4gICAgfCB0cnVlLCBfLCB0cnVlLCBfIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAoKiBwbHVzIGFuZCBzcGFjZTogbGVnYWN5IGltcGxlbWVudGF0aW9uIHByZWZlcnMgcGx1cyAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGhhc2ggZmFsc2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJyAnIFwiJysnXCJcbiAgICB8IGZhbHNlLCBfLCB0cnVlLCBfICAgIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIGZhbHNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInICdcIlxuICAgIHwgdHJ1ZSwgXywgZmFsc2UsIF8gICAgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBmYWxzZSBoYXNoIHNwYWNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInKydcIlxuICAgIHwgZmFsc2UsIF8sIGZhbHNlLCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICgqIENvbnZlcnQgKHBsdXMsIHNwYWNlLCBzeW1iKSB0byBpdHMgYXNzb2NpYXRlZCBmbG9hdF9jb252LiAqKVxuICBhbmQgY29tcHV0ZV9mbG9hdF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGhhc2ggc3BhY2Ugc3ltYiA9XG4gICAgbGV0IGZsYWcgPSBtYXRjaCBwbHVzLCBzcGFjZSB3aXRoXG4gICAgfCBmYWxzZSwgZmFsc2UgLT4gRmxvYXRfZmxhZ19cbiAgICB8IGZhbHNlLCAgdHJ1ZSAtPiBGbG9hdF9mbGFnX3NcbiAgICB8ICB0cnVlLCBmYWxzZSAtPiBGbG9hdF9mbGFnX3BcbiAgICB8ICB0cnVlLCAgdHJ1ZSAtPlxuICAgICAgKCogcGx1cyBhbmQgc3BhY2U6IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBwcmVmZXJzIHBsdXMgKilcbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEZsb2F0X2ZsYWdfcFxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJyAnIFwiJysnXCIgaW5cbiAgICBsZXQga2luZCA9IG1hdGNoIGhhc2gsIHN5bWIgd2l0aFxuICAgIHwgXywgJ2YnIC0+IEZsb2F0X2ZcbiAgICB8IF8sICdlJyAtPiBGbG9hdF9lXG4gICAgfCBfLCAnRScgLT4gRmxvYXRfRVxuICAgIHwgXywgJ2cnIC0+IEZsb2F0X2dcbiAgICB8IF8sICdHJyAtPiBGbG9hdF9HXG4gICAgfCBfLCAnaCcgLT4gRmxvYXRfaFxuICAgIHwgXywgJ0gnIC0+IEZsb2F0X0hcbiAgICB8IGZhbHNlLCAnRicgLT4gRmxvYXRfRlxuICAgIHwgdHJ1ZSwgJ0YnIC0+IEZsb2F0X0NGXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZSBpblxuICAgIGZsYWcsIGtpbmRcblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UgYWJvdXQgaW5jb21wYXRpYmxlIG9wdGlvbnMuKilcbiAgYW5kIGluY29tcGF0aWJsZV9mbGFnIDogdHlwZSBhIC4gaW50IC0+IGludCAtPiBjaGFyIC0+IHN0cmluZyAtPiBhID1cbiAgICBmdW4gcGN0X2luZCBzdHJfaW5kIHN5bWIgb3B0aW9uIC0+XG4gICAgICBsZXQgc3ViZm10ID0gU3RyaW5nLnN1YiBzdHIgcGN0X2luZCAoc3RyX2luZCAtIHBjdF9pbmQpIGluXG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIFxcXG4gICAgICAgICAlcyBpcyBpbmNvbXBhdGlibGUgd2l0aCAnJWMnIGluIHN1Yi1mb3JtYXQgJVNcIlxuICAgICAgICBzdHIgcGN0X2luZCBvcHRpb24gc3ltYiBzdWJmbXRcblxuICBpbiBwYXJzZSAwIChTdHJpbmcubGVuZ3RoIHN0cilcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICgqIEd1YXJkZWQgc3RyaW5nIHRvIGZvcm1hdCBjb252ZXJzaW9ucyAqKVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgZm9ybWF0IGFjY29yZGluZyB0byBhbiBmbXR0eS4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGFuIGVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IGZvcm1hdF9vZl9zdHJpbmdfZm10dHkgc3RyIGZtdHR5ID1cbiAgbGV0IEZtdF9FQkIgZm10ID0gZm10X2ViYl9vZl9zdHJpbmcgc3RyIGluXG4gIHRyeSBGb3JtYXQgKHR5cGVfZm9ybWF0IGZtdCBmbXR0eSwgc3RyKVxuICB3aXRoIFR5cGVfbWlzbWF0Y2ggLT5cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImJhZCBpbnB1dDogZm9ybWF0IHR5cGUgbWlzbWF0Y2ggYmV0d2VlbiAlUyBhbmQgJVNcIlxuICAgICAgc3RyIChzdHJpbmdfb2ZfZm10dHkgZm10dHkpXG5cbigqIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBmb3JtYXQgY29tcGF0aWJsZSB3aXRoIGFuIG90aGVyIGZvcm1hdC4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGFuIGVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IGZvcm1hdF9vZl9zdHJpbmdfZm9ybWF0IHN0ciAoRm9ybWF0IChmbXQnLCBzdHInKSkgPVxuICBsZXQgRm10X0VCQiBmbXQgPSBmbXRfZWJiX29mX3N0cmluZyBzdHIgaW5cbiAgdHJ5IEZvcm1hdCAodHlwZV9mb3JtYXQgZm10IChmbXR0eV9vZl9mbXQgZm10JyksIHN0cilcbiAgd2l0aCBUeXBlX21pc21hdGNoIC0+XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJiYWQgaW5wdXQ6IGZvcm1hdCB0eXBlIG1pc21hdGNoIGJldHdlZW4gJVMgYW5kICVTXCIgc3RyIHN0cidcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBQcmludGZcblxudHlwZSB0ID0gZXhuID0gLi5cblxubGV0IHByaW50ZXJzID0gQXRvbWljLm1ha2UgW11cblxubGV0IGxvY2ZtdCA9IGZvcm1hdF9vZl9zdHJpbmcgXCJGaWxlIFxcXCIlc1xcXCIsIGxpbmUgJWQsIGNoYXJhY3RlcnMgJWQtJWQ6ICVzXCJcblxubGV0IGZpZWxkIHggaSA9XG4gIGxldCBmID0gT2JqLmZpZWxkIHggaSBpblxuICBpZiBub3QgKE9iai5pc19ibG9jayBmKSB0aGVuXG4gICAgc3ByaW50ZiBcIiVkXCIgKE9iai5tYWdpYyBmIDogaW50KSAgICAgICAgICAgKCogY2FuIGFsc28gYmUgYSBjaGFyICopXG4gIGVsc2UgaWYgT2JqLnRhZyBmID0gT2JqLnN0cmluZ190YWcgdGhlblxuICAgIHNwcmludGYgXCIlU1wiIChPYmoubWFnaWMgZiA6IHN0cmluZylcbiAgZWxzZSBpZiBPYmoudGFnIGYgPSBPYmouZG91YmxlX3RhZyB0aGVuXG4gICAgc3RyaW5nX29mX2Zsb2F0IChPYmoubWFnaWMgZiA6IGZsb2F0KVxuICBlbHNlXG4gICAgXCJfXCJcblxubGV0IHJlYyBvdGhlcl9maWVsZHMgeCBpID1cbiAgaWYgaSA+PSBPYmouc2l6ZSB4IHRoZW4gXCJcIlxuICBlbHNlIHNwcmludGYgXCIsICVzJXNcIiAoZmllbGQgeCBpKSAob3RoZXJfZmllbGRzIHggKGkrMSkpXG5cbmxldCBmaWVsZHMgeCA9XG4gIG1hdGNoIE9iai5zaXplIHggd2l0aFxuICB8IDAgLT4gXCJcIlxuICB8IDEgLT4gXCJcIlxuICB8IDIgLT4gc3ByaW50ZiBcIiglcylcIiAoZmllbGQgeCAxKVxuICB8IF8gLT4gc3ByaW50ZiBcIiglcyVzKVwiIChmaWVsZCB4IDEpIChvdGhlcl9maWVsZHMgeCAyKVxuXG5sZXQgdXNlX3ByaW50ZXJzIHggPVxuICBsZXQgcmVjIGNvbnYgPSBmdW5jdGlvblxuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgKG1hdGNoIGhkIHggd2l0aFxuICAgICAgICAgfCBOb25lIHwgZXhjZXB0aW9uIF8gLT4gY29udiB0bFxuICAgICAgICAgfCBTb21lIHMgLT4gU29tZSBzKVxuICAgIHwgW10gLT4gTm9uZSBpblxuICBjb252IChBdG9taWMuZ2V0IHByaW50ZXJzKVxuXG5sZXQgdG9fc3RyaW5nX2RlZmF1bHQgPSBmdW5jdGlvblxuICB8IE91dF9vZl9tZW1vcnkgLT4gXCJPdXQgb2YgbWVtb3J5XCJcbiAgfCBTdGFja19vdmVyZmxvdyAtPiBcIlN0YWNrIG92ZXJmbG93XCJcbiAgfCBNYXRjaF9mYWlsdXJlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis1KSBcIlBhdHRlcm4gbWF0Y2hpbmcgZmFpbGVkXCJcbiAgfCBBc3NlcnRfZmFpbHVyZShmaWxlLCBsaW5lLCBjaGFyKSAtPlxuICAgICAgc3ByaW50ZiBsb2NmbXQgZmlsZSBsaW5lIGNoYXIgKGNoYXIrNikgXCJBc3NlcnRpb24gZmFpbGVkXCJcbiAgfCBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZShmaWxlLCBsaW5lLCBjaGFyKSAtPlxuICAgICAgc3ByaW50ZiBsb2NmbXQgZmlsZSBsaW5lIGNoYXIgKGNoYXIrNikgXCJVbmRlZmluZWQgcmVjdXJzaXZlIG1vZHVsZVwiXG4gIHwgeCAtPlxuICAgICAgbGV0IHggPSBPYmoucmVwciB4IGluXG4gICAgICBpZiBPYmoudGFnIHggPD4gMCB0aGVuXG4gICAgICAgIChPYmoubWFnaWMgKE9iai5maWVsZCB4IDApIDogc3RyaW5nKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgY29uc3RydWN0b3IgPVxuICAgICAgICAgIChPYmoubWFnaWMgKE9iai5maWVsZCAoT2JqLmZpZWxkIHggMCkgMCkgOiBzdHJpbmcpIGluXG4gICAgICAgIGNvbnN0cnVjdG9yIF4gKGZpZWxkcyB4KVxuXG5sZXQgdG9fc3RyaW5nIGUgPVxuICBtYXRjaCB1c2VfcHJpbnRlcnMgZSB3aXRoXG4gIHwgU29tZSBzIC0+IHNcbiAgfCBOb25lIC0+IHRvX3N0cmluZ19kZWZhdWx0IGVcblxubGV0IHByaW50IGZjdCBhcmcgPVxuICB0cnlcbiAgICBmY3QgYXJnXG4gIHdpdGggeCAtPlxuICAgIGVwcmludGYgXCJVbmNhdWdodCBleGNlcHRpb246ICVzXFxuXCIgKHRvX3N0cmluZyB4KTtcbiAgICBmbHVzaCBzdGRlcnI7XG4gICAgcmFpc2UgeFxuXG5sZXQgY2F0Y2ggZmN0IGFyZyA9XG4gIHRyeVxuICAgIGZjdCBhcmdcbiAgd2l0aCB4IC0+XG4gICAgZmx1c2ggc3Rkb3V0O1xuICAgIGVwcmludGYgXCJVbmNhdWdodCBleGNlcHRpb246ICVzXFxuXCIgKHRvX3N0cmluZyB4KTtcbiAgICBleGl0IDJcblxudHlwZSByYXdfYmFja3RyYWNlX3Nsb3RcbnR5cGUgcmF3X2JhY2t0cmFjZV9lbnRyeSA9IHByaXZhdGUgaW50XG50eXBlIHJhd19iYWNrdHJhY2UgPSByYXdfYmFja3RyYWNlX2VudHJ5IGFycmF5XG5cbmxldCByYXdfYmFja3RyYWNlX2VudHJpZXMgYnQgPSBidFxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZTpcbiAgdW5pdCAtPiByYXdfYmFja3RyYWNlID0gXCJjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZVwiXG5cbmV4dGVybmFsIHJhaXNlX3dpdGhfYmFja3RyYWNlOiBleG4gLT4gcmF3X2JhY2t0cmFjZSAtPiAnYVxuICA9IFwiJXJhaXNlX3dpdGhfYmFja3RyYWNlXCJcblxudHlwZSBiYWNrdHJhY2Vfc2xvdCA9XG4gIHwgS25vd25fbG9jYXRpb24gb2Yge1xuICAgICAgaXNfcmFpc2UgICAgOiBib29sO1xuICAgICAgZmlsZW5hbWUgICAgOiBzdHJpbmc7XG4gICAgICBsaW5lX251bWJlciA6IGludDtcbiAgICAgIHN0YXJ0X2NoYXIgIDogaW50O1xuICAgICAgZW5kX2NoYXIgICAgOiBpbnQ7XG4gICAgICBpc19pbmxpbmUgICA6IGJvb2w7XG4gICAgICBkZWZuYW1lICAgICA6IHN0cmluZztcbiAgICB9XG4gIHwgVW5rbm93bl9sb2NhdGlvbiBvZiB7XG4gICAgICBpc19yYWlzZSA6IGJvb2xcbiAgICB9XG5cbigqIHRvIGF2b2lkIHdhcm5pbmcgKilcbmxldCBfID0gW0tub3duX2xvY2F0aW9uIHsgaXNfcmFpc2UgPSBmYWxzZTsgZmlsZW5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lX251bWJlciA9IDA7IHN0YXJ0X2NoYXIgPSAwOyBlbmRfY2hhciA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzX2lubGluZSA9IGZhbHNlOyBkZWZuYW1lID0gXCJcIiB9O1xuICAgICAgICAgVW5rbm93bl9sb2NhdGlvbiB7IGlzX3JhaXNlID0gZmFsc2UgfV1cblxuZXh0ZXJuYWwgY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3Q6XG4gIHJhd19iYWNrdHJhY2Vfc2xvdCAtPiBiYWNrdHJhY2Vfc2xvdCA9IFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFwiXG5cbmV4dGVybmFsIGNvbnZlcnRfcmF3X2JhY2t0cmFjZTpcbiAgcmF3X2JhY2t0cmFjZSAtPiBiYWNrdHJhY2Vfc2xvdCBhcnJheSA9IFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2VcIlxuXG5sZXQgY29udmVydF9yYXdfYmFja3RyYWNlIGJ0ID1cbiAgdHJ5IFNvbWUgKGNvbnZlcnRfcmF3X2JhY2t0cmFjZSBidClcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5sZXQgZm9ybWF0X2JhY2t0cmFjZV9zbG90IHBvcyBzbG90ID1cbiAgbGV0IGluZm8gaXNfcmFpc2UgPVxuICAgIGlmIGlzX3JhaXNlIHRoZW5cbiAgICAgIGlmIHBvcyA9IDAgdGhlbiBcIlJhaXNlZCBhdFwiIGVsc2UgXCJSZS1yYWlzZWQgYXRcIlxuICAgIGVsc2VcbiAgICAgIGlmIHBvcyA9IDAgdGhlbiBcIlJhaXNlZCBieSBwcmltaXRpdmUgb3BlcmF0aW9uIGF0XCIgZWxzZSBcIkNhbGxlZCBmcm9tXCJcbiAgaW5cbiAgbWF0Y2ggc2xvdCB3aXRoXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgICBpZiBsLmlzX3JhaXNlIHRoZW5cbiAgICAgICAgKCogY29tcGlsZXItaW5zZXJ0ZWQgcmUtcmFpc2UsIHNraXBwZWQgKikgTm9uZVxuICAgICAgZWxzZVxuICAgICAgICBTb21lIChzcHJpbnRmIFwiJXMgdW5rbm93biBsb2NhdGlvblwiIChpbmZvIGZhbHNlKSlcbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgICBTb21lIChzcHJpbnRmIFwiJXMgJXMgaW4gZmlsZSBcXFwiJXNcXFwiJXMsIGxpbmUgJWQsIGNoYXJhY3RlcnMgJWQtJWRcIlxuICAgICAgICAgICAgICAoaW5mbyBsLmlzX3JhaXNlKSBsLmRlZm5hbWUgbC5maWxlbmFtZVxuICAgICAgICAgICAgICAoaWYgbC5pc19pbmxpbmUgdGhlbiBcIiAoaW5saW5lZClcIiBlbHNlIFwiXCIpXG4gICAgICAgICAgICAgIGwubGluZV9udW1iZXIgbC5zdGFydF9jaGFyIGwuZW5kX2NoYXIpXG5cbmxldCBwcmludF9leGNlcHRpb25fYmFja3RyYWNlIG91dGNoYW4gYmFja3RyYWNlID1cbiAgbWF0Y2ggYmFja3RyYWNlIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgICBmcHJpbnRmIG91dGNoYW5cbiAgICAgICAgXCIoUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIGNhbm5vdCBwcmludCBzdGFjayBiYWNrdHJhY2UpXFxuXCJcbiAgfCBTb21lIGEgLT5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggYSAtIDEgZG9cbiAgICAgICAgbWF0Y2ggZm9ybWF0X2JhY2t0cmFjZV9zbG90IGkgYS4oaSkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBzdHIgLT4gZnByaW50ZiBvdXRjaGFuIFwiJXNcXG5cIiBzdHJcbiAgICAgIGRvbmVcblxubGV0IHByaW50X3Jhd19iYWNrdHJhY2Ugb3V0Y2hhbiByYXdfYmFja3RyYWNlID1cbiAgcHJpbnRfZXhjZXB0aW9uX2JhY2t0cmFjZSBvdXRjaGFuIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSlcblxuKCogY29uZnVzaW5nbHkgbmFtZWQ6IHByaW50cyB0aGUgZ2xvYmFsIGN1cnJlbnQgYmFja3RyYWNlICopXG5sZXQgcHJpbnRfYmFja3RyYWNlIG91dGNoYW4gPVxuICBwcmludF9yYXdfYmFja3RyYWNlIG91dGNoYW4gKGdldF9yYXdfYmFja3RyYWNlICgpKVxuXG5sZXQgYmFja3RyYWNlX3RvX3N0cmluZyBiYWNrdHJhY2UgPVxuICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICB8IE5vbmUgLT5cbiAgICAgXCIoUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIGNhbm5vdCBwcmludCBzdGFjayBiYWNrdHJhY2UpXFxuXCJcbiAgfCBTb21lIGEgLT5cbiAgICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAxMDI0IGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGEgLSAxIGRvXG4gICAgICAgIG1hdGNoIGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBpIGEuKGkpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgc3RyIC0+IGJwcmludGYgYiBcIiVzXFxuXCIgc3RyXG4gICAgICBkb25lO1xuICAgICAgQnVmZmVyLmNvbnRlbnRzIGJcblxubGV0IHJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIHJhd19iYWNrdHJhY2UgPVxuICBiYWNrdHJhY2VfdG9fc3RyaW5nIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSlcblxubGV0IGJhY2t0cmFjZV9zbG90X2lzX3JhaXNlID0gZnVuY3Rpb25cbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfcmFpc2VcbiAgfCBVbmtub3duX2xvY2F0aW9uIGwgLT4gbC5pc19yYWlzZVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lID0gZnVuY3Rpb25cbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfaW5saW5lXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IGZhbHNlXG5cbnR5cGUgbG9jYXRpb24gPSB7XG4gIGZpbGVuYW1lIDogc3RyaW5nO1xuICBsaW5lX251bWJlciA6IGludDtcbiAgc3RhcnRfY2hhciA6IGludDtcbiAgZW5kX2NoYXIgOiBpbnQ7XG59XG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvbiA9IGZ1bmN0aW9uXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IE5vbmVcbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgU29tZSB7XG4gICAgICBmaWxlbmFtZSAgICA9IGwuZmlsZW5hbWU7XG4gICAgICBsaW5lX251bWJlciA9IGwubGluZV9udW1iZXI7XG4gICAgICBzdGFydF9jaGFyICA9IGwuc3RhcnRfY2hhcjtcbiAgICAgIGVuZF9jaGFyICAgID0gbC5lbmRfY2hhcjtcbiAgICB9XG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9kZWZuYW1lID0gZnVuY3Rpb25cbiAgfCBVbmtub3duX2xvY2F0aW9uIF9cbiAgfCBLbm93bl9sb2NhdGlvbiB7IGRlZm5hbWUgPSBcIlwiIH0gLT4gTm9uZVxuICB8IEtub3duX2xvY2F0aW9uIGwgLT4gU29tZSBsLmRlZm5hbWVcblxubGV0IGJhY2t0cmFjZV9zbG90cyByYXdfYmFja3RyYWNlID1cbiAgKCogVGhlIGRvY3VtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBndWFyYW50ZWVzIHRoYXQgU29tZSBpc1xuICAgICByZXR1cm5lZCBvbmx5IGlmIGEgcGFydCBvZiB0aGUgdHJhY2UgaXMgdXNhYmxlLiBUaGlzIGdpdmVzIHVzXG4gICAgIGEgYml0IG1vcmUgd29yayB0aGFuIGp1c3QgY29udmVydF9yYXdfYmFja3RyYWNlLCBidXQgaXQgbWFrZXMgdGhlXG4gICAgIEFQSSBtb3JlIHVzZXItZnJpZW5kbHkgLS0gb3RoZXJ3aXNlIG1vc3QgdXNlcnMgd291bGQgaGF2ZSB0b1xuICAgICByZWltcGxlbWVudCB0aGUgXCJQcm9ncmFtIG5vdCBsaW5rZWQgd2l0aCAtZywgc29ycnlcIiBsb2dpY1xuICAgICB0aGVtc2VsdmVzLiAqKVxuICBtYXRjaCBjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgYmFja3RyYWNlIC0+XG4gICAgICBsZXQgdXNhYmxlX3Nsb3QgPSBmdW5jdGlvblxuICAgICAgICB8IFVua25vd25fbG9jYXRpb24gXyAtPiBmYWxzZVxuICAgICAgICB8IEtub3duX2xvY2F0aW9uIF8gLT4gdHJ1ZSBpblxuICAgICAgbGV0IHJlYyBleGlzdHNfdXNhYmxlID0gZnVuY3Rpb25cbiAgICAgICAgfCAoLTEpIC0+IGZhbHNlXG4gICAgICAgIHwgaSAtPiB1c2FibGVfc2xvdCBiYWNrdHJhY2UuKGkpIHx8IGV4aXN0c191c2FibGUgKGkgLSAxKSBpblxuICAgICAgaWYgZXhpc3RzX3VzYWJsZSAoQXJyYXkubGVuZ3RoIGJhY2t0cmFjZSAtIDEpXG4gICAgICB0aGVuIFNvbWUgYmFja3RyYWNlXG4gICAgICBlbHNlIE5vbmVcblxubGV0IGJhY2t0cmFjZV9zbG90c19vZl9yYXdfZW50cnkgZW50cnkgPVxuICBiYWNrdHJhY2Vfc2xvdHMgW3wgZW50cnkgfF1cblxubW9kdWxlIFNsb3QgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gYmFja3RyYWNlX3Nsb3RcbiAgbGV0IGZvcm1hdCA9IGZvcm1hdF9iYWNrdHJhY2Vfc2xvdFxuICBsZXQgaXNfcmFpc2UgPSBiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZVxuICBsZXQgaXNfaW5saW5lID0gYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lXG4gIGxldCBsb2NhdGlvbiA9IGJhY2t0cmFjZV9zbG90X2xvY2F0aW9uXG4gIGxldCBuYW1lID0gYmFja3RyYWNlX3Nsb3RfZGVmbmFtZVxuZW5kXG5cbmxldCByYXdfYmFja3RyYWNlX2xlbmd0aCBidCA9IEFycmF5Lmxlbmd0aCBidFxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZV9zbG90IDpcbiAgcmF3X2JhY2t0cmFjZSAtPiBpbnQgLT4gcmF3X2JhY2t0cmFjZV9zbG90ID0gXCJjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdFwiXG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCA6XG4gIHJhd19iYWNrdHJhY2Vfc2xvdCAtPiByYXdfYmFja3RyYWNlX3Nsb3Qgb3B0aW9uXG4gID0gXCJjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90XCJcblxuKCogY29uZnVzaW5nbHkgbmFtZWQ6XG4gICByZXR1cm5zIHRoZSAqc3RyaW5nKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnbG9iYWwgY3VycmVudCBiYWNrdHJhY2UgKilcbmxldCBnZXRfYmFja3RyYWNlICgpID0gcmF3X2JhY2t0cmFjZV90b19zdHJpbmcgKGdldF9yYXdfYmFja3RyYWNlICgpKVxuXG5leHRlcm5hbCByZWNvcmRfYmFja3RyYWNlOiBib29sIC0+IHVuaXQgPSBcImNhbWxfcmVjb3JkX2JhY2t0cmFjZVwiXG5leHRlcm5hbCBiYWNrdHJhY2Vfc3RhdHVzOiB1bml0IC0+IGJvb2wgPSBcImNhbWxfYmFja3RyYWNlX3N0YXR1c1wiXG5cbmxldCByZWMgcmVnaXN0ZXJfcHJpbnRlciBmbiA9XG4gIGxldCBvbGRfcHJpbnRlcnMgPSBBdG9taWMuZ2V0IHByaW50ZXJzIGluXG4gIGxldCBuZXdfcHJpbnRlcnMgPSBmbiA6OiBvbGRfcHJpbnRlcnMgaW5cbiAgbGV0IHN1Y2Nlc3MgPSBBdG9taWMuY29tcGFyZV9hbmRfc2V0IHByaW50ZXJzIG9sZF9wcmludGVycyBuZXdfcHJpbnRlcnMgaW5cbiAgaWYgbm90IHN1Y2Nlc3MgdGhlbiByZWdpc3Rlcl9wcmludGVyIGZuXG5cbmV4dGVybmFsIGdldF9jYWxsc3RhY2s6IGludCAtPiByYXdfYmFja3RyYWNlID0gXCJjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFja1wiXG5cbmxldCBleG5fc2xvdCB4ID1cbiAgbGV0IHggPSBPYmoucmVwciB4IGluXG4gIGlmIE9iai50YWcgeCA9IDAgdGhlbiBPYmouZmllbGQgeCAwIGVsc2UgeFxuXG5sZXQgZXhuX3Nsb3RfaWQgeCA9XG4gIGxldCBzbG90ID0gZXhuX3Nsb3QgeCBpblxuICAoT2JqLm9iaiAoT2JqLmZpZWxkIHNsb3QgMSkgOiBpbnQpXG5cbmxldCBleG5fc2xvdF9uYW1lIHggPVxuICBsZXQgc2xvdCA9IGV4bl9zbG90IHggaW5cbiAgKE9iai5vYmogKE9iai5maWVsZCBzbG90IDApIDogc3RyaW5nKVxuXG5leHRlcm5hbCBnZXRfZGVidWdfaW5mb19zdGF0dXMgOiB1bml0IC0+IGludCA9IFwiY2FtbF9tbF9kZWJ1Z19pbmZvX3N0YXR1c1wiXG5cbigqIERlc2NyaXB0aW9ucyBmb3IgZXJyb3JzIGluIHN0YXJ0dXAuaC4gU2VlIGFsc28gYmFja3RyYWNlLmMgKilcbmxldCBlcnJvcnMgPSBbfCBcIlwiO1xuICAoKiBGSUxFX05PVF9GT1VORCAqKVxuICBcIihDYW5ub3QgcHJpbnQgbG9jYXRpb25zOlxcbiBcXFxuICAgICAgYnl0ZWNvZGUgZXhlY3V0YWJsZSBwcm9ncmFtIGZpbGUgbm90IGZvdW5kKVwiO1xuICAoKiBCQURfQllURUNPREUgKilcbiAgXCIoQ2Fubm90IHByaW50IGxvY2F0aW9uczpcXG4gXFxcbiAgICAgIGJ5dGVjb2RlIGV4ZWN1dGFibGUgcHJvZ3JhbSBmaWxlIGFwcGVhcnMgdG8gYmUgY29ycnVwdClcIjtcbiAgKCogV1JPTkdfTUFHSUMgKilcbiAgXCIoQ2Fubm90IHByaW50IGxvY2F0aW9uczpcXG4gXFxcbiAgICAgIGJ5dGVjb2RlIGV4ZWN1dGFibGUgcHJvZ3JhbSBmaWxlIGhhcyB3cm9uZyBtYWdpYyBudW1iZXIpXCI7XG4gICgqIE5PX0ZEUyAqKVxuICBcIihDYW5ub3QgcHJpbnQgbG9jYXRpb25zOlxcbiBcXFxuICAgICAgYnl0ZWNvZGUgZXhlY3V0YWJsZSBwcm9ncmFtIGZpbGUgY2Fubm90IGJlIG9wZW5lZDtcXG4gXFxcbiAgICAgIC0tIHRvbyBtYW55IG9wZW4gZmlsZXMuIFRyeSBydW5uaW5nIHdpdGggT0NBTUxSVU5QQVJBTT1iPTIpXCJcbnxdXG5cbmxldCBkZWZhdWx0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIGV4biByYXdfYmFja3RyYWNlID1cbiAgZXByaW50ZiBcIkZhdGFsIGVycm9yOiBleGNlcHRpb24gJXNcXG5cIiAodG9fc3RyaW5nIGV4bik7XG4gIHByaW50X3Jhd19iYWNrdHJhY2Ugc3RkZXJyIHJhd19iYWNrdHJhY2U7XG4gIGxldCBzdGF0dXMgPSBnZXRfZGVidWdfaW5mb19zdGF0dXMgKCkgaW5cbiAgaWYgc3RhdHVzIDwgMCB0aGVuXG4gICAgcHJlcnJfZW5kbGluZSBlcnJvcnMuKGFicyBzdGF0dXMpO1xuICBmbHVzaCBzdGRlcnJcblxubGV0IHVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyID0gcmVmIGRlZmF1bHRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXJcblxubGV0IHNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciBmbiA9IHVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIDo9IGZuXG5cbmxldCBlbXB0eV9iYWNrdHJhY2UgOiByYXdfYmFja3RyYWNlID0gW3wgfF1cblxubGV0IHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKSA9XG4gIHRyeVxuICAgIGdldF9yYXdfYmFja3RyYWNlICgpXG4gIHdpdGggXyAoKiBPdXRfb2ZfbWVtb3J5PyAqKSAtPlxuICAgIGVtcHR5X2JhY2t0cmFjZVxuXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbicgZXhuIGRlYnVnZ2VyX2luX3VzZSA9XG4gIHRyeVxuICAgICgqIEdldCB0aGUgYmFja3RyYWNlIG5vdywgaW4gY2FzZSBvbmUgb2YgdGhlIFthdF9leGl0XSBmdW5jdGlvblxuICAgICAgIGRlc3Ryb3lzIGl0LiAqKVxuICAgIGxldCByYXdfYmFja3RyYWNlID1cbiAgICAgIGlmIGRlYnVnZ2VyX2luX3VzZSAoKiBTYW1lIHRlc3QgYXMgaW4gW3J1bnRpbWUvcHJpbnRleGMuY10gKikgdGhlblxuICAgICAgICBlbXB0eV9iYWNrdHJhY2VcbiAgICAgIGVsc2VcbiAgICAgICAgdHJ5X2dldF9yYXdfYmFja3RyYWNlICgpXG4gICAgaW5cbiAgICAodHJ5IFN0ZGxpYi5kb19hdF9leGl0ICgpIHdpdGggXyAtPiAoKSk7XG4gICAgdHJ5XG4gICAgICAhdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgZXhuIHJhd19iYWNrdHJhY2VcbiAgICB3aXRoIGV4bicgLT5cbiAgICAgIGxldCByYXdfYmFja3RyYWNlJyA9IHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICAgZXByaW50ZiBcIkZhdGFsIGVycm9yOiBleGNlcHRpb24gJXNcXG5cIiAodG9fc3RyaW5nIGV4bik7XG4gICAgICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlO1xuICAgICAgZXByaW50ZiBcIkZhdGFsIGVycm9yIGluIHVuY2F1Z2h0IGV4Y2VwdGlvbiBoYW5kbGVyOiBleGNlcHRpb24gJXNcXG5cIlxuICAgICAgICAodG9fc3RyaW5nIGV4bicpO1xuICAgICAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZSc7XG4gICAgICBmbHVzaCBzdGRlcnJcbiAgd2l0aFxuICAgIHwgT3V0X29mX21lbW9yeSAtPlxuICAgICAgICBwcmVycl9lbmRsaW5lXG4gICAgICAgICAgXCJGYXRhbCBlcnJvcjogb3V0IG9mIG1lbW9yeSBpbiB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlclwiXG5cbigqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IFtjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbl0gaW5cbiAgIFtydW50aW1lL3ByaW50ZXhjLmNdIHdoaWNoIGV4cGVjdHMgbm8gZXhjZXB0aW9uIGlzIHJhaXNlZC4gKilcbmxldCBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uIGV4biBkZWJ1Z2dlcl9pbl91c2UgPVxuICB0cnlcbiAgICBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uJyBleG4gZGVidWdnZXJfaW5fdXNlXG4gIHdpdGggXyAtPlxuICAgICgqIFRoZXJlIGlzIG5vdCBtdWNoIHdlIGNhbiBkbyBhdCB0aGlzIHBvaW50ICopXG4gICAgKClcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gJ2EgLT4gdW5pdFxuICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCAoKSA9XG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUHJpbnRleGMuaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvblwiXG4gICAgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvblxuIiwiKCpcbiAgIFJFIC0gQSByZWd1bGFyIGV4cHJlc3Npb24gbGlicmFyeVxuXG4gICBDb3B5cmlnaHQgKEMpIDIwMDEgSmVyb21lIFZvdWlsbG9uXG4gICBlbWFpbDogSmVyb21lLlZvdWlsbG9uQHBwcy5qdXNzaWV1LmZyXG5cbiAgIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAgIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGhcbiAgIGxpbmtpbmcgZXhjZXB0aW9uOyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdFxuICAgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICBUaGlzIGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVVxuICAgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICAgTGljZW5zZSBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICAgRm91bmRhdGlvbiwgSW5jLiwgNTEgRnJhbmtsaW4gU3RyZWV0LCBGaWZ0aCBGbG9vciwgQm9zdG9uLCBNQSAwMjExMC0xMzAxIFVTQVxuKilcblxudHlwZSBjID0gaW50XG50eXBlIHQgPSAoYyAqIGMpIGxpc3RcblxubGV0IHJlYyB1bmlvbiBsIGwnID1cbiAgbWF0Y2ggbCwgbCcgd2l0aFxuICAgIF8sIFtdIC0+IGxcbiAgfCBbXSwgXyAtPiBsJ1xuICB8IChjMSwgYzIpOjpyLCAoYzEnLCBjMicpOjpyJyAtPlxuICAgIGlmIGMyICsgMSA8IGMxJyB0aGVuXG4gICAgICAoYzEsIGMyKTo6dW5pb24gciBsJ1xuICAgIGVsc2UgaWYgYzInICsgMSA8IGMxIHRoZW5cbiAgICAgIChjMScsIGMyJyk6OnVuaW9uIGwgcidcbiAgICBlbHNlIGlmIGMyIDwgYzInIHRoZW5cbiAgICAgIHVuaW9uIHIgKChtaW4gYzEgYzEnLCBjMicpOjpyJylcbiAgICBlbHNlXG4gICAgICB1bmlvbiAoKG1pbiBjMSBjMScsIGMyKTo6cikgcidcblxubGV0IHJlYyBpbnRlciBsIGwnID1cbiAgbWF0Y2ggbCwgbCcgd2l0aFxuICAgIF8sIFtdIC0+IFtdXG4gIHwgW10sIF8gLT4gW11cbiAgfCAoYzEsIGMyKTo6ciwgKGMxJywgYzInKTo6cicgLT5cbiAgICBpZiBjMiA8IGMxJyB0aGVuXG4gICAgICBpbnRlciByIGwnXG4gICAgZWxzZSBpZiBjMicgPCBjMSB0aGVuXG4gICAgICBpbnRlciBsIHInXG4gICAgZWxzZSBpZiBjMiA8IGMyJyB0aGVuXG4gICAgICAobWF4IGMxIGMxJywgYzIpOjppbnRlciByIGwnXG4gICAgZWxzZVxuICAgICAgKG1heCBjMSBjMScsIGMyJyk6OmludGVyIGwgcidcblxubGV0IHJlYyBkaWZmIGwgbCcgPVxuICBtYXRjaCBsLCBsJyB3aXRoXG4gICAgXywgW10gLT4gbFxuICB8IFtdLCBfIC0+IFtdXG4gIHwgKGMxLCBjMik6OnIsIChjMScsIGMyJyk6OnInIC0+XG4gICAgaWYgYzIgPCBjMScgdGhlblxuICAgICAgKGMxLCBjMik6OmRpZmYgciBsJ1xuICAgIGVsc2UgaWYgYzInIDwgYzEgdGhlblxuICAgICAgZGlmZiBsIHInXG4gICAgZWxzZVxuICAgICAgbGV0IHInJyA9IGlmIGMyJyA8IGMyIHRoZW4gKGMyJyArIDEsIGMyKSA6OiByIGVsc2UgciBpblxuICAgICAgaWYgYzEgPCBjMScgdGhlblxuICAgICAgICAoYzEsIGMxJyAtIDEpOjpkaWZmIHInJyByJ1xuICAgICAgZWxzZVxuICAgICAgICBkaWZmIHInJyByJ1xuXG5sZXQgc2luZ2xlIGMgPSBbYywgY11cblxubGV0IGFkZCBjIGwgPSB1bmlvbiAoc2luZ2xlIGMpIGxcblxubGV0IHNlcSBjIGMnID0gaWYgYyA8PSBjJyB0aGVuIFtjLCBjJ10gZWxzZSBbYycsIGNdXG5cbmxldCByZWMgb2Zmc2V0IG8gbCA9XG4gIG1hdGNoIGwgd2l0aFxuICAgIFtdICAgICAgICAgICAgLT4gW11cbiAgfCAoYzEsIGMyKSA6OiByIC0+IChjMSArIG8sIGMyICsgbykgOjogb2Zmc2V0IG8gclxuXG5sZXQgZW1wdHkgPSBbXVxuXG5sZXQgcmVjIG1lbSAoYyA6IGludCkgcyA9XG4gIG1hdGNoIHMgd2l0aFxuICAgIFtdICAgICAgICAgICAgICAtPiBmYWxzZVxuICB8IChjMSwgYzIpIDo6IHJlbSAtPiBpZiBjIDw9IGMyIHRoZW4gYyA+PSBjMSBlbHNlIG1lbSBjIHJlbVxuXG4oKioqKilcblxudHlwZSBoYXNoID0gaW50XG5cbmxldCByZWMgaGFzaF9yZWMgPSBmdW5jdGlvblxuICB8IFtdICAgICAgICAtPiAwXG4gIHwgKGksIGopOjpyIC0+IGkgKyAxMyAqIGogKyAyNTcgKiBoYXNoX3JlYyByXG5sZXQgaGFzaCBsID0gKGhhc2hfcmVjIGwpIGxhbmQgMHgzRkZGRkZGRlxuXG4oKioqKilcblxubGV0IHByaW50X29uZSBjaCAoYzEsIGMyKSA9XG4gIGlmIGMxID0gYzIgdGhlblxuICAgIEZvcm1hdC5mcHJpbnRmIGNoIFwiJWRcIiBjMVxuICBlbHNlXG4gICAgRm9ybWF0LmZwcmludGYgY2ggXCIlZC0lZFwiIGMxIGMyXG5cbmxldCBwcCA9IEZtdC5saXN0IHByaW50X29uZVxuXG5sZXQgcmVjIGl0ZXIgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+ICgpXG4gIHwgKHgsIHkpOjp4cyAtPlxuICAgIGYgeCB5O1xuICAgIGl0ZXIgeHMgIH5mXG5cbmxldCBvbmVfY2hhciA9IGZ1bmN0aW9uXG4gIHwgW2ksIGpdIHdoZW4gaSA9IGogLT4gU29tZSBpXG4gIHwgXyAtPiBOb25lXG5cblxubW9kdWxlIENTZXRNYXAgPSBNYXAuTWFrZSAoc3RydWN0XG4gICAgdHlwZSB0ID0gaW50ICogKGludCAqIGludCkgbGlzdFxuICAgIGxldCBjb21wYXJlIChpLCB1KSAoaiwgdikgPVxuICAgICAgbGV0IGMgPSBjb21wYXJlIGkgaiBpblxuICAgICAgaWYgYyA8PiAwXG4gICAgICB0aGVuIGNcbiAgICAgIGVsc2UgY29tcGFyZSB1IHZcbiAgZW5kKVxuXG5sZXQgZm9sZF9yaWdodCB0IH5pbml0IH5mID0gTGlzdC5mb2xkX3JpZ2h0IGYgdCBpbml0XG5cbmxldCBjc2luZ2xlIGMgPSBzaW5nbGUgKENoYXIuY29kZSBjKVxuXG5sZXQgY2FueSA9IFswLCAyNTVdXG5cbmxldCBpc19lbXB0eSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxubGV0IHJlYyBwcmVwZW5kIHMgeCBsID1cbiAgbWF0Y2ggcywgbCB3aXRoXG4gIHwgW10sIF8gLT4gbFxuICB8IF9yLCBbXSAtPiBbXVxuICB8IChfYywgYycpIDo6IHIsIChbZCwgX2QnXSwgX3gnKSA6OiBfcicgd2hlbiBjJyA8IGQgLT4gcHJlcGVuZCByIHggbFxuICB8IChjLCBjJykgOjogciwgKFtkLCBkJ10sIHgnKSA6OiByJyAtPlxuICAgIGlmIGMgPD0gZCB0aGVuIGJlZ2luXG4gICAgICBpZiBjJyA8IGQnXG4gICAgICB0aGVuIChbZCwgYyddLCB4IEAgeCcpIDo6IHByZXBlbmQgciB4ICgoW2MnICsgMSwgZCddLCB4JykgOjogcicpXG4gICAgICBlbHNlIChbZCwgZCddLCB4IEAgeCcpIDo6IHByZXBlbmQgcyB4IHInXG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIGlmIGMgPiBkJ1xuICAgICAgdGhlbiAoW2QsIGQnXSwgeCcpIDo6IHByZXBlbmQgcyB4IHInXG4gICAgICBlbHNlIChbZCwgYyAtIDFdLCB4JykgOjogcHJlcGVuZCBzIHggKChbYywgZCddLCB4JykgOjogcicpXG4gICAgZW5kXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IHBpY2sgPSBmdW5jdGlvblxuICB8IFtdIC0+IGludmFsaWRfYXJnIFwiUmVfY3NldC5waWNrXCJcbiAgfCAoeCwgXyk6Ol8gLT4geFxuIiwiKCpcbiAgIFJFIC0gQSByZWd1bGFyIGV4cHJlc3Npb24gbGlicmFyeVxuXG4gICBDb3B5cmlnaHQgKEMpIDIwMDEgSmVyb21lIFZvdWlsbG9uXG4gICBlbWFpbDogSmVyb21lLlZvdWlsbG9uQHBwcy5qdXNzaWV1LmZyXG5cbiAgIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAgIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGhcbiAgIGxpbmtpbmcgZXhjZXB0aW9uOyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdFxuICAgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICBUaGlzIGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVVxuICAgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICAgTGljZW5zZSBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICAgRm91bmRhdGlvbiwgSW5jLiwgNTEgRnJhbmtsaW4gU3RyZWV0LCBGaWZ0aCBGbG9vciwgQm9zdG9uLCBNQSAwMjExMC0xMzAxIFVTQVxuKilcblxudHlwZSBzZW0gPSBbIGBMb25nZXN0IHwgYFNob3J0ZXN0IHwgYEZpcnN0IF1cblxudHlwZSByZXBfa2luZCA9IFsgYEdyZWVkeSB8IGBOb25fZ3JlZWR5IF1cblxudHlwZSBtYXJrID0gaW50XG50eXBlIGlkeCA9IGludFxuXG50eXBlIGV4cHIgPSB7IGlkIDogaW50OyBkZWYgOiBkZWYgfVxuXG5hbmQgZGVmID1cbiAgICBDc3Qgb2YgQ3NldC50XG4gIHwgQWx0IG9mIGV4cHIgbGlzdFxuICB8IFNlcSBvZiBzZW0gKiBleHByICogZXhwclxuICB8IEVwc1xuICB8IFJlcCBvZiByZXBfa2luZCAqIHNlbSAqIGV4cHJcbiAgfCBNYXJrIG9mIGludFxuICB8IEVyYXNlIG9mIGludCAqIGludFxuICB8IEJlZm9yZSBvZiBDYXRlZ29yeS50XG4gIHwgQWZ0ZXIgb2YgQ2F0ZWdvcnkudFxuICB8IFBtYXJrIG9mIFBtYXJrLnRcblxubGV0IGhhc2hfY29tYmluZSBoIGFjY3UgPSBhY2N1ICogNjU1OTkgKyBoXG5cbm1vZHVsZSBNYXJrcyA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgbWFya3MgOiAoaW50ICogaW50KSBsaXN0XG4gICAgOyBwbWFya3MgOiBQbWFyay5TZXQudCB9XG5cbiAgbGV0IGVtcHR5ID0geyBtYXJrcyA9IFtdIDsgcG1hcmtzID0gUG1hcmsuU2V0LmVtcHR5IH1cblxuICBsZXQgcmVjIG1lcmdlX21hcmtzX29mZnNldCBvbGQgPSBmdW5jdGlvblxuICAgIHwgW10gLT5cbiAgICAgIG9sZFxuICAgIHwgKGksIHYpIDo6IHJlbSAtPlxuICAgICAgbGV0IG53JyA9IG1lcmdlX21hcmtzX29mZnNldCAoTGlzdC5yZW1vdmVfYXNzcSBpIG9sZCkgcmVtIGluXG4gICAgICBpZiB2ID0gLTIgdGhlblxuICAgICAgICBudydcbiAgICAgIGVsc2VcbiAgICAgICAgKGksIHYpIDo6IG53J1xuXG4gIGxldCBtZXJnZSBvbGQgbncgPVxuICAgIHsgbWFya3MgPSBtZXJnZV9tYXJrc19vZmZzZXQgb2xkLm1hcmtzIG53Lm1hcmtzXG4gICAgOyBwbWFya3MgPSBQbWFyay5TZXQudW5pb24gb2xkLnBtYXJrcyBudy5wbWFya3MgfVxuXG4gIGxldCByZWMgaGFzaF9tYXJrc19vZmZzZXQgbCBhY2N1ID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICAgIFtdICAgICAgICAgIC0+IGFjY3VcbiAgICB8IChhLCBpKSA6OiByIC0+IGhhc2hfbWFya3Nfb2Zmc2V0IHIgKGhhc2hfY29tYmluZSBhIChoYXNoX2NvbWJpbmUgaSBhY2N1KSlcblxuICBsZXQgaGFzaCBtIGFjY3UgPVxuICAgIGhhc2hfbWFya3Nfb2Zmc2V0IG0ubWFya3MgKGhhc2hfY29tYmluZSAoSGFzaHRibC5oYXNoIG0ucG1hcmtzKSBhY2N1KVxuXG4gIGxldCByZWMgbWFya3Nfc2V0X2lkeCBpZHggPSBmdW5jdGlvblxuICAgIHwgKGEsIC0xKSA6OiByZW0gLT5cbiAgICAgIChhLCBpZHgpIDo6IG1hcmtzX3NldF9pZHggaWR4IHJlbVxuICAgIHwgbWFya3MgLT5cbiAgICAgIG1hcmtzXG5cbiAgbGV0IG1hcmtzX3NldF9pZHggbWFya3MgaWR4ID1cbiAgICB7IG1hcmtzIHdpdGggbWFya3MgPSBtYXJrc19zZXRfaWR4IGlkeCBtYXJrcy5tYXJrcyB9XG5cbiAgbGV0IHBwX21hcmtzIGNoIHQgPVxuICAgIG1hdGNoIHQubWFya3Mgd2l0aFxuICAgIHwgW10gLT5cbiAgICAgICgpXG4gICAgfCAoYSwgaSkgOjogciAtPlxuICAgICAgRm9ybWF0LmZwcmludGYgY2ggXCIlZC0lZFwiIGEgaTtcbiAgICAgIExpc3QuaXRlciAoZnVuIChhLCBpKSAtPiBGb3JtYXQuZnByaW50ZiBjaCBcIiAlZC0lZFwiIGEgaSkgclxuZW5kXG5cbigqKioqKVxuXG5sZXQgcHBfc2VtIGNoIGsgPVxuICBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIGNoXG4gICAgKG1hdGNoIGsgd2l0aFxuICAgICAgIGBTaG9ydGVzdCAtPiBcInNob3J0XCJcbiAgICAgfCBgTG9uZ2VzdCAgLT4gXCJsb25nXCJcbiAgICAgfCBgRmlyc3QgICAgLT4gXCJmaXJzdFwiKVxuXG5cbmxldCBwcF9yZXBfa2luZCBmbXQgPSBmdW5jdGlvblxuICB8IGBHcmVlZHkgLT4gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBmbXQgXCJHcmVlZHlcIlxuICB8IGBOb25fZ3JlZWR5IC0+IEZvcm1hdC5wcF9wcmludF9zdHJpbmcgZm10IFwiTm9uX2dyZWVkeVwiXG5cbmxldCByZWMgcHAgY2ggZSA9XG4gIGxldCBvcGVuIEZtdCBpblxuICBtYXRjaCBlLmRlZiB3aXRoXG4gICAgQ3N0IGwgLT5cbiAgICBzZXhwIGNoIFwiY3N0XCIgQ3NldC5wcCBsO1xuICB8IEFsdCBsIC0+XG4gICAgc2V4cCBjaCBcImFsdFwiIChsaXN0IHBwKSBsXG4gIHwgU2VxIChrLCBlLCBlJykgLT5cbiAgICBzZXhwIGNoIFwic2VxXCIgKHRyaXBsZSBwcF9zZW0gcHAgcHApIChrLCBlLCBlJylcbiAgfCBFcHMgLT5cbiAgICBzdHIgY2ggXCJlcHNcIlxuICB8IFJlcCAoX3JrLCBrLCBlKSAtPlxuICAgIHNleHAgY2ggXCJyZXBcIiAocGFpciBwcF9zZW0gcHApIChrLCBlKVxuICB8IE1hcmsgaSAtPlxuICAgIHNleHAgY2ggXCJtYXJrXCIgaW50IGlcbiAgfCBQbWFyayBpIC0+XG4gICAgc2V4cCBjaCBcInBtYXJrXCIgaW50IChpIDo+IGludClcbiAgfCBFcmFzZSAoYiwgZSkgLT5cbiAgICBzZXhwIGNoIFwiZXJhc2VcIiAocGFpciBpbnQgaW50KSAoYiwgZSlcbiAgfCBCZWZvcmUgYyAtPlxuICAgIHNleHAgY2ggXCJiZWZvcmVcIiBDYXRlZ29yeS5wcCBjXG4gIHwgQWZ0ZXIgYyAtPlxuICAgIHNleHAgY2ggXCJhZnRlclwiIENhdGVnb3J5LnBwIGNcblxuXG4oKioqKilcblxubGV0IHJlYyBmaXJzdCBmID0gZnVuY3Rpb25cbiAgfCBbXSAtPlxuICAgIE5vbmVcbiAgfCB4IDo6IHIgLT5cbiAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgTm9uZSAgICAgICAgICAtPiBmaXJzdCBmIHJcbiAgICB8IFNvbWUgXyBhcyByZXMgLT4gcmVzXG5cbigqKioqKVxuXG50eXBlIGlkcyA9IGludCByZWZcbmxldCBjcmVhdGVfaWRzICgpID0gcmVmIDBcblxubGV0IGVwc19leHByID0geyBpZCA9IDA7IGRlZiA9IEVwcyB9XG5cbmxldCBta19leHByIGlkcyBkZWYgPVxuICBpbmNyIGlkcztcbiAgeyBpZCA9ICFpZHM7IGRlZiA9IGRlZiB9XG5cbmxldCBlbXB0eSBpZHMgPSBta19leHByIGlkcyAoQWx0IFtdKVxuXG5sZXQgY3N0IGlkcyBzID1cbiAgaWYgQ3NldC5pc19lbXB0eSBzXG4gIHRoZW4gZW1wdHkgaWRzXG4gIGVsc2UgbWtfZXhwciBpZHMgKENzdCBzKVxuXG5sZXQgYWx0IGlkcyA9IGZ1bmN0aW9uXG4gIHwgW10gIC0+IGVtcHR5IGlkc1xuICB8IFtjXSAtPiBjXG4gIHwgbCAgIC0+IG1rX2V4cHIgaWRzIChBbHQgbClcblxubGV0IHNlcSBpZHMga2luZCB4IHkgPVxuICBtYXRjaCB4LmRlZiwgeS5kZWYgd2l0aFxuICAgIEFsdCBbXSwgXyAgICAgICAgICAgICAgICAgLT4geFxuICB8IF8sIEFsdCBbXSAgICAgICAgICAgICAgICAgLT4geVxuICB8IEVwcywgXyAgICAgICAgICAgICAgICAgICAgLT4geVxuICB8IF8sIEVwcyB3aGVuIGtpbmQgPSBgRmlyc3QgLT4geFxuICB8IF8gICAgICAgICAgICAgICAgICAgICAgICAgLT4gbWtfZXhwciBpZHMgKFNlcSAoa2luZCwgeCwgeSkpXG5cbmxldCBpc19lcHMgZXhwciA9XG4gIG1hdGNoIGV4cHIuZGVmIHdpdGhcbiAgfCBFcHMgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxubGV0IGVwcyBpZHMgPSBta19leHByIGlkcyBFcHNcblxubGV0IHJlcCBpZHMga2luZCBzZW0geCA9IG1rX2V4cHIgaWRzIChSZXAgKGtpbmQsIHNlbSwgeCkpXG5cbmxldCBtYXJrIGlkcyBtID0gbWtfZXhwciBpZHMgKE1hcmsgbSlcblxubGV0IHBtYXJrIGlkcyBpID0gbWtfZXhwciBpZHMgKFBtYXJrIGkpXG5cbmxldCBlcmFzZSBpZHMgbSBtJyA9IG1rX2V4cHIgaWRzIChFcmFzZSAobSwgbScpKVxuXG5sZXQgYmVmb3JlIGlkcyBjID0gbWtfZXhwciBpZHMgKEJlZm9yZSBjKVxuXG5sZXQgYWZ0ZXIgaWRzIGMgPSBta19leHByIGlkcyAoQWZ0ZXIgYylcblxuKCoqKiopXG5cbmxldCByZWMgcmVuYW1lIGlkcyB4ID1cbiAgbWF0Y2ggeC5kZWYgd2l0aFxuICAgIENzdCBfIHwgRXBzIHwgTWFyayBfIHwgUG1hcmsgXyB8IEVyYXNlIF8gfCBCZWZvcmUgXyB8IEFmdGVyIF8gLT5cbiAgICBta19leHByIGlkcyB4LmRlZlxuICB8IEFsdCBsIC0+XG4gICAgbWtfZXhwciBpZHMgKEFsdCAoTGlzdC5tYXAgKHJlbmFtZSBpZHMpIGwpKVxuICB8IFNlcSAoaywgeSwgeikgLT5cbiAgICBta19leHByIGlkcyAoU2VxIChrLCByZW5hbWUgaWRzIHksIHJlbmFtZSBpZHMgeikpXG4gIHwgUmVwIChnLCBrLCB5KSAtPlxuICAgIG1rX2V4cHIgaWRzIChSZXAgKGcsIGssIHJlbmFtZSBpZHMgeSkpXG5cbigqKioqKVxuXG50eXBlIGhhc2ggPSBpbnRcbnR5cGUgbWFya19pbmZvcyA9IGludCBhcnJheVxudHlwZSBzdGF0dXMgPSBGYWlsZWQgfCBNYXRjaCBvZiBtYXJrX2luZm9zICogUG1hcmsuU2V0LnQgfCBSdW5uaW5nXG5cbm1vZHVsZSBFID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBUU2VxIG9mIHQgbGlzdCAqIGV4cHIgKiBzZW1cbiAgICB8IFRFeHAgb2YgTWFya3MudCAqIGV4cHJcbiAgICB8IFRNYXRjaCBvZiBNYXJrcy50XG5cbiAgbGV0IHJlYyBlcXVhbCBsMSBsMiA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBbXSAtPlxuICAgICAgdHJ1ZVxuICAgIHwgVFNlcSAobDEnLCBlMSwgXykgOjogcjEsIFRTZXEgKGwyJywgZTIsIF8pIDo6IHIyIC0+XG4gICAgICBlMS5pZCA9IGUyLmlkICYmIGVxdWFsIGwxJyBsMicgJiYgZXF1YWwgcjEgcjJcbiAgICB8IFRFeHAgKG1hcmtzMSwgZTEpIDo6IHIxLCBURXhwIChtYXJrczIsIGUyKSA6OiByMiAtPlxuICAgICAgZTEuaWQgPSBlMi5pZCAmJiBtYXJrczEgPSBtYXJrczIgJiYgZXF1YWwgcjEgcjJcbiAgICB8IFRNYXRjaCBtYXJrczEgOjogcjEsIFRNYXRjaCBtYXJrczIgOjogcjIgLT5cbiAgICAgIG1hcmtzMSA9IG1hcmtzMiAmJiBlcXVhbCByMSByMlxuICAgIHwgXyAtPlxuICAgICAgZmFsc2VcblxuICBsZXQgcmVjIGhhc2ggbCBhY2N1ID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICBhY2N1XG4gICAgfCBUU2VxIChsJywgZSwgXykgOjogciAtPlxuICAgICAgaGFzaCByIChoYXNoX2NvbWJpbmUgMHgxNzJhMWJjZSAoaGFzaF9jb21iaW5lIGUuaWQgKGhhc2ggbCcgYWNjdSkpKVxuICAgIHwgVEV4cCAobWFya3MsIGUpIDo6IHIgLT5cbiAgICAgIGhhc2ggclxuICAgICAgICAoaGFzaF9jb21iaW5lIDB4MmI0YzBkNzcgKGhhc2hfY29tYmluZSBlLmlkIChNYXJrcy5oYXNoIG1hcmtzIGFjY3UpKSlcbiAgICB8IFRNYXRjaCBtYXJrcyA6OiByIC0+XG4gICAgICBoYXNoIHIgKGhhc2hfY29tYmluZSAweDFjMjA1YWQ1IChNYXJrcy5oYXNoIG1hcmtzIGFjY3UpKVxuXG4gIGxldCB0ZXhwIG1hcmtzIHggPSBURXhwIChtYXJrcywgeClcblxuICBsZXQgdHNlcSBraW5kIHggeSByZW0gPVxuICAgIG1hdGNoIHggd2l0aFxuICAgICAgW10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiByZW1cbiAgICB8IFtURXhwIChtYXJrcywge2RlZiA9IEVwcyA7IF99KV0gLT4gVEV4cCAobWFya3MsIHkpIDo6IHJlbVxuICAgIHwgXyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiBUU2VxICh4LCB5LCBraW5kKSA6OiByZW1cblxuICBsZXQgcmVjIHByaW50X3N0YXRlX3JlYyBjaCBlIHkgPVxuICAgIG1hdGNoIGUgd2l0aFxuICAgIHwgVE1hdGNoIG1hcmtzIC0+XG4gICAgICBGb3JtYXQuZnByaW50ZiBjaCBcIkBbPDI+KE1hdGNoQCAlYSlAXVwiIE1hcmtzLnBwX21hcmtzIG1hcmtzXG4gICAgfCBUU2VxIChsJywgeCwgX2tpbmQpIC0+XG4gICAgICBGb3JtYXQuZnByaW50ZiBjaCBcIkBbPDI+KFNlcUAgXCI7XG4gICAgICBwcmludF9zdGF0ZV9sc3QgY2ggbCcgeDtcbiAgICAgIEZvcm1hdC5mcHJpbnRmIGNoIFwiQCAlYSlAXVwiIHBwIHhcbiAgICB8IFRFeHAgKG1hcmtzLCB7ZGVmID0gRXBzOyBffSkgLT5cbiAgICAgIEZvcm1hdC5mcHJpbnRmIGNoIFwiQFs8Mj4oRXhwQCAlZEAgKCVhKUAgKGVwcykpQF1cIiB5LmlkIE1hcmtzLnBwX21hcmtzIG1hcmtzXG4gICAgfCBURXhwIChtYXJrcywgeCkgLT5cbiAgICAgIEZvcm1hdC5mcHJpbnRmIGNoIFwiQFs8Mj4oRXhwQCAlZEAgKCVhKUAgJWEpQF1cIiB4LmlkIE1hcmtzLnBwX21hcmtzIG1hcmtzIHBwIHhcblxuICBhbmQgcHJpbnRfc3RhdGVfbHN0IGNoIGwgeSA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgICBbXSAtPlxuICAgICAgRm9ybWF0LmZwcmludGYgY2ggXCIoKVwiXG4gICAgfCBlIDo6IHJlbSAtPlxuICAgICAgcHJpbnRfc3RhdGVfcmVjIGNoIGUgeTtcbiAgICAgIExpc3QuaXRlclxuICAgICAgICAoZnVuIGUgLT5cbiAgICAgICAgICAgRm9ybWF0LmZwcmludGYgY2ggXCJAIHwgXCI7XG4gICAgICAgICAgIHByaW50X3N0YXRlX3JlYyBjaCBlIHkpXG4gICAgICAgIHJlbVxuXG4gIGxldCBwcCBjaCB0ID0gcHJpbnRfc3RhdGVfbHN0IGNoIFt0XSB7IGlkID0gMDsgZGVmID0gRXBzIH1cbmVuZFxuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IGlkeDogaWR4XG4gICAgOyBjYXRlZ29yeTogQ2F0ZWdvcnkudFxuICAgIDsgZGVzYzogRS50IGxpc3RcbiAgICA7IG11dGFibGUgc3RhdHVzOiBzdGF0dXMgb3B0aW9uXG4gICAgOyBoYXNoOiBoYXNoIH1cblxuICBsZXQgZHVtbXkgPVxuICAgIHsgaWR4ID0gLTFcbiAgICA7IGNhdGVnb3J5ID0gQ2F0ZWdvcnkuZHVtbXlcbiAgICA7IGRlc2MgPSBbXVxuICAgIDsgc3RhdHVzID0gTm9uZVxuICAgIDsgaGFzaCA9IC0xIH1cblxuICBsZXQgaGFzaCBpZHggY2F0IGRlc2MgPVxuICAgIEUuaGFzaCBkZXNjIChoYXNoX2NvbWJpbmUgaWR4IChoYXNoX2NvbWJpbmUgKENhdGVnb3J5LnRvX2ludCBjYXQpIDApKSBsYW5kIDB4M0ZGRkZGRkZcblxuICBsZXQgbWsgaWR4IGNhdCBkZXNjID1cbiAgICB7IGlkeFxuICAgIDsgY2F0ZWdvcnkgPSBjYXRcbiAgICA7IGRlc2NcbiAgICA7IHN0YXR1cyA9IE5vbmVcbiAgICA7IGhhc2ggPSBoYXNoIGlkeCBjYXQgZGVzY31cblxuICBsZXQgY3JlYXRlIGNhdCBlID0gbWsgMCBjYXQgW0UuVEV4cCAoTWFya3MuZW1wdHksIGUpXVxuXG4gIGxldCBlcXVhbCB4IHkgPVxuICAgICh4Lmhhc2ggOiBpbnQpID0geS5oYXNoICYmICh4LmlkeCA6IGludCkgPSB5LmlkeCAmJlxuICAgIENhdGVnb3J5LmVxdWFsIHguY2F0ZWdvcnkgeS5jYXRlZ29yeSAmJiBFLmVxdWFsIHguZGVzYyB5LmRlc2NcblxuICBsZXQgY29tcGFyZSB4IHkgPVxuICAgIGxldCBjID0gY29tcGFyZSAoeC5oYXNoIDogaW50KSB5Lmhhc2ggaW5cbiAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2VcbiAgICAgIGxldCBjID0gQ2F0ZWdvcnkuY29tcGFyZSB4LmNhdGVnb3J5IHkuY2F0ZWdvcnkgaW5cbiAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZVxuICAgICAgICBjb21wYXJlIHguZGVzYyB5LmRlc2NcblxuICB0eXBlIHQnID0gdFxuICBtb2R1bGUgVGFibGUgPSBIYXNodGJsLk1ha2UoXG4gICAgc3RydWN0XG4gICAgICB0eXBlIHQgPSB0J1xuICAgICAgbGV0IGVxdWFsID0gZXF1YWxcbiAgICAgIGxldCBoYXNoIHQgPSB0Lmhhc2hcbiAgICBlbmQpXG5lbmRcblxuKCoqKiogRmluZCBhIGZyZWUgaW5kZXggKioqKilcblxudHlwZSB3b3JraW5nX2FyZWEgPSBib29sIGFycmF5IHJlZlxuXG5sZXQgY3JlYXRlX3dvcmtpbmdfYXJlYSAoKSA9IHJlZiBbfCBmYWxzZSB8XVxuXG5sZXQgaW5kZXhfY291bnQgdyA9IEFycmF5Lmxlbmd0aCAhd1xuXG5sZXQgcmVzZXRfdGFibGUgYSA9IEFycmF5LmZpbGwgYSAwIChBcnJheS5sZW5ndGggYSkgZmFsc2VcblxubGV0IHJlYyBtYXJrX3VzZWRfaW5kaWNlcyB0YmwgPVxuICBMaXN0Lml0ZXIgKGZ1bmN0aW9uXG4gICAgICB8IEUuVFNlcSAobCwgXywgXykgLT4gbWFya191c2VkX2luZGljZXMgdGJsIGxcbiAgICAgIHwgRS5URXhwIChtYXJrcywgXylcbiAgICAgIHwgRS5UTWF0Y2ggbWFya3MgLT5cbiAgICAgICAgTGlzdC5pdGVyIChmdW4gKF8sIGkpIC0+IGlmIGkgPj0gMCB0aGVuIHRibC4oaSkgPC0gdHJ1ZSlcbiAgICAgICAgICBtYXJrcy5NYXJrcy5tYXJrcylcblxubGV0IHJlYyBmaW5kX2ZyZWUgdGJsIGlkeCBsZW4gPVxuICBpZiBpZHggPSBsZW4gfHwgbm90IHRibC4oaWR4KSB0aGVuIGlkeCBlbHNlIGZpbmRfZnJlZSB0YmwgKGlkeCArIDEpIGxlblxuXG5sZXQgZnJlZV9pbmRleCB0YmxfcmVmIGwgPVxuICBsZXQgdGJsID0gIXRibF9yZWYgaW5cbiAgcmVzZXRfdGFibGUgdGJsO1xuICBtYXJrX3VzZWRfaW5kaWNlcyB0YmwgbDtcbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCB0YmwgaW5cbiAgbGV0IGlkeCA9IGZpbmRfZnJlZSB0YmwgMCBsZW4gaW5cbiAgaWYgaWR4ID0gbGVuIHRoZW4gdGJsX3JlZiA6PSBBcnJheS5tYWtlICgyICogbGVuKSBmYWxzZTtcbiAgaWR4XG5cbigqKioqIENvbXB1dGF0aW9uIG9mIHRoZSBuZXh0IHN0YXRlICoqKiopXG5cbmxldCByZW1vdmVfbWF0Y2hlcyA9IExpc3QuZmlsdGVyIChmdW5jdGlvbiBFLlRNYXRjaCBfIC0+IGZhbHNlIHwgXyAtPiB0cnVlKVxuXG5sZXQgcmVjIHNwbGl0X2F0X21hdGNoX3JlYyBsJyA9IGZ1bmN0aW9uXG4gIHwgW10gICAgICAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBFLlRNYXRjaCBfIDo6IHIgLT4gKExpc3QucmV2IGwnLCByZW1vdmVfbWF0Y2hlcyByKVxuICB8IHggOjogciAgICAgICAgLT4gc3BsaXRfYXRfbWF0Y2hfcmVjICh4IDo6IGwnKSByXG5cbmxldCBzcGxpdF9hdF9tYXRjaCBsID0gc3BsaXRfYXRfbWF0Y2hfcmVjIFtdIGxcblxubGV0IHJlYyByZW1vdmVfZHVwbGljYXRlcyBwcmV2IGwgeSA9XG4gIG1hdGNoIGwgd2l0aFxuICAgIFtdIC0+XG4gICAgKFtdLCBwcmV2KVxuICB8IEUuVE1hdGNoIF8gYXMgeCA6OiBfIC0+ICgqIFRydW5jYXRlIGFmdGVyIGZpcnN0IG1hdGNoICopXG4gICAgKFt4XSwgcHJldilcbiAgfCBFLlRTZXEgKGwnLCB4LCBraW5kKSA6OiByIC0+XG4gICAgbGV0IChsJycsIHByZXYnKSA9IHJlbW92ZV9kdXBsaWNhdGVzIHByZXYgbCcgeCBpblxuICAgIGxldCAocicsIHByZXYnJykgPSByZW1vdmVfZHVwbGljYXRlcyBwcmV2JyByIHkgaW5cbiAgICAoRS50c2VxIGtpbmQgbCcnIHggcicsIHByZXYnJylcbiAgfCBFLlRFeHAgKF9tYXJrcywge2RlZiA9IEVwczsgX30pIGFzIGUgOjogciAtPlxuICAgIGlmIExpc3QubWVtcSB5LmlkIHByZXYgdGhlblxuICAgICAgcmVtb3ZlX2R1cGxpY2F0ZXMgcHJldiByIHlcbiAgICBlbHNlXG4gICAgICBsZXQgKHInLCBwcmV2JykgPSByZW1vdmVfZHVwbGljYXRlcyAoeS5pZCA6OiBwcmV2KSByIHkgaW5cbiAgICAgIChlIDo6IHInLCBwcmV2JylcbiAgfCBFLlRFeHAgKF9tYXJrcywgeCkgYXMgZSA6OiByIC0+XG4gICAgaWYgTGlzdC5tZW1xIHguaWQgcHJldiB0aGVuXG4gICAgICByZW1vdmVfZHVwbGljYXRlcyBwcmV2IHIgeVxuICAgIGVsc2VcbiAgICAgIGxldCAocicsIHByZXYnKSA9IHJlbW92ZV9kdXBsaWNhdGVzICh4LmlkIDo6IHByZXYpIHIgeSBpblxuICAgICAgKGUgOjogcicsIHByZXYnKVxuXG5sZXQgcmVjIHNldF9pZHggaWR4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPlxuICAgIFtdXG4gIHwgRS5UTWF0Y2ggbWFya3MgOjogciAtPlxuICAgIEUuVE1hdGNoIChNYXJrcy5tYXJrc19zZXRfaWR4IG1hcmtzIGlkeCkgOjogc2V0X2lkeCBpZHggclxuICB8IEUuVFNlcSAobCcsIHgsIGtpbmQpIDo6IHIgLT5cbiAgICBFLlRTZXEgKHNldF9pZHggaWR4IGwnLCB4LCBraW5kKSA6OiBzZXRfaWR4IGlkeCByXG4gIHwgRS5URXhwIChtYXJrcywgeCkgOjogciAtPlxuICAgIEUuVEV4cCAoKE1hcmtzLm1hcmtzX3NldF9pZHggbWFya3MgaWR4KSwgeCkgOjogc2V0X2lkeCBpZHggclxuXG5sZXQgZmlsdGVyX21hcmtzIGIgZSBtYXJrcyA9XG4gIHttYXJrcyB3aXRoIE1hcmtzLm1hcmtzID0gTGlzdC5maWx0ZXIgKGZ1biAoaSwgXykgLT4gaSA8IGIgfHwgaSA+IGUpIG1hcmtzLk1hcmtzLm1hcmtzIH1cblxubGV0IHJlYyBkZWx0YV8xIG1hcmtzIGMgfm5leHRfY2F0IH5wcmV2X2NhdCB4IHJlbSA9XG4gICgqRm9ybWF0LmVwcmludGYgXCIlZEAuXCIgeC5pZDsqKVxuICBtYXRjaCB4LmRlZiB3aXRoXG4gICAgQ3N0IHMgLT5cbiAgICBpZiBDc2V0Lm1lbSBjIHMgdGhlbiBFLnRleHAgbWFya3MgZXBzX2V4cHIgOjogcmVtIGVsc2UgcmVtXG4gIHwgQWx0IGwgLT5cbiAgICBkZWx0YV8yIG1hcmtzIGMgfm5leHRfY2F0IH5wcmV2X2NhdCBsIHJlbVxuICB8IFNlcSAoa2luZCwgeSwgeikgLT5cbiAgICBsZXQgeScgPSBkZWx0YV8xIG1hcmtzIGMgfm5leHRfY2F0IH5wcmV2X2NhdCB5IFtdIGluXG4gICAgZGVsdGFfc2VxIGMgfm5leHRfY2F0IH5wcmV2X2NhdCBraW5kIHknIHogcmVtXG4gIHwgUmVwIChyZXBfa2luZCwga2luZCwgeSkgLT5cbiAgICBsZXQgeScgPSBkZWx0YV8xIG1hcmtzIGMgfm5leHRfY2F0IH5wcmV2X2NhdCB5IFtdIGluXG4gICAgbGV0ICh5JycsIG1hcmtzJykgPVxuICAgICAgbWF0Y2hcbiAgICAgICAgZmlyc3RcbiAgICAgICAgICAoZnVuY3Rpb24gRS5UTWF0Y2ggbWFya3MgLT4gU29tZSBtYXJrcyB8IF8gLT4gTm9uZSkgeSdcbiAgICAgIHdpdGhcbiAgICAgICAgTm9uZSAgICAgICAgLT4gKHknLCBtYXJrcylcbiAgICAgIHwgU29tZSBtYXJrcycgLT4gKHJlbW92ZV9tYXRjaGVzIHknLCBtYXJrcycpXG4gICAgaW5cbiAgICBiZWdpbiBtYXRjaCByZXBfa2luZCB3aXRoXG4gICAgICAgIGBHcmVlZHkgICAgIC0+IEUudHNlcSBraW5kIHknJyB4IChFLlRNYXRjaCBtYXJrcycgOjogcmVtKVxuICAgICAgfCBgTm9uX2dyZWVkeSAtPiBFLlRNYXRjaCBtYXJrcyA6OiBFLnRzZXEga2luZCB5JycgeCByZW1cbiAgICBlbmRcbiAgfCBFcHMgLT5cbiAgICBFLlRNYXRjaCBtYXJrcyA6OiByZW1cbiAgfCBNYXJrIGkgLT5cbiAgICBsZXQgbWFya3MgPSB7IG1hcmtzIHdpdGggTWFya3MubWFya3MgPSAoaSwgLTEpIDo6IExpc3QucmVtb3ZlX2Fzc3EgaSBtYXJrcy5NYXJrcy5tYXJrcyB9IGluXG4gICAgRS5UTWF0Y2ggbWFya3MgOjogcmVtXG4gIHwgUG1hcmsgaSAtPlxuICAgIGxldCBtYXJrcyA9IHsgbWFya3Mgd2l0aCBNYXJrcy5wbWFya3MgPSBQbWFyay5TZXQuYWRkIGkgbWFya3MuTWFya3MucG1hcmtzIH0gaW5cbiAgICBFLlRNYXRjaCBtYXJrcyA6OiByZW1cbiAgfCBFcmFzZSAoYiwgZSkgLT5cbiAgICBFLlRNYXRjaCAoZmlsdGVyX21hcmtzIGIgZSBtYXJrcykgOjogcmVtXG4gIHwgQmVmb3JlIGNhdCcnIC0+XG4gICAgaWYgQ2F0ZWdvcnkuaW50ZXJzZWN0IG5leHRfY2F0IGNhdCcnIHRoZW4gRS5UTWF0Y2ggbWFya3MgOjogcmVtIGVsc2UgcmVtXG4gIHwgQWZ0ZXIgY2F0JycgLT5cbiAgICBpZiBDYXRlZ29yeS5pbnRlcnNlY3QgcHJldl9jYXQgY2F0JycgdGhlbiBFLlRNYXRjaCBtYXJrcyA6OiByZW0gZWxzZSByZW1cblxuYW5kIGRlbHRhXzIgbWFya3MgYyB+bmV4dF9jYXQgfnByZXZfY2F0IGwgcmVtID1cbiAgbWF0Y2ggbCB3aXRoXG4gICAgW10gICAgIC0+IHJlbVxuICB8IHkgOjogciAtPlxuICAgIGRlbHRhXzEgbWFya3MgYyB+bmV4dF9jYXQgfnByZXZfY2F0IHlcbiAgICAgIChkZWx0YV8yIG1hcmtzIGMgfm5leHRfY2F0IH5wcmV2X2NhdCByIHJlbSlcblxuYW5kIGRlbHRhX3NlcSBjIH5uZXh0X2NhdCB+cHJldl9jYXQga2luZCB5IHogcmVtID1cbiAgbWF0Y2hcbiAgICBmaXJzdCAoZnVuY3Rpb24gRS5UTWF0Y2ggbWFya3MgLT4gU29tZSBtYXJrcyB8IF8gLT4gTm9uZSkgeVxuICB3aXRoXG4gICAgTm9uZSAtPlxuICAgIEUudHNlcSBraW5kIHkgeiByZW1cbiAgfCBTb21lIG1hcmtzIC0+XG4gICAgbWF0Y2gga2luZCB3aXRoXG4gICAgICBgTG9uZ2VzdCAtPlxuICAgICAgRS50c2VxIGtpbmQgKHJlbW92ZV9tYXRjaGVzIHkpIHpcbiAgICAgICAgKGRlbHRhXzEgbWFya3MgYyB+bmV4dF9jYXQgfnByZXZfY2F0IHogcmVtKVxuICAgIHwgYFNob3J0ZXN0IC0+XG4gICAgICBkZWx0YV8xIG1hcmtzIGMgfm5leHRfY2F0IH5wcmV2X2NhdCB6XG4gICAgICAgIChFLnRzZXEga2luZCAocmVtb3ZlX21hdGNoZXMgeSkgeiByZW0pXG4gICAgfCBgRmlyc3QgLT5cbiAgICAgIGxldCAoeScsIHknJykgPSBzcGxpdF9hdF9tYXRjaCB5IGluXG4gICAgICBFLnRzZXEga2luZCB5JyB6XG4gICAgICAgIChkZWx0YV8xIG1hcmtzIGMgfm5leHRfY2F0IH5wcmV2X2NhdCB6IChFLnRzZXEga2luZCB5JycgeiByZW0pKVxuXG5sZXQgcmVjIGRlbHRhXzMgYyB+bmV4dF9jYXQgfnByZXZfY2F0IHggcmVtID1cbiAgbWF0Y2ggeCB3aXRoXG4gICAgRS5UU2VxICh5LCB6LCBraW5kKSAtPlxuICAgIGxldCB5JyA9IGRlbHRhXzQgYyB+bmV4dF9jYXQgfnByZXZfY2F0IHkgW10gaW5cbiAgICBkZWx0YV9zZXEgYyB+bmV4dF9jYXQgfnByZXZfY2F0IGtpbmQgeScgeiByZW1cbiAgfCBFLlRFeHAgKG1hcmtzLCBlKSAtPlxuICAgIGRlbHRhXzEgbWFya3MgYyB+bmV4dF9jYXQgfnByZXZfY2F0IGUgcmVtXG4gIHwgRS5UTWF0Y2ggXyAtPlxuICAgIHggOjogcmVtXG5cbmFuZCBkZWx0YV80IGMgfm5leHRfY2F0IH5wcmV2X2NhdCBsIHJlbSA9XG4gIG1hdGNoIGwgd2l0aFxuICAgIFtdICAgICAtPiByZW1cbiAgfCB5IDo6IHIgLT5cbiAgICBkZWx0YV8zIGMgfm5leHRfY2F0IH5wcmV2X2NhdCB5XG4gICAgICAoZGVsdGFfNCBjIH5uZXh0X2NhdCB+cHJldl9jYXQgciByZW0pXG5cbmxldCBkZWx0YSB0YmxfcmVmIG5leHRfY2F0IGNoYXIgc3QgPVxuICBsZXQgcHJldl9jYXQgPSBzdC5TdGF0ZS5jYXRlZ29yeSBpblxuICBsZXQgKGV4cHInLCBfKSA9XG4gICAgcmVtb3ZlX2R1cGxpY2F0ZXMgW11cbiAgICAgIChkZWx0YV80IGNoYXIgfm5leHRfY2F0IH5wcmV2X2NhdCBzdC5TdGF0ZS5kZXNjIFtdKVxuICAgICAgZXBzX2V4cHIgaW5cbiAgbGV0IGlkeCA9IGZyZWVfaW5kZXggdGJsX3JlZiBleHByJyBpblxuICBsZXQgZXhwcicnID0gc2V0X2lkeCBpZHggZXhwcicgaW5cbiAgU3RhdGUubWsgaWR4IG5leHRfY2F0IGV4cHInJ1xuXG4oKioqKilcblxubGV0IHJlYyByZWRfdHIgPSBmdW5jdGlvblxuICB8IFtdIHwgW19dIGFzIGwgLT5cbiAgICBsXG4gIHwgKChzMSwgc3QxKSBhcyB0cjEpIDo6ICgoczIsIHN0MikgYXMgdHIyKSA6OiByZW0gLT5cbiAgICBpZiBTdGF0ZS5lcXVhbCBzdDEgc3QyIHRoZW5cbiAgICAgIHJlZF90ciAoKENzZXQudW5pb24gczEgczIsIHN0MSkgOjogcmVtKVxuICAgIGVsc2VcbiAgICAgIHRyMSA6OiByZWRfdHIgKHRyMiA6OiByZW0pXG5cbmxldCBzaW1wbF90ciBsID1cbiAgTGlzdC5zb3J0XG4gICAgKGZ1biAoczEsIF8pIChzMiwgXykgLT4gY29tcGFyZSBzMSBzMilcbiAgICAocmVkX3RyIChMaXN0LnNvcnQgKGZ1biAoXywgc3QxKSAoXywgc3QyKSAtPiBTdGF0ZS5jb21wYXJlIHN0MSBzdDIpIGwpKVxuXG4oKioqKilcblxubGV0IHByZXBlbmRfZGVyaXYgPSBMaXN0LmZvbGRfcmlnaHQgKGZ1biAocywgeCkgbCAtPiBDc2V0LnByZXBlbmQgcyB4IGwpXG5cbmxldCByZWMgcmVzdHJpY3QgcyA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCAocycsIHgnKSA6OiByZW0gLT5cbiAgICBsZXQgcycnID0gQ3NldC5pbnRlciBzIHMnIGluXG4gICAgaWYgQ3NldC5pc19lbXB0eSBzJydcbiAgICB0aGVuIHJlc3RyaWN0IHMgcmVtXG4gICAgZWxzZSAocycnLCB4JykgOjogcmVzdHJpY3QgcyByZW1cblxubGV0IHJlYyByZW1vdmVfbWFya3MgYiBlIHJlbSA9XG4gIGlmIGIgPiBlIHRoZW4gcmVtIGVsc2UgcmVtb3ZlX21hcmtzIGIgKGUgLSAxKSAoKGUsIC0yKSA6OiByZW0pXG5cbmxldCByZWMgcHJlcGVuZF9tYXJrc19leHByIG0gPSBmdW5jdGlvblxuICB8IEUuVFNlcSAobCwgZScsIHMpIC0+IEUuVFNlcSAocHJlcGVuZF9tYXJrc19leHByX2xzdCBtIGwsIGUnLCBzKVxuICB8IEUuVEV4cCAobScsIGUnKSAgIC0+IEUuVEV4cCAoTWFya3MubWVyZ2UgbSBtJywgZScpXG4gIHwgRS5UTWF0Y2ggbScgICAgICAgLT4gRS5UTWF0Y2ggKE1hcmtzLm1lcmdlIG0gbScpXG5cbmFuZCBwcmVwZW5kX21hcmtzX2V4cHJfbHN0IG0gbCA9XG4gIExpc3QubWFwIChwcmVwZW5kX21hcmtzX2V4cHIgbSkgbFxuXG5sZXQgcHJlcGVuZF9tYXJrcyBtID1cbiAgTGlzdC5tYXAgKGZ1biAocywgeCkgLT4gKHMsIHByZXBlbmRfbWFya3NfZXhwcl9sc3QgbSB4KSlcblxubGV0IHJlYyBkZXJpdl8xIGFsbF9jaGFycyBjYXRlZ29yaWVzIG1hcmtzIGNhdCB4IHJlbSA9XG4gIG1hdGNoIHguZGVmIHdpdGhcbiAgfCBDc3QgcyAtPlxuICAgIENzZXQucHJlcGVuZCBzIFtFLnRleHAgbWFya3MgZXBzX2V4cHJdIHJlbVxuICB8IEFsdCBsIC0+XG4gICAgZGVyaXZfMiBhbGxfY2hhcnMgY2F0ZWdvcmllcyBtYXJrcyBjYXQgbCByZW1cbiAgfCBTZXEgKGtpbmQsIHksIHopIC0+XG4gICAgbGV0IHknID0gZGVyaXZfMSBhbGxfY2hhcnMgY2F0ZWdvcmllcyBtYXJrcyBjYXQgeSBbKGFsbF9jaGFycywgW10pXSBpblxuICAgIGRlcml2X3NlcSBhbGxfY2hhcnMgY2F0ZWdvcmllcyBjYXQga2luZCB5JyB6IHJlbVxuICB8IFJlcCAocmVwX2tpbmQsIGtpbmQsIHkpIC0+XG4gICAgbGV0IHknID0gZGVyaXZfMSBhbGxfY2hhcnMgY2F0ZWdvcmllcyBtYXJrcyBjYXQgeSBbKGFsbF9jaGFycywgW10pXSBpblxuICAgIExpc3QuZm9sZF9yaWdodFxuICAgICAgKGZ1biAocywgeikgcmVtIC0+XG4gICAgICAgICBsZXQgKHonLCBtYXJrcycpID1cbiAgICAgICAgICAgbWF0Y2hcbiAgICAgICAgICAgICBmaXJzdFxuICAgICAgICAgICAgICAgKGZ1bmN0aW9uIEUuVE1hdGNoIG1hcmtzIC0+IFNvbWUgbWFya3MgfCBfIC0+IE5vbmUpXG4gICAgICAgICAgICAgICB6XG4gICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgICBOb25lICAgICAgICAtPiAoeiwgbWFya3MpXG4gICAgICAgICAgIHwgU29tZSBtYXJrcycgLT4gKHJlbW92ZV9tYXRjaGVzIHosIG1hcmtzJylcbiAgICAgICAgIGluXG4gICAgICAgICBDc2V0LnByZXBlbmQgc1xuICAgICAgICAgICAobWF0Y2ggcmVwX2tpbmQgd2l0aFxuICAgICAgICAgICAgICBgR3JlZWR5ICAgICAtPiBFLnRzZXEga2luZCB6JyB4IFtFLlRNYXRjaCBtYXJrcyddXG4gICAgICAgICAgICB8IGBOb25fZ3JlZWR5IC0+IEUuVE1hdGNoIG1hcmtzIDo6IEUudHNlcSBraW5kIHonIHggW10pXG4gICAgICAgICAgIHJlbSlcbiAgICAgIHknIHJlbVxuICB8IEVwcyAtPlxuICAgIENzZXQucHJlcGVuZCBhbGxfY2hhcnMgW0UuVE1hdGNoIG1hcmtzXSByZW1cbiAgfCBNYXJrIGkgLT5cbiAgICBDc2V0LnByZXBlbmQgYWxsX2NoYXJzIFtFLlRNYXRjaCB7bWFya3Mgd2l0aCBNYXJrcy5tYXJrcyA9ICgoaSwgLTEpIDo6IExpc3QucmVtb3ZlX2Fzc3EgaSBtYXJrcy5NYXJrcy5tYXJrcyl9XSByZW1cbiAgfCBQbWFyayBfIC0+XG4gICAgQ3NldC5wcmVwZW5kIGFsbF9jaGFycyBbRS5UTWF0Y2ggbWFya3NdIHJlbVxuICB8IEVyYXNlIChiLCBlKSAtPlxuICAgIENzZXQucHJlcGVuZCBhbGxfY2hhcnNcbiAgICAgIFtFLlRNYXRjaCB7bWFya3Mgd2l0aCBNYXJrcy5tYXJrcyA9IChyZW1vdmVfbWFya3MgYiBlIChmaWx0ZXJfbWFya3MgYiBlIG1hcmtzKS5NYXJrcy5tYXJrcyl9XSByZW1cbiAgfCBCZWZvcmUgY2F0JyAtPlxuICAgIENzZXQucHJlcGVuZCAoTGlzdC5hc3NxIGNhdCcgY2F0ZWdvcmllcykgW0UuVE1hdGNoIG1hcmtzXSByZW1cbiAgfCBBZnRlciBjYXQnIC0+XG4gICAgaWYgQ2F0ZWdvcnkuaW50ZXJzZWN0IGNhdCBjYXQnIHRoZW4gQ3NldC5wcmVwZW5kIGFsbF9jaGFycyBbRS5UTWF0Y2ggbWFya3NdIHJlbSBlbHNlIHJlbVxuXG5hbmQgZGVyaXZfMiBhbGxfY2hhcnMgY2F0ZWdvcmllcyBtYXJrcyBjYXQgbCByZW0gPVxuICBtYXRjaCBsIHdpdGhcbiAgICBbXSAgICAgLT4gcmVtXG4gIHwgeSA6OiByIC0+IGRlcml2XzEgYWxsX2NoYXJzIGNhdGVnb3JpZXMgbWFya3MgY2F0IHlcbiAgICAgICAgICAgICAgICAoZGVyaXZfMiBhbGxfY2hhcnMgY2F0ZWdvcmllcyBtYXJrcyBjYXQgciByZW0pXG5cbmFuZCBkZXJpdl9zZXEgYWxsX2NoYXJzIGNhdGVnb3JpZXMgY2F0IGtpbmQgeSB6IHJlbSA9XG4gIGlmXG4gICAgTGlzdC5leGlzdHNcbiAgICAgIChmdW4gKF9zLCB4bCkgLT5cbiAgICAgICAgIExpc3QuZXhpc3RzIChmdW5jdGlvbiBFLlRNYXRjaCBfIC0+IHRydWUgfCBfIC0+IGZhbHNlKSB4bClcbiAgICAgIHlcbiAgdGhlblxuICAgIGxldCB6JyA9IGRlcml2XzEgYWxsX2NoYXJzIGNhdGVnb3JpZXMgTWFya3MuZW1wdHkgY2F0IHogWyhhbGxfY2hhcnMsIFtdKV0gaW5cbiAgICBMaXN0LmZvbGRfcmlnaHRcbiAgICAgIChmdW4gKHMsIHkpIHJlbSAtPlxuICAgICAgICAgbWF0Y2hcbiAgICAgICAgICAgZmlyc3QgKGZ1bmN0aW9uIEUuVE1hdGNoIG1hcmtzIC0+IFNvbWUgbWFya3MgfCBfIC0+IE5vbmUpXG4gICAgICAgICAgICAgeVxuICAgICAgICAgd2l0aFxuICAgICAgICAgICBOb25lIC0+XG4gICAgICAgICAgIENzZXQucHJlcGVuZCBzIChFLnRzZXEga2luZCB5IHogW10pIHJlbVxuICAgICAgICAgfCBTb21lIG1hcmtzIC0+XG4gICAgICAgICAgIGxldCB6JycgPSBwcmVwZW5kX21hcmtzIG1hcmtzIHonIGluXG4gICAgICAgICAgIG1hdGNoIGtpbmQgd2l0aFxuICAgICAgICAgICAgIGBMb25nZXN0IC0+XG4gICAgICAgICAgICAgQ3NldC5wcmVwZW5kIHMgKEUudHNlcSBraW5kIChyZW1vdmVfbWF0Y2hlcyB5KSB6IFtdKSAoXG4gICAgICAgICAgICAgICBwcmVwZW5kX2Rlcml2IChyZXN0cmljdCBzIHonJykgcmVtKVxuICAgICAgICAgICB8IGBTaG9ydGVzdCAtPlxuICAgICAgICAgICAgIHByZXBlbmRfZGVyaXYgKHJlc3RyaWN0IHMgeicnKSAoXG4gICAgICAgICAgICAgICBDc2V0LnByZXBlbmQgcyAoRS50c2VxIGtpbmQgKHJlbW92ZV9tYXRjaGVzIHkpIHogW10pIHJlbSlcbiAgICAgICAgICAgfCBgRmlyc3QgLT5cbiAgICAgICAgICAgICBsZXQgKHknLCB5JycpID0gc3BsaXRfYXRfbWF0Y2ggeSBpblxuICAgICAgICAgICAgIENzZXQucHJlcGVuZCBzIChFLnRzZXEga2luZCB5JyB6IFtdKSAoXG4gICAgICAgICAgICAgICBwcmVwZW5kX2Rlcml2IChyZXN0cmljdCBzIHonJykgKFxuICAgICAgICAgICAgICAgICBDc2V0LnByZXBlbmQgcyAoRS50c2VxIGtpbmQgeScnIHogW10pIHJlbSkpKVxuICAgICAgeSByZW1cbiAgZWxzZVxuICAgIExpc3QuZm9sZF9yaWdodFxuICAgICAgKGZ1biAocywgeGwpIHJlbSAtPiBDc2V0LnByZXBlbmQgcyAoRS50c2VxIGtpbmQgeGwgeiBbXSkgcmVtKSB5IHJlbVxuXG5sZXQgcmVjIGRlcml2XzMgYWxsX2NoYXJzIGNhdGVnb3JpZXMgY2F0IHggcmVtID1cbiAgbWF0Y2ggeCB3aXRoXG4gICAgRS5UU2VxICh5LCB6LCBraW5kKSAtPlxuICAgIGxldCB5JyA9IGRlcml2XzQgYWxsX2NoYXJzIGNhdGVnb3JpZXMgY2F0IHkgWyhhbGxfY2hhcnMsIFtdKV0gaW5cbiAgICBkZXJpdl9zZXEgYWxsX2NoYXJzIGNhdGVnb3JpZXMgY2F0IGtpbmQgeScgeiByZW1cbiAgfCBFLlRFeHAgKG1hcmtzLCBlKSAtPlxuICAgIGRlcml2XzEgYWxsX2NoYXJzIGNhdGVnb3JpZXMgbWFya3MgY2F0IGUgcmVtXG4gIHwgRS5UTWF0Y2ggXyAtPlxuICAgIENzZXQucHJlcGVuZCBhbGxfY2hhcnMgW3hdIHJlbVxuXG5hbmQgZGVyaXZfNCBhbGxfY2hhcnMgY2F0ZWdvcmllcyBjYXQgbCByZW0gPVxuICBtYXRjaCBsIHdpdGhcbiAgICBbXSAgICAgLT4gcmVtXG4gIHwgeSA6OiByIC0+IGRlcml2XzMgYWxsX2NoYXJzIGNhdGVnb3JpZXMgY2F0IHlcbiAgICAgICAgICAgICAgICAoZGVyaXZfNCBhbGxfY2hhcnMgY2F0ZWdvcmllcyBjYXQgciByZW0pXG5cbmxldCBkZXJpdiB0YmxfcmVmIGFsbF9jaGFycyBjYXRlZ29yaWVzIHN0ID1cbiAgbGV0IGRlciA9IGRlcml2XzQgYWxsX2NoYXJzIGNhdGVnb3JpZXMgc3QuU3RhdGUuY2F0ZWdvcnkgc3QuU3RhdGUuZGVzY1xuICAgICAgWyhhbGxfY2hhcnMsIFtdKV0gaW5cbiAgc2ltcGxfdHIgKFxuICAgIExpc3QuZm9sZF9yaWdodCAoZnVuIChzLCBleHByKSByZW0gLT5cbiAgICAgICAgbGV0IChleHByJywgXykgPSByZW1vdmVfZHVwbGljYXRlcyBbXSBleHByIGVwc19leHByIGluXG4oKlxuRm9ybWF0LmVwcmludGYgXCJAWzwzPkBbJWFAXTogJWEgLyAlYUBdQC5cIiBDc2V0LnByaW50IHMgcHJpbnRfc3RhdGUgZXhwciBwcmludF9zdGF0ZSBleHByJztcbiopXG4gICAgICAgIGxldCBpZHggPSBmcmVlX2luZGV4IHRibF9yZWYgZXhwcicgaW5cbiAgICAgICAgbGV0IGV4cHInJyA9IHNldF9pZHggaWR4IGV4cHInIGluXG4gICAgICAgIExpc3QuZm9sZF9yaWdodCAoZnVuIChjYXQnLCBzJykgcmVtIC0+XG4gICAgICAgICAgICBsZXQgcycnID0gQ3NldC5pbnRlciBzIHMnIGluXG4gICAgICAgICAgICBpZiBDc2V0LmlzX2VtcHR5IHMnJ1xuICAgICAgICAgICAgdGhlbiByZW1cbiAgICAgICAgICAgIGVsc2UgKHMnJywgU3RhdGUubWsgaWR4IGNhdCcgZXhwcicnKSA6OiByZW0pXG4gICAgICAgICAgY2F0ZWdvcmllcyByZW0pIGRlciBbXSlcblxuKCoqKiopXG5cbmxldCBmbGF0dGVuX21hdGNoIG0gPVxuICBsZXQgbWEgPSBMaXN0LmZvbGRfbGVmdCAoZnVuIG1hIChpLCBfKSAtPiBtYXggbWEgaSkgKC0xKSBtIGluXG4gIGxldCByZXMgPSBBcnJheS5tYWtlIChtYSArIDEpICgtMSkgaW5cbiAgTGlzdC5pdGVyIChmdW4gKGksIHYpIC0+IHJlcy4oaSkgPC0gdikgbTtcbiAgcmVzXG5cbmxldCBzdGF0dXMgcyA9XG4gIG1hdGNoIHMuU3RhdGUuc3RhdHVzIHdpdGhcbiAgICBTb21lIHN0IC0+XG4gICAgc3RcbiAgfCBOb25lIC0+XG4gICAgbGV0IHN0ID1cbiAgICAgIG1hdGNoIHMuU3RhdGUuZGVzYyB3aXRoXG4gICAgICAgIFtdICAgICAgICAgICAgICAtPiBGYWlsZWRcbiAgICAgIHwgRS5UTWF0Y2ggbSA6OiBfIC0+IE1hdGNoIChmbGF0dGVuX21hdGNoIG0uTWFya3MubWFya3MsIG0uTWFya3MucG1hcmtzKVxuICAgICAgfCBfICAgICAgICAgICAgICAgLT4gUnVubmluZ1xuICAgIGluXG4gICAgcy5TdGF0ZS5zdGF0dXMgPC0gU29tZSBzdDtcbiAgICBzdFxuIiwiKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbm9wZW4gTGV4aW5nXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG50eXBlIHQgPSB7XG4gIGxvY19mbmFtZSA6IHN0cmluZztcbiAgbG9jX3N0YXJ0IDogaW50ICogaW50O1xuICBsb2NfZW5kICAgOiBpbnQgKiBpbnQ7XG4gIGxvY19iY2hhciA6IGludDtcbiAgbG9jX2VjaGFyIDogaW50O1xufVxuXG5sZXQgX2R1bW15IDogdCA9IHtcbiAgbG9jX2ZuYW1lID0gXCJcIjtcbiAgbG9jX3N0YXJ0ID0gKC0xLCAtMSk7XG4gIGxvY19lbmQgICA9ICgtMSwgLTEpO1xuICBsb2NfYmNoYXIgPSAtMTtcbiAgbG9jX2VjaGFyID0gLTE7XG59XG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5sZXQgbWFrZSAocDEgOiBwb3NpdGlvbikgKHAyIDogcG9zaXRpb24pID1cbiAgbGV0IG1rcG9zIChwIDogcG9zaXRpb24pID1cbiAgICAocC5wb3NfbG51bSwgcC5wb3NfY251bSAtIHAucG9zX2JvbClcbiAgaW5cbiAgICB7IGxvY19mbmFtZSA9IHAxLnBvc19mbmFtZTtcbiAgICAgIGxvY19zdGFydCA9IG1rcG9zIHAxICAgIDtcbiAgICAgIGxvY19lbmQgICA9IG1rcG9zIHAyICAgIDtcbiAgICAgIGxvY19iY2hhciA9IHAxLnBvc19jbnVtIDtcbiAgICAgIGxvY19lY2hhciA9IHAyLnBvc19jbnVtIDsgfVxuXG5sZXQgb2ZfbGV4YnVmIChsYiA6IGxleGJ1ZikgPVxuICBsZXQgcDEgPSBMZXhpbmcubGV4ZW1lX3N0YXJ0X3AgbGIgaW5cbiAgbGV0IHAyID0gTGV4aW5nLmxleGVtZV9lbmRfcCBsYiBpblxuICBtYWtlIHAxIHAyXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxubGV0IG1lcmdlIChwMSA6IHQpIChwMiA6IHQpID1cbiAgeyBsb2NfZm5hbWUgPSBwMS5sb2NfZm5hbWU7XG4gICAgbG9jX3N0YXJ0ID0gbWluIHAxLmxvY19zdGFydCBwMi5sb2Nfc3RhcnQ7XG4gICAgbG9jX2VuZCAgID0gbWF4IHAxLmxvY19lbmQgICBwMi5sb2NfZW5kICA7XG4gICAgbG9jX2JjaGFyID0gbWluIHAxLmxvY19iY2hhciBwMi5sb2NfYmNoYXI7XG4gICAgbG9jX2VjaGFyID0gbWF4IHAxLmxvY19lY2hhciBwMi5sb2NfZWNoYXI7IH1cblxubGV0IG1lcmdlYWxsIChwIDogdCBsaXN0KSA9XG4gIG1hdGNoIHAgd2l0aFxuICB8IFtdICAgICAgLT4gX2R1bW15XG4gIHwgdCA6OiB0cyAtPiBMaXN0LmZvbGRfbGVmdCBtZXJnZSB0IHRzXG5cbmxldCBpc2R1bW15IChwIDogdCkgPVxuICBwLmxvY19iY2hhciA8IDAgfHwgcC5sb2NfZWNoYXIgPCAwXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxubGV0IHRvc3RyaW5nIChwIDogdCkgPVxuICBsZXQgc3BvcyA9XG4gICAgaWYgcC5sb2Nfc3RhcnQgPSBwLmxvY19lbmQgdGhlblxuICAgICAgUHJpbnRmLnNwcmludGYgXCJsaW5lICVkICglZClcIlxuICAgICAgICAoZnN0IHAubG9jX3N0YXJ0KSAoc25kIHAubG9jX3N0YXJ0KVxuICAgIGVsc2UgaWYgZnN0IHAubG9jX3N0YXJ0ID0gZnN0IHAubG9jX2VuZCB0aGVuXG4gICAgICBQcmludGYuc3ByaW50ZiBcImxpbmUgJWQgKCVkLSVkKVwiXG4gICAgICAgIChmc3QgcC5sb2Nfc3RhcnQpIChzbmQgcC5sb2Nfc3RhcnQpIChzbmQgcC5sb2NfZW5kKVxuICAgIGVsc2VcbiAgICAgIFByaW50Zi5zcHJpbnRmIFwibGluZSAlZCAoJWQpIHRvIGxpbmUgJWQgKCVkKVwiXG4gICAgICAgIChmc3QgcC5sb2Nfc3RhcnQpIChzbmQgcC5sb2Nfc3RhcnQpXG4gICAgICAgIChmc3QgcC5sb2NfZW5kICApIChzbmQgcC5sb2NfZW5kICApXG4gIGluXG4gICAgUHJpbnRmLnNwcmludGYgXCIlczogJXNcIiBwLmxvY19mbmFtZSBzcG9zXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG50eXBlICdhIGxvY2VkID0geyBwbGxvYyA6IHQ7IHBsZGVzYyA6ICdhOyB9XG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5sZXQgbG9jICAgIHggPSB4LnBsbG9jXG5sZXQgdW5sb2MgIHggPSB4LnBsZGVzY1xubGV0IHVubG9jcyB4ID0gTGlzdC5tYXAgdW5sb2MgeFxuXG5sZXQgbG1hcCAoZiA6ICdhIC0+ICdiKSAoeCA6ICdhIGxvY2VkKSA9XG4gIHsgeCB3aXRoIHBsZGVzYyA9IGYgeC5wbGRlc2MgfVxuXG5sZXQgbWtsb2MgKGxvYyA6IHQpICh4IDogJ2EpIDogJ2EgbG9jZWQgPVxuICB7IHBsbG9jID0gbG9jOyBwbGRlc2MgPSB4OyB9XG4iLCIoKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxub3BlbiBVdGlsc1xub3BlbiBMb2NhdGlvblxub3BlbiBTeW50YXhcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbigqKiBOYW1lcyAqKVxuXG50eXBlIG5hbWUgID0gc3RyaW5nXG50eXBlIHZuYW1lID0gbmFtZSAqIGludFxuXG5sZXQgbmFtZV9vZl92bmFtZSA6IHZuYW1lIC0+IG5hbWUgPSBmc3RcblxubW9kdWxlIE5hbWUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gbmFtZVxuXG4gIGxldCBlcXVhbCAgID0gU3RyaW5nLmVxdWFsXG4gIGxldCBjb21wYXJlID0gU3RyaW5nLmNvbXBhcmVcbiAgbGV0IGhhc2ggICAgPSBIYXNodGJsLmhhc2hcbmVuZFxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuKCoqIFR5cGVzICopXG5cbnR5cGUgdHlwZV8gPVxuICB8IFRWYXIgIG9mIHZuYW1lXG4gIHwgVFVuaXRcbiAgfCBUUHJvZCBvZiB0eXBlXyAqIHR5cGVfXG4gIHwgVE9yICAgb2YgdHlwZV8gKiB0eXBlX1xuICB8IFRSZWMgIG9mIG5hbWUgKiB0eXBlX1xuXG50eXBlIGFyaXR5ID0gdHlwZV8gbGlzdFxuIGFuZCBzaWdfICA9IGFyaXR5ICogdHlwZV9cblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbigqKiBFeHByZXNzaW9ucyAqKVxuXG50eXBlIGV4cHIgID1cbiAgfCBFVmFyIG9mIHZuYW1lXG4gIHwgRUZ1biBvZiBuYW1lICogZXhwciBsaXN0XG5cbiAgbGV0IHJlYyBlX3ZhcnMgPVxuICAgIGxldCBvcGVuIE1vbmFkLkxpc3QgaW4gZnVuY3Rpb25cbiAgICB8IEVWYXIgeCAtPiByZXR1cm4geFxuICAgIHwgRUZ1biAoXywgdHMpIC0+IHRzID4+PSBlX3ZhcnNcbiAgXG5sZXQgcmVjIGVfdmFycyA9XG4gIGxldCBvcGVuIE1vbmFkLkxpc3QgaW4gZnVuY3Rpb25cbiAgfCBFVmFyIHggLT4gcmV0dXJuIHhcbiAgfCBFRnVuIChfLCB0cykgLT4gdHMgPj49IGVfdmFyc1xuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuKCoqIEZvcm11bGFzICopXG5cbnR5cGUgbG9nY29uID0gWyBgQW5kIHwgYE9yIHwgYEltcCB8IGBFcXVpdiB8IGBOb3QgXVxudHlwZSBia2luZCAgPSBbIGBGb3JhbGwgfCBgRXhpc3QgXVxuXG50eXBlIGZvcm0gPVxuICB8IEZUcnVlXG4gIHwgRkZhbHNlXG4gIHwgRlByZWQgb2YgbmFtZSAqIGV4cHIgbGlzdFxuICB8IEZDb25uIG9mIGxvZ2NvbiAqIGZvcm0gbGlzdFxuICB8IEZCaW5kIG9mIGJraW5kICogbmFtZSAqIHR5cGVfICogZm9ybVxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuKCoqIFRlcm1zID0gRm9ybXVsYXMgKyBFeHByZXNzaW9ucyAqKVxuXG50eXBlIHRlcm0gICA9IFtgRiBvZiBmb3JtIHwgYEUgb2YgZXhwcl1cblxubGV0IHRlcm1fb2ZfZXhwciBlIDogdGVybSA9IGBFIGVcbmxldCB0ZXJtX29mX2Zvcm0gZiA6IHRlcm0gPSBgRiBmXG5cbmxldCBleHByX29mX3Rlcm0gKHQgOiB0ZXJtKSA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IGBFIGUgLT4gZVxuICB8IF8gLT4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJFeHBlY3RlZCBhbiBleHByZXNzaW9uXCIpXG5cbmxldCBmb3JtX29mX3Rlcm0gKHQgOiB0ZXJtKSA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IGBGIGYgLT4gZlxuICB8IF8gLT4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJFeHBlY3RlZCBhIGZvcm11bGFcIilcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbigqKiBDb250ZXh0cyAqKVxuXG4oKiBJbW1lZGlhdGUgRm9ybXVsYSBDb25UZVh0ICopXG50eXBlIGlmY3R4ID1cbiAgfCBDQ29ubiBvZiBsb2djb24gKiBmb3JtIGxpc3QgKiBpbnRcbiAgfCBDQmluZCBvZiBia2luZCAqIG5hbWUgKiB0eXBlX1xuICBcbigqIEltbWVkaWF0ZSBFeHByZXNzaW9uIENvblRleFQgKilcbnR5cGUgaWVjdHggPVxuICB8IENGdW4gb2YgbmFtZSAqIGV4cHIgbGlzdCAqIGludFxuXG4oKiBJbW1lZGlhdGUgdGVybSBDb25UZXhUICopXG50eXBlIGljdHggPSBbXG4gIHwgYEYgb2YgaWZjdHhcbiAgfCBgUCBvZiBuYW1lICogZXhwciBsaXN0ICogaW50XG4gIHwgYEUgb2YgaWVjdHhcbiAgfCBgTm9uZVxuXVxuXG4oKiBVbmlmb3JtIGNvbnRleHRzIGFyZSBqdXN0IGxpc3RzICopXG50eXBlIGZjdHggPSBpZmN0eCBsaXN0XG50eXBlIGVjdHggPSBpZWN0eCBsaXN0XG5cbigqIEEgc3VidGVybSBpcyBlaXRoZXIgYSBzdWJmb3JtdWxhLCBhIHN1YmV4cHJlc3Npb24gaW4gaXNvbGF0aW9uLFxuICAgb3IgYSBzdWJleHByZXNzaW9uIG9jY3VycmluZyBpbiBhIHByZWRpY2F0ZSBhcmd1bWVudCAqKVxudHlwZSBjdHggPVxuICB8IENGb3JtIG9mIGZjdHhcbiAgfCBDRXhwciBvZiBlY3R4XG4gIHwgQ0V4cHJQcmVkIG9mIGZjdHggKiBuYW1lICogZXhwciBsaXN0ICogaW50ICogZWN0eFxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuKCoqIFVuaWZpY2F0aW9uICopXG5cbnR5cGUgc2l0ZW0gPSBcbiAgfCBTYm91bmQgb2YgZXhwclxuICB8IFNmbGV4XG5cbnR5cGUgJ2EgZXFucyA9ICgnYSAqICdhKSBsaXN0XG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG4oKiogRW52aXJvbm1lbnRzICopXG5cbnR5cGUgZW52ID0ge1xuICBlbnZfcHJwICAgICA6IChuYW1lLCBhcml0eSAgICAgICAgICAgICkgTWFwLnQ7XG4gIGVudl9mdW4gICAgIDogKG5hbWUsIHNpZ18gICAgICAgICAgICAgKSBNYXAudDtcbiAgZW52X3ZhciAgICAgOiAobmFtZSwgYnZhciAgbGlzdCAgICAgICApIE1hcC50O1xuICBlbnZfdHZhciAgICA6IChuYW1lLCB0eXBlXyBvcHRpb24gbGlzdCkgTWFwLnQ7XG4gIGVudl9ldmFyICAgIDogKG5hbWUsIHR5cGVfIGxpc3QgICAgICAgKSBNYXAudDtcbiAgZW52X2hhbmRsZXMgOiAodm5hbWUsIHVpZCAgICAgICAgICAgICApIEJpTWFwLnQ7XG59XG5cbmFuZCBidmFyID0gdHlwZV8gKiBleHByIG9wdGlvblxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxubW9kdWxlIEVudiA6IHNpZ1xuICB2YWwgbmF0ICA6IHR5cGVfXG4gIHZhbCB6ZXJvIDogZXhwclxuICB2YWwgc3VjYyA6IGV4cHIgLT4gZXhwclxuICB2YWwgYWRkICA6IGV4cHIgLT4gZXhwciAtPiBleHByXG4gIHZhbCBtdWx0IDogZXhwciAtPiBleHByIC0+IGV4cHJcblxuICB2YWwgZW1wdHkgOiBlbnZcbmVuZCA9IHN0cnVjdFxuICBsZXQgbmF0ID0gVFZhciAoXCJuYXRcIiwgMClcbiAgbGV0IHplcm8gPSBFRnVuIChcIlpcIiwgW10pXG4gIGxldCBzdWNjIG4gPSBFRnVuIChcIlNcIiwgW25dKVxuICBsZXQgYWRkIG4gbSA9IEVGdW4gKFwiYWRkXCIsIFtuOyBtXSlcbiAgbGV0IG11bHQgbiBtID0gRUZ1biAoXCJtdWx0XCIsIFtuOyBtXSlcbiAgICBcbiAgbGV0IGVtcHR5IDogZW52ID0gTWFwLntcbiAgICBlbnZfcHJwICAgICA9IGVtcHR5O1xuICAgIGVudl9mdW4gICAgID0gZW1wdHkgfD5cbiAgICAgICAgICAgICAgICAgIGFkZCBcIlpcIiAoW10sIG5hdCkgfD5cbiAgICAgICAgICAgICAgICAgIGFkZCBcIlNcIiAoW25hdF0sIG5hdCkgfD5cbiAgICAgICAgICAgICAgICAgIGFkZCBcImFkZFwiIChbbmF0OyBuYXRdLCBuYXQpIHw+XG4gICAgICAgICAgICAgICAgICBhZGQgXCJtdWx0XCIgKFtuYXQ7IG5hdF0sIG5hdCk7XG4gICAgZW52X3ZhciAgICAgPSBlbXB0eTtcbiAgICBlbnZfdHZhciAgICA9IGVtcHR5IHw+XG4gICAgICAgICAgICAgICAgICBhZGQgXCJuYXRcIiBbTm9uZV07XG4gICAgZW52X2V2YXIgICAgPSBlbXB0eTtcbiAgICBlbnZfaGFuZGxlcyA9IEJpTWFwLmVtcHR5O1xuICB9XG5lbmRcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbmV4Y2VwdGlvbiBEdXBsaWNhdGVkRW50cnkgb2YgW2BQcnAgfCBgRnVuXSAqIG5hbWVcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbm1vZHVsZSBMRW52IDogc2lnXG4gIHR5cGUgbGVudiBcblxuICBleGNlcHRpb24gRW1wdHlMRW52XG5cbiAgdmFsIGVtcHR5IDogbGVudlxuICB2YWwgaW5kaWNlcyA6IGxlbnYgLT4gKG5hbWUsIGludCkgTWFwLnRcbiAgdmFsIGdldF9pbmRleCA6IGxlbnYgLT4gbmFtZSAtPiBpbnRcbiAgdmFsIGV4aXN0cyA6IGxlbnYgLT4gdm5hbWUgLT4gYm9vbFxuICB2YWwgZW50ZXIgOiBsZW52IC0+IG5hbWUgLT4gbGVudlxuICB2YWwgZXhpdCAgOiBsZW52IC0+IGxlbnZcbiAgdmFsIGZvbGQgIDogbGVudiAtPiBuYW1lIC0+ICdhIC0+IChsZW52IC0+ICdhIC0+ICdiKSAtPiAnYlxuZW5kID0gc3RydWN0XG4gIHR5cGUgbGVudiA9IHtcbiAgICBsZV9pbmRpY2VzICA6IChuYW1lLCBpbnQpIE1hcC50O1xuICAgIGxlX2JpbmRpbmdzIDogbmFtZSBsaXN0O1xuICB9XG5cbiAgZXhjZXB0aW9uIEVtcHR5TEVudlxuXG4gIGxldCBlbXB0eSA9XG4gICAgeyBsZV9pbmRpY2VzID0gTWFwLmVtcHR5OyBsZV9iaW5kaW5ncyA9IFtdOyB9XG5cbiAgbGV0IGluZGljZXMgbGVudiA9IGxlbnYubGVfaW5kaWNlc1xuXG4gIGxldCBnZXRfaW5kZXggKGxlbnYgOiBsZW52KSAobmFtZSA6IG5hbWUpID1cbiAgICBNYXAuZmluZCBuYW1lIGxlbnYubGVfaW5kaWNlc1xuICBcbiAgbGV0IGV4aXN0cyAobGVudiA6IGxlbnYpICh4IDogdm5hbWUpID1cbiAgICBMaXN0Lm1lbSB4IChNYXAuYmluZGluZ3MgbGVudi5sZV9pbmRpY2VzKVxuXG4gIGxldCBlbnRlciAobGVudiA6IGxlbnYpIChuYW1lIDogbmFtZSkgPVxuICAgIHsgbGVfaW5kaWNlcyAgPSBNYXAubW9kaWZ5X2RlZiAoLTEpIG5hbWUgKCgrKSAxKSBsZW52LmxlX2luZGljZXM7XG4gICAgICBsZV9iaW5kaW5ncyA9IG5hbWUgOjogbGVudi5sZV9iaW5kaW5nczsgfVxuXG4gIGxldCBleGl0IChsZW52IDogbGVudikgPVxuICAgIG1hdGNoIGxlbnYubGVfYmluZGluZ3Mgd2l0aFxuICAgIHwgW10gLT5cbiAgICAgICAgcmFpc2UgRW1wdHlMRW52XG5cbiAgICB8IG5hbWUgOjogbmFtZXMgLT5cbiAgICAgICAgbGV0IHVwZGF0ZSBpID1cbiAgICAgICAgICBsZXQgaSA9IE9wdGlvbi5nZXQgaSAtIDEgaW5cbiAgICAgICAgICBpZiBpID0gMCB0aGVuIE5vbmUgZWxzZSBTb21lIGkgaW5cblxuICAgICAgICB7IGxlX2JpbmRpbmdzID0gbmFtZXM7XG4gICAgICAgICAgbGVfaW5kaWNlcyAgPSBNYXAubW9kaWZ5X29wdCBuYW1lIHVwZGF0ZSBsZW52LmxlX2luZGljZXM7IH1cblxuICAgbGV0IGZvbGQgKGxlbnYgOiBsZW52KSAobmFtZSA6IG5hbWUpICh4IDogJ2EpIChmIDogbGVudiAtPiAnYSAtPiAnYikgPVxuICAgICBmIChlbnRlciBsZW52IG5hbWUpIHhcbmVuZFxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxubW9kdWxlIFBycHMgOiBzaWdcbiAgdmFsIHB1c2ggICA6IGVudiAtPiBuYW1lICogYXJpdHkgLT4gZW52XG4gIHZhbCBleGlzdHMgOiBlbnYgLT4gbmFtZSAtPiBib29sXG4gIHZhbCBnZXQgICAgOiBlbnYgLT4gbmFtZSAtPiBhcml0eSBvcHRpb25cbiAgdmFsIGFsbCAgICA6IGVudiAtPiAobmFtZSwgYXJpdHkpIE1hcC50XG5lbmQgPSBzdHJ1Y3RcbiAgbGV0IHB1c2ggKGVudiA6IGVudikgKChuYW1lLCBzZykgOiBuYW1lICogYXJpdHkpID1cbiAgICBpZiBNYXAubWVtIG5hbWUgZW52LmVudl9wcnAgdGhlblxuICAgICAgcmFpc2UgKER1cGxpY2F0ZWRFbnRyeSAoYFBycCwgbmFtZSkpO1xuICAgIHsgZW52IHdpdGggZW52X3BycCA9IE1hcC5hZGQgbmFtZSBzZyBlbnYuZW52X3BycCB9XG5cbiAgbGV0IGdldCAoZW52IDogZW52KSAobmFtZSA6IG5hbWUpID1cbiAgICBNYXAuRXhjZXB0aW9ubGVzcy5maW5kIG5hbWUgZW52LmVudl9wcnBcblxuICBsZXQgZXhpc3RzIChlbnYgOiBlbnYpIChuYW1lIDogbmFtZSkgPVxuICAgIE9wdGlvbi5pc19zb21lIChnZXQgZW52IG5hbWUpXG5cbiAgbGV0IGFsbCAoZW52IDogZW52KSA9XG4gICAgZW52LmVudl9wcnBcbmVuZFxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxubW9kdWxlIEZ1bnMgOiBzaWdcbiAgdmFsIHB1c2ggICA6IGVudiAtPiBuYW1lICogc2lnXyAtPiBlbnZcbiAgdmFsIGV4aXN0cyA6IGVudiAtPiBuYW1lIC0+IGJvb2xcbiAgdmFsIGdldCAgICA6IGVudiAtPiBuYW1lIC0+IHNpZ18gb3B0aW9uXG4gIHZhbCBhbGwgICAgOiBlbnYgLT4gKG5hbWUsIHNpZ18pIE1hcC50XG5lbmQgPSBzdHJ1Y3RcbiAgbGV0IHB1c2ggKGVudiA6IGVudikgKChuYW1lLCBzZykgOiBuYW1lICogc2lnXykgPVxuICAgIGlmIE1hcC5tZW0gbmFtZSBlbnYuZW52X3BycCB0aGVuXG4gICAgICByYWlzZSAoRHVwbGljYXRlZEVudHJ5IChgRnVuLCBuYW1lKSk7XG4gICAgeyBlbnYgd2l0aCBlbnZfZnVuID0gTWFwLmFkZCBuYW1lIHNnIGVudi5lbnZfZnVuIH1cblxuICBsZXQgZ2V0IChlbnYgOiBlbnYpIChuYW1lIDogbmFtZSkgPVxuICAgIE1hcC5FeGNlcHRpb25sZXNzLmZpbmQgbmFtZSBlbnYuZW52X2Z1blxuXG4gIGxldCBleGlzdHMgKGVudiA6IGVudikgKG5hbWUgOiBuYW1lKSA9XG4gICAgT3B0aW9uLmlzX3NvbWUgKGdldCBlbnYgbmFtZSlcblxuICBsZXQgYWxsIChlbnYgOiBlbnYpID1cbiAgICBlbnYuZW52X2Z1blxuZW5kXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5tb2R1bGUgVFZhcnMgOiBzaWdcbiAgdmFsIHB1c2ggICA6IGVudiAtPiBuYW1lICogdHlwZV8gb3B0aW9uIC0+IGVudlxuICB2YWwgZ2V0ICAgIDogZW52IC0+IHZuYW1lIC0+IHR5cGVfIG9wdGlvbiBvcHRpb25cbiAgdmFsIGV4aXN0cyA6IGVudiAtPiB2bmFtZSAtPiBib29sXG4gIHZhbCBhbGwgICAgOiBlbnYgLT4gKG5hbWUsIHR5cGVfIG9wdGlvbiBsaXN0KSBNYXAudFxuZW5kID0gc3RydWN0XG4gIGxldCBwdXNoIChlbnYgOiBlbnYpICgobmFtZSwgYm9keSkgOiBuYW1lICogdHlwZV8gb3B0aW9uKSA9XG4gICAgeyBlbnYgd2l0aCBlbnZfdHZhciA9XG4gICAgICAgIE1hcC5tb2RpZnlfb3B0IG5hbWUgKGZ1biBiZHMgLT5cbiAgICAgICAgICBsZXQgdiA9IGJvZHkgOjogT3B0aW9uLmRlZmF1bHQgW10gYmRzIGluXG4gICAgICAgICAgU29tZSB2KSBlbnYuZW52X3R2YXIgfVxuXG4gIGxldCBnZXQgKGVudiA6IGVudikgKChuYW1lLCBpZHgpIDogdm5hbWUpID1cbiAgICBsZXQgYmRzID0gTWFwLmZpbmRfZGVmYXVsdCBbXSBuYW1lIGVudi5lbnZfdHZhciBpblxuICAgIExpc3QubnRoX29wdCBiZHMgaWR4XG4gIFxuICBsZXQgZXhpc3RzIChlbnYgOiBlbnYpICh4IDogdm5hbWUpID1cbiAgICBnZXQgZW52IHggfD4gT3B0aW9uLmlzX3NvbWVcblxuICBsZXQgYWxsIChlbnYgOiBlbnYpID1cbiAgICBlbnYuZW52X3R2YXJcbmVuZFxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuKCoqIE5vdGF0aW9ucyAqKVxuXG5tb2R1bGUgTm90YXRpb24gOiBzaWdcbiAgb3BlbiBUeXhtbFxuICBcbiAgdmFsIHRfdG9hc2NpaSAgOiB0eXBlXyAtPiBzdHJpbmdcbiAgdmFsIHRfdG9zdHJpbmcgOiB0eXBlXyAtPiBzdHJpbmdcbiAgdmFsIHRfdG9odG1sICAgOiB0eXBlXyAtPiBYbWwuZWx0XG4gIHZhbCB0X3RvbWF0aG1sIDogdHlwZV8gLT4gWG1sLmVsdFxuXG4gIHZhbCBlX3RvYXNjaWkgIDogZXhwciAtPiBzdHJpbmdcbiAgdmFsIGVfdG9zdHJpbmcgOiBleHByIC0+IHN0cmluZ1xuICB2YWwgZV90b2h0bWwgICA6ID9pZDpzdHJpbmcgb3B0aW9uIC0+IGV4cHIgLT4gWG1sLmVsdFxuICB2YWwgZV90b21hdGhtbCA6ID9pZDpzdHJpbmcgb3B0aW9uIC0+IGV4cHIgLT4gWG1sLmVsdFxuXG4gIHZhbCBmX3RvYXNjaWkgIDogZm9ybSAtPiBzdHJpbmdcbiAgdmFsIGZfdG9zdHJpbmcgOiBmb3JtIC0+IHN0cmluZ1xuICB2YWwgZl90b2h0bWwgICA6ID9pZDpzdHJpbmcgb3B0aW9uIC0+IGZvcm0gLT4gWG1sLmVsdFxuICB2YWwgZl90b21hdGhtbCA6ID9pZDpzdHJpbmcgb3B0aW9uIC0+IGZvcm0gLT4gWG1sLmVsdFxuICBcbiAgdmFsIHRvYXNjaWkgIDogdGVybSAtPiBzdHJpbmdcbiAgdmFsIHRvc3RyaW5nIDogdGVybSAtPiBzdHJpbmdcbiAgdmFsIHRvaHRtbCAgIDogP2lkOnN0cmluZyBvcHRpb24gLT4gdGVybSAtPiBYbWwuZWx0XG4gIHZhbCB0b21hdGhtbCA6ID9pZDpzdHJpbmcgb3B0aW9uIC0+IHRlcm0gLT4gWG1sLmVsdFxuZW5kID0gc3RydWN0XG4gIG9wZW4gVHl4bWxcbiAgXG4gIGxldCByZWMgcHJpb19vZl9mb3JtID0gZnVuY3Rpb25cbiAgICB8IEZUcnVlICAgICAgICAgLT4gbWF4X2ludFxuICAgIHwgRkZhbHNlICAgICAgICAtPiBtYXhfaW50XG4gICAgfCBGUHJlZCAgXyAgICAgIC0+IG1heF9pbnRcbiAgICB8IEZDb25uIChvcCwgXykgLT4gcHJpb19vZl9vcCBvcFxuICAgIHwgRkJpbmQgXyAgICAgICAtPiBtaW5faW50XG4gIFxuICBhbmQgcHJpb19vZl9leHByID0gZnVuY3Rpb25cbiAgICB8IEVWYXIgXyAtPiBtYXhfaW50XG4gICAgfCBFRnVuIChmLCBfKSAtPiBwcmlvX29mX2Z1biBmXG5cbiAgYW5kIHByaW9fb2ZfdHlwZSA9IGZ1bmN0aW9uXG4gICAgfCBUVW5pdCAgIC0+IG1heF9pbnRcbiAgICB8IFRWYXIgIF8gLT4gbWF4X2ludFxuICAgIHwgVFByb2QgXyAtPiBwcmlvX0FuZFxuICAgIHwgVE9yICAgXyAtPiBwcmlvX09yXG4gICAgfCBUUmVjICBfIC0+IG1pbl9pbnRcblxuICBhbmQgcHJpb19vZl9vcCA9IGZ1bmN0aW9uXG4gICAgfCBgTm90ICAgLT4gcHJpb19Ob3RcbiAgICB8IGBBbmQgICAtPiBwcmlvX0FuZFxuICAgIHwgYE9yICAgIC0+IHByaW9fT3JcbiAgICB8IGBJbXAgICAtPiBwcmlvX0ltcFxuICAgIHwgYEVxdWl2IC0+IHByaW9fRXF1aXZcbiAgXG4gIGFuZCBwcmlvX29mX2Z1biA9IGZ1bmN0aW9uXG4gICAgfCBcIlpcIiAgICAtPiBtYXhfaW50XG4gICAgfCBcIlNcIiAgICAtPiAzXG4gICAgfCBcIm11bHRcIiAtPiAyXG4gICAgfCBcImFkZFwiICAtPiAxXG4gICAgfCBfICAgICAgLT4gbWluX2ludFxuXG4gIGFuZCBwcmlvX05vdCAgID0gNVxuICBhbmQgcHJpb19BbmQgICA9IDRcbiAgYW5kIHByaW9fT3IgICAgPSAzXG4gIGFuZCBwcmlvX0ltcCAgID0gMlxuICBhbmQgcHJpb19FcXVpdiA9IDFcblxuICBsZXQgbGVmdF9hc3NvYyAgPSBbKDwpOyAoPD0pXVxuICBsZXQgcmlnaHRfYXNzb2MgPSBbKDw9KTsgKDwpXVxuICBsZXQgbm9fYXNzb2MgICAgPSBbKDw9KTsgKDw9KV1cblxuICBsZXQgYXNzb2Nfb2Zfb3AgPSBmdW5jdGlvblxuICAgIHwgYE5vdCAgIC0+IFsoPCldXG4gICAgfCBgQW5kXG4gICAgfCBgT3IgICAgLT4gbGVmdF9hc3NvY1xuICAgIHwgYEltcCAgIC0+IHJpZ2h0X2Fzc29jXG4gICAgfCBgRXF1aXYgLT4gbm9fYXNzb2NcbiAgXG4gIGxldCBhc3NvY19vZl9mdW4gPSBmdW5jdGlvblxuICAgIHwgXCJaXCIgICAgLT4gW11cbiAgICB8IFwiU1wiICAgIC0+IFsoPCldXG4gICAgfCBcImFkZFwiXG4gICAgfCBcIm11bHRcIiAtPiBsZWZ0X2Fzc29jXG4gICAgfCBfICAgICAgLT4gYXNzZXJ0IGZhbHNlXG5cbiAgbGV0IHVuaWNvZGVfb2Zfb3AgPSBmdW5jdGlvblxuICAgIHwgYE5vdCAgIC0+IDB4MDBBQ1xuICAgIHwgYEFuZCAgIC0+IDB4MjIyN1xuICAgIHwgYE9yICAgIC0+IDB4MjIyOFxuICAgIHwgYEltcCAgIC0+IDB4MjdGOVxuICAgIHwgYEVxdWl2IC0+IDB4MjdGQVxuICBcbiAgbGV0IGFzY2lpX29mX29wID0gZnVuY3Rpb25cbiAgICB8IGBOb3QgICAtPiBcIn5cIlxuICAgIHwgYEFuZCAgIC0+IFwiJiZcIlxuICAgIHwgYE9yICAgIC0+IFwifHxcIlxuICAgIHwgYEltcCAgIC0+IFwiLT5cIlxuICAgIHwgYEVxdWl2IC0+IFwiPC0+XCJcblxuICBsZXQgZl90b2FzY2lpLCBlX3RvYXNjaWksIHRfdG9hc2NpaSA9XG4gICAgbGV0IG9wZW4gVGV4dCBpblxuXG4gICAgbGV0IHJlYyBmb3JfdHlwZSA/KGlzX3ByID0gZmFsc2UpID1cbiAgICAgIHByIH5kb2l0OmlzX3ByIDw8fCBmdW5jdGlvblxuICAgICAgfCBUVW5pdCAtPlxuICAgICAgICAgIFwiKClcIlxuXG4gICAgICB8IFRWYXIgKHgsIDApIC0+XG4gICAgICAgICAgVVRGOC5vZl9sYXRpbjEgeFxuXG4gICAgICB8IFRWYXIgKHgsIGkpIC0+XG4gICAgICAgICAgUHJpbnRmLnNwcmludGYgXCIlc3slZH1cIiAoVVRGOC5vZl9sYXRpbjEgeCkgaVxuXG4gICAgICB8IFRQcm9kICh0MSwgdDIpXG4gICAgICB8IFRPciAodDEsIHQyKSBhcyB0eSAtPlxuICAgICAgICAgIGxldCB0MSA9IGZvcl90eXBlIH5pc19wcjoocHJpb19vZl90eXBlIHQxIDwgcHJpb19vZl90eXBlIHR5KSB0MSBpblxuICAgICAgICAgIGxldCB0MiA9IGZvcl90eXBlIH5pc19wcjoocHJpb19vZl90eXBlIHQyIDw9IHByaW9fb2ZfdHlwZSB0eSkgdDIgaW5cbiAgICAgICAgICBsZXQgdHljb24gPSBiZWdpbiBtYXRjaCB0eSB3aXRoXG4gICAgICAgICAgICB8IFRQcm9kIF8gLT4gJyonXG4gICAgICAgICAgICB8IFRPciBfICAgLT4gJysnXG4gICAgICAgICAgICB8IF8gICAgICAgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgZW5kIGluIHQxIF4gKHNwYWNlZCAoVVRGOC5vZl9jaGFyIChVQ2hhci5vZl9jaGFyIHR5Y29uKSkpIF4gdDJcblxuICAgICAgfCBUUmVjICh4LCB0KSAtPlxuICAgICAgICAgIEZvcm1hdC5zcHJpbnRmIFwicmVjICVzIC4gJXNcIiAoVVRGOC5vZl9sYXRpbjEgeCkgKGZvcl90eXBlIHQpXG5cbiAgICBhbmQgZm9yX2V4cHIgPSBmdW5jdGlvblxuICAgICAgfCBFVmFyICh4LCAwKSAtPlxuICAgICAgICAgIFVURjgub2ZfbGF0aW4xIHhcblxuICAgICAgfCBFVmFyICh4LCBpKSAtPlxuICAgICAgICAgIEZvcm1hdC5zcHJpbnRmIFwiJXN7JWR9XCIgKFVURjgub2ZfbGF0aW4xIHgpIGlcblxuICAgICAgfCBFRnVuIChmLCBhcmdzKSAtPlxuICAgICAgICAgIGxldCBhcmdzID0gU3RyaW5nLmNvbmNhdCBcIiwgXCIgKExpc3QubWFwIGZvcl9leHByIGFyZ3MpIGluXG4gICAgICAgICAgKFVURjgub2ZfbGF0aW4xIGYpIF4gKHByIGFyZ3MpXG5cbiAgICBhbmQgZm9yX2Zvcm0gPyhpc19wciA9IGZhbHNlKSA9XG4gICAgICBwciB+ZG9pdDppc19wciA8PHwgZnVuY3Rpb25cbiAgICAgIHwgRlRydWUgLT5cbiAgICAgICAgICBcInRydWVcIlxuXG4gICAgICB8IEZGYWxzZSAtPlxuICAgICAgICAgIFwiZmFsc2VcIlxuXG4gICAgICB8IEZDb25uIChsZywgZnMpIC0+IGJlZ2luXG4gICAgICAgICAgbGV0IHRleHRfbGcgPSBsZyB8PiBhc2NpaV9vZl9vcCBpblxuICAgICAgICAgIGxldCB0ZXh0X2ZzID1cbiAgICAgICAgICAgIExpc3QuY29tYmluZSBmcyAoYXNzb2Nfb2Zfb3AgbGcpIHw+XG4gICAgICAgICAgICBMaXN0Lm1hcCAoZnVuIChmLCBjbXApIC0+XG4gICAgICAgICAgICAgIGZvcl9mb3JtIH5pc19wcjooY21wIChwcmlvX29mX2Zvcm0gZikgKHByaW9fb2Zfb3AgbGcpKSBmKSBpblxuXG4gICAgICAgICAgbWF0Y2ggbGcsIHRleHRfZnMgd2l0aFxuICAgICAgICAgIHwgKGBBbmQgfCBgT3IgfCBgSW1wIHwgYEVxdWl2KSwgW2YxOyBmMl0gLT5cbiAgICAgICAgICAgICAgZjEgXiBzcGFjZWQgdGV4dF9sZyBeIGYyXG4gICAgICAgICAgfCBgTm90LCBbZl0gLT5cbiAgICAgICAgICAgICAgc3BhY2VkIH5sZWZ0OmZhbHNlIHRleHRfbGcgXiBmXG4gICAgICAgICAgfCAoYEFuZCB8IGBPciB8IGBJbXAgfCBgTm90IHwgYEVxdWl2KSwgXyAtPlxuICAgICAgICAgICAgICBhc3NlcnQgZmFsc2VcbiAgICAgICAgZW5kXG4gICAgICBcbiAgICAgIHwgRlByZWQgKFwiX0VRXCIsIFtlMTsgZTJdKSAtPlxuICAgICAgICAgIEZvcm1hdC5zcHJpbnRmIFwiJXMgPSAlc1wiXG4gICAgICAgICAgICAoZm9yX2V4cHIgZTEpXG4gICAgICAgICAgICAoZm9yX2V4cHIgZTIpXG5cbiAgICAgIHwgRlByZWQgKG5hbWUsIFtdKSAtPlxuICAgICAgICAgIFVURjgub2ZfbGF0aW4xIG5hbWVcblxuICAgICAgfCBGUHJlZCAobmFtZSwgYXJncykgLT5cbiAgICAgICAgICBsZXQgYXJncyA9IExpc3QubWFwIGZvcl9leHByIGFyZ3MgaW5cbiAgICAgICAgICBsZXQgYXJncyA9IFN0cmluZy5qb2luIFwiLCBcIiBhcmdzIGluXG4gICAgICAgICAgVVRGOC5vZl9sYXRpbjEgbmFtZSBeIChwciBhcmdzKVxuXG4gICAgICB8IEZCaW5kIChiZCwgeCwgdHksIGYpIC0+XG4gICAgICAgICAgbGV0IGJkID0gbWF0Y2ggYmQgd2l0aFxuICAgICAgICAgICAgfCBgRm9yYWxsIC0+IFwiZm9yYWxsXCJcbiAgICAgICAgICAgIHwgYEV4aXN0IC0+IFwiZXhpc3RzXCIgaW5cbiAgICAgICAgICBGb3JtYXQuc3ByaW50ZiBcIiVzICVzIDogJXMgLiAlc1wiXG4gICAgICAgICAgICAoYmQpIChVVEY4Lm9mX2xhdGluMSB4KSAoZm9yX3R5cGUgdHkpIChmb3JfZm9ybSBmKVxuXG4gICAgaW4gKGZ1biBmIC0+IGZvcl9mb3JtIGYpLFxuICAgICAgIChmdW4gZSAtPiBmb3JfZXhwciBlKSxcbiAgICAgICAoZnVuIHQgLT4gZm9yX3R5cGUgdClcblxuICBsZXQgdG9hc2NpaSA9IGZ1bmN0aW9uXG4gICAgfCBgRSBlIC0+IGVfdG9hc2NpaSBlXG4gICAgfCBgRiBmIC0+IGZfdG9hc2NpaSBmXG5cbiAgbGV0IGZfdG9zdHJpbmcsIGVfdG9zdHJpbmcsIHRfdG9zdHJpbmcgPVxuICAgIGxldCBvcGVuIFRleHQgaW5cblxuICAgIGxldCByZWMgZm9yX3R5cGUgPyhpc19wciA9IGZhbHNlKSA9XG4gICAgICBwciB+ZG9pdDppc19wciA8PHwgZnVuY3Rpb25cbiAgICAgIHwgVFVuaXQgLT5cbiAgICAgICAgICBcIigpXCJcbiAgICAgIFxuICAgICAgfCBUVmFyIChcIm5hdFwiLCBfKSAtPlxuICAgICAgICAgIFwi4oSVXCJcblxuICAgICAgfCBUVmFyICh4LCAwKSAtPlxuICAgICAgICAgIFVURjgub2ZfbGF0aW4xIHhcblxuICAgICAgfCBUVmFyICh4LCBpKSAtPlxuICAgICAgICAgIFByaW50Zi5zcHJpbnRmIFwiJXN7JWR9XCIgKFVURjgub2ZfbGF0aW4xIHgpIGlcblxuICAgICAgfCBUUHJvZCAodDEsIHQyKVxuICAgICAgfCBUT3IgKHQxLCB0MikgYXMgdHkgLT5cbiAgICAgICAgICBsZXQgdDEgPSBmb3JfdHlwZSB+aXNfcHI6KHByaW9fb2ZfdHlwZSB0MSA8IHByaW9fb2ZfdHlwZSB0eSkgdDEgaW5cbiAgICAgICAgICBsZXQgdDIgPSBmb3JfdHlwZSB+aXNfcHI6KHByaW9fb2ZfdHlwZSB0MiA8PSBwcmlvX29mX3R5cGUgdHkpIHQyIGluXG4gICAgICAgICAgbGV0IHR5Y29uID0gYmVnaW4gbWF0Y2ggdHkgd2l0aFxuICAgICAgICAgICAgfCBUUHJvZCBfIC0+ICcqJ1xuICAgICAgICAgICAgfCBUT3IgXyAgIC0+ICcrJ1xuICAgICAgICAgICAgfCBfICAgICAgIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIGVuZCBpbiB0MSBeIChzcGFjZWQgKFVURjgub2ZfY2hhciAoVUNoYXIub2ZfY2hhciB0eWNvbikpKSBeIHQyXG5cbiAgICAgIHwgVFJlYyAoeCwgdCkgLT5cbiAgICAgICAgICBGb3JtYXQuc3ByaW50ZiBcInJlYyAlcyAuICVzXCIgKFVURjgub2ZfbGF0aW4xIHgpIChmb3JfdHlwZSB0KVxuXG4gICAgYW5kIGZvcl9leHByID8oaXNfcHIgPSBmYWxzZSkgZXhwciA9XG4gICAgICBtYXRjaCBleHByIHdpdGhcbiAgICAgIHwgRVZhciAoeCwgMCkgLT5cbiAgICAgICAgICBVVEY4Lm9mX2xhdGluMSB4XG5cbiAgICAgIHwgRVZhciAoeCwgaSkgLT5cbiAgICAgICAgICBGb3JtYXQuc3ByaW50ZiBcIiVzeyVkfVwiIChVVEY4Lm9mX2xhdGluMSB4KSBpXG4gICAgICBcbiAgICAgIHwgRUZ1biAoXCJaXCIgICAgYXMgZiwgZXMpXG4gICAgICB8IEVGdW4gKFwiU1wiICAgIGFzIGYsIGVzKVxuICAgICAgfCBFRnVuIChcImFkZFwiICBhcyBmLCBlcylcbiAgICAgIHwgRUZ1biAoXCJtdWx0XCIgYXMgZiwgZXMpIC0+XG4gICAgICAgICAgbGV0IHN0ciBlcyA9XG4gICAgICAgICAgICBMaXN0LmNvbWJpbmUgZXMgKGFzc29jX29mX2Z1biBmKSB8PlxuICAgICAgICAgICAgTGlzdC5tYXBpIChmdW4gaSAoZSwgY21wKSAtPlxuICAgICAgICAgICAgICBmb3JfZXhwciB+aXNfcHI6KGNtcCAocHJpb19vZl9leHByIGUpIChwcmlvX29mX2Z1biBmKSkgZSkgaW5cblxuICAgICAgICAgIGJlZ2luIG1hdGNoIGYsIHN0ciBlcyB3aXRoXG4gICAgICAgICAgfCBcIlpcIiwgW10gLT5cbiAgICAgICAgICAgICAgXCIwXCJcbiAgICAgICAgICB8IFwiU1wiLCBfIC0+XG4gICAgICAgICAgICAgIGxldCByZWMgbnVtZXJhbCBudW0gPSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIHwgRUZ1biAoXCJTXCIsIFt4XSkgLT5cbiAgICAgICAgICAgICAgICAgICAgbnVtZXJhbCAobnVtICsgMSkgeFxuICAgICAgICAgICAgICAgIHwgRUZ1biAoXCJaXCIsIFtdKSAtPlxuICAgICAgICAgICAgICAgICAgICBzdHJpbmdfb2ZfaW50IG51bVxuICAgICAgICAgICAgICAgIHwgZSAtPiBcbiAgICAgICAgICAgICAgICAgICAgKHN0ciBbZV0gfD4gTGlzdC5oZCkgXlxuICAgICAgICAgICAgICAgICAgICBcIuKKlVwiIF5cbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nX29mX2ludCBudW1cbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgbnVtZXJhbCAwIGV4cHJcbiAgICAgICAgICB8IFwiYWRkXCIsIFtlMTsgZTJdIC0+XG4gICAgICAgICAgICAgIGUxIF4gc3BhY2VkIFwiK1wiIF4gZTJcbiAgICAgICAgICB8IFwibXVsdFwiLCBbZTE7IGUyXSAtPlxuICAgICAgICAgICAgICBlMSBeIHNwYWNlZCBcIuKLhVwiIF4gZTJcbiAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgZW5kXG5cbiAgICAgIHwgRUZ1biAoZiwgYXJncykgLT5cbiAgICAgICAgICBsZXQgYXJncyA9IFN0cmluZy5jb25jYXQgXCIsIFwiIChMaXN0Lm1hcCBmb3JfZXhwciBhcmdzKSBpblxuICAgICAgICAgIChVVEY4Lm9mX2xhdGluMSBmKSBeIChwciBhcmdzKVxuXG4gICAgYW5kIGZvcl9mb3JtID8oaXNfcHIgPSBmYWxzZSkgPVxuICAgICAgcHIgfmRvaXQ6aXNfcHIgPDx8IGZ1bmN0aW9uXG4gICAgICB8IEZUcnVlIC0+XG4gICAgICAgICAgVVRGOC5vZl9jaGFyIChVQ2hhci5jaHIgMHgyMkE0KVxuXG4gICAgICB8IEZGYWxzZSAtPlxuICAgICAgICAgIFVURjgub2ZfY2hhciAoVUNoYXIuY2hyIDB4MjJBNSlcblxuICAgICAgfCBGQ29ubiAoYE5vdCwgW0ZQcmVkIChcIl9FUVwiLCBbZTE7IGUyXSldKSAtPlxuICAgICAgICAgIGZvcl9leHByIGUxIF5cbiAgICAgICAgICBzcGFjZWQgKFVURjgub2ZfY2hhciAoVUNoYXIuY2hyIDB4MjI2MCkpIF5cbiAgICAgICAgICBmb3JfZXhwciBlMlxuXG4gICAgICB8IEZDb25uIChsZywgZnMpIC0+IGJlZ2luXG4gICAgICAgICAgbGV0IHRleHRfbGcgPSBsZyB8PiB1bmljb2RlX29mX29wIHw+IFVDaGFyLmNociB8PiBVVEY4Lm9mX2NoYXIgaW5cbiAgICAgICAgICBsZXQgdGV4dF9mcyA9XG4gICAgICAgICAgICBMaXN0LmNvbWJpbmUgZnMgKGFzc29jX29mX29wIGxnKSB8PlxuICAgICAgICAgICAgTGlzdC5tYXAgKGZ1biAoZiwgY21wKSAtPlxuICAgICAgICAgICAgICBmb3JfZm9ybSB+aXNfcHI6KGNtcCAocHJpb19vZl9mb3JtIGYpIChwcmlvX29mX29wIGxnKSkgZikgaW5cblxuICAgICAgICAgIG1hdGNoIGxnLCB0ZXh0X2ZzIHdpdGhcbiAgICAgICAgICB8IChgQW5kIHwgYE9yIHwgYEltcCB8IGBFcXVpdiksIFtmMTsgZjJdIC0+XG4gICAgICAgICAgICAgIGYxIF4gc3BhY2VkIHRleHRfbGcgXiBmMlxuICAgICAgICAgIHwgYE5vdCwgW2ZdIC0+XG4gICAgICAgICAgICAgIHNwYWNlZCB+bGVmdDpmYWxzZSB0ZXh0X2xnIF4gZlxuICAgICAgICAgIHwgKGBBbmQgfCBgT3IgfCBgSW1wIHwgYE5vdCB8IGBFcXVpdiksIF8gLT5cbiAgICAgICAgICAgICAgYXNzZXJ0IGZhbHNlXG4gICAgICAgIGVuZFxuICAgICAgXG4gICAgICB8IEZQcmVkIChcIl9FUVwiLCBbZTE7IGUyXSkgLT5cbiAgICAgICAgICBGb3JtYXQuc3ByaW50ZiBcIiVzID0gJXNcIlxuICAgICAgICAgICAgKGZvcl9leHByIGUxKVxuICAgICAgICAgICAgKGZvcl9leHByIGUyKVxuXG4gICAgICB8IEZQcmVkIChuYW1lLCBbXSkgLT5cbiAgICAgICAgICBVVEY4Lm9mX2xhdGluMSBuYW1lXG5cbiAgICAgIHwgRlByZWQgKG5hbWUsIGFyZ3MpIC0+XG4gICAgICAgICAgbGV0IGFyZ3MgPSBMaXN0Lm1hcCBmb3JfZXhwciBhcmdzIGluXG4gICAgICAgICAgbGV0IGFyZ3MgPSBTdHJpbmcuam9pbiBcIiwgXCIgYXJncyBpblxuICAgICAgICAgIFVURjgub2ZfbGF0aW4xIG5hbWUgXiAocHIgYXJncylcblxuICAgICAgfCBGQmluZCAoYmQsIHgsIHR5LCBmKSAtPlxuICAgICAgICAgIGxldCBiZCA9IG1hdGNoIGJkIHdpdGhcbiAgICAgICAgICAgIHwgYEZvcmFsbCAtPiBVVEY4Lm9mX2NoYXIgKFVDaGFyLmNociAweDIyMDApXG4gICAgICAgICAgICB8IGBFeGlzdCAtPiBVVEY4Lm9mX2NoYXIgKFVDaGFyLmNociAweDIyMDMpIGluXG4gICAgICAgICAgRm9ybWF0LnNwcmludGYgXCIlcyVzIDogJXMgLiAlc1wiXG4gICAgICAgICAgICAoYmQpIChVVEY4Lm9mX2xhdGluMSB4KSAoZm9yX3R5cGUgdHkpIChmb3JfZm9ybSBmKVxuXG4gICAgaW4gKGZ1biBmIC0+IGZvcl9mb3JtIGYpLFxuICAgICAgIChmdW4gZSAtPiBmb3JfZXhwciBlKSxcbiAgICAgICAoZnVuIHQgLT4gZm9yX3R5cGUgdClcblxuICBsZXQgdG9zdHJpbmcgPSBmdW5jdGlvblxuICAgIHwgYEUgZSAtPiBlX3Rvc3RyaW5nIGVcbiAgICB8IGBGIGYgLT4gZl90b3N0cmluZyBmXG5cbiAgbGV0IGZfdG9odG1sLCBlX3RvaHRtbCwgdF90b2h0bWwgPVxuICAgIGxldCBvcGVuIFV0aWxzLkh0bWwgaW5cblxuICAgIGxldCByZWMgZm9yX3R5cGUgPyhpc19wciA9IGZhbHNlKSAodHkgOiB0eXBlXykgPVxuICAgICAgbGV0IGRhdGEgPSBtYXRjaCB0eSB3aXRoXG4gICAgICAgIHwgVFVuaXQgLT5cbiAgICAgICAgICAgIFtzcGFuIFtYbWwucGNkYXRhIFwiKClcIl1dXG5cbiAgICAgICAgfCBUVmFyIChcIm5hdFwiLCBfKSAtPlxuICAgICAgICAgICAgW3NwYW4gW1htbC5wY2RhdGEgXCLihJVcIl1dXG5cbiAgICAgICAgfCBUVmFyICh4LCAwKSAtPlxuICAgICAgICAgICAgW3NwYW4gW1htbC5wY2RhdGEgKFVURjgub2ZfbGF0aW4xIHgpXV1cblxuICAgICAgICB8IFRWYXIgKHgsIGkpIC0+XG4gICAgICAgICAgICBbc3BhbiBbWG1sLnBjZGF0YSAoUHJpbnRmLnNwcmludGYgXCIlc3slZH1cIiAoVVRGOC5vZl9sYXRpbjEgeCkgaSldXVxuXG4gICAgICAgIHwgVFByb2QgKHQxLCB0MilcbiAgICAgICAgfCBUT3IgICAodDEsIHQyKSAtPlxuICAgICAgICAgICAgbGV0IHQxID0gZm9yX3R5cGUgfmlzX3ByOihwcmlvX29mX3R5cGUgdDEgPCBwcmlvX29mX3R5cGUgdHkpIHQxIGluXG4gICAgICAgICAgICBsZXQgdDIgPSBmb3JfdHlwZSB+aXNfcHI6KHByaW9fb2ZfdHlwZSB0MiA8PSBwcmlvX29mX3R5cGUgdHkpIHQyIGluXG4gICAgICAgICAgICBsZXQgdHljb24gPSBtYXRjaCB0eSB3aXRoXG4gICAgICAgICAgICAgIHwgVFByb2QgXyAtPiAnKidcbiAgICAgICAgICAgICAgfCBUT3IgXyAgIC0+ICcrJ1xuICAgICAgICAgICAgICB8IF8gICAgICAgLT4gYXNzZXJ0IGZhbHNlIGluXG4gICAgICAgICAgICB0MSBAIChzcGFjZWQgW1htbC5wY2RhdGEgKFVURjgub2ZfY2hhciAoVUNoYXIub2ZfY2hhciB0eWNvbikpXSkgQCB0MlxuXG4gICAgICAgIHwgVFJlYyAoeCwgdCkgLT5cbiAgICAgICAgICAgIGxldCBhb3V0ID1cbiAgICAgICAgICAgICAgICBbW3NwYW4gW1htbC5wY2RhdGEgXCJyZWNcIl1dXVxuICAgICAgICAgICAgICBAIFtbc3BhbiBbWG1sLnBjZGF0YSAoVVRGOC5vZl9sYXRpbjEgeCldXV1cbiAgICAgICAgICAgICAgQCBbW3NwYW4gW1htbC5wY2RhdGEgXCIuXCJdXV1cbiAgICAgICAgICAgICAgQCBbW3NwYW4gKGZvcl90eXBlIHQpXV1cbiAgICAgICAgICAgIGluIExpc3QuZmxhdHRlbiAoTGlzdC5qb2luIFtzcGFuIFtYbWwuZW50aXR5IFwibmJzcFwiXV0gYW91dClcbiAgICAgIGluXG5cbiAgICAgIFtzcGFuIChwciB+ZG9pdDppc19wciBkYXRhKV1cblxuICAgIGFuZCBmb3JfZXhwciA/KGlkIDogc3RyaW5nIG9wdGlvbiBvcHRpb24pID8oaXNfcHIgPSBmYWxzZSkgKHAgOiBpbnQgbGlzdCkgKGV4cHIgOiBleHByKSA6IFhtbC5lbHQgbGlzdCA9XG4gICAgICBsZXQgZm9yX2V4cHIgPSBmb3JfZXhwciA/aWQgaW5cblxuICAgICAgbGV0IHRoaXNpZCBwID1cbiAgICAgICAgaWQgfD5cbiAgICAgICAgT3B0aW9uLm1hcCAoZnVuIHByZWZpeCAtPlxuICAgICAgICAgIGxldCBwID0gU3RyaW5nLmNvbmNhdCBcIi9cIiAoTGlzdC5yZXZfbWFwIHN0cmluZ19vZl9pbnQgcCkgaW5cbiAgICAgICAgICBPcHRpb24uZm9sZFxuICAgICAgICAgICAgKGZ1biBwIHByZWZpeCAtPiBGb3JtYXQuc3ByaW50ZiBcIiVzOiVzXCIgcHJlZml4IHApXG4gICAgICAgICAgICBwIHByZWZpeCkgfD5cbiAgICAgICAgT3B0aW9uLm1hcCAoZnVuIHggLT4gWG1sLnN0cmluZ19hdHRyaWIgXCJpZFwiIHgpIHw+XG4gICAgICAgIExpc3Qub2Zfb3B0aW9uIGluXG4gICAgICBcbiAgICAgIGxldCBpZCA9IHJlZiB0cnVlIGluXG5cbiAgICAgIGxldCBkYXRhID1cbiAgICAgICAgbWF0Y2ggZXhwciB3aXRoXG4gICAgICAgIHwgRVZhciAoeCwgMCkgLT5cbiAgICAgICAgICAgIFtzcGFuIFtYbWwucGNkYXRhIChVVEY4Lm9mX2xhdGluMSB4KV1dXG5cbiAgICAgICAgfCBFVmFyICh4LCBpKSAtPlxuICAgICAgICAgICAgW3NwYW4gW1htbC5wY2RhdGEgKFByaW50Zi5zcHJpbnRmIFwiJXN7JWR9XCIgKFVURjgub2ZfbGF0aW4xIHgpIGkpXV1cbiAgICAgICAgICAgIFxuICAgICAgICB8IEVGdW4gKFwiWlwiICAgIGFzIGYsIGVzKVxuICAgICAgICB8IEVGdW4gKFwiU1wiICAgIGFzIGYsIGVzKVxuICAgICAgICB8IEVGdW4gKFwiYWRkXCIgIGFzIGYsIGVzKVxuICAgICAgICB8IEVGdW4gKFwibXVsdFwiIGFzIGYsIGVzKSAtPlxuICAgICAgICAgICAgbGV0IHhtbCBlcyBwID1cbiAgICAgICAgICAgICAgTGlzdC5jb21iaW5lIGVzIChhc3NvY19vZl9mdW4gZikgfD5cbiAgICAgICAgICAgICAgTGlzdC5tYXBpIChmdW4gaSAoZSwgY21wKSAtPlxuICAgICAgICAgICAgICAgIGZvcl9leHByIH5pc19wcjooY21wIChwcmlvX29mX2V4cHIgZSkgKHByaW9fb2ZfZnVuIGYpKSAoaSA6OiBwKSBlKSBpblxuXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBmLCB4bWwgZXMgcCB3aXRoXG4gICAgICAgICAgICB8IFwiWlwiLCBbXSAtPlxuICAgICAgICAgICAgICAgIFtzcGFuIFtYbWwucGNkYXRhIFwiMFwiXV1cbiAgICAgICAgICAgIHwgXCJTXCIsIF8gLT5cbiAgICAgICAgICAgICAgICBpZCA6PSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgcmVjIG51bWVyYWwgYWNjIG51bSBzdWIgPSBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgfCBFRnVuIChcIlNcIiwgW3hdKSAtPlxuICAgICAgICAgICAgICAgICAgICAgIG51bWVyYWwgKGZ1biB4IC0+IFtzcGFuIH5hOih0aGlzaWQgc3ViKSAoYWNjIHgpXSkgKG51bSArIDEpICgwIDo6IHN1YikgeFxuICAgICAgICAgICAgICAgICAgfCBFRnVuIChcIlpcIiwgW10pIC0+XG4gICAgICAgICAgICAgICAgICAgICAgW3NwYW4gfmE6KHRoaXNpZCBzdWIpIChhY2MgW1htbC5wY2RhdGEgKHN0cmluZ19vZl9pbnQgbnVtKV0pXVxuICAgICAgICAgICAgICAgICAgfCBlIC0+IFxuICAgICAgICAgICAgICAgICAgICAgIGFjYyBiZWdpblxuICAgICAgICAgICAgICAgICAgICAgICAgKHhtbCBbZV0gKExpc3QudGwgc3ViKSB8PiBMaXN0LmhkKSBAXG4gICAgICAgICAgICAgICAgICAgICAgICBbc3BhbiBbWG1sLnBjZGF0YSBcIuKKlVwiXV0gQFxuICAgICAgICAgICAgICAgICAgICAgICAgW1htbC5wY2RhdGEgKHN0cmluZ19vZl9pbnQgbnVtKV1cbiAgICAgICAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgIG51bWVyYWwgaWRlbnRpdHkgMCBwIGV4cHJcbiAgICAgICAgICAgIHwgXCJhZGRcIiwgW2UxOyBlMl0gLT5cbiAgICAgICAgICAgICAgICBlMSBAIHNwYWNlZCBbc3BhbiBbWG1sLnBjZGF0YSBcIitcIl1dIEAgZTJcbiAgICAgICAgICAgIHwgXCJtdWx0XCIsIFtlMTsgZTJdIC0+XG4gICAgICAgICAgICAgICAgZTEgQCBzcGFjZWQgW3NwYW4gW1htbC5wY2RhdGEgXCLii4VcIl1dIEAgZTJcbiAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgIGFzc2VydCBmYWxzZVxuICAgICAgICAgICAgZW5kXG5cbiAgICAgICAgfCBFRnVuIChuYW1lLCBhcmdzKSAtPlxuICAgICAgICAgICAgbGV0IGFyZ3MgPSBMaXN0Lm1hcGkgKGZ1biBpIGUgLT4gZm9yX2V4cHIgKGkgOjogcCkgZSkgYXJncyBpblxuICAgICAgICAgICAgbGV0IGFvdXQgPVxuICAgICAgICAgICAgICAgIFtbc3BhbiBbWG1sLnBjZGF0YSAoVVRGOC5vZl9sYXRpbjEgbmFtZSldXV1cbiAgICAgICAgICAgICAgQCBbcHIgKExpc3QuZmxhdHRlbiAoTGlzdC5qb2luIFtzcGFuIFtYbWwucGNkYXRhIFwiLFwiOyBYbWwuZW50aXR5IFwibmJzcFwiXV0gYXJncykpXVxuXG4gICAgICAgICAgICBpbiBMaXN0LmZsYXR0ZW4gKExpc3Quam9pbiBbc3BhbiBbWG1sLmVudGl0eSBcIm5ic3BcIl1dIGFvdXQpXG4gICAgICBpblxuXG4gICAgICBbc3BhbiB+YTooaWYgIWlkIHRoZW4gdGhpc2lkIHAgZWxzZSBbXSkgKHByIH5kb2l0OmlzX3ByIGRhdGEpXVxuXG4gICAgYW5kIGZvcl9mb3JtID8oaWQgOiBzdHJpbmcgb3B0aW9uIG9wdGlvbikgPyhpc19wciA9IGZhbHNlKSAocCA6IGludCBsaXN0KSAoZm9ybSA6IGZvcm0pID1cbiAgICAgIGxldCBmb3JfZm9ybSA9IGZvcl9mb3JtID9pZCBpblxuXG4gICAgICBsZXQgdGhpc2lkIHAgPVxuICAgICAgICBpZCB8PlxuICAgICAgICBPcHRpb24ubWFwIChmdW4gcHJlZml4IC0+XG4gICAgICAgICAgbGV0IHAgPSBTdHJpbmcuY29uY2F0IFwiL1wiIChMaXN0LnJldl9tYXAgc3RyaW5nX29mX2ludCBwKSBpblxuICAgICAgICAgIE9wdGlvbi5mb2xkXG4gICAgICAgICAgICAoZnVuIHAgcHJlZml4IC0+IEZvcm1hdC5zcHJpbnRmIFwiJXM6JXNcIiBwcmVmaXggcClcbiAgICAgICAgICAgIHAgcHJlZml4KSB8PlxuICAgICAgICBPcHRpb24ubWFwIChmdW4geCAtPiBYbWwuc3RyaW5nX2F0dHJpYiBcImlkXCIgeCkgfD5cbiAgICAgICAgTGlzdC5vZl9vcHRpb24gaW5cblxuICAgICAgbGV0IGRhdGEgPVxuICAgICAgICBtYXRjaCBmb3JtIHdpdGhcbiAgICAgICAgfCBGVHJ1ZSAtPlxuICAgICAgICAgICAgW3NwYW4gW1htbC5lbnRpdHkgXCIjeDIyQTRcIl1dXG5cbiAgICAgICAgfCBGRmFsc2UgLT5cbiAgICAgICAgICAgIFtzcGFuIFtYbWwuZW50aXR5IFwiI3gyMkE1XCJdXVxuXG4gICAgICAgIHwgRkNvbm4gKGBOb3QsIFtGUHJlZCAoXCJfRVFcIiwgW2UxOyBlMl0pXSkgLT5cbiAgICAgICAgICAgIFtzcGFuIH5hOih0aGlzaWQgKDAgOjogcCkpIChcbiAgICAgICAgICAgICAgW3NwYW4gKGZvcl9leHByID9pZCAoMCA6OiAwIDo6IHApIGUxKTtcbiAgICAgICAgICAgICAgIHNwYW4gW1htbC5lbnRpdHkgXCJuYnNwXCI7IFhtbC5lbnRpdHkgXCIjeDIyNjBcIjsgWG1sLmVudGl0eSBcIm5ic3BcIl07XG4gICAgICAgICAgICAgICBzcGFuIChmb3JfZXhwciA/aWQgKDEgOjogMCA6OiBwKSBlMildKV1cblxuICAgICAgICB8IEZDb25uIChsZywgZnMpIC0+IGJlZ2luXG4gICAgICAgICAgICBsZXQgeG1sX2xnID1cbiAgICAgICAgICAgICAgbGV0IGhleGNvZGUgPSBQcmludGYuc3ByaW50ZiBcIiN4JXhcIiAodW5pY29kZV9vZl9vcCBsZykgaW5cbiAgICAgICAgICAgICAgW3NwYW4gW1htbC5lbnRpdHkgaGV4Y29kZV1dIGluXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCB4bWxfZnMgPVxuICAgICAgICAgICAgICBMaXN0LmNvbWJpbmUgZnMgKGFzc29jX29mX29wIGxnKSB8PlxuICAgICAgICAgICAgICBMaXN0Lm1hcGkgKGZ1biBpIChmLCBjbXApIC0+XG4gICAgICAgICAgICAgICAgZm9yX2Zvcm0gfmlzX3ByOihjbXAgKHByaW9fb2ZfZm9ybSBmKSAocHJpb19vZl9vcCBsZykpIChpIDo6IHApIGYpIGluXG5cbiAgICAgICAgICAgIG1hdGNoIGxnLCB4bWxfZnMgd2l0aFxuICAgICAgICAgICAgfCAoYEFuZCB8IGBPciB8IGBJbXAgfCBgRXF1aXYpLCBbZjE7IGYyXSAtPlxuICAgICAgICAgICAgICAgIGYxIEAgc3BhY2VkIHhtbF9sZyBAIGYyXG4gICAgICAgICAgICB8IGBOb3QsIFtmXSAtPlxuICAgICAgICAgICAgICAgIChzcGFjZWQgfmxlZnQ6ZmFsc2UgeG1sX2xnKSBAIGZcbiAgICAgICAgICAgIHwgKGBBbmQgfCBgT3IgfCBgSW1wIHwgYE5vdCB8IGBFcXVpdiksIF8gLT5cbiAgICAgICAgICAgICAgICBhc3NlcnQgZmFsc2VcbiAgICAgICAgICBlbmRcblxuICAgICAgICB8IEZQcmVkIChcIl9FUVwiLCBbZTE7IGUyXSkgLT5cbiAgICAgICAgICAgIFtzcGFuIChmb3JfZXhwciA/aWQgKDAgOjogcCkgZTEpO1xuICAgICAgICAgICAgIHNwYW4gW1htbC5lbnRpdHkgXCJuYnNwXCI7IFhtbC5wY2RhdGEgXCI9XCI7IFhtbC5lbnRpdHkgXCJuYnNwXCJdO1xuICAgICAgICAgICAgIHNwYW4gKGZvcl9leHByID9pZCAoMSA6OiBwKSBlMildXG5cbiAgICAgICAgfCBGUHJlZCAobmFtZSwgW10pIC0+XG4gICAgICAgICAgICBbc3BhbiBbWG1sLnBjZGF0YSAoVVRGOC5vZl9sYXRpbjEgbmFtZSldXVxuXG4gICAgICAgIHwgRlByZWQgKG5hbWUsIGFyZ3MpIC0+XG4gICAgICAgICAgICBsZXQgYXJncyA9IExpc3QubWFwaSAoZnVuIGkgZSAtPiBmb3JfZXhwciA/aWQgKGkgOjogcCkgZSkgYXJncyBpblxuICAgICAgICAgICAgbGV0IGFvdXQgPVxuICAgICAgICAgICAgICAgIFtbc3BhbiBbWG1sLnBjZGF0YSAoVVRGOC5vZl9sYXRpbjEgbmFtZSldXV1cbiAgICAgICAgICAgICAgQCBbcHIgKExpc3QuZmxhdHRlbiAoTGlzdC5qb2luIFtzcGFuIFtYbWwucGNkYXRhIFwiLFwiOyBYbWwuZW50aXR5IFwibmJzcFwiXV0gYXJncykpXVxuXG4gICAgICAgICAgICBpbiBMaXN0LmZsYXR0ZW4gKExpc3Quam9pbiBbc3BhbiBbWG1sLmVudGl0eSBcIm5ic3BcIl1dIGFvdXQpXG5cbiAgICAgICAgfCBGQmluZCAoYmQsIHgsIHR5LCBmKSAtPlxuICAgICAgICAgICAgbGV0IGJkID0gbWF0Y2ggYmQgd2l0aFxuICAgICAgICAgICAgICB8IGBGb3JhbGwgLT4gVVRGOC5vZl9jaGFyIChVQ2hhci5jaHIgMHgyMjAwKVxuICAgICAgICAgICAgICB8IGBFeGlzdCAtPiBVVEY4Lm9mX2NoYXIgKFVDaGFyLmNociAweDIyMDMpIGluXG5cbiAgICAgICAgICAgIGxldCBhb3V0ID1cbiAgICAgICAgICAgICAgICBbW3NwYW4gW1htbC5wY2RhdGEgKGJkKV1dXVxuICAgICAgICAgICAgICBAIFtbc3BhbiBbWG1sLnBjZGF0YSAoVVRGOC5vZl9sYXRpbjEgeCldXV1cbiAgICAgICAgICAgICAgQCBbW3NwYW4gW1htbC5wY2RhdGEgXCI6XCJdXV1cbiAgICAgICAgICAgICAgQCBbW3NwYW4gKGZvcl90eXBlIHR5KV1dXG4gICAgICAgICAgICAgIEAgW1tzcGFuIFtYbWwucGNkYXRhIFwiLlwiXV1dXG4gICAgICAgICAgICAgIEAgW2Zvcl9mb3JtICgwIDo6IHApIGZdXG5cbiAgICAgICAgICAgIGluIExpc3QuZmxhdHRlbiAoTGlzdC5qb2luIFtzcGFuIFtYbWwuZW50aXR5IFwibmJzcFwiXV0gYW91dClcblxuICAgICAgaW5cblxuICAgICAgW3NwYW4gfmE6KHRoaXNpZCBwKSAocHIgfmRvaXQ6aXNfcHIgZGF0YSldIGluXG5cbiAgICAoKGZ1biA/aWQgKGZvcm0gOiBmb3JtICkgLT4gc3BhbiAoZm9yX2Zvcm0gP2lkIFtdIGZvcm0pKSxcbiAgICAgKGZ1biA/aWQgKGV4cHIgOiBleHByICkgLT4gc3BhbiAoZm9yX2V4cHIgP2lkIFtdIGV4cHIpKSxcbiAgICAgKGZ1biAodHkgOiB0eXBlXykgLT4gc3BhbiAoZm9yX3R5cGUgdHkpKSlcblxuICBsZXQgdG9odG1sID9pZCA9IGZ1bmN0aW9uXG4gICAgfCBgRSBlIC0+IGVfdG9odG1sID9pZCBlXG4gICAgfCBgRiBmIC0+IGZfdG9odG1sID9pZCBmXG5cbiAgbGV0IGZfdG9tYXRobWwsIGVfdG9tYXRobWwsIHRfdG9tYXRobWwgPVxuICAgIGxldCBvcGVuIFR5eG1sIGluXG4gICAgbGV0IG9wZW4gVXRpbHMuTWF0aG1sIGluXG5cbiAgICBsZXQgcmVjIGZvcl90eXBlID8oaXNfcHIgPSBmYWxzZSkgKHR5IDogdHlwZV8pID1cbiAgICAgIGxldCBkYXRhID0gbWF0Y2ggdHkgd2l0aFxuICAgICAgICB8IFRVbml0IC0+XG4gICAgICAgICAgICBbbW8gKFVURjgub2ZfY2hhciAoVUNoYXIub2ZfaW50IDB4MjAyMikpXVxuICAgICAgICBcbiAgICAgICAgfCBUVmFyIChcIm5hdFwiLCBfKSAtPlxuICAgICAgICAgICAgW21vIFwi4oSVXCJdXG5cbiAgICAgICAgfCBUVmFyICh4LCAwKSAtPlxuICAgICAgICAgICAgW21pIChVVEY4Lm9mX2xhdGluMSB4KV1cblxuICAgICAgICB8IFRWYXIgKHgsIGkpIC0+XG4gICAgICAgICAgICBsZXQgeCA9IFByaW50Zi5zcHJpbnRmIFwiJXN7JWR9XCIgKFVURjgub2ZfbGF0aW4xIHgpIGkgaW5cbiAgICAgICAgICAgIFttaSAoVVRGOC5vZl9sYXRpbjEgeCldXG5cbiAgICAgICAgfCBUUHJvZCAodDEsIHQyKVxuICAgICAgICB8IFRPciAgICh0MSwgdDIpIC0+XG4gICAgICAgICAgICBsZXQgdDEgPSBmb3JfdHlwZSB+aXNfcHI6KHByaW9fb2ZfdHlwZSB0MSA8IHByaW9fb2ZfdHlwZSB0eSkgdDEgaW5cbiAgICAgICAgICAgIGxldCB0MiA9IGZvcl90eXBlIH5pc19wcjoocHJpb19vZl90eXBlIHQyIDw9IHByaW9fb2ZfdHlwZSB0eSkgdDIgaW5cbiAgICAgICAgICAgIGxldCB0eWNvbiA9IG1hdGNoIHR5IHdpdGhcbiAgICAgICAgICAgICAgfCBUUHJvZCBfIC0+IFVDaGFyLm9mX2ludCAweDAwRDdcbiAgICAgICAgICAgICAgfCBUT3IgXyAgIC0+IFVDaGFyLm9mX2ludCAweDAwMkJcbiAgICAgICAgICAgICAgfCBfICAgICAgIC0+IGFzc2VydCBmYWxzZSBpblxuICAgICAgICAgICAgdDEgQCBbbW8gKFVURjgub2ZfY2hhciB0eWNvbildIEAgdDJcblxuICAgICAgICB8IFRSZWMgKHgsIHQpIC0+XG4gICAgICAgICAgICBbbW8gKFVURjgub2ZfY2hhciAoVUNoYXIub2ZfaW50IDB4MDNCQykpO1xuICAgICAgICAgICAgIG1pIChVVEY4Lm9mX2xhdGluMSB4KTtcbiAgICAgICAgICAgICBtbyAoVVRGOC5vZl9sYXRpbjEgXCIuXCIpXSBAIGZvcl90eXBlIHRcbiAgICAgIGluXG5cbiAgICAgIFtwciB+ZG9pdDppc19wciAocm93IGRhdGEpXVxuXG4gICAgYW5kIGZvcl9leHByID8oaWQgOiBzdHJpbmcgb3B0aW9uIG9wdGlvbikgPyhpc19wciA9IGZhbHNlKSAocCA6IGludCBsaXN0KSAoZXhwciA6IGV4cHIpID1cbiAgICAgIGxldCBmb3JfZXhwciA9IGZvcl9leHByID9pZCBpblxuXG4gICAgICBsZXQgZGF0YSA9XG4gICAgICAgIG1hdGNoIGV4cHIgd2l0aFxuICAgICAgICB8IEVWYXIgKHgsIDApIC0+XG4gICAgICAgICAgICBbbWkgKFVURjgub2ZfbGF0aW4xIHgpXVxuXG4gICAgICAgIHwgRVZhciAoeCwgaSkgLT5cbiAgICAgICAgICAgIGxldCB4ID0gUHJpbnRmLnNwcmludGYgXCIlc3slZH1cIiAoVVRGOC5vZl9sYXRpbjEgeCkgaSBpblxuICAgICAgICAgICAgW21pIChVVEY4Lm9mX2xhdGluMSB4KV1cbiAgICAgICAgXG4gICAgICAgIHwgRUZ1biAoXCJaXCIgICAgYXMgZiwgZXMpXG4gICAgICAgIHwgRUZ1biAoXCJTXCIgICAgYXMgZiwgZXMpXG4gICAgICAgIHwgRUZ1biAoXCJhZGRcIiAgYXMgZiwgZXMpXG4gICAgICAgIHwgRUZ1biAoXCJtdWx0XCIgYXMgZiwgZXMpIC0+XG4gICAgICAgICAgICBsZXQgeG1sIGVzIHAgPVxuICAgICAgICAgICAgICBMaXN0LmNvbWJpbmUgZXMgKGFzc29jX29mX2Z1biBmKSB8PlxuICAgICAgICAgICAgICBMaXN0Lm1hcGkgKGZ1biBpIChlLCBjbXApIC0+XG4gICAgICAgICAgICAgICAgZm9yX2V4cHIgfmlzX3ByOihjbXAgKHByaW9fb2ZfZXhwciBlKSAocHJpb19vZl9mdW4gZikpIChpIDo6IHApIGUpIGluXG5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGYsIHhtbCBlcyBwIHdpdGhcbiAgICAgICAgICAgIHwgXCJaXCIsIFtdIC0+XG4gICAgICAgICAgICAgICAgW21uIFwiMFwiXVxuICAgICAgICAgICAgfCBcIlNcIiwgXyAtPlxuICAgICAgICAgICAgICAgIGJlZ2luIG1hdGNoIGVzIHdpdGhcbiAgICAgICAgICAgICAgICB8IFtuXSAtPlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjIG51bWVyYWwgYWNjID0gZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICB8IEVGdW4gKFwiU1wiLCBbeF0pIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG51bWVyYWwgKGFjYyArIDEpIHhcbiAgICAgICAgICAgICAgICAgICAgICB8IEVGdW4gKFwiWlwiLCBbXSkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgW21uIChzdHJpbmdfb2ZfaW50IGFjYyldXG4gICAgICAgICAgICAgICAgICAgICAgfCBlIC0+IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoeG1sIFtlXSAoTGlzdC5pbml0IChhY2MgLSAxKSAoZnVuIF8gLT4gMCkgQCBwKSB8PiBMaXN0LmhkKSBAXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFttbyBcIuKKlVwiXSBAXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFttbiAoc3RyaW5nX29mX2ludCBhY2MpXVxuICAgICAgICAgICAgICAgICAgICBpbiBudW1lcmFsIDEgblxuICAgICAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIHwgXCJhZGRcIiwgW2UxOyBlMl0gLT5cbiAgICAgICAgICAgICAgICBlMSBAIFttbyBcIitcIl0gQCBlMlxuICAgICAgICAgICAgfCBcIm11bHRcIiwgW2UxOyBlMl0gLT5cbiAgICAgICAgICAgICAgICBlMSBAIFttbyBcIsOXXCJdIEAgZTJcbiAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgIGFzc2VydCBmYWxzZVxuICAgICAgICAgICAgZW5kXG5cbiAgICAgICAgfCBFRnVuIChuYW1lLCBhcmdzKSAtPlxuICAgICAgICAgICAgbGV0IGFyZ3MgPSBMaXN0Lm1hcGkgKGZ1biBpIGUgLT4gZm9yX2V4cHIgKGkgOjogcCkgZSkgYXJncyBpblxuICAgICAgICAgICAgICAgIFttaSAoVVRGOC5vZl9sYXRpbjEgbmFtZSldXG4gICAgICAgICAgICAgIEAgW3ByIChyb3cgKExpc3QuZmxhdHRlbiAoTGlzdC5qb2luIFttbyBcIixcIl0gYXJncykpKV1cbiAgICAgIGluXG5cbiAgICAgIGxldCB0aGlzaWQgPVxuICAgICAgICBpZCB8PiBPcHRpb24ubWFwIChmdW4gcHJlZml4IC0+XG4gICAgICAgICAgbGV0IHAgPSBTdHJpbmcuY29uY2F0IFwiL1wiIChMaXN0LnJldl9tYXAgc3RyaW5nX29mX2ludCBwKSBpblxuICAgICAgICAgIE9wdGlvbi5mb2xkXG4gICAgICAgICAgICAoZnVuIHAgcHJlZml4IC0+IEZvcm1hdC5zcHJpbnRmIFwiJXM6JXNcIiBwcmVmaXggcClcbiAgICAgICAgICAgIHAgcHJlZml4KSBpblxuICAgICAgbGV0IHRoaXNpZCA9IHRoaXNpZCB8PiBPcHRpb24ubWFwIChYbWwuc3RyaW5nX2F0dHJpYiBcImlkXCIpIGluXG5cbiAgICAgIFtwciB+ZG9pdDppc19wciAocm93IH5hOihMaXN0Lm9mX29wdGlvbiB0aGlzaWQpIGRhdGEpXVxuXG4gICAgYW5kIGZvcl9mb3JtID8oaWQgOiBzdHJpbmcgb3B0aW9uIG9wdGlvbikgPyhpc19wciA9IGZhbHNlKSAocCA6IGludCBsaXN0KSAoZm9ybSA6IGZvcm0pID1cbiAgICAgIGxldCBmb3JfZm9ybSA9IGZvcl9mb3JtID9pZCBpblxuXG4gICAgICBsZXQgdGhpc2lkIHAgPVxuICAgICAgICBpZCB8PlxuICAgICAgICBPcHRpb24ubWFwIChmdW4gcHJlZml4IC0+XG4gICAgICAgICAgbGV0IHAgPSBTdHJpbmcuY29uY2F0IFwiL1wiIChMaXN0LnJldl9tYXAgc3RyaW5nX29mX2ludCBwKSBpblxuICAgICAgICAgIE9wdGlvbi5mb2xkXG4gICAgICAgICAgICAoZnVuIHAgcHJlZml4IC0+IEZvcm1hdC5zcHJpbnRmIFwiJXM6JXNcIiBwcmVmaXggcClcbiAgICAgICAgICAgIHAgcHJlZml4KSB8PlxuICAgICAgICBPcHRpb24ubWFwIChmdW4geCAtPiBYbWwuc3RyaW5nX2F0dHJpYiBcImlkXCIgeCkgfD5cbiAgICAgICAgTGlzdC5vZl9vcHRpb24gaW5cblxuICAgICAgbGV0IGRhdGEgPVxuICAgICAgICBtYXRjaCBmb3JtIHdpdGhcbiAgICAgICAgfCBGVHJ1ZSAtPlxuICAgICAgICAgICAgW21vIChVVEY4Lm9mX2NoYXIgKFVDaGFyLm9mX2ludCAweDIyQTQpKV1cblxuICAgICAgICB8IEZGYWxzZSAtPlxuICAgICAgICAgICAgW21vIChVVEY4Lm9mX2NoYXIgKFVDaGFyLm9mX2ludCAweDIyQTUpKV1cblxuICAgICAgICB8IEZDb25uIChgTm90LCBbRlByZWQgKFwiX0VRXCIsIFtlMTsgZTJdKV0pIC0+XG4gICAgICAgICAgICBbcm93IH5hOih0aGlzaWQgKDAgOjogcCkpIChcbiAgICAgICAgICAgICAgKGZvcl9leHByID9pZCAoMCA6OiAwIDo6IHApIGUxKSBAXG4gICAgICAgICAgICAgIFttbyAoVVRGOC5vZl9jaGFyIChVQ2hhci5vZl9pbnQgMHgyMjYwKSldIEBcbiAgICAgICAgICAgICAgKGZvcl9leHByID9pZCAoMSA6OiAwIDo6IHApIGUyKSldXG5cbiAgICAgICAgfCBGQ29ubiAobGcsIGZzKSAtPiBiZWdpblxuICAgICAgICAgICAgbGV0IHhtbF9sZyA9XG4gICAgICAgICAgICAgIFttbyAoVVRGOC5vZl9jaGFyIChVQ2hhci5vZl9pbnQgKHVuaWNvZGVfb2Zfb3AgbGcpKSldIGluXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCB4bWxfZnMgPVxuICAgICAgICAgICAgICBMaXN0LmNvbWJpbmUgZnMgKGFzc29jX29mX29wIGxnKSB8PlxuICAgICAgICAgICAgICBMaXN0Lm1hcGkgKGZ1biBpIChmLCBjbXApIC0+XG4gICAgICAgICAgICAgICAgZm9yX2Zvcm0gfmlzX3ByOihjbXAgKHByaW9fb2ZfZm9ybSBmKSAocHJpb19vZl9vcCBsZykpIChpIDo6IHApIGYpIGluXG5cbiAgICAgICAgICAgIG1hdGNoIGxnLCB4bWxfZnMgd2l0aFxuICAgICAgICAgICAgfCAoYEFuZCB8IGBPciB8IGBJbXAgfCBgRXF1aXYpLCBbZjE7IGYyXSAtPlxuICAgICAgICAgICAgICAgIGYxIEAgeG1sX2xnIEAgZjJcbiAgICAgICAgICAgIHwgYE5vdCwgW2ZdIC0+XG4gICAgICAgICAgICAgICAgeG1sX2xnIEAgZlxuICAgICAgICAgICAgfCAoYEFuZCB8IGBPciB8IGBJbXAgfCBgTm90IHwgYEVxdWl2KSwgXyAtPlxuICAgICAgICAgICAgICAgIGFzc2VydCBmYWxzZVxuICAgICAgICAgIGVuZFxuXG4gICAgICAgIHwgRlByZWQgKFwiX0VRXCIsIFtlMTsgZTJdKSAtPlxuICAgICAgICAgICAgICAoZm9yX2V4cHIgP2lkICgwIDo6IHApIGUxKVxuICAgICAgICAgICAgQCBbbW8gKFVURjgub2ZfbGF0aW4xIFwiPVwiKV1cbiAgICAgICAgICAgIEAgKGZvcl9leHByID9pZCAoMSA6OiBwKSBlMilcblxuICAgICAgICB8IEZQcmVkIChuYW1lLCBbXSkgLT5cbiAgICAgICAgICAgIFttaSAoVVRGOC5vZl9sYXRpbjEgbmFtZSldXG5cbiAgICAgICAgfCBGUHJlZCAobmFtZSwgYXJncykgLT5cbiAgICAgICAgICAgIGxldCBhcmdzID0gTGlzdC5tYXBpIChmdW4gaSBlIC0+IGZvcl9leHByID9pZCAoaSA6OiBwKSBlKSBhcmdzIGluXG4gICAgICAgICAgICAgICBbbWkgKFVURjgub2ZfbGF0aW4xIG5hbWUpXVxuICAgICAgICAgICAgIEAgW3ByIChyb3cgKExpc3QuZmxhdHRlbiAoTGlzdC5qb2luIFttbyBcIixcIl0gYXJncykpKV1cblxuICAgICAgICB8IEZCaW5kIChiZCwgeCwgdHksIGYpIC0+XG4gICAgICAgICAgICBsZXQgYmQgPSBtYXRjaCBiZCB3aXRoXG4gICAgICAgICAgICAgIHwgYEZvcmFsbCAtPiBVVEY4Lm9mX2NoYXIgKFVDaGFyLmNociAweDIyMDApXG4gICAgICAgICAgICAgIHwgYEV4aXN0ICAtPiBVVEY4Lm9mX2NoYXIgKFVDaGFyLmNociAweDIyMDMpIGluXG5cbiAgICAgICAgICAgIFttbyBiZDsgbWkgKFVURjgub2ZfbGF0aW4xIHgpOyBtbyBcIjpcIl1cbiAgICAgICAgICBAIChmb3JfdHlwZSB0eSlcbiAgICAgICAgICBAIFttbyAoVVRGOC5vZl9sYXRpbjEgXCIuXCIpXVxuICAgICAgICAgIEAgKGZvcl9mb3JtICgwIDo6IHApIGYpXG5cbiAgICAgIGluXG5cbiAgICAgIFtwciB+ZG9pdDppc19wciAocm93IH5hOih0aGlzaWQgcCkgZGF0YSldIGluXG5cbiAgICAoKGZ1biA/aWQgKGZvcm0gOiBmb3JtICkgLT4gcm93IChmb3JfZm9ybSA/aWQgW10gZm9ybSkpLFxuICAgICAoZnVuID9pZCAoZXhwciA6IGV4cHIgKSAtPiByb3cgKGZvcl9leHByID9pZCBbXSBleHByKSksXG4gICAgIChmdW4gKHR5IDogdHlwZV8pIC0+IHJvdyAoZm9yX3R5cGUgdHkpKSlcblxuICBsZXQgdG9tYXRobWwgP2lkID0gZnVuY3Rpb25cbiAgICB8IGBFIGUgLT4gZV90b21hdGhtbCA/aWQgZVxuICAgIHwgYEYgZiAtPiBmX3RvbWF0aG1sID9pZCBmXG5lbmRcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbm1vZHVsZSBWYXJzIDogc2lnXG4gIHZhbCBmcmVzaCAgICAgOiBlbnYgLT4gP2Jhc2VuYW1lOm5hbWUgLT4gdW5pdCAtPiBuYW1lXG4gIHZhbCBwdXNoICAgICAgOiBlbnYgLT4gbmFtZSAqIGJ2YXIgLT4gZW52XG4gIHZhbCBiaW5kICAgICAgOiBlbnYgLT4gbmFtZSAqIHR5cGVfIC0+IG5hbWUgKiBlbnZcbiAgdmFsIGdldCAgICAgICA6IGVudiAtPiB2bmFtZSAtPiBidmFyIG9wdGlvblxuICB2YWwgbW9kaWZ5ICAgIDogZW52IC0+IHZuYW1lICogYnZhciAtPiBlbnZcbiAgdmFsIHJlbW92ZSAgICA6IGVudiAtPiB2bmFtZSAtPiBlbnZcbiAgdmFsIGV4aXN0cyAgICA6IGVudiAtPiB2bmFtZSAtPiBib29sXG4gIHZhbCBieWlkICAgICAgOiBlbnYgLT4gdWlkIC0+ICh2bmFtZSAqIGJ2YXIpIG9wdGlvblxuICB2YWwgZ2V0aWQgICAgIDogZW52IC0+IHZuYW1lIC0+IHVpZCBvcHRpb25cbiAgdmFsIG1hcCAgICAgICA6IGVudiAtPiAoZXhwciBvcHRpb24gLT4gZXhwciBvcHRpb24pIC0+IGVudlxuICB2YWwgYWxsICAgICAgIDogZW52IC0+IChuYW1lLCBidmFyIGxpc3QpIE1hcC50XG4gIHZhbCB0b19zdHJpbmcgOiBlbnYgLT4gbmFtZSAtPiBzdHJpbmdcbiAgdmFsIHRvX2xpc3QgICA6IGVudiAtPiAodWlkICogdm5hbWUgKiBidmFyKSBsaXN0XG5lbmQgPSBzdHJ1Y3RcbiAgbGV0IG5hbWVfY291bnRlcnMgOiAoZW52LCBpbnQgcmVmKSBNYXAudCByZWYgPVxuICAgIHJlZiBNYXAuZW1wdHlcblxuICAoKiBbZnJlc2ggZW52IH5iYXNlbmFtZSAoKV0gZ2VuZXJhdGVzIGEgZnJlc2ggbmFtZSBmb3IgYVxuICAgICBsb2NhbCB2YXJpYWJsZSBpbiBbZW52XSwgYmFzZWQgb24gYW4gb3B0aW9uYWwgW2Jhc2VuYW1lXS4gKilcbiAgbGV0IGZyZXNoIGVudiA/KGJhc2VuYW1lID0gXCJ4XCIpICgpID1cbiAgICBpZiBub3QgKE1hcC5tZW0gYmFzZW5hbWUgZW52LmVudl92YXIpIHRoZW5cbiAgICAgIGJhc2VuYW1lXG4gICAgZWxzZVxuICAgICAgbGV0IG4gPVxuICAgICAgICB0cnkgTWFwLmZpbmQgZW52ICFuYW1lX2NvdW50ZXJzXG4gICAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgbGV0IG4gPSByZWYgMCBpblxuICAgICAgICAgIG5hbWVfY291bnRlcnMgOj0gTWFwLmFkZCBlbnYgbiAhbmFtZV9jb3VudGVycztcbiAgICAgICAgICBuXG4gICAgICBpblxuICAgICAgbGV0IHJlYyBhdXggbiA9XG4gICAgICAgIGxldCBiYXNlbmFtZSA9IGJhc2VuYW1lIF4gc3RyaW5nX29mX2ludCBuIGluXG4gICAgICAgIGlmIG5vdCAoTWFwLm1lbSBiYXNlbmFtZSBlbnYuZW52X3ZhcilcbiAgICAgICAgdGhlbiAoYmFzZW5hbWUsIG4pXG4gICAgICAgIGVsc2UgYXV4IChuKzEpXG4gICAgICBpblxuICAgICAgbGV0IChiYXNlbmFtZSwgbicpID0gYXV4ICFuIGluXG4gICAgICBuIDo9IG4nOyBiYXNlbmFtZVxuXG4gIGxldCBwdXNoIChlbnYgOiBlbnYpICgobmFtZSwgKHR5LCBib2R5KSkgOiBuYW1lICogYnZhcikgPVxuICAgIGxldCBpID0gcmVmIDAgaW5cblxuICAgIGxldCBlbnZfdmFyID0gTWFwLm1vZGlmeV9vcHQgbmFtZSAoZnVuIGJkcyAtPlxuICAgICAgbGV0IHYgPSAodHksIGJvZHkpIDo6IE9wdGlvbi5kZWZhdWx0IFtdIGJkcyBpblxuICAgICAgaSA6PSBMaXN0Lmxlbmd0aCB2IC0gMTsgU29tZSB2KSBlbnYuZW52X3ZhciBpblxuXG4gICAgbGV0IGVudl9oYW5kbGVzID0gXG4gICAgICBCaU1hcC5hZGQgKG5hbWUsICFpKSAoVWlkLmZyZXNoICgpKSBlbnYuZW52X2hhbmRsZXMgaW5cblxuICAgIHsgZW52IHdpdGggZW52X3ZhcjsgZW52X2hhbmRsZXMgfVxuXG4gIGxldCBiaW5kIChlbnYgOiBlbnYpICgobmFtZSwgdHkpIDogbmFtZSAqIHR5cGVfKSA9XG4gICAgbGV0IG5hbWUgPSBmcmVzaCBlbnYgfmJhc2VuYW1lOm5hbWUgKCkgaW5cbiAgICBuYW1lLCBwdXNoIGVudiAobmFtZSwgKHR5LCBOb25lKSlcblxuICBsZXQgZ2V0IChlbnYgOiBlbnYpICgobmFtZSwgaWR4KSA6IHZuYW1lKSA9XG4gICAgbGV0IGJkcyA9IE1hcC5maW5kX2RlZmF1bHQgW10gbmFtZSBlbnYuZW52X3ZhciBpblxuICAgIExpc3QubnRoX29wdCBiZHMgaWR4XG4gIFxuICBsZXQgbW9kaWZ5IChlbnYgOiBlbnYpICgoeCwgaSksIGIgOiB2bmFtZSAqIGJ2YXIpID1cbiAgICBsZXQgZW52X3ZhciA9IE1hcC5tb2RpZnkgeCAoTGlzdC5tb2RpZnlfYXQgaSAoZnVuIF8gLT4gYikpIGVudi5lbnZfdmFyIGluXG4gICAgeyBlbnYgd2l0aCBlbnZfdmFyIH1cbiAgXG4gIGxldCByZW1vdmUgKGVudiA6IGVudikgKCh4LCBpKSA6IHZuYW1lKSA9XG4gICAgbGV0IGVudl92YXIgPSBNYXAubW9kaWZ5IHggKExpc3QucmVtb3ZlX2F0IGkpIGVudi5lbnZfdmFyIGluXG4gICAgeyBlbnYgd2l0aCBlbnZfdmFyIH1cblxuICBsZXQgZXhpc3RzIChlbnYgOiBlbnYpICh4IDogdm5hbWUpID1cbiAgICBPcHRpb24uaXNfc29tZSAoZ2V0IGVudiB4KVxuICBcbiAgbGV0IGdldGlkIGVudiB4ID1cbiAgICBCaU1hcC5maW5kX29wdCB4IGVudi5lbnZfaGFuZGxlc1xuXG4gIGxldCBieWlkIGVudiBpZCA9XG4gICAgbGV0IG9wZW4gTW9uYWQuT3B0aW9uIGluXG4gICAgKGVudi5lbnZfaGFuZGxlcyB8PiBCaU1hcC5pbnZlcnNlIHw+IEJpTWFwLmZpbmRfb3B0IGlkKSA+Pj0gZnVuIHggLT5cbiAgICBnZXQgZW52IHggPj49IGZ1biBib2R5IC0+XG4gICAgcmV0dXJuICh4LCBib2R5KVxuICBcbiAgbGV0IG1hcCAoZW52IDogZW52KSAoZiA6IGV4cHIgb3B0aW9uIC0+IGV4cHIgb3B0aW9uKSA9XG4gICAgeyBlbnYgd2l0aCBlbnZfdmFyID0gTWFwLm1hcCAoTGlzdC5tYXAgKHNuZF9tYXAgZikpIGVudi5lbnZfdmFyIH1cblxuICBsZXQgYWxsIChlbnYgOiBlbnYpID1cbiAgICBlbnYuZW52X3ZhclxuICBcbiAgbGV0IHRvX3N0cmluZyBlbnYgKHggOiBuYW1lKSA9XG4gICAgbGV0IGJzID0gTWFwLmZpbmQgeCBlbnYuZW52X3ZhciBpblxuICAgIFByaW50Zi5zcHJpbnRmIFwiJXMgOiAlc1wiIHhcbiAgICAgIChMaXN0LnRvX3N0cmluZyAoZnVuICh0eSwgYm9keSkgLT5cbiAgICAgICAgbWF0Y2ggYm9keSB3aXRoXG4gICAgICAgIHwgU29tZSBiIC0+IFByaW50Zi5zcHJpbnRmIFwiJXMgOj0gJXNcIiAoTm90YXRpb24udF90b3N0cmluZyB0eSkgKE5vdGF0aW9uLmVfdG9zdHJpbmcgYilcbiAgICAgICAgfCBOb25lIC0+IFByaW50Zi5zcHJpbnRmIFwiJXNcIiAoTm90YXRpb24udF90b3N0cmluZyB0eSkpIGJzKVxuXG4gIGxldCB0b19saXN0IGVudiA9XG4gICAgbGV0IG9wZW4gTW9uYWQuTGlzdCBpblxuICAgIE1hcC5iaW5kaW5ncyBlbnYuZW52X3ZhciA+Pj0gZnVuICh4LCBicykgLT5cbiAgICBMaXN0Lm1hcGkgKGZ1biBpIGIgLT4gKE9wdGlvbi5nZXQgKGdldGlkIGVudiAoeCwgaSkpLCAoeCwgaSksIGIpKSBic1xuZW5kXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5tb2R1bGUgRVZhcnMgOiBzaWdcbiAgdmFsIGZyZXNoICA6ID9iYXNlbmFtZTpuYW1lIC0+IHVuaXQgLT4gbmFtZVxuICB2YWwgcHVzaCAgIDogZW52IC0+IG5hbWUgb3B0aW9uICogdHlwZV8gLT4gbmFtZSAqIGVudlxuICB2YWwgZXhpc3RzIDogZW52IC0+IHZuYW1lIC0+IGJvb2xcbiAgdmFsIGdldCAgICA6IGVudiAtPiB2bmFtZSAtPiB0eXBlXyBvcHRpb25cbiAgdmFsIHJlbW92ZSA6IGVudiAtPiB2bmFtZSAtPiBlbnZcbiAgdmFsIGFsbCAgICA6IGVudiAtPiAobmFtZSwgdHlwZV8gbGlzdCkgTWFwLnRcbmVuZCA9IHN0cnVjdFxuXG4gICgqKiBbZnJlc2hfZXZhcl9uYW1lIH5iYXNlbmFtZSAoKV0gZ2VuZXJhdGVzIGEgZnJlc2ggbmFtZSBmb3IgYW5cbiAgICAgIGV4aXN0ZW50aWFsIHZhcmlhYmxlLCBiYXNlZCBvbiBhbiBvcHRpb25hbCBbYmFzZW5hbWVdLlxuXG4gICAgICBXZSBjaG9vc2UgYnkgY29udmVudGlvbiB0byBuYW1lIGV4aXN0ZW50aWFsIHZhcmlhYmxlcyB3aXRoIGEgbGVhZGluZyAnPycuXG4gICAgICBUaGlzIGVuc3VyZXMgZnJlc2huZXNzIGJ5IGF2b2lkaW5nIGNsYXNoZXMgd2l0aCB2YXJpYWJsZXMgbmFtZXMgaW5wdXRcbiAgICAgIGJ5IHRoZSB1c2VyLCBieSB0aGUgZGVmaW5pdGlvbiBvZiBpZGVudGlmaWVycyBpbiB0aGUgbGV4ZXIuIFRoaXMgYWxzb1xuICAgICAgbWVhbnMgdGhhdCBldmVyeSBuZXcgZXhpc3RlbnRpYWwgdmFyaWFibGUgbXVzdCBiZSBpbnN0YW5jaWF0ZWQgdGhyb3VnaFxuICAgICAgdGhpcyBmdW5jdGlvbi4gKilcblxuICBsZXQgZXZhcl9uYW1lX2NvdW50ZXIgPSByZWYgKC0xKVxuXG4gIGxldCBmcmVzaCA/KGJhc2VuYW1lID0gXCJcIikgKCkgPVxuICAgIGluY3IgZXZhcl9uYW1lX2NvdW50ZXI7XG4gICAgXCI/XCIgXiBiYXNlbmFtZSBeIHN0cmluZ19vZl9pbnQgIWV2YXJfbmFtZV9jb3VudGVyXG5cbiAgbGV0IHB1c2ggKGVudiA6IGVudikgKChuYW1lLCB0eSkgOiBuYW1lIG9wdGlvbiAqIHR5cGVfKSA9XG4gICAgbGV0IG5hbWUgPSBmcmVzaCA/YmFzZW5hbWU6bmFtZSAoKSBpblxuICAgIG5hbWUsIHsgZW52IHdpdGggZW52X2V2YXIgPSBNYXAubW9kaWZ5X29wdCBuYW1lIChmdW4gYmRzIC0+XG4gICAgICAgICAgICAgIFNvbWUgKHR5IDo6IE9wdGlvbi5kZWZhdWx0IFtdIGJkcykpXG4gICAgICAgICAgICAgIGVudi5lbnZfZXZhcjsgfVxuXG4gIGxldCBnZXQgKGVudiA6IGVudikgKChuYW1lLCBpZHgpIDogdm5hbWUpID1cbiAgICBsZXQgYmRzID0gTWFwLmZpbmRfZGVmYXVsdCBbXSBuYW1lIGVudi5lbnZfZXZhciBpblxuICAgIExpc3QubnRoX29wdCBiZHMgaWR4XG5cbiAgbGV0IGV4aXN0cyAoZW52IDogZW52KSAoeCA6IHZuYW1lKSA9XG4gICAgT3B0aW9uLmlzX3NvbWUgKGdldCBlbnYgeClcblxuICBsZXQgcmVtb3ZlIChlbnYgOiBlbnYpICgobmFtZSwgaWR4KSA6IHZuYW1lKSA9XG4gICAgbGV0IGJkcyA9IE1hcC5maW5kX2RlZmF1bHQgW10gbmFtZSBlbnYuZW52X2V2YXIgaW5cbiAgICBsZXQgYmRzID0gTGlzdC5yZW1vdmVfYXQgaWR4IGJkcyBpblxuICAgIHsgZW52IHdpdGggZW52X2V2YXIgPSBNYXAuYWRkIG5hbWUgYmRzIGVudi5lbnZfZXZhciB9XG5cbiAgbGV0IGFsbCAoZW52IDogZW52KSA9XG4gICAgZW52LmVudl9ldmFyXG5lbmRcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbmV4Y2VwdGlvbiBSZWNoZWNrRmFpbHVyZVxuZXhjZXB0aW9uIFR5cGluZ0Vycm9yXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5tb2R1bGUgVk5hbWUgOiBzaWdcbiAgdHlwZSBiZHNcblxuICBtb2R1bGUgTWFwIDogc2lnXG4gICAgdmFsIGVtcHR5IDogYmRzXG4gICAgdmFsIHB1c2ggIDogYmRzIC0+IG5hbWUgLT4gbmFtZSAtPiBiZHNcbiAgZW5kXG5cbiAgdmFsIGxpbmRleCA6IGJkcyAtPiBuYW1lIC0+IGludFxuICB2YWwgcmluZGV4IDogYmRzIC0+IG5hbWUgLT4gaW50XG5cbiAgdmFsIGxmaW5kIDogYmRzIC0+IHZuYW1lIC0+IG5hbWVcbiAgdmFsIHJmaW5kIDogYmRzIC0+IHZuYW1lIC0+IG5hbWVcblxuICB2YWwgZXF1YWwgOiBiZHMgLT4gdm5hbWUgLT4gdm5hbWUgLT4gYm9vbFxuZW5kID0gc3RydWN0XG4gIHR5cGUgYmRzID0gKG5hbWUgKiBuYW1lKSBsaXN0XG5cbiAgbW9kdWxlIE1hcCA9IHN0cnVjdFxuICAgIGxldCBlbXB0eSA6IGJkcyA9XG4gICAgICBbXVxuXG4gICAgbGV0IHB1c2ggKGJkcyA6IGJkcykgKHggOiBuYW1lKSAoeSA6IG5hbWUpID1cbiAgICAgICh4LCB5KSA6OiBiZHNcbiAgZW5kXG4gIFxuICBsZXQgbGluZGV4IChiZHMgOiBiZHMpICh4IDogbmFtZSkgOiBpbnQgPVxuICAgIGxldCByZWMgYXV4IGkgPSBmdW5jdGlvbiBcbiAgICAgIHwgW10gLT4gaVxuICAgICAgfCAoeSwgXykgOjogYmRzIC0+IGF1eCAoaSArIGlmIHggPSB5IHRoZW4gMSBlbHNlIDApIGJkc1xuICAgIGluIGF1eCAwIGJkc1xuXG4gIGxldCByaW5kZXggKGJkcyA6IGJkcykgKHggOiBuYW1lKSA6IGludCA9XG4gICAgbGV0IHJlYyBhdXggaSA9IGZ1bmN0aW9uIFxuICAgICAgfCBbXSAtPiBpXG4gICAgICB8IChfLCB5KSA6OiBiZHMgLT4gYXV4IChpICsgaWYgeCA9IHkgdGhlbiAxIGVsc2UgMCkgYmRzXG4gICAgaW4gYXV4IDAgYmRzXG5cbiAgbGV0IGxmaW5kIChiZHMgOiBiZHMpICgoeCwgaSkgOiB2bmFtZSkgPVxuICAgIGxldCByZWMgYXV4IGogPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgKHksIHopIDo6IF8gICB3aGVuIHggPSB5ICYmIGogPSAwIC0+IHpcbiAgICAgIHwgKHksIF8pIDo6IGJkcyB3aGVuIHggPSB5ICYmIGogPiAwIC0+IGF1eCAoai0xKSBiZHNcbiAgICAgIHwgXyA6OiBiZHMgLT4gYXV4IGogYmRzXG4gICAgaW4gYXV4IGkgYmRzXG4gIFxuICBsZXQgcmZpbmQgKGJkcyA6IGJkcykgKCh4LCBpKSA6IHZuYW1lKSA9XG4gICAgbGV0IHJlYyBhdXggaiA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCAoeSwgeikgOjogXyAgIHdoZW4geCA9IHogJiYgaiA9IDAgLT4geVxuICAgICAgfCAoXywgeikgOjogYmRzIHdoZW4geCA9IHogJiYgaiA+IDAgLT4gYXV4IChqLTEpIGJkc1xuICAgICAgfCBfIDo6IGJkcyAtPiBhdXggaiBiZHNcbiAgICBpbiBhdXggaSBiZHNcblxuICBsZXQgZXF1YWwgKGJkcyA6IGJkcykgKChuLCBpKSA6IHZuYW1lKSAoKG0sIGopIDogdm5hbWUpID1cbiAgICAobiA9IG0gJiYgaSAtIGxpbmRleCBiZHMgbiA9IGogLSByaW5kZXggYmRzIG0pIHx8XG4gICAgKGkgPSBqICYmXG4gICAgICB0cnkgbGZpbmQgYmRzIChuLCBpKSA9IG1cbiAgICAgIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlKVxuZW5kXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5tb2R1bGUgRm9ybSA6IHNpZ1xuICB2YWwgZl9mYWxzZSA6IGZvcm1cbiAgdmFsIGZfdHJ1ZSAgOiBmb3JtXG4gIHZhbCBmX2FuZCAgIDogZm9ybSAtPiBmb3JtIC0+IGZvcm1cbiAgdmFsIGZfb3IgICAgOiBmb3JtIC0+IGZvcm0gLT4gZm9ybVxuICB2YWwgZl9pbXAgICA6IGZvcm0gLT4gZm9ybSAtPiBmb3JtXG4gIHZhbCBmX2VxdWl2IDogZm9ybSAtPiBmb3JtIC0+IGZvcm1cbiAgdmFsIGZfbm90ICAgOiBmb3JtIC0+IGZvcm1cblxuICB2YWwgZl9hbmRzIDogZm9ybSBsaXN0IC0+IGZvcm1cbiAgdmFsIGZfb3JzICA6IGZvcm0gbGlzdCAtPiBmb3JtXG4gIHZhbCBmX2ltcHMgOiBmb3JtIGxpc3QgLT4gZm9ybSAtPiBmb3JtXG5cbiAgdmFsIGZsYXR0ZW5fZGlzanVuY3Rpb25zIDogZm9ybSAtPiBmb3JtIGxpc3RcbiAgdmFsIGZsYXR0ZW5fY29uanVuY3Rpb25zIDogZm9ybSAtPiBmb3JtIGxpc3RcblxuICB2YWwgdF91bmxvYyAgOiBwdHlwZSAtPiB0eXBlX1xuICB2YWwgZV91bmxvYyAgOiBwZXhwciAtPiBleHByXG4gIHZhbCBmX3VubG9jICA6IHBmb3JtIC0+IGZvcm1cblxuICB2YWwgcGFyaXR5ICAgOiBsb2djb24gLT4gaW50XG4gIHZhbCB0Y2hlY2sgICA6IGVudiAtPiBwdHlwZSAtPiB0eXBlX1xuICB2YWwgdHJlY2hlY2sgOiBlbnYgLT4gdHlwZV8gLT4gdW5pdFxuICB2YWwgZWluZmVyICAgOiBlbnYgLT4gZXhwciAtPiB0eXBlX1xuICB2YWwgZWNoZWNrICAgOiBlbnYgLT4gcGV4cHIgLT4gZXhwciAqIHR5cGVfXG4gIHZhbCBlcmVjaGVjayA6IGVudiAtPiB0eXBlXyAtPiBleHByIC0+IHVuaXRcbiAgdmFsIGNoZWNrICAgIDogZW52IC0+IHBmb3JtIC0+IGZvcm1cbiAgdmFsIHJlY2hlY2sgIDogZW52IC0+IGZvcm0gLT4gdW5pdFxuXG4gIHZhbCB0X2VxdWFsIDogP2JkczpWTmFtZS5iZHMgLT4gZW52IC0+IHR5cGVfIC0+IHR5cGVfIC0+IGJvb2xcbiAgdmFsIGVfZXF1YWwgOiA/YmRzOlZOYW1lLmJkcyAtPiBlbnYgLT4gZXhwciAgLT4gZXhwciAgLT4gYm9vbFxuICB2YWwgZl9lcXVhbCA6ID9iZHM6Vk5hbWUuYmRzIC0+IGVudiAtPiBmb3JtICAtPiBmb3JtICAtPiBib29sXG4gIHZhbCBlcXVhbCAgIDogP2JkczpWTmFtZS5iZHMgLT4gZW52IC0+IHRlcm0gLT4gdGVybSAtPiBib29sXG5cbiAgdmFsIGZyZWVfdmFycyAgIDogZm9ybSAtPiBuYW1lIGxpc3RcbiAgdmFsIGVfc2hpZnQgICAgIDogP2luY3I6aW50IC0+IHZuYW1lIC0+IGV4cHIgLT4gZXhwclxuICB2YWwgZl9zaGlmdCAgICAgOiA/aW5jcjppbnQgLT4gdm5hbWUgLT4gZm9ybSAtPiBmb3JtXG4gIHZhbCBzaGlmdCAgICAgICA6ID9pbmNyOmludCAtPiB2bmFtZSAtPiB0ZXJtIC0+IHRlcm1cbiAgdmFsIHNoaWZ0X3VuZGVyIDogdGVybSAtPiB0ZXJtIC0+IHRlcm1cbiAgXG4gIHZhbCBkaXJlY3Rfc3ViZXhwcnMgOiBleHByIC0+IGV4cHIgbGlzdFxuICB2YWwgZGlyZWN0X3N1YmZvcm1zIDogZm9ybSAtPiBmb3JtIGxpc3RcbiAgdmFsIGRpcmVjdF9zdWJ0ZXJtcyA6IHRlcm0gLT4gdGVybSBsaXN0XG4gIFxuICB2YWwgbW9kaWZ5X2RpcmVjdF9zdWJleHBycyA6IGV4cHIgLT4gZXhwciBsaXN0IC0+IGV4cHJcbiAgdmFsIG1vZGlmeV9kaXJlY3Rfc3ViZm9ybXMgOiBmb3JtIC0+IGZvcm0gbGlzdCAtPiBmb3JtXG4gIHZhbCBtb2RpZnlfZGlyZWN0X3N1YnRlcm1zIDogdGVybSAtPiB0ZXJtIGxpc3QgLT4gdGVybVxuICBcbiAgdmFsIHJld3JpdGUgOiA/YmRzOlZOYW1lLmJkcyAtPiBlbnYgLT4gdGVybSAtPiB0ZXJtIC0+IHRlcm0gLT4gdGVybVxuXG4gIHZhbCBlY19maWxsICAgOiBleHByIC0+IGVjdHggLT4gZXhwclxuICB2YWwgZWNfY29uY2F0IDogZWN0eCAtPiBlY3R4IC0+IGVjdHhcbiAgdmFsIGVjX3JldiAgICA6IGVjdHggLT4gZWN0eFxuXG4gIHZhbCBmY19pc19ib3VuZCA6IHZuYW1lIC0+IGZjdHggLT4gYm9vbFxuICB2YWwgZmNfZXhpdCAgICAgOiB2bmFtZSAtPiBmY3R4IC0+IHZuYW1lXG4gIHZhbCBmY19maWxsICAgICA6IGZvcm0gLT4gZmN0eCAtPiBmb3JtXG4gIHZhbCBmY19jb25jYXQgICA6IGZjdHggLT4gZmN0eCAtPiBmY3R4XG4gIHZhbCBmY19yZXYgICAgICA6IGZjdHggLT4gZmN0eFxuICBcbiAgZXhjZXB0aW9uIEludmFsaWRDb250ZXh0RmlsbCBvZiB0ZXJtICogY3R4XG5cbiAgdmFsIGNfaXNfYm91bmQgOiB2bmFtZSAtPiBjdHggLT4gYm9vbFxuICB2YWwgY19leGl0ICAgICA6IHZuYW1lIC0+IGN0eCAtPiB2bmFtZVxuICB2YWwgY19maWxsICAgICA6IHRlcm0gLT4gY3R4IC0+IHRlcm1cbiAgdmFsIGNfcmV2ICAgICAgOiBjdHggLT4gY3R4XG4gIHZhbCBjX3B1c2ggICAgIDogaWN0eCAtPiBjdHggLT4gY3R4XG5cbiAgdmFsIGZyZXNoX3ZhciA6ID9iYXNlbmFtZTpuYW1lIC0+IG5hbWUgbGlzdCAtPiBuYW1lXG5cbiAgbW9kdWxlIFN1YnN0IDogc2lnXG4gICAgdHlwZSBzdWJzdFxuXG4gICAgZXhjZXB0aW9uIFVuYm91bmRWYXJpYWJsZSBvZiB2bmFtZSAqIHN1YnN0XG5cbiAgICB2YWwgZW1wdHkgICAgICAgOiBzdWJzdFxuICAgIHZhbCBhc2xpc3QgICAgICA6IHN1YnN0IC0+IChuYW1lICogc2l0ZW0pIGxpc3RcbiAgICB2YWwgb2ZsaXN0ICAgICAgOiAobmFtZSAqIHNpdGVtKSBsaXN0IC0+IHN1YnN0XG5cbiAgICB2YWwgZm9sZCAgICAgICAgOiAoJ2EgLT4gbmFtZSAqIHNpdGVtIC0+ICdhKSAtPiAnYSAtPiBzdWJzdCAtPiAnYVxuXG4gICAgdmFsIGFkZCAgICAgICAgIDogdm5hbWUgLT4gZXhwciAtPiBzdWJzdCAtPiBzdWJzdFxuICAgIHZhbCBwdXNoICAgICAgICA6IG5hbWUgLT4gc2l0ZW0gLT4gc3Vic3QgLT4gc3Vic3RcbiAgICB2YWwgZmV0Y2ggICAgICAgOiB2bmFtZSAtPiBzdWJzdCAtPiBleHByXG4gICAgdmFsIGdldF90YWcgICAgIDogdm5hbWUgLT4gc3Vic3QgLT4gc2l0ZW0gb3B0aW9uXG5cbiAgICB2YWwgaXNfY29tcGxldGUgOiBzdWJzdCAtPiBib29sXG4gICAgXG4gICAgdmFsIGVfYXBwbHkxICAgIDogdm5hbWUgLT4gZXhwciAtPiBleHByIC0+IGV4cHJcbiAgICB2YWwgZV9pdGVyICAgICAgOiBzdWJzdCAtPiBpbnQgLT4gZXhwciAtPiBleHByXG4gICAgdmFsIGVfYXBwbHkgICAgIDogc3Vic3QgLT4gZXhwciAtPiBleHByXG4gICAgdmFsIGZfYXBwbHkxICAgIDogdm5hbWUgLT4gZXhwciAtPiBmb3JtIC0+IGZvcm1cbiAgICB2YWwgZl9pdGVyICAgICAgOiBzdWJzdCAtPiBpbnQgLT4gZm9ybSAtPiBmb3JtXG4gICAgdmFsIGZfYXBwbHkgICAgIDogc3Vic3QgLT4gZm9ybSAtPiBmb3JtXG5cbiAgICB2YWwgY2xvc2UgICAgICAgOiBzdWJzdCAtPiBzdWJzdFxuICAgIFxuICAgIHZhbCB0b19zdHJpbmcgICA6IHN1YnN0IC0+IHN0cmluZ1xuICBlbmRcblxuICB2YWwgZV91bmlmeSA6IGVudiAtPiBMRW52LmxlbnYgLT4gU3Vic3Quc3Vic3QgLT4gZXhwciBlcW5zIC0+IFN1YnN0LnN1YnN0IG9wdGlvblxuICB2YWwgZl91bmlmeSA6IGVudiAtPiBMRW52LmxlbnYgLT4gU3Vic3Quc3Vic3QgLT4gZm9ybSBlcW5zIC0+IFN1YnN0LnN1YnN0IG9wdGlvblxuZW5kID0gc3RydWN0XG4gIGxldCBmX2FuZCAgID0gZnVuIGYxIGYyIC0+IEZDb25uIChgQW5kICAsIFtmMTsgZjJdKVxuICBsZXQgZl9vciAgICA9IGZ1biBmMSBmMiAtPiBGQ29ubiAoYE9yICAgLCBbZjE7IGYyXSlcbiAgbGV0IGZfaW1wICAgPSBmdW4gZjEgZjIgLT4gRkNvbm4gKGBJbXAgICwgW2YxOyBmMl0pXG4gIGxldCBmX2VxdWl2ID0gZnVuIGYxIGYyIC0+IEZDb25uIChgRXF1aXYsIFtmMTsgZjJdKVxuICBsZXQgZl9ub3QgICA9IGZ1biBmICAgICAtPiBGQ29ubiAoYE5vdCAgLCBbZl0pXG5cdFxuICBsZXQgZl9mYWxzZSA6IGZvcm0gPSBGRmFsc2VcbiAgbGV0IGZfdHJ1ZSAgOiBmb3JtID0gRlRydWVcblxuICBsZXQgZl9hbmRzIChmcyA6IGZvcm0gbGlzdCkgOiBmb3JtID1cbiAgICBtYXRjaCBmcyB3aXRoXG4gICAgfCBbXSAgICAgIC0+IGZfdHJ1ZVxuICAgIHwgW2ZdICAgICAtPiBmXG4gICAgfCBmIDo6IGZzIC0+IExpc3QuZm9sZF9sZWZ0IGZfYW5kIGYgZnNcblxuICBsZXQgZl9vcnMgKGZzIDogZm9ybSBsaXN0KSA6IGZvcm0gPVxuICAgIG1hdGNoIGZzIHdpdGhcbiAgICB8IFtdICAgICAgLT4gZl9mYWxzZVxuICAgIHwgW2ZdICAgICAtPiBmXG4gICAgfCBmIDo6IGZzIC0+IExpc3QuZm9sZF9sZWZ0IGZfb3IgZiBmc1xuXG4gIGxldCBmX2ltcHMgKGZzIDogZm9ybSBsaXN0KSAoZiA6IGZvcm0pID1cbiAgICBMaXN0LmZvbGRfcmlnaHQgZl9pbXAgZnMgZlxuXG4gIGxldCBmbGF0dGVuX2Rpc2p1bmN0aW9ucyA9XG4gICAgbGV0IHJlYyBkb2l0IGFjYyBmID1cbiAgICAgIG1hdGNoIGYgd2l0aFxuICAgICAgfCBGQ29ubiAoYE9yLCBbZjE7IGYyXSkgLT4gZG9pdCAoZjIgOjogYWNjKSBmMVxuICAgICAgfCBfIC0+IGYgOjogYWNjXG4gICAgaW4gZnVuIGYgLT4gZG9pdCBbXSBmXG5cbiAgbGV0IGZsYXR0ZW5fY29uanVuY3Rpb25zID1cbiAgICBsZXQgcmVjIGRvaXQgYWNjIGYgPVxuICAgICAgbWF0Y2ggZiB3aXRoXG4gICAgICB8IEZDb25uIChgQW5kLCBbZjE7IGYyXSkgLT4gZG9pdCAoZjIgOjogYWNjKSBmMVxuICAgICAgfCBfIC0+IGYgOjogYWNjXG4gICAgaW4gZnVuIGYgLT4gZG9pdCBbXSBmXG5cbiAgbGV0IHBhcml0eSAobGcgOiBsb2djb24pID1cbiAgICBtYXRjaCBsZyB3aXRoXG4gICAgfCBgQW5kIC0+IDIgfCBgT3IgLT4gMiB8IGBJbXAgLT4gMiB8IGBFcXVpdiAtPiAyIHwgYE5vdCAtPiAxXG5cblxuICBsZXQgdF9lcXVhbCA9XG4gICAgbGV0IHJlYyBlcV9hbGlhcyAoYmRzIDogVk5hbWUuYmRzKSAoZW52IDogZW52KVxuICAgICAgKGEgOiB2bmFtZSkgKHR5IDogdHlwZV8pIDogYm9vbCA9XG4gICAgICBcbiAgICAgIGxldCB0Z3RfYSA9IFRWYXJzLmdldCBlbnYgYSBpblxuICAgICAgbGV0IGIsIHRndF9iID1cbiAgICAgICAgbWF0Y2ggdHkgd2l0aFxuICAgICAgICB8IFRWYXIgYiAtPiBTb21lIGIsIFRWYXJzLmdldCBlbnYgYlxuICAgICAgICB8IF8gLT4gTm9uZSwgTm9uZVxuICAgICAgaW5cbiAgICAgIG1hdGNoIGIsIHBhaXJfbWFwIE1vbmFkLk9wdGlvbi5jb25jYXQgKHRndF9hLCB0Z3RfYikgd2l0aFxuICAgICAgKCogQmFzZSBjYXNlICopXG4gICAgICB8IE5vbmUsIChOb25lLCBfKSAtPiBmYWxzZSAoKiBiIGlzIG5vdCBhIHZhciwgYW5kIGEgaXMgbm90IGFuIGFsaWFzICopXG4gICAgICB8IFNvbWUgYiwgKE5vbmUsIE5vbmUpIC0+IFZOYW1lLmVxdWFsIGJkcyBhIGIgKCogYiBpcyBhIHZhciwgYW5kIG5laXRoZXIgYSBub3IgYiBhcmUgYWxpYXNlcyAqKVxuICAgICAgKCogUmVjdXJzaXZlIGNhc2UgKGVpdGhlciBhIG9yIGIgaXMgYW4gYWxpYXMpICopXG4gICAgICB8IF8sIChTb21lIHR5JywgXykgLT4gZXEgYmRzIGVudiB0eSB0eSdcbiAgICAgIHwgXywgKF8sIFNvbWUgdHknKSAtPiBlcV9hbGlhcyBiZHMgZW52IGEgdHknXG5cbiAgICBhbmQgZXEgYmRzIGVudiB0eTEgdHkyID1cbiAgICAgIG1hdGNoIHR5MSwgdHkyIHdpdGhcbiAgICAgIHwgVFZhciBhLCB0eSB8IHR5LCBUVmFyIGEgLT5cbiAgICAgICAgICBlcV9hbGlhcyBiZHMgZW52IGEgdHlcblxuICAgICAgfCBUVW5pdCwgVFVuaXQgLT5cbiAgICAgICAgICB0cnVlXG4gICAgICAgIFxuICAgICAgfCBUUHJvZCAodHlhMSwgdHliMSksIFRQcm9kICh0eWEyLCB0eWIyKVxuICAgICAgfCBUT3IgICAodHlhMSwgdHliMSksIFRPciAgICh0eWEyLCB0eWIyKSAtPlxuICAgICAgICAgICAgIGVxIGJkcyBlbnYgdHlhMSB0eWEyXG4gICAgICAgICAgJiYgZXEgYmRzIGVudiB0eWIxIHR5YjJcblxuICAgICAgfCBUUmVjIChhMSwgdHkxKSwgVFJlYyAoYTIsIHR5MikgLT5cbiAgICAgICAgICBlcSAoVk5hbWUuTWFwLnB1c2ggYmRzIGExIGEyKSBlbnYgdHkxIHR5MlxuXG4gICAgICB8IF8sIF8gLT5cbiAgICAgICAgICBmYWxzZVxuXG4gICAgaW4gZnVuID8oYmRzID0gVk5hbWUuTWFwLmVtcHR5KSBlbnYgdHkxIHR5MiAtPiBlcSBiZHMgZW52IHR5MSB0eTJcblxuICBsZXQgZV9lcXVhbCA9XG4gICAgbGV0IHJlYyBhdXggYmRzIGVudiBlMSBlMiA9XG4gICAgICBtYXRjaCBlMSwgZTIgd2l0aFxuXHR8IEVWYXIgeDEsIEVWYXIgeDIgd2hlbiBWTmFtZS5lcXVhbCBiZHMgeDEgeDIgLT4gdHJ1ZVxuXHR8IEVWYXIgeDEsIHQgfCB0LCBFVmFyIHgxIC0+XG5cdFx0XHQgKG1hdGNoIFZhcnMuZ2V0IGVudiB4MSB3aXRoXG5cdFx0XHQgICB8IFNvbWUgKF8sIFNvbWUgdSkgLT4gYXV4IGJkcyBlbnYgdCB1XG5cdFx0XHQgICB8IF8gLT4gZmFsc2UpXG4gICAgICB8IEVGdW4gKGYxLCBlczEpLCBFRnVuIChmMiwgZXMyKSBcbiAgICAgICAgd2hlbiBMaXN0Lmxlbmd0aCBlczEgPSBMaXN0Lmxlbmd0aCBlczIgLT5cbiAgICAgICAgICAoZjEgPSBmMikgJiYgTGlzdC5mb3JfYWxsMiAoYXV4IGJkcyBlbnYpIGVzMSBlczJcbiAgICAgIHwgXywgXyAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgaW5cbiAgICBmdW4gPyhiZHMgPSBWTmFtZS5NYXAuZW1wdHkpIGVudiBlMSBlMiAtPiBhdXggYmRzIGVudiBlMSBlMlxuXG4gIGxldCBmX2VxdWFsID1cbiAgICBsZXQgcmVjIGF1eCBiZHMgZW52IGYxIGYyID1cbiAgICAgIG1hdGNoIGYxLCBmMiB3aXRoXG4gICAgICB8IEZUcnVlICwgRlRydWVcbiAgICAgIHwgRkZhbHNlLCBGRmFsc2UgLT4gdHJ1ZVxuXG4gICAgICB8IEZQcmVkIChwMSwgZXMxKSwgRlByZWQgKHAyLCBlczIpXG4gICAgICAgIHdoZW4gTGlzdC5sZW5ndGggZXMxID0gTGlzdC5sZW5ndGggZXMyXG4gICAgICAgIC0+IChwMSA9IHAyKSAgJiYgTGlzdC5mb3JfYWxsMiAoZV9lcXVhbCB+YmRzIGVudikgZXMxIGVzMiBcblxuICAgICAgfCBGQ29ubiAoYzEsIGZzMSksIEZDb25uIChjMiwgZnMyKVxuICAgICAgICB3aGVuIExpc3QubGVuZ3RoIGZzMSA9IExpc3QubGVuZ3RoIGZzMiBcbiAgICAgICAgLT4gKGMxID0gYzIpICYmIExpc3QuZm9yX2FsbDIgKGF1eCBiZHMgZW52KSBmczEgZnMyXG5cbiAgICAgIHwgRkJpbmQgKGIxLCB4MSwgdHkxLCBmMSksIEZCaW5kIChiMiwgeDIsIHR5MiwgZjIpXG4gICAgICAgIHdoZW4gYjEgPSBiMiAtPlxuICAgICAgICAgICAgdF9lcXVhbCBlbnYgdHkxIHR5MlxuICAgICAgICAgJiYgYXV4IChWTmFtZS5NYXAucHVzaCBiZHMgeDEgeDIpIGVudiBmMSBmMlxuXG4gICAgICB8IF8sIF8gLT5cbiAgICAgICAgICBmYWxzZVxuXG4gICAgaW4gZnVuID8oYmRzID0gVk5hbWUuTWFwLmVtcHR5KSBmMSBmMiAtPiBhdXggYmRzIGYxIGYyXG4gICAgXG4gIGxldCBlcXVhbCA/YmRzIChlbnYgOiBlbnYpICh0MSA6IHRlcm0pICh0MiA6IHRlcm0pIDogYm9vbCA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IGBGIGYxLCBgRiBmMiAtPiBmX2VxdWFsID9iZHMgZW52IGYxIGYyXG4gICAgfCBgRSBlMSwgYEUgZTIgLT4gZV9lcXVhbCA/YmRzIGVudiBlMSBlMlxuICAgIHwgXyAtPiBmYWxzZVxuICAgIFxuICBcbiAgbGV0IHJlYyBmcmVlX3ZhcnMgPVxuICAgIGxldCBvcGVuIE1vbmFkLkxpc3QgaW4gZnVuY3Rpb25cbiAgICB8IEZUcnVlIHwgRkZhbHNlIC0+IHplcm9cbiAgICB8IEZQcmVkIChfLCBlcykgLT4gKGVzID4+PSBlX3ZhcnMpIHw+IExpc3QubWFwIG5hbWVfb2Zfdm5hbWVcbiAgICB8IEZDb25uIChfLCBmcykgLT4gZnMgPj49IGZyZWVfdmFyc1xuICAgIHwgRkJpbmQgKF8sIHgsIF8sIGYpIC0+IExpc3QucmVtb3ZlX2FsbCAoZnJlZV92YXJzIGYpIHhcbiAgXG5cbiAgbGV0IHJlYyBlX3NoaWZ0ID8oaW5jciA9IDEpICh4LCBpIDogdm5hbWUpID0gZnVuY3Rpb25cbiAgICB8IEVWYXIgKHksIGopIHdoZW4geCA9IHkgJiYgaiA+PSBpIC0+IEVWYXIgKHksIGogKyBpbmNyKVxuICAgIHwgRVZhciBfIGFzIGUgLT4gZVxuICAgIHwgRUZ1biAoZiwgZXMpIC0+IEVGdW4gKGYsIExpc3QubWFwIChlX3NoaWZ0IH5pbmNyICh4LCBpKSkgZXMpXG4gXG4gICgqIFtmX3NoaWZ0IH5pbmNyICh4LCBpKSBmXSBpbmNyZWFzZXMgYnkgW2luY3JdIHRoZSBpbmRleCBvZiBldmVyeSBvY2N1cnJlbmNlIG9mIFt4XVxuICAgICBpbiBbZl0gdGhhdCBhcHBlYXJzIHVuZGVyIGF0IGxlYXN0IFtpXSBxdWFudGlmaWVycyB0aGF0IGJpbmQgW3hdLiAqKVxuXG4gIGxldCByZWMgZl9zaGlmdCA/KGluY3IgPSAxKSAoeCwgaSA6IHZuYW1lKSA9IGZ1bmN0aW9uXG4gICAgfCBGVHJ1ZSB8IEZGYWxzZSBhcyBmIC0+IGZcdCBcbiAgICB8IEZQcmVkIChwLCBlcykgLT4gRlByZWQgKHAsIExpc3QubWFwIChlX3NoaWZ0IH5pbmNyICh4LCBpKSkgZXMpXG4gICAgfCBGQ29ubiAoYywgZnMpIC0+IEZDb25uIChjLCBMaXN0Lm1hcCAoZl9zaGlmdCB+aW5jciAoeCwgaSkpIGZzKVxuICAgIHwgRkJpbmQgKGIsIHksIHR5LCBmKSAtPiBGQmluZCAoYiwgeSwgdHksIGZfc2hpZnQgfmluY3IgKHgsIGkgKyBpZiB4ID0geSB0aGVuIDEgZWxzZSAwKSBmKVxuICBcbiAgbGV0IHNoaWZ0ID9pbmNyIHggPSBmdW5jdGlvblxuICAgIHwgYEUgZSAtPiBgRSAoZV9zaGlmdCA/aW5jciB4IGUpXG4gICAgfCBgRiBmIC0+IGBGIChmX3NoaWZ0ID9pbmNyIHggZilcbiAgXG4gICgqIFtzaGlmdF91bmRlciB0IHVdIHdpbGwgc2hpZnQgYnkgMSB0aGUgdmFyaWFibGUgeCBpbiBbdV0gaWYgW3RdIHN0YXJ0cyB3aXRoXG4gICAgIGEgYmluZGVyIGZvciB4LiAqKVxuXG4gIGxldCBzaGlmdF91bmRlciB0IHUgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgYEYgRkJpbmQgKF8sIHgsIF8sIF8pIC0+IHNoaWZ0ICh4LCAwKSB1XG4gICAgfCBfIC0+IHVcblxuXG4gIGxldCBkaXJlY3Rfc3ViZm9ybXMgPSBmdW5jdGlvblxuICAgIHwgRlRydWUgfCBGRmFsc2UgfCBGUHJlZCBfIC0+IFtdXG4gICAgfCBGQ29ubiAoXywgZnMpIC0+IGZzXG4gICAgfCBGQmluZCAoXywgXywgXywgZikgLT4gW2ZdXG4gIFxuICBsZXQgZGlyZWN0X3N1YmV4cHJzID0gZnVuY3Rpb25cbiAgICB8IEVWYXIgXyAtPiBbXVxuICAgIHwgRUZ1biAoXywgZXMpIC0+IGVzXG4gICAgXG4gIGxldCBkaXJlY3Rfc3VidGVybXMgOiB0ZXJtIC0+IHRlcm0gbGlzdCA9IGZ1bmN0aW9uXG4gICAgfCBgRiBGUHJlZCAoXywgZXMpIC0+IExpc3QubWFwIHRlcm1fb2ZfZXhwciBlc1xuICAgIHwgYEYgZiAtPiBMaXN0Lm1hcCB0ZXJtX29mX2Zvcm0gKGRpcmVjdF9zdWJmb3JtcyBmKVxuICAgIHwgYEUgZSAtPiBMaXN0Lm1hcCB0ZXJtX29mX2V4cHIgKGRpcmVjdF9zdWJleHBycyBlKVxuICAgIFxuICBcbiAgbGV0IG1vZGlmeV9kaXJlY3Rfc3ViZm9ybXMgZiBmcyA9XG4gICAgbWF0Y2ggZiwgZnMgd2l0aFxuICAgIHwgKEZUcnVlIHwgRkZhbHNlIHwgRlByZWQgXyksIF8gLT5cbiAgICAgICAgZlxuXG4gICAgfCBGQ29ubiAoYywgZnMpLCBmcycgd2hlbiBMaXN0Lmxlbmd0aCBmcyA9IExpc3QubGVuZ3RoIGZzJyAtPlxuICAgICAgICBGQ29ubiAoYywgZnMnKVxuXG4gICAgfCBGQmluZCAoYiwgeCwgdHksIF8pLCBbZl0gLT5cbiAgICAgICAgRkJpbmQgKGIsIHgsIHR5LCBmKVxuXG4gICAgfCBfIC0+XG4gICAgICAgIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiV3JvbmcgYXJpdHkgZm9yIG5ldyBzdWJmb3JtdWxhc1wiKVxuICBcbiAgbGV0IG1vZGlmeV9kaXJlY3Rfc3ViZXhwcnMgZSBlcyA9XG4gICAgbWF0Y2ggZSwgZXMgd2l0aFxuICAgIHwgRVZhciBfLCBfIC0+XG4gICAgICAgIGVcblxuICAgIHwgRUZ1biAoZiwgZXMpLCBlcycgd2hlbiBMaXN0Lmxlbmd0aCBlcyA9IExpc3QubGVuZ3RoIGVzJyAtPlxuICAgICAgICBFRnVuIChmLCBlcycpXG4gICAgXG4gICAgfCBfIC0+IFxuICAgICAgICByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIldyb25nIGFyaXR5IGZvciBuZXcgc3ViZXhwcmVzc2lvbnNcIilcbiAgXG4gIGxldCBtb2RpZnlfZGlyZWN0X3N1YnRlcm1zICh0IDogdGVybSkgKHRzIDogdGVybSBsaXN0KSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBgRiBGUHJlZCAocCwgZXMpIHdoZW4gTGlzdC5sZW5ndGggZXMgPSBMaXN0Lmxlbmd0aCB0cyAtPlxuICAgICAgICBgRiAoRlByZWQgKHAsIChMaXN0Lm1hcCBleHByX29mX3Rlcm0gdHMpKSlcbiAgICBcbiAgICB8IGBGIGYgLT5cbiAgICAgICAgdHMgfD4gTGlzdC5tYXAgZm9ybV9vZl90ZXJtIHw+IG1vZGlmeV9kaXJlY3Rfc3ViZm9ybXMgZiB8PiB0ZXJtX29mX2Zvcm0gXG5cbiAgICB8IGBFIGUgLT5cbiAgICAgICAgdHMgfD4gTGlzdC5tYXAgZXhwcl9vZl90ZXJtIHw+IG1vZGlmeV9kaXJlY3Rfc3ViZXhwcnMgZSB8PiB0ZXJtX29mX2V4cHJcbiAgXG5cbiAgbGV0IHJlYyByZXdyaXRlID9iZHMgZW52IHJlZCByZXMgKHQgOiB0ZXJtKSA9XG4gICAgaWYgZXF1YWwgP2JkcyBlbnYgcmVkIHQgdGhlblxuICAgICAgcmVzXG4gICAgZWxzZVxuICAgICAgZGlyZWN0X3N1YnRlcm1zIHQgfD5cbiAgICAgIExpc3QubWFwIChyZXdyaXRlIGVudiAoc2hpZnRfdW5kZXIgdCByZWQpIChzaGlmdF91bmRlciB0IHJlcykpIHw+XG4gICAgICBtb2RpZnlfZGlyZWN0X3N1YnRlcm1zIHRcblxuXG4gIGxldCByZWMgZWNfZmlsbCBlID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGVcbiAgICB8IENGdW4gKG5hbWUsIGFyZ3MsIGkpIDo6IGMgLT5cbiAgICAgICAgbGV0IGxzLCBycyA9IExpc3Quc3BsaXRfYXQgaSBhcmdzIGluXG4gICAgICAgIEVGdW4gKG5hbWUsIGxzIEAgW2VjX2ZpbGwgZSBjXSBAIHJzKVxuICBcbiAgbGV0IGVjX2NvbmNhdCA9IChAKVxuXG4gIGxldCBlY19yZXYgPSBMaXN0LnJldlxuXG5cbiAgbGV0IHJlYyBmY19pc19ib3VuZCAoeCwgaSkgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gZmFsc2VcbiAgICB8IENCaW5kIChfLCB5LCBfKSA6OiBjIC0+XG4gICAgICAgIGlmIHggPSB5IHRoZW5cbiAgICAgICAgICBpZiBpID0gMCB0aGVuIHRydWVcbiAgICAgICAgICBlbHNlIGZjX2lzX2JvdW5kICh4LCBpLTEpIGNcbiAgICAgICAgZWxzZSBmY19pc19ib3VuZCAoeCwgaSkgY1xuICAgIHwgXyA6OiBjIC0+XG4gICAgICAgIGZjX2lzX2JvdW5kICh4LCBpKSBjXG5cbiAgbGV0IGZjX2V4aXQgKHgsIGkpID1cbiAgICBsZXQgcmVjIGF1eCBpID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gaVxuICAgICAgfCBDQmluZCAoXywgeSwgXykgOjogYyB3aGVuIHggPSB5IC0+IGF1eCAoaS0xKSBjXG4gICAgICB8IF8gOjogYyAtPiBhdXggaSBjXG4gICAgaW4gZnVuIGMgLT4gKHgsIGF1eCBpIGMpXG5cbiAgbGV0IHJlYyBmY19maWxsIGYgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gZlxuICAgIHwgQ0Nvbm4gKGNvbm4sIGZzLCBpKSA6OiBjIC0+XG4gICAgICAgIGxldCBscywgcnMgPSBMaXN0LnNwbGl0X2F0IGkgZnMgaW5cbiAgICAgICAgRkNvbm4gKGNvbm4sIGxzIEAgW2ZjX2ZpbGwgZiBjXSBAIHJzKVxuICAgIHwgQ0JpbmQgKGIsIHgsIHR5KSA6OiBjIC0+XG4gICAgICAgIEZCaW5kIChiLCB4LCB0eSwgZmNfZmlsbCBmIGMpXG4gICAgXG4gIGxldCBmY19jb25jYXQgPSAoQClcblxuICBsZXQgZmNfcmV2ID0gTGlzdC5yZXZcbiAgICBcbiAgICBcbiAgbGV0IGNfaXNfYm91bmQgeCA9IGZ1bmN0aW9uXG4gICAgfCBDRm9ybSBjIHwgQ0V4cHJQcmVkIChjLCBfLCBfLCBfLCBfKSAtPiBmY19pc19ib3VuZCB4IGNcbiAgICB8IENFeHByIF8gLT4gZmFsc2VcbiAgICBcbiAgbGV0IGNfZXhpdCB4ID0gZnVuY3Rpb25cbiAgICB8IENGb3JtIGMgfCBDRXhwclByZWQgKGMsIF8sIF8sIF8sIF8pIC0+IGZjX2V4aXQgeCBjXG4gICAgfCBDRXhwciBfIC0+IHhcblxuICBleGNlcHRpb24gSW52YWxpZENvbnRleHRGaWxsIG9mIHRlcm0gKiBjdHhcblxuICBsZXQgY19maWxsIHQgYyA9IG1hdGNoIHQsIGMgd2l0aFxuICAgIHwgYEYgZiwgQ0Zvcm0gYyAtPiBgRiAoZmNfZmlsbCBmIGMpXG4gICAgfCBgRSBlLCBDRXhwciBjIC0+IGBFIChlY19maWxsIGUgYylcbiAgICB8IGBFIGUsIENFeHByUHJlZCAoZmMsIG5hbWUsIGFyZ3MsIGksIGVjKSAtPlxuICAgICAgICBsZXQgbHMsIHJzID0gTGlzdC5zcGxpdF9hdCBpIGFyZ3MgaW5cbiAgICAgICAgYEYgKGZjX2ZpbGwgKEZQcmVkIChuYW1lLCBscyBAIFtlY19maWxsIGUgZWNdIEAgcnMpKSBmYylcbiAgICB8IF8gLT4gcmFpc2UgKEludmFsaWRDb250ZXh0RmlsbCAodCwgYykpXG5cbiAgbGV0IGNfcmV2ID0gZnVuY3Rpb25cbiAgICB8IENGb3JtIGMgLT4gQ0Zvcm0gKGZjX3JldiBjKVxuICAgIHwgQ0V4cHIgYyAtPiBDRXhwciAoZWNfcmV2IGMpXG4gICAgfCBDRXhwclByZWQgKGZjLCBuYW1lLCBhcmdzLCBpLCBlYykgLT5cbiAgICAgICAgQ0V4cHJQcmVkIChmY19yZXYgZmMsIG5hbWUsIGFyZ3MsIGksIGVjX3JldiBlYylcbiAgICBcbiAgbGV0IGNfcHVzaF9lIGljID0gZnVuY3Rpb25cbiAgICB8IENFeHByIGMgLT4gQ0V4cHIgKGljIDo6IGMpXG4gICAgfCBDRXhwclByZWQgKGZjLCBuYW1lLCBhcmdzLCBpLCBlYykgLT5cbiAgICAgICAgQ0V4cHJQcmVkIChmYywgbmFtZSwgYXJncywgaSwgaWMgOjogZWMpXG4gICAgfCBfIC0+IHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiY2Fubm90IHB1c2ggZXhwcmVzc2lvbiB0byBmb3JtdWxhIGNvbnRleHRcIilcbiAgICBcbiAgbGV0IGNfcHVzaF9wIChwLCBhcmdzLCBpKSA9IGZ1bmN0aW9uXG4gICAgfCBDRm9ybSBmYyAtPiBDRXhwclByZWQgKGZjLCBwLCBhcmdzLCBpLCBbXSlcbiAgICB8IF8gLT4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJjYW5ub3QgcHVzaCBwcmVkaWNhdGUgdG8gZXhwcmVzc2lvbiBjb250ZXh0XCIpXG4gIFxuICBsZXQgY19wdXNoX2YgaWMgPSBmdW5jdGlvblxuICAgIHwgQ0Zvcm0gYyAtPiBDRm9ybSAoaWMgOjogYylcbiAgICB8IF8gLT4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJjYW5ub3QgcHVzaCBmb3JtdWxhIHRvIGV4cHJlc3Npb24gY29udGV4dFwiKVxuICBcbiAgbGV0IGNfcHVzaCBpYyBjID1cbiAgICBtYXRjaCBpYyB3aXRoXG4gICAgfCBgRSBlIC0+IGNfcHVzaF9lIGUgY1xuICAgIHwgYFAgcCAtPiBjX3B1c2hfcCBwIGNcbiAgICB8IGBGIGYgLT4gY19wdXNoX2YgZiBjXG4gICAgfCBgTm9uZSAtPiBjXG5cblxuICAoKiBbZnJlc2hfdmFyIH5iYXNlbmFtZSBuYW1lc10gZ2VuZXJhdGVzIGEgZnJlc2ggbmFtZSBmb3IgYVxuICAgICB2YXJpYWJsZSByZWxhdGl2ZSB0byB0aGUgb25lcyBpbiBbbmFtZXNdLCBiYXNlZCBvbiBhbiBvcHRpb25hbCBbYmFzZW5hbWVdLiAqKVxuICBsZXQgZnJlc2hfdmFyID8oYmFzZW5hbWUgPSBcInhcIikgbmFtZXMgPVxuICAgIGlmIG5vdCAoTGlzdC5tZW0gYmFzZW5hbWUgbmFtZXMpIHRoZW5cbiAgICAgIGJhc2VuYW1lXG4gICAgZWxzZVxuICAgICAgbGV0IHJlYyBhdXggbiA9XG4gICAgICAgIGxldCBiYXNlbmFtZSA9IGJhc2VuYW1lIF4gc3RyaW5nX29mX2ludCBuIGluXG4gICAgICAgIGlmIG5vdCAoTGlzdC5tZW0gYmFzZW5hbWUgbmFtZXMpXG4gICAgICAgIHRoZW4gYmFzZW5hbWVcbiAgICAgICAgZWxzZSBhdXggKG4rMSlcbiAgICAgIGluXG4gICAgICBhdXggMFxuXG5cbiAgbGV0IHJlYyB0X3VubG9jICh0IDogcHR5cGUpIDogdHlwZV8gPVxuICAgIG1hdGNoIHVubG9jIHQgd2l0aFxuICAgIHwgUFRVbml0IC0+IFRVbml0XG4gICAgfCBQVFZhciB4IC0+IFRWYXIgKHVubG9jIHgsIDApXG4gICAgfCBQVFN1bSAodDEsIHQyKSAtPiBUT3IgKHRfdW5sb2MgdDEsIHRfdW5sb2MgdDIpXG4gICAgfCBQVFByb2QgKHQxLCB0MikgLT4gVFByb2QgKHRfdW5sb2MgdDEsIHRfdW5sb2MgdDIpXG4gICAgfCBQVFJlYyAoeCwgdCkgLT4gVFJlYyAodW5sb2MgeCwgdF91bmxvYyB0KVxuICBcbiAgbGV0IHJlYyBlX3VubG9jIChlIDogcGV4cHIpIDogZXhwciA9XG4gICAgbWF0Y2ggdW5sb2MgZSB3aXRoXG4gICAgfCBQRVZhciAoeCwgaSkgLT4gRVZhciAodW5sb2MgeCwgaSlcbiAgICB8IFBFQXBwIChmLCBhcmdzKSAtPiBFRnVuICh1bmxvYyBmLCBMaXN0Lm1hcCBlX3VubG9jIGFyZ3MpXG4gIFxuICBsZXQgcmVjIGZfdW5sb2MgKGYgOiBwZm9ybSkgOiBmb3JtID1cbiAgICBsZXQgcHJlZCBuYW1lIGZzID0gRkNvbm4gKG5hbWUsIExpc3QubWFwIGZfdW5sb2MgZnMpIGluXG5cbiAgICBtYXRjaCB1bmxvYyBmIHdpdGhcbiAgICB8IFBGQXBwIChwLCBhcmdzKSAtPiBGUHJlZCAodW5sb2MgcCwgTGlzdC5tYXAgZV91bmxvYyBhcmdzKVxuICAgIHwgUEZDc3QgYiAtPiBpZiBiIHRoZW4gRlRydWUgZWxzZSBGRmFsc2VcblxuICAgIHwgUEZBbmQgICAoZjEsIGYyKSAtPiBwcmVkIGBBbmQgICBbZjE7IGYyXVxuICAgIHwgUEZPciAgICAoZjEsIGYyKSAtPiBwcmVkIGBPciAgICBbZjE7IGYyXVxuICAgIHwgUEZJbXAgICAoZjEsIGYyKSAtPiBwcmVkIGBJbXAgICBbZjE7IGYyXVxuICAgIHwgUEZFcXVpdiAoZjEsIGYyKSAtPiBwcmVkIGBFcXVpdiBbZjE7IGYyXVxuICAgIHwgUEZOb3QgICBmMSAgICAgICAtPiBwcmVkIGBOb3QgICBbZjFdXG4gICAgXG4gICAgfCBQRkZvcmFsbCAoKHgsIHR5KSwgZikgLT4gRkJpbmQgKGBGb3JhbGwsIHVubG9jIHgsIHRfdW5sb2MgdHksIGZfdW5sb2MgZilcbiAgICB8IFBGRXhpc3RzICgoeCwgdHkpLCBmKSAtPiBGQmluZCAoYEV4aXN0LCB1bmxvYyB4LCB0X3VubG9jIHR5LCBmX3VubG9jIGYpXG5cblxuICAoKiBGSVhNRSAqKVxuICBsZXQgcmVjIHRyZWNoZWNrIChlbnYgOiBlbnYpICh0eSA6IHR5cGVfKSA6IHVuaXQgPVxuICAgIG1hdGNoIHR5IHdpdGhcbiAgICB8IFRWYXIgeCAtPlxuICAgICAgICBpZiBub3QgKFRWYXJzLmV4aXN0cyBlbnYgeCkgdGhlblxuICAgICAgICAgIHJhaXNlIFJlY2hlY2tGYWlsdXJlXG5cbiAgICB8IFRVbml0IC0+XG4gICAgICAgICgpXG5cbiAgICB8IFRQcm9kICh0eTEsIHR5MilcbiAgICB8IFRPciAgICh0eTEsIHR5MikgLT5cbiAgICAgICAgTGlzdC5pdGVyICh0cmVjaGVjayBlbnYpIFt0eTE7IHR5Ml1cblxuICAgIHwgVFJlYyAoeCwgdHkpIC0+XG4gICAgICAgIHRyZWNoZWNrIChUVmFycy5wdXNoIGVudiAoeCwgTm9uZSkpIHR5XG5cbiAgbGV0IHJlYyBlaW5mZXIgKGVudiA6IGVudikgKGUgOiBleHByKSA6IHR5cGVfID1cbiAgICBtYXRjaCBlIHdpdGhcbiAgICB8IEVWYXIgeCAtPiBiZWdpblxuICAgICAgICBtYXRjaCBWYXJzLmdldCBlbnYgeCB3aXRoXG4gICAgICAgIHwgTm9uZSAgICAgICAgICAtPiByYWlzZSBUeXBpbmdFcnJvclxuICAgICAgICB8IFNvbWUgKHh0eSwgXykgLT4geHR5XG4gICAgICBlbmRcblxuICAgIHwgRUZ1biAoZiwgYXJncykgLT4gYmVnaW5cbiAgICAgICAgbWF0Y2ggRnVucy5nZXQgZW52IGYgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gcmFpc2UgVHlwaW5nRXJyb3JcbiAgICAgICAgfCBTb21lIChmYXJncywgZnJlcykgLT5cbiAgICAgICAgICAgIGlmIExpc3QubGVuZ3RoIGZhcmdzIDw+IExpc3QubGVuZ3RoIGFyZ3MgdGhlblxuICAgICAgICAgICAgICByYWlzZSBUeXBpbmdFcnJvcjtcbiAgICAgICAgICAgIGxldCBhcmdzID0gTGlzdC5tYXAgKGVpbmZlciBlbnYpIGFyZ3MgaW5cbiAgICAgICAgICAgIGlmIG5vdCAoTGlzdC5mb3JfYWxsMiAodF9lcXVhbCBlbnYpIGZhcmdzIGFyZ3MpIHRoZW5cbiAgICAgICAgICAgICAgcmFpc2UgVHlwaW5nRXJyb3I7XG4gICAgICAgICAgICBmcmVzXG4gICAgICBlbmRcblxuICBsZXQgcmVjIGVyZWNoZWNrIChlbnYgOiBlbnYpICh0eSA6IHR5cGVfKSAoZXhwciA6IGV4cHIpIDogdW5pdCA9XG4gICAgbWF0Y2ggZXhwciB3aXRoXG4gICAgfCBFVmFyIHggLT5cbiAgICAgICAgbGV0IHh0eSwgXyA9IE9wdGlvbi5nZXRfZXhuIChWYXJzLmdldCBlbnYgeCkgUmVjaGVja0ZhaWx1cmUgaW5cbiAgICAgICAgaWYgbm90ICh0X2VxdWFsIGVudiB0eSB4dHkpIHRoZW4gcmFpc2UgUmVjaGVja0ZhaWx1cmVcblxuICAgIHwgRUZ1biAoZiwgYXJncykgLT5cbiAgICAgICAgbGV0IHNpZ18sIHJlcyA9IE9wdGlvbi5nZXRfZXhuIChGdW5zLmdldCBlbnYgZikgUmVjaGVja0ZhaWx1cmUgaW5cbiAgICAgICAgaWYgbm90ICh0X2VxdWFsIGVudiB0eSByZXMpIHRoZW5cbiAgICAgICAgICByYWlzZSBSZWNoZWNrRmFpbHVyZTtcbiAgICAgICAgaWYgTGlzdC5sZW5ndGggc2lnXyA8PiBMaXN0Lmxlbmd0aCBhcmdzIHRoZW5cbiAgICAgICAgICByYWlzZSBSZWNoZWNrRmFpbHVyZTtcbiAgICAgICAgTGlzdC5pdGVyMiAoZXJlY2hlY2sgZW52KSBzaWdfIGFyZ3NcblxuICBsZXQgcmVjIHJlY2hlY2sgKGVudiA6IGVudikgKGZvcm0gOiBmb3JtKSA6IHVuaXQgPVxuICAgIG1hdGNoIGZvcm0gd2l0aFxuICAgIHwgRlRydWUgfCBGRmFsc2UgLT4gKClcbiAgICBcbiAgICB8IEZQcmVkIChuYW1lLCBbZTE7IGUyXSkgd2hlbiBuYW1lID0gXCJfRVFcIiAtPlxuICAgICAgICBsZXQgdDEsIHQyID0gcGFpcl9tYXAgKGVpbmZlciBlbnYpIChlMSwgZTIpIGluXG4gICAgICAgIGlmIG5vdCAodF9lcXVhbCBlbnYgdDEgdDIpIHRoZW4gcmFpc2UgUmVjaGVja0ZhaWx1cmVcblxuICAgIHwgRlByZWQgKG5hbWUsIGFyZ3MpIC0+IGJlZ2luXG4gICAgICAgIGxldCBzaWdfID0gT3B0aW9uLmdldF9leG4gKFBycHMuZ2V0IGVudiBuYW1lKSBSZWNoZWNrRmFpbHVyZSBpblxuICAgICAgICBpZiBMaXN0Lmxlbmd0aCBzaWdfIDw+IExpc3QubGVuZ3RoIGFyZ3MgdGhlblxuICAgICAgICAgIHJhaXNlIFJlY2hlY2tGYWlsdXJlO1xuICAgICAgICBMaXN0Lml0ZXIyIChlcmVjaGVjayBlbnYpIHNpZ18gYXJnc1xuICAgICAgZW5kXG5cbiAgICB8IEZDb25uIChsZywgZm9ybXMpIC0+XG4gICAgICAgIGlmIExpc3QubGVuZ3RoIGZvcm1zIDw+IHBhcml0eSBsZyB0aGVuXG4gICAgICAgICAgcmFpc2UgUmVjaGVja0ZhaWx1cmU7XG4gICAgICAgIExpc3QuaXRlciAocmVjaGVjayBlbnYpIGZvcm1zXG5cbiAgICB8IEZCaW5kIChfLCB4LCB4dHksIGYpIC0+XG4gICAgICAgIHRyZWNoZWNrIGVudiB4dHk7IHJlY2hlY2sgKFZhcnMucHVzaCBlbnYgKHgsICh4dHksIE5vbmUpKSkgZlxuXG5cbiAgbGV0IHJlYyB0Y2hlY2sgKGVudiA6IGVudikgKHR5IDogcHR5cGUpID1cbiAgICBtYXRjaCB1bmxvYyB0eSB3aXRoXG4gICAgfCBQVFVuaXQgICAgICAgICAgLT4gVFVuaXRcbiAgICB8IFBUU3VtICAodDEsIHQyKSAtPiBUT3IgICAodGNoZWNrIGVudiB0MSwgdGNoZWNrIGVudiB0MilcbiAgICB8IFBUUHJvZCAodDEsIHQyKSAtPiBUUHJvZCAodGNoZWNrIGVudiB0MSwgdGNoZWNrIGVudiB0MilcblxuICAgIHwgUFRSZWMgKHgsIHQpIC0+XG4gICAgICAgIFRSZWMgKHVubG9jIHgsIHRjaGVjayAoVFZhcnMucHVzaCBlbnYgKHVubG9jIHgsIE5vbmUpKSB0KVxuXG4gICAgfCBQVFZhciB4IC0+XG4gICAgICAgIGlmIG5vdCAoVFZhcnMuZXhpc3RzIGVudiAodW5sb2MgeCwgMCkpIHRoZW5cbiAgICAgICAgICByYWlzZSBUeXBpbmdFcnJvcjtcbiAgICAgICAgVFZhciAodW5sb2MgeCwgMClcblxuICBsZXQgZWNoZWNrIChlbnYgOiBlbnYpIChlIDogcGV4cHIpID1cbiAgICBsZXQgZSA9IGVfdW5sb2MgZSBpblxuICAgIGUsIGVpbmZlciBlbnYgZVxuXG4gIGxldCByZWMgY2hlY2sgKGVudiA6IGVudikgKGZvcm0gOiBwZm9ybSkgPVxuICAgIGxldCBwcmVkIG5hbWUgZnMgPSBGQ29ubiAobmFtZSwgTGlzdC5tYXAgKGNoZWNrIGVudikgZnMpIGluXG5cbiAgICBtYXRjaCB1bmxvYyBmb3JtIHdpdGhcbiAgICB8IFBGQ3N0IHRydWUgIC0+IEZUcnVlXG4gICAgfCBQRkNzdCBmYWxzZSAtPiBGRmFsc2VcblxuICAgIHwgUEZBbmQgICAoZjEsIGYyKSAtPiBwcmVkIGBBbmQgICBbZjE7IGYyXVxuICAgIHwgUEZPciAgICAoZjEsIGYyKSAtPiBwcmVkIGBPciAgICBbZjE7IGYyXVxuICAgIHwgUEZJbXAgICAoZjEsIGYyKSAtPiBwcmVkIGBJbXAgICBbZjE7IGYyXVxuICAgIHwgUEZFcXVpdiAoZjEsIGYyKSAtPiBwcmVkIGBFcXVpdiBbZjE7IGYyXVxuICAgIHwgUEZOb3QgICBmMSAgICAgICAtPiBwcmVkIGBOb3QgICBbZjFdXG4gICAgXG4gICAgfCBQRkFwcCAobmFtZSwgW2UxOyBlMl0pIHdoZW4gdW5sb2MgbmFtZSA9IFwiX0VRXCIgLT5cbiAgICAgICAgbGV0IChlMSwgdDEpLCAoZTIsIHQyKSA9IHBhaXJfbWFwIChlY2hlY2sgZW52KSAoZTEsIGUyKSBpblxuICAgICAgICBpZiBub3QgKHRfZXF1YWwgZW52IHQxIHQyKSB0aGVuIHJhaXNlIFR5cGluZ0Vycm9yXG4gICAgICAgIGVsc2UgRlByZWQgKFwiX0VRXCIsIFtlMTsgZTJdKVxuXG4gICAgfCBQRkFwcCAobmFtZSwgYXJncykgLT4gYmVnaW5cbiAgICAgICAgbWF0Y2ggUHJwcy5nZXQgZW52ICh1bmxvYyBuYW1lKSB3aXRoXG4gICAgICAgIHwgTm9uZSAgICAtPiByYWlzZSBUeXBpbmdFcnJvclxuICAgICAgICB8IFNvbWUgYXIgLT5cbiAgICAgICAgICAgIGlmIExpc3QubGVuZ3RoIGFyZ3MgPD4gTGlzdC5sZW5ndGggYXIgdGhlblxuICAgICAgICAgICAgICByYWlzZSBUeXBpbmdFcnJvcjtcbiAgICAgICAgICAgIGxldCBhcmdzID0gTGlzdC5tYXAgKGVjaGVjayBlbnYpIGFyZ3MgaW5cbiAgICAgICAgICAgIGlmIG5vdCAoTGlzdC5mb3JfYWxsMiAodF9lcXVhbCBlbnYpIGFyIChMaXN0LnNuZCBhcmdzKSkgdGhlblxuICAgICAgICAgICAgICByYWlzZSBUeXBpbmdFcnJvcjtcbiAgICAgICAgICAgIEZQcmVkICh1bmxvYyBuYW1lLCBMaXN0LmZzdCBhcmdzKVxuICAgICAgZW5kXG5cbiAgICB8IFBGRm9yYWxsICgoeCwgeHR5KSwgZikgLT5cbiAgICAgICAgbGV0IHh0eSA9IHRjaGVjayBlbnYgeHR5IGluXG4gICAgICAgIGxldCBmICAgPSBjaGVjayAoVmFycy5wdXNoIGVudiAodW5sb2MgeCwgKHh0eSwgTm9uZSkpKSBmIGluXG4gICAgICAgIEZCaW5kIChgRm9yYWxsLCB1bmxvYyB4LCB4dHksIGYpXG5cbiAgICB8IFBGRXhpc3RzICgoeCwgeHR5KSwgZikgLT5cbiAgICAgICAgbGV0IHh0eSA9IHRjaGVjayBlbnYgeHR5IGluXG4gICAgICAgIGxldCBmICAgPSBjaGVjayAoVmFycy5wdXNoIGVudiAodW5sb2MgeCwgKHh0eSwgTm9uZSkpKSBmIGluXG4gICAgICAgIEZCaW5kIChgRXhpc3QsIHVubG9jIHgsIHh0eSwgZilcblxuICBtb2R1bGUgU3Vic3QgPSBzdHJ1Y3RcbiAgICB0eXBlIHN1YnN0ID0gKG5hbWUgKiBzaXRlbSkgbGlzdFxuXG5cbiAgICBsZXQgZW1wdHkgPSBbXVxuXG4gICAgbGV0IGFzbGlzdCAocyA6IHN1YnN0KSA6IF8gbGlzdCA9XG4gICAgICBzXG5cbiAgICBsZXQgb2ZsaXN0IChzIDogXyBsaXN0KSA6IHN1YnN0ID1cbiAgICAgIHNcblxuICAgIGxldCBmb2xkID0gTGlzdC5mb2xkX2xlZnRcblxuXG4gICAgbGV0IHJlYyBnZXRfdGFnICgobiwgaSkgYXMgeCA6IHZuYW1lKSAocyA6IHN1YnN0KSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgIHwgW10gLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IChtLCB0YWcpIDo6IHMgd2hlbiBuID0gbSAtPlxuICAgICAgICAgIGlmIGkgPSAwIHRoZW4gU29tZSB0YWcgZWxzZSBnZXRfdGFnIChuLCBpLTEpIHNcbiAgICAgIHwgXyA6OiBzIC0+XG4gICAgICAgICAgZ2V0X3RhZyB4IHNcblxuICAgIGxldCBmbGV4ICh4IDogdm5hbWUpIChzIDogc3Vic3QpID1cbiAgICAgIGdldF90YWcgeCBzID0gU29tZSBTZmxleFxuICBcdCAgICAgICAgICAgIFxuICAgIGxldCBib3VuZCAoeCA6IHZuYW1lKSAocyA6IHN1YnN0KSA9XG4gICAgICBtYXRjaCBnZXRfdGFnIHggcyB3aXRoIFNvbWUgKFNib3VuZCBfKSAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuICAgIFxuXG4gICAgZXhjZXB0aW9uIFVuYm91bmRWYXJpYWJsZSBvZiB2bmFtZSAqIHN1YnN0XG4gIFxuICAgIGxldCBmZXRjaCAoeCA6IHZuYW1lKSAocyA6IHN1YnN0KSA9XG4gICAgICBtYXRjaCBnZXRfdGFnIHggcyB3aXRoXG4gICAgICB8IFNvbWUgKFNib3VuZCBlKSAtPiBlXG4gICAgICB8IF8gLT4gcmFpc2UgKFVuYm91bmRWYXJpYWJsZSAoeCwgcykpXG4gIFxuICAgIGxldCByZWMgYWRkICgobiwgaSkgYXMgeCA6IHZuYW1lKSAoZSA6IGV4cHIpIDogc3Vic3QgLT4gc3Vic3QgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBmYWlsd2l0aCBcIlN1YnN0LmFkZCBbMV1cIlxuICAgICAgfCAobSwgdCkgOjogcyB3aGVuIG4gPD4gbSAtPiAobSwgdCkgOjogKGFkZCB4IGUgcylcbiAgICAgIHwgKG0sIHQpIDo6IHMgd2hlbiBuID0gbSAmJiBpID4gMCAtPiAobSwgdCkgOjogKGFkZCAobiwgaS0xKSBlIHMpXG4gICAgICB8IChtLCBTZmxleCkgOjogcyB3aGVuIG4gPSBtICYmIGkgPSAwIC0+IChtLCBTYm91bmQgZSkgOjogc1xuICAgICAgfCBfIC0+IGZhaWx3aXRoIFwiU3Vic3QuYWRkIFsyXVwiXG4gICAgXG4gICAgbGV0IHB1c2ggbSB0IHMgPSAobSwgdCkgOjogc1xuXG5cbiAgICBsZXQgaXNfY29tcGxldGUgKHMgOiBzdWJzdCkgPVxuICAgICAgTGlzdC5mb3JfYWxsIChmdW4gKF8sIHRhZykgLT4gdGFnIDw+IFNmbGV4KSBzXG5cblxuICAgIGxldCByZWMgZV9hcHBseTEgKCh4LCBpKSA6IG5hbWUgKiBpbnQpIChlIDogZXhwcikgKHRnIDogZXhwcikgOiBleHByID1cbiAgICAgIG1hdGNoIHRnIHdpdGhcbiAgICAgIHwgRVZhciAoeSwgaikgd2hlbiB4ID0geSAmJiBpID0gaiAtPlxuICAgICAgICAgIGVcblxuICAgICAgfCBFVmFyICh5LCBqKSB3aGVuIHggPSB5ICYmIGkgPCBqIC0+XG4gICAgICAgICAgRVZhciAoeSwgai0xKVxuXG4gICAgICB8IEVWYXIgXyAtPlxuICAgICAgICAgIHRnXG5cbiAgICAgIHwgRUZ1biAoZiwgYXJncykgLT5cbiAgICAgICAgICBFRnVuIChmLCBMaXN0Lm1hcCAoZV9hcHBseTEgKHgsIGkpIGUpIGFyZ3MpXG5cbiAgICBsZXQgcmVjIGZfYXBwbHkxICgoeCwgaSkgOiBuYW1lICogaW50KSAoZSA6IGV4cHIpIChmIDogZm9ybSkgOiBmb3JtID1cbiAgICAgIG1hdGNoIGYgd2l0aFxuICAgICAgfCBGVHJ1ZSB8IEZGYWxzZSAtPlxuICAgICAgICAgIGZcblxuICAgICAgfCBGQ29ubiAobGcsIGZzKSAtPlxuICAgICAgICAgIEZDb25uIChsZywgTGlzdC5tYXAgKGZfYXBwbHkxICh4LCBpKSBlKSBmcylcblxuICAgICAgfCBGUHJlZCAobmFtZSwgYXJncykgLT5cbiAgICAgICAgICBGUHJlZCAobmFtZSwgTGlzdC5tYXAgKGVfYXBwbHkxICh4LCBpKSBlKSBhcmdzKVxuXG4gICAgICB8IEZCaW5kIChiZCwgeSwgdHksIGYpIC0+XG4gICAgICAgICAgRkJpbmQgKGJkLCB5LCB0eSwgZl9hcHBseTEgKHgsIGkgKyAoaWYgeCA9IHkgdGhlbiAxIGVsc2UgMCkpIChlX3NoaWZ0ICh5LCBpKSBlKSBmKVxuXG5cbiAgICBsZXQgcmVjIGVfaXRlciBzIGkgZSA9XG4gICAgICBpZiBpID0gMCB0aGVuIGUgZWxzZVxuICAgICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgfCAoeCwgU2JvdW5kIGUpIDo6IHMgLT5cbiAgICAgICAgICAgIGVfaXRlciBzIChpLTEpIChlX2FwcGx5MSAoeCwgMCkgZSBlKVxuICAgICAgICB8IChfLCBfKSA6OiBzIC0+XG4gICAgICAgICAgICBlX2l0ZXIgcyAoaS0xKSBlXG5cdCAgICBcbiAgICBsZXQgcmVjIGZfaXRlciBzIGkgZiA9XG4gICAgICBpZiBpID0gMCB0aGVuIGYgZWxzZVxuICAgICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgfCAoeCwgU2JvdW5kIGUpIDo6IHMgLT5cbiAgICAgICAgICAgIGZfaXRlciBzIChpLTEpIChmX2FwcGx5MSAoeCwgMCkgZSBmKVxuICAgICAgICB8IChfLCBfKSA6OiBzIC0+XG4gICAgICAgICAgICBmX2l0ZXIgcyAoaS0xKSBmXG4gICAgICAgICAgICBcblxuICAgIGxldCBlX2FwcGx5IHMgZSA9XG4gICAgICBlX2l0ZXIgcyAoTGlzdC5sZW5ndGggcykgZVxuXG4gICAgbGV0IGZfYXBwbHkgcyBmID1cbiAgICAgIGZfaXRlciBzIChMaXN0Lmxlbmd0aCBzKSBmXG4gICAgICBcblxuICAgIGxldCByZWMgZV9jbG9zZSBzID0gZnVuY3Rpb25cbiAgICAgIHwgRVZhciB4IC0+XG4gICAgICAgICAgYmVnaW5cbiAgICAgICAgICAgIHRyeSBlX2Nsb3NlIHMgKGZldGNoIHggcylcbiAgICAgICAgICAgIHdpdGggVW5ib3VuZFZhcmlhYmxlIF8gLT4gRVZhciB4XG4gICAgICAgICAgZW5kXG4gICAgICB8IEVGdW4gKGYsIGVzKSAtPlxuICAgICAgICAgIEVGdW4gKGYsIExpc3QubWFwIChlX2Nsb3NlIHMpIGVzKVxuICAgICAgXG4gICAgbGV0IGNsb3NlIHMgPVxuICAgICAgcyB8PiBMaXN0Lm1hcCBiZWdpbiBmdW4gKHgsIHRhZykgLT5cbiAgICAgICAgbGV0IHRhZyA9IG1hdGNoIHRhZyB3aXRoXG4gICAgICAgICAgfCBTYm91bmQgZSAtPiBTYm91bmQgKGVfY2xvc2UgcyBlKVxuICAgICAgICAgIHwgXyAtPiB0YWdcbiAgICAgICAgaW4geCwgdGFnXG4gICAgICBlbmRcbiAgICAgIFxuXG4gICAgbGV0IHRvX3N0cmluZyA9XG4gICAgICBMaXN0LnRvX3N0cmluZyB+c2VwOlwiLCBcIiB+bGVmdDpcIntcIiB+cmlnaHQ6XCJ9XCJcbiAgICAgICAgKGZ1biAoeCwgdGFnKSAtPlxuICAgICAgICAgIG1hdGNoIHRhZyB3aXRoXG4gICAgICAgICAgfCBTZmxleCAtPiBcIj9cIiBeIHhcbiAgICAgICAgICB8IFNib3VuZCBlIC0+IHggXiBcIiA6PSBcIiBeIChOb3RhdGlvbi5lX3Rvc3RyaW5nIGUpKVxuICBlbmRcblxuXG4gIGxldCByZWMgb2NjdXJzICh4IDogdm5hbWUpIDogZXhwciAtPiBib29sID0gZnVuY3Rpb25cbiAgICB8IEVWYXIgeSB3aGVuIHggPSB5IC0+IHRydWVcbiAgICB8IEVGdW4gKF8sIHRzKSAtPiBMaXN0LmZvbGRfbGVmdCAoZnVuIGIgdCAtPiBiIHx8IG9jY3VycyB4IHQpIGZhbHNlIHRzXG4gICAgfCBfIC0+IGZhbHNlXG4gIFxuICBsZXQgcmVjIG9jY3Vyc191bmRlciAoKG4sIGkpIGFzIHggOiB2bmFtZSkgOiBleHByIC0+IGJvb2wgPSBmdW5jdGlvblxuICAgIHwgRVZhciAobSwgaikgd2hlbiBuID0gbSAmJiBqIDw9IGkgLT4gdHJ1ZVxuICAgIHwgRUZ1biAoXywgdHMpIC0+IExpc3QuZm9sZF9sZWZ0IChmdW4gYiB0IC0+IGIgfHwgb2NjdXJzX3VuZGVyIHggdCkgZmFsc2UgdHNcbiAgICB8IF8gLT4gZmFsc2VcblxuXG4gICgqKiBbZV91bmlmeSBlbnYgcyBlcW5zXSBpbXBsZW1lbnRzIGEgdmFyaWFudCBvZiBNYXJ0ZWxsaSBhbmQgTW9udGFuYXJpJ3NcbiAgICAgIHVuaWZpY2F0aW9uIGFsZ29yaXRobSBvbiBhIGxpc3Qgb2YgdGVybSBlcXVhdGlvbnMgW2VxbnNdLCB3aXRoIGFkZGl0aW9uYWxcbiAgICAgIGhhbmRsaW5nIG9mIGEgc3Vic3RpdHV0aW9uIFtzXSBob2xkaW5nIHRoZSBsaXN0IG9mIGJpbmRpbmdzIGFuZCB1bmlmaWFibGUgKG9yXG4gICAgICBcImZsZXhcIikgdmFyaWFibGVzLCBhbmQgYSBsb2NhbCBlbnZpcm9ubWVudCBbbGVudl0gaG9sZGluZyBhIGNvbnRleHQgb2YgbG9jYWxseVxuICAgICAgYm91bmQgdmFyaWFibGVzLiAqKVxuXG4gXHQgICBcbiAgZXhjZXB0aW9uIEludmFsaWRfY29uc3RhbnQgXG5cdCAgIFxuICBsZXQgcmVjIGVfdW5pZnkgKHZlbnYgOiBlbnYpIChsZW52IDogTEVudi5sZW52KSAocyA6IFN1YnN0LnN1YnN0KSA9IGZ1bmN0aW9uXG5cbiAgICAoKiBzdWNjZXNzICopXG4gICAgfCBbXSAtPlxuICAgICAgICBTb21lIChTdWJzdC5jbG9zZSBzKVxuXG4gICAgfCAodCwgdSkgOjogZXFucyAtPlxuXG4gICAgICAgIGxldCB1bmlmeV9jb25kIHggdCA9XG4gICAgICAgICAgU3Vic3QuZmxleCB4IHMgJiZcbiAgICAgICAgICBub3QgKG9jY3VycyB4IHQpICYmICgqIG1heWJlIHVubmVjZXNzYXJ5IGNoZWNrPyAqKVxuICAgICAgICAgIE1hcC5mb3JfYWxsIChmdW4gbiBpIC0+IFxuICAgICAgICAgICAgbm90IChvY2N1cnNfdW5kZXIgKG4sIGkpIHQpKVxuICAgICAgICAgICAgKExFbnYuaW5kaWNlcyBsZW52KVxuICAgICAgICBpblxuICAgICAgICBsZXQgdW5pZnlfYm9keSB4IHQgPVxuICAgICAgICAgIGVfdW5pZnkgdmVudiBsZW52IChTdWJzdC5hZGQgeCB0IHMpIGVxbnNcbiAgICAgICAgaW5cblxuICAgICAgICBsZXQgc3Vic3RpdHV0ZV9jb25kIHggPSBTdWJzdC5ib3VuZCB4IHMgaW5cbiAgICAgICAgbGV0IHN1YnN0aXR1dGVfYm9keSB4IHQgPVxuICAgICAgICAgIGVfdW5pZnkgdmVudiBsZW52IHMgKCgoU3Vic3QuZmV0Y2ggeCBzKSwgdCkgOjogZXFucylcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGlzX2NvbnN0IHggID1cblx0ICBtYXRjaCBWYXJzLmdldCB2ZW52IHggd2l0aFxuXHQgICAgfCBTb21lIChfLCBTb21lIF8pIC0+IHRydWVcblx0ICAgIHwgXyAtPiBmYWxzZVxuXHRpblxuXHRcbiAgICAgICAgbWF0Y2ggdCwgdSB3aXRoXG5cdCAgICBcbiAgICAgICAgKCogKGVsaW1pbmF0ZSkgaXMgZGVjb21wb3NlZCBpbnRvIHRoZSAyIGZvbGxvd2luZyBtdXR1YWxseSBleGNsdXNpdmUgY2FzZXM6ICopXG5cdCAgICBcdCAgICBcbiAgICAgICAgKCogKHVuaWZ5KSAqKVxuICAgICAgICB8IEVWYXIgeCwgdCB3aGVuIHVuaWZ5X2NvbmQgeCB0IC0+IHVuaWZ5X2JvZHkgeCB0XG4gICAgICAgIHwgdCwgRVZhciB4IHdoZW4gdW5pZnlfY29uZCB4IHQgLT4gdW5pZnlfYm9keSB4IHRcblxuICAgICAgICAoKiAoc3Vic3RpdHV0ZSkgKilcbiAgICAgICAgfCBFVmFyIHgsIHQgd2hlbiBzdWJzdGl0dXRlX2NvbmQgeCAtPiBzdWJzdGl0dXRlX2JvZHkgeCB0XG4gICAgICAgIHwgdCwgRVZhciB4IHdoZW4gc3Vic3RpdHV0ZV9jb25kIHggLT4gc3Vic3RpdHV0ZV9ib2R5IHggdFxuXG4gICAgICAgICgqIChkZWxldGUpICopXG4gICAgICAgIHwgRVZhciB4LCBFVmFyIHkgd2hlbiB4ID0geSAtPlxuICAgICAgICAgICAgZV91bmlmeSB2ZW52IGxlbnYgcyBlcW5zXG5cdCAgICBcbiAgICAgICAgKCogKGRlY29tcG9zZSkgKilcbiAgICAgICAgfCBFRnVuIChmLCB0cyksIEVGdW4gKGcsIHVzKSB3aGVuIGYgPSBnIC0+XG4gICAgICAgICAgICBlX3VuaWZ5IHZlbnYgbGVudiBzICgoTGlzdC5jb21iaW5lIHRzIHVzKSBAIGVxbnMpXG5cblx0KCooZXhwYW5kKSopXG5cdHwgdCwgRVZhciB5IHdoZW4gaXNfY29uc3QgeSAtPlxuXHQgICAgKG1hdGNoIFZhcnMuZ2V0IHZlbnYgeSB3aXRoXG5cdCAgICAgIHwgU29tZSAoXywgU29tZSB5ZSkgLT4gZV91bmlmeSB2ZW52IGxlbnYgcyAoKHQseWUpOjplcW5zKVxuXHQgICAgICB8IF8gLT4gcmFpc2UgSW52YWxpZF9jb25zdGFudClcblx0fCBFVmFyIHgsIHUgd2hlbiBpc19jb25zdCB4IC0+XG5cdCAgICAobWF0Y2ggVmFycy5nZXQgdmVudiB4IHdpdGhcblx0ICAgICAgfCBTb21lIChfLCBTb21lIHhlKSAtPiBlX3VuaWZ5IHZlbnYgbGVudiBzICgoeGUsIHUpOjplcW5zKVxuXHQgICAgICB8IF8gLT4gcmFpc2UgSW52YWxpZF9jb25zdGFudClcblxuICAgICAgICAoKiAoZmFpbCkgKilcbiAgICAgICAgfCBfIC0+IE5vbmVcblx0XG5cbiAgKCoqIFtmX3VuaWZ5IGVudiBzIGVxbnNdIGRvZXMgdW5pZmljYXRpb24gb2YgYSBsaXN0IG9mIGVxdWF0aW9ucyBbZXFuc10gYmV0d2VlblxuICAgICAgZm9ybXVsYXMsIHVwZGF0aW5nIGFsb25nIHRoZSB3YXkgYSBzdWJzdGl0dXRpb24gW3NdIGFuZCBhIGxvY2FsIGVudmlyb25tZW50IFtsZW52XVxuICAgICAgaG9sZGluZyBhIGNvbnRleHQgb2YgbG9jYWxseSBib3VuZCB2YXJpYWJsZXMuXG4gICopXG4gIGxldCByZWMgZl91bmlmeSAodmVudiA6IGVudilcbiAgICAgKGxlbnYgOiBMRW52LmxlbnYpIChzIDogU3Vic3Quc3Vic3QpID1cbiAgICBsZXQgb3BlbiBNb25hZC5PcHRpb24gaW4gZnVuY3Rpb25cblxuICAgIHwgW10gLT4gU29tZSBzXG5cbiAgICB8IChmMSwgZjIpIDo6IGVxbnMgLT4gbWF0Y2ggZjEsIGYyIHdpdGhcblxuICAgICAgICB8IEZUcnVlLCBGVHJ1ZSB8IEZGYWxzZSwgRkZhbHNlIC0+XG4gICAgICAgICAgXG4gICAgICAgICAgICBmX3VuaWZ5IHZlbnYgbGVudiBzIGVxbnNcblxuICAgICAgICB8IEZQcmVkIChwMSwgbDEpLCBGUHJlZCAocDIsIGwyKVxuICAgICAgICAgIHdoZW4gcDEgPSBwMiAmJiBMaXN0Lmxlbmd0aCBsMSA9IExpc3QubGVuZ3RoIGwyIC0+ICAgICAgIFxuXG4gICAgICAgICAgICBlX3VuaWZ5IHZlbnYgbGVudiBzIChMaXN0LmNvbWJpbmUgbDEgbDIpID4+PSBmdW4gcyAtPlxuICAgICAgICAgICAgZl91bmlmeSB2ZW52IGxlbnYgcyBlcW5zXG5cbiAgICAgICAgfCBGQ29ubiAoYzEsIGwxKSwgRkNvbm4gKGMyLCBsMilcbiAgICAgICAgICB3aGVuIGMxID0gYzIgJiYgTGlzdC5sZW5ndGggbDEgPSBMaXN0Lmxlbmd0aCBsMiAtPlxuXG4gICAgICAgICAgICBsZXQgc3ViZXFucyA9IExpc3QuY29tYmluZSBsMSBsMiBpblxuICAgICAgICAgICAgZl91bmlmeSB2ZW52IGxlbnYgcyAoc3ViZXFucyBAIGVxbnMpXG5cbiAgICAgICAgfCBGQmluZCAoYjEsIHgxLCB0eTEsIGYxKSwgRkJpbmQgKGIyLCB4MiwgdHkyLCBmMilcbiAgICAgICAgICB3aGVuIGIxID0gYjIgJiYgdHkxID0gdHkyIC0+XG5cbiAgICAgICAgICAgIGxldCBmMiA9IFN1YnN0LmZfYXBwbHkxICh4MiwgMCkgKEVWYXIgKHgxLCAwKSkgKGZfc2hpZnQgKHgxLCAwKSBmMikgaW5cbiAgICAgICAgICAgIGZfdW5pZnkgdmVudiAoTEVudi5lbnRlciBsZW52IHgxKSBzIFtmMSwgZjJdID4+PSBmdW4gcyAtPlxuICAgICAgICAgICAgZl91bmlmeSB2ZW52IGxlbnYgcyBlcW5zXG5cbiAgICAgICAgfCBfIC0+IE5vbmVcbmVuZFxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxubW9kdWxlIEdvYWwgOiBzaWdcbiAgdHlwZSBlbnRyeVxuXG4gIHZhbCBjaGVja19lbnRyeSA6IGVudiAtPiBwdmFyIC0+IGVudHJ5XG4gIHZhbCBlbnZfb2ZfZW50cmllcyA6IHB2YXIgbGlzdCAtPiBlbnZcbiAgdmFsIGNoZWNrIDogcGdvYWwgLT4gZW52ICogZm9ybSBsaXN0ICogZm9ybVxuZW5kID0gc3RydWN0XG4gIHR5cGUgZW50cnkgPVxuICAgIHwgRVBWYXIgIG9mIChuYW1lICogYXJpdHkpXG4gICAgfCBFVEZ1biAgb2YgKG5hbWUgKiBzaWdfKVxuICAgIHwgRVRWYXIgIG9mIChuYW1lICogYnZhcilcbiAgICB8IEVUVFZhciBvZiAobmFtZSAqIHR5cGVfIG9wdGlvbilcbiAgICBcbiAgbGV0IGNoZWNrX2VudHJ5IGVudiA9XG4gICAgbGV0IGZvcl90eXBlID0gRm9ybS50Y2hlY2sgZW52IGluXG4gICAgbGV0IGZvcl9leHByID0gRm9ybS5lY2hlY2sgZW52IGluXG4gICAgZnVuY3Rpb25cbiAgICB8IFBQcm9wIChuYW1lLCBhcikgLT5cbiAgICAgICAgRVBWYXIgKHVubG9jIG5hbWUsIExpc3QubWFwIGZvcl90eXBlIGFyKVxuICAgIHwgUEZ1biAobmFtZSwgKGFyLCB0eSkpIC0+XG4gICAgICAgIEVURnVuICh1bmxvYyBuYW1lLCAoTGlzdC5tYXAgZm9yX3R5cGUgYXIsIGZvcl90eXBlIHR5KSlcbiAgICB8IFBWYXIgKG5hbWUsIHR5KSAtPlxuICAgICAgICBFVFZhciAodW5sb2MgbmFtZSwgKGZvcl90eXBlIHR5LCBOb25lKSlcbiAgICB8IFBFeHByIChuYW1lLCBib2R5KSAtPlxuICAgICAgICBsZXQgYm9keSwgdHkgPSBmb3JfZXhwciBib2R5IGluXG4gICAgICAgIEVUVmFyICh1bmxvYyBuYW1lLCAodHksIFNvbWUgYm9keSkpXG4gICAgfCBQVFZhciBuYW1lIC0+XG4gICAgICAgIEVUVFZhciAodW5sb2MgbmFtZSwgTm9uZSlcbiAgICB8IFBUeXBlIChuYW1lLCB0eSkgLT5cbiAgICAgICAgRVRUVmFyICh1bmxvYyBuYW1lLCBTb21lIChmb3JfdHlwZSB0eSkpXG5cbiAgbGV0IGVudl9vZl9lbnRyaWVzIChlbnRyaWVzIDogcHZhciBsaXN0KSA9XG4gICAgTGlzdC5mb2xkX2xlZnQgKGZ1biBlbnYgZW50cnkgLT5cbiAgICAgIG1hdGNoIGNoZWNrX2VudHJ5IGVudiBlbnRyeSB3aXRoXG4gICAgICB8IEVQVmFyICBubXR5IC0+IFBycHMucHVzaCAgZW52IG5tdHlcbiAgICAgIHwgRVRGdW4gIG5tdHkgLT4gRnVucy5wdXNoICBlbnYgbm10eVxuICAgICAgfCBFVFZhciAgbm10eSAtPiBWYXJzLnB1c2ggIGVudiBubXR5XG4gICAgICB8IEVUVFZhciBubXR5IC0+IFRWYXJzLnB1c2ggZW52IG5tdHkpIEVudi5lbXB0eSBlbnRyaWVzXG4gICAgICBcbiAgbGV0IGNoZWNrICgocHMsIGhzLCBmKSA6IHBnb2FsKSA9XG4gICAgbGV0IGVudiA9IGVudl9vZl9lbnRyaWVzIHBzIGluXG4gICAgbGV0IGZvcl9mb3JtID0gRm9ybS5jaGVjayBlbnYgaW5cbiAgICAoZW52LCBMaXN0Lm1hcCBmb3JfZm9ybSBocywgZm9yX2Zvcm0gZilcbmVuZFxuIiwiXG4oKiBUaGlzIGdlbmVyYXRlZCBjb2RlIHJlcXVpcmVzIHRoZSBmb2xsb3dpbmcgdmVyc2lvbiBvZiBNZW5oaXJMaWI6ICopXG5cbmxldCAoKSA9XG4gIE1lbmhpckxpYi5TdGF0aWNWZXJzaW9uLnJlcXVpcmVfMjAyMjAyMTBcblxubW9kdWxlIE1lbmhpckJhc2ljcyA9IHN0cnVjdFxuICBcbiAgZXhjZXB0aW9uIEVycm9yXG4gIFxuICBsZXQgX2VSUiA9XG4gICAgZnVuIF9zIC0+XG4gICAgICByYWlzZSBFcnJvclxuICBcbiAgdHlwZSB0b2tlbiA9IFxuICAgIHwgVFlQRVxuICAgIHwgVFJVRVxuICAgIHwgU1RBUlxuICAgIHwgU0VNSUNPTE9OXG4gICAgfCBSUEFSRU5cbiAgICB8IFJFQ1xuICAgIHwgUkJSQUNFXG4gICAgfCBQUk9PRlxuICAgIHwgUExVU1xuICAgIHwgTkFUIG9mIChcbiMgNyBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICAgIChpbnQpXG4jIDI5IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgKVxuICAgIHwgTFJBUlJPV1xuICAgIHwgTFBBUkVOXG4gICAgfCBMT1JcbiAgICB8IExORUdcbiAgICB8IExCUkFDRVxuICAgIHwgTEFSUk9XXG4gICAgfCBMQU5EXG4gICAgfCBJREVOVCBvZiAoXG4jIDYgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgICAoU3ludGF4LnN5bWJvbClcbiMgNDEgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICApXG4gICAgfCBGT1JBTExcbiAgICB8IEZBTFNFXG4gICAgfCBFWElTVFNcbiAgICB8IEVRXG4gICAgfCBFT0ZcbiAgICB8IERPVFxuICAgIHwgRENPTE9OXG4gICAgfCBDT01NQVxuICAgIHwgQ09MT05FUVxuICAgIHwgQ09MT05cbiAgICB8IEFNUFxuICBcbmVuZFxuXG5pbmNsdWRlIE1lbmhpckJhc2ljc1xuXG4jIDEgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgXG4gIG9wZW4gTG9jYXRpb25cbiAgb3BlbiBTeW50YXhcblxuIyA2NCBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG5cbm1vZHVsZSBUYWJsZXMgPSBzdHJ1Y3RcbiAgXG4gIGluY2x1ZGUgTWVuaGlyQmFzaWNzXG4gIFxuICBsZXQgdG9rZW4ydGVybWluYWwgOiB0b2tlbiAtPiBpbnQgPVxuICAgIGZ1biBfdG9rIC0+XG4gICAgICBtYXRjaCBfdG9rIHdpdGhcbiAgICAgIHwgQU1QIC0+XG4gICAgICAgICAgMjlcbiAgICAgIHwgQ09MT04gLT5cbiAgICAgICAgICAyOFxuICAgICAgfCBDT0xPTkVRIC0+XG4gICAgICAgICAgMjdcbiAgICAgIHwgQ09NTUEgLT5cbiAgICAgICAgICAyNlxuICAgICAgfCBEQ09MT04gLT5cbiAgICAgICAgICAyNVxuICAgICAgfCBET1QgLT5cbiAgICAgICAgICAyNFxuICAgICAgfCBFT0YgLT5cbiAgICAgICAgICAyM1xuICAgICAgfCBFUSAtPlxuICAgICAgICAgIDIyXG4gICAgICB8IEVYSVNUUyAtPlxuICAgICAgICAgIDIxXG4gICAgICB8IEZBTFNFIC0+XG4gICAgICAgICAgMjBcbiAgICAgIHwgRk9SQUxMIC0+XG4gICAgICAgICAgMTlcbiAgICAgIHwgSURFTlQgXyAtPlxuICAgICAgICAgIDE4XG4gICAgICB8IExBTkQgLT5cbiAgICAgICAgICAxN1xuICAgICAgfCBMQVJST1cgLT5cbiAgICAgICAgICAxNlxuICAgICAgfCBMQlJBQ0UgLT5cbiAgICAgICAgICAxNVxuICAgICAgfCBMTkVHIC0+XG4gICAgICAgICAgMTRcbiAgICAgIHwgTE9SIC0+XG4gICAgICAgICAgMTNcbiAgICAgIHwgTFBBUkVOIC0+XG4gICAgICAgICAgMTJcbiAgICAgIHwgTFJBUlJPVyAtPlxuICAgICAgICAgIDExXG4gICAgICB8IE5BVCBfIC0+XG4gICAgICAgICAgMTBcbiAgICAgIHwgUExVUyAtPlxuICAgICAgICAgIDlcbiAgICAgIHwgUFJPT0YgLT5cbiAgICAgICAgICA4XG4gICAgICB8IFJCUkFDRSAtPlxuICAgICAgICAgIDdcbiAgICAgIHwgUkVDIC0+XG4gICAgICAgICAgNlxuICAgICAgfCBSUEFSRU4gLT5cbiAgICAgICAgICA1XG4gICAgICB8IFNFTUlDT0xPTiAtPlxuICAgICAgICAgIDRcbiAgICAgIHwgU1RBUiAtPlxuICAgICAgICAgIDNcbiAgICAgIHwgVFJVRSAtPlxuICAgICAgICAgIDJcbiAgICAgIHwgVFlQRSAtPlxuICAgICAgICAgIDFcbiAgXG4gIGFuZCBlcnJvcl90ZXJtaW5hbCA9XG4gICAgMFxuICBcbiAgYW5kIHRva2VuMnZhbHVlIDogdG9rZW4gLT4gT2JqLnQgPVxuICAgIGZ1biBfdG9rIC0+XG4gICAgICBtYXRjaCBfdG9rIHdpdGhcbiAgICAgIHwgQU1QIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgQ09MT04gLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBDT0xPTkVRIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgQ09NTUEgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBEQ09MT04gLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBET1QgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBFT0YgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBFUSAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IEVYSVNUUyAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IEZBTFNFIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgRk9SQUxMIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgSURFTlQgX3YgLT5cbiAgICAgICAgICBPYmoucmVwciBfdlxuICAgICAgfCBMQU5EIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgTEFSUk9XIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgTEJSQUNFIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgTE5FRyAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IExPUiAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IExQQVJFTiAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IExSQVJST1cgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBOQVQgX3YgLT5cbiAgICAgICAgICBPYmoucmVwciBfdlxuICAgICAgfCBQTFVTIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgUFJPT0YgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBSQlJBQ0UgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBSRUMgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBSUEFSRU4gLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBTRU1JQ09MT04gLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBTVEFSIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgVFJVRSAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IFRZUEUgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICBcbiAgYW5kIGRlZmF1bHRfcmVkdWN0aW9uID1cbiAgICAoOCwgXCJcXDAwMD5cXDAwMFxcMDAwXFwwMDA8XFwwMTRcXDAwMD1cXHJcXDAwMFxcMDAwLVxcMDAwXFwwMDA7XFwwMDBcXDAxNVxcMDAxXFwwMDA/XFwwMDBAXFwwMThcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMDQ1XFwwMDAzXFwwMDBcXDAwMDI3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDA5XFwwMDBcXDAwMFxcMDIxXFwwMTZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAyM1xcMDAwXFwwMDBcXDAwMFxcMDI3XFwwMDBcXDAxN1xcMDAwXFwwMDJcXDAwMEFcXDAwMEJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwKSBcXDAwN1xcMDAwXFxuXFwwMDBcXDAwMFxcYlxcMDAwXFwwMDBcXDAwMFxcMDAzXFxcIlxcMDAwXFwwMDAkJ1xcMDAwXFwwMDAvXFwwMDBcXDAwMFxcMDAwXFwwMDBDXFwwMDBcXDAwMCtcXDAwMERcXDAwMFxcMDAwJVxcMDA0XFwwMDBFXFwwMDBGXFwwMDVcXDAwMEdcIilcbiAgXG4gIGFuZCBlcnJvciA9XG4gICAgKDMwLCBcIlxcMTI4XFxiIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTMwXFwwMDBcXDAwMydwSFxcMDA0XFxiIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBAXFwwMDBcXDAwMlxcMDAwXFwwMDJcXGJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDEyOFxcMDAwXFwwMDBcXDAxNlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBAXFwwMDBcXDAwMFxcMDAwXFwwMDJcXDEyOChcXDI0MFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDAgXFxuPFxcMDAwXFwxMjgoXFwyNDBcXDAwMElcXDIyMDJcXDAwMVxcMDAyXFxiXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDE4U1xcMDEyXFwxMjhcXDAwMFxcMDAyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMlxcMDAyXFxiIFxcMDAwXFwwMDBcXDAwMFxcMTI4XFwwMDBcXDAwMFxcMDAwXFxiXFwwMDBcXDEzMFxcYlxcMDAwXFwwMDZcXGIgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA1XFwwMTZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBBXFwwMDBcXDAwMFxcMDAwIFxcMTMwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxiIFxcMTI4XFwwMDFcXDIwNFxcYlxcMDI2RzAgaVxcMDE2QFxcMDAwXFwxMjhcXDAwMFxcMDAwXFwwMDJcXDAwMlxcMDAwXFwxNjNcXDE5MlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMCBcXDAwMFxcMDAwXFwwMDBcXDAwMlxcMDAyXFwwMDBcXDE2M1xcMTkyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDBcXDEyOFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMTQ4XFwxOTMgXFwxMjgoXFwyNDBcXDAwMElMXFwwMThcXGJcXDAwMlxcMTQzXFwwMDBcXDAwNFxcMTQ4XFwxOTMgXFwxMjgoXFwyNDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcYlxcMDAyXFwxNDNcXDAwMFxcMDA0XFwxNDhcXDE5MyBcXDAxOFNcXDAwNFxcMTI4XFwwMDBcXDAwMFxcMDAwXFwwMDFcXDAwNTBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBTXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDUwQFxcMDAwXFwwMDBcXDAwMFxcMDAzXFxcIlxcMDAwXFwxMjhcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXGJcXDAwMFxcYlxcMTI4XFwwMDAwXFxiIFxcMTI4XFwwMDFcXDE0MFxcMDAwXFwwMDJcXDAwMiBcXDAwMFxcMDMwXFxuXFwxMzYgIGNcXDAwMlxcMDAwXFwxNDQgXFwxMzBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxMzBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDJcXGJcXDE2MFxcMDAwY1xcMDAyXFwwMDBcXDE0NFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDAgXFwwMDBcXDAwMlxcYiBcXDAwMGNcXDAwMFxcMDAwXFwxMjhcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcYlxcMTI4XFwwMDBcXDAwMFxcMTMwKFxcMjQwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxNDhcXDE5MiBcXDEyOChcXDI0MFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDAgXFwwMDBcXDAwMCBcXG48XFwwMDBcXDAwMFNcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDE2XFwwMDBcXDAwMFxcMDAwXFwwMDBcXGJcXDEyOFxcMDAwIVxcMDAwXFwwMDBcXDEyOFxcMDAwXFwwMDBcXDAwMFxcMDAwIFxcMDAwXFxiXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMEBcXDAwMFxcMTMwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDAgXFwxMzBcXGJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDFcXDAwNFxcMDAwXFwwMTZcXDAwMFxcMDAwXFwwMDBcXDAwMFwiKVxuICBcbiAgYW5kIHN0YXJ0ID1cbiAgICA1XG4gIFxuICBhbmQgYWN0aW9uID1cbiAgICAoKDE2LCBcIlxcMDAwXFwwMDZcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFx0XFwwMDBcXDIzMlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAyNlxcMDAwXFwwMDVcXDAwMFxcMDAwXFwwMDBcXGJcXDAwMEhcXDAwMFxcMDAwXFwwMDBkXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMEZcXDAwMFxcMDAwXFwwMDBcXDEzOFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDEzOFxcMDAwXFwxMzhcXDAwMFxcMDI0XFwwMDBcXDIzMlxcMDAweFxcMDAwZlxcMDAwXFwxMzJcXDAwMHJcXDAwMFxcMTQ4XFwwMDBcXDE1MFxcMDAwXFwxNDRcXDAwMFxcMTQ4XFwwMDBcXDE0OFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDFcXDAzMFxcMDAwXFwwMDBcXDAwMEpcXDAwMFxcMTQ4XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTQ4XFwwMDA4XFwwMDBKXFwwMDFcXDAyNFxcMDAwXFwxNDhcXDAwMFxcMTM4XFwwMDBcXDAwMFxcMDAwXFwxMzJcXDAwMFxcMTYwXFwwMDBcXDEzOFxcMDAwXFwwMDBcXDAwMFxcMTkyXFwwMDBcXDAwNVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE3MlxcMDAwXFwxMzhcXDAwMFxcMjAwXFwwMDBcXDEzOFxcMDAwXFwyMjhcXDAwMFxcMTM4XFwwMDBcXDAwMFxcMDAwXFwxMzhcXDAwMVxcMDAwXFwwMDFcXDAyOFxcMDAwXFwwMDBcXDAwMVxcMTM2XFwwMDBcXDAwMFxcMDAwdlxcMDAwXFwwMDBcXDAwMVxcMTUwXFwwMDBcXDAwMFxcMDAwXFwyMTJcXDAwMFxcMDAwXFwwMDBcXDIwNFxcMDAxXFwwMTJcXDAwMFxcMTQ4XFwwMDFcXDE3MlxcMDAwLFxcMDAwXFwxNDhcXDAwMVxcXFxcXDAwMFxcMTQ4XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFwwMDBcXDAwMWpcXDAwMWBcXDAwMFxcMDAwXFwwMDBcXDIyNlxcMDAwXFwxNDhcXDAwMVxcMTg2XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA1XFwwMDE2XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMWRcXDAwMFxcMTM4XFwwMDBcXDAwMFxcMDAwXFwyNDhcXDAwMFxcMTM4XFwwMDFcXDE4NFxcMDAwXFwyMjRcXDAwMFxcMDAwXFwwMDFEXFwwMDBcXDIxMlxcMDAwXFwwMDBcXDAwMVxcMTY0XFwwMDBcXDAwMFxcMDAxXFwwMDJcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMVxcMDIyXFwwMDBcXDAwMFxcMDAxalxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE4NFxcMDAwXFwwMDBcIiksICgxNiwgXCJcXDAwMFxcMjI5XFwwMDBcXDIyOVxcMDAxXFwxNTBcXDAwMFxcMDA3XFwwMDBcXDIyOVxcMDAwXFxcIlxcMDAwXFwxNDlcXDAwMFxcMjI5XFwwMDBcXDAxOFxcMDAwXFwyMjlcXDAwMFxcblxcMDAwNlxcMDAwXFwyMjlcXDAwMFxcMjI5XFwwMDA6XFwwMDBcXG5cXDAwMFxcMDE0XFwwMDBNXFwwMDBcXDE3M1xcMDAwXFwyMjlcXDAwME1cXDAwMFxcMDE0XFwwMDBcXDIyOVxcMDAwTVxcMDAwblxcMDAwTVxcMDAwXFwwMjFcXDAwMDZcXDAwME1cXDAwME1cXDAwMFxcMDIxXFwwMDBcXDE3MFxcMDAwXFwyMTNcXDAwMFxcMjEzXFwwMDBcXDIyOVxcMDAwTVxcMDAwXFwyMTNcXDAwMFxcMjEzXFwwMDBNXFwwMDAuXFwwMDBcXDE3MFxcMDAwXFwyMjFcXDAwMFxcMjIxXFwwMDA+XFwwMDBcXDIxM1xcMDAwXFwyMjFcXDAwMFxcMTgyXFwwMDFSXFwwMDBcXDAyMVxcMDAxalxcMDAxclxcMDAwXFwyMTNcXDAwMFxcMjEzXFwwMDBcXDIyMVxcMDAwXFwyMTNcXDAwMEZcXDAwMFVcXDAwMFxcMjEzXFwwMDBTXFwwMDBVXFwwMDBcXDIyMVxcMDAwXFwyMjFcXDAwMFVcXDAwMFxcMjIxXFwwMDBVXFwwMDB2XFwwMDBcXDIyMVxcMDAwVVxcMDAwVVxcMDAwW1xcMDAwXFwyNDZcXDAwMF5cXDAwMFxcMjU0XFwwMDBcXDI0MVxcMDAwVVxcMDAxXFwwMTRcXDAwMVxcMDA2XFwwMDBVXFwwMDB5XFwwMDBcXDE1MFxcMDAwXFwxMzRcXDAwMGJcXDAwMHlcXDAwMGZcXDAwMH5cXDAwMFxcMTMwXFwwMDBcXDE0NlxcMDAwalxcMDAwelxcMDAwXFwyMDZcXDAwMFxcMjEwXFwwMDBxXFwwMDBcXDE1NFxcMDAwXFwxMzhcXDAwMHFcXDAwMFxcMTcwXFwwMDBcXDE0MlxcMDAwXFwyNDZcXDAwMFxcMjAyXFwwMDBcXDI1NFxcMDAweVxcMDAwXFwxODJcXDAwMVxcMDE0XFwwMDFcXDAwNlxcMDAwXFwyMThcXDAwMGVcXDAwMTtcXDAwMT5cXDAwMGVcXDAwMHFcXDAwMFxcMTI5XFwwMDBcXDI0NlxcMDAwcVxcMDAwXFwyNTRcXDAwMFxcMTI5XFwwMDFcXDI1NVxcMDAxXFwwMTRcXDAwMVxcMDA2XFwwMDBcXDIzMFxcMDAwXVxcMDAxQlxcMDAwXFwwMjJcXDAwMF1cXDAwMGVcXDAwMU5cXDAwMF1cXDAwMGVcXDAwMF1cXDAwMFxcblxcMDAxXFwxMzBcXDAwMF1cXDAwMVxcMDA2XFwwMDFcXDE3OFxcMDAwYVxcMDAwXFwwMTRcXDAwMVxcMTkxXFwwMDBhXFwwMDBdXFwwMDApXFwwMDBcXDI0NlxcMDAwXVxcMDAwXFwyNTRcXDAwMClcXDAwMFxcMTcwXFwwMDFcXDAxNFxcMDAxXFwwMDZcXDAwMFxcMTk3XFwwMDBtXFwwMDBcXDE2MlxcMDAwXFwxODJcXDAwMG1cXDAwMGFcXDAwMFxcMTk3XFwwMDBcXDI0NlxcMDAwYVxcMDAwXFwyNTRcXDAwMVxcMjE4XFwwMDBeXFwwMDFcXDAxNFxcMDAxXFwwMDZcXDAwMClcXDAwMUZcXDAwMVxcMjM1XFwwMDBcXDEzN1xcMDAwXFwxOTNcXDAwMG1cXDAwMFxcMTY1XFwwMDBiXFwwMDBtXFwwMDBmXFwwMDBcXDE2NVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBqXFwwMDB6XFwwMDBcXDIwNlxcMDAwXFwyMTBcXDAwMFxcMTcwXFwwMDBcXDE1N1xcMDAwXFwxNzBcXDAwMCFcXDAwMVxcMjQzXFwwMDBcXDE1N1xcMDAwXFwxODJcXDAwMCFcXDAwMFxcMTgyXFwwMDBcXDE4MVxcMDAwXFwxMzRcXDAwMVxcMTk4XFwwMDBcXDI0NlxcMDAwXFwxNTdcXDAwMFxcMjU0XFwwMDBcXDE1N1xcMDAwXFwxNDZcXDAwMVxcMDE0XFwwMDFcXDAwNlxcMDAwXFwwMDBcXDAwMHlcXDAwMFxcMDAwXFwwMDBcXDE1NFxcMDAwXFwxNTdcXDAwMVxcXCJcXDAwMCFcXDAwMVpcXDAwMVxcMTY2XFwwMDFaXFwwMDBcXDAwMFxcMDAwPVxcMDAwXFwwMDBcXDAwMD1cXDAwMVxcMjExXFwwMDBcXDAwMFxcMDAwPVxcMDAwPVxcMDAwXFwyNDZcXDAwMFxcMDAwXFwwMDBcXDI1NFxcMDAwXFwxNzBcXDAwMC1cXDAwMVxcMDE0XFwwMDFcXDAwNlxcMDAwXFwwMDBcXDAwMC1cXDAwMFxcMTgyXFwwMDBcXDE3MFxcMDAwXFwxODlcXDAwMTNcXDAwMFxcMDAwXFwwMDFcXDIxNFxcMDAwXFwxODlcXDAwMFxcMTgyXFwwMDBcXDI0NlxcMDAwXFwwMDBcXDAwMFxcMjU0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMVxcMDE0XFwwMDFcXDAwNlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDAtXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMHVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTg5XCIpKVxuICBcbiAgYW5kIGxocyA9XG4gICAgKDgsIFwiXFwwMDRcXDAwM1xcMDAyXFwwMDFcXDAwMFxcMDMwXFwwMzBcXDAzMFxcMDMwXFwwMzBcXDAzMFxcMDMwXFwwMjlcXDAyOFxcMDI4XFwwMjdcXDAyNlxcMDI2XFwwMjZcXDAyNlxcMDI2XFwwMjZcXDAyNlxcMDI2XFwwMjZcXDAyNlxcMDI2XFwwMjZcXDAyNlxcMDI1XFwwMjRcXDAyNFxcMDIzXFwwMjNcXDAyMlxcMDIyXFwwMjFcXDAyMFxcMDIwXFwwMTlcXDAxOVxcMDE4XFwwMThcXDAxN1xcMDE3XFwwMTZcXDAxNlxcMDE1XFwwMTRcXHJcXDAxMlxcMDEyXFwwMTJcXDAxMlxcMDEyXFwwMTJcXDAxMVxcblxcblxcblxcblxcdFxcdFxcYlxcYlxcMDA3XFwwMDdcXDAwNlxcMDA2XFwwMDVcXDAwNVwiKVxuICBcbiAgYW5kIGdvdG8gPVxuICAgICgoOCwgXCIyXFwwMDBEXFwwMDA6XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwQFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcclxcMDAwXFwwMDBQWlxcMDAwRlxcMDAwXFwwMDBcXG5cXDAwMFxcMDAyXFwwMDBcXDAwMFxcMTg0XFwxOTBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxOTRcXDAwMFxcMDAwXFwyMDBcXDAwMFxcMDAwXFwwMDBcXDAwMHRcXDAwMFpcXDAwMH5cXDAwMFxcMDAwXFwyMDhcXDAwMFxcMDAwXFwwMDBcXDEzMFxcMDAwXFwxMzRcXDAwMFxcMTM4XFwwMDBcXDE0MlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyMDhcXDAwMFxcMDAwXFwxNzRcXDAwMFxcdFxcMDAwXFwwMDBcXDAwMFxcMDI0XFwwMDBcXDAyOFxcMDAwXFwwMDBcXDAwMFxcMjE4XFwwMDBcXDAwMFxcMDAwWlxcMDIxXFwwMDBcXDAwMFxcMDAwKlxcMDAwXFwwMDBcXDE1MlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTJcXDAwMCxcXDAwMFxcMDAwXFwxODJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDBcIiksICg4LCBcIjg5S344OWdjLFYsXFwxMjdoLDFYPGlkMjxMXFwwMDdlc28sXnlfcTg5WVxcMDE5XFwwMDdxa2BcXDAwN1xcblxcXFxcXDAwN3pcXDAwN1xcMDA3XFxiPGlcXHI4OVxcMDI5XFxuXFwwMjA4OVxcblxcMDExNlxcblxcMDExXFwwMTdcXG5cXDAxMWxISjg5XFwwMDA8Rzg5ODk4OTg5ODlcXDAwMDxGODlcXDAwMDw9PD88QTxDPEUsVlxcMDA3PG4sMFkoKiwtWiwvODssU1xcMDAwXFxueCxiXCIpKVxuICBcbiAgYW5kIHNlbWFudGljX2FjdGlvbiA9XG4gICAgW3xcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHggOiAoXG4jIDYgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgICAoU3ludGF4LnN5bWJvbClcbiMgMjI5IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF92ID1cbiAgICAgICAgICBsZXQgeCA9XG4gICAgICAgICAgICBsZXQgeCA9XG4gICAgICAgICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194XyBpblxuICAgICAgICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgICAgICAgIFxuIyAyMjIgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgIChcbiAgICB7IHBsZGVzYyA9IHg7XG4gICAgICBwbGxvYyAgPSBMb2NhdGlvbi5tYWtlIF9zdGFydHBvcyBfZW5kcG9zO1xuICAgIH1cbiAgKVxuIyAyNDYgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBcbiMgODEgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIHggKVxuIyAyNTIgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICAgXG4gICAgICAgICAgaW5cbiAgICAgICAgICAoXG4jIDE5NSBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICggUFByb3AgKHgsIFtdKSApXG4jIDI1OCBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgIDogKFN5bnRheC5wdmFyKSlcbiAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHhzO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeHNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194c187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geDtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB4cyA6IChTeW50YXgucGFyaXR5KSA9IE9iai5tYWdpYyB4cyBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCB4IDogKFxuIyA2IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgKFN5bnRheC5zeW1ib2wpXG4jIDI5NCBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hzXyBpblxuICAgICAgICBsZXQgX3YgPVxuICAgICAgICAgIGxldCB4dHkgPVxuICAgICAgICAgICAgbGV0IHR5cyA9XG4gICAgICAgICAgICAgIGxldCBhb3V0ID0gXG4jIDIyOSBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHhzIClcbiMgMzA1IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgIFxuIyAyMzggXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGFvdXQgKVxuIyAzMTAgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBcbiMgMTg2IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgKCB0eXMgKVxuIyAzMTYgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICAgXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgeCA9XG4gICAgICAgICAgICBsZXQgeCA9XG4gICAgICAgICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194XyBpblxuICAgICAgICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgICAgICAgIFxuIyAyMjIgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgIChcbiAgICB7IHBsZGVzYyA9IHg7XG4gICAgICBwbGxvYyAgPSBMb2NhdGlvbi5tYWtlIF9zdGFydHBvcyBfZW5kcG9zO1xuICAgIH1cbiAgKVxuIyAzMzAgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBcbiMgODEgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIHggKVxuIyAzMzYgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICAgXG4gICAgICAgICAgaW5cbiAgICAgICAgICAoXG4jIDE5OCBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICggUFByb3AgKHgsIHh0eSkgKVxuIyAzNDIgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICA6IChTeW50YXgucHZhcikpXG4gICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4dHk7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194dHlfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194dHlfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzI7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgeHR5IDogKFN5bnRheC5wc2lnbmF0dXJlKSA9IE9iai5tYWdpYyB4dHkgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgeCA6IChcbiMgNiBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICAgIChTeW50YXguc3ltYm9sKVxuIyAzNzggXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIHggaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194dHlfIGluXG4gICAgICAgIGxldCBfdiA9XG4gICAgICAgICAgbGV0IHggPVxuICAgICAgICAgICAgbGV0IHggPVxuICAgICAgICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeF8gaW5cbiAgICAgICAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICAgICAgICBcbiMgMjIyIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAoXG4gICAgeyBwbGRlc2MgPSB4O1xuICAgICAgcGxsb2MgID0gTG9jYXRpb24ubWFrZSBfc3RhcnRwb3MgX2VuZHBvcztcbiAgICB9XG4gIClcbiMgMzk1IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgXG4jIDgxIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCB4IClcbiMgNDAxIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgIFxuICAgICAgICAgIGluXG4gICAgICAgICAgKFxuIyAyMDEgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAoIFBGdW4gKHgsIHh0eSkgKVxuIyA0MDcgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICA6IChTeW50YXgucHZhcikpXG4gICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4dHk7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194dHlfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194dHlfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzI7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgeHR5IDogKFN5bnRheC5wdHlwZSkgPSBPYmoubWFnaWMgeHR5IGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IHggOiAoXG4jIDYgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgICAoU3ludGF4LnN5bWJvbClcbiMgNDQzIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeHR5XyBpblxuICAgICAgICBsZXQgX3YgPVxuICAgICAgICAgIGxldCB4ID1cbiAgICAgICAgICAgIGxldCB4ID1cbiAgICAgICAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hfIGluXG4gICAgICAgICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgICAgICAgXG4jIDIyMiBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICAgKFxuICAgIHsgcGxkZXNjID0geDtcbiAgICAgIHBsbG9jICA9IExvY2F0aW9uLm1ha2UgX3N0YXJ0cG9zIF9lbmRwb3M7XG4gICAgfVxuICApXG4jIDQ2MCBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIFxuIyA4MSBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICggeCApXG4jIDQ2NiBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgICBcbiAgICAgICAgICBpblxuICAgICAgICAgIChcbiMgMjA0IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgKCBQVmFyICh4LCB4dHkpIClcbiMgNDcyIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgOiAoU3ludGF4LnB2YXIpKVxuICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gYm9keTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2JvZHlfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19ib2R5XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4O1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGJvZHkgOiAoU3ludGF4LnBleHByKSA9IE9iai5tYWdpYyBib2R5IGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IHggOiAoXG4jIDYgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgICAoU3ludGF4LnN5bWJvbClcbiMgNTA4IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfYm9keV8gaW5cbiAgICAgICAgbGV0IF92ID1cbiAgICAgICAgICBsZXQgeCA9XG4gICAgICAgICAgICBsZXQgeCA9XG4gICAgICAgICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194XyBpblxuICAgICAgICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgICAgICAgIFxuIyAyMjIgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgIChcbiAgICB7IHBsZGVzYyA9IHg7XG4gICAgICBwbGxvYyAgPSBMb2NhdGlvbi5tYWtlIF9zdGFydHBvcyBfZW5kcG9zO1xuICAgIH1cbiAgKVxuIyA1MjUgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBcbiMgODEgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIHggKVxuIyA1MzEgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICAgXG4gICAgICAgICAgaW5cbiAgICAgICAgICAoXG4jIDIwNyBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICggUEV4cHIgKHgsIGJvZHkpIClcbiMgNTM3IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgOiAoU3ludGF4LnB2YXIpKVxuICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHggOiAoXG4jIDYgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgICAoU3ludGF4LnN5bWJvbClcbiMgNTY1IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF92ID1cbiAgICAgICAgICBsZXQgYSA9XG4gICAgICAgICAgICBsZXQgeCA9XG4gICAgICAgICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194XyBpblxuICAgICAgICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgICAgICAgIFxuIyAyMjIgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgIChcbiAgICB7IHBsZGVzYyA9IHg7XG4gICAgICBwbGxvYyAgPSBMb2NhdGlvbi5tYWtlIF9zdGFydHBvcyBfZW5kcG9zO1xuICAgIH1cbiAgKVxuIyA1ODMgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBcbiMgODEgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIHggKVxuIyA1ODkgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICAgXG4gICAgICAgICAgaW5cbiAgICAgICAgICAoXG4jIDIxMCBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICggUFRWYXIgYSApXG4jIDU5NSBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgIDogKFN5bnRheC5wdmFyKSlcbiAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHQ7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzNfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18zXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB0IDogKFN5bnRheC5wdHlwZSkgPSBPYmoubWFnaWMgdCBpblxuICAgICAgICBsZXQgXzMgOiB1bml0ID0gT2JqLm1hZ2ljIF8zIGluXG4gICAgICAgIGxldCB4IDogKFxuIyA2IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgKFN5bnRheC5zeW1ib2wpXG4jIDYzNyBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3RfIGluXG4gICAgICAgIGxldCBfdiA9XG4gICAgICAgICAgbGV0IGEgPVxuICAgICAgICAgICAgbGV0IHggPVxuICAgICAgICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeF8gaW5cbiAgICAgICAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICAgICAgICBcbiMgMjIyIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAoXG4gICAgeyBwbGRlc2MgPSB4O1xuICAgICAgcGxsb2MgID0gTG9jYXRpb24ubWFrZSBfc3RhcnRwb3MgX2VuZHBvcztcbiAgICB9XG4gIClcbiMgNjU1IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgXG4jIDgxIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCB4IClcbiMgNjYxIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgIFxuICAgICAgICAgIGluXG4gICAgICAgICAgKFxuIyAyMTMgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAoIFBUeXBlIChhLCB0KSApXG4jIDY2NyBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgIDogKFN5bnRheC5wdmFyKSlcbiAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB4IDogKFN5bnRheC5wZXhwcl9yKSA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF92ID1cbiAgICAgICAgICBsZXQgZSA9XG4gICAgICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeF8gaW5cbiAgICAgICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgICAgIFxuIyAyMjIgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgIChcbiAgICB7IHBsZGVzYyA9IHg7XG4gICAgICBwbGxvYyAgPSBMb2NhdGlvbi5tYWtlIF9zdGFydHBvcyBfZW5kcG9zO1xuICAgIH1cbiAgKVxuIyA3MDEgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICAgXG4gICAgICAgICAgaW5cbiAgICAgICAgICAoXG4jIDEzMyBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICggZSApXG4jIDcwNyBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgIDogKFN5bnRheC5wZXhwcikpXG4gICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGU7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgZSA6IChTeW50YXgucGV4cHJfcikgPSBPYmoubWFnaWMgZSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2VfIGluXG4gICAgICAgIGxldCBfdiA6IChTeW50YXgucGV4cHJfcikgPSBcbiMgMTI1IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgKCBlIClcbiMgNzMzIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18zXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geDtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzMgOiB1bml0ID0gT2JqLm1hZ2ljIF8zIGluXG4gICAgICAgIGxldCB4IDogKFN5bnRheC5wZXhwcl9yKSA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzNfIGluXG4gICAgICAgIGxldCBfdiA9XG4gICAgICAgICAgbGV0IGUgPSBcbiMgMjM0IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICggeCApXG4jIDc3MyBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgIGluXG4gICAgICAgICAgKFxuIyAxMjcgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAoIGUgKVxuIyA3NzggXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICA6IChTeW50YXgucGV4cHJfcikpXG4gICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgeCA6IChTeW50YXgucGZvcm1fcikgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hfIGluXG4gICAgICAgIGxldCBfdiA9XG4gICAgICAgICAgbGV0IGYgPVxuICAgICAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hfIGluXG4gICAgICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgICAgICBcbiMgMjIyIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAoXG4gICAgeyBwbGRlc2MgPSB4O1xuICAgICAgcGxsb2MgID0gTG9jYXRpb24ubWFrZSBfc3RhcnRwb3MgX2VuZHBvcztcbiAgICB9XG4gIClcbiMgODEyIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgIFxuICAgICAgICAgIGluXG4gICAgICAgICAgKFxuIyAxODEgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAoIGYgKVxuIyA4MTggXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICA6IChTeW50YXgucGZvcm0pKVxuICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzM7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fM187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18zXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8zIDogdW5pdCA9IE9iai5tYWdpYyBfMyBpblxuICAgICAgICBsZXQgeCA6IChTeW50YXgucGZvcm1fcikgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18zXyBpblxuICAgICAgICBsZXQgX3YgPVxuICAgICAgICAgIGxldCBmID0gXG4jIDIzNCBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAoIHggKVxuIyA4NTkgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICBpblxuICAgICAgICAgIChcbiMgMTQyIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgKCBmIClcbiMgODY0IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgOiAoU3ludGF4LnBmb3JtX3IpKVxuICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF92IDogKFN5bnRheC5wZm9ybV9yKSA9IFxuIyAxNDUgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICggUEZDc3QgdHJ1ZSApXG4jIDg5MCBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF92IDogKFN5bnRheC5wZm9ybV9yKSA9IFxuIyAxNDggXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICggUEZDc3QgZmFsc2UgKVxuIyA5MTUgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB4IDogKFxuIyA2IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgKFN5bnRheC5zeW1ib2wpXG4jIDkzNiBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hfIGluXG4gICAgICAgIGxldCBfdiA9XG4gICAgICAgICAgbGV0IHggPVxuICAgICAgICAgICAgbGV0IHggPVxuICAgICAgICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeF8gaW5cbiAgICAgICAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICAgICAgICBcbiMgMjIyIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAoXG4gICAgeyBwbGRlc2MgPSB4O1xuICAgICAgcGxsb2MgID0gTG9jYXRpb24ubWFrZSBfc3RhcnRwb3MgX2VuZHBvcztcbiAgICB9XG4gIClcbiMgOTUzIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgXG4jIDgxIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCB4IClcbiMgOTU5IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgIFxuICAgICAgICAgIGluXG4gICAgICAgICAgKFxuIyAxNTEgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAoIFBGQXBwICh4LCBbXSkgKVxuIyA5NjUgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICA6IChTeW50YXgucGZvcm1fcikpXG4gICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlMjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2UyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZTJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzI7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGUxO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2UxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2UxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgZTIgOiAoU3ludGF4LnBleHByX3IgTG9jYXRpb24ubG9jZWQpID0gT2JqLm1hZ2ljIGUyIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IGUxIDogKFN5bnRheC5wZXhwcl9yIExvY2F0aW9uLmxvY2VkKSA9IE9iai5tYWdpYyBlMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZTFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lMl8gaW5cbiAgICAgICAgbGV0IF92IDogKFN5bnRheC5wZm9ybV9yKSA9IFxuIyAxNTQgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAoIFBGQXBwIChta2xvYyBfZHVtbXkgXCJfRVFcIiwgW2UxOyBlMl0pIClcbiMgMTAwNSBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzM7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fM187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18zXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGFvdXQ7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2FvdXRfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2FvdXRfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4O1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8zIDogdW5pdCA9IE9iai5tYWdpYyBfMyBpblxuICAgICAgICBsZXQgYW91dCA6IChTeW50YXgucGV4cHIgbGlzdCkgPSBPYmoubWFnaWMgYW91dCBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCB4IDogKFxuIyA2IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgKFN5bnRheC5zeW1ib2wpXG4jIDEwNDcgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIHggaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fM18gaW5cbiAgICAgICAgbGV0IF92ID1cbiAgICAgICAgICBsZXQgYXJncyA9XG4gICAgICAgICAgICBsZXQgeCA9IFxuIyAyNDggXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGFvdXQgKVxuIyAxMDU3IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgXG4jIDIzNCBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAoIHggKVxuIyAxMDYyIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgIFxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IHggPVxuICAgICAgICAgICAgbGV0IHggPVxuICAgICAgICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeF8gaW5cbiAgICAgICAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICAgICAgICBcbiMgMjIyIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAoXG4gICAgeyBwbGRlc2MgPSB4O1xuICAgICAgcGxsb2MgID0gTG9jYXRpb24ubWFrZSBfc3RhcnRwb3MgX2VuZHBvcztcbiAgICB9XG4gIClcbiMgMTA3NiBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIFxuIyA4MSBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICggeCApXG4jIDEwODIgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICAgXG4gICAgICAgICAgaW5cbiAgICAgICAgICAoXG4jIDE1NyBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICggUEZBcHAgKHgsIGFyZ3MpIClcbiMgMTA4OCBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgIDogKFN5bnRheC5wZm9ybV9yKSlcbiAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGYyO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZjJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19mMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZjE7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZjFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZjFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBmMiA6IChTeW50YXgucGZvcm0pID0gT2JqLm1hZ2ljIGYyIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IGYxIDogKFN5bnRheC5wZm9ybSkgPSBPYmoubWFnaWMgZjEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2YxXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZjJfIGluXG4gICAgICAgIGxldCBfdiA6IChTeW50YXgucGZvcm1fcikgPSBcbiMgMTYwIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgKCBQRkFuZCAoZjEsIGYyKSApXG4jIDExMjggXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGYyO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZjJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19mMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZjE7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZjFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZjFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBmMiA6IChTeW50YXgucGZvcm0pID0gT2JqLm1hZ2ljIGYyIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IGYxIDogKFN5bnRheC5wZm9ybSkgPSBPYmoubWFnaWMgZjEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2YxXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZjJfIGluXG4gICAgICAgIGxldCBfdiA6IChTeW50YXgucGZvcm1fcikgPSBcbiMgMTYzIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgKCBQRk9yIChmMSwgZjIpIClcbiMgMTE2NyBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZjI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19mMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2YyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBmMTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19mMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19mMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGYyIDogKFN5bnRheC5wZm9ybSkgPSBPYmoubWFnaWMgZjIgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgZjEgOiAoU3ludGF4LnBmb3JtKSA9IE9iai5tYWdpYyBmMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZjFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19mMl8gaW5cbiAgICAgICAgbGV0IF92IDogKFN5bnRheC5wZm9ybV9yKSA9IFxuIyAxNjYgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAoIFBGSW1wIChmMSwgZjIpIClcbiMgMTIwNiBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZjI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19mMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2YyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBmMTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19mMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19mMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGYyIDogKFN5bnRheC5wZm9ybSkgPSBPYmoubWFnaWMgZjIgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgZjEgOiAoU3ludGF4LnBmb3JtKSA9IE9iai5tYWdpYyBmMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZjFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19mMl8gaW5cbiAgICAgICAgbGV0IF92IDogKFN5bnRheC5wZm9ybV9yKSA9IFxuIyAxNjkgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAoIFBGRXF1aXYgKGYxLCBmMikgKVxuIyAxMjQ1IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBmO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2ZfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgZiA6IChTeW50YXgucGZvcm0pID0gT2JqLm1hZ2ljIGYgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19mXyBpblxuICAgICAgICBsZXQgX3YgOiAoU3ludGF4LnBmb3JtX3IpID0gXG4jIDE3MiBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICggUEZOb3QgZiApXG4jIDEyNzcgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGY7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19mXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzNfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18zXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHh0eTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194dHlfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeHR5XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBmIDogKFN5bnRheC5wZm9ybSkgPSBPYmoubWFnaWMgZiBpblxuICAgICAgICBsZXQgXzMgOiB1bml0ID0gT2JqLm1hZ2ljIF8zIGluXG4gICAgICAgIGxldCB4dHkgOiAoU3ludGF4LnB0eWlkZW50KSA9IE9iai5tYWdpYyB4dHkgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19mXyBpblxuICAgICAgICBsZXQgX3YgOiAoU3ludGF4LnBmb3JtX3IpID0gXG4jIDE3NSBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICggUEZGb3JhbGwgKHh0eSwgZikgKVxuIyAxMzIzIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBmO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2ZfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzM7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18zXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fM187XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4dHk7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeHR5XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3h0eV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgZiA6IChTeW50YXgucGZvcm0pID0gT2JqLm1hZ2ljIGYgaW5cbiAgICAgICAgbGV0IF8zIDogdW5pdCA9IE9iai5tYWdpYyBfMyBpblxuICAgICAgICBsZXQgeHR5IDogKFN5bnRheC5wdHlpZGVudCkgPSBPYmoubWFnaWMgeHR5IGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZl8gaW5cbiAgICAgICAgbGV0IF92IDogKFN5bnRheC5wZm9ybV9yKSA9IFxuIyAxNzggXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAoIFBGRXhpc3RzICh4dHksIGYpIClcbiMgMTM2OSBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2ZfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19mXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8zO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fM187XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzNfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gaHM7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfaHNfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfaHNfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4cztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hzXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeHNfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGYgOiAoU3ludGF4LnBmb3JtKSA9IE9iai5tYWdpYyBmIGluXG4gICAgICAgIGxldCBfMyA6IHVuaXQgPSBPYmoubWFnaWMgXzMgaW5cbiAgICAgICAgbGV0IGhzIDogKFN5bnRheC5wZm9ybSBsaXN0IG9wdGlvbikgPSBPYmoubWFnaWMgaHMgaW5cbiAgICAgICAgbGV0IHhzIDogKFN5bnRheC5wdmFyIGxpc3QpID0gT2JqLm1hZ2ljIHhzIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194c18gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2ZfIGluXG4gICAgICAgIGxldCBfdiA9XG4gICAgICAgICAgbGV0IHBzID1cbiAgICAgICAgICAgIGxldCBhb3V0ID0gXG4jIDIyOSBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHhzIClcbiMgMTQxNyBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIFxuIyAyMzggXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGFvdXQgKVxuIyAxNDIyIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgIFxuICAgICAgICAgIGluXG4gICAgICAgICAgKFxuIyAyMTggXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAoIChwcywgQmF0T3B0aW9uLmRlZmF1bHQgW10gaHMsIGYpIClcbiMgMTQyOCBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgIDogKFN5bnRheC5wZ29hbCkpXG4gICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLmN1cnJlbnQgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgX3YgOiAoU3ludGF4LnBhcml0eSkgPSBcbiMgMTM5IFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggW10gKVxuIyAxNDQ3IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgeCA6IChTeW50YXgucGFyaXR5KSA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF92IDogKFN5bnRheC5wYXJpdHkpID0gXG4jIDE0MSBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHggKVxuIyAxNDcyIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLmN1cnJlbnQgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgX3YgOiAoU3ludGF4LnB2YXIgbGlzdCkgPSBcbiMgMTM5IFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggW10gKVxuIyAxNDkwIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgeCA6IChTeW50YXgucHZhciBsaXN0KSA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF92IDogKFN5bnRheC5wdmFyIGxpc3QpID0gXG4jIDE0MSBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHggKVxuIyAxNTE1IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLmN1cnJlbnQgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgX3YgOiAoU3ludGF4LnBmb3JtIGxpc3QpID0gXG4jIDEzOSBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIFtdIClcbiMgMTUzMyBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHggOiAoU3ludGF4LnBmb3JtIGxpc3QpID0gT2JqLm1hZ2ljIHggaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194XyBpblxuICAgICAgICBsZXQgX3YgOiAoU3ludGF4LnBmb3JtIGxpc3QpID0gXG4jIDE0MSBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHggKVxuIyAxNTU4IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2VfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzI7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgZSA6IChTeW50YXgucGV4cHIpID0gT2JqLm1hZ2ljIGUgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgeCA6IChcbiMgNiBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICAgIChTeW50YXguc3ltYm9sKVxuIyAxNTkzIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZV8gaW5cbiAgICAgICAgbGV0IF92ID1cbiAgICAgICAgICBsZXQgeCA9XG4gICAgICAgICAgICBsZXQgeCA9XG4gICAgICAgICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194XyBpblxuICAgICAgICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgICAgICAgIFxuIyAyMjIgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgIChcbiAgICB7IHBsZGVzYyA9IHg7XG4gICAgICBwbGxvYyAgPSBMb2NhdGlvbi5tYWtlIF9zdGFydHBvcyBfZW5kcG9zO1xuICAgIH1cbiAgKVxuIyAxNjEwIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgXG4jIDgxIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCB4IClcbiMgMTYxNiBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgICBcbiAgICAgICAgICBpblxuICAgICAgICAgIChcbiMgMTM3IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgKCAoeCwgZSkgKVxuIyAxNjIyIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgOiAoU3ludGF4LnBuZXhwcikpXG4gICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLmN1cnJlbnQgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgX3YgOiAoU3ludGF4LnBmb3JtIGxpc3Qgb3B0aW9uKSA9IFxuIyAxMTEgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCBOb25lIClcbiMgMTY0MSBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geHM7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194c187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hzXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHhzIDogKFN5bnRheC5wZm9ybSBsaXN0KSA9IE9iai5tYWdpYyB4cyBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hzXyBpblxuICAgICAgICBsZXQgX3YgPVxuICAgICAgICAgIGxldCB4ID1cbiAgICAgICAgICAgIGxldCB4ID1cbiAgICAgICAgICAgICAgbGV0IGFvdXQgPSBcbiMgMjI5IFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggeHMgKVxuIyAxNjc2IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgIFxuIyAyMzggXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGFvdXQgKVxuIyAxNjgxIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgXG4jIDE4MCBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHggKVxuIyAxNjg3IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgIFxuICAgICAgICAgIGluXG4gICAgICAgICAgKFxuIyAxMTMgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCBTb21lIHggKVxuIyAxNjkzIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgOiAoU3ludGF4LnBmb3JtIGxpc3Qgb3B0aW9uKSlcbiAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB4IDogKFN5bnRheC5wdHlwZSkgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hfIGluXG4gICAgICAgIGxldCBfdiA6IChTeW50YXgucGFyaXR5KSA9IFxuIyAyMzggXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCBbIHggXSApXG4jIDE3MTkgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHhzO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeHNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194c187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geDtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB4cyA6IChTeW50YXgucGFyaXR5KSA9IE9iai5tYWdpYyB4cyBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCB4IDogKFN5bnRheC5wdHlwZSkgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hzXyBpblxuICAgICAgICBsZXQgX3YgOiAoU3ludGF4LnBhcml0eSkgPSBcbiMgMjQwIFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggeCA6OiB4cyApXG4jIDE3NTggXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB4IDogKFN5bnRheC5wdmFyKSA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF92IDogKFN5bnRheC5wdmFyIGxpc3QpID0gXG4jIDIzOCBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIFsgeCBdIClcbiMgMTc4MyBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geHM7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194c187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hzXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4O1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHhzIDogKFN5bnRheC5wdmFyIGxpc3QpID0gT2JqLm1hZ2ljIHhzIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IHggOiAoU3ludGF4LnB2YXIpID0gT2JqLm1hZ2ljIHggaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194c18gaW5cbiAgICAgICAgbGV0IF92IDogKFN5bnRheC5wdmFyIGxpc3QpID0gXG4jIDI0MCBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHggOjogeHMgKVxuIyAxODIyIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgeCA6IChTeW50YXgucGV4cHIpID0gT2JqLm1hZ2ljIHggaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194XyBpblxuICAgICAgICBsZXQgX3YgOiAoU3ludGF4LnBleHByIGxpc3QpID0gXG4jIDIzOCBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIFsgeCBdIClcbiMgMTg0NyBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geHM7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194c187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hzXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4O1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHhzIDogKFN5bnRheC5wZXhwciBsaXN0KSA9IE9iai5tYWdpYyB4cyBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCB4IDogKFN5bnRheC5wZXhwcikgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hzXyBpblxuICAgICAgICBsZXQgX3YgOiAoU3ludGF4LnBleHByIGxpc3QpID0gXG4jIDI0MCBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHggOjogeHMgKVxuIyAxODg2IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgeCA6IChTeW50YXgucGZvcm0pID0gT2JqLm1hZ2ljIHggaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194XyBpblxuICAgICAgICBsZXQgX3YgOiAoU3ludGF4LnBmb3JtIGxpc3QpID0gXG4jIDIzOCBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIFsgeCBdIClcbiMgMTkxMSBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geHM7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194c187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hzXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4O1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHhzIDogKFN5bnRheC5wZm9ybSBsaXN0KSA9IE9iai5tYWdpYyB4cyBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCB4IDogKFN5bnRheC5wZm9ybSkgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hzXyBpblxuICAgICAgICBsZXQgX3YgOiAoU3ludGF4LnBmb3JtIGxpc3QpID0gXG4jIDI0MCBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHggOjogeHMgKVxuIyAxOTUwIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0eTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3R5XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdHlfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzI7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHhzO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hzXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hzXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgdHkgOiAoU3ludGF4LnB0eXBlKSA9IE9iai5tYWdpYyB0eSBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCB4cyA6IChTeW50YXgucGFyaXR5KSA9IE9iai5tYWdpYyB4cyBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeHNfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc190eV8gaW5cbiAgICAgICAgbGV0IF92ID1cbiAgICAgICAgICBsZXQgYXIgPVxuICAgICAgICAgICAgbGV0IHR5cyA9XG4gICAgICAgICAgICAgIGxldCBhb3V0ID0gXG4jIDIyOSBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHhzIClcbiMgMTk5MiBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICBcbiMgMjM4IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBhb3V0IClcbiMgMTk5NyBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIFxuIyAxODYgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAoIHR5cyApXG4jIDIwMDMgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICAgXG4gICAgICAgICAgaW5cbiAgICAgICAgICAoXG4jIDE5MCBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICggKGFyLCB0eSkgKVxuIyAyMDA5IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgOiAoU3ludGF4LnBzaWduYXR1cmUpKVxuICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdHk7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190eV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3R5XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4O1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHR5IDogKFN5bnRheC5wdHlwZSkgPSBPYmoubWFnaWMgdHkgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgeCA6IChcbiMgNiBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICAgIChTeW50YXguc3ltYm9sKVxuIyAyMDQ1IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfdHlfIGluXG4gICAgICAgIGxldCBfdiA9XG4gICAgICAgICAgbGV0IHggPVxuICAgICAgICAgICAgbGV0IHggPVxuICAgICAgICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeF8gaW5cbiAgICAgICAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICAgICAgICBcbiMgMjIyIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAoXG4gICAgeyBwbGRlc2MgPSB4O1xuICAgICAgcGxsb2MgID0gTG9jYXRpb24ubWFrZSBfc3RhcnRwb3MgX2VuZHBvcztcbiAgICB9XG4gIClcbiMgMjA2MiBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIFxuIyA4MSBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICggeCApXG4jIDIwNjggXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICAgXG4gICAgICAgICAgaW5cbiAgICAgICAgICAoXG4jIDg0IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgKCAoeCwgdHkpIClcbiMgMjA3NCBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgIDogKFN5bnRheC5wdHlpZGVudCkpXG4gICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgeCA6IChTeW50YXgucHR5cGVfcikgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hfIGluXG4gICAgICAgIGxldCBfdiA9XG4gICAgICAgICAgbGV0IHQgPVxuICAgICAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hfIGluXG4gICAgICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgICAgICBcbiMgMjIyIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAoXG4gICAgeyBwbGRlc2MgPSB4O1xuICAgICAgcGxsb2MgID0gTG9jYXRpb24ubWFrZSBfc3RhcnRwb3MgX2VuZHBvcztcbiAgICB9XG4gIClcbiMgMjEwOCBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgICBcbiAgICAgICAgICBpblxuICAgICAgICAgIChcbiMgMTA3IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgKCB0IClcbiMgMjExNCBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgIDogKFN5bnRheC5wdHlwZSkpXG4gICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18zXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geDtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzMgOiB1bml0ID0gT2JqLm1hZ2ljIF8zIGluXG4gICAgICAgIGxldCB4IDogKFN5bnRheC5wdHlwZV9yKSA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzNfIGluXG4gICAgICAgIGxldCBfdiA9XG4gICAgICAgICAgbGV0IHQgPSBcbiMgMjM0IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICggeCApXG4jIDIxNTUgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICBpblxuICAgICAgICAgIChcbiMgODkgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAoIHQgKVxuIyAyMTYwIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgOiAoU3ludGF4LnB0eXBlX3IpKVxuICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzM7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fM187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18zXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8zIDogdW5pdCA9IE9iai5tYWdpYyBfMyBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18zXyBpblxuICAgICAgICBsZXQgX3YgPVxuICAgICAgICAgIGxldCBfMSA9XG4gICAgICAgICAgICBsZXQgeCA9IFxuIyAyMzAgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgKCAoKSApXG4jIDIxOTUgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBcbiMgMjM0IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICggeCApXG4jIDIyMDAgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICAgXG4gICAgICAgICAgaW5cbiAgICAgICAgICAoXG4jIDkyIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgKCBQVFVuaXQgKVxuIyAyMjA2IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgOiAoU3ludGF4LnB0eXBlX3IpKVxuICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHggOiAoXG4jIDYgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgICAoU3ludGF4LnN5bWJvbClcbiMgMjIyOCBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hfIGluXG4gICAgICAgIGxldCBfdiA9XG4gICAgICAgICAgbGV0IHggPVxuICAgICAgICAgICAgbGV0IHggPVxuICAgICAgICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeF8gaW5cbiAgICAgICAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICAgICAgICBcbiMgMjIyIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAoXG4gICAgeyBwbGRlc2MgPSB4O1xuICAgICAgcGxsb2MgID0gTG9jYXRpb24ubWFrZSBfc3RhcnRwb3MgX2VuZHBvcztcbiAgICB9XG4gIClcbiMgMjI0NSBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIFxuIyA4MSBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICggeCApXG4jIDIyNTEgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICAgXG4gICAgICAgICAgaW5cbiAgICAgICAgICAoXG4jIDk1IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgKCBQVFZhciB4IClcbiMgMjI1NyBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgIDogKFN5bnRheC5wdHlwZV9yKSlcbiAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHQyO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdDJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190Ml87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdDE7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdDFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdDFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB0MiA6IChTeW50YXgucHR5cGUpID0gT2JqLm1hZ2ljIHQyIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IHQxIDogKFN5bnRheC5wdHlwZSkgPSBPYmoubWFnaWMgdDEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3QxXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfdDJfIGluXG4gICAgICAgIGxldCBfdiA6IChTeW50YXgucHR5cGVfcikgPSBcbiMgOTggXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAoIFBUU3VtICh0MSwgdDIpIClcbiMgMjI5NyBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdDI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190Ml87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3QyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0MTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190MV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190MV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHQyIDogKFN5bnRheC5wdHlwZSkgPSBPYmoubWFnaWMgdDIgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgdDEgOiAoU3ludGF4LnB0eXBlKSA9IE9iai5tYWdpYyB0MSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfdDFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc190Ml8gaW5cbiAgICAgICAgbGV0IF92IDogKFN5bnRheC5wdHlwZV9yKSA9IFxuIyAxMDEgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAoIFBUUHJvZCAodDEsIHQyKSApXG4jIDIzMzYgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHQ7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzNfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18zXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB0IDogKFN5bnRheC5wdHlwZSkgPSBPYmoubWFnaWMgdCBpblxuICAgICAgICBsZXQgXzMgOiB1bml0ID0gT2JqLm1hZ2ljIF8zIGluXG4gICAgICAgIGxldCB4IDogKFxuIyA2IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgKFN5bnRheC5zeW1ib2wpXG4jIDIzNzcgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIHggaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc190XyBpblxuICAgICAgICBsZXQgX3YgPVxuICAgICAgICAgIGxldCB4ID1cbiAgICAgICAgICAgIGxldCB4ID1cbiAgICAgICAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hfIGluXG4gICAgICAgICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgICAgICAgXG4jIDIyMiBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICAgKFxuICAgIHsgcGxkZXNjID0geDtcbiAgICAgIHBsbG9jICA9IExvY2F0aW9uLm1ha2UgX3N0YXJ0cG9zIF9lbmRwb3M7XG4gICAgfVxuICApXG4jIDIzOTUgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBcbiMgODEgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIHggKVxuIyAyNDAxIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgIFxuICAgICAgICAgIGluXG4gICAgICAgICAgKFxuIyAxMDQgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAoIFBUUmVjICh4LCB0KSApXG4jIDI0MDcgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICA6IChTeW50YXgucHR5cGVfcikpXG4gICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgeCA6IChTeW50YXgucGV4cHJfcikgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hfIGluXG4gICAgICAgIGxldCBfdiA9XG4gICAgICAgICAgbGV0IGUgPVxuICAgICAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hfIGluXG4gICAgICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgICAgICBcbiMgMjIyIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAoXG4gICAgeyBwbGRlc2MgPSB4O1xuICAgICAgcGxsb2MgID0gTG9jYXRpb24ubWFrZSBfc3RhcnRwb3MgX2VuZHBvcztcbiAgICB9XG4gIClcbiMgMjQ0MSBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgICBcbiAgICAgICAgICBpblxuICAgICAgICAgIChcbiMgMTMwIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgKCBlIClcbiMgMjQ0NyBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgIDogKFN5bnRheC5wZXhwcl9yIExvY2F0aW9uLmxvY2VkKSlcbiAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB4IDogKFxuIyA2IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgKFN5bnRheC5zeW1ib2wpXG4jIDI0NjkgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIHggaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194XyBpblxuICAgICAgICBsZXQgX3YgPVxuICAgICAgICAgIGxldCB4ID1cbiAgICAgICAgICAgIGxldCB4ID1cbiAgICAgICAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hfIGluXG4gICAgICAgICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgICAgICAgXG4jIDIyMiBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICAgKFxuICAgIHsgcGxkZXNjID0geDtcbiAgICAgIHBsbG9jICA9IExvY2F0aW9uLm1ha2UgX3N0YXJ0cG9zIF9lbmRwb3M7XG4gICAgfVxuICApXG4jIDI0ODYgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBcbiMgODEgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIHggKVxuIyAyNDkyIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgIFxuICAgICAgICAgIGluXG4gICAgICAgICAgKFxuIyAxMTIgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAoIFBFVmFyICh4LCAwKSApXG4jIDI0OTggXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICA6IChTeW50YXgucGV4cHJfcikpXG4gICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfNDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX180XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzRfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gaTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfaV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfaV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194XztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzQgOiB1bml0ID0gT2JqLm1hZ2ljIF80IGluXG4gICAgICAgIGxldCBpIDogKFxuIyA3IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgKGludClcbiMgMjUzOSBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgaSBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCB4IDogKFxuIyA2IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgKFN5bnRheC5zeW1ib2wpXG4jIDI1NDUgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIHggaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fNF8gaW5cbiAgICAgICAgbGV0IF92ID1cbiAgICAgICAgICBsZXQgeCA9XG4gICAgICAgICAgICBsZXQgeCA9XG4gICAgICAgICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194XyBpblxuICAgICAgICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgICAgICAgIFxuIyAyMjIgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgIChcbiAgICB7IHBsZGVzYyA9IHg7XG4gICAgICBwbGxvYyAgPSBMb2NhdGlvbi5tYWtlIF9zdGFydHBvcyBfZW5kcG9zO1xuICAgIH1cbiAgKVxuIyAyNTYyIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgXG4jIDgxIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCB4IClcbiMgMjU2OCBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgICBcbiAgICAgICAgICBpblxuICAgICAgICAgIChcbiMgMTE1IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgKCBQRVZhciAoeCwgaSkgKVxuIyAyNTc0IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgOiAoU3ludGF4LnBleHByX3IpKVxuICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzM7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fM187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18zXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4O1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8zIDogdW5pdCA9IE9iai5tYWdpYyBfMyBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCB4IDogKFxuIyA2IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgKFN5bnRheC5zeW1ib2wpXG4jIDI2MTAgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIHggaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fM18gaW5cbiAgICAgICAgbGV0IF92ID1cbiAgICAgICAgICBsZXQgXzIgPVxuICAgICAgICAgICAgbGV0IHggPSBcbiMgMjMwIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICggKCkgKVxuIyAyNjIwIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgXG4jIDIzNCBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAoIHggKVxuIyAyNjI1IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgIFxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IGYgPVxuICAgICAgICAgICAgbGV0IHggPVxuICAgICAgICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeF8gaW5cbiAgICAgICAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICAgICAgICBcbiMgMjIyIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAoXG4gICAgeyBwbGRlc2MgPSB4O1xuICAgICAgcGxsb2MgID0gTG9jYXRpb24ubWFrZSBfc3RhcnRwb3MgX2VuZHBvcztcbiAgICB9XG4gIClcbiMgMjYzOSBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIFxuIyA4MSBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICggeCApXG4jIDI2NDUgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICAgXG4gICAgICAgICAgaW5cbiAgICAgICAgICAoXG4jIDExOCBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICggUEVBcHAgKGYsIFtdKSApXG4jIDI2NTEgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICA6IChTeW50YXgucGV4cHJfcikpXG4gICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18zXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gYW91dDtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfYW91dF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfYW91dF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194XztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzMgOiB1bml0ID0gT2JqLm1hZ2ljIF8zIGluXG4gICAgICAgIGxldCBhb3V0IDogKFN5bnRheC5wZXhwciBsaXN0KSA9IE9iai5tYWdpYyBhb3V0IGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IHggOiAoXG4jIDYgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgICAoU3ludGF4LnN5bWJvbClcbiMgMjY5NCBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18zXyBpblxuICAgICAgICBsZXQgX3YgPVxuICAgICAgICAgIGxldCBhcmdzID1cbiAgICAgICAgICAgIGxldCB4ID0gXG4jIDI0OCBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggYW91dCApXG4jIDI3MDQgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBcbiMgMjM0IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICggeCApXG4jIDI3MDkgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICAgXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgZiA9XG4gICAgICAgICAgICBsZXQgeCA9XG4gICAgICAgICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194XyBpblxuICAgICAgICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgICAgICAgIFxuIyAyMjIgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgIChcbiAgICB7IHBsZGVzYyA9IHg7XG4gICAgICBwbGxvYyAgPSBMb2NhdGlvbi5tYWtlIF9zdGFydHBvcyBfZW5kcG9zO1xuICAgIH1cbiAgKVxuIyAyNzIzIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgXG4jIDgxIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCB4IClcbiMgMjcyOSBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgICBcbiAgICAgICAgICBpblxuICAgICAgICAgIChcbiMgMTIxIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgKCBQRUFwcCAoZiwgYXJncykgKVxuIyAyNzM1IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgOiAoU3ludGF4LnBleHByX3IpKVxuICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF92ID1cbiAgICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzFfIGluXG4gICAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgICAoXG4jIDU1IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgKCByYWlzZSAoUGFyc2VFcnJvciAoU29tZSAoTG9jYXRpb24ubWFrZSBfc3RhcnRwb3MgX2VuZHBvcyksIE5vbmUpKSApXG4jIDI3NjQgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgICA6IChTeW50YXgucGV4cHIpKVxuICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgZSA6IChTeW50YXgucGV4cHIpID0gT2JqLm1hZ2ljIGUgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2VfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMl8gaW5cbiAgICAgICAgbGV0IF92IDogKFN5bnRheC5wZXhwcikgPSBcbiMgNTcgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAoIGUgKVxuIyAyNzk3IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18xXyBpblxuICAgICAgICBsZXQgX3YgPVxuICAgICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMV8gaW5cbiAgICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICAgIChcbiMgNjkgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWx5XCJcbiAgICggcmFpc2UgKFBhcnNlRXJyb3IgKFNvbWUgKExvY2F0aW9uLm1ha2UgX3N0YXJ0cG9zIF9lbmRwb3MpLCBOb25lKSkgKVxuIyAyODI1IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgOiAoU3ludGF4LnBmb3JtKSlcbiAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGY7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2ZfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2ZfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IGYgOiAoU3ludGF4LnBmb3JtKSA9IE9iai5tYWdpYyBmIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19mXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzJfIGluXG4gICAgICAgIGxldCBfdiA6IChTeW50YXgucGZvcm0pID0gXG4jIDcxIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgKCBmIClcbiMgMjg1OCBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF92ID1cbiAgICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzFfIGluXG4gICAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgICAoXG4jIDc2IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAoIHJhaXNlIChQYXJzZUVycm9yIChTb21lIChMb2NhdGlvbi5tYWtlIF9zdGFydHBvcyBfZW5kcG9zKSwgTm9uZSkpIClcbiMgMjg4NiBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgICAgICAgIDogKFN5bnRheC5wZ29hbCkpXG4gICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBwO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19wXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19wXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCBwIDogKFN5bnRheC5wZ29hbCkgPSBPYmoubWFnaWMgcCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfcF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18yXyBpblxuICAgICAgICBsZXQgX3YgOiAoU3ludGF4LnBnb2FsKSA9IFxuIyA3OCBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICggcCApXG4jIDI5MTkgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfdiA9XG4gICAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18xXyBpblxuICAgICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgICAgKFxuIyA2MiBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICggcmFpc2UgKFBhcnNlRXJyb3IgKFNvbWUgKExvY2F0aW9uLm1ha2UgX3N0YXJ0cG9zIF9lbmRwb3MpLCBOb25lKSkgKVxuIyAyOTQ3IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgOiAoU3ludGF4LnBuZXhwcikpXG4gICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCBlIDogKFN5bnRheC5wbmV4cHIpID0gT2JqLm1hZ2ljIGUgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2VfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMl8gaW5cbiAgICAgICAgbGV0IF92IDogKFN5bnRheC5wbmV4cHIpID0gXG4jIDY0IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICggZSApXG4jIDI5ODAgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfdiA9XG4gICAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18xXyBpblxuICAgICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgICAgKFxuIyA0OCBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICggcmFpc2UgKFBhcnNlRXJyb3IgKFNvbWUgKExvY2F0aW9uLm1ha2UgX3N0YXJ0cG9zIF9lbmRwb3MpLCBOb25lKSkgKVxuIyAzMDA4IFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgOiAoU3ludGF4LnB0eXBlKSlcbiAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHQ7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3RfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3RfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IHQgOiAoU3ludGF4LnB0eXBlKSA9IE9iai5tYWdpYyB0IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc190XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzJfIGluXG4gICAgICAgIGxldCBfdiA6IChTeW50YXgucHR5cGUpID0gXG4jIDUwIFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICggdCApXG4jIDMwNDEgXCJsaWJzL2VuZ2luZS9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgfF1cbiAgXG4gIGFuZCB0cmFjZSA9XG4gICAgTm9uZVxuICBcbmVuZFxuXG5tb2R1bGUgTWVuaGlySW50ZXJwcmV0ZXIgPSBzdHJ1Y3RcbiAgXG4gIG1vZHVsZSBFVCA9IE1lbmhpckxpYi5UYWJsZUludGVycHJldGVyLk1ha2VFbmdpbmVUYWJsZSAoVGFibGVzKVxuICBcbiAgbW9kdWxlIFRJID0gTWVuaGlyTGliLkVuZ2luZS5NYWtlIChFVClcbiAgXG4gIGluY2x1ZGUgVElcbiAgXG4gIG1vZHVsZSBTeW1ib2xzID0gc3RydWN0XG4gICAgXG4gICAgdHlwZSBfIHRlcm1pbmFsID0gXG4gICAgICB8IFRfZXJyb3IgOiB1bml0IHRlcm1pbmFsXG4gICAgICB8IFRfVFlQRSA6IHVuaXQgdGVybWluYWxcbiAgICAgIHwgVF9UUlVFIDogdW5pdCB0ZXJtaW5hbFxuICAgICAgfCBUX1NUQVIgOiB1bml0IHRlcm1pbmFsXG4gICAgICB8IFRfU0VNSUNPTE9OIDogdW5pdCB0ZXJtaW5hbFxuICAgICAgfCBUX1JQQVJFTiA6IHVuaXQgdGVybWluYWxcbiAgICAgIHwgVF9SRUMgOiB1bml0IHRlcm1pbmFsXG4gICAgICB8IFRfUkJSQUNFIDogdW5pdCB0ZXJtaW5hbFxuICAgICAgfCBUX1BST09GIDogdW5pdCB0ZXJtaW5hbFxuICAgICAgfCBUX1BMVVMgOiB1bml0IHRlcm1pbmFsXG4gICAgICB8IFRfTkFUIDogKFxuIyA3IFwibGlicy9lbmdpbmUvcGFyc2VyLm1seVwiXG4gICAgICAgKGludClcbiMgMzA4MSBcImxpYnMvZW5naW5lL3BhcnNlci5tbFwiXG4gICAgKSB0ZXJtaW5hbFxuICAgICAgfCBUX0xSQVJST1cgOiB1bml0IHRlcm1pbmFsXG4gICAgICB8IFRfTFBBUkVOIDogdW5pdCB0ZXJtaW5hbFxuICAgICAgfCBUX0xPUiA6IHVuaXQgdGVybWluYWxcbiAgICAgIHwgVF9MTkVHIDogdW5pdCB0ZXJtaW5hbFxuICAgICAgfCBUX0xCUkFDRSA6IHVuaXQgdGVybWluYWxcbiAgICAgIHwgVF9MQVJST1cgOiB1bml0IHRlcm1pbmFsXG4gICAgICB8IFRfTEFORCA6IHVuaXQgdGVybWluYWxcbiAgICAgIHwgVF9JREVOVCA6IChcbiMgNiBcImxpYnMvZW5naW5lL3BhcnNlci5tbHlcIlxuICAgICAgIChTeW50YXguc3ltYm9sKVxuIyAzMDkzIFwibGlicy9lbmdpbmUvcGFyc2VyLm1sXCJcbiAgICApIHRlcm1pbmFsXG4gICAgICB8IFRfRk9SQUxMIDogdW5pdCB0ZXJtaW5hbFxuICAgICAgfCBUX0ZBTFNFIDogdW5pdCB0ZXJtaW5hbFxuICAgICAgfCBUX0VYSVNUUyA6IHVuaXQgdGVybWluYWxcbiAgICAgIHwgVF9FUSA6IHVuaXQgdGVybWluYWxcbiAgICAgIHwgVF9FT0YgOiB1bml0IHRlcm1pbmFsXG4gICAgICB8IFRfRE9UIDogdW5pdCB0ZXJtaW5hbFxuICAgICAgfCBUX0RDT0xPTiA6IHVuaXQgdGVybWluYWxcbiAgICAgIHwgVF9DT01NQSA6IHVuaXQgdGVybWluYWxcbiAgICAgIHwgVF9DT0xPTkVRIDogdW5pdCB0ZXJtaW5hbFxuICAgICAgfCBUX0NPTE9OIDogdW5pdCB0ZXJtaW5hbFxuICAgICAgfCBUX0FNUCA6IHVuaXQgdGVybWluYWxcbiAgICBcbiAgICB0eXBlIF8gbm9udGVybWluYWwgPSBcbiAgICAgIHwgTl94dHlwZSA6IChTeW50YXgucHR5cGUpIG5vbnRlcm1pbmFsXG4gICAgICB8IE5feG5leHByIDogKFN5bnRheC5wbmV4cHIpIG5vbnRlcm1pbmFsXG4gICAgICB8IE5feGdvYWwgOiAoU3ludGF4LnBnb2FsKSBub250ZXJtaW5hbFxuICAgICAgfCBOX3hmb3JtIDogKFN5bnRheC5wZm9ybSkgbm9udGVybWluYWxcbiAgICAgIHwgTl94ZXhwciA6IChTeW50YXgucGV4cHIpIG5vbnRlcm1pbmFsXG4gICAgICB8IE5fdW5wYXJlbnNfZXhwcl9yIDogKFN5bnRheC5wZXhwcl9yKSBub250ZXJtaW5hbFxuICAgICAgfCBOX3VucGFyZW5zX2V4cHIgOiAoU3ludGF4LnBleHByX3IgTG9jYXRpb24ubG9jZWQpIG5vbnRlcm1pbmFsXG4gICAgICB8IE5fdHlwZV9yIDogKFN5bnRheC5wdHlwZV9yKSBub250ZXJtaW5hbFxuICAgICAgfCBOX3R5cGVfIDogKFN5bnRheC5wdHlwZSkgbm9udGVybWluYWxcbiAgICAgIHwgTl90eWlkZW50IDogKFN5bnRheC5wdHlpZGVudCkgbm9udGVybWluYWxcbiAgICAgIHwgTl9zaWduYXR1cmUgOiAoU3ludGF4LnBzaWduYXR1cmUpIG5vbnRlcm1pbmFsXG4gICAgICB8IE5fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfZm9ybV8gOiAoU3ludGF4LnBmb3JtIGxpc3QpIG5vbnRlcm1pbmFsXG4gICAgICB8IE5fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfZXhwcl8gOiAoU3ludGF4LnBleHByIGxpc3QpIG5vbnRlcm1pbmFsXG4gICAgICB8IE5fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfZW50cnlfIDogKFN5bnRheC5wdmFyIGxpc3QpIG5vbnRlcm1pbmFsXG4gICAgICB8IE5fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQU1QX3R5cGVfXyA6IChTeW50YXgucGFyaXR5KSBub250ZXJtaW5hbFxuICAgICAgfCBOX29wdGlvbl9wcmVjZWRlZF9TRU1JQ09MT05fcGxpc3QwX2Zvcm1fQ09NTUFfX18gOiAoU3ludGF4LnBmb3JtIGxpc3Qgb3B0aW9uKSBub250ZXJtaW5hbFxuICAgICAgfCBOX25leHByIDogKFN5bnRheC5wbmV4cHIpIG5vbnRlcm1pbmFsXG4gICAgICB8IE5fbG9wdGlvbl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9mb3JtX18gOiAoU3ludGF4LnBmb3JtIGxpc3QpIG5vbnRlcm1pbmFsXG4gICAgICB8IE5fbG9wdGlvbl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9lbnRyeV9fIDogKFN5bnRheC5wdmFyIGxpc3QpIG5vbnRlcm1pbmFsXG4gICAgICB8IE5fbG9wdGlvbl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9BTVBfdHlwZV9fXyA6IChTeW50YXgucGFyaXR5KSBub250ZXJtaW5hbFxuICAgICAgfCBOX2dvYWwgOiAoU3ludGF4LnBnb2FsKSBub250ZXJtaW5hbFxuICAgICAgfCBOX2Zvcm1fciA6IChTeW50YXgucGZvcm1fcikgbm9udGVybWluYWxcbiAgICAgIHwgTl9mb3JtIDogKFN5bnRheC5wZm9ybSkgbm9udGVybWluYWxcbiAgICAgIHwgTl9leHByX3IgOiAoU3ludGF4LnBleHByX3IpIG5vbnRlcm1pbmFsXG4gICAgICB8IE5fZXhwciA6IChTeW50YXgucGV4cHIpIG5vbnRlcm1pbmFsXG4gICAgICB8IE5fZW50cnkgOiAoU3ludGF4LnB2YXIpIG5vbnRlcm1pbmFsXG4gICAgXG4gIGVuZFxuICBcbiAgaW5jbHVkZSBTeW1ib2xzXG4gIFxuICBpbmNsdWRlIE1lbmhpckxpYi5JbnNwZWN0aW9uVGFibGVJbnRlcnByZXRlci5NYWtlIChUYWJsZXMpIChzdHJ1Y3RcbiAgICBcbiAgICBpbmNsdWRlIFRJXG4gICAgXG4gICAgaW5jbHVkZSBTeW1ib2xzXG4gICAgXG4gICAgaW5jbHVkZSBNZW5oaXJMaWIuSW5zcGVjdGlvblRhYmxlSW50ZXJwcmV0ZXIuU3ltYm9scyAoU3ltYm9scylcbiAgICBcbiAgICBsZXQgdGVybWluYWwgPVxuICAgICAgZnVuIHQgLT5cbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgMCAtPlxuICAgICAgICAgICAgWCAoVCBUX2Vycm9yKVxuICAgICAgICB8IDEgLT5cbiAgICAgICAgICAgIFggKFQgVF9UWVBFKVxuICAgICAgICB8IDIgLT5cbiAgICAgICAgICAgIFggKFQgVF9UUlVFKVxuICAgICAgICB8IDMgLT5cbiAgICAgICAgICAgIFggKFQgVF9TVEFSKVxuICAgICAgICB8IDQgLT5cbiAgICAgICAgICAgIFggKFQgVF9TRU1JQ09MT04pXG4gICAgICAgIHwgNSAtPlxuICAgICAgICAgICAgWCAoVCBUX1JQQVJFTilcbiAgICAgICAgfCA2IC0+XG4gICAgICAgICAgICBYIChUIFRfUkVDKVxuICAgICAgICB8IDcgLT5cbiAgICAgICAgICAgIFggKFQgVF9SQlJBQ0UpXG4gICAgICAgIHwgOCAtPlxuICAgICAgICAgICAgWCAoVCBUX1BST09GKVxuICAgICAgICB8IDkgLT5cbiAgICAgICAgICAgIFggKFQgVF9QTFVTKVxuICAgICAgICB8IDEwIC0+XG4gICAgICAgICAgICBYIChUIFRfTkFUKVxuICAgICAgICB8IDExIC0+XG4gICAgICAgICAgICBYIChUIFRfTFJBUlJPVylcbiAgICAgICAgfCAxMiAtPlxuICAgICAgICAgICAgWCAoVCBUX0xQQVJFTilcbiAgICAgICAgfCAxMyAtPlxuICAgICAgICAgICAgWCAoVCBUX0xPUilcbiAgICAgICAgfCAxNCAtPlxuICAgICAgICAgICAgWCAoVCBUX0xORUcpXG4gICAgICAgIHwgMTUgLT5cbiAgICAgICAgICAgIFggKFQgVF9MQlJBQ0UpXG4gICAgICAgIHwgMTYgLT5cbiAgICAgICAgICAgIFggKFQgVF9MQVJST1cpXG4gICAgICAgIHwgMTcgLT5cbiAgICAgICAgICAgIFggKFQgVF9MQU5EKVxuICAgICAgICB8IDE4IC0+XG4gICAgICAgICAgICBYIChUIFRfSURFTlQpXG4gICAgICAgIHwgMTkgLT5cbiAgICAgICAgICAgIFggKFQgVF9GT1JBTEwpXG4gICAgICAgIHwgMjAgLT5cbiAgICAgICAgICAgIFggKFQgVF9GQUxTRSlcbiAgICAgICAgfCAyMSAtPlxuICAgICAgICAgICAgWCAoVCBUX0VYSVNUUylcbiAgICAgICAgfCAyMiAtPlxuICAgICAgICAgICAgWCAoVCBUX0VRKVxuICAgICAgICB8IDIzIC0+XG4gICAgICAgICAgICBYIChUIFRfRU9GKVxuICAgICAgICB8IDI0IC0+XG4gICAgICAgICAgICBYIChUIFRfRE9UKVxuICAgICAgICB8IDI1IC0+XG4gICAgICAgICAgICBYIChUIFRfRENPTE9OKVxuICAgICAgICB8IDI2IC0+XG4gICAgICAgICAgICBYIChUIFRfQ09NTUEpXG4gICAgICAgIHwgMjcgLT5cbiAgICAgICAgICAgIFggKFQgVF9DT0xPTkVRKVxuICAgICAgICB8IDI4IC0+XG4gICAgICAgICAgICBYIChUIFRfQ09MT04pXG4gICAgICAgIHwgMjkgLT5cbiAgICAgICAgICAgIFggKFQgVF9BTVApXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IGZhbHNlXG4gICAgXG4gICAgYW5kIG5vbnRlcm1pbmFsID1cbiAgICAgIGZ1biBudCAtPlxuICAgICAgICBtYXRjaCBudCB3aXRoXG4gICAgICAgIHwgMzAgLT5cbiAgICAgICAgICAgIFggKE4gTl9lbnRyeSlcbiAgICAgICAgfCAyOSAtPlxuICAgICAgICAgICAgWCAoTiBOX2V4cHIpXG4gICAgICAgIHwgMjggLT5cbiAgICAgICAgICAgIFggKE4gTl9leHByX3IpXG4gICAgICAgIHwgMjcgLT5cbiAgICAgICAgICAgIFggKE4gTl9mb3JtKVxuICAgICAgICB8IDI2IC0+XG4gICAgICAgICAgICBYIChOIE5fZm9ybV9yKVxuICAgICAgICB8IDI1IC0+XG4gICAgICAgICAgICBYIChOIE5fZ29hbClcbiAgICAgICAgfCAyNCAtPlxuICAgICAgICAgICAgWCAoTiBOX2xvcHRpb25fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQU1QX3R5cGVfX18pXG4gICAgICAgIHwgMjMgLT5cbiAgICAgICAgICAgIFggKE4gTl9sb3B0aW9uX3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX2VudHJ5X18pXG4gICAgICAgIHwgMjIgLT5cbiAgICAgICAgICAgIFggKE4gTl9sb3B0aW9uX3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX2Zvcm1fXylcbiAgICAgICAgfCAyMSAtPlxuICAgICAgICAgICAgWCAoTiBOX25leHByKVxuICAgICAgICB8IDIwIC0+XG4gICAgICAgICAgICBYIChOIE5fb3B0aW9uX3ByZWNlZGVkX1NFTUlDT0xPTl9wbGlzdDBfZm9ybV9DT01NQV9fXylcbiAgICAgICAgfCAxOSAtPlxuICAgICAgICAgICAgWCAoTiBOX3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0FNUF90eXBlX18pXG4gICAgICAgIHwgMTggLT5cbiAgICAgICAgICAgIFggKE4gTl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9lbnRyeV8pXG4gICAgICAgIHwgMTcgLT5cbiAgICAgICAgICAgIFggKE4gTl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9leHByXylcbiAgICAgICAgfCAxNiAtPlxuICAgICAgICAgICAgWCAoTiBOX3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX2Zvcm1fKVxuICAgICAgICB8IDE1IC0+XG4gICAgICAgICAgICBYIChOIE5fc2lnbmF0dXJlKVxuICAgICAgICB8IDE0IC0+XG4gICAgICAgICAgICBYIChOIE5fdHlpZGVudClcbiAgICAgICAgfCAxMyAtPlxuICAgICAgICAgICAgWCAoTiBOX3R5cGVfKVxuICAgICAgICB8IDEyIC0+XG4gICAgICAgICAgICBYIChOIE5fdHlwZV9yKVxuICAgICAgICB8IDExIC0+XG4gICAgICAgICAgICBYIChOIE5fdW5wYXJlbnNfZXhwcilcbiAgICAgICAgfCAxMCAtPlxuICAgICAgICAgICAgWCAoTiBOX3VucGFyZW5zX2V4cHJfcilcbiAgICAgICAgfCA5IC0+XG4gICAgICAgICAgICBYIChOIE5feGV4cHIpXG4gICAgICAgIHwgOCAtPlxuICAgICAgICAgICAgWCAoTiBOX3hmb3JtKVxuICAgICAgICB8IDcgLT5cbiAgICAgICAgICAgIFggKE4gTl94Z29hbClcbiAgICAgICAgfCA2IC0+XG4gICAgICAgICAgICBYIChOIE5feG5leHByKVxuICAgICAgICB8IDUgLT5cbiAgICAgICAgICAgIFggKE4gTl94dHlwZSlcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgZmFsc2VcbiAgICBcbiAgICBhbmQgbHIwX2luY29taW5nID1cbiAgICAgICg4LCBcIlxcMDAwXFwwMDJcXDAyNiZcXDAyNlxcMDEyXFwwMjEjXFwwMTI5OzYjIFxcMDIyXFwwMTY5XFwwMTJcXDAxOTswXFwwMDBcXDAwMlxcMDA2XFwwMjZcXDAzMCZcXDAyNiNcXDAxMigmOlxcMDE0JjJcXDAyNlxcMDEyJlxcMDI1XFwwMTJcXDAyN1xcYlxcMDI1XFwwMjdcXDAyMFxcMDI3XFwwMjdcXDAyN1xcMDI5MiosXFwwMjkyXFwwMjFcXDAyMy5cXDAyMzU3XFwwMjQ3XFwwMjg3XFxcIjckNzc3NVxcMDEyN1xcMDE3NzBcXDAwMFxcMDAyXFwwMDQmOFxcMDI3JjRcXDAyNzwnJzE4OzpcXDAyN1xcMDMxMVxcXCJcXDAyN1xcMDE1JS9cXG4hLTc2ISlcXDAxODczMD02JVxcMDAwXFwwMDImODtcXHIrMFxcMDAwXFwwMDJcXDAxMVxcMDI3MFwiKVxuICAgIFxuICAgIGFuZCByaHMgPVxuICAgICAgKCg4LCBcIlxcMDE5XFwwMTdcXDAxNVxcclxcMDExJiY0MSY6XFwwMzEmOlxcMDI3Jjg7XFwwMDQmXFwwMDQmOFxcMDI3OVxcMDIxXFwwMjY5XFwwMTI1XFwwMjY1XFwwMTJcXDAwNiomXFwwMjMuXFwwMjMmXFwwMjYjXFwwMTI3JDc3XFwwMjg3N1xcXCI3N1xcMDI0N1xcMDMwNyhcXDAyOTI3LFxcMDI5MjcvKVxcMDE4NyclISY4O1xcbi1cXDAyN1xcMDI3PCc9PTYlOzs2Izc3NiExXFxcIlxcMDI3JjpcXDAyN1xcMDI1XFwwMjZcXDAyNVxcMDEyXFwwMjZcXDAxMiZcXDAyN1xcMDIwXFwwMjdcXDAyN1xcYlxcMDI3XFwwMTQmMlxcMDI3XFwwMjEmJiBcXDAyMlxcMDE2JlxcMDI2XFwwMTImXFwwMjYjXFwwMTJcXDAwMjswXFwwMDI3MFxcMDAyMzBcXDAwMiswXFwwMDJcXDAyNzBcIiksICg4LCBcIlxcMDAwXFwwMDFcXDAwMlxcMDAzXFwwMDRcXDAwNVxcMDA2XFx0XFwwMTJcXDAxNVxcMDE4XFwwMjBcXDAyNFxcMDI1XFwwMjZcXDAyOVxcMDMwIVxcXCIjJCcrLjE0Nzk9QUVFRkZHR0hLS01OUVJVVllaXWBjZGdpam1wdHV2en1cXDEyOVxcMTMwXFwxMzJcXDEzM1xcMTM1XFwxMzZcXDEzOFxcMTM5XFwxNDFcXDE0MlxcMTQ0XCIpKVxuICAgIFxuICAgIGFuZCBscjBfY29yZSA9XG4gICAgICAoOCwgXCJcXDAwMFxcMDAxXFwwMDJcXDAwM1xcMDA0XFwwMDVcXDAwNlxcMDA3XFxiXFx0XFxuXFwwMTFcXDAxMlxcclxcMDE0XFwwMTVcXDAxNlxcMDE3XFwwMThcXDAxOVxcMDIwXFwwMjFcXDAyMlxcMDIzXFwwMjRcXDAyNVxcMDI2XFwwMjdcXDAyOFxcMDI5XFwwMzBcXDAzMSAhXFxcIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QENEQUJFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xcXFxdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+XFwxMjdcIilcbiAgICBcbiAgICBhbmQgbHIwX2l0ZW1zID1cbiAgICAgICgoMzIsIFwiXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNDRcXDAwMVxcMDAwXFwwMDA4XFwwMDFcXDAwMFxcMDAwXFwyNDBcXDAwMVxcMDAwXFwwMDBcXDIzNlxcMDAxXFwwMDBcXDAwMFxcMjMyXFwwMDFcXDAwMFxcMDAwXFwyMjhcXDAwMVxcMDAwXFwwMDBcXDI0MFxcMDAyXFwwMDBcXDAwMFxcMjM2XFwwMDJcXDAwMFxcMDAwXFwyMzZcXDAwM1xcMDAwXFwwMDA0XFwwMDFcXDAwMFxcMDAwXFwyNDBcXDAwM1xcMDAwXFwwMDBcXDI0MFxcMDA0XFwwMDBcXDAwMDBcXDAwMVxcMDAwXFwwMDBcXDE3NlxcMDAxXFwwMDBcXDAwMFxcMTcyXFwwMDFcXDAwMFxcMDAwXFwxNzZcXDAwMlxcMDAwXFwwMDBcXDE3NlxcMDAzXFwwMDBcXDAwMFxcMjMyXFwwMDJcXDAwMFxcMDAwXFwyMzJcXDAwM1xcMDAwXFwwMDBcXDIzMlxcMDA0XFwwMDBcXDAwMDhcXDAwMlxcMDAwXFwwMDA4XFwwMDNcXDAwMFxcMDAwXFwwMDBcXDAwMVxcMDAwXFwwMDBcXDI0OFxcMDAxXFwwMDBcXDAwMFxcMjQ4XFwwMDJcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDI1MlxcMDAxXFwwMDBcXDAwMERcXDAwMVxcMDAwXFwwMDBAXFwwMDFcXDAwMFxcMDAwaFxcMDAxXFwwMDBcXDAwMFxcMjQwXFwwMDFcXDAwMFxcMDAwXFwyMzZcXDAwMVxcMDAwXFwwMDBcXDIzMlxcMDAxXFwwMDBcXDAwMFxcMjI4XFwwMDFcXDAwMFxcMDAwVFxcMDAxXFwwMDBcXDAwMExcXDAwMVxcMDAwXFwwMDBcXDI0MFxcMDAyXFwwMDBcXDAwMFxcMjM2XFwwMDJcXDAwMFxcMDAwVFxcMDAyXFwwMDBcXDAwMFxcMjQwXFwwMDNcXDAwMFxcMDAwVFxcMDAzXFwwMDBcXDAwMFxcMjQwXFwwMDRcXDAwMFxcMDAwVFxcMDA0XFwwMDBcXDAwMGxcXDAwMVxcMDAwXFwwMDBcXDE5MlxcMDAxXFwwMDBcXDAwMFxcMTkyXFwwMDJcXDAwMFxcMDAwXFwyMjBcXDAwMVxcMDAwXFwwMDBcXDIyMFxcMDAyXFwwMDBcXDAwMFxcMjIwXFwwMDNcXDAwMFxcMDAwXFwyMDRcXDAwMVxcMDAwXFwwMDBcXDIwMFxcMDAxXFwwMDBcXDAwMFxcMjA0XFwwMDJcXDAwMFxcMDAwXFwyMDhcXDAwMVxcMDAwXFwwMDBcXDIwMFxcMDAyXFwwMDBcXDAwMFxcMTk2XFwwMDFcXDAwMFxcMDAwXFwyMDBcXDAwM1xcMDAwXFwwMDBcXDIxNlxcMDAxXFwwMDBcXDAwMFxcMjEyXFwwMDFcXDAwMFxcMDAwXFwyMTZcXDAwMlxcMDAwXFwwMDBcXDE5NlxcMDAxXFwwMDBcXDAwMFxcMjE2XFwwMDNcXDAwMFxcMDAwXFwyMTZcXDAwMVxcMDAwXFwwMDBcXDIxMlxcMDAxXFwwMDBcXDAwMFxcMjEyXFwwMDJcXDAwMFxcMDAwXFwyMTZcXDAwMVxcMDAwXFwwMDBcXDIxMlxcMDAzXFwwMDBcXDAwMFxcMjEyXFwwMDFcXDAwMFxcMDAwXFwyMjBcXDAwNFxcMDAwXFwwMDBcXDIxNlxcMDAxXFwwMDBcXDAwMFxcMjEyXFwwMDFcXDAwMFxcMDAwXFwyMTZcXDAwMVxcMDAwXFwwMDBcXDIxMlxcMDAxXFwwMDBcXDAwMFxcMTkyXFwwMDNcXDAwMFxcMDAwbFxcMDAyXFwwMDBcXDAwMGxcXDAwM1xcMDAwXFwwMDBIXFwwMDFcXDAwMFxcMDAwcFxcMDAxXFwwMDBcXDAwMHBcXDAwMlxcMDAwXFwwMDBwXFwwMDNcXDAwMFxcMDAwXFwyMjRcXDAwMVxcMDAwXFwwMDBQXFwwMDFcXDAwMFxcMDAwUFxcMDAyXFwwMDBcXDAwMFBcXDAwM1xcMDAwXFwwMDA8XFwwMDFcXDAwMFxcMDAwcFxcMDA0XFwwMDBcXDAwMGRcXDAwMVxcMDAwXFwwMDBgXFwwMDFcXDAwMFxcMDAwXFxcXFxcMDAxXFwwMDBcXDAwMFhcXDAwMVxcMDAwXFwwMDBkXFwwMDJcXDAwMFxcMDAwZFxcMDAzXFwwMDBcXDAwMGRcXDAwMVxcMDAwXFwwMDBgXFwwMDFcXDAwMFxcMDAwXFxcXFxcMDAxXFwwMDBcXDAwMFhcXDAwMVxcMDAwXFwwMDBcXFxcXFwwMDJcXDAwMFxcMDAwZFxcMDAxXFwwMDBcXDAwMGBcXDAwMVxcMDAwXFwwMDBcXFxcXFwwMDNcXDAwMFxcMDAwXFxcXFxcMDAxXFwwMDBcXDAwMFhcXDAwMVxcMDAwXFwwMDBgXFwwMDJcXDAwMFxcMDAwZFxcMDAxXFwwMDBcXDAwMGBcXDAwM1xcMDAwXFwwMDBgXFwwMDFcXDAwMFxcMDAwXFxcXFxcMDAxXFwwMDBcXDAwMFhcXDAwMVxcMDAwXFwwMDBYXFwwMDJcXDAwMFxcMDAwZFxcMDAxXFwwMDBcXDAwMGBcXDAwMVxcMDAwXFwwMDBcXFxcXFwwMDFcXDAwMFxcMDAwWFxcMDAzXFwwMDBcXDAwMFhcXDAwMVxcMDAwXFwwMDBsXFwwMDRcXDAwMFxcMDAwZFxcMDAxXFwwMDBcXDAwMGBcXDAwMVxcMDAwXFwwMDBcXFxcXFwwMDFcXDAwMFxcMDAwWFxcMDAxXFwwMDBcXDAwMGhcXDAwMlxcMDAwXFwwMDBkXFwwMDFcXDAwMFxcMDAwYFxcMDAxXFwwMDBcXDAwMFxcXFxcXDAwMVxcMDAwXFwwMDBYXFwwMDFcXDAwMFxcMDAwQFxcMDAyXFwwMDBcXDAwMDxcXDAwMVxcMDAwXFwwMDBAXFwwMDNcXDAwMFxcMDAwZFxcMDAxXFwwMDBcXDAwMGBcXDAwMVxcMDAwXFwwMDBcXFxcXFwwMDFcXDAwMFxcMDAwWFxcMDAxXFwwMDBcXDAwMFxcMDA0XFwwMDFcXDAwMFxcMDAxXFwwMDBcXDAwMVxcMDAwXFwwMDBkXFwwMDFcXDAwMFxcMDAwYFxcMDAxXFwwMDBcXDAwMFxcXFxcXDAwMVxcMDAwXFwwMDBYXFwwMDFcXDAwMFxcMDAxXFwwMDBcXDAwMlxcMDAwXFwwMDBcXGJcXDAwMFxcMDAwXFwwMDFcXDAwNFxcMDAxXFwwMDBcXDAwMCxcXDAwMVxcMDAwXFwwMDAoXFwwMDFcXDAwMFxcMDAwLFxcMDAyXFwwMDBcXDAwMChcXDAwMlxcMDAwXFwwMDAsXFwwMDNcXDAwMFxcMDAwXFwyMTZcXDAwMVxcMDAwXFwwMDBcXDIxMlxcMDAxXFwwMDBcXDAwMCxcXDAwNFxcMDAwXFwwMDAkXFwwMDFcXDAwMFxcMDAwIFxcMDAxXFwwMDBcXDAwMFxcMDI4XFwwMDFcXDAwMFxcMDAwXFwwMjRcXDAwMVxcMDAwXFwwMDBcXDAyMFxcMDAxXFwwMDBcXDAwMFxcMDI0XFwwMDJcXDAwMFxcMDAwXFwyMTZcXDAwMVxcMDAwXFwwMDBcXDIxMlxcMDAxXFwwMDBcXDAwMFxcMTYwXFwwMDFcXDAwMFxcMDAwXFwxNTZcXDAwMVxcMDAwXFwwMDBcXDE2MFxcMDAyXFwwMDBcXDAwMFxcMTYwXFwwMDNcXDAwMFxcMDAwfFxcMDAxXFwwMDBcXDAwMFxcMDI0XFwwMDNcXDAwMFxcMDAwJFxcMDAyXFwwMDBcXDAwMCRcXDAwM1xcMDAwXFwwMDAgXFwwMDJcXDAwMFxcMDAwXFwwMjhcXDAwMlxcMDAwXFwwMDBcXDIxNlxcMDAxXFwwMDBcXDAwMFxcMjEyXFwwMDFcXDAwMFxcMDAwXFwxNjBcXDAwMVxcMDAwXFwwMDBcXDE1NlxcMDAxXFwwMDBcXDAwMCBcXDAwM1xcMDAwXFwwMDBcXDAyOFxcMDAzXFwwMDBcXDAwMFxcMTg4XFwwMDFcXDAwMFxcMDAwXFwxODhcXDAwMlxcMDAwXFwwMDBcXDIxNlxcMDAxXFwwMDBcXDAwMFxcMjEyXFwwMDFcXDAwMFxcMDAwXFwxODhcXDAwM1xcMDAwXFwwMDBcXGJcXDAwMVxcMDAwXFwwMDBcXDEzMlxcMDAxXFwwMDBcXDAwMHRcXDAwMVxcMDAwXFwwMDBcXDE1MlxcMDAxXFwwMDBcXDAwMFxcMTQwXFwwMDFcXDAwMFxcMDAwXFwxNTJcXDAwMlxcMDAwXFwwMDBcXDE4NFxcMDAxXFwwMDBcXDAwMFxcMTgwXFwwMDFcXDAwMFxcMDAwZFxcMDAxXFwwMDBcXDAwMGBcXDAwMVxcMDAwXFwwMDBcXFxcXFwwMDFcXDAwMFxcMDAwWFxcMDAxXFwwMDBcXDAwMFxcMTg0XFwwMDJcXDAwMFxcMDAwXFwxODRcXDAwM1xcMDAwXFwwMDB0XFwwMDJcXDAwMFxcMDAwdFxcMDAzXFwwMDBcXDAwMHRcXDAwNFxcMDAwXFwwMDBkXFwwMDFcXDAwMFxcMDAwYFxcMDAxXFwwMDBcXDAwMFxcXFxcXDAwMVxcMDAwXFwwMDBYXFwwMDFcXDAwMFxcMDAxXFxiXFwwMDFcXDAwMFxcMDAxXFxiXFwwMDJcXDAwMFxcMDAwXFwxNjhcXDAwMVxcMDAwXFwwMDBcXDE2NFxcMDAxXFwwMDBcXDAwMFxcMTY4XFwwMDJcXDAwMFxcMDAwXFwxNjhcXDAwM1xcMDAwXFwwMDBcXDAxMlxcMDAwXFwwMDBcXDAwMVxcMDEyXFwwMDFcXDAwMFxcMDAwXFwxNDRcXDAwMVxcMDAwXFwwMDBcXDE0NFxcMDAyXFwwMDBcXDAwMFxcMTQ0XFwwMDNcXDAwMFxcMDAwXFwwMTJcXDAwMVxcMDAwXFwwMDFcXDAxNlxcMDAxXFwwMDBcXDAwMVxcMDE2XFwwMDJcXDAwMFxcMDAwXFwwMTZcXDAwMFxcMDAwXFwwMDFcXDAyMFxcMDAxXFwwMDBcXDAwMFxcMDE2XFwwMDFcXDAwMFxcMDAxXFwwMjRcXDAwMVxcMDAwXFwwMDBcXDIxNlxcMDAxXFwwMDBcXDAwMFxcMjEyXFwwMDFcXDAwMFxcMDAxXFwwMjRcXDAwMlwiKSwgKDgsIFwiXFwwMDBcXDAwMVxcMDAyXFwwMDNcXDAwN1xcdFxcblxcMDExXFwwMTJcXHJcXDAxNFxcMDE2XFwwMTdcXDAxOFxcMDE5XFwwMjBcXDAyMVxcMDIyXFwwMjNcXDAyNFxcMDI1XFwwMjZcXDAyN1xcMDI4XFwwMjlcXDAzMFxcMDMxJSgqLC0uLzAxMjQ1Njg5Ozw9QEFER0pLTE1OT1BRUlNUVVpbYGFmZ2xtcnd8flxcMTI3XFwxMzFcXDEzMlxcMTM3XFwxMzhcXDEzOVxcMTQwXFwxNDJcXDE0NFxcMTQ1XFwxNDhcXDE1M1xcMTU0XFwxNThcXDE1OVxcMTYwXFwxNjFcXDE2MlxcMTYzXFwxNjRcXDE2NlxcMTcxXFwxNzJcXDE3M1xcMTc0XFwxNzdcXDE3OFxcMTc5XFwxODBcXDE4MVxcMTgyXFwxODNcXDE4OVxcMTkwXFwxOTFcXDE5MlxcMTkzXFwxOThcXDE5OVxcMjAwXFwyMDJcXDIwM1xcMjA0XFwyMDVcXDIwNlxcMjA3XFwyMDhcXDIwOVxcMjEwXFwyMTFcXDIxMlxcMjEzXFwyMTRcXDIxNVxcMjE4XFwyMTlcIikpXG4gICAgXG4gICAgYW5kIG51bGxhYmxlID1cbiAgICAgIFwiXFwwMDBcXDAwMFxcMDExXFwxMjhcIlxuICAgIFxuICAgIGFuZCBmaXJzdCA9XG4gICAgICAoMzAsIFwiXFwxMzBcXGIgXFwwMDJcXDAwMFxcMDAwXFwxMjhcXDAxMlxcMTM2XFwwMDJcXDAwMChcXDAwMlxcMTQzXFwwMDBcXDEyOFxcYiBcXDAwMlxcYiBcXDEyOFxcYlxcMDAwXFwwMDJcXDAwMDIgXFxiXFwwMDBcXDE2MFxcbjxcXDAwMlxcMDAwIFxcMTI4XFwwMDBcXDAwMFxcMDAyXFwwMDBcXDAwMFxcMDAwXFxiXFwwMDBcXDAwMlxcYiBcXDAwMFxcYiBcXDEyOFxcMDAwXFwwMDBcXDAwMlxcMDAwXFwwMDBcXDEzMChcXDAwMCBcXG48XFwwMDBcXDAwMCBcXDEyOFxcMDA0XFwwMDBcXDAwMlxcMDAwXFwwMDBcXDEzMFxcYlxcMDAwXFxiXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTI4XFwwMDJcXDAwMFxcMTYzXFwxOTJcXDAxNlxcMDAwXFxiXFwwMDBcXDAwMlxcYiBcXDAwMVxcXCJcXDAwMFxcMTI4XFwwMDJcXDAwMFxcMTYzXFwxOTJcXGJcXDAwMlxcMTQzXFwwMDBcXDAwMFxcYiBcXDAwMFxcMDAwIFxcMTI4XFwwMDRcXDAwMFxcMDAyXFwwMDBcXDAwMFwiKVxuICAgIFxuICBlbmQpIChFVCkgKFRJKVxuICBcbmVuZFxuXG5sZXQgeHR5cGUgPVxuICBmdW4gbGV4ZXIgbGV4YnVmIC0+XG4gICAgKE9iai5tYWdpYyAoTWVuaGlySW50ZXJwcmV0ZXIuZW50cnkgYExlZ2FjeSAxMjMgbGV4ZXIgbGV4YnVmKSA6IChTeW50YXgucHR5cGUpKVxuXG5hbmQgeG5leHByID1cbiAgZnVuIGxleGVyIGxleGJ1ZiAtPlxuICAgIChPYmoubWFnaWMgKE1lbmhpckludGVycHJldGVyLmVudHJ5IGBMZWdhY3kgMTE1IGxleGVyIGxleGJ1ZikgOiAoU3ludGF4LnBuZXhwcikpXG5cbmFuZCB4Z29hbCA9XG4gIGZ1biBsZXhlciBsZXhidWYgLT5cbiAgICAoT2JqLm1hZ2ljIChNZW5oaXJJbnRlcnByZXRlci5lbnRyeSBgTGVnYWN5IDc3IGxleGVyIGxleGJ1ZikgOiAoU3ludGF4LnBnb2FsKSlcblxuYW5kIHhmb3JtID1cbiAgZnVuIGxleGVyIGxleGJ1ZiAtPlxuICAgIChPYmoubWFnaWMgKE1lbmhpckludGVycHJldGVyLmVudHJ5IGBMZWdhY3kgMjEgbGV4ZXIgbGV4YnVmKSA6IChTeW50YXgucGZvcm0pKVxuXG5hbmQgeGV4cHIgPVxuICBmdW4gbGV4ZXIgbGV4YnVmIC0+XG4gICAgKE9iai5tYWdpYyAoTWVuaGlySW50ZXJwcmV0ZXIuZW50cnkgYExlZ2FjeSAwIGxleGVyIGxleGJ1ZikgOiAoU3ludGF4LnBleHByKSlcblxubW9kdWxlIEluY3JlbWVudGFsID0gc3RydWN0XG4gIFxuICBsZXQgeHR5cGUgPVxuICAgIGZ1biBpbml0aWFsX3Bvc2l0aW9uIC0+XG4gICAgICAoT2JqLm1hZ2ljIChNZW5oaXJJbnRlcnByZXRlci5zdGFydCAxMjMgaW5pdGlhbF9wb3NpdGlvbikgOiAoU3ludGF4LnB0eXBlKSBNZW5oaXJJbnRlcnByZXRlci5jaGVja3BvaW50KVxuICBcbiAgYW5kIHhuZXhwciA9XG4gICAgZnVuIGluaXRpYWxfcG9zaXRpb24gLT5cbiAgICAgIChPYmoubWFnaWMgKE1lbmhpckludGVycHJldGVyLnN0YXJ0IDExNSBpbml0aWFsX3Bvc2l0aW9uKSA6IChTeW50YXgucG5leHByKSBNZW5oaXJJbnRlcnByZXRlci5jaGVja3BvaW50KVxuICBcbiAgYW5kIHhnb2FsID1cbiAgICBmdW4gaW5pdGlhbF9wb3NpdGlvbiAtPlxuICAgICAgKE9iai5tYWdpYyAoTWVuaGlySW50ZXJwcmV0ZXIuc3RhcnQgNzcgaW5pdGlhbF9wb3NpdGlvbikgOiAoU3ludGF4LnBnb2FsKSBNZW5oaXJJbnRlcnByZXRlci5jaGVja3BvaW50KVxuICBcbiAgYW5kIHhmb3JtID1cbiAgICBmdW4gaW5pdGlhbF9wb3NpdGlvbiAtPlxuICAgICAgKE9iai5tYWdpYyAoTWVuaGlySW50ZXJwcmV0ZXIuc3RhcnQgMjEgaW5pdGlhbF9wb3NpdGlvbikgOiAoU3ludGF4LnBmb3JtKSBNZW5oaXJJbnRlcnByZXRlci5jaGVja3BvaW50KVxuICBcbiAgYW5kIHhleHByID1cbiAgICBmdW4gaW5pdGlhbF9wb3NpdGlvbiAtPlxuICAgICAgKE9iai5tYWdpYyAoTWVuaGlySW50ZXJwcmV0ZXIuc3RhcnQgMCBpbml0aWFsX3Bvc2l0aW9uKSA6IChTeW50YXgucGV4cHIpIE1lbmhpckludGVycHJldGVyLmNoZWNrcG9pbnQpXG4gIFxuZW5kXG4iLCIoKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxue1xuICBvcGVuIFV0aWxzXG4gIG9wZW4gUGFyc2VyXG5cbiAgbW9kdWxlIEwgPSBMb2NhdGlvblxuXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuICBsZXQgbGV4X2Vycm9yIGxleGJ1ZiBtc2cgPVxuICAgIHJhaXNlIChTeW50YXguUGFyc2VFcnJvciAoU29tZSAoTC5vZl9sZXhidWYgbGV4YnVmKSwgU29tZSBtc2cpKVxuXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuICBsZXQgX2tleXdvcmRzID0gW1xuICAgIFwidHJ1ZVwiICAsIFRSVUUgIDtcbiAgICBcImV4aXN0c1wiLCBFWElTVFM7XG4gICAgXCJmYWxzZVwiICwgRkFMU0UgO1xuICAgIFwiZm9yYWxsXCIsIEZPUkFMTDtcbiAgICBcInJlY1wiICAgLCBSRUMgICA7XG4gICAgXCJ0eXBlXCIgICwgVFlQRSAgO1xuICBdXG5cbiAgKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG4gIGxldCBrZXl3b3JkcyA9XG4gICAgbGV0IHRhYmxlID0gSGFzaHRibC5jcmVhdGUgMCBpblxuICAgIExpc3QuaXRlciAoY3VycnkgKEhhc2h0YmwuYWRkIHRhYmxlKSkgX2tleXdvcmRzOyB0YWJsZVxufVxuXG5sZXQgZW1wdHkgICA9IFwiXCJcbmxldCBibGFuayAgID0gWycgJyAnXFx0JyAnXFxyJ11cbmxldCBuZXdsaW5lID0gJ1xcbidcbmxldCB1cHBlciAgID0gWydBJy0nWiddXG5sZXQgbG93ZXIgICA9IFsnYSctJ3onXVxubGV0IGxldHRlciAgPSB1cHBlciB8IGxvd2VyXG5sZXQgZGlnaXQgICA9IFsnMCctJzknXVxubGV0IHVpbnQgICAgPSBkaWdpdCtcblxubGV0IGljaGFyID0gKGxldHRlciB8IGRpZ2l0IHwgJ18nIHwgJ1xcJycpXG5sZXQgaWRlbnQgPSBsZXR0ZXIgaWNoYXIqXG5sZXQgbmF0ICAgPSBkaWdpdCtcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbnJ1bGUgbWFpbiA9IHBhcnNlXG4gIHwgbmV3bGluZSAgICAgeyBMZXhpbmcubmV3X2xpbmUgbGV4YnVmOyBtYWluIGxleGJ1ZiB9XG4gIHwgYmxhbmsrICAgICAgeyBtYWluIGxleGJ1ZiB9XG4gIHwgaWRlbnQgYXMgaWQgeyB0cnkgSGFzaHRibC5maW5kIGtleXdvcmRzIGlkIHdpdGggTm90X2ZvdW5kIC0+IElERU5UIGlkIH1cbiAgfCBuYXQgYXMgbiAgICB7IE5BVCAoaW50X29mX3N0cmluZyBuKSB9XG5cbiAgfCBcIihcIiAgIHsgTFBBUkVOICAgIH1cbiAgfCBcIilcIiAgIHsgUlBBUkVOICAgIH1cbiAgfCBcIntcIiAgIHsgTEJSQUNFICAgIH1cbiAgfCBcIn1cIiAgIHsgUkJSQUNFICAgIH1cbiAgfCBcIiYmXCIgIHsgTEFORCAgICAgIH1cbiAgfCBcInx8XCIgIHsgTE9SICAgICAgIH1cbiAgfCBcIn5cIiAgIHsgTE5FRyAgICAgIH1cbiAgfCBcIi0+XCIgIHsgTEFSUk9XICAgIH1cbiAgfCBcIjwtPlwiIHsgTFJBUlJPVyAgIH1cbiAgfCBcInwtXCIgIHsgUFJPT0YgICAgIH1cbiAgfCBcIixcIiAgIHsgQ09NTUEgICAgIH1cbiAgfCBcIi5cIiAgIHsgRE9UICAgICAgIH1cbiAgfCBcIjtcIiAgIHsgU0VNSUNPTE9OIH1cbiAgfCBcIjpcIiAgIHsgQ09MT04gICAgIH1cbiAgfCBcIjo6XCIgIHsgRENPTE9OICAgIH1cbiAgfCBcIj1cIiAgIHsgRVEgICAgICAgIH1cbiAgfCBcIjo9XCIgIHsgQ09MT05FUSAgIH1cbiAgfCBcIiZcIiAgIHsgQU1QICAgICAgIH1cbiAgfCBcIitcIiAgIHsgUExVUyAgICAgIH1cbiAgfCBcIipcIiAgIHsgU1RBUiAgICAgIH1cblxuICB8IGVvZiB7IEVPRiB9XG5cbiAgfCAgXyBhcyBjIHsgbGV4X2Vycm9yIGxleGJ1ZiAoUHJpbnRmLnNwcmludGYgXCJpbGxlZ2FsIGNoYXJhY3RlcjogJWNcIiBjKSB9XG4iLCIjIDIgXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuIFxuICBvcGVuIFV0aWxzXG4gIG9wZW4gUGFyc2VyXG5cbiAgbW9kdWxlIEwgPSBMb2NhdGlvblxuXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuICBsZXQgbGV4X2Vycm9yIGxleGJ1ZiBtc2cgPVxuICAgIHJhaXNlIChTeW50YXguUGFyc2VFcnJvciAoU29tZSAoTC5vZl9sZXhidWYgbGV4YnVmKSwgU29tZSBtc2cpKVxuXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuICBsZXQgX2tleXdvcmRzID0gW1xuICAgIFwidHJ1ZVwiICAsIFRSVUUgIDtcbiAgICBcImV4aXN0c1wiLCBFWElTVFM7XG4gICAgXCJmYWxzZVwiICwgRkFMU0UgO1xuICAgIFwiZm9yYWxsXCIsIEZPUkFMTDtcbiAgICBcInJlY1wiICAgLCBSRUMgICA7XG4gICAgXCJ0eXBlXCIgICwgVFlQRSAgO1xuICBdXG5cbiAgKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG4gIGxldCBrZXl3b3JkcyA9XG4gICAgbGV0IHRhYmxlID0gSGFzaHRibC5jcmVhdGUgMCBpblxuICAgIExpc3QuaXRlciAoY3VycnkgKEhhc2h0YmwuYWRkIHRhYmxlKSkgX2tleXdvcmRzOyB0YWJsZVxuXG4jIDI4IFwibGlicy9lbmdpbmUvbGV4ZXIubWxcIlxubGV0IF9fb2NhbWxfbGV4X3RhYmxlcyA9IHtcbiAgTGV4aW5nLmxleF9iYXNlID1cbiAgIFwiXFwwMDBcXDAwMFxcMjMwXFwyNTVcXDIzMVxcMjU1XFwyMzJcXDI1NVxcMjMzXFwyNTVcXDIzNlxcMjU1XFwwMzNcXDAwMFxcMjM5XFwyNTVcXFxuICAgIFxcMjQwXFwyNTVcXDI0MVxcMjU1XFwwMDJcXDAwMFxcMDAwXFwwMDBcXDI0NVxcMjU1XFwwMThcXDAwMFxcMDAxXFwwMDBcXDI0OFxcMjU1XFxcbiAgICBcXDI0OVxcMjU1XFwyNTBcXDI1NVxcMjUxXFwyNTVcXDA3OVxcMDAwXFwwOThcXDAwMFxcMDAyXFwwMDBcXDI1NVxcMjU1XFwyNDdcXDI1NVxcXG4gICAgXFwyNDJcXDI1NVxcMjQ2XFwyNTVcXDI0NFxcMjU1XFwwMDJcXDAwMFxcMjQzXFwyNTVcXDIzNVxcMjU1XFwyMzdcXDI1NVwiO1xuICBMZXhpbmcubGV4X2JhY2t0cmsgPVxuICAgXCJcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAxN1xcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAyNVxcMDAwXFwwMjVcXDAwMFxcMjU1XFwyNTVcXDAyNVxcMDAwXFwwMjFcXDAwMFxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDAzXFwwMDBcXDAwMlxcMDAwXFwwMDFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XCI7XG4gIExleGluZy5sZXhfZGVmYXVsdCA9XG4gICBcIlxcMDAxXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcIjtcbiAgTGV4aW5nLmxleF90cmFucyA9XG4gICBcIlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMjFcXDAwMFxcMDIyXFwwMDBcXDAyMVxcMDAwXFwwMDBcXDAwMFxcMDIxXFwwMDBcXDAwMFxcMDAwXFwwMjFcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAyMVxcMDAwXFwwMDBcXDAwMFxcMDIxXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxNFxcMDAwXFwwMjNcXDAwMFxcXG4gICAgXFwwMThcXDAwMFxcMDE3XFwwMDBcXDAwM1xcMDAwXFwwMDRcXDAwMFxcMDA5XFwwMDBcXDAxMVxcMDAwXFwwMDhcXDAwMFxcMDI3XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDA2XFwwMDBcXDAwN1xcMDAwXFwwMTBcXDAwMFxcMDA1XFwwMDBcXDAyNlxcMDAwXFwwMjRcXDAwMFxcXG4gICAgXFwwMjhcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXFxuICAgIFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFxcbiAgICBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcXG4gICAgXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMzBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMjlcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFxcbiAgICBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcXG4gICAgXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXFxuICAgIFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDE2XFwwMDBcXDAxM1xcMDAwXFwwMTVcXDAwMFxcMDEyXFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDIwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMjVcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFxcbiAgICBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXFxuICAgIFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFxcbiAgICBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcXG4gICAgXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAyMFxcMDAwXFwwMDBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFxcbiAgICBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcXG4gICAgXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXFxuICAgIFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXCI7XG4gIExleGluZy5sZXhfY2hlY2sgPVxuICAgXCJcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMjFcXDAwMFxcMjU1XFwyNTVcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMDIxXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDAyMVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMDE0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTFcXDAwMFxcMDEzXFwwMDBcXFxuICAgIFxcMDI3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA2XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA2XFwwMDBcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAyMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDEzXFwwMDBcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcXG4gICAgXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFxcbiAgICBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcXG4gICAgXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXFxuICAgIFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwwMjBcXDAwMFxcMjU1XFwyNTVcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcXG4gICAgXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXFxuICAgIFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFxcbiAgICBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDAwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVwiO1xuICBMZXhpbmcubGV4X2Jhc2VfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2JhY2t0cmtfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2RlZmF1bHRfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X3RyYW5zX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9jaGVja19jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfY29kZSA9XG4gICBcIlwiO1xufVxuXG5sZXQgcmVjIG1haW4gbGV4YnVmID1cbiAgIF9fb2NhbWxfbGV4X21haW5fcmVjIGxleGJ1ZiAwXG5hbmQgX19vY2FtbF9sZXhfbWFpbl9yZWMgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlID1cbiAgbWF0Y2ggTGV4aW5nLmVuZ2luZSBfX29jYW1sX2xleF90YWJsZXMgX19vY2FtbF9sZXhfc3RhdGUgbGV4YnVmIHdpdGhcbiAgICAgIHwgMCAtPlxuIyA0MyBcImxpYnMvZW5naW5lL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICAgKCBMZXhpbmcubmV3X2xpbmUgbGV4YnVmOyBtYWluIGxleGJ1ZiApXG4jIDE1OCBcImxpYnMvZW5naW5lL2xleGVyLm1sXCJcblxuICB8IDEgLT5cbiMgNDQgXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICggbWFpbiBsZXhidWYgKVxuIyAxNjMgXCJsaWJzL2VuZ2luZS9sZXhlci5tbFwiXG5cbiAgfCAyIC0+XG5sZXRcbiMgNDUgXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuICAgICAgICAgICAgIGlkXG4jIDE2OSBcImxpYnMvZW5naW5lL2xleGVyLm1sXCJcbj0gTGV4aW5nLnN1Yl9sZXhlbWUgbGV4YnVmIGxleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BvcyBsZXhidWYuTGV4aW5nLmxleF9jdXJyX3BvcyBpblxuIyA0NSBcImxpYnMvZW5naW5lL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICAgKCB0cnkgSGFzaHRibC5maW5kIGtleXdvcmRzIGlkIHdpdGggTm90X2ZvdW5kIC0+IElERU5UIGlkIClcbiMgMTczIFwibGlicy9lbmdpbmUvbGV4ZXIubWxcIlxuXG4gIHwgMyAtPlxubGV0XG4jIDQ2IFwibGlicy9lbmdpbmUvbGV4ZXIubWxsXCJcbiAgICAgICAgICAgblxuIyAxNzkgXCJsaWJzL2VuZ2luZS9sZXhlci5tbFwiXG49IExleGluZy5zdWJfbGV4ZW1lIGxleGJ1ZiBsZXhidWYuTGV4aW5nLmxleF9zdGFydF9wb3MgbGV4YnVmLkxleGluZy5sZXhfY3Vycl9wb3MgaW5cbiMgNDYgXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICggTkFUIChpbnRfb2Zfc3RyaW5nIG4pIClcbiMgMTgzIFwibGlicy9lbmdpbmUvbGV4ZXIubWxcIlxuXG4gIHwgNCAtPlxuIyA0OCBcImxpYnMvZW5naW5lL2xleGVyLm1sbFwiXG4gICAgICAgICAgKCBMUEFSRU4gICAgKVxuIyAxODggXCJsaWJzL2VuZ2luZS9sZXhlci5tbFwiXG5cbiAgfCA1IC0+XG4jIDQ5IFwibGlicy9lbmdpbmUvbGV4ZXIubWxsXCJcbiAgICAgICAgICAoIFJQQVJFTiAgICApXG4jIDE5MyBcImxpYnMvZW5naW5lL2xleGVyLm1sXCJcblxuICB8IDYgLT5cbiMgNTAgXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuICAgICAgICAgICggTEJSQUNFICAgIClcbiMgMTk4IFwibGlicy9lbmdpbmUvbGV4ZXIubWxcIlxuXG4gIHwgNyAtPlxuIyA1MSBcImxpYnMvZW5naW5lL2xleGVyLm1sbFwiXG4gICAgICAgICAgKCBSQlJBQ0UgICAgKVxuIyAyMDMgXCJsaWJzL2VuZ2luZS9sZXhlci5tbFwiXG5cbiAgfCA4IC0+XG4jIDUyIFwibGlicy9lbmdpbmUvbGV4ZXIubWxsXCJcbiAgICAgICAgICAoIExBTkQgICAgICApXG4jIDIwOCBcImxpYnMvZW5naW5lL2xleGVyLm1sXCJcblxuICB8IDkgLT5cbiMgNTMgXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuICAgICAgICAgICggTE9SICAgICAgIClcbiMgMjEzIFwibGlicy9lbmdpbmUvbGV4ZXIubWxcIlxuXG4gIHwgMTAgLT5cbiMgNTQgXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuICAgICAgICAgICggTE5FRyAgICAgIClcbiMgMjE4IFwibGlicy9lbmdpbmUvbGV4ZXIubWxcIlxuXG4gIHwgMTEgLT5cbiMgNTUgXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuICAgICAgICAgICggTEFSUk9XICAgIClcbiMgMjIzIFwibGlicy9lbmdpbmUvbGV4ZXIubWxcIlxuXG4gIHwgMTIgLT5cbiMgNTYgXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuICAgICAgICAgICggTFJBUlJPVyAgIClcbiMgMjI4IFwibGlicy9lbmdpbmUvbGV4ZXIubWxcIlxuXG4gIHwgMTMgLT5cbiMgNTcgXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuICAgICAgICAgICggUFJPT0YgICAgIClcbiMgMjMzIFwibGlicy9lbmdpbmUvbGV4ZXIubWxcIlxuXG4gIHwgMTQgLT5cbiMgNTggXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuICAgICAgICAgICggQ09NTUEgICAgIClcbiMgMjM4IFwibGlicy9lbmdpbmUvbGV4ZXIubWxcIlxuXG4gIHwgMTUgLT5cbiMgNTkgXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuICAgICAgICAgICggRE9UICAgICAgIClcbiMgMjQzIFwibGlicy9lbmdpbmUvbGV4ZXIubWxcIlxuXG4gIHwgMTYgLT5cbiMgNjAgXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuICAgICAgICAgICggU0VNSUNPTE9OIClcbiMgMjQ4IFwibGlicy9lbmdpbmUvbGV4ZXIubWxcIlxuXG4gIHwgMTcgLT5cbiMgNjEgXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuICAgICAgICAgICggQ09MT04gICAgIClcbiMgMjUzIFwibGlicy9lbmdpbmUvbGV4ZXIubWxcIlxuXG4gIHwgMTggLT5cbiMgNjIgXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuICAgICAgICAgICggRENPTE9OICAgIClcbiMgMjU4IFwibGlicy9lbmdpbmUvbGV4ZXIubWxcIlxuXG4gIHwgMTkgLT5cbiMgNjMgXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuICAgICAgICAgICggRVEgICAgICAgIClcbiMgMjYzIFwibGlicy9lbmdpbmUvbGV4ZXIubWxcIlxuXG4gIHwgMjAgLT5cbiMgNjQgXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuICAgICAgICAgICggQ09MT05FUSAgIClcbiMgMjY4IFwibGlicy9lbmdpbmUvbGV4ZXIubWxcIlxuXG4gIHwgMjEgLT5cbiMgNjUgXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuICAgICAgICAgICggQU1QICAgICAgIClcbiMgMjczIFwibGlicy9lbmdpbmUvbGV4ZXIubWxcIlxuXG4gIHwgMjIgLT5cbiMgNjYgXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuICAgICAgICAgICggUExVUyAgICAgIClcbiMgMjc4IFwibGlicy9lbmdpbmUvbGV4ZXIubWxcIlxuXG4gIHwgMjMgLT5cbiMgNjcgXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuICAgICAgICAgICggU1RBUiAgICAgIClcbiMgMjgzIFwibGlicy9lbmdpbmUvbGV4ZXIubWxcIlxuXG4gIHwgMjQgLT5cbiMgNjkgXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuICAgICAgICAoIEVPRiApXG4jIDI4OCBcImxpYnMvZW5naW5lL2xleGVyLm1sXCJcblxuICB8IDI1IC0+XG5sZXRcbiMgNzEgXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuICAgICAgICAgIGNcbiMgMjk0IFwibGlicy9lbmdpbmUvbGV4ZXIubWxcIlxuPSBMZXhpbmcuc3ViX2xleGVtZV9jaGFyIGxleGJ1ZiBsZXhidWYuTGV4aW5nLmxleF9zdGFydF9wb3MgaW5cbiMgNzEgXCJsaWJzL2VuZ2luZS9sZXhlci5tbGxcIlxuICAgICAgICAgICAgKCBsZXhfZXJyb3IgbGV4YnVmIChQcmludGYuc3ByaW50ZiBcImlsbGVnYWwgY2hhcmFjdGVyOiAlY1wiIGMpIClcbiMgMjk4IFwibGlicy9lbmdpbmUvbGV4ZXIubWxcIlxuXG4gIHwgX19vY2FtbF9sZXhfc3RhdGUgLT4gbGV4YnVmLkxleGluZy5yZWZpbGxfYnVmZiBsZXhidWY7XG4gICAgICBfX29jYW1sX2xleF9tYWluX3JlYyBsZXhidWYgX19vY2FtbF9sZXhfc3RhdGVcblxuOztcblxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgIEJlbm9pdCBWYXVnb24sIEVOU1RBICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBQYWRkaW5nIHBvc2l0aW9uLiAqKVxudHlwZSBwYWR0eSA9XG4gIHwgTGVmdCAgICgqIFRleHQgaXMgbGVmdCBqdXN0aWZpZWQgKCctJyBvcHRpb24pLiAgICAgICAgICAgICAgICopXG4gIHwgUmlnaHQgICgqIFRleHQgaXMgcmlnaHQganVzdGlmaWVkIChubyAnLScgb3B0aW9uKS4gICAgICAgICAgICopXG4gIHwgWmVyb3MgICgqIFRleHQgaXMgcmlnaHQganVzdGlmaWVkIGJ5IHplcm9zIChzZWUgJzAnIG9wdGlvbikuICopXG5cbigqKiopXG5cbigqIEludGVnZXIgY29udmVyc2lvbi4gKilcbnR5cGUgaW50X2NvbnYgPVxuICB8IEludF9kIHwgSW50X3BkIHwgSW50X3NkICAgICAgICAoKiAgJWQgfCAlK2QgfCAlIGQgICopXG4gIHwgSW50X2kgfCBJbnRfcGkgfCBJbnRfc2kgICAgICAgICgqICAlaSB8ICUraSB8ICUgaSAgKilcbiAgfCBJbnRfeCB8IEludF9DeCAgICAgICAgICAgICAgICAgKCogICV4IHwgJSN4ICAgICAgICAqKVxuICB8IEludF9YIHwgSW50X0NYICAgICAgICAgICAgICAgICAoKiAgJVggfCAlI1ggICAgICAgICopXG4gIHwgSW50X28gfCBJbnRfQ28gICAgICAgICAgICAgICAgICgqICAlbyB8ICUjbyAgICAgICAgKilcbiAgfCBJbnRfdSAgICAgICAgICAgICAgICAgICAgICAgICAgKCogICV1ICAgICAgICAgICAgICAqKVxuICB8IEludF9DZCB8IEludF9DaSB8IEludF9DdSAgICAgICAoKiAgJSNkIHwgJSNpIHwgJSN1ICopXG5cbigqIEZsb2F0IGNvbnZlcnNpb24uICopXG50eXBlIGZsb2F0X2ZsYWdfY29udiA9XG4gIHwgRmxvYXRfZmxhZ18gICAgICAgICAgICAgICAgICAgICgqICVbZmVFZ0dGaEhdICopXG4gIHwgRmxvYXRfZmxhZ19wICAgICAgICAgICAgICAgICAgICgqICUrW2ZlRWdHRmhIXSAqKVxuICB8IEZsb2F0X2ZsYWdfcyAgICAgICAgICAgICAgICAgICAoKiAlIFtmZUVnR0ZoSF0gKilcbnR5cGUgZmxvYXRfa2luZF9jb252ID1cbiAgfCBGbG9hdF9mICAgICAgICAgICAgICAgICAgICAgICAgKCogICVmIHwgJStmIHwgJSBmICAqKVxuICB8IEZsb2F0X2UgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJWUgfCAlK2UgfCAlIGUgICopXG4gIHwgRmxvYXRfRSAgICAgICAgICAgICAgICAgICAgICAgICgqICAlRSB8ICUrRSB8ICUgRSAgKilcbiAgfCBGbG9hdF9nICAgICAgICAgICAgICAgICAgICAgICAgKCogICVnIHwgJStnIHwgJSBnICAqKVxuICB8IEZsb2F0X0cgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUcgfCAlK0cgfCAlIEcgICopXG4gIHwgRmxvYXRfRiAgICAgICAgICAgICAgICAgICAgICAgICgqICAlRiB8ICUrRiB8ICUgRiAgKilcbiAgfCBGbG9hdF9oICAgICAgICAgICAgICAgICAgICAgICAgKCogICVoIHwgJStoIHwgJSBoICAqKVxuICB8IEZsb2F0X0ggICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUggfCAlK0ggfCAlIEggICopXG4gIHwgRmxvYXRfQ0YgICAgICAgICAgICAgICAgICAgICAgICgqICAlI0Z8ICUrI0Z8ICUgI0YgKilcbnR5cGUgZmxvYXRfY29udiA9IGZsb2F0X2ZsYWdfY29udiAqIGZsb2F0X2tpbmRfY29udlxuXG4oKioqKVxuXG4oKiBDaGFyIHNldHMgKHNlZSAlWy4uLl0pIGFyZSBiaXRtYXBzIGltcGxlbWVudGVkIGFzIDMyLWNoYXIgc3RyaW5ncy4gKilcbnR5cGUgY2hhcl9zZXQgPSBzdHJpbmdcblxuKCoqKilcblxuKCogQ291bnRlciB1c2VkIGluIFNjYW5mLiAqKVxudHlwZSBjb3VudGVyID1cbiAgfCBMaW5lX2NvdW50ZXIgICAgICgqICAlbCAgICAgICopXG4gIHwgQ2hhcl9jb3VudGVyICAgICAoKiAgJW4gICAgICAqKVxuICB8IFRva2VuX2NvdW50ZXIgICAgKCogICVOLCAlTCAgKilcblxuKCoqKilcblxuKCogUGFkZGluZyBvZiBzdHJpbmdzIGFuZCBudW1iZXJzLiAqKVxudHlwZSAoJ2EsICdiKSBwYWRkaW5nID1cbiAgKCogTm8gcGFkZGluZyAoZXg6IFwiJWRcIikgKilcbiAgfCBOb19wYWRkaW5nICA6ICgnYSwgJ2EpIHBhZGRpbmdcbiAgKCogTGl0ZXJhbCBwYWRkaW5nIChleDogXCIlOGRcIikgKilcbiAgfCBMaXRfcGFkZGluZyA6IHBhZHR5ICogaW50IC0+ICgnYSwgJ2EpIHBhZGRpbmdcbiAgKCogUGFkZGluZyBhcyBleHRyYSBhcmd1bWVudCAoZXg6IFwiJSpkXCIpICopXG4gIHwgQXJnX3BhZGRpbmcgOiBwYWR0eSAtPiAoaW50IC0+ICdhLCAnYSkgcGFkZGluZ1xuXG4oKiBTb21lIGZvcm1hdHMsIHN1Y2ggYXMgJV9kLFxuICAgb25seSBhY2NlcHQgYW4gb3B0aW9uYWwgbnVtYmVyIGFzIHBhZGRpbmcgb3B0aW9uIChubyBleHRyYSBhcmd1bWVudCkgKilcbnR5cGUgcGFkX29wdGlvbiA9IGludCBvcHRpb25cblxuKCogUHJlY2lzaW9uIG9mIGZsb2F0cyBhbmQgJzAnLXBhZGRpbmcgb2YgaW50ZWdlcnMuICopXG50eXBlICgnYSwgJ2IpIHByZWNpc2lvbiA9XG4gICgqIE5vIHByZWNpc2lvbiAoZXg6IFwiJWZcIikgKilcbiAgfCBOb19wcmVjaXNpb24gOiAoJ2EsICdhKSBwcmVjaXNpb25cbiAgKCogTGl0ZXJhbCBwcmVjaXNpb24gKGV4OiBcIiUuM2ZcIikgKilcbiAgfCBMaXRfcHJlY2lzaW9uIDogaW50IC0+ICgnYSwgJ2EpIHByZWNpc2lvblxuICAoKiBQcmVjaXNpb24gYXMgZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUuKmZcIikgKilcbiAgfCBBcmdfcHJlY2lzaW9uIDogKGludCAtPiAnYSwgJ2EpIHByZWNpc2lvblxuXG4oKiBTb21lIGZvcm1hdHMsIHN1Y2ggYXMgJV9mLFxuICAgb25seSBhY2NlcHQgYW4gb3B0aW9uYWwgbnVtYmVyIGFzIHByZWNpc2lvbiBvcHRpb24gKG5vIGV4dHJhIGFyZ3VtZW50KSAqKVxudHlwZSBwcmVjX29wdGlvbiA9IGludCBvcHRpb25cblxuKCogc2VlIHRoZSBDdXN0b20gZm9ybWF0IGNvbWJpbmF0b3IgKilcbnR5cGUgKCdhLCAnYiwgJ2MpIGN1c3RvbV9hcml0eSA9XG4gIHwgQ3VzdG9tX3plcm8gOiAoJ2EsIHN0cmluZywgJ2EpIGN1c3RvbV9hcml0eVxuICB8IEN1c3RvbV9zdWNjIDogKCdhLCAnYiwgJ2MpIGN1c3RvbV9hcml0eSAtPlxuICAgICgnYSwgJ3ggLT4gJ2IsICd4IC0+ICdjKSBjdXN0b21fYXJpdHlcblxuKCoqKilcblxuKCogICAgICAgIFJlbGF0aW9uYWwgZm9ybWF0IHR5cGVzXG5cbkluIHRoZSBmaXJzdCBmb3JtYXQrZ2FkdHMgaW1wbGVtZW50YXRpb24sIHRoZSB0eXBlIGZvciAlKC4uJSkgaW4gdGhlXG5mbXQgR0FEVCB3YXMgYXMgZm9sbG93czpcblxufCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgcGFkX29wdGlvbiAqICgnZDEsICdxMSwgJ2QyLCAncTIpIHJlYWRlcl9uYl91bmlmaWVyICpcbiAgICAoJ3gsICdiLCAnYywgJ2QxLCAncTEsICd1KSBmbXR0eSAqXG4gICAgKCd1LCAnYiwgJ2MsICdxMSwgJ2UxLCAnZikgZm10IC0+XG4gICAgICAoKCd4LCAnYiwgJ2MsICdkMiwgJ3EyLCAndSkgZm9ybWF0NiAtPiAneCwgJ2IsICdjLCAnZDEsICdlMSwgJ2YpIGZtdFxuXG5Ob3RpY2UgdGhhdCB0aGUgJ3UgcGFyYW1ldGVyIGluICdmIHBvc2l0aW9uIGluIHRoZSBmb3JtYXQgYXJndW1lbnRcbigoJ3gsIC4uLCAndSkgZm9ybWF0NiAtPiAuLikgaXMgZXF1YWwgdG8gdGhlICd1IHBhcmFtZXRlciBpbiAnYVxucG9zaXRpb24gaW4gdGhlIGZvcm1hdCB0YWlsICgoJ3UsIC4uLCAnZikgZm10KS4gVGhpcyBtZWFucyB0aGF0IHRoZVxudHlwZSBvZiB0aGUgZXhwZWN0ZWQgZm9ybWF0IHBhcmFtZXRlciBkZXBlbmRzIG9mIHdoZXJlIHRoZSAlKC4uLiUpXG5hcmUgaW4gdGhlIGZvcm1hdCBzdHJpbmc6XG5cbiAgIyBQcmludGYucHJpbnRmIFwiJSglKVwiXG4gIC0gOiAodW5pdCwgb3V0X2NoYW5uZWwsIHVuaXQsICdfYSwgJ19hLCB1bml0KVxuICAgICAgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDYgLT4gdW5pdFxuICA9IDxmdW4+XG4gICMgUHJpbnRmLnByaW50ZiBcIiUoJSklZFwiXG4gIC0gOiAoaW50IC0+IHVuaXQsIG91dF9jaGFubmVsLCB1bml0LCAnX2EsICdfYSwgaW50IC0+IHVuaXQpXG4gICAgICBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NiAtPiBpbnQgLT4gdW5pdFxuICA9IDxmdW4+XG5cbk9uIHRoZSBjb250cmFyeSwgdGhlIGxlZ2FjeSB0eXBlciBnaXZlcyBhIGNsZXZlciB0eXBlIHRoYXQgZG9lcyBub3RcbmRlcGVuZCBvbiB0aGUgcG9zaXRpb24gb2YgJSguLiUpIGluIHRoZSBmb3JtYXQgc3RyaW5nLiBGb3IgZXhhbXBsZSxcbiUoJSkgd2lsbCBoYXZlIHRoZSBwb2x5bW9ycGhpYyB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKTogaXQgY2FuXG5iZSBjb25jYXRlbmF0ZWQgdG8gYW55IGZvcm1hdCB0eXBlLCBhbmQgb25seSBlbmZvcmNlcyB0aGUgY29uc3RyYWludFxudGhhdCBpdHMgJ2EgYW5kICdmIHBhcmFtZXRlcnMgYXJlIGVxdWFsIChubyBmb3JtYXQgYXJndW1lbnRzKSBhbmQgJ2RcbmFuZCAnZSBhcmUgZXF1YWwgKG5vIHJlYWRlciBhcmd1bWVudCkuXG5cblRoZSB3ZWFrZW5pbmcgb2YgdGhpcyBwYXJhbWV0ZXIgdHlwZSBpbiB0aGUgR0FEVCB2ZXJzaW9uIGJyb2tlIHVzZXJcbmNvZGUgKGluIGZhY3QgaXQgZXNzZW50aWFsbHkgbWFkZSAlKC4uLiUpIHVudXNhYmxlIGV4Y2VwdCBhdCB0aGUgbGFzdFxucG9zaXRpb24gb2YgYSBmb3JtYXQpLiBJbiBwYXJ0aWN1bGFyLCB0aGUgZm9sbG93aW5nIHdvdWxkIG5vdCB3b3JrXG5hbnltb3JlOlxuXG4gIGZ1biBzZXAgLT5cbiAgICBGb3JtYXQucHJpbnRmIFwiZm9vJSglKWJhciUoJSliYXpcIiBzZXAgc2VwXG5cbkFzIHRoZSB0eXBlLWNoZWNrZXIgd291bGQgcmVxdWlyZSB0d28gKmluY29tcGF0aWJsZSogdHlwZXMgZm9yIHRoZSAlKCUpXG5pbiBkaWZmZXJlbnQgcG9zaXRpb25zLlxuXG5UaGUgc29sdXRpb24gdG8gcmVnYWluIGEgZ2VuZXJhbCB0eXBlIGZvciAlKC4uJSkgaXMgdG8gZ2VuZXJhbGl6ZSB0aGlzXG50ZWNobmlxdWUsIG5vdCBvbmx5IG9uIHRoZSAnZCwgJ2UgcGFyYW1ldGVycywgYnV0IG9uIGFsbCBzaXhcbnBhcmFtZXRlcnMgb2YgYSBmb3JtYXQ6IHdlIGludHJvZHVjZSBhIFwicmVsYXRpb25hbFwiIHR5cGVcbiAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbndob3NlIHZhbHVlcyBhcmUgcHJvb2ZzIHRoYXQgKCdhMSwgLi4sICdmMSkgYW5kICgnYTIsIC4uLCAnZjIpIG1vcmFsbHlcbmNvcnJlc3BvbmQgdG8gdGhlIHNhbWUgZm9ybWF0IHR5cGU6ICdhMSBpcyBvYnRhaW5lZCBmcm9tICdmMSwnYjEsJ2MxXG5pbiB0aGUgZXhhY3Qgc2FtZSB3YXkgdGhhdCAnYTIgaXMgb2J0YWluZWQgZnJvbSAnZjIsJ2IyLCdjMiwgZXRjLlxuXG5Gb3IgZXhhbXBsZSwgdGhlIHJlbGF0aW9uIGJldHdlZW4gdHdvIGZvcm1hdCB0eXBlcyBiZWdpbm5pbmcgd2l0aCBhIENoYXJcbnBhcmFtZXRlciBpcyBhcyBmb2xsb3dzOlxuXG58IENoYXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAgKilcbiAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgKGNoYXIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgY2hhciAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuSW4gdGhlIGdlbmVyYWwgY2FzZSwgdGhlIHRlcm0gc3RydWN0dXJlIG9mIGZtdHR5X3JlbCBpcyAoYWxtb3N0WzFdKVxuaXNvbW9ycGhpYyB0byB0aGUgZm10dHkgb2YgdGhlIHByZXZpb3VzIGltcGxlbWVudGF0aW9uOiBldmVyeVxuY29uc3RydWN0b3IgaXMgcmUtcmVhZCB3aXRoIGEgYmluYXJ5LCByZWxhdGlvbmFsIHR5cGUsIGluc3RlYWQgb2YgdGhlXG5wcmV2aW91cyB1bmFyeSB0eXBpbmcuIGZtdHR5IGNhbiB0aGVuIGJlIHJlLWRlZmluZWQgYXMgdGhlIGRpYWdvbmFsIG9mXG5mbXR0eV9yZWw6XG5cbiAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgPVxuICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmLFxuICAgICAgICAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9yZWxcblxuT25jZSB3ZSBoYXZlIHRoaXMgZm10dHlfcmVsIHR5cGUgaW4gcGxhY2UsIHdlIGNhbiBnaXZlIHRoZSBtb3JlXG5nZW5lcmFsIHR5cGUgdG8gJSguLi4lKTpcblxufCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgcGFkX29wdGlvbiAqXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMiwgJ2IsICdjLCAnajIsICdkLCAnYSkgZm10dHlfcmVsICpcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IsICdjLCAnajIsICdlLCAnZikgZm10XG5cbldlIGFjY2VwdCBhbnkgZm9ybWF0ICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NikgKHRoaXMgaXNcbmNvbXBsZXRlbHkgdW5yZWxhdGVkIHRvIHRoZSB0eXBlIG9mIHRoZSBjdXJyZW50IGZvcm1hdCksIGJ1dCBhbHNvXG5yZXF1aXJlIGEgcHJvb2YgdGhhdCB0aGlzIGZvcm1hdCBpcyBpbiByZWxhdGlvbiB0byBhbm90aGVyIGZvcm1hdCB0aGF0XG5pcyBjb25jYXRlbmFibGUgdG8gdGhlIGZvcm1hdCB0YWlsLiBXaGVuIGV4ZWN1dGluZyBhICUoLi4uJSkgZm9ybWF0XG4oaW4gY2FtbGludGVybmFsRm9ybWF0Lm1sOm1ha2VfcHJpbnRmIG9yIHNjYW5mLm1sOm1ha2Vfc2NhbmYpLCB3ZVxudHJhbnN0eXBlIHRoZSBmb3JtYXQgYWxvbmcgdGhpcyByZWxhdGlvbiB1c2luZyB0aGUgJ3JlY2FzdCcgZnVuY3Rpb25cbnRvIHRyYW5zcG9zZSBiZXR3ZWVuIHJlbGF0ZWQgZm9ybWF0IHR5cGVzLlxuXG4gIHZhbCByZWNhc3QgOlxuICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSkgZm10XG4gIC0+ICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIC0+ICgnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXRcblxuTk9URSBbMV06IHRoZSB0eXBpbmcgb2YgRm9ybWF0X3N1YnN0X3R5IHJlcXVpcmVzIG5vdCBvbmUgZm9ybWF0IHR5cGUsIGJ1dFxudHdvLCBvbmUgdG8gZXN0YWJsaXNoIHRoZSBsaW5rIGJldHdlZW4gdGhlIGZvcm1hdCBhcmd1bWVudCBhbmQgdGhlXG5maXJzdCBzaXggcGFyYW1ldGVycywgYW5kIHRoZSBvdGhlciBmb3IgdGhlIGxpbmsgYmV0d2VlbiB0aGUgZm9ybWF0XG5hcmd1bWVudCBhbmQgdGhlIGxhc3Qgc2l4IHBhcmFtZXRlcnMuXG5cbnwgRm9ybWF0X3N1YnN0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZDEsICdhMSkgZm10dHlfcmVsICpcbiAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZDIsICdhMikgZm10dHlfcmVsICpcbiAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2UxLCAnZjEsXG4gICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG5XaGVuIHdlIGdlbmVyYXRlIGEgZm9ybWF0IEFTVCwgd2UgZ2VuZXJhdGUgZXhhY3RseSB0aGUgc2FtZSB3aXRuZXNzXG5mb3IgYm90aCByZWxhdGlvbnMsIGFuZCB0aGUgd2l0bmVzcy1jb252ZXJzaW9uIGZ1bmN0aW9ucyBpblxuY2FtbGludGVybmFsRm9ybWF0IGRvIHJlbHkgb24gdGhpcyBpbnZhcmlhbnQuIEZvciBleGFtcGxlLCB0aGVcbmZ1bmN0aW9uIHRoYXQgcHJvdmVzIHRoYXQgdGhlIHJlbGF0aW9uIGlzIHRyYW5zaXRpdmVcblxuICB2YWwgdHJhbnMgOlxuICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICAtPiAoJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMixcbiAgICAgICdhMywgJ2IzLCAnYzMsICdkMywgJ2UzLCAnZjMpIGZtdHR5X3JlbFxuICAtPiAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMywgJ2IzLCAnYzMsICdkMywgJ2UzLCAnZjMpIGZtdHR5X3JlbFxuXG5kb2VzIGFzc3VtZSB0aGF0IHRoZSB0d28gaW5wdXRzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSB0ZXJtIHN0cnVjdHVyZVxuKGFuZCBpcyBvbmx5IGV2ZXJ5IHVzZWQgZm9yIGFyZ3VtZW50IHdpdG5lc3NlcyBvZiB0aGVcbkZvcm1hdF9zdWJzdF90eSBjb25zdHJ1Y3RvcikuXG4qKVxuXG4oKiBUeXBlIG9mIGEgYmxvY2sgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSBibG9ja190eXBlID1cbiAgfCBQcF9oYm94ICAgKCogSG9yaXpvbnRhbCBibG9jayBubyBsaW5lIGJyZWFraW5nICopXG4gIHwgUHBfdmJveCAgICgqIFZlcnRpY2FsIGJsb2NrIGVhY2ggYnJlYWsgbGVhZHMgdG8gYSBuZXcgbGluZSAqKVxuICB8IFBwX2h2Ym94ICAoKiBIb3Jpem9udGFsLXZlcnRpY2FsIGJsb2NrOiBzYW1lIGFzIHZib3gsIGV4Y2VwdCBpZiB0aGlzIGJsb2NrXG4gICAgICAgICAgICAgICAgIGlzIHNtYWxsIGVub3VnaCB0byBmaXQgb24gYSBzaW5nbGUgbGluZSAqKVxuICB8IFBwX2hvdmJveCAoKiBIb3Jpem9udGFsIG9yIFZlcnRpY2FsIGJsb2NrOiBicmVha3MgbGVhZCB0byBuZXcgbGluZVxuICAgICAgICAgICAgICAgICBvbmx5IHdoZW4gbmVjZXNzYXJ5IHRvIHByaW50IHRoZSBjb250ZW50IG9mIHRoZSBibG9jayAqKVxuICB8IFBwX2JveCAgICAoKiBIb3Jpem9udGFsIG9yIEluZGVudCBibG9jazogYnJlYWtzIGxlYWQgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgb25seSB3aGVuIG5lY2Vzc2FyeSB0byBwcmludCB0aGUgY29udGVudCBvZiB0aGUgYmxvY2ssIG9yXG4gICAgICAgICAgICAgICAgIHdoZW4gaXQgbGVhZHMgdG8gYSBuZXcgaW5kZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgbGluZSAqKVxuICB8IFBwX2ZpdHMgICAoKiBJbnRlcm5hbCB1c2FnZTogd2hlbiBhIGJsb2NrIGZpdHMgb24gYSBzaW5nbGUgbGluZSAqKVxuXG4oKiBGb3JtYXR0aW5nIGVsZW1lbnQgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSBmb3JtYXR0aW5nX2xpdCA9XG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBdICAgKilcbiAgfCBDbG9zZV90YWcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQH0gICAqKVxuICB8IEJyZWFrIG9mIHN0cmluZyAqIGludCAqIGludCAgICAgICAgICAoKiBALCB8IEAgIHwgQDsgfCBAOzw+ICopXG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEA/ICAgKilcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQFxcbiAgKilcbiAgfCBGbHVzaF9uZXdsaW5lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQC4gICAqKVxuICB8IE1hZ2ljX3NpemUgb2Ygc3RyaW5nICogaW50ICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAPG4+ICopXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBAICAgKilcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQCUlICAqKVxuICB8IFNjYW5faW5kaWMgb2YgY2hhciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAWCAgICopXG5cbigqIEZvcm1hdHRpbmcgZWxlbWVudCB1c2VkIGJ5IHRoZSBGb3JtYXQgcHJldHR5LXByaW50ZXIuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXR0aW5nX2dlbiA9XG4gIHwgT3Blbl90YWcgOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAgICAgICgqIEB7ICAgKilcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW5cbiAgfCBPcGVuX2JveCA6ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICAgICAgKCogQFsgICAqKVxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXR0aW5nX2dlblxuXG4oKioqKVxuXG4oKiBMaXN0IG9mIGZvcm1hdCB0eXBlIGVsZW1lbnRzLiAqKVxuKCogSW4gcGFydGljdWxhciB1c2VkIHRvIHJlcHJlc2VudCAlKC4uLiUpIGFuZCAley4uLiV9IGNvbnRlbnRzLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSA9XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmLFxuICAgICAgJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfcmVsXG5hbmQgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCA9XG4gIHwgQ2hhcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVjICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoY2hhciAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGNoYXIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgU3RyaW5nX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVzICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoc3RyaW5nIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgc3RyaW5nIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEludF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlZCAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGludCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnQzMl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWxkICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQzMiAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludDMyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IE5hdGl2ZWludF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbmQgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKG5hdGl2ZWludCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIG5hdGl2ZWludCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnQ2NF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUxkICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQ2NCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludDY0IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEZsb2F0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlZiAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGZsb2F0IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgZmxvYXQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgQm9vbF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVCICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoYm9vbCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGJvb2wgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbiAgfCBGb3JtYXRfYXJnX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXsuLi4lfSAqKVxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5ICpcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMilcbiAgICAgICAgICAgZm10dHlfcmVsXG4gIHwgRm9ybWF0X3N1YnN0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAgICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2QxLCAnYTEpIGZtdHR5X3JlbCAqXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzIsICdiMiwgJ2MyLCAnajIsICdkMiwgJ2EyKSBmbXR0eV9yZWwgKlxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZTEsICdmMSxcbiAgICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiMiwgJ2MyLCAnajIsICdlMiwgJ2YyKVxuICAgICAgICAgICBmbXR0eV9yZWxcblxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnMuICopXG4gIHwgQWxwaGFfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVhICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdiMSAtPiAneCAtPiAnYzEpIC0+ICd4IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdiMiAtPiAneCAtPiAnYzIpIC0+ICd4IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IFRoZXRhX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAldCAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnYjEgLT4gJ2MxKSAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnYjIgLT4gJ2MyKSAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBBbnlfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFVzZWQgZm9yIGN1c3RvbSBmb3JtYXRzICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgneCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICd4IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yLiAqKVxuICB8IFJlYWRlcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlciAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCd4IC0+ICdhMSwgJ2IxLCAnYzEsICgnYjEgLT4gJ3gpIC0+ICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ3ggLT4gJ2EyLCAnYjIsICdjMiwgKCdiMiAtPiAneCkgLT4gJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfciAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICgnYjEgLT4gJ3gpIC0+ICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgKCdiMiAtPiAneCkgLT4gJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbiAgfCBFbmRfb2ZfZm10dHkgOlxuICAgICAgKCdmMSwgJ2IxLCAnYzEsICdkMSwgJ2QxLCAnZjEsXG4gICAgICAgJ2YyLCAnYjIsICdjMiwgJ2QyLCAnZDIsICdmMikgZm10dHlfcmVsXG5cbigqKiopXG5cbigqIExpc3Qgb2YgZm9ybWF0IGVsZW1lbnRzLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgPVxuICB8IENoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENhbWxfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVDICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFN0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVzICopXG4gICAgICAoJ3gsIHN0cmluZyAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENhbWxfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVTICopXG4gICAgICAoJ3gsIHN0cmluZyAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQzMiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbFtkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGludDMyIC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgTmF0aXZlaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJW5bZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBuYXRpdmVpbnQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQ2NCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlTFtkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGludDY0IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRmxvYXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtmZUVnR0ZoSF0gKilcbiAgICAgIGZsb2F0X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBmbG9hdCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEJvb2wgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbYkJdICopXG4gICAgICAoJ3gsIGJvb2wgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGbHVzaCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlISAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBhYmMgKilcbiAgICAgIHN0cmluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENoYXJfbGl0ZXJhbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIHggKilcbiAgICAgIGNoYXIgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICB8IEZvcm1hdF9hcmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV7Li4uJX0gKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm10dHkgKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgICAgcGFkX29wdGlvbiAqXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzIsICdiLCAnYywgJ2oyLCAnZCwgJ2EpIGZtdHR5X3JlbCAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYiwgJ2MsICdqMiwgJ2UsICdmKSBmbXRcblxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3Rvci4gKilcbiAgfCBBbHBoYSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYSAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdiIC0+ICd4IC0+ICdjKSAtPiAneCAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBUaGV0YSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAldCAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdiIC0+ICdjKSAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3I6ICopXG4gIHwgRm9ybWF0dGluZ19saXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQF8gKilcbiAgICAgIGZvcm1hdHRpbmdfbGl0ICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRm9ybWF0dGluZ19nZW4gOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBfICopXG4gICAgICAoJ2ExLCAnYiwgJ2MsICdkMSwgJ2UxLCAnZjEpIGZvcm1hdHRpbmdfZ2VuICpcbiAgICAgICgnZjEsICdiLCAnYywgJ2UxLCAnZTIsICdmMikgZm10IC0+ICgnYTEsICdiLCAnYywgJ2QxLCAnZTIsICdmMikgZm10XG5cbiAgKCogU2NhbmYgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IFJlYWRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVyICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCAtPiAnYSwgJ2IsICdjLCAoJ2IgLT4gJ3gpIC0+ICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fY2hhcl9zZXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbLi4uXSAqKVxuICAgICAgcGFkX29wdGlvbiAqIGNoYXJfc2V0ICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoc3RyaW5nIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbbmxOTF0gKilcbiAgICAgIGNvdW50ZXIgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChpbnQgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgU2Nhbl9uZXh0X2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJTBjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJZ25vcmVkX3BhcmFtIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGlnbm9yZWQgKiAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBDdXN0b20gcHJpbnRpbmcgZm9ybWF0IChQUiM2NDUyLCBHUFIjMTQwKVxuXG4gICAgIFdlIGluY2x1ZGUgYSB0eXBlIEN1c3RvbSBvZiBcImN1c3RvbSBjb252ZXJ0ZXJzXCIsIHdoZXJlIGFuXG4gICAgIGFyYml0cmFyeSBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBjb252ZXJ0IG9uZSBvciBtb3JlXG4gICAgIGFyZ3VtZW50cy4gVGhlcmUgaXMgbm8gc3ludGF4IGZvciBjdXN0b20gY29udmVydGVycywgaXQgaXMgb25seVxuICAgICBpbnRlbmRlZCBmb3IgY3VzdG9tIHByb2Nlc3NvcnMgdGhhdCB3aXNoIHRvIHJlbHkgb24gdGhlXG4gICAgIHN0ZGxpYi1kZWZpbmVkIGZvcm1hdCBHQURUcy5cblxuICAgICBGb3IgaW5zdGFuY2UgYSBwcmUtcHJvY2Vzc29yIGNvdWxkIGNob29zZSB0byBpbnRlcnByZXQgc3RyaW5nc1xuICAgICBwcmVmaXhlZCB3aXRoIFtcIiFcIl0gYXMgZm9ybWF0IHN0cmluZ3Mgd2hlcmUgWyV7eyAuLi4gfX1dIGlzXG4gICAgIGEgc3BlY2lhbCBmb3JtIHRvIHBhc3MgYSB0b19zdHJpbmcgZnVuY3Rpb24sIHNvIHRoYXQgb25lIGNvdWxkXG4gICAgIHdyaXRlOlxuXG4gICAgIHtbXG4gICAgICAgdHlwZSB0ID0geyB4IDogaW50OyB5IDogaW50IH1cblxuICAgICAgIGxldCBzdHJpbmdfb2ZfdCB0ID0gUHJpbnRmLnNwcmludGYgXCJ7IHggPSAlZDsgeSA9ICVkIH1cIiB0LnggdC55XG5cbiAgICAgICBQcmludGYucHJpbnRmICFcInQgPSAle3tzdHJpbmdfb2ZfdH19XCIgeyB4ID0gNDI7IHkgPSA0MiB9XG4gICAgIF19XG4gICopXG4gIHwgQ3VzdG9tIDpcbiAgICAgICgnYSwgJ3gsICd5KSBjdXN0b21fYXJpdHkgKiAodW5pdCAtPiAneCkgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoJ3ksICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogZW5kIG9mIGEgZm9ybWF0IHNwZWNpZmljYXRpb24gKilcbiAgfCBFbmRfb2ZfZm9ybWF0IDpcbiAgICAgICAgKCdmLCAnYiwgJ2MsICdlLCAnZSwgJ2YpIGZtdFxuXG4oKioqKVxuXG4oKiBUeXBlIGZvciBpZ25vcmVkIHBhcmFtZXRlcnMgKHNlZSBcIiVfXCIpLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBpZ25vcmVkID1cbiAgfCBJZ25vcmVkX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2MgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9DICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfcyAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfUyAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQzMiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9sZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9uZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQ2NCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9MZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mbG9hdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9mICopXG4gICAgICBwYWRfb3B0aW9uICogcHJlY19vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Jvb2wgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX0IgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3suLi4lfSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfKC4uLiUpICopXG4gICAgICBwYWRfb3B0aW9uICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9yZWFkZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9yICopXG4gICAgICAoJ2EsICdiLCAnYywgKCdiIC0+ICd4KSAtPiAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9bLi4uXSAqKVxuICAgICAgcGFkX29wdGlvbiAqIGNoYXJfc2V0IC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9bbmxOTF0gKilcbiAgICAgIGNvdW50ZXIgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXzBjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuXG5hbmQgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPVxuICBGb3JtYXQgb2YgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAqIHN0cmluZ1xuXG5sZXQgcmVjIGVyYXNlX3JlbCA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIGkgaiBrIGwgLlxuICAoYSwgYiwgYywgZCwgZSwgZixcbiAgIGcsIGgsIGksIGosIGssIGwpIGZtdHR5X3JlbCAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHlcbj0gZnVuY3Rpb25cbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBDaGFyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIFN0cmluZ190eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBJbnRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBJbnQzMl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIEludDY0X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIE5hdGl2ZWludF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIEZsb2F0X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBCb29sX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgZXJhc2VfcmVsIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIF90eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MSwgZXJhc2VfcmVsIHJlc3QpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPlxuICAgIEFscGhhX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgVGhldGFfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgQW55X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPlxuICAgIFJlYWRlcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHR5cGUgY29uY2F0ZW5hdGlvbiAqKVxuXG4oKiBDb25jYXRlbmF0ZSB0d28gZm9ybWF0IHR5cGVzLiAqKVxuKCogVXNlZCBieTpcbiAgICogcmVhZGVyX25iX3VuaWZpZXJfb2ZfZm10dHkgdG8gY291bnQgcmVhZGVycyBpbiBhbiBmbXR0eSxcbiAgICogU2NhbmYudGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyB0byBleHRyYWN0IHJlYWRlcnMgaW5zaWRlICUoLi4uJSksXG4gICAqIENhbWxpbnRlcm5hbEZvcm1hdC5mbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCB0byBleHRyYWN0IGZvcm1hdCB0eXBlLiAqKVxuXG4oKlxubGV0IHJlYyBjb25jYXRfZm10dHkgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCAuXG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGYsIGIsIGMsIGUsIGcsIGgpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGcsIGgpIGZtdHR5ID1cbiopXG5sZXQgcmVjIGNvbmNhdF9mbXR0eSA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMlxuICAgICAgIGcxIGoxIGcyIGoyXG4gIC5cbiAgICAoZzEsIGIxLCBjMSwgajEsIGQxLCBhMSxcbiAgICAgZzIsIGIyLCBjMiwgajIsIGQyLCBhMikgZm10dHlfcmVsIC0+XG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbCAtPlxuICAgIChnMSwgYjEsIGMxLCBqMSwgZTEsIGYxLFxuICAgICBnMiwgYjIsIGMyLCBqMiwgZTIsIGYyKSBmbXR0eV9yZWwgPVxuZnVuIGZtdHR5MSBmbXR0eTIgLT4gbWF0Y2ggZm10dHkxIHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBDaGFyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBTdHJpbmdfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIEludF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBJbnQzMl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+XG4gICAgTmF0aXZlaW50X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIEludDY0X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIEZsb2F0X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgQm9vbF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBBbHBoYV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFRoZXRhX3R5IHJlc3QgLT5cbiAgICBUaGV0YV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgQW55X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBSZWFkZXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEVuZF9vZl9mbXR0eSAtPiBmbXR0eTJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBjb25jYXRlbmF0aW9uICopXG5cbigqIENvbmNhdGVuYXRlIHR3byBmb3JtYXRzLiAqKVxubGV0IHJlYyBjb25jYXRfZm10IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggLlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoZiwgYiwgYywgZSwgZywgaCkgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGcsIGgpIGZtdCA9XG5mdW4gZm10MSBmbXQyIC0+IG1hdGNoIGZtdDEgd2l0aFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIFN0cmluZyAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIENhbWxfc3RyaW5nIChwYWQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgSW50MzIgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludDY0IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBDaGFyIChyZXN0KSAtPlxuICAgIENoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgQ2FtbF9jaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgQm9vbCAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBBbHBoYSByZXN0IC0+XG4gICAgQWxwaGEgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFRoZXRhIHJlc3QgLT5cbiAgICBUaGV0YSAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ3VzdG9tIChhcml0eSwgZiwgcmVzdCkgLT5cbiAgICBDdXN0b20gKGFyaXR5LCBmLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBSZWFkZXIgcmVzdCAtPlxuICAgIFJlYWRlciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIEZsdXNoIChjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgU3RyaW5nX2xpdGVyYWwgKHN0ciwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgQ2hhcl9saXRlcmFsICAgKGNociwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBGb3JtYXRfYXJnIChwYWQsIGZtdHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmcgICAocGFkLCBmbXR0eSwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWQsIGZtdHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdCAocGFkLCBmbXR0eSwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgIFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgKHJlc3QpIC0+XG4gICAgU2Nhbl9uZXh0X2NoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBJZ25vcmVkX3BhcmFtIChpZ24sIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpIC0+XG4gICAgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAtPlxuICAgIEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBmbXQyXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBHYWJyaWVsIFNjaGVyZXIsIHByb2pldCBQYXJ0b3V0LCBJTlJJQSBQYXJpcy1TYWNsYXkgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDIwIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENhbWxpbnRlcm5hbEF0b21pYyBpcyBhIGRlcGVuZGVuY3kgb2YgU3RkbGliLCBzbyBpdCBpcyBjb21waWxlZCB3aXRoXG4gICAtbm9wZXJ2YXNpdmVzLiAqKVxuZXh0ZXJuYWwgKCA9PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxXCJcbmV4dGVybmFsICggKyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuZXh0ZXJuYWwgaWdub3JlIDogJ2EgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5cbigqIFdlIGFyZSBub3QgcmV1c2luZyAoJ2EgcmVmKSBkaXJlY3RseSB0byBtYWtlIGl0IGVhc2llciB0byByZWFzb25cbiAgIGFib3V0IGF0b21pY2l0eSBpZiB3ZSB3aXNoIHRvOiBldmVuIGluIGEgc2VxdWVudGlhbCBpbXBsZW1lbnRhdGlvbixcbiAgIHNpZ25hbHMgYW5kIG90aGVyIGFzeW5jaHJvbm91cyBjYWxsYmFja3MgbWlnaHQgYnJlYWsgYXRvbWljaXR5LiAqKVxudHlwZSAnYSB0ID0ge211dGFibGUgdjogJ2F9XG5cbmxldCBtYWtlIHYgPSB7dn1cbmxldCBnZXQgciA9IHIudlxubGV0IHNldCByIHYgPSByLnYgPC0gdlxuXG4oKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBhcmUgc2V0IHRvIG5ldmVyIGJlIGlubGluZWQ6IEZsYW1iZGEgaXNcbiAgIGFsbG93ZWQgdG8gbW92ZSBzdXJyb3VuZGluZyBjb2RlIGluc2lkZSB0aGUgY3JpdGljYWwgc2VjdGlvbixcbiAgIGluY2x1ZGluZyBhbGxvY2F0aW9ucy4gKilcblxubGV0W0BpbmxpbmUgbmV2ZXJdIGV4Y2hhbmdlIHIgdiA9XG4gICgqIEJFR0lOIEFUT01JQyAqKVxuICBsZXQgY3VyID0gci52IGluXG4gIHIudiA8LSB2O1xuICAoKiBFTkQgQVRPTUlDICopXG4gIGN1clxuXG5sZXRbQGlubGluZSBuZXZlcl0gY29tcGFyZV9hbmRfc2V0IHIgc2VlbiB2ID1cbiAgKCogQkVHSU4gQVRPTUlDICopXG4gIGxldCBjdXIgPSByLnYgaW5cbiAgaWYgY3VyID09IHNlZW4gdGhlbiAoXG4gICAgci52IDwtIHY7XG4gICAgKCogRU5EIEFUT01JQyAqKVxuICAgIHRydWVcbiAgKSBlbHNlXG4gICAgZmFsc2VcblxubGV0W0BpbmxpbmUgbmV2ZXJdIGZldGNoX2FuZF9hZGQgciBuID1cbiAgKCogQkVHSU4gQVRPTUlDICopXG4gIGxldCBjdXIgPSByLnYgaW5cbiAgci52IDwtIChjdXIgKyBuKTtcbiAgKCogRU5EIEFUT01JQyAqKVxuICBjdXJcblxubGV0IGluY3IgciA9IGlnbm9yZSAoZmV0Y2hfYW5kX2FkZCByIDEpXG5sZXQgZGVjciByID0gaWdub3JlIChmZXRjaF9hbmRfYWRkIHIgKC0xKSlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogRXhjZXB0aW9ucyAqKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiAnYSAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCAoKSA9XG4gICgqIGZvciBydW50aW1lL2ZhaWxfbmF0LmMgKilcbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgXCJQZXJ2YXNpdmVzLmFycmF5X2JvdW5kX2Vycm9yXCJcbiAgICAoSW52YWxpZF9hcmd1bWVudCBcImluZGV4IG91dCBvZiBib3VuZHNcIilcblxuZXh0ZXJuYWwgcmFpc2UgOiBleG4gLT4gJ2EgPSBcIiVyYWlzZVwiXG5leHRlcm5hbCByYWlzZV9ub3RyYWNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2Vfbm90cmFjZVwiXG5cbmxldCBmYWlsd2l0aCBzID0gcmFpc2UoRmFpbHVyZSBzKVxubGV0IGludmFsaWRfYXJnIHMgPSByYWlzZShJbnZhbGlkX2FyZ3VtZW50IHMpXG5cbmV4Y2VwdGlvbiBFeGl0XG5leGNlcHRpb24gTWF0Y2hfZmFpbHVyZSA9IE1hdGNoX2ZhaWx1cmVcbmV4Y2VwdGlvbiBBc3NlcnRfZmFpbHVyZSA9IEFzc2VydF9mYWlsdXJlXG5leGNlcHRpb24gSW52YWxpZF9hcmd1bWVudCA9IEludmFsaWRfYXJndW1lbnRcbmV4Y2VwdGlvbiBGYWlsdXJlID0gRmFpbHVyZVxuZXhjZXB0aW9uIE5vdF9mb3VuZCA9IE5vdF9mb3VuZFxuZXhjZXB0aW9uIE91dF9vZl9tZW1vcnkgPSBPdXRfb2ZfbWVtb3J5XG5leGNlcHRpb24gU3RhY2tfb3ZlcmZsb3cgPSBTdGFja19vdmVyZmxvd1xuZXhjZXB0aW9uIFN5c19lcnJvciA9IFN5c19lcnJvclxuZXhjZXB0aW9uIEVuZF9vZl9maWxlID0gRW5kX29mX2ZpbGVcbmV4Y2VwdGlvbiBEaXZpc2lvbl9ieV96ZXJvID0gRGl2aXNpb25fYnlfemVyb1xuZXhjZXB0aW9uIFN5c19ibG9ja2VkX2lvID0gU3lzX2Jsb2NrZWRfaW9cbmV4Y2VwdGlvbiBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSA9IFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlXG5cbigqIENvbXBvc2l0aW9uIG9wZXJhdG9ycyAqKVxuXG5leHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoJ2EgLT4gJ2IpIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuZXh0ZXJuYWwgKCBAQCApIDogKCdhIC0+ICdiKSAtPiAnYSAtPiAnYiA9IFwiJWFwcGx5XCJcblxuKCogRGVidWdnaW5nICopXG5cbmV4dGVybmFsIF9fTE9DX18gOiBzdHJpbmcgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fRklMRV9fIDogc3RyaW5nID0gXCIlbG9jX0ZJTEVcIlxuZXh0ZXJuYWwgX19MSU5FX18gOiBpbnQgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX01PRFVMRV9fIDogc3RyaW5nID0gXCIlbG9jX01PRFVMRVwiXG5leHRlcm5hbCBfX1BPU19fIDogc3RyaW5nICogaW50ICogaW50ICogaW50ID0gXCIlbG9jX1BPU1wiXG5leHRlcm5hbCBfX0ZVTkNUSU9OX18gOiBzdHJpbmcgPSBcIiVsb2NfRlVOQ1RJT05cIlxuXG5leHRlcm5hbCBfX0xPQ19PRl9fIDogJ2EgLT4gc3RyaW5nICogJ2EgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fTElORV9PRl9fIDogJ2EgLT4gaW50ICogJ2EgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX1BPU19PRl9fIDogJ2EgLT4gKHN0cmluZyAqIGludCAqIGludCAqIGludCkgKiAnYSA9IFwiJWxvY19QT1NcIlxuXG4oKiBDb21wYXJpc29ucyAqKVxuXG5leHRlcm5hbCAoID0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5leHRlcm5hbCAoIDw+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuZXh0ZXJuYWwgKCA8ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuZXh0ZXJuYWwgKCA+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuZXh0ZXJuYWwgKCA8PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG5leHRlcm5hbCAoID49ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcmVxdWFsXCJcbmV4dGVybmFsIGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcblxubGV0IG1pbiB4IHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG5leHRlcm5hbCAoID09ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXFcIlxuZXh0ZXJuYWwgKCAhPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxXCJcblxuKCogQm9vbGVhbiBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuZXh0ZXJuYWwgKCAmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggb3IgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbmV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcblxuKCogSW50ZWdlciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsICggfi0gKSA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuZXh0ZXJuYWwgKCB+KyApIDogaW50IC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHN1Y2MgOiBpbnQgLT4gaW50ID0gXCIlc3VjY2ludFwiXG5leHRlcm5hbCBwcmVkIDogaW50IC0+IGludCA9IFwiJXByZWRpbnRcIlxuZXh0ZXJuYWwgKCArICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG5leHRlcm5hbCAoIC0gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbmV4dGVybmFsICggKiApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtdWxpbnRcIlxuZXh0ZXJuYWwgKCAvICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWRpdmludFwiXG5leHRlcm5hbCAoIG1vZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtb2RpbnRcIlxuXG5sZXQgYWJzIHggPSBpZiB4ID49IDAgdGhlbiB4IGVsc2UgLXhcblxuZXh0ZXJuYWwgKCBsYW5kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFuZGludFwiXG5leHRlcm5hbCAoIGxvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVvcmludFwiXG5leHRlcm5hbCAoIGx4b3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIleG9yaW50XCJcblxubGV0IGxub3QgeCA9IHggbHhvciAoLTEpXG5cbmV4dGVybmFsICggbHNsICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG5leHRlcm5hbCAoIGxzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxuZXh0ZXJuYWwgKCBhc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYXNyaW50XCJcblxubGV0IG1heF9pbnQgPSAoLTEpIGxzciAxXG5sZXQgbWluX2ludCA9IG1heF9pbnQgKyAxXG5cbigqIEZsb2F0aW5nLXBvaW50IG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgKCB+LS4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlbmVnZmxvYXRcIlxuZXh0ZXJuYWwgKCB+Ky4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgKCArLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVhZGRmbG9hdFwiXG5leHRlcm5hbCAoIC0uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJXN1YmZsb2F0XCJcbmV4dGVybmFsICggKi4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlbXVsZmxvYXRcIlxuZXh0ZXJuYWwgKCAvLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVkaXZmbG9hdFwiXG5leHRlcm5hbCAoICoqICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9wb3dlcl9mbG9hdFwiIFwicG93XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cF9mbG9hdFwiIFwiZXhwXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cG0xIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwbTFfZmxvYXRcIiBcImNhbWxfZXhwbTFcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zaF9mbG9hdFwiIFwiY2FtbF9hY29zaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbmhfZmxvYXRcIiBcImNhbWxfYXNpbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc3FydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NxcnRfZmxvYXRcIiBcInNxcnRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuX2Zsb2F0XCIgXCJ0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RhbmhfZmxvYXRcIiBcInRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuaF9mbG9hdFwiIFwiY2FtbF9hdGFuaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjZWlsIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY2VpbF9mbG9hdFwiIFwiY2VpbFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9vciA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb29yX2Zsb2F0XCIgXCJmbG9vclwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhYnNfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFic2Zsb2F0XCJcbmV4dGVybmFsIGNvcHlzaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbW9kX2Zsb2F0XCIgXCJmbW9kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuZXh0ZXJuYWwgbGRleHAgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gKGludCBbQHVudGFnZ2VkXSkgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kZiA6IGZsb2F0IC0+IGZsb2F0ICogZmxvYXQgPSBcImNhbWxfbW9kZl9mbG9hdFwiXG5leHRlcm5hbCBmbG9hdCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgZmxvYXRfb2ZfaW50IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCB0cnVuY2F0ZSA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgaW50X29mX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxubGV0IGluZmluaXR5ID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0YwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IG5lZ19pbmZpbml0eSA9XG4gIGZsb2F0X29mX2JpdHMgMHhGRl9GMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBuYW4gPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRjBfMDBfMDBfMDBfMDBfMDBfMDFMXG5sZXQgbWF4X2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0VGX0ZGX0ZGX0ZGX0ZGX0ZGX0ZGTFxubGV0IG1pbl9mbG9hdCA9XG4gIGZsb2F0X29mX2JpdHMgMHgwMF8xMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBlcHNpbG9uX2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDNDX0IwXzAwXzAwXzAwXzAwXzAwXzAwTFxuXG50eXBlIGZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cblxuKCogU3RyaW5nIGFuZCBieXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGVzIFN0cmluZyBhbmQgQnl0ZXMgKilcblxuZXh0ZXJuYWwgc3RyaW5nX2xlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGJ5dGVzX2xlbmd0aCA6IGJ5dGVzIC0+IGludCA9IFwiJWJ5dGVzX2xlbmd0aFwiXG5leHRlcm5hbCBieXRlc19jcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIHN0cmluZ19ibGl0IDogc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGJ5dGVzX2JsaXQgOiBieXRlcyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuXG5sZXQgKCBeICkgczEgczIgPVxuICBsZXQgbDEgPSBzdHJpbmdfbGVuZ3RoIHMxIGFuZCBsMiA9IHN0cmluZ19sZW5ndGggczIgaW5cbiAgbGV0IHMgPSBieXRlc19jcmVhdGUgKGwxICsgbDIpIGluXG4gIHN0cmluZ19ibGl0IHMxIDAgcyAwIGwxO1xuICBzdHJpbmdfYmxpdCBzMiAwIHMgbDEgbDI7XG4gIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgc1xuXG4oKiBDaGFyYWN0ZXIgb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZSBDaGFyICopXG5cbmV4dGVybmFsIGludF9vZl9jaGFyIDogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCB1bnNhZmVfY2hhcl9vZl9pbnQgOiBpbnQgLT4gY2hhciA9IFwiJWlkZW50aXR5XCJcbmxldCBjaGFyX29mX2ludCBuID1cbiAgaWYgbiA8IDAgfHwgbiA+IDI1NSB0aGVuIGludmFsaWRfYXJnIFwiY2hhcl9vZl9pbnRcIiBlbHNlIHVuc2FmZV9jaGFyX29mX2ludCBuXG5cbigqIFVuaXQgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBpZ25vcmUgOiAnYSAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxuKCogUGFpciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGZzdCA6ICdhICogJ2IgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgc25kIDogJ2EgKiAnYiAtPiAnYiA9IFwiJWZpZWxkMVwiXG5cbigqIFJlZmVyZW5jZXMgKilcblxudHlwZSAnYSByZWYgPSB7IG11dGFibGUgY29udGVudHMgOiAnYSB9XG5leHRlcm5hbCByZWYgOiAnYSAtPiAnYSByZWYgPSBcIiVtYWtlbXV0YWJsZVwiXG5leHRlcm5hbCAoICEgKSA6ICdhIHJlZiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCAoIDo9ICkgOiAnYSByZWYgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5leHRlcm5hbCBpbmNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlaW5jclwiXG5leHRlcm5hbCBkZWNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlZGVjclwiXG5cbigqIFJlc3VsdCB0eXBlICopXG5cbnR5cGUgKCdhLCdiKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdiXG5cbigqIFN0cmluZyBjb252ZXJzaW9uIGZ1bmN0aW9ucyAqKVxuXG5leHRlcm5hbCBmb3JtYXRfaW50IDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQgOiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5cbmxldCBzdHJpbmdfb2ZfYm9vbCBiID1cbiAgaWYgYiB0aGVuIFwidHJ1ZVwiIGVsc2UgXCJmYWxzZVwiXG5sZXQgYm9vbF9vZl9zdHJpbmcgPSBmdW5jdGlvblxuICB8IFwidHJ1ZVwiIC0+IHRydWVcbiAgfCBcImZhbHNlXCIgLT4gZmFsc2VcbiAgfCBfIC0+IGludmFsaWRfYXJnIFwiYm9vbF9vZl9zdHJpbmdcIlxuXG5sZXQgYm9vbF9vZl9zdHJpbmdfb3B0ID0gZnVuY3Rpb25cbiAgfCBcInRydWVcIiAtPiBTb21lIHRydWVcbiAgfCBcImZhbHNlXCIgLT4gU29tZSBmYWxzZVxuICB8IF8gLT4gTm9uZVxuXG5sZXQgc3RyaW5nX29mX2ludCBuID1cbiAgZm9ybWF0X2ludCBcIiVkXCIgblxuXG5leHRlcm5hbCBpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludCA9IFwiY2FtbF9pbnRfb2Zfc3RyaW5nXCJcblxubGV0IGludF9vZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBwcm92aWRlIHRoaXMgZGlyZWN0bHkgYXMgYSBub24tcmFpc2luZyBwcmltaXRpdmUuICopXG4gIHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxuZXh0ZXJuYWwgc3RyaW5nX2dldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG5cbmxldCB2YWxpZF9mbG9hdF9sZXhlbSBzID1cbiAgbGV0IGwgPSBzdHJpbmdfbGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPj0gbCB0aGVuIHMgXiBcIi5cIiBlbHNlXG4gICAgbWF0Y2ggc3RyaW5nX2dldCBzIGkgd2l0aFxuICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiBsb29wIChpICsgMSlcbiAgICB8IF8gLT4gc1xuICBpblxuICBsb29wIDBcblxubGV0IHN0cmluZ19vZl9mbG9hdCBmID0gdmFsaWRfZmxvYXRfbGV4ZW0gKGZvcm1hdF9mbG9hdCBcIiUuMTJnXCIgZilcblxuZXh0ZXJuYWwgZmxvYXRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5cbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBwcm92aWRlIHRoaXMgZGlyZWN0bHkgYXMgYSBub24tcmFpc2luZyBwcmltaXRpdmUuICopXG4gIHRyeSBTb21lIChmbG9hdF9vZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG4oKiBMaXN0IG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGUgTGlzdCAqKVxuXG5sZXQgcmVjICggQCApIGwxIGwyID1cbiAgbWF0Y2ggbDEgd2l0aFxuICAgIFtdIC0+IGwyXG4gIHwgaGQgOjogdGwgLT4gaGQgOjogKHRsIEAgbDIpXG5cbigqIEkvTyBvcGVyYXRpb25zICopXG5cbnR5cGUgaW5fY2hhbm5lbFxudHlwZSBvdXRfY2hhbm5lbFxuXG5leHRlcm5hbCBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDogaW50IC0+IG91dF9jaGFubmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcIlxuZXh0ZXJuYWwgb3Blbl9kZXNjcmlwdG9yX2luIDogaW50IC0+IGluX2NoYW5uZWwgPSBcImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luXCJcblxubGV0IHN0ZGluID0gb3Blbl9kZXNjcmlwdG9yX2luIDBcbmxldCBzdGRvdXQgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDFcbmxldCBzdGRlcnIgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDJcblxuKCogR2VuZXJhbCBvdXRwdXQgZnVuY3Rpb25zICopXG5cbnR5cGUgb3Blbl9mbGFnID1cbiAgICBPcGVuX3Jkb25seSB8IE9wZW5fd3Jvbmx5IHwgT3Blbl9hcHBlbmRcbiAgfCBPcGVuX2NyZWF0IHwgT3Blbl90cnVuYyB8IE9wZW5fZXhjbFxuICB8IE9wZW5fYmluYXJ5IHwgT3Blbl90ZXh0IHwgT3Blbl9ub25ibG9ja1xuXG5leHRlcm5hbCBvcGVuX2Rlc2MgOiBzdHJpbmcgLT4gb3Blbl9mbGFnIGxpc3QgLT4gaW50IC0+IGludCA9IFwiY2FtbF9zeXNfb3BlblwiXG5cbmV4dGVybmFsIHNldF9vdXRfY2hhbm5lbF9uYW1lOiBvdXRfY2hhbm5lbCAtPiBzdHJpbmcgLT4gdW5pdCA9XG4gIFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXCJcblxubGV0IG9wZW5fb3V0X2dlbiBtb2RlIHBlcm0gbmFtZSA9XG4gIGxldCBjID0gb3Blbl9kZXNjcmlwdG9yX291dChvcGVuX2Rlc2MgbmFtZSBtb2RlIHBlcm0pIGluXG4gIHNldF9vdXRfY2hhbm5lbF9uYW1lIGMgbmFtZTtcbiAgY1xuXG5sZXQgb3Blbl9vdXQgbmFtZSA9XG4gIG9wZW5fb3V0X2dlbiBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fdHJ1bmM7IE9wZW5fdGV4dF0gMG82NjYgbmFtZVxuXG5sZXQgb3Blbl9vdXRfYmluIG5hbWUgPVxuICBvcGVuX291dF9nZW4gW09wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0OyBPcGVuX3RydW5jOyBPcGVuX2JpbmFyeV0gMG82NjYgbmFtZVxuXG5leHRlcm5hbCBmbHVzaCA6IG91dF9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfZmx1c2hcIlxuXG5leHRlcm5hbCBvdXRfY2hhbm5lbHNfbGlzdCA6IHVuaXQgLT4gb3V0X2NoYW5uZWwgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3RcIlxuXG5sZXQgZmx1c2hfYWxsICgpID1cbiAgbGV0IHJlYyBpdGVyID0gZnVuY3Rpb25cbiAgICAgIFtdIC0+ICgpXG4gICAgfCBhOjpsIC0+XG4gICAgICAgIGJlZ2luIHRyeVxuICAgICAgICAgICAgZmx1c2ggYVxuICAgICAgICB3aXRoIFN5c19lcnJvciBfIC0+XG4gICAgICAgICAgKCkgKCogaWdub3JlIGNoYW5uZWxzIGNsb3NlZCBkdXJpbmcgYSBwcmVjZWRpbmcgZmx1c2guICopXG4gICAgICAgIGVuZDtcbiAgICAgICAgaXRlciBsXG4gIGluIGl0ZXIgKG91dF9jaGFubmVsc19saXN0ICgpKVxuXG5leHRlcm5hbCB1bnNhZmVfb3V0cHV0IDogb3V0X2NoYW5uZWwgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dHB1dF9ieXRlc1wiXG5leHRlcm5hbCB1bnNhZmVfb3V0cHV0X3N0cmluZyA6IG91dF9jaGFubmVsIC0+IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dHB1dFwiXG5cbmV4dGVybmFsIG91dHB1dF9jaGFyIDogb3V0X2NoYW5uZWwgLT4gY2hhciAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9jaGFyXCJcblxubGV0IG91dHB1dF9ieXRlcyBvYyBzID1cbiAgdW5zYWZlX291dHB1dCBvYyBzIDAgKGJ5dGVzX2xlbmd0aCBzKVxuXG5sZXQgb3V0cHV0X3N0cmluZyBvYyBzID1cbiAgdW5zYWZlX291dHB1dF9zdHJpbmcgb2MgcyAwIChzdHJpbmdfbGVuZ3RoIHMpXG5cbmxldCBvdXRwdXQgb2MgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJvdXRwdXRcIlxuICBlbHNlIHVuc2FmZV9vdXRwdXQgb2MgcyBvZnMgbGVuXG5cbmxldCBvdXRwdXRfc3Vic3RyaW5nIG9jIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBzdHJpbmdfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIm91dHB1dF9zdWJzdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9vdXRwdXRfc3RyaW5nIG9jIHMgb2ZzIGxlblxuXG5leHRlcm5hbCBvdXRwdXRfYnl0ZSA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9jaGFyXCJcbmV4dGVybmFsIG91dHB1dF9iaW5hcnlfaW50IDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2ludFwiXG5cbmV4dGVybmFsIG1hcnNoYWxfdG9fY2hhbm5lbCA6IG91dF9jaGFubmVsIC0+ICdhIC0+IHVuaXQgbGlzdCAtPiB1bml0XG4gICAgID0gXCJjYW1sX291dHB1dF92YWx1ZVwiXG5sZXQgb3V0cHV0X3ZhbHVlIGNoYW4gdiA9IG1hcnNoYWxfdG9fY2hhbm5lbCBjaGFuIHYgW11cblxuZXh0ZXJuYWwgc2Vla19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX291dFwiXG5leHRlcm5hbCBwb3Nfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX3Bvc19vdXRcIlxuZXh0ZXJuYWwgb3V0X2NoYW5uZWxfbGVuZ3RoIDogb3V0X2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZVwiXG5leHRlcm5hbCBjbG9zZV9vdXRfY2hhbm5lbCA6IG91dF9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfY2xvc2VfY2hhbm5lbFwiXG5sZXQgY2xvc2Vfb3V0IG9jID0gZmx1c2ggb2M7IGNsb3NlX291dF9jaGFubmVsIG9jXG5sZXQgY2xvc2Vfb3V0X25vZXJyIG9jID1cbiAgKHRyeSBmbHVzaCBvYyB3aXRoIF8gLT4gKCkpO1xuICAodHJ5IGNsb3NlX291dF9jaGFubmVsIG9jIHdpdGggXyAtPiAoKSlcbmV4dGVybmFsIHNldF9iaW5hcnlfbW9kZV9vdXQgOiBvdXRfY2hhbm5lbCAtPiBib29sIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXCJcblxuKCogR2VuZXJhbCBpbnB1dCBmdW5jdGlvbnMgKilcblxuZXh0ZXJuYWwgc2V0X2luX2NoYW5uZWxfbmFtZTogaW5fY2hhbm5lbCAtPiBzdHJpbmcgLT4gdW5pdCA9XG4gIFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXCJcblxubGV0IG9wZW5faW5fZ2VuIG1vZGUgcGVybSBuYW1lID1cbiAgbGV0IGMgPSBvcGVuX2Rlc2NyaXB0b3JfaW4ob3Blbl9kZXNjIG5hbWUgbW9kZSBwZXJtKSBpblxuICBzZXRfaW5fY2hhbm5lbF9uYW1lIGMgbmFtZTtcbiAgY1xuXG5sZXQgb3Blbl9pbiBuYW1lID1cbiAgb3Blbl9pbl9nZW4gW09wZW5fcmRvbmx5OyBPcGVuX3RleHRdIDAgbmFtZVxuXG5sZXQgb3Blbl9pbl9iaW4gbmFtZSA9XG4gIG9wZW5faW5fZ2VuIFtPcGVuX3Jkb25seTsgT3Blbl9iaW5hcnldIDAgbmFtZVxuXG5leHRlcm5hbCBpbnB1dF9jaGFyIDogaW5fY2hhbm5lbCAtPiBjaGFyID0gXCJjYW1sX21sX2lucHV0X2NoYXJcIlxuXG5leHRlcm5hbCB1bnNhZmVfaW5wdXQgOiBpbl9jaGFubmVsIC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gaW50XG4gICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfaW5wdXRcIlxuXG5sZXQgaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJpbnB1dFwiXG4gIGVsc2UgdW5zYWZlX2lucHV0IGljIHMgb2ZzIGxlblxuXG5sZXQgcmVjIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgbGVuIDw9IDAgdGhlbiAoKSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSB1bnNhZmVfaW5wdXQgaWMgcyBvZnMgbGVuIGluXG4gICAgaWYgciA9IDBcbiAgICB0aGVuIHJhaXNlIEVuZF9vZl9maWxlXG4gICAgZWxzZSB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgKG9mcyArIHIpIChsZW4gLSByKVxuICBlbmRcblxubGV0IHJlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcInJlYWxseV9pbnB1dFwiXG4gIGVsc2UgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW5cblxubGV0IHJlYWxseV9pbnB1dF9zdHJpbmcgaWMgbGVuID1cbiAgbGV0IHMgPSBieXRlc19jcmVhdGUgbGVuIGluXG4gIHJlYWxseV9pbnB1dCBpYyBzIDAgbGVuO1xuICBieXRlc191bnNhZmVfdG9fc3RyaW5nIHNcblxuZXh0ZXJuYWwgaW5wdXRfc2Nhbl9saW5lIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lXCJcblxubGV0IGlucHV0X2xpbmUgY2hhbiA9XG4gIGxldCByZWMgYnVpbGRfcmVzdWx0IGJ1ZiBwb3MgPSBmdW5jdGlvblxuICAgIFtdIC0+IGJ1ZlxuICB8IGhkIDo6IHRsIC0+XG4gICAgICBsZXQgbGVuID0gYnl0ZXNfbGVuZ3RoIGhkIGluXG4gICAgICBieXRlc19ibGl0IGhkIDAgYnVmIChwb3MgLSBsZW4pIGxlbjtcbiAgICAgIGJ1aWxkX3Jlc3VsdCBidWYgKHBvcyAtIGxlbikgdGwgaW5cbiAgbGV0IHJlYyBzY2FuIGFjY3UgbGVuID1cbiAgICBsZXQgbiA9IGlucHV0X3NjYW5fbGluZSBjaGFuIGluXG4gICAgaWYgbiA9IDAgdGhlbiBiZWdpbiAgICAgICAgICAgICAgICAgICAoKiBuID0gMDogd2UgYXJlIGF0IEVPRiAqKVxuICAgICAgbWF0Y2ggYWNjdSB3aXRoXG4gICAgICAgIFtdIC0+IHJhaXNlIEVuZF9vZl9maWxlXG4gICAgICB8IF8gIC0+IGJ1aWxkX3Jlc3VsdCAoYnl0ZXNfY3JlYXRlIGxlbikgbGVuIGFjY3VcbiAgICBlbmQgZWxzZSBpZiBuID4gMCB0aGVuIGJlZ2luICAgICAgICAgICgqIG4gPiAwOiBuZXdsaW5lIGZvdW5kIGluIGJ1ZmZlciAqKVxuICAgICAgbGV0IHJlcyA9IGJ5dGVzX2NyZWF0ZSAobiAtIDEpIGluXG4gICAgICBpZ25vcmUgKHVuc2FmZV9pbnB1dCBjaGFuIHJlcyAwIChuIC0gMSkpO1xuICAgICAgaWdub3JlIChpbnB1dF9jaGFyIGNoYW4pOyAgICAgICAgICAgKCogc2tpcCB0aGUgbmV3bGluZSAqKVxuICAgICAgbWF0Y2ggYWNjdSB3aXRoXG4gICAgICAgIFtdIC0+IHJlc1xuICAgICAgfCAgXyAtPiBsZXQgbGVuID0gbGVuICsgbiAtIDEgaW5cbiAgICAgICAgICAgICAgYnVpbGRfcmVzdWx0IChieXRlc19jcmVhdGUgbGVuKSBsZW4gKHJlcyA6OiBhY2N1KVxuICAgIGVuZCBlbHNlIGJlZ2luICAgICAgICAgICAgICAgICAgICAgICAgKCogbiA8IDA6IG5ld2xpbmUgbm90IGZvdW5kICopXG4gICAgICBsZXQgYmVnID0gYnl0ZXNfY3JlYXRlICgtbikgaW5cbiAgICAgIGlnbm9yZSh1bnNhZmVfaW5wdXQgY2hhbiBiZWcgMCAoLW4pKTtcbiAgICAgIHNjYW4gKGJlZyA6OiBhY2N1KSAobGVuIC0gbilcbiAgICBlbmRcbiAgaW4gYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyAoc2NhbiBbXSAwKVxuXG5leHRlcm5hbCBpbnB1dF9ieXRlIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfY2hhclwiXG5leHRlcm5hbCBpbnB1dF9iaW5hcnlfaW50IDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfaW50XCJcbmV4dGVybmFsIGlucHV0X3ZhbHVlIDogaW5fY2hhbm5lbCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZVwiXG5leHRlcm5hbCBzZWVrX2luIDogaW5fY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX2luXCJcbmV4dGVybmFsIHBvc19pbiA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX3Bvc19pblwiXG5leHRlcm5hbCBpbl9jaGFubmVsX2xlbmd0aCA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZVwiXG5leHRlcm5hbCBjbG9zZV9pbiA6IGluX2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9jbG9zZV9jaGFubmVsXCJcbmxldCBjbG9zZV9pbl9ub2VyciBpYyA9ICh0cnkgY2xvc2VfaW4gaWMgd2l0aCBfIC0+ICgpKVxuZXh0ZXJuYWwgc2V0X2JpbmFyeV9tb2RlX2luIDogaW5fY2hhbm5lbCAtPiBib29sIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcIlxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIG91dHB1dCAqKVxuXG5sZXQgcHJpbnRfY2hhciBjID0gb3V0cHV0X2NoYXIgc3Rkb3V0IGNcbmxldCBwcmludF9zdHJpbmcgcyA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IHNcbmxldCBwcmludF9ieXRlcyBzID0gb3V0cHV0X2J5dGVzIHN0ZG91dCBzXG5sZXQgcHJpbnRfaW50IGkgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCAoc3RyaW5nX29mX2ludCBpKVxubGV0IHByaW50X2Zsb2F0IGYgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCAoc3RyaW5nX29mX2Zsb2F0IGYpXG5sZXQgcHJpbnRfZW5kbGluZSBzID1cbiAgb3V0cHV0X3N0cmluZyBzdGRvdXQgczsgb3V0cHV0X2NoYXIgc3Rkb3V0ICdcXG4nOyBmbHVzaCBzdGRvdXRcbmxldCBwcmludF9uZXdsaW5lICgpID0gb3V0cHV0X2NoYXIgc3Rkb3V0ICdcXG4nOyBmbHVzaCBzdGRvdXRcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBvbiBzdGFuZGFyZCBlcnJvciAqKVxuXG5sZXQgcHJlcnJfY2hhciBjID0gb3V0cHV0X2NoYXIgc3RkZXJyIGNcbmxldCBwcmVycl9zdHJpbmcgcyA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIHNcbmxldCBwcmVycl9ieXRlcyBzID0gb3V0cHV0X2J5dGVzIHN0ZGVyciBzXG5sZXQgcHJlcnJfaW50IGkgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciAoc3RyaW5nX29mX2ludCBpKVxubGV0IHByZXJyX2Zsb2F0IGYgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciAoc3RyaW5nX29mX2Zsb2F0IGYpXG5sZXQgcHJlcnJfZW5kbGluZSBzID1cbiAgb3V0cHV0X3N0cmluZyBzdGRlcnIgczsgb3V0cHV0X2NoYXIgc3RkZXJyICdcXG4nOyBmbHVzaCBzdGRlcnJcbmxldCBwcmVycl9uZXdsaW5lICgpID0gb3V0cHV0X2NoYXIgc3RkZXJyICdcXG4nOyBmbHVzaCBzdGRlcnJcblxuKCogSW5wdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIGlucHV0ICopXG5cbmxldCByZWFkX2xpbmUgKCkgPSBmbHVzaCBzdGRvdXQ7IGlucHV0X2xpbmUgc3RkaW5cbmxldCByZWFkX2ludCAoKSA9IGludF9vZl9zdHJpbmcocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9pbnRfb3B0ICgpID0gaW50X29mX3N0cmluZ19vcHQocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9mbG9hdCAoKSA9IGZsb2F0X29mX3N0cmluZyhyZWFkX2xpbmUoKSlcbmxldCByZWFkX2Zsb2F0X29wdCAoKSA9IGZsb2F0X29mX3N0cmluZ19vcHQocmVhZF9saW5lKCkpXG5cbigqIE9wZXJhdGlvbnMgb24gbGFyZ2UgZmlsZXMgKilcblxubW9kdWxlIExhcmdlRmlsZSA9XG4gIHN0cnVjdFxuICAgIGV4dGVybmFsIHNlZWtfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50NjQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX291dF82NFwiXG4gICAgZXh0ZXJuYWwgcG9zX291dCA6IG91dF9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX3Bvc19vdXRfNjRcIlxuICAgIGV4dGVybmFsIG91dF9jaGFubmVsX2xlbmd0aCA6IG91dF9jaGFubmVsIC0+IGludDY0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFwiXG4gICAgZXh0ZXJuYWwgc2Vla19pbiA6IGluX2NoYW5uZWwgLT4gaW50NjQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX2luXzY0XCJcbiAgICBleHRlcm5hbCBwb3NfaW4gOiBpbl9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX3Bvc19pbl82NFwiXG4gICAgZXh0ZXJuYWwgaW5fY2hhbm5lbF9sZW5ndGggOiBpbl9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFwiXG4gIGVuZFxuXG4oKiBGb3JtYXRzICopXG5cbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDZcbiAgID0gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2XG4gICA9IEZvcm1hdCBvZiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZtdFxuICAgICAgICAgICAgICAgKiBzdHJpbmdcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgPSAoJ2EsICdiLCAnYywgJ2MsICdjLCAnZCkgZm9ybWF0NlxuXG50eXBlICgnYSwgJ2IsICdjKSBmb3JtYXQgPSAoJ2EsICdiLCAnYywgJ2MpIGZvcm1hdDRcblxubGV0IHN0cmluZ19vZl9mb3JtYXQgKEZvcm1hdCAoX2ZtdCwgc3RyKSkgPSBzdHJcblxuZXh0ZXJuYWwgZm9ybWF0X29mX3N0cmluZyA6XG4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9IFwiJWlkZW50aXR5XCJcblxubGV0ICggXl4gKSAoRm9ybWF0IChmbXQxLCBzdHIxKSkgKEZvcm1hdCAoZm10Miwgc3RyMikpID1cbiAgRm9ybWF0IChDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuY29uY2F0X2ZtdCBmbXQxIGZtdDIsXG4gICAgICAgICAgc3RyMSBeIFwiJSxcIiBeIHN0cjIpXG5cbigqIE1pc2NlbGxhbmVvdXMgKilcblxuZXh0ZXJuYWwgc3lzX2V4aXQgOiBpbnQgLT4gJ2EgPSBcImNhbWxfc3lzX2V4aXRcIlxuXG5sZXQgZXhpdF9mdW5jdGlvbiA9IENhbWxpbnRlcm5hbEF0b21pYy5tYWtlIGZsdXNoX2FsbFxuXG5sZXQgcmVjIGF0X2V4aXQgZiA9XG4gIGxldCBtb2R1bGUgQXRvbWljID0gQ2FtbGludGVybmFsQXRvbWljIGluXG4gICgqIE1QUiM3MjUzLCBNUFIjNzc5NjogbWFrZSBzdXJlIFwiZlwiIGlzIGV4ZWN1dGVkIG9ubHkgb25jZSAqKVxuICBsZXQgZl95ZXRfdG9fcnVuID0gQXRvbWljLm1ha2UgdHJ1ZSBpblxuICBsZXQgb2xkX2V4aXQgPSBBdG9taWMuZ2V0IGV4aXRfZnVuY3Rpb24gaW5cbiAgbGV0IG5ld19leGl0ICgpID1cbiAgICBpZiBBdG9taWMuY29tcGFyZV9hbmRfc2V0IGZfeWV0X3RvX3J1biB0cnVlIGZhbHNlIHRoZW4gZiAoKSA7XG4gICAgb2xkX2V4aXQgKClcbiAgaW5cbiAgbGV0IHN1Y2Nlc3MgPSBBdG9taWMuY29tcGFyZV9hbmRfc2V0IGV4aXRfZnVuY3Rpb24gb2xkX2V4aXQgbmV3X2V4aXQgaW5cbiAgaWYgbm90IHN1Y2Nlc3MgdGhlbiBhdF9leGl0IGZcblxubGV0IGRvX2F0X2V4aXQgKCkgPSAoQ2FtbGludGVybmFsQXRvbWljLmdldCBleGl0X2Z1bmN0aW9uKSAoKVxuXG5sZXQgZXhpdCByZXRjb2RlID1cbiAgZG9fYXRfZXhpdCAoKTtcbiAgc3lzX2V4aXQgcmV0Y29kZVxuXG5sZXQgXyA9IHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5kb19hdF9leGl0XCIgZG9fYXRfZXhpdFxuXG5leHRlcm5hbCBtYWpvciA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19tYWpvclwiXG5leHRlcm5hbCBuYWtlZF9wb2ludGVyc19jaGVja2VkIDogdW5pdCAtPiBib29sXG4gID0gXCJjYW1sX3N5c19jb25zdF9uYWtlZF9wb2ludGVyc19jaGVja2VkXCJcbmxldCAoKSA9IGlmIG5ha2VkX3BvaW50ZXJzX2NoZWNrZWQgKCkgdGhlbiBhdF9leGl0IG1ham9yXG5cbigqTU9EVUxFX0FMSUFTRVMqKVxubW9kdWxlIEFyZyAgICAgICAgICA9IEFyZ1xubW9kdWxlIEFycmF5ICAgICAgICA9IEFycmF5XG5tb2R1bGUgQXJyYXlMYWJlbHMgID0gQXJyYXlMYWJlbHNcbm1vZHVsZSBBdG9taWMgICAgICAgPSBBdG9taWNcbm1vZHVsZSBCaWdhcnJheSAgICAgPSBCaWdhcnJheVxubW9kdWxlIEJvb2wgICAgICAgICA9IEJvb2xcbm1vZHVsZSBCdWZmZXIgICAgICAgPSBCdWZmZXJcbm1vZHVsZSBCeXRlcyAgICAgICAgPSBCeXRlc1xubW9kdWxlIEJ5dGVzTGFiZWxzICA9IEJ5dGVzTGFiZWxzXG5tb2R1bGUgQ2FsbGJhY2sgICAgID0gQ2FsbGJhY2tcbm1vZHVsZSBDaGFyICAgICAgICAgPSBDaGFyXG5tb2R1bGUgQ29tcGxleCAgICAgID0gQ29tcGxleFxubW9kdWxlIERpZ2VzdCAgICAgICA9IERpZ2VzdFxubW9kdWxlIEVpdGhlciAgICAgICA9IEVpdGhlclxubW9kdWxlIEVwaGVtZXJvbiAgICA9IEVwaGVtZXJvblxubW9kdWxlIEZpbGVuYW1lICAgICA9IEZpbGVuYW1lXG5tb2R1bGUgRmxvYXQgICAgICAgID0gRmxvYXRcbm1vZHVsZSBGb3JtYXQgICAgICAgPSBGb3JtYXRcbm1vZHVsZSBGdW4gICAgICAgICAgPSBGdW5cbm1vZHVsZSBHYyAgICAgICAgICAgPSBHY1xubW9kdWxlIEdlbmxleCAgICAgICA9IEdlbmxleFxubW9kdWxlIEhhc2h0YmwgICAgICA9IEhhc2h0Ymxcbm1vZHVsZSBJbl9jaGFubmVsICAgPSBJbl9jaGFubmVsXG5tb2R1bGUgSW50ICAgICAgICAgID0gSW50XG5tb2R1bGUgSW50MzIgICAgICAgID0gSW50MzJcbm1vZHVsZSBJbnQ2NCAgICAgICAgPSBJbnQ2NFxubW9kdWxlIExhenkgICAgICAgICA9IExhenlcbm1vZHVsZSBMZXhpbmcgICAgICAgPSBMZXhpbmdcbm1vZHVsZSBMaXN0ICAgICAgICAgPSBMaXN0XG5tb2R1bGUgTGlzdExhYmVscyAgID0gTGlzdExhYmVsc1xubW9kdWxlIE1hcCAgICAgICAgICA9IE1hcFxubW9kdWxlIE1hcnNoYWwgICAgICA9IE1hcnNoYWxcbm1vZHVsZSBNb3JlTGFiZWxzICAgPSBNb3JlTGFiZWxzXG5tb2R1bGUgTmF0aXZlaW50ICAgID0gTmF0aXZlaW50XG5tb2R1bGUgT2JqICAgICAgICAgID0gT2JqXG5tb2R1bGUgT28gICAgICAgICAgID0gT29cbm1vZHVsZSBPcHRpb24gICAgICAgPSBPcHRpb25cbm1vZHVsZSBPdXRfY2hhbm5lbCAgPSBPdXRfY2hhbm5lbFxubW9kdWxlIFBhcnNpbmcgICAgICA9IFBhcnNpbmdcbm1vZHVsZSBQZXJ2YXNpdmVzICAgPSBQZXJ2YXNpdmVzXG5tb2R1bGUgUHJpbnRleGMgICAgID0gUHJpbnRleGNcbm1vZHVsZSBQcmludGYgICAgICAgPSBQcmludGZcbm1vZHVsZSBRdWV1ZSAgICAgICAgPSBRdWV1ZVxubW9kdWxlIFJhbmRvbSAgICAgICA9IFJhbmRvbVxubW9kdWxlIFJlc3VsdCAgICAgICA9IFJlc3VsdFxubW9kdWxlIFNjYW5mICAgICAgICA9IFNjYW5mXG5tb2R1bGUgU2VxICAgICAgICAgID0gU2VxXG5tb2R1bGUgU2V0ICAgICAgICAgID0gU2V0XG5tb2R1bGUgU3RhY2sgICAgICAgID0gU3RhY2tcbm1vZHVsZSBTdGRMYWJlbHMgICAgPSBTdGRMYWJlbHNcbm1vZHVsZSBTdHJlYW0gICAgICAgPSBTdHJlYW1cbm1vZHVsZSBTdHJpbmcgICAgICAgPSBTdHJpbmdcbm1vZHVsZSBTdHJpbmdMYWJlbHMgPSBTdHJpbmdMYWJlbHNcbm1vZHVsZSBTeXMgICAgICAgICAgPSBTeXNcbm1vZHVsZSBVY2hhciAgICAgICAgPSBVY2hhclxubW9kdWxlIFVuaXQgICAgICAgICA9IFVuaXRcbm1vZHVsZSBXZWFrICAgICAgICAgPSBXZWFrXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICBKZXJlbWllIERpbWlubywgSmFuZSBTdHJlZXQgRXVyb3BlICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE3IEphbmUgU3RyZWV0IEdyb3VwIExMQyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqKiBAZGVwcmVjYXRlZCBVc2UgeyFTdGRsaWJ9ICopXG5cbmV4dGVybmFsIHJhaXNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2VcIlxuZXh0ZXJuYWwgcmFpc2Vfbm90cmFjZSA6IGV4biAtPiAnYSA9IFwiJXJhaXNlX25vdHJhY2VcIlxubGV0IGludmFsaWRfYXJnID0gaW52YWxpZF9hcmdcbmxldCBmYWlsd2l0aCA9IGZhaWx3aXRoXG5leGNlcHRpb24gRXhpdFxuZXh0ZXJuYWwgKCA9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXF1YWxcIlxuZXh0ZXJuYWwgKCA8PiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxdWFsXCJcbmV4dGVybmFsICggPCApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbmV4dGVybmFsICggPiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJ0aGFuXCJcbmV4dGVybmFsICggPD0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzZXF1YWxcIlxuZXh0ZXJuYWwgKCA+PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG5leHRlcm5hbCBjb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5sZXQgbWluID0gbWluXG5sZXQgbWF4ID0gbWF4XG5leHRlcm5hbCAoID09ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXFcIlxuZXh0ZXJuYWwgKCAhPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxXCJcbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbiAgW0BAb2NhbWwuZGVwcmVjYXRlZCBcIlVzZSAoJiYpIGluc3RlYWQuXCJdXG5leHRlcm5hbCAoIHx8ICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG5leHRlcm5hbCAoIG9yICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG4gIFtAQG9jYW1sLmRlcHJlY2F0ZWQgXCJVc2UgKHx8KSBpbnN0ZWFkLlwiXVxuZXh0ZXJuYWwgX19MT0NfXyA6IHN0cmluZyA9IFwiJWxvY19MT0NcIlxuZXh0ZXJuYWwgX19GSUxFX18gOiBzdHJpbmcgPSBcIiVsb2NfRklMRVwiXG5leHRlcm5hbCBfX0xJTkVfXyA6IGludCA9IFwiJWxvY19MSU5FXCJcbmV4dGVybmFsIF9fTU9EVUxFX18gOiBzdHJpbmcgPSBcIiVsb2NfTU9EVUxFXCJcbmV4dGVybmFsIF9fUE9TX18gOiBzdHJpbmcgKiBpbnQgKiBpbnQgKiBpbnQgPSBcIiVsb2NfUE9TXCJcbmV4dGVybmFsIF9fTE9DX09GX18gOiAnYSAtPiBzdHJpbmcgKiAnYSA9IFwiJWxvY19MT0NcIlxuZXh0ZXJuYWwgX19MSU5FX09GX18gOiAnYSAtPiBpbnQgKiAnYSA9IFwiJWxvY19MSU5FXCJcbmV4dGVybmFsIF9fUE9TX09GX18gOiAnYSAtPiAoc3RyaW5nICogaW50ICogaW50ICogaW50KSAqICdhID0gXCIlbG9jX1BPU1wiXG5leHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoJ2EgLT4gJ2IpIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuZXh0ZXJuYWwgKCBAQCApIDogKCdhIC0+ICdiKSAtPiAnYSAtPiAnYiA9IFwiJWFwcGx5XCJcbmV4dGVybmFsICggfi0gKSA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuZXh0ZXJuYWwgKCB+KyApIDogaW50IC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHN1Y2MgOiBpbnQgLT4gaW50ID0gXCIlc3VjY2ludFwiXG5leHRlcm5hbCBwcmVkIDogaW50IC0+IGludCA9IFwiJXByZWRpbnRcIlxuZXh0ZXJuYWwgKCArICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG5leHRlcm5hbCAoIC0gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbmV4dGVybmFsICggKiApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtdWxpbnRcIlxuZXh0ZXJuYWwgKCAvICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWRpdmludFwiXG5leHRlcm5hbCAoIG1vZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtb2RpbnRcIlxubGV0IGFicyA9IGFic1xubGV0IG1heF9pbnQgPSBtYXhfaW50XG5sZXQgbWluX2ludCA9IG1pbl9pbnRcbmV4dGVybmFsICggbGFuZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhbmRpbnRcIlxuZXh0ZXJuYWwgKCBsb3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlb3JpbnRcIlxuZXh0ZXJuYWwgKCBseG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXhvcmludFwiXG5sZXQgbG5vdCA9IGxub3RcbmV4dGVybmFsICggbHNsICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG5leHRlcm5hbCAoIGxzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxuZXh0ZXJuYWwgKCBhc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYXNyaW50XCJcbmV4dGVybmFsICggfi0uICkgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJW5lZ2Zsb2F0XCJcbmV4dGVybmFsICggfisuICkgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsICggKy4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWRkZmxvYXRcIlxuZXh0ZXJuYWwgKCAtLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVzdWJmbG9hdFwiXG5leHRlcm5hbCAoICouICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJW11bGZsb2F0XCJcbmV4dGVybmFsICggLy4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlZGl2ZmxvYXRcIlxuZXh0ZXJuYWwgKCAqKiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcG93ZXJfZmxvYXRcIiBcInBvd1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHBtMSA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cG0xX2Zsb2F0XCIgXCJjYW1sX2V4cG0xXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzFwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMXBfZmxvYXRcIiBcImNhbWxfbG9nMXBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luX2Zsb2F0XCIgXCJzaW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuX2Zsb2F0XCIgXCJ0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9oeXBvdF9mbG9hdFwiIFwiY2FtbF9oeXBvdFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zaF9mbG9hdFwiIFwiY29zaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luaF9mbG9hdFwiIFwic2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuaF9mbG9hdFwiIFwidGFuaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjZWlsIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY2VpbF9mbG9hdFwiIFwiY2VpbFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9vciA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb29yX2Zsb2F0XCIgXCJmbG9vclwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhYnNfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFic2Zsb2F0XCJcbmV4dGVybmFsIGNvcHlzaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbW9kX2Zsb2F0XCIgXCJmbW9kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuZXh0ZXJuYWwgbGRleHAgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gKGludCBbQHVudGFnZ2VkXSkgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kZiA6IGZsb2F0IC0+IGZsb2F0ICogZmxvYXQgPSBcImNhbWxfbW9kZl9mbG9hdFwiXG5leHRlcm5hbCBmbG9hdCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgZmxvYXRfb2ZfaW50IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCB0cnVuY2F0ZSA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgaW50X29mX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5sZXQgaW5maW5pdHkgPSBpbmZpbml0eVxubGV0IG5lZ19pbmZpbml0eSA9IG5lZ19pbmZpbml0eVxubGV0IG5hbiA9IG5hblxubGV0IG1heF9mbG9hdCA9IG1heF9mbG9hdFxubGV0IG1pbl9mbG9hdCA9IG1pbl9mbG9hdFxubGV0IGVwc2lsb25fZmxvYXQgPSBlcHNpbG9uX2Zsb2F0XG50eXBlIG5vbnJlYyBmcGNsYXNzID0gZnBjbGFzcyA9XG4gICAgRlBfbm9ybWFsXG4gIHwgRlBfc3Vibm9ybWFsXG4gIHwgRlBfemVyb1xuICB8IEZQX2luZmluaXRlXG4gIHwgRlBfbmFuXG5leHRlcm5hbCBjbGFzc2lmeV9mbG9hdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBmcGNsYXNzID1cbiAgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0XCIgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxubGV0ICggXiApID0gKCBeIClcbmV4dGVybmFsIGludF9vZl9jaGFyIDogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5sZXQgY2hhcl9vZl9pbnQgPSBjaGFyX29mX2ludFxuZXh0ZXJuYWwgaWdub3JlIDogJ2EgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5sZXQgc3RyaW5nX29mX2Jvb2wgPSBzdHJpbmdfb2ZfYm9vbFxubGV0IGJvb2xfb2Zfc3RyaW5nID0gYm9vbF9vZl9zdHJpbmdcbmxldCBib29sX29mX3N0cmluZ19vcHQgPSBib29sX29mX3N0cmluZ19vcHRcbmxldCBzdHJpbmdfb2ZfaW50ID0gc3RyaW5nX29mX2ludFxuZXh0ZXJuYWwgaW50X29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQgPSBcImNhbWxfaW50X29mX3N0cmluZ1wiXG5sZXQgaW50X29mX3N0cmluZ19vcHQgPSBpbnRfb2Zfc3RyaW5nX29wdFxubGV0IHN0cmluZ19vZl9mbG9hdCA9IHN0cmluZ19vZl9mbG9hdFxuZXh0ZXJuYWwgZmxvYXRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5sZXQgZmxvYXRfb2Zfc3RyaW5nX29wdCA9IGZsb2F0X29mX3N0cmluZ19vcHRcbmV4dGVybmFsIGZzdCA6ICdhICogJ2IgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgc25kIDogJ2EgKiAnYiAtPiAnYiA9IFwiJWZpZWxkMVwiXG5sZXQgKCBAICkgID0gKCBAIClcbnR5cGUgbm9ucmVjIGluX2NoYW5uZWwgPSBpbl9jaGFubmVsXG50eXBlIG5vbnJlYyBvdXRfY2hhbm5lbCA9IG91dF9jaGFubmVsXG5sZXQgc3RkaW4gPSBzdGRpblxubGV0IHN0ZG91dCA9IHN0ZG91dFxubGV0IHN0ZGVyciA9IHN0ZGVyclxubGV0IHByaW50X2NoYXIgPSBwcmludF9jaGFyXG5sZXQgcHJpbnRfc3RyaW5nID0gcHJpbnRfc3RyaW5nXG5sZXQgcHJpbnRfYnl0ZXMgPSBwcmludF9ieXRlc1xubGV0IHByaW50X2ludCA9IHByaW50X2ludFxubGV0IHByaW50X2Zsb2F0ID0gcHJpbnRfZmxvYXRcbmxldCBwcmludF9lbmRsaW5lID0gcHJpbnRfZW5kbGluZVxubGV0IHByaW50X25ld2xpbmUgPSBwcmludF9uZXdsaW5lXG5sZXQgcHJlcnJfY2hhciA9IHByZXJyX2NoYXJcbmxldCBwcmVycl9zdHJpbmcgPSBwcmVycl9zdHJpbmdcbmxldCBwcmVycl9ieXRlcyA9IHByZXJyX2J5dGVzXG5sZXQgcHJlcnJfaW50ID0gcHJlcnJfaW50XG5sZXQgcHJlcnJfZmxvYXQgPSBwcmVycl9mbG9hdFxubGV0IHByZXJyX2VuZGxpbmUgPSBwcmVycl9lbmRsaW5lXG5sZXQgcHJlcnJfbmV3bGluZSA9IHByZXJyX25ld2xpbmVcbmxldCByZWFkX2xpbmUgPSByZWFkX2xpbmVcbmxldCByZWFkX2ludCA9IHJlYWRfaW50XG5sZXQgcmVhZF9pbnRfb3B0ID0gcmVhZF9pbnRfb3B0XG5sZXQgcmVhZF9mbG9hdCA9IHJlYWRfZmxvYXRcbmxldCByZWFkX2Zsb2F0X29wdCA9IHJlYWRfZmxvYXRfb3B0XG50eXBlIG5vbnJlYyBvcGVuX2ZsYWcgPSBvcGVuX2ZsYWcgPVxuICAgIE9wZW5fcmRvbmx5XG4gIHwgT3Blbl93cm9ubHlcbiAgfCBPcGVuX2FwcGVuZFxuICB8IE9wZW5fY3JlYXRcbiAgfCBPcGVuX3RydW5jXG4gIHwgT3Blbl9leGNsXG4gIHwgT3Blbl9iaW5hcnlcbiAgfCBPcGVuX3RleHRcbiAgfCBPcGVuX25vbmJsb2NrXG5sZXQgb3Blbl9vdXQgPSBvcGVuX291dFxubGV0IG9wZW5fb3V0X2JpbiA9IG9wZW5fb3V0X2JpblxubGV0IG9wZW5fb3V0X2dlbiA9IG9wZW5fb3V0X2dlblxubGV0IGZsdXNoID0gZmx1c2hcbmxldCBmbHVzaF9hbGwgPSBmbHVzaF9hbGxcbmxldCBvdXRwdXRfY2hhciA9IG91dHB1dF9jaGFyXG5sZXQgb3V0cHV0X3N0cmluZyA9IG91dHB1dF9zdHJpbmdcbmxldCBvdXRwdXRfYnl0ZXMgPSBvdXRwdXRfYnl0ZXNcbmxldCBvdXRwdXQgPSBvdXRwdXRcbmxldCBvdXRwdXRfc3Vic3RyaW5nID0gb3V0cHV0X3N1YnN0cmluZ1xubGV0IG91dHB1dF9ieXRlID0gb3V0cHV0X2J5dGVcbmxldCBvdXRwdXRfYmluYXJ5X2ludCA9IG91dHB1dF9iaW5hcnlfaW50XG5sZXQgb3V0cHV0X3ZhbHVlID0gb3V0cHV0X3ZhbHVlXG5sZXQgc2Vla19vdXQgPSBzZWVrX291dFxubGV0IHBvc19vdXQgPSBwb3Nfb3V0XG5sZXQgb3V0X2NoYW5uZWxfbGVuZ3RoID0gb3V0X2NoYW5uZWxfbGVuZ3RoXG5sZXQgY2xvc2Vfb3V0ID0gY2xvc2Vfb3V0XG5sZXQgY2xvc2Vfb3V0X25vZXJyID0gY2xvc2Vfb3V0X25vZXJyXG5sZXQgc2V0X2JpbmFyeV9tb2RlX291dCA9IHNldF9iaW5hcnlfbW9kZV9vdXRcbmxldCBvcGVuX2luID0gb3Blbl9pblxubGV0IG9wZW5faW5fYmluID0gb3Blbl9pbl9iaW5cbmxldCBvcGVuX2luX2dlbiA9IG9wZW5faW5fZ2VuXG5sZXQgaW5wdXRfY2hhciA9IGlucHV0X2NoYXJcbmxldCBpbnB1dF9saW5lID0gaW5wdXRfbGluZVxubGV0IGlucHV0ID0gaW5wdXRcbmxldCByZWFsbHlfaW5wdXQgPSByZWFsbHlfaW5wdXRcbmxldCByZWFsbHlfaW5wdXRfc3RyaW5nID0gcmVhbGx5X2lucHV0X3N0cmluZ1xubGV0IGlucHV0X2J5dGUgPSBpbnB1dF9ieXRlXG5sZXQgaW5wdXRfYmluYXJ5X2ludCA9IGlucHV0X2JpbmFyeV9pbnRcbmxldCBpbnB1dF92YWx1ZSA9IGlucHV0X3ZhbHVlXG5sZXQgc2Vla19pbiA9IHNlZWtfaW5cbmxldCBwb3NfaW4gPSBwb3NfaW5cbmxldCBpbl9jaGFubmVsX2xlbmd0aCA9IGluX2NoYW5uZWxfbGVuZ3RoXG5sZXQgY2xvc2VfaW4gPSBjbG9zZV9pblxubGV0IGNsb3NlX2luX25vZXJyID0gY2xvc2VfaW5fbm9lcnJcbmxldCBzZXRfYmluYXJ5X21vZGVfaW4gPSBzZXRfYmluYXJ5X21vZGVfaW5cbm1vZHVsZSBMYXJnZUZpbGUgPSBMYXJnZUZpbGVcbnR5cGUgbm9ucmVjICdhIHJlZiA9ICdhIHJlZiA9IHsgbXV0YWJsZSBjb250ZW50cyA6ICdhIH1cbmV4dGVybmFsIHJlZiA6ICdhIC0+ICdhIHJlZiA9IFwiJW1ha2VtdXRhYmxlXCJcbmV4dGVybmFsICggISApIDogJ2EgcmVmIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsICggOj0gKSA6ICdhIHJlZiAtPiAnYSAtPiB1bml0ID0gXCIlc2V0ZmllbGQwXCJcbmV4dGVybmFsIGluY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVpbmNyXCJcbmV4dGVybmFsIGRlY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVkZWNyXCJcbnR5cGUgbm9ucmVjICgnYSwnYikgcmVzdWx0ID0gKCdhLCdiKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdiXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID1cbiAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2XG50eXBlICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NCA9ICgnYSwgJ2IsICdjLCAnYywgJ2MsICdkKSBmb3JtYXQ2XG50eXBlICgnYSwgJ2IsICdjKSBmb3JtYXQgPSAoJ2EsICdiLCAnYywgJ2MpIGZvcm1hdDRcbmxldCBzdHJpbmdfb2ZfZm9ybWF0ID0gc3RyaW5nX29mX2Zvcm1hdFxuZXh0ZXJuYWwgZm9ybWF0X29mX3N0cmluZyA6XG4gICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID0gXCIlaWRlbnRpdHlcIlxubGV0ICggXl4gKSA9ICggXl4gKVxubGV0IGV4aXQgPSBleGl0XG5sZXQgYXRfZXhpdCA9IGF0X2V4aXRcbmxldCB2YWxpZF9mbG9hdF9sZXhlbSA9IHZhbGlkX2Zsb2F0X2xleGVtXG5sZXQgZG9fYXRfZXhpdCA9IGRvX2F0X2V4aXRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQW4gYWxpYXMgZm9yIHRoZSB0eXBlIG9mIGxpc3RzLiAqKVxudHlwZSAnYSB0ID0gJ2EgbGlzdCA9IFtdIHwgKDo6KSBvZiAnYSAqICdhIGxpc3RcblxuKCogTGlzdCBvcGVyYXRpb25zICopXG5cbmxldCByZWMgbGVuZ3RoX2F1eCBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGxlblxuICB8IF86OmwgLT4gbGVuZ3RoX2F1eCAobGVuICsgMSkgbFxuXG5sZXQgbGVuZ3RoIGwgPSBsZW5ndGhfYXV4IDAgbFxuXG5sZXQgY29ucyBhIGwgPSBhOjpsXG5cbmxldCBoZCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFpbHdpdGggXCJoZFwiXG4gIHwgYTo6XyAtPiBhXG5cbmxldCB0bCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFpbHdpdGggXCJ0bFwiXG4gIHwgXzo6bCAtPiBsXG5cbmxldCBudGggbCBuID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QubnRoXCIgZWxzZVxuICBsZXQgcmVjIG50aF9hdXggbCBuID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IGZhaWx3aXRoIFwibnRoXCJcbiAgICB8IGE6OmwgLT4gaWYgbiA9IDAgdGhlbiBhIGVsc2UgbnRoX2F1eCBsIChuLTEpXG4gIGluIG50aF9hdXggbCBuXG5cbmxldCBudGhfb3B0IGwgbiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0Lm50aFwiIGVsc2VcbiAgbGV0IHJlYyBudGhfYXV4IGwgbiA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCBhOjpsIC0+IGlmIG4gPSAwIHRoZW4gU29tZSBhIGVsc2UgbnRoX2F1eCBsIChuLTEpXG4gIGluIG50aF9hdXggbCBuXG5cbmxldCBhcHBlbmQgPSAoQClcblxubGV0IHJlYyByZXZfYXBwZW5kIGwxIGwyID1cbiAgbWF0Y2ggbDEgd2l0aFxuICAgIFtdIC0+IGwyXG4gIHwgYSA6OiBsIC0+IHJldl9hcHBlbmQgbCAoYSA6OiBsMilcblxubGV0IHJldiBsID0gcmV2X2FwcGVuZCBsIFtdXG5cbmxldCByZWMgaW5pdF90YWlscmVjX2F1eCBhY2MgaSBuIGYgPVxuICBpZiBpID49IG4gdGhlbiBhY2NcbiAgZWxzZSBpbml0X3RhaWxyZWNfYXV4IChmIGkgOjogYWNjKSAoaSsxKSBuIGZcblxubGV0IHJlYyBpbml0X2F1eCBpIG4gZiA9XG4gIGlmIGkgPj0gbiB0aGVuIFtdXG4gIGVsc2VcbiAgICBsZXQgciA9IGYgaSBpblxuICAgIHIgOjogaW5pdF9hdXggKGkrMSkgbiBmXG5cbmxldCByZXZfaW5pdF90aHJlc2hvbGQgPVxuICBtYXRjaCBTeXMuYmFja2VuZF90eXBlIHdpdGhcbiAgfCBTeXMuTmF0aXZlIHwgU3lzLkJ5dGVjb2RlIC0+IDEwXzAwMFxuICAoKiBXZSBkb24ndCBrbm93IHRoZSBzaXplIG9mIHRoZSBzdGFjaywgYmV0dGVyIGJlIHNhZmUgYW5kIGFzc3VtZSBpdCdzXG4gICAgIHNtYWxsLiAqKVxuICB8IFN5cy5PdGhlciBfIC0+IDUwXG5cbmxldCBpbml0IGxlbiBmID1cbiAgaWYgbGVuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5pbml0XCIgZWxzZVxuICBpZiBsZW4gPiByZXZfaW5pdF90aHJlc2hvbGQgdGhlbiByZXYgKGluaXRfdGFpbHJlY19hdXggW10gMCBsZW4gZilcbiAgZWxzZSBpbml0X2F1eCAwIGxlbiBmXG5cbmxldCByZWMgZmxhdHRlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBsOjpyIC0+IGwgQCBmbGF0dGVuIHJcblxubGV0IGNvbmNhdCA9IGZsYXR0ZW5cblxubGV0IHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBhOjpsIC0+IGxldCByID0gZiBhIGluIHIgOjogbWFwIGYgbFxuXG5sZXQgcmVjIG1hcGkgaSBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbXVxuICB8IGE6OmwgLT4gbGV0IHIgPSBmIGkgYSBpbiByIDo6IG1hcGkgKGkgKyAxKSBmIGxcblxubGV0IG1hcGkgZiBsID0gbWFwaSAwIGYgbFxuXG5sZXQgcmV2X21hcCBmIGwgPVxuICBsZXQgcmVjIHJtYXBfZiBhY2N1ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY3VcbiAgICB8IGE6OmwgLT4gcm1hcF9mIChmIGEgOjogYWNjdSkgbFxuICBpblxuICBybWFwX2YgW10gbFxuXG5cbmxldCByZWMgaXRlciBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiAoKVxuICB8IGE6OmwgLT4gZiBhOyBpdGVyIGYgbFxuXG5sZXQgcmVjIGl0ZXJpIGkgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gKClcbiAgfCBhOjpsIC0+IGYgaSBhOyBpdGVyaSAoaSArIDEpIGYgbFxuXG5sZXQgaXRlcmkgZiBsID0gaXRlcmkgMCBmIGxcblxubGV0IHJlYyBmb2xkX2xlZnQgZiBhY2N1IGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgICBbXSAtPiBhY2N1XG4gIHwgYTo6bCAtPiBmb2xkX2xlZnQgZiAoZiBhY2N1IGEpIGxcblxubGV0IHJlYyBmb2xkX3JpZ2h0IGYgbCBhY2N1ID1cbiAgbWF0Y2ggbCB3aXRoXG4gICAgW10gLT4gYWNjdVxuICB8IGE6OmwgLT4gZiBhIChmb2xkX3JpZ2h0IGYgbCBhY2N1KVxuXG5sZXQgcmVjIG1hcDIgZiBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBbXVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gbGV0IHIgPSBmIGExIGEyIGluIHIgOjogbWFwMiBmIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5tYXAyXCJcblxubGV0IHJldl9tYXAyIGYgbDEgbDIgPVxuICBsZXQgcmVjIHJtYXAyX2YgYWNjdSBsMSBsMiA9XG4gICAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIHwgKFtdLCBbXSkgLT4gYWNjdVxuICAgIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBybWFwMl9mIChmIGExIGEyIDo6IGFjY3UpIGwxIGwyXG4gICAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LnJldl9tYXAyXCJcbiAgaW5cbiAgcm1hcDJfZiBbXSBsMSBsMlxuXG5cbmxldCByZWMgaXRlcjIgZiBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiAoKVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gZiBhMSBhMjsgaXRlcjIgZiBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuaXRlcjJcIlxuXG5sZXQgcmVjIGZvbGRfbGVmdDIgZiBhY2N1IGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGFjY3VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGZvbGRfbGVmdDIgZiAoZiBhY2N1IGExIGEyKSBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9sZF9sZWZ0MlwiXG5cbmxldCByZWMgZm9sZF9yaWdodDIgZiBsMSBsMiBhY2N1ID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGFjY3VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGYgYTEgYTIgKGZvbGRfcmlnaHQyIGYgbDEgbDIgYWNjdSlcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvbGRfcmlnaHQyXCJcblxubGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgIFtdIC0+IHRydWVcbiAgfCBhOjpsIC0+IHAgYSAmJiBmb3JfYWxsIHAgbFxuXG5sZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gcCBhIHx8IGV4aXN0cyBwIGxcblxubGV0IHJlYyBmb3JfYWxsMiBwIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IHRydWVcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHAgYTEgYTIgJiYgZm9yX2FsbDIgcCBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9yX2FsbDJcIlxuXG5sZXQgcmVjIGV4aXN0czIgcCBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBmYWxzZVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcCBhMSBhMiB8fCBleGlzdHMyIHAgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmV4aXN0czJcIlxuXG5sZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gY29tcGFyZSBhIHggPSAwIHx8IG1lbSB4IGxcblxubGV0IHJlYyBtZW1xIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhbHNlXG4gIHwgYTo6bCAtPiBhID09IHggfHwgbWVtcSB4IGxcblxubGV0IHJlYyBhc3NvYyB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoYSxiKTo6bCAtPiBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBiIGVsc2UgYXNzb2MgeCBsXG5cbmxldCByZWMgYXNzb2Nfb3B0IHggPSBmdW5jdGlvblxuICAgIFtdIC0+IE5vbmVcbiAgfCAoYSxiKTo6bCAtPiBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBTb21lIGIgZWxzZSBhc3NvY19vcHQgeCBsXG5cbmxldCByZWMgYXNzcSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoYSxiKTo6bCAtPiBpZiBhID09IHggdGhlbiBiIGVsc2UgYXNzcSB4IGxcblxubGV0IHJlYyBhc3NxX29wdCB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBOb25lXG4gIHwgKGEsYik6OmwgLT4gaWYgYSA9PSB4IHRoZW4gU29tZSBiIGVsc2UgYXNzcV9vcHQgeCBsXG5cbmxldCByZWMgbWVtX2Fzc29jIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IGZhbHNlXG4gIHwgKGEsIF8pIDo6IGwgLT4gY29tcGFyZSBhIHggPSAwIHx8IG1lbV9hc3NvYyB4IGxcblxubGV0IHJlYyBtZW1fYXNzcSB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBmYWxzZVxuICB8IChhLCBfKSA6OiBsIC0+IGEgPT0geCB8fCBtZW1fYXNzcSB4IGxcblxubGV0IHJlYyByZW1vdmVfYXNzb2MgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCAoYSwgXyBhcyBwYWlyKSA6OiBsIC0+XG4gICAgICBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBsIGVsc2UgcGFpciA6OiByZW1vdmVfYXNzb2MgeCBsXG5cbmxldCByZWMgcmVtb3ZlX2Fzc3EgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCAoYSwgXyBhcyBwYWlyKSA6OiBsIC0+IGlmIGEgPT0geCB0aGVuIGwgZWxzZSBwYWlyIDo6IHJlbW92ZV9hc3NxIHggbFxuXG5sZXQgcmVjIGZpbmQgcCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIHggZWxzZSBmaW5kIHAgbFxuXG5sZXQgcmVjIGZpbmRfb3B0IHAgPSBmdW5jdGlvblxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4gU29tZSB4IGVsc2UgZmluZF9vcHQgcCBsXG5cbmxldCByZWMgZmluZF9tYXAgZiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogbCAtPlxuICAgICBiZWdpbiBtYXRjaCBmIHggd2l0aFxuICAgICAgIHwgU29tZSBfIGFzIHJlc3VsdCAtPiByZXN1bHRcbiAgICAgICB8IE5vbmUgLT4gZmluZF9tYXAgZiBsXG4gICAgIGVuZFxuXG5sZXQgZmluZF9hbGwgcCA9XG4gIGxldCByZWMgZmluZCBhY2N1ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiByZXYgYWNjdVxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiBmaW5kICh4IDo6IGFjY3UpIGwgZWxzZSBmaW5kIGFjY3UgbCBpblxuICBmaW5kIFtdXG5cbmxldCBmaWx0ZXIgPSBmaW5kX2FsbFxuXG5sZXQgZmlsdGVyaSBwIGwgPVxuICBsZXQgcmVjIGF1eCBpIGFjYyA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gcmV2IGFjY1xuICB8IHg6OmwgLT4gYXV4IChpICsgMSkgKGlmIHAgaSB4IHRoZW4geDo6YWNjIGVsc2UgYWNjKSBsXG4gIGluXG4gIGF1eCAwIFtdIGxcblxubGV0IGZpbHRlcl9tYXAgZiA9XG4gIGxldCByZWMgYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmV2IGFjY3VcbiAgICB8IHggOjogbCAtPlxuICAgICAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgICB8IE5vbmUgLT4gYXV4IGFjY3UgbFxuICAgICAgICB8IFNvbWUgdiAtPiBhdXggKHYgOjogYWNjdSkgbFxuICBpblxuICBhdXggW11cblxubGV0IGNvbmNhdF9tYXAgZiBsID1cbiAgbGV0IHJlYyBhdXggZiBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmV2IGFjY1xuICAgIHwgeCA6OiBsIC0+XG4gICAgICAgbGV0IHhzID0gZiB4IGluXG4gICAgICAgYXV4IGYgKHJldl9hcHBlbmQgeHMgYWNjKSBsXG4gIGluIGF1eCBmIFtdIGxcblxubGV0IGZvbGRfbGVmdF9tYXAgZiBhY2N1IGwgPVxuICBsZXQgcmVjIGF1eCBhY2N1IGxfYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2N1LCByZXYgbF9hY2N1XG4gICAgfCB4IDo6IGwgLT5cbiAgICAgICAgbGV0IGFjY3UsIHggPSBmIGFjY3UgeCBpblxuICAgICAgICBhdXggYWNjdSAoeCA6OiBsX2FjY3UpIGwgaW5cbiAgYXV4IGFjY3UgW10gbFxuXG5sZXQgcGFydGl0aW9uIHAgbCA9XG4gIGxldCByZWMgcGFydCB5ZXMgbm8gPSBmdW5jdGlvblxuICB8IFtdIC0+IChyZXYgeWVzLCByZXYgbm8pXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIHBhcnQgKHggOjogeWVzKSBubyBsIGVsc2UgcGFydCB5ZXMgKHggOjogbm8pIGwgaW5cbiAgcGFydCBbXSBbXSBsXG5cbmxldCBwYXJ0aXRpb25fbWFwIHAgbCA9XG4gIGxldCByZWMgcGFydCBsZWZ0IHJpZ2h0ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiAocmV2IGxlZnQsIHJldiByaWdodClcbiAgfCB4IDo6IGwgLT5cbiAgICAgYmVnaW4gbWF0Y2ggcCB4IHdpdGhcbiAgICAgICB8IEVpdGhlci5MZWZ0IHYgLT4gcGFydCAodiA6OiBsZWZ0KSByaWdodCBsXG4gICAgICAgfCBFaXRoZXIuUmlnaHQgdiAtPiBwYXJ0IGxlZnQgKHYgOjogcmlnaHQpIGxcbiAgICAgZW5kXG4gIGluXG4gIHBhcnQgW10gW10gbFxuXG5sZXQgcmVjIHNwbGl0ID0gZnVuY3Rpb25cbiAgICBbXSAtPiAoW10sIFtdKVxuICB8ICh4LHkpOjpsIC0+XG4gICAgICBsZXQgKHJ4LCByeSkgPSBzcGxpdCBsIGluICh4OjpyeCwgeTo6cnkpXG5cbmxldCByZWMgY29tYmluZSBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBbXVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gKGExLCBhMikgOjogY29tYmluZSBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuY29tYmluZVwiXG5cbigqKiBzb3J0aW5nICopXG5cbmxldCByZWMgbWVyZ2UgY21wIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgbDIgLT4gbDJcbiAgfCBsMSwgW10gLT4gbDFcbiAgfCBoMSA6OiB0MSwgaDIgOjogdDIgLT5cbiAgICAgIGlmIGNtcCBoMSBoMiA8PSAwXG4gICAgICB0aGVuIGgxIDo6IG1lcmdlIGNtcCB0MSBsMlxuICAgICAgZWxzZSBoMiA6OiBtZXJnZSBjbXAgbDEgdDJcblxuXG5sZXQgc3RhYmxlX3NvcnQgY21wIGwgPVxuICBsZXQgcmVjIHJldl9tZXJnZSBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgaWYgY21wIGgxIGgyIDw9IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2UgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZSBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgcmV2X21lcmdlX3JldiBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgaWYgY21wIGgxIGgyID4gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZV9yZXYgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZV9yZXYgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHNvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID0gaWYgY21wIHgxIHgyIDw9IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBpZiBjbXAgeDEgeDIgPD0gMCB0aGVuXG4gICAgICAgICAgICBpZiBjbXAgeDIgeDMgPD0gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPD0gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA8PSAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgZWxzZSBpZiBjbXAgeDIgeDMgPD0gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IG4sIGwgLT5cbiAgICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICAgbGV0IHMxLCBsMiA9IHJldl9zb3J0IG4xIGwgaW5cbiAgICAgICAgbGV0IHMyLCB0bCA9IHJldl9zb3J0IG4yIGwyIGluXG4gICAgICAgIChyZXZfbWVyZ2VfcmV2IHMxIHMyIFtdLCB0bClcbiAgYW5kIHJldl9zb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9IGlmIGNtcCB4MSB4MiA+IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBpZiBjbXAgeDEgeDIgPiAwIHRoZW5cbiAgICAgICAgICAgIGlmIGNtcCB4MiB4MyA+IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzID4gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA+IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MiB4MyA+IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSBzb3J0IG4xIGwgaW5cbiAgICAgICAgbGV0IHMyLCB0bCA9IHNvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZSBzMSBzMiBbXSwgdGwpXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggbCBpblxuICBpZiBsZW4gPCAyIHRoZW4gbCBlbHNlIGZzdCAoc29ydCBsZW4gbClcblxuXG5sZXQgc29ydCA9IHN0YWJsZV9zb3J0XG5sZXQgZmFzdF9zb3J0ID0gc3RhYmxlX3NvcnRcblxuKCogTm90ZTogb24gYSBsaXN0IG9mIGxlbmd0aCBiZXR3ZWVuIGFib3V0IDEwMDAwMCAoZGVwZW5kaW5nIG9uIHRoZSBtaW5vclxuICAgaGVhcCBzaXplIGFuZCB0aGUgdHlwZSBvZiB0aGUgbGlzdCkgYW5kIFN5cy5tYXhfYXJyYXlfc2l6ZSwgaXQgaXNcbiAgIGFjdHVhbGx5IGZhc3RlciB0byB1c2UgdGhlIGZvbGxvd2luZywgYnV0IGl0IG1pZ2h0IGFsc28gdXNlIG1vcmUgbWVtb3J5XG4gICBiZWNhdXNlIHRoZSBhcmd1bWVudCBsaXN0IGNhbm5vdCBiZSBkZWFsbG9jYXRlZCBpbmNyZW1lbnRhbGx5LlxuXG4gICBBbHNvLCB0aGVyZSBzZWVtcyB0byBiZSBhIGJ1ZyBpbiB0aGlzIGNvZGUgb3IgaW4gdGhlXG4gICBpbXBsZW1lbnRhdGlvbiBvZiBvYmpfdHJ1bmNhdGUuXG5cbmV4dGVybmFsIG9ial90cnVuY2F0ZSA6ICdhIGFycmF5IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX29ial90cnVuY2F0ZVwiXG5cbmxldCBhcnJheV90b19saXN0X2luX3BsYWNlIGEgPVxuICBsZXQgbCA9IEFycmF5Lmxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBhY2N1IG4gcCA9XG4gICAgaWYgcCA8PSAwIHRoZW4gYWNjdSBlbHNlIGJlZ2luXG4gICAgICBpZiBwID0gbiB0aGVuIGJlZ2luXG4gICAgICAgIG9ial90cnVuY2F0ZSBhIHA7XG4gICAgICAgIGxvb3AgKGEuKHAtMSkgOjogYWNjdSkgKG4tMTAwMCkgKHAtMSlcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIGxvb3AgKGEuKHAtMSkgOjogYWNjdSkgbiAocC0xKVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGluXG4gIGxvb3AgW10gKGwtMTAwMCkgbFxuXG5cbmxldCBzdGFibGVfc29ydCBjbXAgbCA9XG4gIGxldCBhID0gQXJyYXkub2ZfbGlzdCBsIGluXG4gIEFycmF5LnN0YWJsZV9zb3J0IGNtcCBhO1xuICBhcnJheV90b19saXN0X2luX3BsYWNlIGFcblxuKilcblxuXG4oKiogc29ydGluZyArIHJlbW92aW5nIGR1cGxpY2F0ZXMgKilcblxubGV0IHNvcnRfdW5pcSBjbXAgbCA9XG4gIGxldCByZWMgcmV2X21lcmdlIGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBsZXQgYyA9IGNtcCBoMSBoMiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIHJldl9tZXJnZSB0MSB0MiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2UgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZSBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgcmV2X21lcmdlX3JldiBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgbGV0IGMgPSBjbXAgaDEgaDIgaW5cbiAgICAgICAgaWYgYyA9IDAgdGhlbiByZXZfbWVyZ2VfcmV2IHQxIHQyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSBpZiBjID4gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZV9yZXYgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZV9yZXYgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHNvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxXSBlbHNlIGlmIGMgPCAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDJdIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgzXSBlbHNlIFt4MzsgeDJdXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDI7IHgxXVxuICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgbiwgbCAtPlxuICAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgICBsZXQgczEsIGwyID0gcmV2X3NvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gcmV2X3NvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZV9yZXYgczEgczIgW10sIHRsKVxuICBhbmQgcmV2X3NvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxXSBlbHNlIGlmIGMgPiAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDJdIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgzXSBlbHNlIFt4MzsgeDJdXG4gICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDI7IHgxXVxuICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgbiwgbCAtPlxuICAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgICBsZXQgczEsIGwyID0gc29ydCBuMSBsIGluXG4gICAgICAgIGxldCBzMiwgdGwgPSBzb3J0IG4yIGwyIGluXG4gICAgICAgIChyZXZfbWVyZ2UgczEgczIgW10sIHRsKVxuICBpblxuICBsZXQgbGVuID0gbGVuZ3RoIGwgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIGwgZWxzZSBmc3QgKHNvcnQgbGVuIGwpXG5cblxubGV0IHJlYyBjb21wYXJlX2xlbmd0aHMgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiAwXG4gIHwgW10sIF8gLT4gLTFcbiAgfCBfLCBbXSAtPiAxXG4gIHwgXyA6OiBsMSwgXyA6OiBsMiAtPiBjb21wYXJlX2xlbmd0aHMgbDEgbDJcbjs7XG5cbmxldCByZWMgY29tcGFyZV9sZW5ndGhfd2l0aCBsIG4gPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPlxuICAgIGlmIG4gPSAwIHRoZW4gMCBlbHNlXG4gICAgICBpZiBuID4gMCB0aGVuIC0xIGVsc2UgMVxuICB8IF8gOjogbCAtPlxuICAgIGlmIG4gPD0gMCB0aGVuIDEgZWxzZVxuICAgICAgY29tcGFyZV9sZW5ndGhfd2l0aCBsIChuLTEpXG47O1xuXG4oKiogezEgQ29tcGFyaXNvbn0gKilcblxuKCogTm90ZTogd2UgYXJlICpub3QqIHNob3J0Y3V0dGluZyB0aGUgbGlzdCBieSB1c2luZ1xuICAgW0xpc3QuY29tcGFyZV9sZW5ndGhzXSBmaXJzdDsgdGhpcyBtYXkgYmUgc2xvd2VyIG9uIGxvbmcgbGlzdHNcbiAgIGltbWVkaWF0ZWx5IHN0YXJ0IHdpdGggZGlzdGluY3QgZWxlbWVudHMuIEl0IGlzIGFsc28gaW5jb3JyZWN0IGZvclxuICAgW2NvbXBhcmVdIGJlbG93LCBhbmQgaXQgaXMgYmV0dGVyIChwcmluY2lwbGUgb2YgbGVhc3Qgc3VycHJpc2UpIHRvXG4gICB1c2UgdGhlIHNhbWUgYXBwcm9hY2ggZm9yIGJvdGggZnVuY3Rpb25zLiAqKVxubGV0IHJlYyBlcXVhbCBlcSBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IHRydWVcbiAgfCBbXSwgXzo6XyB8IF86Ol8sIFtdIC0+IGZhbHNlXG4gIHwgYTE6OmwxLCBhMjo6bDIgLT4gZXEgYTEgYTIgJiYgZXF1YWwgZXEgbDEgbDJcblxubGV0IHJlYyBjb21wYXJlIGNtcCBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXzo6XyAtPiAtMVxuICB8IF86Ol8sIFtdIC0+IDFcbiAgfCBhMTo6bDEsIGEyOjpsMiAtPlxuICAgIGxldCBjID0gY21wIGExIGEyIGluXG4gICAgaWYgYyA8PiAwIHRoZW4gY1xuICAgIGVsc2UgY29tcGFyZSBjbXAgbDEgbDJcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBsID1cbiAgbGV0IHJlYyBhdXggbCAoKSA9IG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gU2VxLk5pbFxuICAgIHwgeCA6OiB0YWlsIC0+IFNlcS5Db25zICh4LCBhdXggdGFpbClcbiAgaW5cbiAgYXV4IGxcblxubGV0IG9mX3NlcSBzZXEgPVxuICBsZXQgcmVjIGRpcmVjdCBkZXB0aCBzZXEgOiBfIGxpc3QgPVxuICAgIGlmIGRlcHRoPTBcbiAgICB0aGVuXG4gICAgICBTZXEuZm9sZF9sZWZ0IChmdW4gYWNjIHggLT4geDo6YWNjKSBbXSBzZXFcbiAgICAgIHw+IHJldiAoKiB0YWlscmVjICopXG4gICAgZWxzZSBtYXRjaCBzZXEoKSB3aXRoXG4gICAgICB8IFNlcS5OaWwgLT4gW11cbiAgICAgIHwgU2VxLkNvbnMgKHgsIG5leHQpIC0+IHggOjogZGlyZWN0IChkZXB0aC0xKSBuZXh0XG4gIGluXG4gIGRpcmVjdCA1MDAgc2VxXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE9wZXJhdGlvbnMgb24gaW50ZXJuYWwgcmVwcmVzZW50YXRpb25zIG9mIHZhbHVlcyAqKVxuXG50eXBlIHRcblxudHlwZSByYXdfZGF0YSA9IG5hdGl2ZWludFxuXG5leHRlcm5hbCByZXByIDogJ2EgLT4gdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIG9iaiA6IHQgLT4gJ2EgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBtYWdpYyA6ICdhIC0+ICdiID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgaXNfaW50IDogdCAtPiBib29sID0gXCIlb2JqX2lzX2ludFwiXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBpc19ibG9jayBhID0gbm90IChpc19pbnQgYSlcbmV4dGVybmFsIHRhZyA6IHQgLT4gaW50ID0gXCJjYW1sX29ial90YWdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2V0X3RhZyA6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3NldF90YWdcIlxuZXh0ZXJuYWwgc2l6ZSA6IHQgLT4gaW50ID0gXCIlb2JqX3NpemVcIlxuZXh0ZXJuYWwgcmVhY2hhYmxlX3dvcmRzIDogdCAtPiBpbnQgPSBcImNhbWxfb2JqX3JlYWNoYWJsZV93b3Jkc1wiXG5leHRlcm5hbCBmaWVsZCA6IHQgLT4gaW50IC0+IHQgPSBcIiVvYmpfZmllbGRcIlxuZXh0ZXJuYWwgc2V0X2ZpZWxkIDogdCAtPiBpbnQgLT4gdCAtPiB1bml0ID0gXCIlb2JqX3NldF9maWVsZFwiXG5leHRlcm5hbCBmbG9hdGFycmF5X2dldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfZ2V0XCJcbmV4dGVybmFsIGZsb2F0YXJyYXlfc2V0IDpcbiAgICBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfc2V0XCJcbmxldCBbQGlubGluZSBhbHdheXNdIGRvdWJsZV9maWVsZCB4IGkgPSBmbG9hdGFycmF5X2dldCAob2JqIHggOiBmbG9hdGFycmF5KSBpXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBzZXRfZG91YmxlX2ZpZWxkIHggaSB2ID1cbiAgZmxvYXRhcnJheV9zZXQgKG9iaiB4IDogZmxvYXRhcnJheSkgaSB2XG5leHRlcm5hbCByYXdfZmllbGQgOiB0IC0+IGludCAtPiByYXdfZGF0YSA9IFwiY2FtbF9vYmpfcmF3X2ZpZWxkXCJcbmV4dGVybmFsIHNldF9yYXdfZmllbGQgOiB0IC0+IGludCAtPiByYXdfZGF0YSAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9vYmpfc2V0X3Jhd19maWVsZFwiXG5cbmV4dGVybmFsIG5ld19ibG9jayA6IGludCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9vYmpfYmxvY2tcIlxuZXh0ZXJuYWwgZHVwIDogdCAtPiB0ID0gXCJjYW1sX29ial9kdXBcIlxuZXh0ZXJuYWwgdHJ1bmNhdGUgOiB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX29ial90cnVuY2F0ZVwiXG5leHRlcm5hbCBhZGRfb2Zmc2V0IDogdCAtPiBJbnQzMi50IC0+IHQgPSBcImNhbWxfb2JqX2FkZF9vZmZzZXRcIlxuZXh0ZXJuYWwgd2l0aF90YWcgOiBpbnQgLT4gdCAtPiB0ID0gXCJjYW1sX29ial93aXRoX3RhZ1wiXG5cbmxldCBmaXJzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnID0gMFxubGV0IGxhc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yX3RhZyA9IDI0NVxuXG5sZXQgbGF6eV90YWcgPSAyNDZcbmxldCBjbG9zdXJlX3RhZyA9IDI0N1xubGV0IG9iamVjdF90YWcgPSAyNDhcbmxldCBpbmZpeF90YWcgPSAyNDlcbmxldCBmb3J3YXJkX3RhZyA9IDI1MFxuXG5sZXQgbm9fc2Nhbl90YWcgPSAyNTFcblxubGV0IGFic3RyYWN0X3RhZyA9IDI1MVxubGV0IHN0cmluZ190YWcgPSAyNTJcbmxldCBkb3VibGVfdGFnID0gMjUzXG5sZXQgZG91YmxlX2FycmF5X3RhZyA9IDI1NFxubGV0IGN1c3RvbV90YWcgPSAyNTVcbmxldCBmaW5hbF90YWcgPSBjdXN0b21fdGFnXG5cblxubGV0IGludF90YWcgPSAxMDAwXG5sZXQgb3V0X29mX2hlYXBfdGFnID0gMTAwMVxubGV0IHVuYWxpZ25lZF90YWcgPSAxMDAyXG5cbm1vZHVsZSBDbG9zdXJlID0gc3RydWN0XG4gIHR5cGUgaW5mbyA9IHtcbiAgICBhcml0eTogaW50O1xuICAgIHN0YXJ0X2VudjogaW50O1xuICB9XG5cbiAgbGV0IGluZm9fb2ZfcmF3IChpbmZvIDogbmF0aXZlaW50KSA9XG4gICAgbGV0IG9wZW4gTmF0aXZlaW50IGluXG4gICAgbGV0IGFyaXR5ID1cbiAgICAgICgqIHNpZ25lZDogbmVnYXRpdmUgZm9yIHR1cGxlZCBmdW5jdGlvbnMgKilcbiAgICAgIGlmIFN5cy53b3JkX3NpemUgPSA2NCB0aGVuXG4gICAgICAgIHRvX2ludCAoc2hpZnRfcmlnaHQgaW5mbyA1NilcbiAgICAgIGVsc2VcbiAgICAgICAgdG9faW50IChzaGlmdF9yaWdodCBpbmZvIDI0KVxuICAgIGluXG4gICAgbGV0IHN0YXJ0X2VudiA9XG4gICAgICAoKiBzdGFydF9lbnYgaXMgdW5zaWduZWQsIGJ1dCB3ZSBrbm93IGl0IGNhbiBhbHdheXMgZml0IGFuIE9DYW1sXG4gICAgICAgICBpbnRlZ2VyIHNvIHdlIHVzZSBbdG9faW50XSBpbnN0ZWFkIG9mIFt1bnNpZ25lZF90b19pbnRdLiAqKVxuICAgICAgdG9faW50IChzaGlmdF9yaWdodF9sb2dpY2FsIChzaGlmdF9sZWZ0IGluZm8gOCkgOSkgaW5cbiAgICB7IGFyaXR5OyBzdGFydF9lbnYgfVxuXG4gICgqIG5vdGU6IHdlIGV4cGVjdCBhIGNsb3N1cmUsIG5vdCBhbiBpbmZpeCBwb2ludGVyICopXG4gIGxldCBpbmZvIChvYmogOiB0KSA9XG4gICAgYXNzZXJ0ICh0YWcgb2JqID0gY2xvc3VyZV90YWcpO1xuICAgIGluZm9fb2ZfcmF3IChyYXdfZmllbGQgb2JqIDEpXG5lbmRcblxubW9kdWxlIEV4dGVuc2lvbl9jb25zdHJ1Y3RvciA9XG5zdHJ1Y3RcbiAgdHlwZSB0ID0gZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXG4gIGxldCBvZl92YWwgeCA9XG4gICAgbGV0IHggPSByZXByIHggaW5cbiAgICBsZXQgc2xvdCA9XG4gICAgICBpZiAoaXNfYmxvY2sgeCkgJiYgKHRhZyB4KSA8PiBvYmplY3RfdGFnICYmIChzaXplIHgpID49IDEgdGhlbiBmaWVsZCB4IDBcbiAgICAgIGVsc2UgeFxuICAgIGluXG4gICAgbGV0IG5hbWUgPVxuICAgICAgaWYgKGlzX2Jsb2NrIHNsb3QpICYmICh0YWcgc2xvdCkgPSBvYmplY3RfdGFnIHRoZW4gZmllbGQgc2xvdCAwXG4gICAgICBlbHNlIGludmFsaWRfYXJnIFwiT2JqLmV4dGVuc2lvbl9jb25zdHJ1Y3RvclwiXG4gICAgaW5cbiAgICAgIGlmICh0YWcgbmFtZSkgPSBzdHJpbmdfdGFnIHRoZW4gKG9iaiBzbG90IDogdClcbiAgICAgIGVsc2UgaW52YWxpZF9hcmcgXCJPYmouZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXCJcblxuICBsZXQgW0BpbmxpbmUgYWx3YXlzXSBuYW1lIChzbG90IDogdCkgPVxuICAgIChvYmogKGZpZWxkIChyZXByIHNsb3QpIDApIDogc3RyaW5nKVxuXG4gIGxldCBbQGlubGluZSBhbHdheXNdIGlkIChzbG90IDogdCkgPVxuICAgIChvYmogKGZpZWxkIChyZXByIHNsb3QpIDEpIDogaW50KVxuZW5kXG5cbmxldCBleHRlbnNpb25fY29uc3RydWN0b3IgPSBFeHRlbnNpb25fY29uc3RydWN0b3Iub2ZfdmFsXG5sZXQgZXh0ZW5zaW9uX25hbWUgPSBFeHRlbnNpb25fY29uc3RydWN0b3IubmFtZVxubGV0IGV4dGVuc2lvbl9pZCA9IEV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5pZFxuXG5tb2R1bGUgRXBoZW1lcm9uID0gc3RydWN0XG4gIHR5cGUgb2JqX3QgPSB0XG5cbiAgdHlwZSB0ICgqKiBlcGhlbWVyb24gKilcblxuICAgKCoqIFRvIGNoYW5nZSBpbiBzeW5jIHdpdGggd2Vhay5oICopXG4gIGxldCBhZGRpdGlvbmFsX3ZhbHVlcyA9IDJcbiAgbGV0IG1heF9lcGhlX2xlbmd0aCA9IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIC0gYWRkaXRpb25hbF92YWx1ZXNcblxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gdCA9IFwiY2FtbF9lcGhlX2NyZWF0ZVwiOztcbiAgbGV0IGNyZWF0ZSBsID1cbiAgICBpZiBub3QgKDAgPD0gbCAmJiBsIDw9IG1heF9lcGhlX2xlbmd0aCkgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJPYmouRXBoZW1lcm9uLmNyZWF0ZVwiO1xuICAgIGNyZWF0ZSBsXG5cbiAgbGV0IGxlbmd0aCB4ID0gc2l6ZShyZXByIHgpIC0gYWRkaXRpb25hbF92YWx1ZXNcblxuICBsZXQgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIG1zZyA9XG4gICAgaWYgbm90ICgwIDw9IG8gJiYgbyA8IGxlbmd0aCBlKSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBtc2dcblxuICBleHRlcm5hbCBnZXRfa2V5OiB0IC0+IGludCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfa2V5XCJcbiAgbGV0IGdldF9rZXkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLmdldF9rZXlcIjtcbiAgICBnZXRfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGdldF9rZXlfY29weTogdCAtPiBpbnQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2tleV9jb3B5XCJcbiAgbGV0IGdldF9rZXlfY29weSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uZ2V0X2tleV9jb3B5XCI7XG4gICAgZ2V0X2tleV9jb3B5IGUgb1xuXG4gIGV4dGVybmFsIHNldF9rZXk6IHQgLT4gaW50IC0+IG9ial90IC0+IHVuaXQgPSBcImNhbWxfZXBoZV9zZXRfa2V5XCJcbiAgbGV0IHNldF9rZXkgZSBvIHggPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uc2V0X2tleVwiO1xuICAgIHNldF9rZXkgZSBvIHhcblxuICBleHRlcm5hbCB1bnNldF9rZXk6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9rZXlcIlxuICBsZXQgdW5zZXRfa2V5IGUgbyA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi51bnNldF9rZXlcIjtcbiAgICB1bnNldF9rZXkgZSBvXG5cbiAgZXh0ZXJuYWwgY2hlY2tfa2V5OiB0IC0+IGludCAtPiBib29sID0gXCJjYW1sX2VwaGVfY2hlY2tfa2V5XCJcbiAgbGV0IGNoZWNrX2tleSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uY2hlY2tfa2V5XCI7XG4gICAgY2hlY2tfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGJsaXRfa2V5IDogdCAtPiBpbnQgLT4gdCAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICA9IFwiY2FtbF9lcGhlX2JsaXRfa2V5XCJcblxuICBsZXQgYmxpdF9rZXkgZTEgbzEgZTIgbzIgbCA9XG4gICAgaWYgbCA8IDAgfHwgbzEgPCAwIHx8IG8xID4gbGVuZ3RoIGUxIC0gbFxuICAgICAgIHx8IG8yIDwgMCB8fCBvMiA+IGxlbmd0aCBlMiAtIGxcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiT2JqLkVwaGVtZXJvbi5ibGl0X2tleVwiXG4gICAgZWxzZSBpZiBsIDw+IDAgdGhlbiBibGl0X2tleSBlMSBvMSBlMiBvMiBsXG5cbiAgZXh0ZXJuYWwgZ2V0X2RhdGE6IHQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2RhdGFcIlxuICBleHRlcm5hbCBnZXRfZGF0YV9jb3B5OiB0IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9kYXRhX2NvcHlcIlxuICBleHRlcm5hbCBzZXRfZGF0YTogdCAtPiBvYmpfdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2RhdGFcIlxuICBleHRlcm5hbCB1bnNldF9kYXRhOiB0IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9kYXRhXCJcbiAgZXh0ZXJuYWwgY2hlY2tfZGF0YTogdCAtPiBib29sID0gXCJjYW1sX2VwaGVfY2hlY2tfZGF0YVwiXG4gIGV4dGVybmFsIGJsaXRfZGF0YSA6IHQgLT4gdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfYmxpdF9kYXRhXCJcblxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEludGVybmFscyBvZiBmb3JjaW5nIGxhenkgdmFsdWVzLiAqKVxuXG50eXBlICdhIHQgPSAnYSBsYXp5X3RcblxuZXhjZXB0aW9uIFVuZGVmaW5lZFxuXG5sZXQgcmFpc2VfdW5kZWZpbmVkID0gT2JqLnJlcHIgKGZ1biAoKSAtPiByYWlzZSBVbmRlZmluZWQpXG5cbmV4dGVybmFsIG1ha2VfZm9yd2FyZCA6IE9iai50IC0+IE9iai50IC0+IHVuaXQgPSBcImNhbWxfb2JqX21ha2VfZm9yd2FyZFwiXG5cbigqIEFzc3VtZSBbYmxrXSBpcyBhIGJsb2NrIHdpdGggdGFnIGxhenkgKilcbmxldCBmb3JjZV9sYXp5X2Jsb2NrIChibGsgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgY2xvc3VyZSA9IChPYmoub2JqIChPYmouZmllbGQgKE9iai5yZXByIGJsaykgMCkgOiB1bml0IC0+ICdhcmcpIGluXG4gIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCByYWlzZV91bmRlZmluZWQ7XG4gIHRyeVxuICAgIGxldCByZXN1bHQgPSBjbG9zdXJlICgpIGluXG4gICAgbWFrZV9mb3J3YXJkIChPYmoucmVwciBibGspIChPYmoucmVwciByZXN1bHQpO1xuICAgIHJlc3VsdFxuICB3aXRoIGUgLT5cbiAgICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgKE9iai5yZXByIChmdW4gKCkgLT4gcmFpc2UgZSkpO1xuICAgIHJhaXNlIGVcblxuXG4oKiBBc3N1bWUgW2Jsa10gaXMgYSBibG9jayB3aXRoIHRhZyBsYXp5ICopXG5sZXQgZm9yY2VfdmFsX2xhenlfYmxvY2sgKGJsayA6ICdhcmcgbGF6eV90KSA9XG4gIGxldCBjbG9zdXJlID0gKE9iai5vYmogKE9iai5maWVsZCAoT2JqLnJlcHIgYmxrKSAwKSA6IHVuaXQgLT4gJ2FyZykgaW5cbiAgT2JqLnNldF9maWVsZCAoT2JqLnJlcHIgYmxrKSAwIHJhaXNlX3VuZGVmaW5lZDtcbiAgbGV0IHJlc3VsdCA9IGNsb3N1cmUgKCkgaW5cbiAgbWFrZV9mb3J3YXJkIChPYmoucmVwciBibGspIChPYmoucmVwciByZXN1bHQpO1xuICByZXN1bHRcblxuXG4oKiBbZm9yY2VdIGlzIG5vdCB1c2VkLCBzaW5jZSBbTGF6eS5mb3JjZV0gaXMgZGVjbGFyZWQgYXMgYSBwcmltaXRpdmVcbiAgIHdob3NlIGNvZGUgaW5saW5lcyB0aGUgdGFnIHRlc3RzIG9mIGl0cyBhcmd1bWVudCwgZXhjZXB0IHdoZW4gYWZsXG4gICBpbnN0cnVtZW50YXRpb24gaXMgdHVybmVkIG9uLiAqKVxuXG5sZXQgZm9yY2UgKGx6diA6ICdhcmcgbGF6eV90KSA9XG4gICgqIFVzaW5nIFtTeXMub3BhcXVlX2lkZW50aXR5XSBwcmV2ZW50cyB0d28gcG90ZW50aWFsIHByb2JsZW1zOlxuICAgICAtIElmIHRoZSB2YWx1ZSBpcyBrbm93biB0byBoYXZlIEZvcndhcmRfdGFnLCB0aGVuIGl0cyB0YWcgY291bGQgaGF2ZVxuICAgICAgIGNoYW5nZWQgZHVyaW5nIEdDLCBzbyB0aGF0IGluZm9ybWF0aW9uIG11c3QgYmUgZm9yZ290dGVuIChzZWUgR1BSIzcxM1xuICAgICAgIGFuZCBpc3N1ZSAjNzMwMSlcbiAgICAgLSBJZiB0aGUgdmFsdWUgaXMga25vd24gdG8gYmUgaW1tdXRhYmxlLCB0aGVuIGlmIHRoZSBjb21waWxlclxuICAgICAgIGNhbm5vdCBwcm92ZSB0aGF0IHRoZSBsYXN0IGJyYW5jaCBpcyBub3QgdGFrZW4gaXQgd2lsbCBpc3N1ZSBhXG4gICAgICAgd2FybmluZyA1OSAobW9kaWZpY2F0aW9uIG9mIGFuIGltbXV0YWJsZSB2YWx1ZSkgKilcbiAgbGV0IGx6diA9IFN5cy5vcGFxdWVfaWRlbnRpdHkgbHp2IGluXG4gIGxldCB4ID0gT2JqLnJlcHIgbHp2IGluXG4gIGxldCB0ID0gT2JqLnRhZyB4IGluXG4gIGlmIHQgPSBPYmouZm9yd2FyZF90YWcgdGhlbiAoT2JqLm9iaiAoT2JqLmZpZWxkIHggMCkgOiAnYXJnKSBlbHNlXG4gIGlmIHQgPD4gT2JqLmxhenlfdGFnIHRoZW4gKE9iai5vYmogeCA6ICdhcmcpXG4gIGVsc2UgZm9yY2VfbGF6eV9ibG9jayBsenZcblxuXG5sZXQgZm9yY2VfdmFsIChsenYgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgeCA9IE9iai5yZXByIGx6diBpblxuICBsZXQgdCA9IE9iai50YWcgeCBpblxuICBpZiB0ID0gT2JqLmZvcndhcmRfdGFnIHRoZW4gKE9iai5vYmogKE9iai5maWVsZCB4IDApIDogJ2FyZykgZWxzZVxuICBpZiB0IDw+IE9iai5sYXp5X3RhZyB0aGVuIChPYmoub2JqIHggOiAnYXJnKVxuICBlbHNlIGZvcmNlX3ZhbF9sYXp5X2Jsb2NrIGx6dlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgIFNpbW9uIENydWFuZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW1NlcV06IGZ1bmN0aW9uYWwgaXRlcmF0b3JzICopXG5cbnR5cGUgKydhIG5vZGUgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgJ2EgKiAnYSB0XG5cbmFuZCAnYSB0ID0gdW5pdCAtPiAnYSBub2RlXG5cbmxldCBlbXB0eSAoKSA9IE5pbFxuXG5sZXQgcmV0dXJuIHggKCkgPSBDb25zICh4LCBlbXB0eSlcblxubGV0IGNvbnMgeCBuZXh0ICgpID0gQ29ucyAoeCwgbmV4dClcblxubGV0IHJlYyBhcHBlbmQgc2VxMSBzZXEyICgpID1cbiAgbWF0Y2ggc2VxMSgpIHdpdGhcbiAgfCBOaWwgLT4gc2VxMigpXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gQ29ucyAoeCwgYXBwZW5kIG5leHQgc2VxMilcblxubGV0IHJlYyBtYXAgZiBzZXEgKCkgPSBtYXRjaCBzZXEoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+IENvbnMgKGYgeCwgbWFwIGYgbmV4dClcblxubGV0IHJlYyBmaWx0ZXJfbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGZpbHRlcl9tYXAgZiBuZXh0ICgpXG4gICAgICAgIHwgU29tZSB5IC0+IENvbnMgKHksIGZpbHRlcl9tYXAgZiBuZXh0KVxuXG5sZXQgcmVjIGZpbHRlciBmIHNlcSAoKSA9IG1hdGNoIHNlcSgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGlmIGYgeFxuICAgICAgdGhlbiBDb25zICh4LCBmaWx0ZXIgZiBuZXh0KVxuICAgICAgZWxzZSBmaWx0ZXIgZiBuZXh0ICgpXG5cbmxldCByZWMgY29uY2F0IHNlcSAoKSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgIGFwcGVuZCB4IChjb25jYXQgbmV4dCkgKClcblxubGV0IHJlYyBmbGF0X21hcCBmIHNlcSAoKSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgYXBwZW5kIChmIHgpIChmbGF0X21hcCBmIG5leHQpICgpXG5cbmxldCBjb25jYXRfbWFwID0gZmxhdF9tYXBcblxubGV0IHJlYyBmb2xkX2xlZnQgZiBhY2Mgc2VxID1cbiAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgICB8IE5pbCAtPiBhY2NcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGxldCBhY2MgPSBmIGFjYyB4IGluXG4gICAgICAgIGZvbGRfbGVmdCBmIGFjYyBuZXh0XG5cbmxldCByZWMgaXRlciBmIHNlcSA9XG4gIG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGYgeDtcbiAgICAgICAgaXRlciBmIG5leHRcblxubGV0IHJlYyB1bmZvbGQgZiB1ICgpID1cbiAgbWF0Y2ggZiB1IHdpdGhcbiAgfCBOb25lIC0+IE5pbFxuICB8IFNvbWUgKHgsIHUnKSAtPiBDb25zICh4LCB1bmZvbGQgZiB1JylcblxubGV0IGlzX2VtcHR5IHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoXywgXykgLT5cbiAgICAgIGZhbHNlXG5cbmxldCB1bmNvbnMgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIFNvbWUgKHgsIHhzKVxuICB8IE5pbCAtPlxuICAgICAgTm9uZVxuXG5cblxubGV0IHJlYyBsZW5ndGhfYXV4IGFjY3UgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIGFjY3VcbiAgfCBDb25zIChfLCB4cykgLT5cbiAgICAgIGxlbmd0aF9hdXggKGFjY3UgKyAxKSB4c1xuXG5sZXRbQGlubGluZV0gbGVuZ3RoIHhzID1cbiAgbGVuZ3RoX2F1eCAwIHhzXG5cbmxldCByZWMgaXRlcmlfYXV4IGYgaSB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgKClcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIGYgaSB4O1xuICAgICAgaXRlcmlfYXV4IGYgKGkrMSkgeHNcblxubGV0W0BpbmxpbmVdIGl0ZXJpIGYgeHMgPVxuICBpdGVyaV9hdXggZiAwIHhzXG5cbmxldCByZWMgZm9sZF9sZWZ0aV9hdXggZiBhY2N1IGkgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIGFjY3VcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIGxldCBhY2N1ID0gZiBhY2N1IGkgeCBpblxuICAgICAgZm9sZF9sZWZ0aV9hdXggZiBhY2N1IChpKzEpIHhzXG5cbmxldFtAaW5saW5lXSBmb2xkX2xlZnRpIGYgYWNjdSB4cyA9XG4gIGZvbGRfbGVmdGlfYXV4IGYgYWNjdSAwIHhzXG5cbmxldCByZWMgZm9yX2FsbCBwIHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBwIHggJiYgZm9yX2FsbCBwIHhzXG5cbmxldCByZWMgZXhpc3RzIHAgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIGZhbHNlXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBwIHggfHwgZXhpc3RzIHAgeHNcblxubGV0IHJlYyBmaW5kIHAgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5vbmVcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIGlmIHAgeCB0aGVuIFNvbWUgeCBlbHNlIGZpbmQgcCB4c1xuXG5sZXQgcmVjIGZpbmRfbWFwIGYgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5vbmVcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBmaW5kX21hcCBmIHhzXG4gICAgICB8IFNvbWUgXyBhcyByZXN1bHQgLT5cbiAgICAgICAgICByZXN1bHRcblxuKCogW2l0ZXIyXSwgW2ZvbGRfbGVmdDJdLCBbZm9yX2FsbDJdLCBbZXhpc3RzMl0sIFttYXAyXSwgW3ppcF0gd29yayBhbHNvIGluXG4gICB0aGUgY2FzZSB3aGVyZSB0aGUgdHdvIHNlcXVlbmNlcyBoYXZlIGRpZmZlcmVudCBsZW5ndGhzLiBUaGV5IHN0b3AgYXMgc29vblxuICAgYXMgb25lIHNlcXVlbmNlIGlzIGV4aGF1c3RlZC4gVGhlaXIgYmVoYXZpb3IgaXMgc2xpZ2h0bHkgYXN5bW1ldHJpYzogd2hlblxuICAgW3hzXSBpcyBlbXB0eSwgdGhleSBkbyBub3QgZm9yY2UgW3lzXTsgaG93ZXZlciwgd2hlbiBbeXNdIGlzIGVtcHR5LCBbeHNdIGlzXG4gICBmb3JjZWQsIGV2ZW4gdGhvdWdoIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGFwcGxpY2F0aW9uIFt4cygpXSB0dXJucyBvdXRcbiAgIHRvIGJlIHVzZWxlc3MuICopXG5cbmxldCByZWMgaXRlcjIgZiB4cyB5cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgKClcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIHlzKCkgd2l0aFxuICAgICAgfCBOaWwgLT5cbiAgICAgICAgICAoKVxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBmIHggeTtcbiAgICAgICAgICBpdGVyMiBmIHhzIHlzXG5cbmxldCByZWMgZm9sZF9sZWZ0MiBmIGFjY3UgeHMgeXMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIGFjY3VcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIHlzKCkgd2l0aFxuICAgICAgfCBOaWwgLT5cbiAgICAgICAgICBhY2N1XG4gICAgICB8IENvbnMgKHksIHlzKSAtPlxuICAgICAgICAgIGxldCBhY2N1ID0gZiBhY2N1IHggeSBpblxuICAgICAgICAgIGZvbGRfbGVmdDIgZiBhY2N1IHhzIHlzXG5cbmxldCByZWMgZm9yX2FsbDIgZiB4cyB5cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgdHJ1ZVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgQ29ucyAoeSwgeXMpIC0+XG4gICAgICAgICAgZiB4IHkgJiYgZm9yX2FsbDIgZiB4cyB5c1xuXG5sZXQgcmVjIGV4aXN0czIgZiB4cyB5cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgZmFsc2VcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIHlzKCkgd2l0aFxuICAgICAgfCBOaWwgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBmIHggeSB8fCBleGlzdHMyIGYgeHMgeXNcblxubGV0IHJlYyBlcXVhbCBlcSB4cyB5cyA9XG4gIG1hdGNoIHhzKCksIHlzKCkgd2l0aFxuICB8IE5pbCwgTmlsIC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoeCwgeHMpLCBDb25zICh5LCB5cykgLT5cbiAgICAgIGVxIHggeSAmJiBlcXVhbCBlcSB4cyB5c1xuICB8IE5pbCwgQ29ucyAoXywgXylcbiAgfCBDb25zIChfLCBfKSwgTmlsIC0+XG4gICAgICBmYWxzZVxuXG5sZXQgcmVjIGNvbXBhcmUgY21wIHhzIHlzID1cbiAgbWF0Y2ggeHMoKSwgeXMoKSB3aXRoXG4gIHwgTmlsLCBOaWwgLT5cbiAgICAgIDBcbiAgfCBDb25zICh4LCB4cyksIENvbnMgKHksIHlzKSAtPlxuICAgICAgbGV0IGMgPSBjbXAgeCB5IGluXG4gICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2UgY29tcGFyZSBjbXAgeHMgeXNcbiAgfCBOaWwsIENvbnMgKF8sIF8pIC0+XG4gICAgICAtMVxuICB8IENvbnMgKF8sIF8pLCBOaWwgLT5cbiAgICAgICsxXG5cblxuXG4oKiBbaW5pdF9hdXggZiBpIGpdIGlzIHRoZSBzZXF1ZW5jZSBbZiBpLCAuLi4sIGYgKGotMSldLiAqKVxuXG5sZXQgcmVjIGluaXRfYXV4IGYgaSBqICgpID1cbiAgaWYgaSA8IGogdGhlbiBiZWdpblxuICAgIENvbnMgKGYgaSwgaW5pdF9hdXggZiAoaSArIDEpIGopXG4gIGVuZFxuICBlbHNlXG4gICAgTmlsXG5cbmxldCBpbml0IG4gZiA9XG4gIGlmIG4gPCAwIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlNlcS5pbml0XCJcbiAgZWxzZVxuICAgIGluaXRfYXV4IGYgMCBuXG5cbmxldCByZWMgcmVwZWF0IHggKCkgPVxuICBDb25zICh4LCByZXBlYXQgeClcblxubGV0IHJlYyBmb3JldmVyIGYgKCkgPVxuICBDb25zIChmKCksIGZvcmV2ZXIgZilcblxuKCogVGhpcyBwcmVsaW1pbmFyeSBkZWZpbml0aW9uIG9mIFtjeWNsZV0gcmVxdWlyZXMgdGhlIHNlcXVlbmNlIFt4c11cbiAgIHRvIGJlIG5vbmVtcHR5LiBBcHBseWluZyBpdCB0byBhbiBlbXB0eSBzZXF1ZW5jZSB3b3VsZCBwcm9kdWNlIGFcbiAgIHNlcXVlbmNlIHRoYXQgZGl2ZXJnZXMgd2hlbiBpdCBpcyBmb3JjZWQuICopXG5cbmxldCByZWMgY3ljbGVfbm9uZW1wdHkgeHMgKCkgPVxuICBhcHBlbmQgeHMgKGN5Y2xlX25vbmVtcHR5IHhzKSAoKVxuXG4oKiBbY3ljbGUgeHNdIGNoZWNrcyB3aGV0aGVyIFt4c10gaXMgZW1wdHkgYW5kLCBpZiBzbywgcmV0dXJucyBhbiBlbXB0eVxuICAgc2VxdWVuY2UuIE90aGVyd2lzZSwgW2N5Y2xlIHhzXSBwcm9kdWNlcyBvbmUgY29weSBvZiBbeHNdIGZvbGxvd2VkXG4gICB3aXRoIHRoZSBpbmZpbml0ZSBzZXF1ZW5jZSBbY3ljbGVfbm9uZW1wdHkgeHNdLiBUaHVzLCB0aGUgbm9uZW1wdGluZXNzXG4gICBjaGVjayBpcyBwZXJmb3JtZWQganVzdCBvbmNlLiAqKVxuXG5sZXQgY3ljbGUgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzJykgLT5cbiAgICAgIENvbnMgKHgsIGFwcGVuZCB4cycgKGN5Y2xlX25vbmVtcHR5IHhzKSlcblxuKCogW2l0ZXJhdGUxIGYgeF0gaXMgdGhlIHNlcXVlbmNlIFtmIHgsIGYgKGYgeCksIC4uLl0uXG4gICBJdCBpcyBlcXVpdmFsZW50IHRvIFt0YWlsIChpdGVyYXRlIGYgeCldLlxuICAgW2l0ZXJhdGUxXSBpcyB1c2VkIGFzIGEgYnVpbGRpbmcgYmxvY2sgaW4gdGhlIGRlZmluaXRpb24gb2YgW2l0ZXJhdGVdLiAqKVxuXG5sZXQgcmVjIGl0ZXJhdGUxIGYgeCAoKSA9XG4gIGxldCB5ID0gZiB4IGluXG4gIENvbnMgKHksIGl0ZXJhdGUxIGYgeSlcblxuKCogW2l0ZXJhdGUgZiB4XSBpcyB0aGUgc2VxdWVuY2UgW3gsIGYgeCwgLi4uXS4gKilcblxuKCogVGhlIHJlYXNvbiB3aHkgd2UgZ2l2ZSB0aGlzIHNsaWdodGx5IGluZGlyZWN0IGRlZmluaXRpb24gb2YgW2l0ZXJhdGVdLFxuICAgYXMgb3Bwb3NlZCB0byB0aGUgbW9yZSBuYWl2ZSBkZWZpbml0aW9uIHRoYXQgbWF5IGNvbWUgdG8gbWluZCwgaXMgdGhhdFxuICAgd2UgYXJlIGNhcmVmdWwgdG8gYXZvaWQgZXZhbHVhdGluZyBbZiB4XSB1bnRpbCB0aGlzIGZ1bmN0aW9uIGNhbGwgaXNcbiAgIGFjdHVhbGx5IG5lY2Vzc2FyeS4gVGhlIG5haXZlIGRlZmluaXRpb24gKG5vdCBzaG93biBoZXJlKSBjb21wdXRlcyB0aGVcbiAgIHNlY29uZCBhcmd1bWVudCBvZiB0aGUgc2VxdWVuY2UsIFtmIHhdLCB3aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBpc1xuICAgcmVxdWVzdGVkIGJ5IHRoZSB1c2VyLiAqKVxuXG5sZXQgaXRlcmF0ZSBmIHggPVxuICBjb25zIHggKGl0ZXJhdGUxIGYgeClcblxuXG5cbmxldCByZWMgbWFwaV9hdXggZiBpIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIENvbnMgKGYgaSB4LCBtYXBpX2F1eCBmIChpKzEpIHhzKVxuXG5sZXRbQGlubGluZV0gbWFwaSBmIHhzID1cbiAgbWFwaV9hdXggZiAwIHhzXG5cbigqIFt0YWlsX3NjYW4gZiBzIHhzXSBpcyBlcXVpdmFsZW50IHRvIFt0YWlsIChzY2FuIGYgcyB4cyldLlxuICAgW3RhaWxfc2Nhbl0gaXMgdXNlZCBhcyBhIGJ1aWxkaW5nIGJsb2NrIGluIHRoZSBkZWZpbml0aW9uIG9mIFtzY2FuXS4gKilcblxuKCogVGhpcyBzbGlnaHRseSBpbmRpcmVjdCBkZWZpbml0aW9uIG9mIFtzY2FuXSBpcyBtZWFudCB0byBhdm9pZCBjb21wdXRpbmdcbiAgIGVsZW1lbnRzIHRvbyBlYXJseTsgc2VlIHRoZSBhYm92ZSBjb21tZW50IGFib3V0IFtpdGVyYXRlMV0gYW5kIFtpdGVyYXRlXS4gKilcblxubGV0IHJlYyB0YWlsX3NjYW4gZiBzIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIGxldCBzID0gZiBzIHggaW5cbiAgICAgIENvbnMgKHMsIHRhaWxfc2NhbiBmIHMgeHMpXG5cbmxldCBzY2FuIGYgcyB4cyA9XG4gIGNvbnMgcyAodGFpbF9zY2FuIGYgcyB4cylcblxuKCogW3Rha2VdIGlzIGRlZmluZWQgaW4gc3VjaCBhIHdheSB0aGF0IFt0YWtlIDAgeHNdIHJldHVybnMgW2VtcHR5XVxuICAgaW1tZWRpYXRlbHksIHdpdGhvdXQgYWxsb2NhdGluZyBhbnkgbWVtb3J5LiAqKVxuXG5sZXQgcmVjIHRha2VfYXV4IG4geHMgPVxuICBpZiBuID0gMCB0aGVuXG4gICAgZW1wdHlcbiAgZWxzZVxuICAgIGZ1biAoKSAtPlxuICAgICAgbWF0Y2ggeHMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIE5pbFxuICAgICAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgICAgICBDb25zICh4LCB0YWtlX2F1eCAobi0xKSB4cylcblxubGV0IHRha2UgbiB4cyA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJTZXEudGFrZVwiO1xuICB0YWtlX2F1eCBuIHhzXG5cbigqIFtmb3JjZV9kcm9wIG4geHNdIGlzIGVxdWl2YWxlbnQgdG8gW2Ryb3AgbiB4cyAoKV0uXG4gICBbZm9yY2VfZHJvcCBuIHhzXSByZXF1aXJlcyBbbiA+IDBdLlxuICAgW2ZvcmNlX2Ryb3BdIGlzIHVzZWQgYXMgYSBidWlsZGluZyBibG9jayBpbiB0aGUgZGVmaW5pdGlvbiBvZiBbZHJvcF0uICopXG5cbmxldCByZWMgZm9yY2VfZHJvcCBuIHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zIChfLCB4cykgLT5cbiAgICAgIGxldCBuID0gbiAtIDEgaW5cbiAgICAgIGlmIG4gPSAwIHRoZW5cbiAgICAgICAgeHMoKVxuICAgICAgZWxzZVxuICAgICAgICBmb3JjZV9kcm9wIG4geHNcblxuKCogW2Ryb3BdIGlzIGRlZmluZWQgaW4gc3VjaCBhIHdheSB0aGF0IFtkcm9wIDAgeHNdIHJldHVybnMgW3hzXSBpbW1lZGlhdGVseSxcbiAgIHdpdGhvdXQgYWxsb2NhdGluZyBhbnkgbWVtb3J5LiAqKVxuXG5sZXQgZHJvcCBuIHhzID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlNlcS5kcm9wXCJcbiAgZWxzZSBpZiBuID0gMCB0aGVuXG4gICAgeHNcbiAgZWxzZVxuICAgIGZ1biAoKSAtPlxuICAgICAgZm9yY2VfZHJvcCBuIHhzXG5cbmxldCByZWMgdGFrZV93aGlsZSBwIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIGlmIHAgeCB0aGVuIENvbnMgKHgsIHRha2Vfd2hpbGUgcCB4cykgZWxzZSBOaWxcblxubGV0IHJlYyBkcm9wX3doaWxlIHAgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSBhcyBub2RlIC0+XG4gICAgICBpZiBwIHggdGhlbiBkcm9wX3doaWxlIHAgeHMgKCkgZWxzZSBub2RlXG5cbmxldCByZWMgZ3JvdXAgZXEgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgQ29ucyAoY29ucyB4ICh0YWtlX3doaWxlIChlcSB4KSB4cyksIGdyb3VwIGVxIChkcm9wX3doaWxlIChlcSB4KSB4cykpXG5cbmV4Y2VwdGlvbiBGb3JjZWRfdHdpY2VcblxubW9kdWxlIFN1c3BlbnNpb24gPSBzdHJ1Y3RcblxuICB0eXBlICdhIHN1c3BlbnNpb24gPVxuICAgIHVuaXQgLT4gJ2FcblxuICAoKiBDb252ZXJzaW9ucy4gKilcblxuICBsZXQgdG9fbGF6eSA6ICdhIHN1c3BlbnNpb24gLT4gJ2EgTGF6eS50ID1cbiAgICBMYXp5LmZyb21fZnVuXG4gICAgKCogZnVuIHMgLT4gbGF6eSAocygpKSAqKVxuXG4gIGxldCBmcm9tX2xhenkgKHMgOiAnYSBMYXp5LnQpIDogJ2Egc3VzcGVuc2lvbiA9XG4gICAgZnVuICgpIC0+IExhenkuZm9yY2Ugc1xuXG4gICgqIFttZW1vaXplXSB0dXJucyBhbiBhcmJpdHJhcnkgc3VzcGVuc2lvbiBpbnRvIGEgcGVyc2lzdGVudCBzdXNwZW5zaW9uLiAqKVxuXG4gIGxldCBtZW1vaXplIChzIDogJ2Egc3VzcGVuc2lvbikgOiAnYSBzdXNwZW5zaW9uID1cbiAgICBmcm9tX2xhenkgKHRvX2xhenkgcylcblxuICAoKiBbZmFpbHVyZV0gaXMgYSBzdXNwZW5zaW9uIHRoYXQgZmFpbHMgd2hlbiBmb3JjZWQuICopXG5cbiAgbGV0IGZhaWx1cmUgOiBfIHN1c3BlbnNpb24gPVxuICAgIGZ1biAoKSAtPlxuICAgICAgKCogQSBzdXNwZW5zaW9uIGNyZWF0ZWQgYnkgW29uY2VdIGhhcyBiZWVuIGZvcmNlZCB0d2ljZS4gKilcbiAgICAgIHJhaXNlIEZvcmNlZF90d2ljZVxuXG4gICgqIElmIFtmXSBpcyBhIHN1c3BlbnNpb24sIHRoZW4gW29uY2UgZl0gaXMgYSBzdXNwZW5zaW9uIHRoYXQgY2FuIGJlIGZvcmNlZFxuICAgICBhdCBtb3N0IG9uY2UuIElmIGl0IGlzIGZvcmNlZCBtb3JlIHRoYW4gb25jZSwgdGhlbiBbRm9yY2VkX3R3aWNlXSBpc1xuICAgICByYWlzZWQuICopXG5cbiAgbGV0IG9uY2UgKGYgOiAnYSBzdXNwZW5zaW9uKSA6ICdhIHN1c3BlbnNpb24gPVxuICAgIGxldCBhY3Rpb24gPSBDYW1saW50ZXJuYWxBdG9taWMubWFrZSBmIGluXG4gICAgZnVuICgpIC0+XG4gICAgICAoKiBHZXQgdGhlIGZ1bmN0aW9uIGN1cnJlbnRseSBzdG9yZWQgaW4gW2FjdGlvbl0sIGFuZCB3cml0ZSB0aGVcbiAgICAgICAgIGZ1bmN0aW9uIFtmYWlsdXJlXSBpbiBpdHMgcGxhY2UsIHNvIHRoZSBuZXh0IGFjY2VzcyB3aWxsIHJlc3VsdFxuICAgICAgICAgaW4gYSBjYWxsIHRvIFtmYWlsdXJlKCldLiAqKVxuICAgICAgbGV0IGYgPSBDYW1saW50ZXJuYWxBdG9taWMuZXhjaGFuZ2UgYWN0aW9uIGZhaWx1cmUgaW5cbiAgICAgIGYoKVxuXG5lbmQgKCogU3VzcGVuc2lvbiAqKVxuXG5sZXQgcmVjIG1lbW9pemUgeHMgPVxuICBTdXNwZW5zaW9uLm1lbW9pemUgKGZ1biAoKSAtPlxuICAgIG1hdGNoIHhzKCkgd2l0aFxuICAgIHwgTmlsIC0+XG4gICAgICAgIE5pbFxuICAgIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICAgIENvbnMgKHgsIG1lbW9pemUgeHMpXG4gIClcblxubGV0IHJlYyBvbmNlIHhzID1cbiAgU3VzcGVuc2lvbi5vbmNlIChmdW4gKCkgLT5cbiAgICBtYXRjaCB4cygpIHdpdGhcbiAgICB8IE5pbCAtPlxuICAgICAgICBOaWxcbiAgICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgICBDb25zICh4LCBvbmNlIHhzKVxuICApXG5cblxubGV0IHJlYyB6aXAgeHMgeXMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIE5pbFxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBDb25zICgoeCwgeSksIHppcCB4cyB5cylcblxubGV0IHJlYyBtYXAyIGYgeHMgeXMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIE5pbFxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBDb25zIChmIHggeSwgbWFwMiBmIHhzIHlzKVxuXG5sZXQgcmVjIGludGVybGVhdmUgeHMgeXMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIHlzKClcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIENvbnMgKHgsIGludGVybGVhdmUgeXMgeHMpXG5cbigqIFtzb3J0ZWRfbWVyZ2UxbCBjbXAgeCB4cyB5c10gaXMgZXF1aXZhbGVudCB0b1xuICAgICBbc29ydGVkX21lcmdlIGNtcCAoY29ucyB4IHhzKSB5c10uXG5cbiAgIFtzb3J0ZWRfbWVyZ2UxciBjbXAgeHMgeSB5c10gaXMgZXF1aXZhbGVudCB0b1xuICAgICBbc29ydGVkX21lcmdlIGNtcCB4cyAoY29ucyB5IHlzKV0uXG5cbiAgIFtzb3J0ZWRfbWVyZ2UxIGNtcCB4IHhzIHkgeXNdIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgW3NvcnRlZF9tZXJnZSBjbXAgKGNvbnMgeCB4cykgKGNvbnMgeSB5cyldLlxuXG4gICBUaGVzZSB0aHJlZSBmdW5jdGlvbnMgYXJlIHVzZWQgYXMgYnVpbGRpbmcgYmxvY2tzIGluIHRoZSBkZWZpbml0aW9uXG4gICBvZiBbc29ydGVkX21lcmdlXS4gKilcblxubGV0IHJlYyBzb3J0ZWRfbWVyZ2UxbCBjbXAgeCB4cyB5cyAoKSA9XG4gIG1hdGNoIHlzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgQ29ucyAoeCwgeHMpXG4gIHwgQ29ucyAoeSwgeXMpIC0+XG4gICAgICBzb3J0ZWRfbWVyZ2UxIGNtcCB4IHhzIHkgeXNcblxuYW5kIHNvcnRlZF9tZXJnZTFyIGNtcCB4cyB5IHlzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBDb25zICh5LCB5cylcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIHNvcnRlZF9tZXJnZTEgY21wIHggeHMgeSB5c1xuXG5hbmQgc29ydGVkX21lcmdlMSBjbXAgeCB4cyB5IHlzID1cbiAgaWYgY21wIHggeSA8PSAwIHRoZW5cbiAgICBDb25zICh4LCBzb3J0ZWRfbWVyZ2UxciBjbXAgeHMgeSB5cylcbiAgZWxzZVxuICAgIENvbnMgKHksIHNvcnRlZF9tZXJnZTFsIGNtcCB4IHhzIHlzKVxuXG5sZXQgc29ydGVkX21lcmdlIGNtcCB4cyB5cyAoKSA9XG4gIG1hdGNoIHhzKCksIHlzKCkgd2l0aFxuICAgIHwgTmlsLCBOaWwgLT5cbiAgICAgICAgTmlsXG4gICAgfCBOaWwsIGNcbiAgICB8IGMsIE5pbCAtPlxuICAgICAgICBjXG4gICAgfCBDb25zICh4LCB4cyksIENvbnMgKHksIHlzKSAtPlxuICAgICAgICBzb3J0ZWRfbWVyZ2UxIGNtcCB4IHhzIHkgeXNcblxuXG5sZXQgcmVjIG1hcF9mc3QgeHlzICgpID1cbiAgbWF0Y2ggeHlzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoKHgsIF8pLCB4eXMpIC0+XG4gICAgICBDb25zICh4LCBtYXBfZnN0IHh5cylcblxubGV0IHJlYyBtYXBfc25kIHh5cyAoKSA9XG4gIG1hdGNoIHh5cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKChfLCB5KSwgeHlzKSAtPlxuICAgICAgQ29ucyAoeSwgbWFwX3NuZCB4eXMpXG5cbmxldCB1bnppcCB4eXMgPVxuICBtYXBfZnN0IHh5cywgbWFwX3NuZCB4eXNcblxubGV0IHNwbGl0ID1cbiAgdW56aXBcblxuKCogW2ZpbHRlcl9tYXBfZmluZF9sZWZ0X21hcCBmIHhzXSBpcyBlcXVpdmFsZW50IHRvXG4gICBbZmlsdGVyX21hcCBFaXRoZXIuZmluZF9sZWZ0IChtYXAgZiB4cyldLiAqKVxuXG5sZXQgcmVjIGZpbHRlcl9tYXBfZmluZF9sZWZ0X21hcCBmIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICB8IEVpdGhlci5MZWZ0IHkgLT5cbiAgICAgICAgICBDb25zICh5LCBmaWx0ZXJfbWFwX2ZpbmRfbGVmdF9tYXAgZiB4cylcbiAgICAgIHwgRWl0aGVyLlJpZ2h0IF8gLT5cbiAgICAgICAgICBmaWx0ZXJfbWFwX2ZpbmRfbGVmdF9tYXAgZiB4cyAoKVxuXG5sZXQgcmVjIGZpbHRlcl9tYXBfZmluZF9yaWdodF9tYXAgZiB4cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgfCBFaXRoZXIuTGVmdCBfIC0+XG4gICAgICAgICAgZmlsdGVyX21hcF9maW5kX3JpZ2h0X21hcCBmIHhzICgpXG4gICAgICB8IEVpdGhlci5SaWdodCB6IC0+XG4gICAgICAgICAgQ29ucyAoeiwgZmlsdGVyX21hcF9maW5kX3JpZ2h0X21hcCBmIHhzKVxuXG5sZXQgcGFydGl0aW9uX21hcCBmIHhzID1cbiAgZmlsdGVyX21hcF9maW5kX2xlZnRfbWFwIGYgeHMsXG4gIGZpbHRlcl9tYXBfZmluZF9yaWdodF9tYXAgZiB4c1xuXG5sZXQgcGFydGl0aW9uIHAgeHMgPVxuICBmaWx0ZXIgcCB4cywgZmlsdGVyIChmdW4geCAtPiBub3QgKHAgeCkpIHhzXG5cbigqIElmIFt4c3NdIGlzIGEgbWF0cml4IChhIHNlcXVlbmNlIG9mIHJvd3MpLCB0aGVuIFtwZWVsIHhzc10gaXMgYSBwYWlyIG9mXG4gICB0aGUgZmlyc3QgY29sdW1uIChhIHNlcXVlbmNlIG9mIGVsZW1lbnRzKSBhbmQgb2YgdGhlIHJlbWFpbmRlciBvZiB0aGVcbiAgIG1hdHJpeCAoYSBzZXF1ZW5jZSBvZiBzaG9ydGVyIHJvd3MpLiBUaGVzZSB0d28gc2VxdWVuY2VzIGhhdmUgdGhlIHNhbWVcbiAgIGxlbmd0aC4gVGhlIHJvd3Mgb2YgdGhlIG1hdHJpeCBbeHNzXSBhcmUgbm90IHJlcXVpcmVkIHRvIGhhdmUgdGhlIHNhbWVcbiAgIGxlbmd0aC4gQW4gZW1wdHkgcm93IGlzIGlnbm9yZWQuICopXG5cbigqIEJlY2F1c2UgW3BlZWxdIHVzZXMgW3VuemlwXSwgaXRzIGFyZ3VtZW50IG11c3QgYmUgcGVyc2lzdGVudC4gVGhlIHNhbWVcbiAgIHJlbWFyayBhcHBsaWVzIHRvIFt0cmFuc3Bvc2VdLCBbZGlhZ29uYWxzXSwgW3Byb2R1Y3RdLCBldGMuICopXG5cbmxldCBwZWVsIHhzcyA9XG4gIHVuemlwIChmaWx0ZXJfbWFwIHVuY29ucyB4c3MpXG5cbmxldCByZWMgdHJhbnNwb3NlIHhzcyAoKSA9XG4gIGxldCBoZWFkcywgdGFpbHMgPSBwZWVsIHhzcyBpblxuICBpZiBpc19lbXB0eSBoZWFkcyB0aGVuIGJlZ2luXG4gICAgYXNzZXJ0IChpc19lbXB0eSB0YWlscyk7XG4gICAgTmlsXG4gIGVuZFxuICBlbHNlXG4gICAgQ29ucyAoaGVhZHMsIHRyYW5zcG9zZSB0YWlscylcblxuKCogVGhlIGludGVybmFsIGZ1bmN0aW9uIFtkaWFnb25hbHNdIHRha2VzIGFuIGV4dHJhIGFyZ3VtZW50LCBbcmVtYWluZGVyc10sXG4gICB3aGljaCBjb250YWlucyB0aGUgcmVtYWluZGVycyBvZiB0aGUgcm93cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuXG4gICBkaXNjb3ZlcmVkLiAqKVxuXG5sZXQgcmVjIGRpYWdvbmFscyByZW1haW5kZXJzIHhzcyAoKSA9XG4gIG1hdGNoIHhzcygpIHdpdGhcbiAgfCBDb25zICh4cywgeHNzKSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggeHMoKSB3aXRoXG4gICAgICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgICAgICgqIFdlIGRpc2NvdmVyIGEgbmV3IG5vbmVtcHR5IHJvdyBbeCA6OiB4c10uIFRodXMsIHRoZSBuZXh0IGRpYWdvbmFsXG4gICAgICAgICAgICAgaXMgW3ggOjogaGVhZHNdOiB0aGlzIGRpYWdvbmFsIGJlZ2lucyB3aXRoIFt4XSBhbmQgY29udGludWVzIHdpdGhcbiAgICAgICAgICAgICB0aGUgZmlyc3QgZWxlbWVudCBvZiBldmVyeSByb3cgaW4gW3JlbWFpbmRlcnNdLiBJbiB0aGUgcmVjdXJzaXZlXG4gICAgICAgICAgICAgY2FsbCwgdGhlIGFyZ3VtZW50IFtyZW1haW5kZXJzXSBpcyBpbnN0YW50aWF0ZWQgd2l0aCBbeHMgOjpcbiAgICAgICAgICAgICB0YWlsc10sIHdoaWNoIG1lYW5zIHRoYXQgd2UgaGF2ZSBvbmUgbW9yZSByZW1haW5pbmcgcm93LCBbeHNdLFxuICAgICAgICAgICAgIGFuZCB0aGF0IHdlIGtlZXAgdGhlIHRhaWxzIG9mIHRoZSBwcmUtZXhpc3RpbmcgcmVtYWluaW5nIHJvd3MuICopXG4gICAgICAgICAgbGV0IGhlYWRzLCB0YWlscyA9IHBlZWwgcmVtYWluZGVycyBpblxuICAgICAgICAgIENvbnMgKGNvbnMgeCBoZWFkcywgZGlhZ29uYWxzIChjb25zIHhzIHRhaWxzKSB4c3MpXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgICgqIFdlIGRpc2NvdmVyIGEgbmV3IGVtcHR5IHJvdy4gSW4gdGhpcyBjYXNlLCB0aGUgbmV3IGRpYWdvbmFsIGlzXG4gICAgICAgICAgICAganVzdCBbaGVhZHNdLCBhbmQgW3JlbWFpbmRlcnNdIGlzIGluc3RhbnRpYXRlZCB3aXRoIGp1c3QgW3RhaWxzXSxcbiAgICAgICAgICAgICBhcyB3ZSBkbyBub3QgaGF2ZSBvbmUgbW9yZSByZW1haW5pbmcgcm93LiAqKVxuICAgICAgICAgIGxldCBoZWFkcywgdGFpbHMgPSBwZWVsIHJlbWFpbmRlcnMgaW5cbiAgICAgICAgICBDb25zIChoZWFkcywgZGlhZ29uYWxzIHRhaWxzIHhzcylcbiAgICAgIGVuZFxuICB8IE5pbCAtPlxuICAgICAgKCogVGhlcmUgYXJlIG5vIG1vcmUgcm93cyB0byBiZSBkaXNjb3ZlcmVkLiBUaGVyZSByZW1haW5zIHRvIGV4aGF1c3RcbiAgICAgICAgIHRoZSByZW1haW5pbmcgcm93cy4gKilcbiAgICAgIHRyYW5zcG9zZSByZW1haW5kZXJzICgpXG5cbigqIElmIFt4c3NdIGlzIGEgbWF0cml4IChhIHNlcXVlbmNlIG9mIHJvd3MpLCB0aGVuIFtkaWFnb25hbHMgeHNzXSBpc1xuICAgdGhlIHNlcXVlbmNlIG9mIGl0cyBkaWFnb25hbHMuXG5cbiAgIFRoZSBmaXJzdCBkaWFnb25hbCBjb250YWlucyBqdXN0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZVxuICAgZmlyc3Qgcm93LiBUaGUgc2Vjb25kIGRpYWdvbmFsIGNvbnRhaW5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZVxuICAgc2Vjb25kIHJvdyBhbmQgdGhlIHNlY29uZCBlbGVtZW50IG9mIHRoZSBmaXJzdCByb3c7IGFuZCBzbyBvbi5cbiAgIFRoaXMga2luZCBvZiBkaWFnb25hbCBpcyBpbiBmYWN0IHNvbWV0aW1lcyBrbm93biBhcyBhbiBhbnRpZGlhZ29uYWwuXG5cbiAgIC0gRXZlcnkgZGlhZ29uYWwgaXMgYSBmaW5pdGUgc2VxdWVuY2UuXG4gICAtIFRoZSByb3dzIG9mIHRoZSBtYXRyaXggW3hzc10gYXJlIG5vdCByZXF1aXJlZCB0byBoYXZlIHRoZSBzYW1lIGxlbmd0aC5cbiAgIC0gVGhlIG1hdHJpeCBbeHNzXSBpcyBub3QgcmVxdWlyZWQgdG8gYmUgZmluaXRlIChpbiBlaXRoZXIgZGlyZWN0aW9uKS5cbiAgIC0gVGhlIG1hdHJpeCBbeHNzXSBtdXN0IGJlIHBlcnNpc3RlbnQuICopXG5cbmxldCBkaWFnb25hbHMgeHNzID1cbiAgZGlhZ29uYWxzIGVtcHR5IHhzc1xuXG5sZXQgbWFwX3Byb2R1Y3QgZiB4cyB5cyA9XG4gIGNvbmNhdCAoZGlhZ29uYWxzIChcbiAgICBtYXAgKGZ1biB4IC0+XG4gICAgICBtYXAgKGZ1biB5IC0+XG4gICAgICAgIGYgeCB5XG4gICAgICApIHlzXG4gICAgKSB4c1xuICApKVxuXG5sZXQgcHJvZHVjdCB4cyB5cyA9XG4gIG1hcF9wcm9kdWN0IChmdW4geCB5IC0+ICh4LCB5KSkgeHMgeXNcblxubGV0IG9mX2Rpc3BlbnNlciBpdCA9XG4gIGxldCByZWMgYyAoKSA9XG4gICAgbWF0Y2ggaXQoKSB3aXRoXG4gICAgfCBOb25lIC0+XG4gICAgICAgIE5pbFxuICAgIHwgU29tZSB4IC0+XG4gICAgICAgIENvbnMgKHgsIGMpXG4gIGluXG4gIGNcblxubGV0IHRvX2Rpc3BlbnNlciB4cyA9XG4gIGxldCBzID0gcmVmIHhzIGluXG4gIGZ1biAoKSAtPlxuICAgIG1hdGNoICghcykoKSB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgICAgTm9uZVxuICAgIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICAgIHMgOj0geHM7XG4gICAgICAgIFNvbWUgeFxuXG5cblxubGV0IHJlYyBpbnRzIGkgKCkgPVxuICBDb25zIChpLCBpbnRzIChpICsgMSkpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENoYXJhY3RlciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGNvZGU6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdW5zYWZlX2NocjogaW50IC0+IGNoYXIgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBjaHIgbiA9XG4gIGlmIG4gPCAwIHx8IG4gPiAyNTUgdGhlbiBpbnZhbGlkX2FyZyBcIkNoYXIuY2hyXCIgZWxzZSB1bnNhZmVfY2hyIG5cblxuZXh0ZXJuYWwgYnl0ZXNfY3JlYXRlOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIGJ5dGVzX3Vuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5cbmxldCBlc2NhcGVkID0gZnVuY3Rpb25cbiAgfCAnXFwnJyAtPiBcIlxcXFwnXCJcbiAgfCAnXFxcXCcgLT4gXCJcXFxcXFxcXFwiXG4gIHwgJ1xcbicgLT4gXCJcXFxcblwiXG4gIHwgJ1xcdCcgLT4gXCJcXFxcdFwiXG4gIHwgJ1xccicgLT4gXCJcXFxcclwiXG4gIHwgJ1xcYicgLT4gXCJcXFxcYlwiXG4gIHwgJyAnIC4uICd+JyBhcyBjIC0+XG4gICAgICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSAxIGluXG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMCBjO1xuICAgICAgdW5zYWZlX3RvX3N0cmluZyBzXG4gIHwgYyAtPlxuICAgICAgbGV0IG4gPSBjb2RlIGMgaW5cbiAgICAgIGxldCBzID0gYnl0ZXNfY3JlYXRlIDQgaW5cbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAwICdcXFxcJztcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAxICh1bnNhZmVfY2hyICg0OCArIG4gLyAxMDApKTtcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAyICh1bnNhZmVfY2hyICg0OCArIChuIC8gMTApIG1vZCAxMCkpO1xuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDMgKHVuc2FmZV9jaHIgKDQ4ICsgbiBtb2QgMTApKTtcbiAgICAgIHVuc2FmZV90b19zdHJpbmcgc1xuXG5sZXQgbG93ZXJjYXNlID0gZnVuY3Rpb25cbiAgfCAnQScgLi4gJ1onXG4gIHwgJ1xcMTkyJyAuLiAnXFwyMTQnXG4gIHwgJ1xcMjE2JyAuLiAnXFwyMjInIGFzIGMgLT5cbiAgICB1bnNhZmVfY2hyKGNvZGUgYyArIDMyKVxuICB8IGMgLT4gY1xuXG5sZXQgdXBwZXJjYXNlID0gZnVuY3Rpb25cbiAgfCAnYScgLi4gJ3onXG4gIHwgJ1xcMjI0JyAuLiAnXFwyNDYnXG4gIHwgJ1xcMjQ4JyAuLiAnXFwyNTQnIGFzIGMgLT5cbiAgICB1bnNhZmVfY2hyKGNvZGUgYyAtIDMyKVxuICB8IGMgLT4gY1xuXG5sZXQgbG93ZXJjYXNlX2FzY2lpID0gZnVuY3Rpb25cbiAgfCAnQScgLi4gJ1onIGFzIGMgLT4gdW5zYWZlX2Nocihjb2RlIGMgKyAzMilcbiAgfCBjIC0+IGNcblxubGV0IHVwcGVyY2FzZV9hc2NpaSA9IGZ1bmN0aW9uXG4gIHwgJ2EnIC4uICd6JyBhcyBjIC0+IHVuc2FmZV9jaHIoY29kZSBjIC0gMzIpXG4gIHwgYyAtPiBjXG5cbnR5cGUgdCA9IGNoYXJcblxubGV0IGNvbXBhcmUgYzEgYzIgPSBjb2RlIGMxIC0gY29kZSBjMlxubGV0IGVxdWFsIChjMTogdCkgKGMyOiB0KSA9IGNvbXBhcmUgYzEgYzIgPSAwXG4iLCIoKiBUeVhNTFxuICogaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy90eXhtbFxuICogQ29weXJpZ2h0IChDKSAyMDEzIEdhYnJpZWwgUmFkYW5uZSA8ZHJ1cHlvZytjYW1sQHpvaG8uY29tPlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4gKiBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICogR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICogRm91bmRhdGlvbiwgSW5jLiwgNTEgRnJhbmtsaW4gU3RyZWV0LCBTdWl0ZSA1MDAsIEJvc3RvbiwgTUEgMDIxMTAtMTMwMSwgVVNBLlxuKilcblxubW9kdWxlIHR5cGUgVCA9IHNpZ1xuICB0eXBlICdhIHRcbiAgdmFsIHJldHVybiA6ICdhIC0+ICdhIHRcblxuICB0eXBlICgtJ2EsICdiKSBmdFxuICB2YWwgZm1hcCA6ICgnYSwgJ2IpIGZ0IC0+ICdhIHQgLT4gJ2IgdFxuXG4gIHR5cGUgJ2EgdGxpc3RcbiAgdmFsIG5pbCA6IHVuaXQgLT4gJ2EgdGxpc3RcbiAgdmFsIHNpbmdsZXRvbiA6ICdhIHQgLT4gJ2EgdGxpc3RcbiAgdmFsIGNvbnMgOiAnYSB0IC0+ICdhIHRsaXN0IC0+ICdhIHRsaXN0XG4gIHZhbCBhcHBlbmQgOiAnYSB0bGlzdCAtPiAnYSB0bGlzdCAtPiAnYSB0bGlzdFxuICB2YWwgbWFwIDogKCdhLCAnYikgZnQgLT4gJ2EgdGxpc3QgLT4gJ2IgdGxpc3RcbmVuZFxuXG5tb2R1bGUgdHlwZSBOb1dyYXAgPVxuICBUIHdpdGggdHlwZSAnYSB0ID0gJ2FcbiAgICAgYW5kIHR5cGUgJ2EgdGxpc3QgPSAnYSBsaXN0XG4gICAgIGFuZCB0eXBlICgtJ2EsICdiKSBmdCA9ICdhIC0+ICdiXG5cbm1vZHVsZSBOb1dyYXAgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2FcbiAgdHlwZSAnYSB0bGlzdCA9ICdhIGxpc3RcbiAgdHlwZSAoLSdhLCAnYikgZnQgPSAnYSAtPiAnYlxuICBleHRlcm5hbCByZXR1cm4gOiAnYSAtPiAnYSA9IFwiJWlkZW50aXR5XCJcbiAgbGV0IGZtYXAgZiA6ICAnYSB0IC0+ICdiIHQgPSBmXG5cbiAgbGV0IG5pbCAoKSA9IFtdXG4gIGxldCBzaW5nbGV0b24geCA9IFt4XVxuICBsZXQgY29ucyB4IHhzID0geDo6eHNcbiAgbGV0IGFwcGVuZCB4IHk9IHhAeVxuICBsZXQgbWFwID0gTGlzdC5tYXBcbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHQgPSBpbnRcblxubGV0IHplcm8gPSAwXG5sZXQgb25lID0gMVxubGV0IG1pbnVzX29uZSA9IC0xXG5leHRlcm5hbCBuZWcgOiBpbnQgLT4gaW50ID0gXCIlbmVnaW50XCJcbmV4dGVybmFsIGFkZCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYWRkaW50XCJcbmV4dGVybmFsIHN1YiA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbmV4dGVybmFsIG11bCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbXVsaW50XCJcbmV4dGVybmFsIGRpdiA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlZGl2aW50XCJcbmV4dGVybmFsIHJlbSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbW9kaW50XCJcbmV4dGVybmFsIHN1Y2MgOiBpbnQgLT4gaW50ID0gXCIlc3VjY2ludFwiXG5leHRlcm5hbCBwcmVkIDogaW50IC0+IGludCA9IFwiJXByZWRpbnRcIlxubGV0IGFicyB4ID0gaWYgeCA+PSAwIHRoZW4geCBlbHNlIC14XG5sZXQgbWF4X2ludCA9ICgtMSkgbHNyIDFcbmxldCBtaW5faW50ID0gbWF4X2ludCArIDFcbmV4dGVybmFsIGxvZ2FuZCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYW5kaW50XCJcbmV4dGVybmFsIGxvZ29yIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVvcmludFwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXhvcmludFwiXG5sZXQgbG9nbm90IHggPSBsb2d4b3IgeCAoLTEpXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc2xpbnRcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFzcmludFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxubGV0IGVxdWFsIDogaW50IC0+IGludCAtPiBib29sID0gKCA9IClcbmxldCBjb21wYXJlIDogaW50IC0+IGludCAtPiBpbnQgPSBTdGRsaWIuY29tcGFyZVxubGV0IG1pbiB4IHkgOiB0ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmxldCBtYXggeCB5IDogdCA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5leHRlcm5hbCB0b19mbG9hdCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcblxuKCpcbmV4dGVybmFsIGludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50ID0gXCJjYW1sX2ludF9vZl9zdHJpbmdcIlxubGV0IG9mX3N0cmluZyBzID0gdHJ5IFNvbWUgKGludF9vZl9zdHJpbmcgcykgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuKilcblxuZXh0ZXJuYWwgZm9ybWF0X2ludCA6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxubGV0IHRvX3N0cmluZyB4ID0gZm9ybWF0X2ludCBcIiVkXCIgeFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBCeXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgKilcblxuKCogV0FSTklORzogU29tZSBmdW5jdGlvbnMgaW4gdGhpcyBmaWxlIGFyZSBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCBmb3JcbiAgIGVmZmljaWVuY3kgcmVhc29ucy4gV2hlbiB5b3UgbW9kaWZ5IHRoZSBvbmUgaW4gdGhpcyBmaWxlIHlvdSBuZWVkIHRvXG4gICBtb2RpZnkgaXRzIGR1cGxpY2F0ZSBpbiBzdHJpbmcubWwuXG4gICBUaGVzZSBmdW5jdGlvbnMgaGF2ZSBhIFwiZHVwbGljYXRlZFwiIGNvbW1lbnQgYWJvdmUgdGhlaXIgZGVmaW5pdGlvbi5cbiopXG5cbmV4dGVybmFsIGxlbmd0aCA6IGJ5dGVzIC0+IGludCA9IFwiJWJ5dGVzX2xlbmd0aFwiXG5leHRlcm5hbCBzdHJpbmdfbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgPSBcIiVieXRlc19zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCB1bnNhZmVfZ2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgPSBcIiVieXRlc191bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfZmlsbCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9maWxsX2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHVuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuZXh0ZXJuYWwgdW5zYWZlX29mX3N0cmluZyA6IHN0cmluZyAtPiBieXRlcyA9IFwiJWJ5dGVzX29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIHVuc2FmZV9ibGl0IDogYnl0ZXMgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9ieXRlc1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB1bnNhZmVfYmxpdF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuXG5sZXQgbWFrZSBuIGMgPVxuICBsZXQgcyA9IGNyZWF0ZSBuIGluXG4gIHVuc2FmZV9maWxsIHMgMCBuIGM7XG4gIHNcblxubGV0IGluaXQgbiBmID1cbiAgbGV0IHMgPSBjcmVhdGUgbiBpblxuICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICB1bnNhZmVfc2V0IHMgaSAoZiBpKVxuICBkb25lO1xuICBzXG5cbmxldCBlbXB0eSA9IGNyZWF0ZSAwXG5cbmxldCBjb3B5IHMgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gIHVuc2FmZV9ibGl0IHMgMCByIDAgbGVuO1xuICByXG5cbmxldCB0b19zdHJpbmcgYiA9IHVuc2FmZV90b19zdHJpbmcgKGNvcHkgYilcbmxldCBvZl9zdHJpbmcgcyA9IGNvcHkgKHVuc2FmZV9vZl9zdHJpbmcgcylcblxubGV0IHN1YiBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5zdWIgLyBCeXRlcy5zdWJcIlxuICBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gICAgdW5zYWZlX2JsaXQgcyBvZnMgciAwIGxlbjtcbiAgICByXG4gIGVuZFxuXG5sZXQgc3ViX3N0cmluZyBiIG9mcyBsZW4gPSB1bnNhZmVfdG9fc3RyaW5nIChzdWIgYiBvZnMgbGVuKVxuXG4oKiBhZGRpdGlvbiB3aXRoIGFuIG92ZXJmbG93IGNoZWNrICopXG5sZXQgKCsrKSBhIGIgPVxuICBsZXQgYyA9IGEgKyBiIGluXG4gIG1hdGNoIGEgPCAwLCBiIDwgMCwgYyA8IDAgd2l0aFxuICB8IHRydWUgLCB0cnVlICwgZmFsc2VcbiAgfCBmYWxzZSwgZmFsc2UsIHRydWUgIC0+IGludmFsaWRfYXJnIFwiQnl0ZXMuZXh0ZW5kXCIgKCogb3ZlcmZsb3cgKilcbiAgfCBfIC0+IGNcblxubGV0IGV4dGVuZCBzIGxlZnQgcmlnaHQgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgKysgbGVmdCArKyByaWdodCBpblxuICBsZXQgciA9IGNyZWF0ZSBsZW4gaW5cbiAgbGV0IChzcmNvZmYsIGRzdG9mZikgPSBpZiBsZWZ0IDwgMCB0aGVuIC1sZWZ0LCAwIGVsc2UgMCwgbGVmdCBpblxuICBsZXQgY3B5bGVuID0gSW50Lm1pbiAobGVuZ3RoIHMgLSBzcmNvZmYpIChsZW4gLSBkc3RvZmYpIGluXG4gIGlmIGNweWxlbiA+IDAgdGhlbiB1bnNhZmVfYmxpdCBzIHNyY29mZiByIGRzdG9mZiBjcHlsZW47XG4gIHJcblxubGV0IGZpbGwgcyBvZnMgbGVuIGMgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5maWxsIC8gQnl0ZXMuZmlsbFwiXG4gIGVsc2UgdW5zYWZlX2ZpbGwgcyBvZnMgbGVuIGNcblxubGV0IGJsaXQgczEgb2ZzMSBzMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IGxlbmd0aCBzMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggczIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ5dGVzLmJsaXRcIlxuICBlbHNlIHVuc2FmZV9ibGl0IHMxIG9mczEgczIgb2ZzMiBsZW5cblxubGV0IGJsaXRfc3RyaW5nIHMxIG9mczEgczIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBzdHJpbmdfbGVuZ3RoIHMxIC0gbGVuXG4gICAgICAgICAgICAgfHwgb2ZzMiA8IDAgfHwgb2ZzMiA+IGxlbmd0aCBzMiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmJsaXQgLyBCeXRlcy5ibGl0X3N0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX2JsaXRfc3RyaW5nIHMxIG9mczEgczIgb2ZzMiBsZW5cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpdGVyIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZih1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGl0ZXJpIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgZW5zdXJlX2dlICh4OmludCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSBpbnZhbGlkX2FyZyBcIkJ5dGVzLmNvbmNhdFwiXG5cbmxldCByZWMgc3VtX2xlbmd0aHMgYWNjIHNlcGxlbiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjXG4gIHwgaGQgOjogW10gLT4gbGVuZ3RoIGhkICsgYWNjXG4gIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgc2VwbGVuICsgYWNjKSBhY2MpIHNlcGxlbiB0bFxuXG5sZXQgcmVjIHVuc2FmZV9ibGl0cyBkc3QgcG9zIHNlcCBzZXBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGRzdFxuICB8IGhkIDo6IFtdIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpOyBkc3RcbiAgfCBoZCA6OiB0bCAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTtcbiAgICB1bnNhZmVfYmxpdCBzZXAgMCBkc3QgKHBvcyArIGxlbmd0aCBoZCkgc2VwbGVuO1xuICAgIHVuc2FmZV9ibGl0cyBkc3QgKHBvcyArIGxlbmd0aCBoZCArIHNlcGxlbikgc2VwIHNlcGxlbiB0bFxuXG5sZXQgY29uY2F0IHNlcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZW1wdHlcbiAgfCBsIC0+IGxldCBzZXBsZW4gPSBsZW5ndGggc2VwIGluXG4gICAgICAgICAgdW5zYWZlX2JsaXRzXG4gICAgICAgICAgICAoY3JlYXRlIChzdW1fbGVuZ3RocyAwIHNlcGxlbiBsKSlcbiAgICAgICAgICAgIDAgc2VwIHNlcGxlbiBsXG5cbmxldCBjYXQgczEgczIgPVxuICBsZXQgbDEgPSBsZW5ndGggczEgaW5cbiAgbGV0IGwyID0gbGVuZ3RoIHMyIGluXG4gIGxldCByID0gY3JlYXRlIChsMSArIGwyKSBpblxuICB1bnNhZmVfYmxpdCBzMSAwIHIgMCBsMTtcbiAgdW5zYWZlX2JsaXQgczIgMCByIGwxIGwyO1xuICByXG5cblxuZXh0ZXJuYWwgY2hhcl9jb2RlOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGNoYXJfY2hyOiBpbnQgLT4gY2hhciA9IFwiJWlkZW50aXR5XCJcblxubGV0IGlzX3NwYWNlID0gZnVuY3Rpb25cbiAgfCAnICcgfCAnXFwwMTInIHwgJ1xcbicgfCAnXFxyJyB8ICdcXHQnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCB0cmltIHMgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IGxlbiAmJiBpc19zcGFjZSAodW5zYWZlX2dldCBzICFpKSBkb1xuICAgIGluY3IgaVxuICBkb25lO1xuICBsZXQgaiA9IHJlZiAobGVuIC0gMSkgaW5cbiAgd2hpbGUgIWogPj0gIWkgJiYgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAhaikgZG9cbiAgICBkZWNyIGpcbiAgZG9uZTtcbiAgaWYgIWogPj0gIWkgdGhlblxuICAgIHN1YiBzICFpICghaiAtICFpICsgMSlcbiAgZWxzZVxuICAgIGVtcHR5XG5cbmxldCBlc2NhcGVkIHMgPVxuICBsZXQgbiA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG9cbiAgICBuIDo9ICFuICtcbiAgICAgIChtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICAgfCAnXFxcIicgfCAnXFxcXCcgfCAnXFxuJyB8ICdcXHQnIHwgJ1xccicgfCAnXFxiJyAtPiAyXG4gICAgICAgfCAnICcgLi4gJ34nIC0+IDFcbiAgICAgICB8IF8gLT4gNClcbiAgZG9uZTtcbiAgaWYgIW4gPSBsZW5ndGggcyB0aGVuIGNvcHkgcyBlbHNlIGJlZ2luXG4gICAgbGV0IHMnID0gY3JlYXRlICFuIGluXG4gICAgbiA6PSAwO1xuICAgIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG9cbiAgICAgIGJlZ2luIG1hdGNoIHVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgIHwgKCdcXFwiJyB8ICdcXFxcJykgYXMgYyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gY1xuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ24nXG4gICAgICB8ICdcXHQnIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAndCdcbiAgICAgIHwgJ1xccicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICdyJ1xuICAgICAgfCAnXFxiJyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ2InXG4gICAgICB8ICgnICcgLi4gJ34nKSBhcyBjIC0+IHVuc2FmZV9zZXQgcycgIW4gY1xuICAgICAgfCBjIC0+XG4gICAgICAgICAgbGV0IGEgPSBjaGFyX2NvZGUgYyBpblxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyBhIC8gMTAwKSk7XG4gICAgICAgICAgaW5jciBuO1xuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gKGNoYXJfY2hyICg0OCArIChhIC8gMTApIG1vZCAxMCkpO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyBhIG1vZCAxMCkpO1xuICAgICAgZW5kO1xuICAgICAgaW5jciBuXG4gICAgZG9uZTtcbiAgICBzJ1xuICBlbmRcblxubGV0IG1hcCBmIHMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGwgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkbyB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBzIGkpKSBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCBtYXBpIGYgcyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgbCA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgcyBpKSkgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgZm9sZF9sZWZ0IGYgeCBhID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZTtcbiAgIXJcblxubGV0IGZvbGRfcmlnaHQgZiBhIHggPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gbGVuZ3RoIGEgLSAxIGRvd250byAwIGRvXG4gICAgciA6PSBmICh1bnNhZmVfZ2V0IGEgaSkgIXJcbiAgZG9uZTtcbiAgIXJcblxubGV0IGV4aXN0cyBwIHMgPVxuICBsZXQgbiA9IGxlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IHMgaSkgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgZm9yX2FsbCBwIHMgPVxuICBsZXQgbiA9IGxlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgcyBpKSB0aGVuIGxvb3AgKHN1Y2MgaSlcbiAgICBlbHNlIGZhbHNlIGluXG4gIGxvb3AgMFxuXG5sZXQgdXBwZXJjYXNlX2FzY2lpIHMgPSBtYXAgQ2hhci51cHBlcmNhc2VfYXNjaWkgc1xubGV0IGxvd2VyY2FzZV9hc2NpaSBzID0gbWFwIENoYXIubG93ZXJjYXNlX2FzY2lpIHNcblxubGV0IGFwcGx5MSBmIHMgPVxuICBpZiBsZW5ndGggcyA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNvcHkgcyBpblxuICAgIHVuc2FmZV9zZXQgciAwIChmKHVuc2FmZV9nZXQgcyAwKSk7XG4gICAgclxuICBlbmRcblxubGV0IGNhcGl0YWxpemVfYXNjaWkgcyA9IGFwcGx5MSBDaGFyLnVwcGVyY2FzZV9hc2NpaSBzXG5sZXQgdW5jYXBpdGFsaXplX2FzY2lpIHMgPSBhcHBseTEgQ2hhci5sb3dlcmNhc2VfYXNjaWkgc1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHN0YXJ0c193aXRoIH5wcmVmaXggcyA9XG4gIGxldCBsZW5fcyA9IGxlbmd0aCBzXG4gIGFuZCBsZW5fcHJlID0gbGVuZ3RoIHByZWZpeCBpblxuICBsZXQgcmVjIGF1eCBpID1cbiAgICBpZiBpID0gbGVuX3ByZSB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHVuc2FmZV9nZXQgcyBpIDw+IHVuc2FmZV9nZXQgcHJlZml4IGkgdGhlbiBmYWxzZVxuICAgIGVsc2UgYXV4IChpICsgMSlcbiAgaW4gbGVuX3MgPj0gbGVuX3ByZSAmJiBhdXggMFxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGVuZHNfd2l0aCB+c3VmZml4IHMgPVxuICBsZXQgbGVuX3MgPSBsZW5ndGggc1xuICBhbmQgbGVuX3N1ZiA9IGxlbmd0aCBzdWZmaXggaW5cbiAgbGV0IGRpZmYgPSBsZW5fcyAtIGxlbl9zdWYgaW5cbiAgbGV0IHJlYyBhdXggaSA9XG4gICAgaWYgaSA9IGxlbl9zdWYgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiB1bnNhZmVfZ2V0IHMgKGRpZmYgKyBpKSA8PiB1bnNhZmVfZ2V0IHN1ZmZpeCBpIHRoZW4gZmFsc2VcbiAgICBlbHNlIGF1eCAoaSArIDEpXG4gIGluIGRpZmYgPj0gMCAmJiBhdXggMFxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWMgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgaW5kZXhfcmVjIHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4IHMgYyA9IGluZGV4X3JlYyBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIGluZGV4X3JlY19vcHQgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgaW5kZXhfcmVjX29wdCBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9vcHQgcyBjID0gaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tIC8gQnl0ZXMuaW5kZXhfZnJvbVwiIGVsc2VcbiAgaW5kZXhfcmVjIHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMuaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgaW5kZXhfcmVjX29wdCBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWMgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSByaW5kZXhfcmVjIHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4IHMgYyA9IHJpbmRleF9yZWMgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb20gLyBCeXRlcy5yaW5kZXhfZnJvbVwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjIHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWNfb3B0IHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgcmluZGV4X3JlY19vcHQgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfb3B0IHMgYyA9IHJpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5yaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgcmluZGV4X3JlY19vcHQgcyBpIGNcblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb250YWluc19mcm9tIC8gQnl0ZXMuY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChpbmRleF9yZWMgcyBsIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGNvbnRhaW5zIHMgYyA9IGNvbnRhaW5zX2Zyb20gcyAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAwIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJjb250YWluc19mcm9tIC8gQnl0ZXMucmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAocmluZGV4X3JlYyBzIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuXG50eXBlIHQgPSBieXRlc1xuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5leHRlcm5hbCBlcXVhbCA6IHQgLT4gdCAtPiBib29sID0gXCJjYW1sX2J5dGVzX2VxdWFsXCIgW0BAbm9hbGxvY11cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBzcGxpdF9vbl9jaGFyIHNlcCBzID1cbiAgbGV0IHIgPSByZWYgW10gaW5cbiAgbGV0IGogPSByZWYgKGxlbmd0aCBzKSBpblxuICBmb3IgaSA9IGxlbmd0aCBzIC0gMSBkb3dudG8gMCBkb1xuICAgIGlmIHVuc2FmZV9nZXQgcyBpID0gc2VwIHRoZW4gYmVnaW5cbiAgICAgIHIgOj0gc3ViIHMgKGkgKyAxKSAoIWogLSBpIC0gMSkgOjogIXI7XG4gICAgICBqIDo9IGlcbiAgICBlbmRcbiAgZG9uZTtcbiAgc3ViIHMgMCAhaiA6OiAhclxuXG4oKiBEZXByZWNhdGVkIGZ1bmN0aW9ucyBpbXBsZW1lbnRlZCB2aWEgb3RoZXIgZGVwcmVjYXRlZCBmdW5jdGlvbnMgKilcbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbmxldCB1cHBlcmNhc2UgcyA9IG1hcCBDaGFyLnVwcGVyY2FzZSBzXG5sZXQgbG93ZXJjYXNlIHMgPSBtYXAgQ2hhci5sb3dlcmNhc2Ugc1xuXG5sZXQgY2FwaXRhbGl6ZSBzID0gYXBwbHkxIENoYXIudXBwZXJjYXNlIHNcbmxldCB1bmNhcGl0YWxpemUgcyA9IGFwcGx5MSBDaGFyLmxvd2VyY2FzZSBzXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgcyA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPSBsZW5ndGggcyB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IGdldCBzIGkgaW5cbiAgICAgIFNlcS5Db25zICh4LCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCB0b19zZXFpIHMgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpID0gbGVuZ3RoIHMgdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBnZXQgcyBpIGluXG4gICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IG9mX3NlcSBpID1cbiAgbGV0IG4gPSByZWYgMCBpblxuICBsZXQgYnVmID0gcmVmIChtYWtlIDI1NiAnXFwwMDAnKSBpblxuICBsZXQgcmVzaXplICgpID1cbiAgICAoKiByZXNpemUgKilcbiAgICBsZXQgbmV3X2xlbiA9IEludC5taW4gKDIgKiBsZW5ndGggIWJ1ZikgU3lzLm1heF9zdHJpbmdfbGVuZ3RoIGluXG4gICAgaWYgbGVuZ3RoICFidWYgPSBuZXdfbGVuIHRoZW4gZmFpbHdpdGggXCJCeXRlcy5vZl9zZXE6IGNhbm5vdCBncm93IGJ5dGVzXCI7XG4gICAgbGV0IG5ld19idWYgPSBtYWtlIG5ld19sZW4gJ1xcMDAwJyBpblxuICAgIGJsaXQgIWJ1ZiAwIG5ld19idWYgMCAhbjtcbiAgICBidWYgOj0gbmV3X2J1ZlxuICBpblxuICBTZXEuaXRlclxuICAgIChmdW4gYyAtPlxuICAgICAgIGlmICFuID0gbGVuZ3RoICFidWYgdGhlbiByZXNpemUoKTtcbiAgICAgICBzZXQgIWJ1ZiAhbiBjO1xuICAgICAgIGluY3IgbilcbiAgICBpO1xuICBzdWIgIWJ1ZiAwICFuXG5cbigqKiB7NiBCaW5hcnkgZW5jb2RpbmcvZGVjb2Rpbmcgb2YgaW50ZWdlcnN9ICopXG5cbigqIFRoZSBnZXRfIGZ1bmN0aW9ucyBhcmUgYWxsIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5cbmV4dGVybmFsIHVuc2FmZV9nZXRfdWludDggOiBieXRlcyAtPiBpbnQgLT4gaW50ID0gXCIlYnl0ZXNfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfZ2V0X3VpbnQxNl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcIiVjYW1sX2J5dGVzX2dldDE2dVwiXG5leHRlcm5hbCBnZXRfdWludDggOiBieXRlcyAtPiBpbnQgLT4gaW50ID0gXCIlYnl0ZXNfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgZ2V0X3VpbnQxNl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcIiVjYW1sX2J5dGVzX2dldDE2XCJcbmV4dGVybmFsIGdldF9pbnQzMl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQzMiA9IFwiJWNhbWxfYnl0ZXNfZ2V0MzJcIlxuZXh0ZXJuYWwgZ2V0X2ludDY0X25lIDogYnl0ZXMgLT4gaW50IC0+IGludDY0ID0gXCIlY2FtbF9ieXRlc19nZXQ2NFwiXG5cbmV4dGVybmFsIHVuc2FmZV9zZXRfdWludDggOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXRfdWludDE2X25lIDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiJWNhbWxfYnl0ZXNfc2V0MTZ1XCJcbmV4dGVybmFsIHNldF9pbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgc2V0X2ludDE2X25lIDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQxNlwiXG5leHRlcm5hbCBzZXRfaW50MzJfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50MzIgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MzJcIlxuZXh0ZXJuYWwgc2V0X2ludDY0X25lIDogYnl0ZXMgLT4gaW50IC0+IGludDY0IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDY0XCJcbmV4dGVybmFsIHN3YXAxNiA6IGludCAtPiBpbnQgPSBcIiVic3dhcDE2XCJcbmV4dGVybmFsIHN3YXAzMiA6IGludDMyIC0+IGludDMyID0gXCIlYnN3YXBfaW50MzJcIlxuZXh0ZXJuYWwgc3dhcDY0IDogaW50NjQgLT4gaW50NjQgPSBcIiVic3dhcF9pbnQ2NFwiXG5cbmxldCB1bnNhZmVfZ2V0X3VpbnQxNl9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhblxuICB0aGVuIHN3YXAxNiAodW5zYWZlX2dldF91aW50MTZfbmUgYiBpKVxuICBlbHNlIHVuc2FmZV9nZXRfdWludDE2X25lIGIgaVxuXG5sZXQgdW5zYWZlX2dldF91aW50MTZfYmUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW5cbiAgdGhlbiB1bnNhZmVfZ2V0X3VpbnQxNl9uZSBiIGlcbiAgZWxzZSBzd2FwMTYgKHVuc2FmZV9nZXRfdWludDE2X25lIGIgaSlcblxubGV0IGdldF9pbnQ4IGIgaSA9XG4gICgoZ2V0X3VpbnQ4IGIgaSkgbHNsIChTeXMuaW50X3NpemUgLSA4KSkgYXNyIChTeXMuaW50X3NpemUgLSA4KVxuXG5sZXQgZ2V0X3VpbnQxNl9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAxNiAoZ2V0X3VpbnQxNl9uZSBiIGkpXG4gIGVsc2UgZ2V0X3VpbnQxNl9uZSBiIGlcblxubGV0IGdldF91aW50MTZfYmUgYiBpID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDE2IChnZXRfdWludDE2X25lIGIgaSlcbiAgZWxzZSBnZXRfdWludDE2X25lIGIgaVxuXG5sZXQgZ2V0X2ludDE2X25lIGIgaSA9XG4gICgoZ2V0X3VpbnQxNl9uZSBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gMTYpKSBhc3IgKFN5cy5pbnRfc2l6ZSAtIDE2KVxuXG5sZXQgZ2V0X2ludDE2X2xlIGIgaSA9XG4gICgoZ2V0X3VpbnQxNl9sZSBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gMTYpKSBhc3IgKFN5cy5pbnRfc2l6ZSAtIDE2KVxuXG5sZXQgZ2V0X2ludDE2X2JlIGIgaSA9XG4gICgoZ2V0X3VpbnQxNl9iZSBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gMTYpKSBhc3IgKFN5cy5pbnRfc2l6ZSAtIDE2KVxuXG5sZXQgZ2V0X2ludDMyX2xlIGIgaSA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDMyIChnZXRfaW50MzJfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQzMl9uZSBiIGlcblxubGV0IGdldF9pbnQzMl9iZSBiIGkgPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMzIgKGdldF9pbnQzMl9uZSBiIGkpXG4gIGVsc2UgZ2V0X2ludDMyX25lIGIgaVxuXG5sZXQgZ2V0X2ludDY0X2xlIGIgaSA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDY0IChnZXRfaW50NjRfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQ2NF9uZSBiIGlcblxubGV0IGdldF9pbnQ2NF9iZSBiIGkgPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwNjQgKGdldF9pbnQ2NF9uZSBiIGkpXG4gIGVsc2UgZ2V0X2ludDY0X25lIGIgaVxuXG5sZXQgdW5zYWZlX3NldF91aW50MTZfbGUgYiBpIHggPVxuICBpZiBTeXMuYmlnX2VuZGlhblxuICB0aGVuIHVuc2FmZV9zZXRfdWludDE2X25lIGIgaSAoc3dhcDE2IHgpXG4gIGVsc2UgdW5zYWZlX3NldF91aW50MTZfbmUgYiBpIHhcblxubGV0IHVuc2FmZV9zZXRfdWludDE2X2JlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW5cbiAgdGhlbiB1bnNhZmVfc2V0X3VpbnQxNl9uZSBiIGkgeCBlbHNlXG4gIHVuc2FmZV9zZXRfdWludDE2X25lIGIgaSAoc3dhcDE2IHgpXG5cbmxldCBzZXRfaW50MTZfbGUgYiBpIHggPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQxNl9uZSBiIGkgKHN3YXAxNiB4KVxuICBlbHNlIHNldF9pbnQxNl9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDE2X2JlIGIgaSB4ID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDE2X25lIGIgaSAoc3dhcDE2IHgpXG4gIGVsc2Ugc2V0X2ludDE2X25lIGIgaSB4XG5cbmxldCBzZXRfaW50MzJfbGUgYiBpIHggPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQzMl9uZSBiIGkgKHN3YXAzMiB4KVxuICBlbHNlIHNldF9pbnQzMl9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDMyX2JlIGIgaSB4ID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDMyX25lIGIgaSAoc3dhcDMyIHgpXG4gIGVsc2Ugc2V0X2ludDMyX25lIGIgaSB4XG5cbmxldCBzZXRfaW50NjRfbGUgYiBpIHggPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQ2NF9uZSBiIGkgKHN3YXA2NCB4KVxuICBlbHNlIHNldF9pbnQ2NF9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDY0X2JlIGIgaSB4ID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDY0X25lIGIgaSAoc3dhcDY0IHgpXG4gIGVsc2Ugc2V0X2ludDY0X25lIGIgaSB4XG5cbmxldCBzZXRfdWludDggPSBzZXRfaW50OFxubGV0IHNldF91aW50MTZfbmUgPSBzZXRfaW50MTZfbmVcbmxldCBzZXRfdWludDE2X2JlID0gc2V0X2ludDE2X2JlXG5sZXQgc2V0X3VpbnQxNl9sZSA9IHNldF9pbnQxNl9sZVxuXG4oKiBVVEYgY29kZWNzIGFuZCB2YWxpZGF0aW9ucyAqKVxuXG5sZXQgZGVjX2ludmFsaWQgPSBVY2hhci51dGZfZGVjb2RlX2ludmFsaWRcbmxldFtAaW5saW5lXSBkZWNfcmV0IG4gdSA9IFVjaGFyLnV0Zl9kZWNvZGUgbiAoVWNoYXIudW5zYWZlX29mX2ludCB1KVxuXG4oKiBJbiBjYXNlIG9mIGRlY29kaW5nIGVycm9yLCBpZiB3ZSBlcnJvciBvbiB0aGUgZmlyc3QgYnl0ZSwgd2VcbiAgIGNvbnN1bWUgdGhlIGJ5dGUsIG90aGVyd2lzZSB3ZSBjb25zdW1lIHRoZSBbbl0gYnl0ZXMgcHJlY2VlZGluZ1xuICAgdGhlIGVycm9yaW5nIGJ5dGUuXG5cbiAgIFRoaXMgbWVhbnMgdGhhdCBpZiBhIGNsaWVudCB1c2VzIGRlY29kZXMgd2l0aG91dCBjYXJpbmcgYWJvdXRcbiAgIHZhbGlkaXR5IGl0IG5hdHVyYWxseSByZXBsYWNlIGJvZ3VzIGRhdGEgd2l0aCBVY2hhci5yZXAgYWNjb3JkaW5nXG4gICB0byB0aGUgV0hBVFdHIEVuY29kaW5nIHN0YW5kYXJkLiBPdGhlciBzY2hlbWVzIGFyZSBwb3NzaWJsZSBieVxuICAgY29uc3VsdGluZyB0aGUgbnVtYmVyIG9mIHVzZWQgYnl0ZXMgb24gaW52YWxpZCBkZWNvZGVzLiBGb3IgbW9yZVxuICAgZGV0YWlscyBzZWUgaHR0cHM6Ly9oc2l2b25lbi5maS9icm9rZW4tdXRmLTgvXG5cbiAgIEZvciB0aGlzIHJlYXNvbiBpbiBbZ2V0X3V0Zl84X3VjaGFyXSB3ZSBncmFkdWFsbHkgY2hlY2sgdGhlIG5leHRcbiAgIGJ5dGUgaXMgYXZhaWxhYmxlIHJhdGhlciB0aGFuIGRvaW5nIGl0IGltbWVkaWF0ZWx5IGFmdGVyIHRoZVxuICAgZmlyc3QgYnl0ZS4gQ29udHJhc3Qgd2l0aCBbaXNfdmFsaWRfdXRmXzhdLiAqKVxuXG4oKiBVVEYtOCAqKVxuXG5sZXRbQGlubGluZV0gbm90X2luX3g4MF90b194QkYgYiA9IGIgbHNyIDYgPD4gMGIxMFxubGV0W0BpbmxpbmVdIG5vdF9pbl94QTBfdG9feEJGIGIgPSBiIGxzciA1IDw+IDBiMTAxXG5sZXRbQGlubGluZV0gbm90X2luX3g4MF90b194OUYgYiA9IGIgbHNyIDUgPD4gMGIxMDBcbmxldFtAaW5saW5lXSBub3RfaW5feDkwX3RvX3hCRiBiID0gYiA8IDB4OTAgfHwgMHhCRiA8IGJcbmxldFtAaW5saW5lXSBub3RfaW5feDgwX3RvX3g4RiBiID0gYiBsc3IgNCA8PiAweDhcblxubGV0W0BpbmxpbmVdIHV0Zl84X3VjaGFyXzIgYjAgYjEgPVxuICAoKGIwIGxhbmQgMHgxRikgbHNsIDYpIGxvclxuICAoKGIxIGxhbmQgMHgzRikpXG5cbmxldFtAaW5saW5lXSB1dGZfOF91Y2hhcl8zIGIwIGIxIGIyID1cbiAgKChiMCBsYW5kIDB4MEYpIGxzbCAxMikgbG9yXG4gICgoYjEgbGFuZCAweDNGKSBsc2wgNikgbG9yXG4gICgoYjIgbGFuZCAweDNGKSlcblxubGV0W0BpbmxpbmVdIHV0Zl84X3VjaGFyXzQgYjAgYjEgYjIgYjMgPVxuICAoKGIwIGxhbmQgMHgwNykgbHNsIDE4KSBsb3JcbiAgKChiMSBsYW5kIDB4M0YpIGxzbCAxMikgbG9yXG4gICgoYjIgbGFuZCAweDNGKSBsc2wgNikgbG9yXG4gICgoYjMgbGFuZCAweDNGKSlcblxubGV0IGdldF91dGZfOF91Y2hhciBiIGkgPVxuICBsZXQgYjAgPSBnZXRfdWludDggYiBpIGluICgqIHJhaXNlcyBpZiBbaV0gaXMgbm90IGEgdmFsaWQgaW5kZXguICopXG4gIGxldCBnZXQgPSB1bnNhZmVfZ2V0X3VpbnQ4IGluXG4gIGxldCBtYXggPSBsZW5ndGggYiAtIDEgaW5cbiAgbWF0Y2ggQ2hhci51bnNhZmVfY2hyIGIwIHdpdGggKCogU2VlIFRoZSBVbmljb2RlIFN0YW5kYXJkLCBUYWJsZSAzLjcgKilcbiAgfCAnXFx4MDAnIC4uICdcXHg3RicgLT4gZGVjX3JldCAxIGIwXG4gIHwgJ1xceEMyJyAuLiAnXFx4REYnIC0+XG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBiMSA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjEgdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGRlY19yZXQgMiAodXRmXzhfdWNoYXJfMiBiMCBiMSlcbiAgfCAnXFx4RTAnIC0+XG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBiMSA9IGdldCBiIGkgaW4gaWYgbm90X2luX3hBMF90b194QkYgYjEgdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGIyID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMiB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgZGVjX3JldCAzICh1dGZfOF91Y2hhcl8zIGIwIGIxIGIyKVxuICB8ICdcXHhFMScgLi4gJ1xceEVDJyB8ICdcXHhFRScgLi4gJ1xceEVGJyAtPlxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgYjEgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIxIHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBiMiA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjIgdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGRlY19yZXQgMyAodXRmXzhfdWNoYXJfMyBiMCBiMSBiMilcbiAgfCAnXFx4RUQnIC0+XG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBiMSA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194OUYgYjEgdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGIyID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMiB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgZGVjX3JldCAzICh1dGZfOF91Y2hhcl8zIGIwIGIxIGIyKVxuICB8ICdcXHhGMCcgLT5cbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGIxID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDkwX3RvX3hCRiBiMSB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgYjIgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIyIHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAzIGVsc2VcbiAgICAgIGxldCBiMyA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjMgdGhlbiBkZWNfaW52YWxpZCAzIGVsc2VcbiAgICAgIGRlY19yZXQgNCAodXRmXzhfdWNoYXJfNCBiMCBiMSBiMiBiMylcbiAgfCAnXFx4RjEnIC4uICdcXHhGMycgLT5cbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGIxID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMSB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgYjIgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIyIHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAzIGVsc2VcbiAgICAgIGxldCBiMyA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjMgdGhlbiBkZWNfaW52YWxpZCAzIGVsc2VcbiAgICAgIGRlY19yZXQgNCAodXRmXzhfdWNoYXJfNCBiMCBiMSBiMiBiMylcbiAgfCAnXFx4RjQnIC0+XG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBiMSA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194OEYgYjEgdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGIyID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMiB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMyBlbHNlXG4gICAgICBsZXQgYjMgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIzIHRoZW4gZGVjX2ludmFsaWQgMyBlbHNlXG4gICAgICBkZWNfcmV0IDQgKHV0Zl84X3VjaGFyXzQgYjAgYjEgYjIgYjMpXG4gIHwgXyAtPiBkZWNfaW52YWxpZCAxXG5cbmxldCBzZXRfdXRmXzhfdWNoYXIgYiBpIHUgPVxuICBsZXQgc2V0ID0gdW5zYWZlX3NldF91aW50OCBpblxuICBsZXQgbWF4ID0gbGVuZ3RoIGIgLSAxIGluXG4gIG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiAgfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgdSB3aGVuIHUgPD0gMHgwMDdGIC0+XG4gICAgICBzZXRfdWludDggYiBpIHU7XG4gICAgICAxXG4gIHwgdSB3aGVuIHUgPD0gMHgwN0ZGIC0+XG4gICAgICBsZXQgbGFzdCA9IGkgKyAxIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gMCBlbHNlXG4gICAgICAoc2V0X3VpbnQ4IGIgaSAoMHhDMCBsb3IgKHUgbHNyIDYpKTtcbiAgICAgICBzZXQgYiBsYXN0ICgweDgwIGxvciAodSBsYW5kIDB4M0YpKTtcbiAgICAgICAyKVxuICB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICAgbGV0IGxhc3QgPSBpICsgMiBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIDAgZWxzZVxuICAgICAgKHNldF91aW50OCBiIGkgKDB4RTAgbG9yICh1IGxzciAxMikpO1xuICAgICAgIHNldCBiIChpICsgMSkgKDB4ODAgbG9yICgodSBsc3IgNikgbGFuZCAweDNGKSk7XG4gICAgICAgc2V0IGIgbGFzdCAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSk7XG4gICAgICAgMylcbiAgfCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPlxuICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIDAgZWxzZVxuICAgICAgKHNldF91aW50OCBiIGkgKDB4RjAgbG9yICh1IGxzciAxOCkpO1xuICAgICAgIHNldCBiIChpICsgMSkgKDB4ODAgbG9yICgodSBsc3IgMTIpIGxhbmQgMHgzRikpO1xuICAgICAgIHNldCBiIChpICsgMikgKDB4ODAgbG9yICgodSBsc3IgNikgbGFuZCAweDNGKSk7XG4gICAgICAgc2V0IGIgbGFzdCAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSk7XG4gICAgICAgNClcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgaXNfdmFsaWRfdXRmXzggYiA9XG4gIGxldCByZWMgbG9vcCBtYXggYiBpID1cbiAgICBpZiBpID4gbWF4IHRoZW4gdHJ1ZSBlbHNlXG4gICAgbGV0IGdldCA9IHVuc2FmZV9nZXRfdWludDggaW5cbiAgICBtYXRjaCBDaGFyLnVuc2FmZV9jaHIgKGdldCBiIGkpIHdpdGhcbiAgICB8ICdcXHgwMCcgLi4gJ1xceDdGJyAtPiBsb29wIG1heCBiIChpICsgMSlcbiAgICB8ICdcXHhDMicgLi4gJ1xceERGJyAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAxIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXhcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIGxhc3QpXG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBsb29wIG1heCBiIChsYXN0ICsgMSlcbiAgICB8ICdcXHhFMCcgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMiBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4XG4gICAgICAgIHx8IG5vdF9pbl94QTBfdG9feEJGIChnZXQgYiAoaSArIDEpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgbGFzdClcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgbWF4IGIgKGxhc3QgKyAxKVxuICAgIHwgJ1xceEUxJyAuLiAnXFx4RUMnIHwgJ1xceEVFJyAuLiAnXFx4RUYnIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDIgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heFxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgKGkgKyAxKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIGxhc3QpXG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBsb29wIG1heCBiIChsYXN0ICsgMSlcbiAgICB8ICdcXHhFRCcgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMiBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4XG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feDlGIChnZXQgYiAoaSArIDEpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgbGFzdClcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgbWF4IGIgKGxhc3QgKyAxKVxuICAgIHwgJ1xceEYwJyAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXhcbiAgICAgICAgfHwgbm90X2luX3g5MF90b194QkYgKGdldCBiIChpICsgMSkpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiAoaSArIDIpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgbGFzdClcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgbWF4IGIgKGxhc3QgKyAxKVxuICAgIHwgJ1xceEYxJyAuLiAnXFx4RjMnIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heFxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgKGkgKyAxKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIChpICsgMikpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiBsYXN0KVxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgbG9vcCBtYXggYiAobGFzdCArIDEpXG4gICAgfCAnXFx4RjQnIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heFxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3g4RiAoZ2V0IGIgKGkgKyAxKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIChpICsgMikpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiBsYXN0KVxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgbG9vcCBtYXggYiAobGFzdCArIDEpXG4gICAgfCBfIC0+IGZhbHNlXG4gIGluXG4gIGxvb3AgKGxlbmd0aCBiIC0gMSkgYiAwXG5cbigqIFVURi0xNkJFICopXG5cbmxldCBnZXRfdXRmXzE2YmVfdWNoYXIgYiBpID1cbiAgbGV0IGdldCA9IHVuc2FmZV9nZXRfdWludDE2X2JlIGluXG4gIGxldCBtYXggPSBsZW5ndGggYiAtIDEgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IG1heCB0aGVuIGludmFsaWRfYXJnIFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiIGVsc2VcbiAgaWYgaSA9IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgfCB1IHdoZW4gdSA8IDB4RDgwMCB8fCB1ID4gMHhERkZGIC0+IGRlY19yZXQgMiB1XG4gIHwgdSB3aGVuIHUgPiAweERCRkYgLT4gZGVjX2ludmFsaWQgMlxuICB8IGhpIC0+ICgqIGNvbWJpbmUgW2hpXSB3aXRoIGEgbG93IHN1cnJvZ2F0ZSAqKVxuICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIGRlY19pbnZhbGlkIChtYXggLSBpICsgMSkgZWxzZVxuICAgICAgbWF0Y2ggZ2V0IGIgKGkgKyAyKSB3aXRoXG4gICAgICB8IHUgd2hlbiB1IDwgMHhEQzAwIHx8IHUgPiAweERGRkYgLT4gZGVjX2ludmFsaWQgMiAoKiByZXRyeSBoZXJlICopXG4gICAgICB8IGxvIC0+XG4gICAgICAgICAgbGV0IHUgPSAoKChoaSBsYW5kIDB4M0ZGKSBsc2wgMTApIGxvciAobG8gbGFuZCAweDNGRikpICsgMHgxMDAwMCBpblxuICAgICAgICAgIGRlY19yZXQgNCB1XG5cbmxldCBzZXRfdXRmXzE2YmVfdWNoYXIgYiBpIHUgPVxuICBsZXQgc2V0ID0gdW5zYWZlX3NldF91aW50MTZfYmUgaW5cbiAgbGV0IG1heCA9IGxlbmd0aCBiIC0gMSBpblxuICBpZiBpIDwgMCB8fCBpID4gbWF4IHRoZW4gaW52YWxpZF9hcmcgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIgZWxzZVxuICBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuICB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICAgbGV0IGxhc3QgPSBpICsgMSBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIDAgZWxzZSAoc2V0IGIgaSB1OyAyKVxuICB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gMCBlbHNlXG4gICAgICBsZXQgdScgPSB1IC0gMHgxMDAwMCBpblxuICAgICAgbGV0IGhpID0gKDB4RDgwMCBsb3IgKHUnIGxzciAxMCkpIGluXG4gICAgICBsZXQgbG8gPSAoMHhEQzAwIGxvciAodScgbGFuZCAweDNGRikpIGluXG4gICAgICBzZXQgYiBpIGhpOyBzZXQgYiAoaSArIDIpIGxvOyA0XG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGlzX3ZhbGlkX3V0Zl8xNmJlIGIgPVxuICBsZXQgcmVjIGxvb3AgbWF4IGIgaSA9XG4gICAgbGV0IGdldCA9IHVuc2FmZV9nZXRfdWludDE2X2JlIGluXG4gICAgaWYgaSA+IG1heCB0aGVuIHRydWUgZWxzZVxuICAgIGlmIGkgPSBtYXggdGhlbiBmYWxzZSBlbHNlXG4gICAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gICAgfCB1IHdoZW4gdSA8IDB4RDgwMCB8fCB1ID4gMHhERkZGIC0+IGxvb3AgbWF4IGIgKGkgKyAyKVxuICAgIHwgdSB3aGVuIHUgPiAweERCRkYgLT4gZmFsc2VcbiAgICB8IF9oaSAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiBmYWxzZSBlbHNlXG4gICAgICAgIG1hdGNoIGdldCBiIChpICsgMikgd2l0aFxuICAgICAgICB8IHUgd2hlbiB1IDwgMHhEQzAwIHx8IHUgPiAweERGRkYgLT4gZmFsc2VcbiAgICAgICAgfCBfbG8gLT4gbG9vcCBtYXggYiAoaSArIDQpXG4gIGluXG4gIGxvb3AgKGxlbmd0aCBiIC0gMSkgYiAwXG5cbigqIFVURi0xNkxFICopXG5cbmxldCBnZXRfdXRmXzE2bGVfdWNoYXIgYiBpID1cbiAgbGV0IGdldCA9IHVuc2FmZV9nZXRfdWludDE2X2xlIGluXG4gIGxldCBtYXggPSBsZW5ndGggYiAtIDEgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IG1heCB0aGVuIGludmFsaWRfYXJnIFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiIGVsc2VcbiAgaWYgaSA9IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgfCB1IHdoZW4gdSA8IDB4RDgwMCB8fCB1ID4gMHhERkZGIC0+IGRlY19yZXQgMiB1XG4gIHwgdSB3aGVuIHUgPiAweERCRkYgLT4gZGVjX2ludmFsaWQgMlxuICB8IGhpIC0+ICgqIGNvbWJpbmUgW2hpXSB3aXRoIGEgbG93IHN1cnJvZ2F0ZSAqKVxuICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIGRlY19pbnZhbGlkIChtYXggLSBpICsgMSkgZWxzZVxuICAgICAgbWF0Y2ggZ2V0IGIgKGkgKyAyKSB3aXRoXG4gICAgICB8IHUgd2hlbiB1IDwgMHhEQzAwIHx8IHUgPiAweERGRkYgLT4gZGVjX2ludmFsaWQgMiAoKiByZXRyeSBoZXJlICopXG4gICAgICB8IGxvIC0+XG4gICAgICAgICAgbGV0IHUgPSAoKChoaSBsYW5kIDB4M0ZGKSBsc2wgMTApIGxvciAobG8gbGFuZCAweDNGRikpICsgMHgxMDAwMCBpblxuICAgICAgICAgIGRlY19yZXQgNCB1XG5cbmxldCBzZXRfdXRmXzE2bGVfdWNoYXIgYiBpIHUgPVxuICBsZXQgc2V0ID0gdW5zYWZlX3NldF91aW50MTZfbGUgaW5cbiAgbGV0IG1heCA9IGxlbmd0aCBiIC0gMSBpblxuICBpZiBpIDwgMCB8fCBpID4gbWF4IHRoZW4gaW52YWxpZF9hcmcgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIgZWxzZVxuICBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuICB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICAgbGV0IGxhc3QgPSBpICsgMSBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIDAgZWxzZSAoc2V0IGIgaSB1OyAyKVxuICB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gMCBlbHNlXG4gICAgICBsZXQgdScgPSB1IC0gMHgxMDAwMCBpblxuICAgICAgbGV0IGhpID0gKDB4RDgwMCBsb3IgKHUnIGxzciAxMCkpIGluXG4gICAgICBsZXQgbG8gPSAoMHhEQzAwIGxvciAodScgbGFuZCAweDNGRikpIGluXG4gICAgICBzZXQgYiBpIGhpOyBzZXQgYiAoaSArIDIpIGxvOyA0XG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGlzX3ZhbGlkX3V0Zl8xNmxlIGIgPVxuICBsZXQgcmVjIGxvb3AgbWF4IGIgaSA9XG4gICAgbGV0IGdldCA9IHVuc2FmZV9nZXRfdWludDE2X2xlIGluXG4gICAgaWYgaSA+IG1heCB0aGVuIHRydWUgZWxzZVxuICAgIGlmIGkgPSBtYXggdGhlbiBmYWxzZSBlbHNlXG4gICAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gICAgfCB1IHdoZW4gdSA8IDB4RDgwMCB8fCB1ID4gMHhERkZGIC0+IGxvb3AgbWF4IGIgKGkgKyAyKVxuICAgIHwgdSB3aGVuIHUgPiAweERCRkYgLT4gZmFsc2VcbiAgICB8IF9oaSAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiBmYWxzZSBlbHNlXG4gICAgICAgIG1hdGNoIGdldCBiIChpICsgMikgd2l0aFxuICAgICAgICB8IHUgd2hlbiB1IDwgMHhEQzAwIHx8IHUgPiAweERGRkYgLT4gZmFsc2VcbiAgICAgICAgfCBfbG8gLT4gbG9vcCBtYXggYiAoaSArIDQpXG4gIGluXG4gIGxvb3AgKGxlbmd0aCBiIC0gMSkgYiAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBHYWxsaXVtLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFN0cmluZyBvcGVyYXRpb25zLCBiYXNlZCBvbiBieXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgKilcblxuKCogV0FSTklORzogU29tZSBmdW5jdGlvbnMgaW4gdGhpcyBmaWxlIGFyZSBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sIGZvclxuICAgZWZmaWNpZW5jeSByZWFzb25zLiBXaGVuIHlvdSBtb2RpZnkgdGhlIG9uZSBpbiB0aGlzIGZpbGUgeW91IG5lZWQgdG9cbiAgIG1vZGlmeSBpdHMgZHVwbGljYXRlIGluIGJ5dGVzLm1sLlxuICAgVGhlc2UgZnVuY3Rpb25zIGhhdmUgYSBcImR1cGxpY2F0ZWRcIiBjb21tZW50IGFib3ZlIHRoZWlyIGRlZmluaXRpb24uXG4qKVxuXG5leHRlcm5hbCBsZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5leHRlcm5hbCBnZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJXN0cmluZ19zYWZlX3NldFwiXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX3N0cmluZ1wiXG5leHRlcm5hbCB1bnNhZmVfZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVzdHJpbmdfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6IHN0cmluZyAtPiBpbnQgLT4gIGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfZmlsbF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuXG5tb2R1bGUgQiA9IEJ5dGVzXG5cbmxldCBidHMgPSBCLnVuc2FmZV90b19zdHJpbmdcbmxldCBib3MgPSBCLnVuc2FmZV9vZl9zdHJpbmdcblxubGV0IG1ha2UgbiBjID1cbiAgQi5tYWtlIG4gYyB8PiBidHNcbmxldCBpbml0IG4gZiA9XG4gIEIuaW5pdCBuIGYgfD4gYnRzXG5sZXQgZW1wdHkgPSBcIlwiXG5sZXQgY29weSBzID1cbiAgQi5jb3B5IChib3MgcykgfD4gYnRzXG5sZXQgb2ZfYnl0ZXMgPSBCLnRvX3N0cmluZ1xubGV0IHRvX2J5dGVzID0gQi5vZl9zdHJpbmdcbmxldCBzdWIgcyBvZnMgbGVuID1cbiAgQi5zdWIgKGJvcyBzKSBvZnMgbGVuIHw+IGJ0c1xubGV0IGZpbGwgPVxuICBCLmZpbGxcbmxldCBibGl0ID1cbiAgQi5ibGl0X3N0cmluZ1xuXG5sZXQgZW5zdXJlX2dlICh4OmludCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb25jYXRcIlxuXG5sZXQgcmVjIHN1bV9sZW5ndGhzIGFjYyBzZXBsZW4gPSBmdW5jdGlvblxuICB8IFtdIC0+IGFjY1xuICB8IGhkIDo6IFtdIC0+IGxlbmd0aCBoZCArIGFjY1xuICB8IGhkIDo6IHRsIC0+IHN1bV9sZW5ndGhzIChlbnN1cmVfZ2UgKGxlbmd0aCBoZCArIHNlcGxlbiArIGFjYykgYWNjKSBzZXBsZW4gdGxcblxubGV0IHJlYyB1bnNhZmVfYmxpdHMgZHN0IHBvcyBzZXAgc2VwbGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBkc3RcbiAgfCBoZCA6OiBbXSAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTsgZHN0XG4gIHwgaGQgOjogdGwgLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7XG4gICAgdW5zYWZlX2JsaXQgc2VwIDAgZHN0IChwb3MgKyBsZW5ndGggaGQpIHNlcGxlbjtcbiAgICB1bnNhZmVfYmxpdHMgZHN0IChwb3MgKyBsZW5ndGggaGQgKyBzZXBsZW4pIHNlcCBzZXBsZW4gdGxcblxubGV0IGNvbmNhdCBzZXAgPSBmdW5jdGlvblxuICAgIFtdIC0+IFwiXCJcbiAgfCBsIC0+IGxldCBzZXBsZW4gPSBsZW5ndGggc2VwIGluIGJ0cyBAQFxuICAgICAgICAgIHVuc2FmZV9ibGl0c1xuICAgICAgICAgICAgKEIuY3JlYXRlIChzdW1fbGVuZ3RocyAwIHNlcGxlbiBsKSlcbiAgICAgICAgICAgIDAgc2VwIHNlcGxlbiBsXG5cbmxldCBjYXQgPSAoIF4gKVxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaXRlciBmIHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvIGYgKHVuc2FmZV9nZXQgcyBpKSBkb25lXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpdGVyaSBmIHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBzIGkpIGRvbmVcblxubGV0IG1hcCBmIHMgPVxuICBCLm1hcCBmIChib3MgcykgfD4gYnRzXG5sZXQgbWFwaSBmIHMgPVxuICBCLm1hcGkgZiAoYm9zIHMpIHw+IGJ0c1xubGV0IGZvbGRfcmlnaHQgZiB4IGEgPVxuICBCLmZvbGRfcmlnaHQgZiAoYm9zIHgpIGFcbmxldCBmb2xkX2xlZnQgZiBhIHggPVxuICBCLmZvbGRfbGVmdCBmIGEgKGJvcyB4KVxubGV0IGV4aXN0cyBmIHMgPVxuICBCLmV4aXN0cyBmIChib3MgcylcbmxldCBmb3JfYWxsIGYgcyA9XG4gIEIuZm9yX2FsbCBmIChib3MgcylcblxuKCogQmV3YXJlOiB3ZSBjYW5ub3QgdXNlIEIudHJpbSBvciBCLmVzY2FwZSBiZWNhdXNlIHRoZXkgYWx3YXlzIG1ha2UgYVxuICAgY29weSwgYnV0IFN0cmluZy5tbGkgc3BlbGxzIG91dCBzb21lIGNhc2VzIHdoZXJlIHdlIGFyZSBub3QgYWxsb3dlZFxuICAgdG8gbWFrZSBhIGNvcHkuICopXG5cbmxldCBpc19zcGFjZSA9IGZ1bmN0aW9uXG4gIHwgJyAnIHwgJ1xcMDEyJyB8ICdcXG4nIHwgJ1xccicgfCAnXFx0JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5sZXQgdHJpbSBzID1cbiAgaWYgcyA9IFwiXCIgdGhlbiBzXG4gIGVsc2UgaWYgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAwKSB8fCBpc19zcGFjZSAodW5zYWZlX2dldCBzIChsZW5ndGggcyAtIDEpKVxuICAgIHRoZW4gYnRzIChCLnRyaW0gKGJvcyBzKSlcbiAgZWxzZSBzXG5cbmxldCBlc2NhcGVkIHMgPVxuICBsZXQgcmVjIGVzY2FwZV9pZl9uZWVkZWQgcyBuIGkgPVxuICAgIGlmIGkgPj0gbiB0aGVuIHMgZWxzZVxuICAgICAgbWF0Y2ggdW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgfCAnXFxcIicgfCAnXFxcXCcgfCAnXFwwMDAnLi4nXFwwMzEnIHwgJ1xcMTI3Jy4uICdcXDI1NScgLT5cbiAgICAgICAgICBidHMgKEIuZXNjYXBlZCAoYm9zIHMpKVxuICAgICAgfCBfIC0+IGVzY2FwZV9pZl9uZWVkZWQgcyBuIChpKzEpXG4gIGluXG4gIGVzY2FwZV9pZl9uZWVkZWQgcyAobGVuZ3RoIHMpIDBcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWMgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgaW5kZXhfcmVjIHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXggcyBjID0gaW5kZXhfcmVjIHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWNfb3B0IHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIGluZGV4X3JlY19vcHQgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9vcHQgcyBjID0gaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb20gLyBCeXRlcy5pbmRleF9mcm9tXCIgZWxzZVxuICAgIGluZGV4X3JlYyBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMuaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgaW5kZXhfcmVjX29wdCBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgcmluZGV4X3JlYyBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIHJpbmRleF9yZWMgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleCBzIGMgPSByaW5kZXhfcmVjIHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4X2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb20gLyBCeXRlcy5yaW5kZXhfZnJvbVwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjIHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgcmluZGV4X3JlY19vcHQgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSByaW5kZXhfcmVjX29wdCBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4X29wdCBzIGMgPSByaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5yaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgcmluZGV4X3JlY19vcHQgcyBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb250YWluc19mcm9tIC8gQnl0ZXMuY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChpbmRleF9yZWMgcyBsIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGNvbnRhaW5zIHMgYyA9IGNvbnRhaW5zX2Zyb20gcyAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJjb250YWluc19mcm9tIHMgaSBjID1cbiAgaWYgaSA8IDAgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5yY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChyaW5kZXhfcmVjIHMgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG5sZXQgdXBwZXJjYXNlX2FzY2lpIHMgPVxuICBCLnVwcGVyY2FzZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IGxvd2VyY2FzZV9hc2NpaSBzID1cbiAgQi5sb3dlcmNhc2VfYXNjaWkgKGJvcyBzKSB8PiBidHNcbmxldCBjYXBpdGFsaXplX2FzY2lpIHMgPVxuICBCLmNhcGl0YWxpemVfYXNjaWkgKGJvcyBzKSB8PiBidHNcbmxldCB1bmNhcGl0YWxpemVfYXNjaWkgcyA9XG4gIEIudW5jYXBpdGFsaXplX2FzY2lpIChib3MgcykgfD4gYnRzXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBzdGFydHNfd2l0aCB+cHJlZml4IHMgPVxuICBsZXQgbGVuX3MgPSBsZW5ndGggc1xuICBhbmQgbGVuX3ByZSA9IGxlbmd0aCBwcmVmaXggaW5cbiAgbGV0IHJlYyBhdXggaSA9XG4gICAgaWYgaSA9IGxlbl9wcmUgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiB1bnNhZmVfZ2V0IHMgaSA8PiB1bnNhZmVfZ2V0IHByZWZpeCBpIHRoZW4gZmFsc2VcbiAgICBlbHNlIGF1eCAoaSArIDEpXG4gIGluIGxlbl9zID49IGxlbl9wcmUgJiYgYXV4IDBcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGVuZHNfd2l0aCB+c3VmZml4IHMgPVxuICBsZXQgbGVuX3MgPSBsZW5ndGggc1xuICBhbmQgbGVuX3N1ZiA9IGxlbmd0aCBzdWZmaXggaW5cbiAgbGV0IGRpZmYgPSBsZW5fcyAtIGxlbl9zdWYgaW5cbiAgbGV0IHJlYyBhdXggaSA9XG4gICAgaWYgaSA9IGxlbl9zdWYgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiB1bnNhZmVfZ2V0IHMgKGRpZmYgKyBpKSA8PiB1bnNhZmVfZ2V0IHN1ZmZpeCBpIHRoZW4gZmFsc2VcbiAgICBlbHNlIGF1eCAoaSArIDEpXG4gIGluIGRpZmYgPj0gMCAmJiBhdXggMFxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgc3BsaXRfb25fY2hhciBzZXAgcyA9XG4gIGxldCByID0gcmVmIFtdIGluXG4gIGxldCBqID0gcmVmIChsZW5ndGggcykgaW5cbiAgZm9yIGkgPSBsZW5ndGggcyAtIDEgZG93bnRvIDAgZG9cbiAgICBpZiB1bnNhZmVfZ2V0IHMgaSA9IHNlcCB0aGVuIGJlZ2luXG4gICAgICByIDo9IHN1YiBzIChpICsgMSkgKCFqIC0gaSAtIDEpIDo6ICFyO1xuICAgICAgaiA6PSBpXG4gICAgZW5kXG4gIGRvbmU7XG4gIHN1YiBzIDAgIWogOjogIXJcblxuKCogRGVwcmVjYXRlZCBmdW5jdGlvbnMgaW1wbGVtZW50ZWQgdmlhIG90aGVyIGRlcHJlY2F0ZWQgZnVuY3Rpb25zICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5sZXQgdXBwZXJjYXNlIHMgPVxuICBCLnVwcGVyY2FzZSAoYm9zIHMpIHw+IGJ0c1xubGV0IGxvd2VyY2FzZSBzID1cbiAgQi5sb3dlcmNhc2UgKGJvcyBzKSB8PiBidHNcbmxldCBjYXBpdGFsaXplIHMgPVxuICBCLmNhcGl0YWxpemUgKGJvcyBzKSB8PiBidHNcbmxldCB1bmNhcGl0YWxpemUgcyA9XG4gIEIudW5jYXBpdGFsaXplIChib3MgcykgfD4gYnRzXG5cbnR5cGUgdCA9IHN0cmluZ1xuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5leHRlcm5hbCBlcXVhbCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbCA9IFwiY2FtbF9zdHJpbmdfZXF1YWxcIiBbQEBub2FsbG9jXVxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHMgPSBib3MgcyB8PiBCLnRvX3NlcVxuXG5sZXQgdG9fc2VxaSBzID0gYm9zIHMgfD4gQi50b19zZXFpXG5cbmxldCBvZl9zZXEgZyA9IEIub2Zfc2VxIGcgfD4gYnRzXG5cbigqIFVURiBkZWNvZGVycyBhbmQgdmFsaWRhdG9ycyAqKVxuXG5sZXQgZ2V0X3V0Zl84X3VjaGFyIHMgaSA9IEIuZ2V0X3V0Zl84X3VjaGFyIChib3MgcykgaVxubGV0IGlzX3ZhbGlkX3V0Zl84IHMgPSBCLmlzX3ZhbGlkX3V0Zl84IChib3MgcylcblxubGV0IGdldF91dGZfMTZiZV91Y2hhciBzIGkgPSBCLmdldF91dGZfMTZiZV91Y2hhciAoYm9zIHMpIGlcbmxldCBpc192YWxpZF91dGZfMTZiZSBzID0gQi5pc192YWxpZF91dGZfMTZiZSAoYm9zIHMpXG5cbmxldCBnZXRfdXRmXzE2bGVfdWNoYXIgcyBpID0gQi5nZXRfdXRmXzE2bGVfdWNoYXIgKGJvcyBzKSBpXG5sZXQgaXNfdmFsaWRfdXRmXzE2bGUgcyA9IEIuaXNfdmFsaWRfdXRmXzE2bGUgKGJvcyBzKVxuXG4oKiogezYgQmluYXJ5IGVuY29kaW5nL2RlY29kaW5nIG9mIGludGVnZXJzfSAqKVxuXG5leHRlcm5hbCBnZXRfdWludDggOiBzdHJpbmcgLT4gaW50IC0+IGludCA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG5leHRlcm5hbCBnZXRfdWludDE2X25lIDogc3RyaW5nIC0+IGludCAtPiBpbnQgPSBcIiVjYW1sX3N0cmluZ19nZXQxNlwiXG5leHRlcm5hbCBnZXRfaW50MzJfbmUgOiBzdHJpbmcgLT4gaW50IC0+IGludDMyID0gXCIlY2FtbF9zdHJpbmdfZ2V0MzJcIlxuZXh0ZXJuYWwgZ2V0X2ludDY0X25lIDogc3RyaW5nIC0+IGludCAtPiBpbnQ2NCA9IFwiJWNhbWxfc3RyaW5nX2dldDY0XCJcblxubGV0IGdldF9pbnQ4IHMgaSA9IEIuZ2V0X2ludDggKGJvcyBzKSBpXG5sZXQgZ2V0X3VpbnQxNl9sZSBzIGkgPSBCLmdldF91aW50MTZfbGUgKGJvcyBzKSBpXG5sZXQgZ2V0X3VpbnQxNl9iZSBzIGkgPSBCLmdldF91aW50MTZfYmUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDE2X25lIHMgaSA9IEIuZ2V0X2ludDE2X25lIChib3MgcykgaVxubGV0IGdldF9pbnQxNl9sZSBzIGkgPSBCLmdldF9pbnQxNl9sZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50MTZfYmUgcyBpID0gQi5nZXRfaW50MTZfYmUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDMyX2xlIHMgaSA9IEIuZ2V0X2ludDMyX2xlIChib3MgcykgaVxubGV0IGdldF9pbnQzMl9iZSBzIGkgPSBCLmdldF9pbnQzMl9iZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50NjRfbGUgcyBpID0gQi5nZXRfaW50NjRfbGUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDY0X2JlIHMgaSA9IEIuZ2V0X2ludDY0X2JlIChib3MgcykgaVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgYXJyYXlzLiAqKVxudHlwZSAnYSB0ID0gJ2EgYXJyYXlcblxuKCogQXJyYXkgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBsZW5ndGggOiAnYSBhcnJheSAtPiBpbnQgPSBcIiVhcnJheV9sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgPSBcIiVhcnJheV9zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlYXJyYXlfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgbWFrZTogaW50IC0+ICdhIC0+ICdhIGFycmF5ID0gXCJjYW1sX21ha2VfdmVjdFwiXG5leHRlcm5hbCBjcmVhdGU6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuZXh0ZXJuYWwgdW5zYWZlX3N1YiA6ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfc3ViXCJcbmV4dGVybmFsIGFwcGVuZF9wcmltIDogJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfYXBwZW5kXCJcbmV4dGVybmFsIGNvbmNhdCA6ICdhIGFycmF5IGxpc3QgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfY29uY2F0XCJcbmV4dGVybmFsIHVuc2FmZV9ibGl0IDpcbiAgJ2EgYXJyYXkgLT4gaW50IC0+ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9hcnJheV9ibGl0XCJcbmV4dGVybmFsIHVuc2FmZV9maWxsIDpcbiAgJ2EgYXJyYXkgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2FycmF5X2ZpbGxcIlxuZXh0ZXJuYWwgY3JlYXRlX2Zsb2F0OiBpbnQgLT4gZmxvYXQgYXJyYXkgPSBcImNhbWxfbWFrZV9mbG9hdF92ZWN0XCJcbmxldCBtYWtlX2Zsb2F0ID0gY3JlYXRlX2Zsb2F0XG5cbm1vZHVsZSBGbG9hdGFycmF5ID0gc3RydWN0XG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBmbG9hdGFycmF5ID0gXCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlXCJcbiAgZXh0ZXJuYWwgbGVuZ3RoIDogZmxvYXRhcnJheSAtPiBpbnQgPSBcIiVmbG9hdGFycmF5X2xlbmd0aFwiXG4gIGV4dGVybmFsIGdldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV9zYWZlX2dldFwiXG4gIGV4dGVybmFsIHNldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfc2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV91bnNhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXRcbiAgICAgID0gXCIlZmxvYXRhcnJheV91bnNhZmVfc2V0XCJcbmVuZFxuXG5sZXQgaW5pdCBsIGYgPVxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZVxuICBpZiBsIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuaW5pdFwiXG4gICgqIFNlZSAjNjU3NS4gV2UgY291bGQgYWxzbyBjaGVjayBmb3IgbWF4aW11bSBhcnJheSBzaXplLCBidXQgdGhpcyBkZXBlbmRzXG4gICAgIG9uIHdoZXRoZXIgd2UgY3JlYXRlIGEgZmxvYXQgYXJyYXkgb3IgYSByZWd1bGFyIG9uZS4uLiAqKVxuICBlbHNlXG4gICBsZXQgcmVzID0gY3JlYXRlIGwgKGYgMCkgaW5cbiAgIGZvciBpID0gMSB0byBwcmVkIGwgZG9cbiAgICAgdW5zYWZlX3NldCByZXMgaSAoZiBpKVxuICAgZG9uZTtcbiAgIHJlc1xuXG5sZXQgbWFrZV9tYXRyaXggc3ggc3kgaW5pdCA9XG4gIGxldCByZXMgPSBjcmVhdGUgc3ggW3x8XSBpblxuICBmb3IgeCA9IDAgdG8gcHJlZCBzeCBkb1xuICAgIHVuc2FmZV9zZXQgcmVzIHggKGNyZWF0ZSBzeSBpbml0KVxuICBkb25lO1xuICByZXNcblxubGV0IGNyZWF0ZV9tYXRyaXggPSBtYWtlX21hdHJpeFxuXG5sZXQgY29weSBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpbiBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSB1bnNhZmVfc3ViIGEgMCBsXG5cbmxldCBhcHBlbmQgYTEgYTIgPVxuICBsZXQgbDEgPSBsZW5ndGggYTEgaW5cbiAgaWYgbDEgPSAwIHRoZW4gY29weSBhMlxuICBlbHNlIGlmIGxlbmd0aCBhMiA9IDAgdGhlbiB1bnNhZmVfc3ViIGExIDAgbDFcbiAgZWxzZSBhcHBlbmRfcHJpbSBhMSBhMlxuXG5sZXQgc3ViIGEgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuc3ViXCJcbiAgZWxzZSB1bnNhZmVfc3ViIGEgb2ZzIGxlblxuXG5sZXQgZmlsbCBhIG9mcyBsZW4gdiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuZmlsbFwiXG4gIGVsc2UgdW5zYWZlX2ZpbGwgYSBvZnMgbGVuIHZcblxubGV0IGJsaXQgYTEgb2ZzMSBhMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IGxlbmd0aCBhMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggYTIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmJsaXRcIlxuICBlbHNlIHVuc2FmZV9ibGl0IGExIG9mczEgYTIgb2ZzMiBsZW5cblxubGV0IGl0ZXIgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbmxldCBpdGVyMiBmIGEgYiA9XG4gIGlmIGxlbmd0aCBhIDw+IGxlbmd0aCBiIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkFycmF5Lml0ZXIyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gIGVsc2VcbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpIGRvbmVcblxubGV0IG1hcCBmIGEgPVxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCAoZih1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgZm9yIGkgPSAxIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZih1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgbWFwMiBmIGEgYiA9XG4gIGxldCBsYSA9IGxlbmd0aCBhIGluXG4gIGxldCBsYiA9IGxlbmd0aCBiIGluXG4gIGlmIGxhIDw+IGxiIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkFycmF5Lm1hcDI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgZWxzZSBiZWdpblxuICAgIGlmIGxhID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgICAgbGV0IHIgPSBjcmVhdGUgbGEgKGYgKHVuc2FmZV9nZXQgYSAwKSAodW5zYWZlX2dldCBiIDApKSBpblxuICAgICAgZm9yIGkgPSAxIHRvIGxhIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkpXG4gICAgICBkb25lO1xuICAgICAgclxuICAgIGVuZFxuICBlbmRcblxubGV0IGl0ZXJpIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgbWFwaSBmIGEgPVxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCAoZiAwICh1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgZm9yIGkgPSAxIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgdG9fbGlzdCBhID1cbiAgbGV0IHJlYyB0b2xpc3QgaSByZXMgPVxuICAgIGlmIGkgPCAwIHRoZW4gcmVzIGVsc2UgdG9saXN0IChpIC0gMSkgKHVuc2FmZV9nZXQgYSBpIDo6IHJlcykgaW5cbiAgdG9saXN0IChsZW5ndGggYSAtIDEpIFtdXG5cbigqIENhbm5vdCB1c2UgTGlzdC5sZW5ndGggaGVyZSBiZWNhdXNlIHRoZSBMaXN0IG1vZHVsZSBkZXBlbmRzIG9uIEFycmF5LiAqKVxubGV0IHJlYyBsaXN0X2xlbmd0aCBhY2N1ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2N1XG4gIHwgXzo6dCAtPiBsaXN0X2xlbmd0aCAoc3VjYyBhY2N1KSB0XG5cbmxldCBvZl9saXN0ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbfHxdXG4gIHwgaGQ6OnRsIGFzIGwgLT5cbiAgICAgIGxldCBhID0gY3JlYXRlIChsaXN0X2xlbmd0aCAwIGwpIGhkIGluXG4gICAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICAgICAgW10gLT4gYVxuICAgICAgICB8IGhkOjp0bCAtPiB1bnNhZmVfc2V0IGEgaSBoZDsgZmlsbCAoaSsxKSB0bCBpblxuICAgICAgZmlsbCAxIHRsXG5cbmxldCBmb2xkX2xlZnQgZiB4IGEgPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgYSBpKVxuICBkb25lO1xuICAhclxuXG5sZXQgZm9sZF9sZWZ0X21hcCBmIGFjYyBpbnB1dF9hcnJheSA9XG4gIGxldCBsZW4gPSBsZW5ndGggaW5wdXRfYXJyYXkgaW5cbiAgaWYgbGVuID0gMCB0aGVuIChhY2MsIFt8fF0pIGVsc2UgYmVnaW5cbiAgICBsZXQgYWNjLCBlbHQgPSBmIGFjYyAodW5zYWZlX2dldCBpbnB1dF9hcnJheSAwKSBpblxuICAgIGxldCBvdXRwdXRfYXJyYXkgPSBjcmVhdGUgbGVuIGVsdCBpblxuICAgIGxldCBhY2MgPSByZWYgYWNjIGluXG4gICAgZm9yIGkgPSAxIHRvIGxlbiAtIDEgZG9cbiAgICAgIGxldCBhY2MnLCBlbHQgPSBmICFhY2MgKHVuc2FmZV9nZXQgaW5wdXRfYXJyYXkgaSkgaW5cbiAgICAgIGFjYyA6PSBhY2MnO1xuICAgICAgdW5zYWZlX3NldCBvdXRwdXRfYXJyYXkgaSBlbHQ7XG4gICAgZG9uZTtcbiAgICAhYWNjLCBvdXRwdXRfYXJyYXlcbiAgZW5kXG5cbmxldCBmb2xkX3JpZ2h0IGYgYSB4ID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IGxlbmd0aCBhIC0gMSBkb3dudG8gMCBkb1xuICAgIHIgOj0gZiAodW5zYWZlX2dldCBhIGkpICFyXG4gIGRvbmU7XG4gICFyXG5cbmxldCBleGlzdHMgcCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IGZvcl9hbGwgcCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiBsb29wIChzdWNjIGkpXG4gICAgZWxzZSBmYWxzZSBpblxuICBsb29wIDBcblxubGV0IGZvcl9hbGwyIHAgbDEgbDIgPVxuICBsZXQgbjEgPSBsZW5ndGggbDFcbiAgYW5kIG4yID0gbGVuZ3RoIGwyIGluXG4gIGlmIG4xIDw+IG4yIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5mb3JfYWxsMlwiXG4gIGVsc2UgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuMSB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgbDEgaSkgKHVuc2FmZV9nZXQgbDIgaSkgdGhlbiBsb29wIChzdWNjIGkpXG4gICAgZWxzZSBmYWxzZSBpblxuICBsb29wIDBcblxubGV0IGV4aXN0czIgcCBsMSBsMiA9XG4gIGxldCBuMSA9IGxlbmd0aCBsMVxuICBhbmQgbjIgPSBsZW5ndGggbDIgaW5cbiAgaWYgbjEgPD4gbjIgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmV4aXN0czJcIlxuICBlbHNlIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbjEgdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBsMSBpKSAodW5zYWZlX2dldCBsMiBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBtZW0geCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgY29tcGFyZSAodW5zYWZlX2dldCBhIGkpIHggPSAwIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IG1lbXEgeCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgeCA9PSAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IGZpbmRfb3B0IHAgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gTm9uZVxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgIGlmIHAgeCB0aGVuIFNvbWUgeFxuICAgICAgZWxzZSBsb29wIChzdWNjIGkpXG4gIGluXG4gIGxvb3AgMFxuXG5sZXQgZmluZF9tYXAgZiBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBOb25lXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggZiAodW5zYWZlX2dldCBhIGkpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBsb29wIChzdWNjIGkpXG4gICAgICB8IFNvbWUgXyBhcyByIC0+IHJcbiAgaW5cbiAgbG9vcCAwXG5cbmxldCBzcGxpdCB4ID1cbiAgaWYgeCA9IFt8fF0gdGhlbiBbfHxdLCBbfHxdXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgYTAsIGIwID0gdW5zYWZlX2dldCB4IDAgaW5cbiAgICBsZXQgbiA9IGxlbmd0aCB4IGluXG4gICAgbGV0IGEgPSBjcmVhdGUgbiBhMCBpblxuICAgIGxldCBiID0gY3JlYXRlIG4gYjAgaW5cbiAgICBmb3IgaSA9IDEgdG8gbiAtIDEgZG9cbiAgICAgIGxldCBhaSwgYmkgPSB1bnNhZmVfZ2V0IHggaSBpblxuICAgICAgdW5zYWZlX3NldCBhIGkgYWk7XG4gICAgICB1bnNhZmVfc2V0IGIgaSBiaVxuICAgIGRvbmU7XG4gICAgYSwgYlxuICBlbmRcblxubGV0IGNvbWJpbmUgYSBiID1cbiAgbGV0IG5hID0gbGVuZ3RoIGEgaW5cbiAgbGV0IG5iID0gbGVuZ3RoIGIgaW5cbiAgaWYgbmEgPD4gbmIgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmNvbWJpbmVcIjtcbiAgaWYgbmEgPSAwIHRoZW4gW3x8XVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IHggPSBjcmVhdGUgbmEgKHVuc2FmZV9nZXQgYSAwLCB1bnNhZmVfZ2V0IGIgMCkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbmEgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHggaSAodW5zYWZlX2dldCBhIGksIHVuc2FmZV9nZXQgYiBpKVxuICAgIGRvbmU7XG4gICAgeFxuICBlbmRcblxuZXhjZXB0aW9uIEJvdHRvbSBvZiBpbnRcbmxldCBzb3J0IGNtcCBhID1cbiAgbGV0IG1heHNvbiBsIGkgPVxuICAgIGxldCBpMzEgPSBpK2kraSsxIGluXG4gICAgbGV0IHggPSByZWYgaTMxIGluXG4gICAgaWYgaTMxKzIgPCBsIHRoZW4gYmVnaW5cbiAgICAgIGlmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwIHRoZW4geCA6PSBpMzErMTtcbiAgICAgIGlmIGNtcCAoZ2V0IGEgIXgpIChnZXQgYSAoaTMxKzIpKSA8IDAgdGhlbiB4IDo9IGkzMSsyO1xuICAgICAgIXhcbiAgICBlbmQgZWxzZVxuICAgICAgaWYgaTMxKzEgPCBsICYmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwXG4gICAgICB0aGVuIGkzMSsxXG4gICAgICBlbHNlIGlmIGkzMSA8IGwgdGhlbiBpMzEgZWxzZSByYWlzZSAoQm90dG9tIGkpXG4gIGluXG4gIGxldCByZWMgdHJpY2tsZWRvd24gbCBpIGUgPVxuICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgIGlmIGNtcCAoZ2V0IGEgaikgZSA+IDAgdGhlbiBiZWdpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICB0cmlja2xlZG93biBsIGogZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgc2V0IGEgaSBlO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IHRyaWNrbGUgbCBpIGUgPSB0cnkgdHJpY2tsZWRvd24gbCBpIGUgd2l0aCBCb3R0b20gaSAtPiBzZXQgYSBpIGUgaW5cbiAgbGV0IHJlYyBidWJibGVkb3duIGwgaSA9XG4gICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgYnViYmxlZG93biBsIGpcbiAgaW5cbiAgbGV0IGJ1YmJsZSBsIGkgPSB0cnkgYnViYmxlZG93biBsIGkgd2l0aCBCb3R0b20gaSAtPiBpIGluXG4gIGxldCByZWMgdHJpY2tsZXVwIGkgZSA9XG4gICAgbGV0IGZhdGhlciA9IChpIC0gMSkgLyAzIGluXG4gICAgYXNzZXJ0IChpIDw+IGZhdGhlcik7XG4gICAgaWYgY21wIChnZXQgYSBmYXRoZXIpIGUgPCAwIHRoZW4gYmVnaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGZhdGhlcik7XG4gICAgICBpZiBmYXRoZXIgPiAwIHRoZW4gdHJpY2tsZXVwIGZhdGhlciBlIGVsc2Ugc2V0IGEgMCBlO1xuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICBzZXQgYSBpIGU7XG4gICAgZW5kO1xuICBpblxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGZvciBpID0gKGwgKyAxKSAvIDMgLSAxIGRvd250byAwIGRvIHRyaWNrbGUgbCBpIChnZXQgYSBpKTsgZG9uZTtcbiAgZm9yIGkgPSBsIC0gMSBkb3dudG8gMiBkb1xuICAgIGxldCBlID0gKGdldCBhIGkpIGluXG4gICAgc2V0IGEgaSAoZ2V0IGEgMCk7XG4gICAgdHJpY2tsZXVwIChidWJibGUgaSAwKSBlO1xuICBkb25lO1xuICBpZiBsID4gMSB0aGVuIChsZXQgZSA9IChnZXQgYSAxKSBpbiBzZXQgYSAxIChnZXQgYSAwKTsgc2V0IGEgMCBlKVxuXG5cbmxldCBjdXRvZmYgPSA1XG5sZXQgc3RhYmxlX3NvcnQgY21wIGEgPVxuICBsZXQgbWVyZ2Ugc3JjMW9mcyBzcmMxbGVuIHNyYzIgc3JjMm9mcyBzcmMybGVuIGRzdCBkc3RvZnMgPVxuICAgIGxldCBzcmMxciA9IHNyYzFvZnMgKyBzcmMxbGVuIGFuZCBzcmMyciA9IHNyYzJvZnMgKyBzcmMybGVuIGluXG4gICAgbGV0IHJlYyBsb29wIGkxIHMxIGkyIHMyIGQgPVxuICAgICAgaWYgY21wIHMxIHMyIDw9IDAgdGhlbiBiZWdpblxuICAgICAgICBzZXQgZHN0IGQgczE7XG4gICAgICAgIGxldCBpMSA9IGkxICsgMSBpblxuICAgICAgICBpZiBpMSA8IHNyYzFyIHRoZW5cbiAgICAgICAgICBsb29wIGkxIChnZXQgYSBpMSkgaTIgczIgKGQgKyAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYmxpdCBzcmMyIGkyIGRzdCAoZCArIDEpIChzcmMyciAtIGkyKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGRzdCBkIHMyO1xuICAgICAgICBsZXQgaTIgPSBpMiArIDEgaW5cbiAgICAgICAgaWYgaTIgPCBzcmMyciB0aGVuXG4gICAgICAgICAgbG9vcCBpMSBzMSBpMiAoZ2V0IHNyYzIgaTIpIChkICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJsaXQgYSBpMSBkc3QgKGQgKyAxKSAoc3JjMXIgLSBpMSlcbiAgICAgIGVuZFxuICAgIGluIGxvb3Agc3JjMW9mcyAoZ2V0IGEgc3JjMW9mcykgc3JjMm9mcyAoZ2V0IHNyYzIgc3JjMm9mcykgZHN0b2ZzO1xuICBpblxuICBsZXQgaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICBsZXQgZSA9IChnZXQgYSAoc3Jjb2ZzICsgaSkpIGluXG4gICAgICBsZXQgaiA9IHJlZiAoZHN0b2ZzICsgaSAtIDEpIGluXG4gICAgICB3aGlsZSAoIWogPj0gZHN0b2ZzICYmIGNtcCAoZ2V0IGRzdCAhaikgZSA+IDApIGRvXG4gICAgICAgIHNldCBkc3QgKCFqICsgMSkgKGdldCBkc3QgIWopO1xuICAgICAgICBkZWNyIGo7XG4gICAgICBkb25lO1xuICAgICAgc2V0IGRzdCAoIWogKyAxKSBlO1xuICAgIGRvbmU7XG4gIGluXG4gIGxldCByZWMgc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiA9XG4gICAgaWYgbGVuIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuIGVsc2UgYmVnaW5cbiAgICAgIGxldCBsMSA9IGxlbiAvIDIgaW5cbiAgICAgIGxldCBsMiA9IGxlbiAtIGwxIGluXG4gICAgICBzb3J0dG8gKHNyY29mcyArIGwxKSBkc3QgKGRzdG9mcyArIGwxKSBsMjtcbiAgICAgIHNvcnR0byBzcmNvZnMgYSAoc3Jjb2ZzICsgbDIpIGwxO1xuICAgICAgbWVyZ2UgKHNyY29mcyArIGwyKSBsMSBkc3QgKGRzdG9mcyArIGwxKSBsMiBkc3QgZHN0b2ZzO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gMCBhIDAgbCBlbHNlIGJlZ2luXG4gICAgbGV0IGwxID0gbCAvIDIgaW5cbiAgICBsZXQgbDIgPSBsIC0gbDEgaW5cbiAgICBsZXQgdCA9IG1ha2UgbDIgKGdldCBhIDApIGluXG4gICAgc29ydHRvIGwxIHQgMCBsMjtcbiAgICBzb3J0dG8gMCBhIGwyIGwxO1xuICAgIG1lcmdlIGwyIGwxIHQgMCBsMiBhIDA7XG4gIGVuZFxuXG5cbmxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIGEgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICB0aGVuXG4gICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICAgIGVsc2UgU2VxLk5pbFxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBhID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgdGhlblxuICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gICAgZWxzZSBTZXEuTmlsXG4gIGluXG4gIGF1eCAwXG5cbmxldCBvZl9yZXZfbGlzdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW3x8XVxuICB8IGhkOjp0bCBhcyBsIC0+XG4gICAgICBsZXQgbGVuID0gbGlzdF9sZW5ndGggMCBsIGluXG4gICAgICBsZXQgYSA9IGNyZWF0ZSBsZW4gaGQgaW5cbiAgICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgICAgICBbXSAtPiBhXG4gICAgICAgIHwgaGQ6OnRsIC0+IHVuc2FmZV9zZXQgYSBpIGhkOyBmaWxsIChpLTEpIHRsXG4gICAgICBpblxuICAgICAgZmlsbCAobGVuLTIpIHRsXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCBsID0gU2VxLmZvbGRfbGVmdCAoZnVuIGFjYyB4IC0+IHg6OmFjYykgW10gaSBpblxuICBvZl9yZXZfbGlzdCBsXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbSW50MzJdOiAzMi1iaXQgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnIDogaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9uZWdcIlxuZXh0ZXJuYWwgYWRkIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9hZGRcIlxuZXh0ZXJuYWwgc3ViIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9zdWJcIlxuZXh0ZXJuYWwgbXVsIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9tdWxcIlxuZXh0ZXJuYWwgZGl2IDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9kaXZcIlxuZXh0ZXJuYWwgcmVtIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9hbmRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX29yXCJcbmV4dGVybmFsIGxvZ3hvciA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDMyIC0+IGludCAtPiBpbnQzMiA9IFwiJWludDMyX2xzclwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogaW50MzIgLT4gaW50ID0gXCIlaW50MzJfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50MzJcbiAgPSBcImNhbWxfaW50MzJfb2ZfZmxvYXRcIiBcImNhbWxfaW50MzJfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDMyIC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDMyX3RvX2Zsb2F0XCIgXCJjYW1sX2ludDMyX3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYml0c19vZl9mbG9hdCA6IGZsb2F0IC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRcIiBcImNhbWxfaW50MzJfYml0c19vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQzMiAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbmxldCB6ZXJvID0gMGxcbmxldCBvbmUgPSAxbFxubGV0IG1pbnVzX29uZSA9IC0xbFxubGV0IHN1Y2MgbiA9IGFkZCBuIDFsXG5sZXQgcHJlZCBuID0gc3ViIG4gMWxcbmxldCBhYnMgbiA9IGlmIG4gPj0gMGwgdGhlbiBuIGVsc2UgbmVnIG5cbmxldCBtaW5faW50ID0gMHg4MDAwMDAwMGxcbmxldCBtYXhfaW50ID0gMHg3RkZGRkZGRmxcbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMWwpXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBtYXRjaCBTeXMud29yZF9zaXplIHdpdGhcbiAgfCAzMiAtPlxuICAgICAgbGV0IG1heF9pbnQgPSBvZl9pbnQgU3RkbGliLm1heF9pbnQgaW5cbiAgICAgIGZ1biBuIC0+XG4gICAgICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICAgICAgU29tZSAodG9faW50IG4pXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBOb25lXG4gIHwgNjQgLT5cbiAgICAgICgqIFNvIHRoYXQgaXQgY29tcGlsZXMgaW4gMzItYml0ICopXG4gICAgICBsZXQgbWFzayA9IDB4RkZGRiBsc2wgMTYgbG9yIDB4RkZGRiBpblxuICAgICAgZnVuIG4gLT4gU29tZSAodG9faW50IG4gbGFuZCBtYXNrKVxuICB8IF8gLT5cbiAgICAgIGFzc2VydCBmYWxzZVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gaW50MzIgLT4gc3RyaW5nID0gXCJjYW1sX2ludDMyX2Zvcm1hdFwiXG5sZXQgdG9fc3RyaW5nIG4gPSBmb3JtYXQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDMyID0gXCJjYW1sX2ludDMyX29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG50eXBlIHQgPSBpbnQzMlxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5sZXQgZXF1YWwgKHg6IHQpICh5OiB0KSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXQgdW5zaWduZWRfY29tcGFyZSBuIG0gPVxuICBjb21wYXJlIChzdWIgbiBtaW5faW50KSAoc3ViIG0gbWluX2ludClcblxubGV0IG1pbiB4IHkgOiB0ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmxldCBtYXggeCB5IDogdCA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5cbigqIFVuc2lnbmVkIGRpdmlzaW9uIGZyb20gc2lnbmVkIGRpdmlzaW9uIG9mIHRoZSBzYW1lXG4gICBiaXRuZXNzLiBTZWUgV2FycmVuIEpyLiwgSGVucnkgUy4gKDIwMTMpLiBIYWNrZXIncyBEZWxpZ2h0ICgyIGVkLiksIFNlYyA5LTMuXG4qKVxubGV0IHVuc2lnbmVkX2RpdiBuIGQgPVxuICBpZiBkIDwgemVybyB0aGVuXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSBuIGQgPCAwIHRoZW4gemVybyBlbHNlIG9uZVxuICBlbHNlXG4gICAgbGV0IHEgPSBzaGlmdF9sZWZ0IChkaXYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbiAxKSBkKSAxIGluXG4gICAgbGV0IHIgPSBzdWIgbiAobXVsIHEgZCkgaW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIHIgZCA+PSAwIHRoZW4gc3VjYyBxIGVsc2UgcVxuXG5sZXQgdW5zaWduZWRfcmVtIG4gZCA9XG4gIHN1YiBuIChtdWwgKHVuc2lnbmVkX2RpdiBuIGQpIGQpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbSW50NjRdOiA2NC1iaXQgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnIDogaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9uZWdcIlxuZXh0ZXJuYWwgYWRkIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hZGRcIlxuZXh0ZXJuYWwgc3ViIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9zdWJcIlxuZXh0ZXJuYWwgbXVsIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tdWxcIlxuZXh0ZXJuYWwgZGl2IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9kaXZcIlxuZXh0ZXJuYWwgcmVtIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X29yXCJcbmV4dGVybmFsIGxvZ3hvciA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzclwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogaW50NjQgLT4gaW50ID0gXCIlaW50NjRfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X3RvX2Zsb2F0XCIgXCJjYW1sX2ludDY0X3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgb2ZfaW50MzIgOiBpbnQzMiAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyIDogaW50NjQgLT4gaW50MzIgPSBcIiVpbnQ2NF90b19pbnQzMlwiXG5leHRlcm5hbCBvZl9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9uYXRpdmVpbnRcIlxuZXh0ZXJuYWwgdG9fbmF0aXZlaW50IDogaW50NjQgLT4gbmF0aXZlaW50ID0gXCIlaW50NjRfdG9fbmF0aXZlaW50XCJcblxubGV0IHplcm8gPSAwTFxubGV0IG9uZSA9IDFMXG5sZXQgbWludXNfb25lID0gLTFMXG5sZXQgc3VjYyBuID0gYWRkIG4gMUxcbmxldCBwcmVkIG4gPSBzdWIgbiAxTFxubGV0IGFicyBuID0gaWYgbiA+PSAwTCB0aGVuIG4gZWxzZSBuZWcgblxubGV0IG1pbl9pbnQgPSAweDgwMDAwMDAwMDAwMDAwMDBMXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZGRkZGRkZGRkxcbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMUwpXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICBmdW4gbiAtPlxuICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICBTb21lICh0b19pbnQgbilcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBpbnQ2NCAtPiBzdHJpbmcgPSBcImNhbWxfaW50NjRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjQgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cblxuXG5leHRlcm5hbCBiaXRzX29mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxudHlwZSB0ID0gaW50NjRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbmxldCBtaW4geCB5IDogdCA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA6IHQgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG4oKiBVbnNpZ25lZCBkaXZpc2lvbiBmcm9tIHNpZ25lZCBkaXZpc2lvbiBvZiB0aGUgc2FtZVxuICAgYml0bmVzcy4gU2VlIFdhcnJlbiBKci4sIEhlbnJ5IFMuICgyMDEzKS4gSGFja2VyJ3MgRGVsaWdodCAoMiBlZC4pLCBTZWMgOS0zLlxuKilcbmxldCB1bnNpZ25lZF9kaXYgbiBkID1cbiAgaWYgZCA8IHplcm8gdGhlblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgbiBkIDwgMCB0aGVuIHplcm8gZWxzZSBvbmVcbiAgZWxzZVxuICAgIGxldCBxID0gc2hpZnRfbGVmdCAoZGl2IChzaGlmdF9yaWdodF9sb2dpY2FsIG4gMSkgZCkgMSBpblxuICAgIGxldCByID0gc3ViIG4gKG11bCBxIGQpIGluXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSByIGQgPj0gMCB0aGVuIHN1Y2MgcSBlbHNlIHFcblxubGV0IHVuc2lnbmVkX3JlbSBuIGQgPVxuICBzdWIgbiAobXVsICh1bnNpZ25lZF9kaXYgbiBkKSBkKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW05hdGl2ZWludF06IHByb2Nlc3Nvci1uYXRpdmUgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X25lZ1wiXG5leHRlcm5hbCBhZGQ6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2FkZFwiXG5leHRlcm5hbCBzdWI6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X3N1YlwiXG5leHRlcm5hbCBtdWw6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X211bFwiXG5leHRlcm5hbCBkaXY6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2RpdlwiXG5leHRlcm5hbCByZW06IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X21vZFwiXG5leHRlcm5hbCBsb2dhbmQ6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2FuZFwiXG5leHRlcm5hbCBsb2dvcjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb3JcIlxuZXh0ZXJuYWwgbG9neG9yOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF94b3JcIlxuZXh0ZXJuYWwgc2hpZnRfbGVmdDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0OiBuYXRpdmVpbnQgLT4gaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbHNyXCJcbmV4dGVybmFsIG9mX2ludDogaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50OiBuYXRpdmVpbnQgLT4gaW50ID0gXCIlbmF0aXZlaW50X3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IG5hdGl2ZWludFxuICA9IFwiY2FtbF9uYXRpdmVpbnRfb2ZfZmxvYXRcIiBcImNhbWxfbmF0aXZlaW50X29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBuYXRpdmVpbnQgLT4gZmxvYXRcbiAgPSBcImNhbWxfbmF0aXZlaW50X3RvX2Zsb2F0XCIgXCJjYW1sX25hdGl2ZWludF90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG9mX2ludDMyOiBpbnQzMiAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb2ZfaW50MzJcIlxuZXh0ZXJuYWwgdG9faW50MzI6IG5hdGl2ZWludCAtPiBpbnQzMiA9IFwiJW5hdGl2ZWludF90b19pbnQzMlwiXG5cbmxldCB6ZXJvID0gMG5cbmxldCBvbmUgPSAxblxubGV0IG1pbnVzX29uZSA9IC0xblxubGV0IHN1Y2MgbiA9IGFkZCBuIDFuXG5sZXQgcHJlZCBuID0gc3ViIG4gMW5cbmxldCBhYnMgbiA9IGlmIG4gPj0gMG4gdGhlbiBuIGVsc2UgbmVnIG5cbmxldCBzaXplID0gU3lzLndvcmRfc2l6ZVxubGV0IG1pbl9pbnQgPSBzaGlmdF9sZWZ0IDFuIChzaXplIC0gMSlcbmxldCBtYXhfaW50ID0gc3ViIG1pbl9pbnQgMW5cbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMW4pXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICBmdW4gbiAtPlxuICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICBTb21lICh0b19pbnQgbilcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBuYXRpdmVpbnQgLT4gc3RyaW5nID0gXCJjYW1sX25hdGl2ZWludF9mb3JtYXRcIlxubGV0IHRvX3N0cmluZyBuID0gZm9ybWF0IFwiJWRcIiBuXG5cbmV4dGVybmFsIG9mX3N0cmluZzogc3RyaW5nIC0+IG5hdGl2ZWludCA9IFwiY2FtbF9uYXRpdmVpbnRfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbnR5cGUgdCA9IG5hdGl2ZWludFxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5sZXQgZXF1YWwgKHg6IHQpICh5OiB0KSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXQgdW5zaWduZWRfY29tcGFyZSBuIG0gPVxuICBjb21wYXJlIChzdWIgbiBtaW5faW50KSAoc3ViIG0gbWluX2ludClcblxubGV0IG1pbiB4IHkgOiB0ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmxldCBtYXggeCB5IDogdCA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5cbigqIFVuc2lnbmVkIGRpdmlzaW9uIGZyb20gc2lnbmVkIGRpdmlzaW9uIG9mIHRoZSBzYW1lXG4gICBiaXRuZXNzLiBTZWUgV2FycmVuIEpyLiwgSGVucnkgUy4gKDIwMTMpLiBIYWNrZXIncyBEZWxpZ2h0ICgyIGVkLiksIFNlYyA5LTMuXG4qKVxubGV0IHVuc2lnbmVkX2RpdiBuIGQgPVxuICBpZiBkIDwgemVybyB0aGVuXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSBuIGQgPCAwIHRoZW4gemVybyBlbHNlIG9uZVxuICBlbHNlXG4gICAgbGV0IHEgPSBzaGlmdF9sZWZ0IChkaXYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbiAxKSBkKSAxIGluXG4gICAgbGV0IHIgPSBzdWIgbiAobXVsIHEgZCkgaW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIHIgZCA+PSAwIHRoZW4gc3VjYyBxIGVsc2UgcVxuXG5sZXQgdW5zaWduZWRfcmVtIG4gZCA9XG4gIHN1YiBuIChtdWwgKHVuc2lnbmVkX2RpdiBuIGQpIGQpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFNldHMgb3ZlciBvcmRlcmVkIHR5cGVzICopXG5cbm1vZHVsZSB0eXBlIE9yZGVyZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuICBzaWdcbiAgICB0eXBlIGVsdFxuICAgIHR5cGUgdFxuICAgIHZhbCBlbXB0eTogdFxuICAgIHZhbCBpc19lbXB0eTogdCAtPiBib29sXG4gICAgdmFsIG1lbTogZWx0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBhZGQ6IGVsdCAtPiB0IC0+IHRcbiAgICB2YWwgc2luZ2xldG9uOiBlbHQgLT4gdFxuICAgIHZhbCByZW1vdmU6IGVsdCAtPiB0IC0+IHRcbiAgICB2YWwgdW5pb246IHQgLT4gdCAtPiB0XG4gICAgdmFsIGludGVyOiB0IC0+IHQgLT4gdFxuICAgIHZhbCBkaXNqb2ludDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgZGlmZjogdCAtPiB0IC0+IHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgc3Vic2V0OiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBpdGVyOiAoZWx0IC0+IHVuaXQpIC0+IHQgLT4gdW5pdFxuICAgIHZhbCBtYXA6IChlbHQgLT4gZWx0KSAtPiB0IC0+IHRcbiAgICB2YWwgZm9sZDogKGVsdCAtPiAnYSAtPiAnYSkgLT4gdCAtPiAnYSAtPiAnYVxuICAgIHZhbCBmb3JfYWxsOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gYm9vbFxuICAgIHZhbCBleGlzdHM6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBib29sXG4gICAgdmFsIGZpbHRlcjogKGVsdCAtPiBib29sKSAtPiB0IC0+IHRcbiAgICB2YWwgZmlsdGVyX21hcDogKGVsdCAtPiBlbHQgb3B0aW9uKSAtPiB0IC0+IHRcbiAgICB2YWwgcGFydGl0aW9uOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gdCAqIHRcbiAgICB2YWwgY2FyZGluYWw6IHQgLT4gaW50XG4gICAgdmFsIGVsZW1lbnRzOiB0IC0+IGVsdCBsaXN0XG4gICAgdmFsIG1pbl9lbHQ6IHQgLT4gZWx0XG4gICAgdmFsIG1pbl9lbHRfb3B0OiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgbWF4X2VsdDogdCAtPiBlbHRcbiAgICB2YWwgbWF4X2VsdF9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBjaG9vc2U6IHQgLT4gZWx0XG4gICAgdmFsIGNob29zZV9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBzcGxpdDogZWx0IC0+IHQgLT4gdCAqIGJvb2wgKiB0XG4gICAgdmFsIGZpbmQ6IGVsdCAtPiB0IC0+IGVsdFxuICAgIHZhbCBmaW5kX29wdDogZWx0IC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBmaW5kX2ZpcnN0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0XG4gICAgdmFsIGZpbmRfZmlyc3Rfb3B0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBmaW5kX2xhc3Q6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHRcbiAgICB2YWwgZmluZF9sYXN0X29wdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgb2ZfbGlzdDogZWx0IGxpc3QgLT4gdFxuICAgIHZhbCB0b19zZXFfZnJvbSA6IGVsdCAtPiB0IC0+IGVsdCBTZXEudFxuICAgIHZhbCB0b19zZXEgOiB0IC0+IGVsdCBTZXEudFxuICAgIHZhbCB0b19yZXZfc2VxIDogdCAtPiBlbHQgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6IGVsdCBTZXEudCAtPiB0IC0+IHRcbiAgICB2YWwgb2Zfc2VxIDogZWx0IFNlcS50IC0+IHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKE9yZDogT3JkZXJlZFR5cGUpID1cbiAgc3RydWN0XG4gICAgdHlwZSBlbHQgPSBPcmQudFxuICAgIHR5cGUgdCA9IEVtcHR5IHwgTm9kZSBvZiB7bDp0OyB2OmVsdDsgcjp0OyBoOmludH1cblxuICAgICgqIFNldHMgYXJlIHJlcHJlc2VudGVkIGJ5IGJhbGFuY2VkIGJpbmFyeSB0cmVlcyAodGhlIGhlaWdodHMgb2YgdGhlXG4gICAgICAgY2hpbGRyZW4gZGlmZmVyIGJ5IGF0IG1vc3QgMiAqKVxuXG4gICAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7aH0gLT4gaFxuXG4gICAgKCogQ3JlYXRlcyBhIG5ldyBub2RlIHdpdGggbGVmdCBzb24gbCwgdmFsdWUgdiBhbmQgcmlnaHQgc29uIHIuXG4gICAgICAgV2UgbXVzdCBoYXZlIGFsbCBlbGVtZW50cyBvZiBsIDwgdiA8IGFsbCBlbGVtZW50cyBvZiByLlxuICAgICAgIGwgYW5kIHIgbXVzdCBiZSBiYWxhbmNlZCBhbmQgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMi5cbiAgICAgICBJbmxpbmUgZXhwYW5zaW9uIG9mIGhlaWdodCBmb3IgYmV0dGVyIHNwZWVkLiAqKVxuXG4gICAgbGV0IGNyZWF0ZSBsIHYgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgTm9kZXtsOyB2OyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSwgYnV0IHBlcmZvcm1zIG9uZSBzdGVwIG9mIHJlYmFsYW5jaW5nIGlmIG5lY2Vzc2FyeS5cbiAgICAgICBBc3N1bWVzIGwgYW5kIHIgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDMuXG4gICAgICAgSW5saW5lIGV4cGFuc2lvbiBvZiBjcmVhdGUgZm9yIGJldHRlciBzcGVlZCBpbiB0aGUgbW9zdCBmcmVxdWVudCBjYXNlXG4gICAgICAgd2hlcmUgbm8gcmViYWxhbmNpbmcgaXMgcmVxdWlyZWQuICopXG5cbiAgICBsZXQgYmFsIGwgdiByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBpZiBobCA+IGhyICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPWxsOyB2PWx2OyByPWxyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsciB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSBsbCBsdiAoY3JlYXRlIGxyIHYgcilcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPWxybDsgdj1scnY7IHI9bHJyfS0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBscmwpIGxydiAoY3JlYXRlIGxyciB2IHIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlIGlmIGhyID4gaGwgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9cmw7IHY9cnY7IHI9cnJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB2IHJsKSBydiByclxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9cmxsOyB2PXJsdjsgcj1ybHJ9IC0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHYgcmxsKSBybHYgKGNyZWF0ZSBybHIgcnYgcnIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIE5vZGV7bDsgdjsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgKCogSW5zZXJ0aW9uIG9mIG9uZSBlbGVtZW50ICopXG5cbiAgICBsZXQgcmVjIGFkZCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9kZXtsPUVtcHR5OyB2PXg7IHI9RW1wdHk7IGg9MX1cbiAgICAgIHwgTm9kZXtsOyB2OyByfSBhcyB0IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIHQgZWxzZVxuICAgICAgICAgIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IGFkZCB4IGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiB0IGVsc2UgYmFsIGxsIHYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IGFkZCB4IHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiB0IGVsc2UgYmFsIGwgdiByclxuXG4gICAgbGV0IHNpbmdsZXRvbiB4ID0gTm9kZXtsPUVtcHR5OyB2PXg7IHI9RW1wdHk7IGg9MX1cblxuICAgICgqIEJld2FyZTogdGhvc2UgdHdvIGZ1bmN0aW9ucyBhc3N1bWUgdGhhdCB0aGUgYWRkZWQgdiBpcyAqc3RyaWN0bHkqXG4gICAgICAgc21hbGxlciAob3IgYmlnZ2VyKSB0aGFuIGFsbCB0aGUgcHJlc2VudCBlbGVtZW50cyBpbiB0aGUgdHJlZTsgaXRcbiAgICAgICBkb2VzIG5vdCB0ZXN0IGZvciBlcXVhbGl0eSB3aXRoIHRoZSBjdXJyZW50IG1pbiAob3IgbWF4KSBlbGVtZW50LlxuICAgICAgIEluZGVlZCwgdGhleSBhcmUgb25seSB1c2VkIGR1cmluZyB0aGUgXCJqb2luXCIgb3BlcmF0aW9uIHdoaWNoXG4gICAgICAgcmVzcGVjdHMgdGhpcyBwcmVjb25kaXRpb24uXG4gICAgKilcblxuICAgIGxldCByZWMgYWRkX21pbl9lbGVtZW50IHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24geFxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICBiYWwgKGFkZF9taW5fZWxlbWVudCB4IGwpIHYgclxuXG4gICAgbGV0IHJlYyBhZGRfbWF4X2VsZW1lbnQgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiB4XG4gICAgICB8IE5vZGUge2w7IHY7IHJ9IC0+XG4gICAgICAgIGJhbCBsIHYgKGFkZF9tYXhfZWxlbWVudCB4IHIpXG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSBhbmQgYmFsLCBidXQgbm8gYXNzdW1wdGlvbnMgYXJlIG1hZGUgb24gdGhlXG4gICAgICAgcmVsYXRpdmUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IHJlYyBqb2luIGwgdiByID1cbiAgICAgIG1hdGNoIChsLCByKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gYWRkX21pbl9lbGVtZW50IHYgclxuICAgICAgfCAoXywgRW1wdHkpIC0+IGFkZF9tYXhfZWxlbWVudCB2IGxcbiAgICAgIHwgKE5vZGV7bD1sbDsgdj1sdjsgcj1scjsgaD1saH0sIE5vZGV7bD1ybDsgdj1ydjsgcj1ycjsgaD1yaH0pIC0+XG4gICAgICAgICAgaWYgbGggPiByaCArIDIgdGhlbiBiYWwgbGwgbHYgKGpvaW4gbHIgdiByKSBlbHNlXG4gICAgICAgICAgaWYgcmggPiBsaCArIDIgdGhlbiBiYWwgKGpvaW4gbCB2IHJsKSBydiByciBlbHNlXG4gICAgICAgICAgY3JlYXRlIGwgdiByXG5cbiAgICAoKiBTbWFsbGVzdCBhbmQgZ3JlYXRlc3QgZWxlbWVudCBvZiBhIHNldCAqKVxuXG4gICAgbGV0IHJlYyBtaW5fZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bD1FbXB0eTsgdn0gLT4gdlxuICAgICAgfCBOb2Rle2x9IC0+IG1pbl9lbHQgbFxuXG4gICAgbGV0IHJlYyBtaW5fZWx0X29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXtsPUVtcHR5OyB2fSAtPiBTb21lIHZcbiAgICAgIHwgTm9kZXtsfSAtPiBtaW5fZWx0X29wdCBsXG5cbiAgICBsZXQgcmVjIG1heF9lbHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXt2OyByPUVtcHR5fSAtPiB2XG4gICAgICB8IE5vZGV7cn0gLT4gbWF4X2VsdCByXG5cbiAgICBsZXQgcmVjIG1heF9lbHRfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2Rle3Y7IHI9RW1wdHl9IC0+IFNvbWUgdlxuICAgICAgfCBOb2Rle3J9IC0+IG1heF9lbHRfb3B0IHJcblxuICAgICgqIFJlbW92ZSB0aGUgc21hbGxlc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gc2V0ICopXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9taW5fZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQucmVtb3ZlX21pbl9lbHRcIlxuICAgICAgfCBOb2Rle2w9RW1wdHk7IHJ9IC0+IHJcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBiYWwgKHJlbW92ZV9taW5fZWx0IGwpIHYgclxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIEFzc3VtZSB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAyLiAqKVxuXG4gICAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT4gYmFsIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgTm8gYXNzdW1wdGlvbiBvbiB0aGUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IGNvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IGpvaW4gdDEgKG1pbl9lbHQgdDIpIChyZW1vdmVfbWluX2VsdCB0MilcblxuICAgICgqIFNwbGl0dGluZy4gIHNwbGl0IHggcyByZXR1cm5zIGEgdHJpcGxlIChsLCBwcmVzZW50LCByKSB3aGVyZVxuICAgICAgICAtIGwgaXMgdGhlIHNldCBvZiBlbGVtZW50cyBvZiBzIHRoYXQgYXJlIDwgeFxuICAgICAgICAtIHIgaXMgdGhlIHNldCBvZiBlbGVtZW50cyBvZiBzIHRoYXQgYXJlID4geFxuICAgICAgICAtIHByZXNlbnQgaXMgZmFsc2UgaWYgcyBjb250YWlucyBubyBlbGVtZW50IGVxdWFsIHRvIHgsXG4gICAgICAgICAgb3IgdHJ1ZSBpZiBzIGNvbnRhaW5zIGFuIGVsZW1lbnQgZXF1YWwgdG8geC4gKilcblxuICAgIGxldCByZWMgc3BsaXQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKEVtcHR5LCBmYWxzZSwgRW1wdHkpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gKGwsIHRydWUsIHIpXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgKGxsLCBwcmVzLCBybCkgPSBzcGxpdCB4IGwgaW4gKGxsLCBwcmVzLCBqb2luIHJsIHYgcilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGxyLCBwcmVzLCBycikgPSBzcGxpdCB4IHIgaW4gKGpvaW4gbCB2IGxyLCBwcmVzLCBycilcblxuICAgICgqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBzZXQgb3BlcmF0aW9ucyAqKVxuXG4gICAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICAgIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uIEVtcHR5IC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgYyA9IDAgfHwgbWVtIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIHJlbW92ZSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bDsgdjsgcn0gYXMgdCkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgICBsZXQgbGwgPSByZW1vdmUgeCBsIGluXG4gICAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgYmFsIGxsIHYgclxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgcnIgPSByZW1vdmUgeCByIGluXG4gICAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgYmFsIGwgdiByclxuXG4gICAgbGV0IHJlYyB1bmlvbiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdDIpIC0+IHQyXG4gICAgICB8ICh0MSwgRW1wdHkpIC0+IHQxXG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjE7IGg9aDF9LCBOb2Rle2w9bDI7IHY9djI7IHI9cjI7IGg9aDJ9KSAtPlxuICAgICAgICAgIGlmIGgxID49IGgyIHRoZW5cbiAgICAgICAgICAgIGlmIGgyID0gMSB0aGVuIGFkZCB2MiBzMSBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIGxldCAobDIsIF8sIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgICAgIGpvaW4gKHVuaW9uIGwxIGwyKSB2MSAodW5pb24gcjEgcjIpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBoMSA9IDEgdGhlbiBhZGQgdjEgczIgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBsZXQgKGwxLCBfLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjIgKHVuaW9uIHIxIHIyKVxuICAgICAgICAgICAgZW5kXG5cbiAgICBsZXQgcmVjIGludGVyIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBFbXB0eVxuICAgICAgfCAoXywgRW1wdHkpIC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjF9LCB0MikgLT5cbiAgICAgICAgICBtYXRjaCBzcGxpdCB2MSB0MiB3aXRoXG4gICAgICAgICAgICAobDIsIGZhbHNlLCByMikgLT5cbiAgICAgICAgICAgICAgY29uY2F0IChpbnRlciBsMSBsMikgKGludGVyIHIxIHIyKVxuICAgICAgICAgIHwgKGwyLCB0cnVlLCByMikgLT5cbiAgICAgICAgICAgICAgam9pbiAoaW50ZXIgbDEgbDIpIHYxIChpbnRlciByMSByMilcblxuICAgICgqIFNhbWUgYXMgc3BsaXQsIGJ1dCBjb21wdXRlIHRoZSBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlc1xuICAgICAgIG9ubHkgaWYgdGhlIHBpdm90IGVsZW1lbnQgaXMgbm90IGluIHRoZSBzZXQuICBUaGUgcmlnaHQgc3VidHJlZVxuICAgICAgIGlzIGNvbXB1dGVkIG9uIGRlbWFuZC4gKilcblxuICAgIHR5cGUgc3BsaXRfYmlzID1cbiAgICAgIHwgRm91bmRcbiAgICAgIHwgTm90Rm91bmQgb2YgdCAqICh1bml0IC0+IHQpXG5cbiAgICBsZXQgcmVjIHNwbGl0X2JpcyB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb3RGb3VuZCAoRW1wdHksIChmdW4gKCkgLT4gRW1wdHkpKVxuICAgICAgfCBOb2Rle2w7IHY7IHI7IF99IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIEZvdW5kXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBtYXRjaCBzcGxpdF9iaXMgeCBsIHdpdGhcbiAgICAgICAgICAgIHwgRm91bmQgLT4gRm91bmRcbiAgICAgICAgICAgIHwgTm90Rm91bmQgKGxsLCBybCkgLT4gTm90Rm91bmQgKGxsLCAoZnVuICgpIC0+IGpvaW4gKHJsICgpKSB2IHIpKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1hdGNoIHNwbGl0X2JpcyB4IHIgd2l0aFxuICAgICAgICAgICAgfCBGb3VuZCAtPiBGb3VuZFxuICAgICAgICAgICAgfCBOb3RGb3VuZCAobHIsIHJyKSAtPiBOb3RGb3VuZCAoam9pbiBsIHYgbHIsIHJyKVxuXG4gICAgbGV0IHJlYyBkaXNqb2ludCBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgfCAoXywgRW1wdHkpIC0+IHRydWVcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMX0sIHQyKSAtPlxuICAgICAgICAgIGlmIHMxID09IHMyIHRoZW4gZmFsc2VcbiAgICAgICAgICBlbHNlIG1hdGNoIHNwbGl0X2JpcyB2MSB0MiB3aXRoXG4gICAgICAgICAgICAgIE5vdEZvdW5kKGwyLCByMikgLT4gZGlzam9pbnQgbDEgbDIgJiYgZGlzam9pbnQgcjEgKHIyICgpKVxuICAgICAgICAgICAgfCBGb3VuZCAtPiBmYWxzZVxuXG4gICAgbGV0IHJlYyBkaWZmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBFbXB0eVxuICAgICAgfCAodDEsIEVtcHR5KSAtPiB0MVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxfSwgdDIpIC0+XG4gICAgICAgICAgbWF0Y2ggc3BsaXQgdjEgdDIgd2l0aFxuICAgICAgICAgICAgKGwyLCBmYWxzZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGpvaW4gKGRpZmYgbDEgbDIpIHYxIChkaWZmIHIxIHIyKVxuICAgICAgICAgIHwgKGwyLCB0cnVlLCByMikgLT5cbiAgICAgICAgICAgICAgY29uY2F0IChkaWZmIGwxIGwyKSAoZGlmZiByMSByMilcblxuICAgIHR5cGUgZW51bWVyYXRpb24gPSBFbmQgfCBNb3JlIG9mIGVsdCAqIHQgKiBlbnVtZXJhdGlvblxuXG4gICAgbGV0IHJlYyBjb25zX2VudW0gcyBlID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgICBFbXB0eSAtPiBlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gY29uc19lbnVtIGwgKE1vcmUodiwgciwgZSkpXG5cbiAgICBsZXQgcmVjIGNvbXBhcmVfYXV4IGUxIGUyID1cbiAgICAgICAgbWF0Y2ggKGUxLCBlMikgd2l0aFxuICAgICAgICAoRW5kLCBFbmQpIC0+IDBcbiAgICAgIHwgKEVuZCwgXykgIC0+IC0xXG4gICAgICB8IChfLCBFbmQpIC0+IDFcbiAgICAgIHwgKE1vcmUodjEsIHIxLCBlMSksIE1vcmUodjIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPD4gMFxuICAgICAgICAgIHRoZW4gY1xuICAgICAgICAgIGVsc2UgY29tcGFyZV9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcblxuICAgIGxldCBjb21wYXJlIHMxIHMyID1cbiAgICAgIGNvbXBhcmVfYXV4IChjb25zX2VudW0gczEgRW5kKSAoY29uc19lbnVtIHMyIEVuZClcblxuICAgIGxldCBlcXVhbCBzMSBzMiA9XG4gICAgICBjb21wYXJlIHMxIHMyID0gMFxuXG4gICAgbGV0IHJlYyBzdWJzZXQgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICBFbXB0eSwgXyAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgXywgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBOb2RlIHtsPWwxOyB2PXYxOyByPXIxfSwgKE5vZGUge2w9bDI7IHY9djI7IHI9cjJ9IGFzIHQyKSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBzdWJzZXQgbDEgbDIgJiYgc3Vic2V0IHIxIHIyXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBzdWJzZXQgKE5vZGUge2w9bDE7IHY9djE7IHI9RW1wdHk7IGg9MH0pIGwyICYmIHN1YnNldCByMSB0MlxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN1YnNldCAoTm9kZSB7bD1FbXB0eTsgdj12MTsgcj1yMTsgaD0wfSkgcjIgJiYgc3Vic2V0IGwxIHQyXG5cbiAgICBsZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+ICgpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gaXRlciBmIGw7IGYgdjsgaXRlciBmIHJcblxuICAgIGxldCByZWMgZm9sZCBmIHMgYWNjdSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGZvbGQgZiByIChmIHYgKGZvbGQgZiBsIGFjY3UpKVxuXG4gICAgbGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiB0cnVlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gcCB2ICYmIGZvcl9hbGwgcCBsICYmIGZvcl9hbGwgcCByXG5cbiAgICBsZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBwIHYgfHwgZXhpc3RzIHAgbCB8fCBleGlzdHMgcCByXG5cbiAgICBsZXQgcmVjIGZpbHRlciBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bDsgdjsgcn0pIGFzIHQgLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCBsJyA9IGZpbHRlciBwIGwgaW5cbiAgICAgICAgICBsZXQgcHYgPSBwIHYgaW5cbiAgICAgICAgICBsZXQgcicgPSBmaWx0ZXIgcCByIGluXG4gICAgICAgICAgaWYgcHYgdGhlblxuICAgICAgICAgICAgaWYgbD09bCcgJiYgcj09cicgdGhlbiB0IGVsc2Ugam9pbiBsJyB2IHInXG4gICAgICAgICAgZWxzZSBjb25jYXQgbCcgcidcblxuICAgIGxldCByZWMgcGFydGl0aW9uIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoRW1wdHksIEVtcHR5KVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgKGx0LCBsZikgPSBwYXJ0aXRpb24gcCBsIGluXG4gICAgICAgICAgbGV0IHB2ID0gcCB2IGluXG4gICAgICAgICAgbGV0IChydCwgcmYpID0gcGFydGl0aW9uIHAgciBpblxuICAgICAgICAgIGlmIHB2XG4gICAgICAgICAgdGhlbiAoam9pbiBsdCB2IHJ0LCBjb25jYXQgbGYgcmYpXG4gICAgICAgICAgZWxzZSAoY29uY2F0IGx0IHJ0LCBqb2luIGxmIHYgcmYpXG5cbiAgICBsZXQgcmVjIGNhcmRpbmFsID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2Rle2w7IHJ9IC0+IGNhcmRpbmFsIGwgKyAxICsgY2FyZGluYWwgclxuXG4gICAgbGV0IHJlYyBlbGVtZW50c19hdXggYWNjdSA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBlbGVtZW50c19hdXggKHYgOjogZWxlbWVudHNfYXV4IGFjY3UgcikgbFxuXG4gICAgbGV0IGVsZW1lbnRzIHMgPVxuICAgICAgZWxlbWVudHNfYXV4IFtdIHNcblxuICAgIGxldCBjaG9vc2UgPSBtaW5fZWx0XG5cbiAgICBsZXQgY2hvb3NlX29wdCA9IG1pbl9lbHRfb3B0XG5cbiAgICBsZXQgcmVjIGZpbmQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIHZcbiAgICAgICAgICBlbHNlIGZpbmQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHRfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9sYXN0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdjAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBTb21lIHZcbiAgICAgICAgICBlbHNlIGZpbmRfb3B0IHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgdHJ5X2pvaW4gbCB2IHIgPVxuICAgICAgKCogW2pvaW4gbCB2IHJdIGNhbiBvbmx5IGJlIGNhbGxlZCB3aGVuIChlbGVtZW50cyBvZiBsIDwgdiA8XG4gICAgICAgICBlbGVtZW50cyBvZiByKTsgdXNlIFt0cnlfam9pbiBsIHYgcl0gd2hlbiB0aGlzIHByb3BlcnR5IG1heVxuICAgICAgICAgbm90IGhvbGQsIGJ1dCB5b3UgaG9wZSBpdCBkb2VzIGhvbGQgaW4gdGhlIGNvbW1vbiBjYXNlICopXG4gICAgICBpZiAobCA9IEVtcHR5IHx8IE9yZC5jb21wYXJlIChtYXhfZWx0IGwpIHYgPCAwKVxuICAgICAgJiYgKHIgPSBFbXB0eSB8fCBPcmQuY29tcGFyZSB2IChtaW5fZWx0IHIpIDwgMClcbiAgICAgIHRoZW4gam9pbiBsIHYgclxuICAgICAgZWxzZSB1bmlvbiBsIChhZGQgdiByKVxuXG4gICAgbGV0IHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gYXMgdCAtPlxuICAgICAgICAgKCogZW5mb3JjZSBsZWZ0LXRvLXJpZ2h0IGV2YWx1YXRpb24gb3JkZXIgKilcbiAgICAgICAgIGxldCBsJyA9IG1hcCBmIGwgaW5cbiAgICAgICAgIGxldCB2JyA9IGYgdiBpblxuICAgICAgICAgbGV0IHInID0gbWFwIGYgciBpblxuICAgICAgICAgaWYgbCA9PSBsJyAmJiB2ID09IHYnICYmIHIgPT0gcicgdGhlbiB0XG4gICAgICAgICBlbHNlIHRyeV9qb2luIGwnIHYnIHInXG5cbiAgICBsZXQgdHJ5X2NvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IHRyeV9qb2luIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICBsZXQgcmVjIGZpbHRlcl9tYXAgZiA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gYXMgdCAtPlxuICAgICAgICAgKCogZW5mb3JjZSBsZWZ0LXRvLXJpZ2h0IGV2YWx1YXRpb24gb3JkZXIgKilcbiAgICAgICAgIGxldCBsJyA9IGZpbHRlcl9tYXAgZiBsIGluXG4gICAgICAgICBsZXQgdicgPSBmIHYgaW5cbiAgICAgICAgIGxldCByJyA9IGZpbHRlcl9tYXAgZiByIGluXG4gICAgICAgICBiZWdpbiBtYXRjaCB2JyB3aXRoXG4gICAgICAgICAgIHwgU29tZSB2JyAtPlxuICAgICAgICAgICAgICBpZiBsID09IGwnICYmIHYgPT0gdicgJiYgciA9PSByJyB0aGVuIHRcbiAgICAgICAgICAgICAgZWxzZSB0cnlfam9pbiBsJyB2JyByJ1xuICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgdHJ5X2NvbmNhdCBsJyByJ1xuICAgICAgICAgZW5kXG5cbiAgICBsZXQgb2Zfc29ydGVkX2xpc3QgbCA9XG4gICAgICBsZXQgcmVjIHN1YiBuIGwgPVxuICAgICAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICAgICAgfCAwLCBsIC0+IEVtcHR5LCBsXG4gICAgICAgIHwgMSwgeDAgOjogbCAtPiBOb2RlIHtsPUVtcHR5OyB2PXgwOyByPUVtcHR5OyBoPTF9LCBsXG4gICAgICAgIHwgMiwgeDAgOjogeDEgOjogbCAtPlxuICAgICAgICAgICAgTm9kZXtsPU5vZGV7bD1FbXB0eTsgdj14MDsgcj1FbXB0eTsgaD0xfTsgdj14MTsgcj1FbXB0eTsgaD0yfSwgbFxuICAgICAgICB8IDMsIHgwIDo6IHgxIDo6IHgyIDo6IGwgLT5cbiAgICAgICAgICAgIE5vZGV7bD1Ob2Rle2w9RW1wdHk7IHY9eDA7IHI9RW1wdHk7IGg9MX07IHY9eDE7XG4gICAgICAgICAgICAgICAgIHI9Tm9kZXtsPUVtcHR5OyB2PXgyOyByPUVtcHR5OyBoPTF9OyBoPTJ9LCBsXG4gICAgICAgIHwgbiwgbCAtPlxuICAgICAgICAgIGxldCBubCA9IG4gLyAyIGluXG4gICAgICAgICAgbGV0IGxlZnQsIGwgPSBzdWIgbmwgbCBpblxuICAgICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBtaWQgOjogbCAtPlxuICAgICAgICAgICAgbGV0IHJpZ2h0LCBsID0gc3ViIChuIC0gbmwgLSAxKSBsIGluXG4gICAgICAgICAgICBjcmVhdGUgbGVmdCBtaWQgcmlnaHQsIGxcbiAgICAgIGluXG4gICAgICBmc3QgKHN1YiAoTGlzdC5sZW5ndGggbCkgbClcblxuICAgIGxldCBvZl9saXN0IGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IGVtcHR5XG4gICAgICB8IFt4MF0gLT4gc2luZ2xldG9uIHgwXG4gICAgICB8IFt4MDsgeDFdIC0+IGFkZCB4MSAoc2luZ2xldG9uIHgwKVxuICAgICAgfCBbeDA7IHgxOyB4Ml0gLT4gYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpXG4gICAgICB8IFt4MDsgeDE7IHgyOyB4M10gLT4gYWRkIHgzIChhZGQgeDIgKGFkZCB4MSAoc2luZ2xldG9uIHgwKSkpXG4gICAgICB8IFt4MDsgeDE7IHgyOyB4MzsgeDRdIC0+IGFkZCB4NCAoYWRkIHgzIChhZGQgeDIgKGFkZCB4MSAoc2luZ2xldG9uIHgwKSkpKVxuICAgICAgfCBfIC0+IG9mX3NvcnRlZF9saXN0IChMaXN0LnNvcnRfdW5pcSBPcmQuY29tcGFyZSBsKVxuXG4gICAgbGV0IGFkZF9zZXEgaSBtID1cbiAgICAgIFNlcS5mb2xkX2xlZnQgKGZ1biBzIHggLT4gYWRkIHggcykgbSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPSBhZGRfc2VxIGkgZW1wdHlcblxuICAgIGxldCByZWMgc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoeCwgdCwgcmVzdCkgLT4gU2VxLkNvbnMgKHgsIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIHQgcmVzdCkpXG5cbiAgICBsZXQgdG9fc2VxIGMgPSBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSBjIEVuZClcblxuICAgIGxldCByZWMgc25vY19lbnVtIHMgZSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IHNub2NfZW51bSByIChNb3JlKHYsIGwsIGUpKVxuXG4gICAgbGV0IHJlYyByZXZfc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoeCwgdCwgcmVzdCkgLT4gU2VxLkNvbnMgKHgsIHJldl9zZXFfb2ZfZW51bV8gKHNub2NfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3Jldl9zZXEgYyA9IHJldl9zZXFfb2ZfZW51bV8gKHNub2NfZW51bSBjIEVuZClcblxuICAgIGxldCB0b19zZXFfZnJvbSBsb3cgcyA9XG4gICAgICBsZXQgcmVjIGF1eCBsb3cgcyBjID0gbWF0Y2ggcyB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gY1xuICAgICAgICB8IE5vZGUge2w7IHI7IHY7IF99IC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBPcmQuY29tcGFyZSB2IGxvdyB3aXRoXG4gICAgICAgICAgICAgIHwgMCAtPiBNb3JlICh2LCByLCBjKVxuICAgICAgICAgICAgICB8IG4gd2hlbiBuPDAgLT4gYXV4IGxvdyByIGNcbiAgICAgICAgICAgICAgfCBfIC0+IGF1eCBsb3cgbCAoTW9yZSAodiwgciwgYykpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGluXG4gICAgICBzZXFfb2ZfZW51bV8gKGF1eCBsb3cgcyBFbmQpXG4gIGVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgdHlwZSBPcmRlcmVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICErJ2EgdFxuICAgIHZhbCBlbXB0eTogJ2EgdFxuICAgIHZhbCBpc19lbXB0eTogJ2EgdCAtPiBib29sXG4gICAgdmFsIG1lbTogIGtleSAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgYWRkOiBrZXkgLT4gJ2EgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIHVwZGF0ZToga2V5IC0+ICgnYSBvcHRpb24gLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgc2luZ2xldG9uOiBrZXkgLT4gJ2EgLT4gJ2EgdFxuICAgIHZhbCByZW1vdmU6IGtleSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgbWVyZ2U6XG4gICAgICAgICAgKGtleSAtPiAnYSBvcHRpb24gLT4gJ2Igb3B0aW9uIC0+ICdjIG9wdGlvbikgLT4gJ2EgdCAtPiAnYiB0IC0+ICdjIHRcbiAgICB2YWwgdW5pb246IChrZXkgLT4gJ2EgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBjb21wYXJlOiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgaXRlcjogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBmb3JfYWxsOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBleGlzdHM6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGZpbHRlcjogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgZmlsdGVyX21hcDogKGtleSAtPiAnYSAtPiAnYiBvcHRpb24pIC0+ICdhIHQgLT4gJ2IgdFxuICAgIHZhbCBwYXJ0aXRpb246IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0ICogJ2EgdFxuICAgIHZhbCBjYXJkaW5hbDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgYmluZGluZ3M6ICdhIHQgLT4gKGtleSAqICdhKSBsaXN0XG4gICAgdmFsIG1pbl9iaW5kaW5nOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgbWluX2JpbmRpbmdfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIG1heF9iaW5kaW5nOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgbWF4X2JpbmRpbmdfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIGNob29zZTogJ2EgdCAtPiAoa2V5ICogJ2EpXG4gICAgdmFsIGNob29zZV9vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgc3BsaXQ6IGtleSAtPiAnYSB0IC0+ICdhIHQgKiAnYSBvcHRpb24gKiAnYSB0XG4gICAgdmFsIGZpbmQ6IGtleSAtPiAnYSB0IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiBrZXkgLT4gJ2EgdCAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9maXJzdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IGtleSAqICdhXG4gICAgdmFsIGZpbmRfZmlyc3Rfb3B0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgZmluZF9sYXN0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4ga2V5ICogJ2FcbiAgICB2YWwgZmluZF9sYXN0X29wdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIG1hcDogKCdhIC0+ICdiKSAtPiAnYSB0IC0+ICdiIHRcbiAgICB2YWwgbWFwaTogKGtleSAtPiAnYSAtPiAnYikgLT4gJ2EgdCAtPiAnYiB0XG4gICAgdmFsIHRvX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCB0b19yZXZfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3NlcV9mcm9tIDoga2V5IC0+ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZShPcmQ6IE9yZGVyZWRUeXBlKSA9IHN0cnVjdFxuXG4gICAgdHlwZSBrZXkgPSBPcmQudFxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSBvZiB7bDonYSB0OyB2OmtleTsgZDonYTsgcjonYSB0OyBoOmludH1cblxuICAgIGxldCBoZWlnaHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGUge2h9IC0+IGhcblxuICAgIGxldCBjcmVhdGUgbCB4IGQgciA9XG4gICAgICBsZXQgaGwgPSBoZWlnaHQgbCBhbmQgaHIgPSBoZWlnaHQgciBpblxuICAgICAgTm9kZXtsOyB2PXg7IGQ7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgIGxldCBzaW5nbGV0b24geCBkID0gTm9kZXtsPUVtcHR5OyB2PXg7IGQ7IHI9RW1wdHk7IGg9MX1cblxuICAgIGxldCBiYWwgbCB4IGQgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgaWYgaGwgPiBociArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1sbDsgdj1sdjsgZD1sZDsgcj1scn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHIgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgbGwgbHYgbGQgKGNyZWF0ZSBsciB4IGQgcilcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPWxybDsgdj1scnY7IGQ9bHJkOyByPWxycn0tPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgbGQgbHJsKSBscnYgbHJkIChjcmVhdGUgbHJyIHggZCByKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZSBpZiBociA+IGhsICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPXJsOyB2PXJ2OyBkPXJkOyByPXJyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IHJyID49IGhlaWdodCBybCB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgeCBkIHJsKSBydiByZCByclxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9cmxsOyB2PXJsdjsgZD1ybGQ7IHI9cmxyfSAtPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB4IGQgcmxsKSBybHYgcmxkIChjcmVhdGUgcmxyIHJ2IHJkIHJyKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZVxuICAgICAgICBOb2Rle2w7IHY9eDsgZDsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICAgIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uIEVtcHR5IC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIGFkZCB4IGRhdGEgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vZGV7bD1FbXB0eTsgdj14OyBkPWRhdGE7IHI9RW1wdHk7IGg9MX1cbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gYXMgbSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgaWYgZCA9PSBkYXRhIHRoZW4gbSBlbHNlIE5vZGV7bDsgdj14OyBkPWRhdGE7IHI7IGh9XG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSBhZGQgeCBkYXRhIGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gYWRkIHggZGF0YSByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyBmaW5kIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBkXG4gICAgICAgICAgZWxzZSBmaW5kIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3RfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2MCBkMCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3QgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYwIGQwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHQgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2MCBkMCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3QgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGQwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHQgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfb3B0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gU29tZSBkXG4gICAgICAgICAgZWxzZSBmaW5kX29wdCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgTm9kZSB7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGMgPSAwIHx8IG1lbSB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBtaW5fYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsPUVtcHR5OyB2OyBkfSAtPiAodiwgZClcbiAgICAgIHwgTm9kZSB7bH0gLT4gbWluX2JpbmRpbmcgbFxuXG4gICAgbGV0IHJlYyBtaW5fYmluZGluZ19vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHY7IGR9IC0+IFNvbWUgKHYsIGQpXG4gICAgICB8IE5vZGUge2x9LT4gbWluX2JpbmRpbmdfb3B0IGxcblxuICAgIGxldCByZWMgbWF4X2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7djsgZDsgcj1FbXB0eX0gLT4gKHYsIGQpXG4gICAgICB8IE5vZGUge3J9IC0+IG1heF9iaW5kaW5nIHJcblxuICAgIGxldCByZWMgbWF4X2JpbmRpbmdfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2RlIHt2OyBkOyByPUVtcHR5fSAtPiBTb21lICh2LCBkKVxuICAgICAgfCBOb2RlIHtyfSAtPiBtYXhfYmluZGluZ19vcHQgclxuXG4gICAgbGV0IHJlYyByZW1vdmVfbWluX2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5yZW1vdmVfbWluX2VsdFwiXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHJ9IC0+IHJcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gYmFsIChyZW1vdmVfbWluX2JpbmRpbmcgbCkgdiBkIHJcblxuICAgIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+XG4gICAgICAgICAgbGV0ICh4LCBkKSA9IG1pbl9iaW5kaW5nIHQyIGluXG4gICAgICAgICAgYmFsIHQxIHggZCAocmVtb3ZlX21pbl9iaW5kaW5nIHQyKVxuXG4gICAgbGV0IHJlYyByZW1vdmUgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgKE5vZGUge2w7IHY7IGQ7IHJ9IGFzIG0pIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIG1lcmdlIGwgclxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gcmVtb3ZlIHggbCBpbiBpZiBsID09IGxsIHRoZW4gbSBlbHNlIGJhbCBsbCB2IGQgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IHJlbW92ZSB4IHIgaW4gaWYgciA9PSByciB0aGVuIG0gZWxzZSBiYWwgbCB2IGQgcnJcblxuICAgIGxldCByZWMgdXBkYXRlIHggZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggZiBOb25lIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gRW1wdHlcbiAgICAgICAgICB8IFNvbWUgZGF0YSAtPiBOb2Rle2w9RW1wdHk7IHY9eDsgZD1kYXRhOyByPUVtcHR5OyBoPTF9XG4gICAgICAgICAgZW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IGFzIG0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIG1hdGNoIGYgKFNvbWUgZCkgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IG1lcmdlIGwgclxuICAgICAgICAgICAgfCBTb21lIGRhdGEgLT5cbiAgICAgICAgICAgICAgICBpZiBkID09IGRhdGEgdGhlbiBtIGVsc2UgTm9kZXtsOyB2PXg7IGQ9ZGF0YTsgcjsgaH1cbiAgICAgICAgICBlbmQgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSB1cGRhdGUgeCBmIGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gdXBkYXRlIHggZiByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGl0ZXIgZiBsOyBmIHYgZDsgaXRlciBmIHJcblxuICAgIGxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IC0+XG4gICAgICAgICAgbGV0IGwnID0gbWFwIGYgbCBpblxuICAgICAgICAgIGxldCBkJyA9IGYgZCBpblxuICAgICAgICAgIGxldCByJyA9IG1hcCBmIHIgaW5cbiAgICAgICAgICBOb2Rle2w9bCc7IHY7IGQ9ZCc7IHI9cic7IGh9XG5cbiAgICBsZXQgcmVjIG1hcGkgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gLT5cbiAgICAgICAgICBsZXQgbCcgPSBtYXBpIGYgbCBpblxuICAgICAgICAgIGxldCBkJyA9IGYgdiBkIGluXG4gICAgICAgICAgbGV0IHInID0gbWFwaSBmIHIgaW5cbiAgICAgICAgICBOb2Rle2w9bCc7IHY7IGQ9ZCc7IHI9cic7IGh9XG5cbiAgICBsZXQgcmVjIGZvbGQgZiBtIGFjY3UgPVxuICAgICAgbWF0Y2ggbSB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBmb2xkIGYgciAoZiB2IGQgKGZvbGQgZiBsIGFjY3UpKVxuXG4gICAgbGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiB0cnVlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IHAgdiBkICYmIGZvcl9hbGwgcCBsICYmIGZvcl9hbGwgcCByXG5cbiAgICBsZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gcCB2IGQgfHwgZXhpc3RzIHAgbCB8fCBleGlzdHMgcCByXG5cbiAgICAoKiBCZXdhcmU6IHRob3NlIHR3byBmdW5jdGlvbnMgYXNzdW1lIHRoYXQgdGhlIGFkZGVkIGsgaXMgKnN0cmljdGx5KlxuICAgICAgIHNtYWxsZXIgKG9yIGJpZ2dlcikgdGhhbiBhbGwgdGhlIHByZXNlbnQga2V5cyBpbiB0aGUgdHJlZTsgaXRcbiAgICAgICBkb2VzIG5vdCB0ZXN0IGZvciBlcXVhbGl0eSB3aXRoIHRoZSBjdXJyZW50IG1pbiAob3IgbWF4KSBrZXkuXG5cbiAgICAgICBJbmRlZWQsIHRoZXkgYXJlIG9ubHkgdXNlZCBkdXJpbmcgdGhlIFwiam9pblwiIG9wZXJhdGlvbiB3aGljaFxuICAgICAgIHJlc3BlY3RzIHRoaXMgcHJlY29uZGl0aW9uLlxuICAgICopXG5cbiAgICBsZXQgcmVjIGFkZF9taW5fYmluZGluZyBrIHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24gayB4XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgIGJhbCAoYWRkX21pbl9iaW5kaW5nIGsgeCBsKSB2IGQgclxuXG4gICAgbGV0IHJlYyBhZGRfbWF4X2JpbmRpbmcgayB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIGsgeFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICBiYWwgbCB2IGQgKGFkZF9tYXhfYmluZGluZyBrIHggcilcblxuICAgICgqIFNhbWUgYXMgY3JlYXRlIGFuZCBiYWwsIGJ1dCBubyBhc3N1bXB0aW9ucyBhcmUgbWFkZSBvbiB0aGVcbiAgICAgICByZWxhdGl2ZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgcmVjIGpvaW4gbCB2IGQgciA9XG4gICAgICBtYXRjaCAobCwgcikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IGFkZF9taW5fYmluZGluZyB2IGQgclxuICAgICAgfCAoXywgRW1wdHkpIC0+IGFkZF9tYXhfYmluZGluZyB2IGQgbFxuICAgICAgfCAoTm9kZXtsPWxsOyB2PWx2OyBkPWxkOyByPWxyOyBoPWxofSxcbiAgICAgICAgIE5vZGV7bD1ybDsgdj1ydjsgZD1yZDsgcj1ycjsgaD1yaH0pIC0+XG4gICAgICAgICAgaWYgbGggPiByaCArIDIgdGhlbiBiYWwgbGwgbHYgbGQgKGpvaW4gbHIgdiBkIHIpIGVsc2VcbiAgICAgICAgICBpZiByaCA+IGxoICsgMiB0aGVuIGJhbCAoam9pbiBsIHYgZCBybCkgcnYgcmQgcnIgZWxzZVxuICAgICAgICAgIGNyZWF0ZSBsIHYgZCByXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgTm8gYXNzdW1wdGlvbiBvbiB0aGUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IGNvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+XG4gICAgICAgICAgbGV0ICh4LCBkKSA9IG1pbl9iaW5kaW5nIHQyIGluXG4gICAgICAgICAgam9pbiB0MSB4IGQgKHJlbW92ZV9taW5fYmluZGluZyB0MilcblxuICAgIGxldCBjb25jYXRfb3Jfam9pbiB0MSB2IGQgdDIgPVxuICAgICAgbWF0Y2ggZCB3aXRoXG4gICAgICB8IFNvbWUgZCAtPiBqb2luIHQxIHYgZCB0MlxuICAgICAgfCBOb25lIC0+IGNvbmNhdCB0MSB0MlxuXG4gICAgbGV0IHJlYyBzcGxpdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAoRW1wdHksIE5vbmUsIEVtcHR5KVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiAobCwgU29tZSBkLCByKVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IChsbCwgcHJlcywgcmwpID0gc3BsaXQgeCBsIGluIChsbCwgcHJlcywgam9pbiBybCB2IGQgcilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGxyLCBwcmVzLCBycikgPSBzcGxpdCB4IHIgaW4gKGpvaW4gbCB2IGQgbHIsIHByZXMsIHJyKVxuXG4gICAgbGV0IHJlYyBtZXJnZSBmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBFbXB0eSkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGUge2w9bDE7IHY9djE7IGQ9ZDE7IHI9cjE7IGg9aDF9LCBfKSB3aGVuIGgxID49IGhlaWdodCBzMiAtPlxuICAgICAgICAgIGxldCAobDIsIGQyLCByMikgPSBzcGxpdCB2MSBzMiBpblxuICAgICAgICAgIGNvbmNhdF9vcl9qb2luIChtZXJnZSBmIGwxIGwyKSB2MSAoZiB2MSAoU29tZSBkMSkgZDIpIChtZXJnZSBmIHIxIHIyKVxuICAgICAgfCAoXywgTm9kZSB7bD1sMjsgdj12MjsgZD1kMjsgcj1yMn0pIC0+XG4gICAgICAgICAgbGV0IChsMSwgZDEsIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgY29uY2F0X29yX2pvaW4gKG1lcmdlIGYgbDEgbDIpIHYyIChmIHYyIGQxIChTb21lIGQyKSkgKG1lcmdlIGYgcjEgcjIpXG4gICAgICB8IF8gLT5cbiAgICAgICAgICBhc3NlcnQgZmFsc2VcblxuICAgIGxldCByZWMgdW5pb24gZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICB8IChFbXB0eSwgcykgfCAocywgRW1wdHkpIC0+IHNcbiAgICAgIHwgKE5vZGUge2w9bDE7IHY9djE7IGQ9ZDE7IHI9cjE7IGg9aDF9LFxuICAgICAgICAgTm9kZSB7bD1sMjsgdj12MjsgZD1kMjsgcj1yMjsgaD1oMn0pIC0+XG4gICAgICAgICAgaWYgaDEgPj0gaDIgdGhlblxuICAgICAgICAgICAgbGV0IChsMiwgZDIsIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMiB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYxIGQxIHJcbiAgICAgICAgICAgIHwgU29tZSBkMiAtPiBjb25jYXRfb3Jfam9pbiBsIHYxIChmIHYxIGQxIGQyKSByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsMSwgZDEsIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYyIGQyIHJcbiAgICAgICAgICAgIHwgU29tZSBkMSAtPiBjb25jYXRfb3Jfam9pbiBsIHYyIChmIHYyIGQxIGQyKSByXG5cbiAgICBsZXQgcmVjIGZpbHRlciBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gYXMgbSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyIHAgbCBpblxuICAgICAgICAgIGxldCBwdmQgPSBwIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlciBwIHIgaW5cbiAgICAgICAgICBpZiBwdmQgdGhlbiBpZiBsPT1sJyAmJiByPT1yJyB0aGVuIG0gZWxzZSBqb2luIGwnIHYgZCByJ1xuICAgICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG5cbiAgICBsZXQgcmVjIGZpbHRlcl9tYXAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgKCogY2FsbCBbZl0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgbCcgPSBmaWx0ZXJfbWFwIGYgbCBpblxuICAgICAgICAgIGxldCBmdmQgPSBmIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlcl9tYXAgZiByIGluXG4gICAgICAgICAgYmVnaW4gbWF0Y2ggZnZkIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBkJyAtPiBqb2luIGwnIHYgZCcgcidcbiAgICAgICAgICAgIHwgTm9uZSAtPiBjb25jYXQgbCcgcidcbiAgICAgICAgICBlbmRcblxuICAgIGxldCByZWMgcGFydGl0aW9uIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoRW1wdHksIEVtcHR5KVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IChsdCwgbGYpID0gcGFydGl0aW9uIHAgbCBpblxuICAgICAgICAgIGxldCBwdmQgPSBwIHYgZCBpblxuICAgICAgICAgIGxldCAocnQsIHJmKSA9IHBhcnRpdGlvbiBwIHIgaW5cbiAgICAgICAgICBpZiBwdmRcbiAgICAgICAgICB0aGVuIChqb2luIGx0IHYgZCBydCwgY29uY2F0IGxmIHJmKVxuICAgICAgICAgIGVsc2UgKGNvbmNhdCBsdCBydCwgam9pbiBsZiB2IGQgcmYpXG5cbiAgICB0eXBlICdhIGVudW1lcmF0aW9uID0gRW5kIHwgTW9yZSBvZiBrZXkgKiAnYSAqICdhIHQgKiAnYSBlbnVtZXJhdGlvblxuXG4gICAgbGV0IHJlYyBjb25zX2VudW0gbSBlID1cbiAgICAgIG1hdGNoIG0gd2l0aFxuICAgICAgICBFbXB0eSAtPiBlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGNvbnNfZW51bSBsIChNb3JlKHYsIGQsIHIsIGUpKVxuXG4gICAgbGV0IGNvbXBhcmUgY21wIG0xIG0yID1cbiAgICAgIGxldCByZWMgY29tcGFyZV9hdXggZTEgZTIgPVxuICAgICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgICAoRW5kLCBFbmQpIC0+IDBcbiAgICAgICAgfCAoRW5kLCBfKSAgLT4gLTFcbiAgICAgICAgfCAoXywgRW5kKSAtPiAxXG4gICAgICAgIHwgKE1vcmUodjEsIGQxLCByMSwgZTEpLCBNb3JlKHYyLCBkMiwgcjIsIGUyKSkgLT5cbiAgICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZVxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgZDEgZDIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZVxuICAgICAgICAgICAgY29tcGFyZV9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcbiAgICAgIGluIGNvbXBhcmVfYXV4IChjb25zX2VudW0gbTEgRW5kKSAoY29uc19lbnVtIG0yIEVuZClcblxuICAgIGxldCBlcXVhbCBjbXAgbTEgbTIgPVxuICAgICAgbGV0IHJlYyBlcXVhbF9hdXggZTEgZTIgPVxuICAgICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgICAoRW5kLCBFbmQpIC0+IHRydWVcbiAgICAgICAgfCAoRW5kLCBfKSAgLT4gZmFsc2VcbiAgICAgICAgfCAoXywgRW5kKSAtPiBmYWxzZVxuICAgICAgICB8IChNb3JlKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSh2MiwgZDIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgICBPcmQuY29tcGFyZSB2MSB2MiA9IDAgJiYgY21wIGQxIGQyICYmXG4gICAgICAgICAgICBlcXVhbF9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcbiAgICAgIGluIGVxdWFsX2F1eCAoY29uc19lbnVtIG0xIEVuZCkgKGNvbnNfZW51bSBtMiBFbmQpXG5cbiAgICBsZXQgcmVjIGNhcmRpbmFsID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2RlIHtsOyByfSAtPiBjYXJkaW5hbCBsICsgMSArIGNhcmRpbmFsIHJcblxuICAgIGxldCByZWMgYmluZGluZ3NfYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGJpbmRpbmdzX2F1eCAoKHYsIGQpIDo6IGJpbmRpbmdzX2F1eCBhY2N1IHIpIGxcblxuICAgIGxldCBiaW5kaW5ncyBzID1cbiAgICAgIGJpbmRpbmdzX2F1eCBbXSBzXG5cbiAgICBsZXQgY2hvb3NlID0gbWluX2JpbmRpbmdcblxuICAgIGxldCBjaG9vc2Vfb3B0ID0gbWluX2JpbmRpbmdfb3B0XG5cbiAgICBsZXQgYWRkX3NlcSBpIG0gPVxuICAgICAgU2VxLmZvbGRfbGVmdCAoZnVuIG0gKGssdikgLT4gYWRkIGsgdiBtKSBtIGlcblxuICAgIGxldCBvZl9zZXEgaSA9IGFkZF9zZXEgaSBlbXB0eVxuXG4gICAgbGV0IHJlYyBzZXFfb2ZfZW51bV8gYyAoKSA9IG1hdGNoIGMgd2l0aFxuICAgICAgfCBFbmQgLT4gU2VxLk5pbFxuICAgICAgfCBNb3JlIChrLHYsdCxyZXN0KSAtPiBTZXEuQ29ucyAoKGssdiksIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIHQgcmVzdCkpXG5cbiAgICBsZXQgdG9fc2VxIG0gPVxuICAgICAgc2VxX29mX2VudW1fIChjb25zX2VudW0gbSBFbmQpXG5cbiAgICBsZXQgcmVjIHNub2NfZW51bSBzIGUgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGVcbiAgICAgIHwgTm9kZXtsOyB2OyBkOyByfSAtPiBzbm9jX2VudW0gciAoTW9yZSh2LCBkLCBsLCBlKSlcblxuICAgIGxldCByZWMgcmV2X3NlcV9vZl9lbnVtXyBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgICB8IEVuZCAtPiBTZXEuTmlsXG4gICAgICB8IE1vcmUgKGssdix0LHJlc3QpIC0+XG4gICAgICAgICAgU2VxLkNvbnMgKChrLHYpLCByZXZfc2VxX29mX2VudW1fIChzbm9jX2VudW0gdCByZXN0KSlcblxuICAgIGxldCB0b19yZXZfc2VxIGMgPVxuICAgICAgcmV2X3NlcV9vZl9lbnVtXyAoc25vY19lbnVtIGMgRW5kKVxuXG4gICAgbGV0IHRvX3NlcV9mcm9tIGxvdyBtID1cbiAgICAgIGxldCByZWMgYXV4IGxvdyBtIGMgPSBtYXRjaCBtIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBjXG4gICAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgX30gLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIE9yZC5jb21wYXJlIHYgbG93IHdpdGhcbiAgICAgICAgICAgICAgfCAwIC0+IE1vcmUgKHYsIGQsIHIsIGMpXG4gICAgICAgICAgICAgIHwgbiB3aGVuIG48MCAtPiBhdXggbG93IHIgY1xuICAgICAgICAgICAgICB8IF8gLT4gYXV4IGxvdyBsIChNb3JlICh2LCBkLCByLCBjKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIHNlcV9vZl9lbnVtXyAoYXV4IGxvdyBtIEVuZClcbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSB7IG11dGFibGUgYyA6ICdhIGxpc3Q7IG11dGFibGUgbGVuIDogaW50OyB9XG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG5sZXQgY3JlYXRlICgpID0geyBjID0gW107IGxlbiA9IDA7IH1cblxubGV0IGNsZWFyIHMgPSBzLmMgPC0gW107IHMubGVuIDwtIDBcblxubGV0IGNvcHkgcyA9IHsgYyA9IHMuYzsgbGVuID0gcy5sZW47IH1cblxubGV0IHB1c2ggeCBzID0gcy5jIDwtIHggOjogcy5jOyBzLmxlbiA8LSBzLmxlbiArIDFcblxubGV0IHBvcCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6dGwgLT4gcy5jIDwtIHRsOyBzLmxlbiA8LSBzLmxlbiAtIDE7IGhkXG4gIHwgW10gICAgIC0+IHJhaXNlIEVtcHR5XG5cbmxldCBwb3Bfb3B0IHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjp0bCAtPiBzLmMgPC0gdGw7IHMubGVuIDwtIHMubGVuIC0gMTsgU29tZSBoZFxuICB8IFtdICAgICAtPiBOb25lXG5cbmxldCB0b3AgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6Ol8gLT4gaGRcbiAgfCBbXSAgICAtPiByYWlzZSBFbXB0eVxuXG5sZXQgdG9wX29wdCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6XyAtPiBTb21lIGhkXG4gIHwgW10gICAgLT4gTm9uZVxuXG5sZXQgaXNfZW1wdHkgcyA9IChzLmMgPSBbXSlcblxubGV0IGxlbmd0aCBzID0gcy5sZW5cblxubGV0IGl0ZXIgZiBzID0gTGlzdC5pdGVyIGYgcy5jXG5cbmxldCBmb2xkIGYgYWNjIHMgPSBMaXN0LmZvbGRfbGVmdCBmIGFjYyBzLmNcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID0gTGlzdC50b19zZXEgcy5jXG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcyA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcyBnO1xuICBzXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIEZyYW5jb2lzIFBvdHRpZXIsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgIEplcmVtaWUgRGltaW5vLCBKYW5lIFN0cmVldCBFdXJvcGUgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG50eXBlICdhIGNlbGwgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgeyBjb250ZW50OiAnYTsgbXV0YWJsZSBuZXh0OiAnYSBjZWxsIH1cblxudHlwZSAnYSB0ID0ge1xuICBtdXRhYmxlIGxlbmd0aDogaW50O1xuICBtdXRhYmxlIGZpcnN0OiAnYSBjZWxsO1xuICBtdXRhYmxlIGxhc3Q6ICdhIGNlbGxcbn1cblxubGV0IGNyZWF0ZSAoKSA9IHtcbiAgbGVuZ3RoID0gMDtcbiAgZmlyc3QgPSBOaWw7XG4gIGxhc3QgPSBOaWxcbn1cblxubGV0IGNsZWFyIHEgPVxuICBxLmxlbmd0aCA8LSAwO1xuICBxLmZpcnN0IDwtIE5pbDtcbiAgcS5sYXN0IDwtIE5pbFxuXG5sZXQgYWRkIHggcSA9XG4gIGxldCBjZWxsID0gQ29ucyB7XG4gICAgY29udGVudCA9IHg7XG4gICAgbmV4dCA9IE5pbFxuICB9IGluXG4gIG1hdGNoIHEubGFzdCB3aXRoXG4gIHwgTmlsIC0+XG4gICAgcS5sZW5ndGggPC0gMTtcbiAgICBxLmZpcnN0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcbiAgfCBDb25zIGxhc3QgLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCArIDE7XG4gICAgbGFzdC5uZXh0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcblxubGV0IHB1c2ggPVxuICBhZGRcblxubGV0IHBlZWsgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50IH0gLT4gY29udGVudFxuXG5sZXQgcGVla19vcHQgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiBOb25lXG4gIHwgQ29ucyB7IGNvbnRlbnQgfSAtPiBTb21lIGNvbnRlbnRcblxubGV0IHRvcCA9XG4gIHBlZWtcblxubGV0IHRha2UgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0ID0gTmlsIH0gLT5cbiAgICBjbGVhciBxO1xuICAgIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBjb250ZW50XG5cbmxldCB0YWtlX29wdCBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IE5vbmVcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCA9IE5pbCB9IC0+XG4gICAgY2xlYXIgcTtcbiAgICBTb21lIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBTb21lIGNvbnRlbnRcblxubGV0IHBvcCA9XG4gIHRha2VcblxubGV0IGNvcHkgPVxuICBsZXQgcmVjIGNvcHkgcV9yZXMgcHJldiBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiBxX3Jlcy5sYXN0IDwtIHByZXY7IHFfcmVzXG4gICAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgICBsZXQgcmVzID0gQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSBpblxuICAgICAgYmVnaW4gbWF0Y2ggcHJldiB3aXRoXG4gICAgICB8IE5pbCAtPiBxX3Jlcy5maXJzdCA8LSByZXNcbiAgICAgIHwgQ29ucyBwIC0+IHAubmV4dCA8LSByZXNcbiAgICAgIGVuZDtcbiAgICAgIGNvcHkgcV9yZXMgcmVzIG5leHRcbiAgaW5cbiAgZnVuIHEgLT4gY29weSB7IGxlbmd0aCA9IHEubGVuZ3RoOyBmaXJzdCA9IE5pbDsgbGFzdCA9IE5pbCB9IE5pbCBxLmZpcnN0XG5cbmxldCBpc19lbXB0eSBxID1cbiAgcS5sZW5ndGggPSAwXG5cbmxldCBsZW5ndGggcSA9XG4gIHEubGVuZ3RoXG5cbmxldCBpdGVyID1cbiAgbGV0IHJlYyBpdGVyIGYgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGYgY29udGVudDtcbiAgICAgIGl0ZXIgZiBuZXh0XG4gIGluXG4gIGZ1biBmIHEgLT4gaXRlciBmIHEuZmlyc3RcblxubGV0IGZvbGQgPVxuICBsZXQgcmVjIGZvbGQgZiBhY2N1IGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+IGFjY3VcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGxldCBhY2N1ID0gZiBhY2N1IGNvbnRlbnQgaW5cbiAgICAgIGZvbGQgZiBhY2N1IG5leHRcbiAgaW5cbiAgZnVuIGYgYWNjdSBxIC0+IGZvbGQgZiBhY2N1IHEuZmlyc3RcblxubGV0IHRyYW5zZmVyIHExIHEyID1cbiAgaWYgcTEubGVuZ3RoID4gMCB0aGVuXG4gICAgbWF0Y2ggcTIubGFzdCB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMS5sZW5ndGg7XG4gICAgICBxMi5maXJzdCA8LSBxMS5maXJzdDtcbiAgICAgIHEyLmxhc3QgPC0gcTEubGFzdDtcbiAgICAgIGNsZWFyIHExXG4gICAgfCBDb25zIGxhc3QgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMi5sZW5ndGggKyBxMS5sZW5ndGg7XG4gICAgICBsYXN0Lm5leHQgPC0gcTEuZmlyc3Q7XG4gICAgICBxMi5sYXN0IDwtIHExLmxhc3Q7XG4gICAgICBjbGVhciBxMVxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHEgPVxuICBsZXQgcmVjIGF1eCBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgfCBOaWwgLT4gU2VxLk5pbFxuICAgIHwgQ29ucyB7IGNvbnRlbnQ9eDsgbmV4dDsgfSAtPiBTZXEuQ29ucyAoeCwgYXV4IG5leHQpXG4gIGluXG4gIGF1eCBxLmZpcnN0XG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcSA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcSBnO1xuICBxXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICBQaWVycmUgV2VpcyBhbmQgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk5IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEV4dGVuc2libGUgYnVmZmVycyAqKVxuXG50eXBlIHQgPVxuIHttdXRhYmxlIGJ1ZmZlciA6IGJ5dGVzO1xuICBtdXRhYmxlIHBvc2l0aW9uIDogaW50O1xuICBtdXRhYmxlIGxlbmd0aCA6IGludDtcbiAgaW5pdGlhbF9idWZmZXIgOiBieXRlc31cbigqIEludmFyaWFudHM6IGFsbCBwYXJ0cyBvZiB0aGUgY29kZSBwcmVzZXJ2ZSB0aGUgaW52YXJpYW50cyB0aGF0OlxuICAgLSBbMCA8PSBiLnBvc2l0aW9uIDw9IGIubGVuZ3RoXVxuICAgLSBbYi5sZW5ndGggPSBCeXRlcy5sZW5ndGggYi5idWZmZXJdXG5cbiAgIE5vdGUgaW4gcGFydGljdWxhciB0aGF0IFtiLnBvc2l0aW9uID0gYi5sZW5ndGhdIGlzIGxlZ2FsLFxuICAgaXQgbWVhbnMgdGhhdCB0aGUgYnVmZmVyIGlzIGZ1bGwgYW5kIHdpbGwgaGF2ZSB0byBiZSBleHRlbmRlZFxuICAgYmVmb3JlIGFueSBmdXJ0aGVyIGFkZGl0aW9uLiAqKVxuXG5sZXQgY3JlYXRlIG4gPVxuIGxldCBuID0gaWYgbiA8IDEgdGhlbiAxIGVsc2UgbiBpblxuIGxldCBuID0gaWYgbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuIFN5cy5tYXhfc3RyaW5nX2xlbmd0aCBlbHNlIG4gaW5cbiBsZXQgcyA9IEJ5dGVzLmNyZWF0ZSBuIGluXG4ge2J1ZmZlciA9IHM7IHBvc2l0aW9uID0gMDsgbGVuZ3RoID0gbjsgaW5pdGlhbF9idWZmZXIgPSBzfVxuXG5sZXQgY29udGVudHMgYiA9IEJ5dGVzLnN1Yl9zdHJpbmcgYi5idWZmZXIgMCBiLnBvc2l0aW9uXG5sZXQgdG9fYnl0ZXMgYiA9IEJ5dGVzLnN1YiBiLmJ1ZmZlciAwIGIucG9zaXRpb25cblxubGV0IHN1YiBiIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYi5wb3NpdGlvbiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLnN1YlwiXG4gIGVsc2UgQnl0ZXMuc3ViX3N0cmluZyBiLmJ1ZmZlciBvZnMgbGVuXG5cblxubGV0IGJsaXQgc3JjIHNyY29mZiBkc3QgZHN0b2ZmIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgc3Jjb2ZmIDwgMCB8fCBzcmNvZmYgPiBzcmMucG9zaXRpb24gLSBsZW5cbiAgICAgICAgICAgICB8fCBkc3RvZmYgPCAwIHx8IGRzdG9mZiA+IChCeXRlcy5sZW5ndGggZHN0KSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLmJsaXRcIlxuICBlbHNlXG4gICAgQnl0ZXMudW5zYWZlX2JsaXQgc3JjLmJ1ZmZlciBzcmNvZmYgZHN0IGRzdG9mZiBsZW5cblxuXG5sZXQgbnRoIGIgb2ZzID1cbiAgaWYgb2ZzIDwgMCB8fCBvZnMgPj0gYi5wb3NpdGlvbiB0aGVuXG4gICBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5udGhcIlxuICBlbHNlIEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmZXIgb2ZzXG5cblxubGV0IGxlbmd0aCBiID0gYi5wb3NpdGlvblxuXG5sZXQgY2xlYXIgYiA9IGIucG9zaXRpb24gPC0gMFxuXG5sZXQgcmVzZXQgYiA9XG4gIGIucG9zaXRpb24gPC0gMDtcbiAgYi5idWZmZXIgPC0gYi5pbml0aWFsX2J1ZmZlcjtcbiAgYi5sZW5ndGggPC0gQnl0ZXMubGVuZ3RoIGIuYnVmZmVyXG5cbigqIFtyZXNpemUgYiBtb3JlXSBlbnN1cmVzIHRoYXQgW2IucG9zaXRpb24gKyBtb3JlIDw9IGIubGVuZ3RoXSBob2xkc1xuICAgYnkgZHluYW1pY2FsbHkgZXh0ZW5kaW5nIFtiLmJ1ZmZlcl0gaWYgbmVjZXNzYXJ5IC0tIGFuZCB0aHVzXG4gICBpbmNyZWFzaW5nIFtiLmxlbmd0aF0uXG5cbiAgIEluIHBhcnRpY3VsYXIsIGFmdGVyIFtyZXNpemUgYiBtb3JlXSBpcyBjYWxsZWQsIGEgZGlyZWN0IGFjY2VzcyBvZlxuICAgc2l6ZSBbbW9yZV0gYXQgW2IucG9zaXRpb25dIHdpbGwgYWx3YXlzIGJlIGluLWJvdW5kcywgc28gdGhhdFxuICAgKHVuc2FmZV97Z2V0LHNldH0pIG1heSBiZSB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbiopXG5sZXQgcmVzaXplIGIgbW9yZSA9XG4gIGxldCBvbGRfcG9zID0gYi5wb3NpdGlvbiBpblxuICBsZXQgb2xkX2xlbiA9IGIubGVuZ3RoIGluXG4gIGxldCBuZXdfbGVuID0gcmVmIG9sZF9sZW4gaW5cbiAgd2hpbGUgb2xkX3BvcyArIG1vcmUgPiAhbmV3X2xlbiBkbyBuZXdfbGVuIDo9IDIgKiAhbmV3X2xlbiBkb25lO1xuICBpZiAhbmV3X2xlbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuIGJlZ2luXG4gICAgaWYgb2xkX3BvcyArIG1vcmUgPD0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgdGhlbiBuZXdfbGVuIDo9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgIGVsc2UgZmFpbHdpdGggXCJCdWZmZXIuYWRkOiBjYW5ub3QgZ3JvdyBidWZmZXJcIlxuICBlbmQ7XG4gIGxldCBuZXdfYnVmZmVyID0gQnl0ZXMuY3JlYXRlICFuZXdfbGVuIGluXG4gICgqIFBSIzYxNDg6IGxldCdzIGtlZXAgdXNpbmcgW2JsaXRdIHJhdGhlciB0aGFuIFt1bnNhZmVfYmxpdF0gaW5cbiAgICAgdGhpcyB0cmlja3kgZnVuY3Rpb24gdGhhdCBpcyBzbG93IGFueXdheS4gKilcbiAgQnl0ZXMuYmxpdCBiLmJ1ZmZlciAwIG5ld19idWZmZXIgMCBiLnBvc2l0aW9uO1xuICBiLmJ1ZmZlciA8LSBuZXdfYnVmZmVyO1xuICBiLmxlbmd0aCA8LSAhbmV3X2xlbjtcbiAgYXNzZXJ0IChiLnBvc2l0aW9uICsgbW9yZSA8PSBiLmxlbmd0aCk7XG4gIGFzc2VydCAob2xkX3BvcyArIG1vcmUgPD0gYi5sZW5ndGgpO1xuICAoKVxuICAoKiBOb3RlOiB0aGVyZSBhcmUgdmFyaW91cyBzaXR1YXRpb25zIChwcmVlbXB0aXZlIHRocmVhZHMsIHNpZ25hbHMgYW5kXG4gICAgIGdjIGZpbmFsaXplcnMpIHdoZXJlIE9DYW1sIGNvZGUgbWF5IGJlIHJ1biBhc3luY2hyb25vdXNseTsgaW5cbiAgICAgcGFydGljdWxhciwgdGhlcmUgbWF5IGJlIGEgcmFjZSB3aXRoIGFub3RoZXIgdXNlciBvZiBbYl0sIGNoYW5naW5nXG4gICAgIGl0cyBtdXRhYmxlIGZpZWxkcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSBbcmVzaXplXSBjYWxsLiBUaGUgQnVmZmVyXG4gICAgIG1vZHVsZSBkb2VzIG5vdCBwcm92aWRlIGFueSBjb3JyZWN0bmVzcyBndWFyYW50ZWUgaWYgdGhhdCBoYXBwZW5zLFxuICAgICBidXQgd2UgbXVzdCBzdGlsbCBlbnN1cmUgdGhhdCB0aGUgZGF0YXN0cnVjdHVyZSBpbnZhcmlhbnRzIGhvbGQgZm9yXG4gICAgIG1lbW9yeS1zYWZldHkgLS0gYXMgd2UgcGxhbiB0byB1c2UgW3Vuc2FmZV97Z2V0LHNldH1dLlxuXG4gICAgIFRoZXJlIGFyZSB0d28gcG90ZW50aWFsIGFsbG9jYXRpb24gcG9pbnRzIGluIHRoaXMgZnVuY3Rpb24sXG4gICAgIFtyZWZdIGFuZCBbQnl0ZXMuY3JlYXRlXSwgYnV0IGFsbCByZWFkcyBhbmQgd3JpdGVzIHRvIHRoZSBmaWVsZHNcbiAgICAgb2YgW2JdIGhhcHBlbiBiZWZvcmUgYm90aCBvZiB0aGVtIG9yIGFmdGVyIGJvdGggb2YgdGhlbS5cblxuICAgICBXZSB0aGVyZWZvcmUgYXNzdW1lIHRoYXQgW2IucG9zaXRpb25dIG1heSBjaGFuZ2UgYXQgdGhlc2UgYWxsb2NhdGlvbnMsXG4gICAgIGFuZCBjaGVjayB0aGF0IHRoZSBbYi5wb3NpdGlvbiArIG1vcmUgPD0gYi5sZW5ndGhdIHBvc3Rjb25kaXRpb25cbiAgICAgaG9sZHMgZm9yIGJvdGggdmFsdWVzIG9mIFtiLnBvc2l0aW9uXSwgYmVmb3JlIG9yIGFmdGVyIHRoZSBmdW5jdGlvblxuICAgICBpcyBjYWxsZWQuIE1vcmUgcHJlY2lzZWx5LCB0aGUgZm9sbG93aW5nIGludmFyaWFudHMgbXVzdCBob2xkIGlmIHRoZVxuICAgICBmdW5jdGlvbiByZXR1cm5zIGNvcnJlY3RseSwgaW4gYWRkaXRpb24gdG8gdGhlIHVzdWFsIGJ1ZmZlciBpbnZhcmlhbnRzOlxuICAgICAtIFtvbGQoYi5wb3NpdGlvbikgKyBtb3JlIDw9IG5ldyhiLmxlbmd0aCldXG4gICAgIC0gW25ldyhiLnBvc2l0aW9uKSArIG1vcmUgPD0gbmV3KGIubGVuZ3RoKV1cbiAgICAgLSBbb2xkKGIubGVuZ3RoKSA8PSBuZXcoYi5sZW5ndGgpXVxuXG4gICAgIE5vdGU6IFtiLnBvc2l0aW9uICsgbW9yZSA8PSBvbGQoYi5sZW5ndGgpXSBkb2VzICpub3QqXG4gICAgIGhvbGQgaW4gZ2VuZXJhbCwgYXMgaXQgaXMgcHJlY2lzZWx5IHRoZSBjYXNlIHdoZXJlIHlvdSBuZWVkXG4gICAgIHRvIGNhbGwgW3Jlc2l6ZV0gdG8gaW5jcmVhc2UgW2IubGVuZ3RoXS5cblxuICAgICBOb3RlOiBbYXNzZXJ0XSBhYm92ZSBkb2VzIG5vdCBtZWFuIHRoYXQgd2Uga25vdyB0aGUgY29uZGl0aW9uc1xuICAgICBhbHdheXMgaG9sZCwgYnV0IHRoYXQgdGhlIGZ1bmN0aW9uIG1heSByZXR1cm4gY29ycmVjdGx5XG4gICAgIG9ubHkgaWYgdGhleSBob2xkLlxuXG4gICAgIE5vdGU6IHRoZSBvdGhlciBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgZG9lcyBub3QgbmVlZFxuICAgICB0byBiZSBjaGVja2VkIHdpdGggdGhpcyBsZXZlbCBvZiBzY3J1dGlueSwgZ2l2ZW4gdGhhdCB0aGV5XG4gICAgIHJlYWQvd3JpdGUgdGhlIGJ1ZmZlciBpbW1lZGlhdGVseSBhZnRlciBjaGVja2luZyB0aGF0XG4gICAgIFtiLnBvc2l0aW9uICsgbW9yZSA8PSBiLmxlbmd0aF0gaG9sZCBvciBjYWxsaW5nIFtyZXNpemVdLlxuICAqKVxuXG5sZXQgYWRkX2NoYXIgYiBjID1cbiAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgaWYgcG9zID49IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMTtcbiAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciBwb3MgYztcbiAgYi5wb3NpdGlvbiA8LSBwb3MgKyAxXG5cbmxldCB1Y2hhcl91dGZfOF9ieXRlX2xlbmd0aF9tYXggPSA0XG5sZXQgdWNoYXJfdXRmXzE2X2J5dGVfbGVuZ3RoX21heCA9IDRcblxubGV0IHJlYyBhZGRfdXRmXzhfdWNoYXIgYiB1ID1cbiAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgaWYgcG9zID49IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgdWNoYXJfdXRmXzhfYnl0ZV9sZW5ndGhfbWF4O1xuICBsZXQgbiA9IEJ5dGVzLnNldF91dGZfOF91Y2hhciBiLmJ1ZmZlciBwb3MgdSBpblxuICBpZiBuID0gMFxuICB0aGVuIChyZXNpemUgYiB1Y2hhcl91dGZfOF9ieXRlX2xlbmd0aF9tYXg7IGFkZF91dGZfOF91Y2hhciBiIHUpXG4gIGVsc2UgKGIucG9zaXRpb24gPC0gcG9zICsgbilcblxubGV0IHJlYyBhZGRfdXRmXzE2YmVfdWNoYXIgYiB1ID1cbiAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgaWYgcG9zID49IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgdWNoYXJfdXRmXzE2X2J5dGVfbGVuZ3RoX21heDtcbiAgbGV0IG4gPSBCeXRlcy5zZXRfdXRmXzE2YmVfdWNoYXIgYi5idWZmZXIgcG9zIHUgaW5cbiAgaWYgbiA9IDBcbiAgdGhlbiAocmVzaXplIGIgdWNoYXJfdXRmXzE2X2J5dGVfbGVuZ3RoX21heDsgYWRkX3V0Zl8xNmJlX3VjaGFyIGIgdSlcbiAgZWxzZSAoYi5wb3NpdGlvbiA8LSBwb3MgKyBuKVxuXG5sZXQgcmVjIGFkZF91dGZfMTZsZV91Y2hhciBiIHUgPVxuICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICBpZiBwb3MgPj0gYi5sZW5ndGggdGhlbiByZXNpemUgYiB1Y2hhcl91dGZfMTZfYnl0ZV9sZW5ndGhfbWF4O1xuICBsZXQgbiA9IEJ5dGVzLnNldF91dGZfMTZsZV91Y2hhciBiLmJ1ZmZlciBwb3MgdSBpblxuICBpZiBuID0gMFxuICB0aGVuIChyZXNpemUgYiB1Y2hhcl91dGZfMTZfYnl0ZV9sZW5ndGhfbWF4OyBhZGRfdXRmXzE2bGVfdWNoYXIgYiB1KVxuICBlbHNlIChiLnBvc2l0aW9uIDwtIHBvcyArIG4pXG5cbmxldCBhZGRfc3Vic3RyaW5nIGIgcyBvZmZzZXQgbGVuID1cbiAgaWYgb2Zmc2V0IDwgMCB8fCBsZW4gPCAwIHx8IG9mZnNldCA+IFN0cmluZy5sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLmFkZF9zdWJzdHJpbmcvYWRkX3N1YmJ5dGVzXCI7XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgbGVuIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgbGVuO1xuICBCeXRlcy51bnNhZmVfYmxpdF9zdHJpbmcgcyBvZmZzZXQgYi5idWZmZXIgYi5wb3NpdGlvbiBsZW47XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfc3ViYnl0ZXMgYiBzIG9mZnNldCBsZW4gPVxuICBhZGRfc3Vic3RyaW5nIGIgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcykgb2Zmc2V0IGxlblxuXG5sZXQgYWRkX3N0cmluZyBiIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgbGVuIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgbGVuO1xuICBCeXRlcy51bnNhZmVfYmxpdF9zdHJpbmcgcyAwIGIuYnVmZmVyIGIucG9zaXRpb24gbGVuO1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2J5dGVzIGIgcyA9IGFkZF9zdHJpbmcgYiAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzKVxuXG5sZXQgYWRkX2J1ZmZlciBiIGJzID1cbiAgYWRkX3N1YmJ5dGVzIGIgYnMuYnVmZmVyIDAgYnMucG9zaXRpb25cblxuKCogdGhpcyAocHJpdmF0ZSkgZnVuY3Rpb24gY291bGQgbW92ZSBpbnRvIHRoZSBzdGFuZGFyZCBsaWJyYXJ5ICopXG5sZXQgcmVhbGx5X2lucHV0X3VwX3RvIGljIGJ1ZiBvZnMgbGVuID1cbiAgbGV0IHJlYyBsb29wIGljIGJ1ZiB+YWxyZWFkeV9yZWFkIH5vZnMgfnRvX3JlYWQgPVxuICAgIGlmIHRvX3JlYWQgPSAwIHRoZW4gYWxyZWFkeV9yZWFkXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHIgPSBpbnB1dCBpYyBidWYgb2ZzIHRvX3JlYWQgaW5cbiAgICAgIGlmIHIgPSAwIHRoZW4gYWxyZWFkeV9yZWFkXG4gICAgICBlbHNlIGJlZ2luXG4gICAgICAgIGxldCBhbHJlYWR5X3JlYWQgPSBhbHJlYWR5X3JlYWQgKyByIGluXG4gICAgICAgIGxldCBvZnMgPSBvZnMgKyByIGluXG4gICAgICAgIGxldCB0b19yZWFkID0gdG9fcmVhZCAtIHIgaW5cbiAgICAgICAgbG9vcCBpYyBidWYgfmFscmVhZHlfcmVhZCB+b2ZzIH50b19yZWFkXG4gICAgICBlbmRcbiAgICBlbmRcbiAgaW4gbG9vcCBpYyBidWYgfmFscmVhZHlfcmVhZDowIH5vZnMgfnRvX3JlYWQ6bGVuXG5cblxubGV0IHVuc2FmZV9hZGRfY2hhbm5lbF91cF90byBiIGljIGxlbiA9XG4gIGlmIGIucG9zaXRpb24gKyBsZW4gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIGxlbjtcbiAgbGV0IG4gPSByZWFsbHlfaW5wdXRfdXBfdG8gaWMgYi5idWZmZXIgYi5wb3NpdGlvbiBsZW4gaW5cbiAgKCogVGhlIGFzc2VydGlvbiBiZWxvdyBtYXkgZmFpbCBpbiB3ZWlyZCBzY2VuYXJpbyB3aGVyZVxuICAgICB0aHJlYWRlZC9maW5hbGl6ZXIgY29kZSwgcnVuIGFzeW5jaHJvbm91c2x5IGR1cmluZyB0aGVcbiAgICAgW3JlYWxseV9pbnB1dF91cF90b10gY2FsbCwgcmFjZXMgb24gdGhlIGJ1ZmZlcjsgd2UgZG9uJ3QgZW5zdXJlXG4gICAgIGNvcnJlY3RuZXNzIGluIHRoaXMgY2FzZSwgYnV0IG5lZWQgdG8gcHJlc2VydmUgdGhlIGludmFyaWFudHMgZm9yXG4gICAgIG1lbW9yeS1zYWZldHkgKHNlZSBkaXNjdXNzaW9uIG9mIFtyZXNpemVdKS4gKilcbiAgYXNzZXJ0IChiLnBvc2l0aW9uICsgbiA8PSBiLmxlbmd0aCk7XG4gIGIucG9zaXRpb24gPC0gYi5wb3NpdGlvbiArIG47XG4gIG5cblxubGV0IGFkZF9jaGFubmVsIGIgaWMgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBsZW4gPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlbiAgICgqIFBSIzUwMDQgKilcbiAgICBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5hZGRfY2hhbm5lbFwiO1xuICBsZXQgbiA9IHVuc2FmZV9hZGRfY2hhbm5lbF91cF90byBiIGljIGxlbiBpblxuICAoKiBJdCBpcyBpbnRlbnRpb25hbCB0aGF0IGEgY29uc3VtZXIgY2F0Y2hpbmcgRW5kX29mX2ZpbGVcbiAgICAgd2lsbCBzZWUgdGhlIGRhdGEgd3JpdHRlbiAoc2VlICM2NzE5LCAjNzEzNikuICopXG4gIGlmIG4gPCBsZW4gdGhlbiByYWlzZSBFbmRfb2ZfZmlsZTtcbiAgKClcblxubGV0IG91dHB1dF9idWZmZXIgb2MgYiA9XG4gIG91dHB1dCBvYyBiLmJ1ZmZlciAwIGIucG9zaXRpb25cblxubGV0IGNsb3NpbmcgPSBmdW5jdGlvblxuICB8ICcoJyAtPiAnKSdcbiAgfCAneycgLT4gJ30nXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuKCogb3BlbmluZyBhbmQgY2xvc2luZzogb3BlbiBhbmQgY2xvc2UgY2hhcmFjdGVycywgdHlwaWNhbGx5ICggYW5kIClcbiAgIGs6IGJhbGFuY2Ugb2Ygb3BlbmluZyBhbmQgY2xvc2luZyBjaGFyc1xuICAgczogdGhlIHN0cmluZyB3aGVyZSB3ZSBhcmUgc2VhcmNoaW5nXG4gICBzdGFydDogdGhlIGluZGV4IHdoZXJlIHdlIHN0YXJ0IHRoZSBzZWFyY2guICopXG5sZXQgYWR2YW5jZV90b19jbG9zaW5nIG9wZW5pbmcgY2xvc2luZyBrIHMgc3RhcnQgPVxuICBsZXQgcmVjIGFkdmFuY2UgayBpIGxpbSA9XG4gICAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICAgIGlmIHMuW2ldID0gb3BlbmluZyB0aGVuIGFkdmFuY2UgKGsgKyAxKSAoaSArIDEpIGxpbSBlbHNlXG4gICAgaWYgcy5baV0gPSBjbG9zaW5nIHRoZW5cbiAgICAgIGlmIGsgPSAwIHRoZW4gaSBlbHNlIGFkdmFuY2UgKGsgLSAxKSAoaSArIDEpIGxpbVxuICAgIGVsc2UgYWR2YW5jZSBrIChpICsgMSkgbGltIGluXG4gIGFkdmFuY2UgayBzdGFydCAoU3RyaW5nLmxlbmd0aCBzKVxuXG5sZXQgYWR2YW5jZV90b19ub25fYWxwaGEgcyBzdGFydCA9XG4gIGxldCByZWMgYWR2YW5jZSBpIGxpbSA9XG4gICAgaWYgaSA+PSBsaW0gdGhlbiBsaW0gZWxzZVxuICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onIHwgJzAnIC4uICc5JyB8ICdfJyAtPiBhZHZhbmNlIChpICsgMSkgbGltXG4gICAgfCBfIC0+IGkgaW5cbiAgYWR2YW5jZSBzdGFydCAoU3RyaW5nLmxlbmd0aCBzKVxuXG4oKiBXZSBhcmUganVzdCBhdCB0aGUgYmVnaW5uaW5nIG9mIGFuIGlkZW50IGluIHMsIHN0YXJ0aW5nIGF0IHN0YXJ0LiAqKVxubGV0IGZpbmRfaWRlbnQgcyBzdGFydCBsaW0gPVxuICBpZiBzdGFydCA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBtYXRjaCBzLltzdGFydF0gd2l0aFxuICAoKiBQYXJlbnRoZXNpemVkIGlkZW50ID8gKilcbiAgfCAnKCcgfCAneycgYXMgYyAtPlxuICAgICBsZXQgbmV3X3N0YXJ0ID0gc3RhcnQgKyAxIGluXG4gICAgIGxldCBzdG9wID0gYWR2YW5jZV90b19jbG9zaW5nIGMgKGNsb3NpbmcgYykgMCBzIG5ld19zdGFydCBpblxuICAgICBTdHJpbmcuc3ViIHMgbmV3X3N0YXJ0IChzdG9wIC0gc3RhcnQgLSAxKSwgc3RvcCArIDFcbiAgKCogUmVndWxhciBpZGVudCAqKVxuICB8IF8gLT5cbiAgICAgbGV0IHN0b3AgPSBhZHZhbmNlX3RvX25vbl9hbHBoYSBzIChzdGFydCArIDEpIGluXG4gICAgIFN0cmluZy5zdWIgcyBzdGFydCAoc3RvcCAtIHN0YXJ0KSwgc3RvcFxuXG4oKiBTdWJzdGl0dXRlICRpZGVudCwgJChpZGVudCksIG9yICR7aWRlbnR9IGluIHMsXG4gICAgYWNjb3JkaW5nIHRvIHRoZSBmdW5jdGlvbiBtYXBwaW5nIGYuICopXG5sZXQgYWRkX3N1YnN0aXR1dGUgYiBmIHMgPVxuICBsZXQgbGltID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCByZWMgc3Vic3QgcHJldmlvdXMgaSA9XG4gICAgaWYgaSA8IGxpbSB0aGVuIGJlZ2luXG4gICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICB8ICckJyBhcyBjdXJyZW50IHdoZW4gcHJldmlvdXMgPSAnXFxcXCcgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0ICcgJyAoaSArIDEpXG4gICAgICB8ICckJyAtPlxuICAgICAgICAgbGV0IGogPSBpICsgMSBpblxuICAgICAgICAgbGV0IGlkZW50LCBuZXh0X2kgPSBmaW5kX2lkZW50IHMgaiBsaW0gaW5cbiAgICAgICAgIGFkZF9zdHJpbmcgYiAoZiBpZGVudCk7XG4gICAgICAgICBzdWJzdCAnICcgbmV4dF9pXG4gICAgICB8IGN1cnJlbnQgd2hlbiBwcmV2aW91cyA9PSAnXFxcXCcgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgJ1xcXFwnO1xuICAgICAgICAgYWRkX2NoYXIgYiBjdXJyZW50O1xuICAgICAgICAgc3Vic3QgJyAnIChpICsgMSlcbiAgICAgIHwgJ1xcXFwnIGFzIGN1cnJlbnQgLT5cbiAgICAgICAgIHN1YnN0IGN1cnJlbnQgKGkgKyAxKVxuICAgICAgfCBjdXJyZW50IC0+XG4gICAgICAgICBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCBjdXJyZW50IChpICsgMSlcbiAgICBlbmQgZWxzZVxuICAgIGlmIHByZXZpb3VzID0gJ1xcXFwnIHRoZW4gYWRkX2NoYXIgYiBwcmV2aW91cyBpblxuICBzdWJzdCAnICcgMFxuXG5sZXQgdHJ1bmNhdGUgYiBsZW4gPVxuICAgIGlmIGxlbiA8IDAgfHwgbGVuID4gbGVuZ3RoIGIgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJCdWZmZXIudHJ1bmNhdGVcIlxuICAgIGVsc2VcbiAgICAgIGIucG9zaXRpb24gPC0gbGVuXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgYiA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICgqIE5vdGUgdGhhdCBiLnBvc2l0aW9uIGlzIG5vdCBhIGNvbnN0YW50IGFuZCBjYW5ub3QgYmUgbGlmdGVkIG91dCBvZiBhdXggKilcbiAgICBpZiBpID49IGIucG9zaXRpb24gdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZmVyIGkgaW5cbiAgICAgIFNlcS5Db25zICh4LCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCB0b19zZXFpIGIgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICAoKiBOb3RlIHRoYXQgYi5wb3NpdGlvbiBpcyBub3QgYSBjb25zdGFudCBhbmQgY2Fubm90IGJlIGxpZnRlZCBvdXQgb2YgYXV4ICopXG4gICAgaWYgaSA+PSBiLnBvc2l0aW9uIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmZlciBpIGluXG4gICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IGFkZF9zZXEgYiBzZXEgPSBTZXEuaXRlciAoYWRkX2NoYXIgYikgc2VxXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCBiID0gY3JlYXRlIDMyIGluXG4gIGFkZF9zZXEgYiBpO1xuICBiXG5cbigqKiB7NiBCaW5hcnkgZW5jb2Rpbmcgb2YgaW50ZWdlcnN9ICopXG5cbmV4dGVybmFsIHVuc2FmZV9zZXRfaW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQxNiA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MTZ1XCJcbmV4dGVybmFsIHVuc2FmZV9zZXRfaW50MzIgOiBieXRlcyAtPiBpbnQgLT4gaW50MzIgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MzJ1XCJcbmV4dGVybmFsIHVuc2FmZV9zZXRfaW50NjQgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0NjR1XCJcbmV4dGVybmFsIHN3YXAxNiA6IGludCAtPiBpbnQgPSBcIiVic3dhcDE2XCJcbmV4dGVybmFsIHN3YXAzMiA6IGludDMyIC0+IGludDMyID0gXCIlYnN3YXBfaW50MzJcIlxuZXh0ZXJuYWwgc3dhcDY0IDogaW50NjQgLT4gaW50NjQgPSBcIiVic3dhcF9pbnQ2NFwiXG5cblxubGV0IGFkZF9pbnQ4IGIgeCA9XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgMSBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDE7XG4gIHVuc2FmZV9zZXRfaW50OCBiLmJ1ZmZlciBiLnBvc2l0aW9uIHg7XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfaW50MTZfbmUgYiB4ID1cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyAyIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMjtcbiAgdW5zYWZlX3NldF9pbnQxNiBiLmJ1ZmZlciBiLnBvc2l0aW9uIHg7XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfaW50MzJfbmUgYiB4ID1cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyA0IGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgNDtcbiAgdW5zYWZlX3NldF9pbnQzMiBiLmJ1ZmZlciBiLnBvc2l0aW9uIHg7XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfaW50NjRfbmUgYiB4ID1cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyA4IGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgODtcbiAgdW5zYWZlX3NldF9pbnQ2NCBiLmJ1ZmZlciBiLnBvc2l0aW9uIHg7XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfaW50MTZfbGUgYiB4ID1cbiAgYWRkX2ludDE2X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDE2IHggZWxzZSB4KVxuXG5sZXQgYWRkX2ludDE2X2JlIGIgeCA9XG4gIGFkZF9pbnQxNl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHggZWxzZSBzd2FwMTYgeClcblxubGV0IGFkZF9pbnQzMl9sZSBiIHggPVxuICBhZGRfaW50MzJfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMzIgeCBlbHNlIHgpXG5cbmxldCBhZGRfaW50MzJfYmUgYiB4ID1cbiAgYWRkX2ludDMyX25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4geCBlbHNlIHN3YXAzMiB4KVxuXG5sZXQgYWRkX2ludDY0X2xlIGIgeCA9XG4gIGFkZF9pbnQ2NF9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXA2NCB4IGVsc2UgeClcblxubGV0IGFkZF9pbnQ2NF9iZSBiIHggPVxuICBhZGRfaW50NjRfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiB4IGVsc2Ugc3dhcDY0IHgpXG5cbmxldCBhZGRfdWludDggPSBhZGRfaW50OFxubGV0IGFkZF91aW50MTZfbmUgPSBhZGRfaW50MTZfbmVcbmxldCBhZGRfdWludDE2X2xlID0gYWRkX2ludDE2X2xlXG5sZXQgYWRkX3VpbnQxNl9iZSA9IGFkZF9pbnQxNl9iZVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBYYXZpZXIgTGVyb3kgYW5kIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxubGV0IGtmcHJpbnRmIGsgbyAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmIChmdW4gYWNjIC0+IG91dHB1dF9hY2MgbyBhY2M7IGsgbykgRW5kX29mX2FjYyBmbXRcbmxldCBrYnByaW50ZiBrIGIgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZiAoZnVuIGFjYyAtPiBidWZwdXRfYWNjIGIgYWNjOyBrIGIpIEVuZF9vZl9hY2MgZm10XG5sZXQgaWtmcHJpbnRmIGsgb2MgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX2lwcmludGYgayBvYyBmbXRcbmxldCBpa2JwcmludGYgPSBpa2ZwcmludGZcblxubGV0IGZwcmludGYgb2MgZm10ID0ga2ZwcmludGYgaWdub3JlIG9jIGZtdFxubGV0IGJwcmludGYgYiBmbXQgPSBrYnByaW50ZiBpZ25vcmUgYiBmbXRcbmxldCBpZnByaW50ZiBvYyBmbXQgPSBpa2ZwcmludGYgaWdub3JlIG9jIGZtdFxubGV0IGlicHJpbnRmIGIgZm10ID0gaWticHJpbnRmIGlnbm9yZSBiIGZtdFxubGV0IHByaW50ZiBmbXQgPSBmcHJpbnRmIHN0ZG91dCBmbXRcbmxldCBlcHJpbnRmIGZtdCA9IGZwcmludGYgc3RkZXJyIGZtdFxuXG5sZXQga3NwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBrJyBhY2MgPVxuICAgIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDY0IGluXG4gICAgc3RycHV0X2FjYyBidWYgYWNjO1xuICAgIGsgKEJ1ZmZlci5jb250ZW50cyBidWYpIGluXG4gIG1ha2VfcHJpbnRmIGsnIEVuZF9vZl9hY2MgZm10XG5cbmxldCBzcHJpbnRmIGZtdCA9IGtzcHJpbnRmIChmdW4gcyAtPiBzKSBmbXRcblxubGV0IGtwcmludGYgPSBrc3ByaW50ZlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBpZCA6ICdhIC0+ICdhID0gXCIlaWRlbnRpdHlcIlxubGV0IGNvbnN0IGMgXyA9IGNcbmxldCBmbGlwIGYgeCB5ID0gZiB5IHhcbmxldCBuZWdhdGUgcCB2ID0gbm90IChwIHYpXG5cbmV4Y2VwdGlvbiBGaW5hbGx5X3JhaXNlZCBvZiBleG5cblxubGV0ICgpID0gUHJpbnRleGMucmVnaXN0ZXJfcHJpbnRlciBAQCBmdW5jdGlvblxufCBGaW5hbGx5X3JhaXNlZCBleG4gLT4gU29tZSAoXCJGdW4uRmluYWxseV9yYWlzZWQ6IFwiIF4gUHJpbnRleGMudG9fc3RyaW5nIGV4bilcbnwgXyAtPiBOb25lXG5cbmxldCBwcm90ZWN0IH4oZmluYWxseSA6IHVuaXQgLT4gdW5pdCkgd29yayA9XG4gIGxldCBmaW5hbGx5X25vX2V4biAoKSA9XG4gICAgdHJ5IGZpbmFsbHkgKCkgd2l0aCBlIC0+XG4gICAgICBsZXQgYnQgPSBQcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICAgUHJpbnRleGMucmFpc2Vfd2l0aF9iYWNrdHJhY2UgKEZpbmFsbHlfcmFpc2VkIGUpIGJ0XG4gIGluXG4gIG1hdGNoIHdvcmsgKCkgd2l0aFxuICB8IHJlc3VsdCAtPiBmaW5hbGx5X25vX2V4biAoKSA7IHJlc3VsdFxuICB8IGV4Y2VwdGlvbiB3b3JrX2V4biAtPlxuICAgICAgbGV0IHdvcmtfYnQgPSBQcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICAgZmluYWxseV9ub19leG4gKCkgO1xuICAgICAgUHJpbnRleGMucmFpc2Vfd2l0aF9iYWNrdHJhY2Ugd29ya19leG4gd29ya19idFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNZXNzYWdlIGRpZ2VzdCAoTUQ1KSAqKVxuXG50eXBlIHQgPSBzdHJpbmdcblxubGV0IGNvbXBhcmUgPSBTdHJpbmcuY29tcGFyZVxubGV0IGVxdWFsID0gU3RyaW5nLmVxdWFsXG5cbmV4dGVybmFsIHVuc2FmZV9zdHJpbmc6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHQgPSBcImNhbWxfbWQ1X3N0cmluZ1wiXG5leHRlcm5hbCBjaGFubmVsOiBpbl9jaGFubmVsIC0+IGludCAtPiB0ID0gXCJjYW1sX21kNV9jaGFuXCJcblxubGV0IHN0cmluZyBzdHIgPVxuICB1bnNhZmVfc3RyaW5nIHN0ciAwIChTdHJpbmcubGVuZ3RoIHN0cilcblxubGV0IGJ5dGVzIGIgPSBzdHJpbmcgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYilcblxubGV0IHN1YnN0cmluZyBzdHIgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBTdHJpbmcubGVuZ3RoIHN0ciAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LnN1YnN0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX3N0cmluZyBzdHIgb2ZzIGxlblxuXG5sZXQgc3ViYnl0ZXMgYiBvZnMgbGVuID0gc3Vic3RyaW5nIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGIpIG9mcyBsZW5cblxubGV0IGZpbGUgZmlsZW5hbWUgPVxuICBsZXQgaWMgPSBvcGVuX2luX2JpbiBmaWxlbmFtZSBpblxuICBtYXRjaCBjaGFubmVsIGljICgtMSkgd2l0aFxuICAgIHwgZCAtPiBjbG9zZV9pbiBpYzsgZFxuICAgIHwgZXhjZXB0aW9uIGUgLT4gY2xvc2VfaW4gaWM7IHJhaXNlIGVcblxubGV0IG91dHB1dCBjaGFuIGRpZ2VzdCA9XG4gIG91dHB1dF9zdHJpbmcgY2hhbiBkaWdlc3RcblxubGV0IGlucHV0IGNoYW4gPSByZWFsbHlfaW5wdXRfc3RyaW5nIGNoYW4gMTZcblxubGV0IGNoYXJfaGV4IG4gPVxuICBDaGFyLnVuc2FmZV9jaHIgKG4gKyBpZiBuIDwgMTAgdGhlbiBDaGFyLmNvZGUgJzAnIGVsc2UgKENoYXIuY29kZSAnYScgLSAxMCkpXG5cbmxldCB0b19oZXggZCA9XG4gIGlmIFN0cmluZy5sZW5ndGggZCA8PiAxNiB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LnRvX2hleFwiO1xuICBsZXQgcmVzdWx0ID0gQnl0ZXMuY3JlYXRlIDMyIGluXG4gIGZvciBpID0gMCB0byAxNSBkb1xuICAgIGxldCB4ID0gQ2hhci5jb2RlIGQuW2ldIGluXG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXN1bHQgKGkqMikgKGNoYXJfaGV4ICh4IGxzciA0KSk7XG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXN1bHQgKGkqMisxKSAoY2hhcl9oZXggKHggbGFuZCAweDBmKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzdWx0XG5cbmxldCBmcm9tX2hleCBzID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBzIDw+IDMyIHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3QuZnJvbV9oZXhcIjtcbiAgbGV0IGRpZ2l0IGMgPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJzAnLi4nOScgLT4gQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJzAnXG4gICAgfCAnQScuLidGJyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnQScgKyAxMFxuICAgIHwgJ2EnLi4nZicgLT4gQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJ2EnICsgMTBcbiAgICB8IF8gLT4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJEaWdlc3QuZnJvbV9oZXhcIilcbiAgaW5cbiAgbGV0IGJ5dGUgaSA9IGRpZ2l0IHMuW2ldIGxzbCA0ICsgZGlnaXQgcy5baSsxXSBpblxuICBsZXQgcmVzdWx0ID0gQnl0ZXMuY3JlYXRlIDE2IGluXG4gIGZvciBpID0gMCB0byAxNSBkb1xuICAgIEJ5dGVzLnNldCByZXN1bHQgaSAoQ2hhci5jaHIgKGJ5dGUgKDIgKiBpKSkpO1xuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc3VsdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBQc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3JcbiAgIFRoaXMgaXMgYSBsYWdnZWQtRmlib25hY2NpIEYoNTUsIDI0LCArKSB3aXRoIGEgbW9kaWZpZWQgYWRkaXRpb25cbiAgIGZ1bmN0aW9uIHRvIGVuaGFuY2UgdGhlIG1peGluZyBvZiBiaXRzLlxuICAgSWYgd2UgdXNlIG5vcm1hbCBhZGRpdGlvbiwgdGhlIGxvdy1vcmRlciBiaXQgZmFpbHMgdGVzdHMgMSBhbmQgN1xuICAgb2YgdGhlIERpZWhhcmQgdGVzdCBzdWl0ZSwgYW5kIGJpdHMgMSBhbmQgMiBhbHNvIGZhaWwgdGVzdCA3LlxuICAgSWYgd2UgdXNlIG11bHRpcGxpY2F0aW9uIGFzIHN1Z2dlc3RlZCBieSBNYXJzYWdsaWEsIGl0IGRvZXNuJ3QgZmFyZVxuICAgbXVjaCBiZXR0ZXIuXG4gICBCeSBtaXhpbmcgdGhlIGJpdHMgb2Ygb25lIG9mIHRoZSBudW1iZXJzIGJlZm9yZSBhZGRpdGlvbiAoWE9SIHRoZVxuICAgNSBoaWdoLW9yZGVyIGJpdHMgaW50byB0aGUgbG93LW9yZGVyIGJpdHMpLCB3ZSBnZXQgYSBnZW5lcmF0b3IgdGhhdFxuICAgcGFzc2VzIGFsbCB0aGUgRGllaGFyZCB0ZXN0cy5cbiopXG5cbmV4dGVybmFsIHJhbmRvbV9zZWVkOiB1bml0IC0+IGludCBhcnJheSA9IFwiY2FtbF9zeXNfcmFuZG9tX3NlZWRcIlxuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcblxuICB0eXBlIHQgPSB7IHN0IDogaW50IGFycmF5OyBtdXRhYmxlIGlkeCA6IGludCB9XG5cbiAgbGV0IG5ld19zdGF0ZSAoKSA9IHsgc3QgPSBBcnJheS5tYWtlIDU1IDA7IGlkeCA9IDAgfVxuICBsZXQgYXNzaWduIHN0MSBzdDIgPVxuICAgIEFycmF5LmJsaXQgc3QyLnN0IDAgc3QxLnN0IDAgNTU7XG4gICAgc3QxLmlkeCA8LSBzdDIuaWR4XG5cblxuICBsZXQgZnVsbF9pbml0IHMgc2VlZCA9XG4gICAgbGV0IGNvbWJpbmUgYWNjdSB4ID0gRGlnZXN0LnN0cmluZyAoYWNjdSBeIEludC50b19zdHJpbmcgeCkgaW5cbiAgICBsZXQgZXh0cmFjdCBkID1cbiAgICAgIENoYXIuY29kZSBkLlswXSArIChDaGFyLmNvZGUgZC5bMV0gbHNsIDgpICsgKENoYXIuY29kZSBkLlsyXSBsc2wgMTYpXG4gICAgICArIChDaGFyLmNvZGUgZC5bM10gbHNsIDI0KVxuICAgIGluXG4gICAgbGV0IHNlZWQgPSBpZiBBcnJheS5sZW5ndGggc2VlZCA9IDAgdGhlbiBbfCAwIHxdIGVsc2Ugc2VlZCBpblxuICAgIGxldCBsID0gQXJyYXkubGVuZ3RoIHNlZWQgaW5cbiAgICBmb3IgaSA9IDAgdG8gNTQgZG9cbiAgICAgIHMuc3QuKGkpIDwtIGk7XG4gICAgZG9uZTtcbiAgICBsZXQgYWNjdSA9IHJlZiBcInhcIiBpblxuICAgIGZvciBpID0gMCB0byA1NCArIEludC5tYXggNTUgbCBkb1xuICAgICAgbGV0IGogPSBpIG1vZCA1NSBpblxuICAgICAgbGV0IGsgPSBpIG1vZCBsIGluXG4gICAgICBhY2N1IDo9IGNvbWJpbmUgIWFjY3Ugc2VlZC4oayk7XG4gICAgICBzLnN0LihqKSA8LSAocy5zdC4oaikgbHhvciBleHRyYWN0ICFhY2N1KSBsYW5kIDB4M0ZGRkZGRkY7ICAoKiBQUiM1NTc1ICopXG4gICAgZG9uZTtcbiAgICBzLmlkeCA8LSAwXG5cblxuICBsZXQgbWFrZSBzZWVkID1cbiAgICBsZXQgcmVzdWx0ID0gbmV3X3N0YXRlICgpIGluXG4gICAgZnVsbF9pbml0IHJlc3VsdCBzZWVkO1xuICAgIHJlc3VsdFxuXG5cbiAgbGV0IG1ha2Vfc2VsZl9pbml0ICgpID0gbWFrZSAocmFuZG9tX3NlZWQgKCkpXG5cbiAgbGV0IGNvcHkgcyA9XG4gICAgbGV0IHJlc3VsdCA9IG5ld19zdGF0ZSAoKSBpblxuICAgIGFzc2lnbiByZXN1bHQgcztcbiAgICByZXN1bHRcblxuXG4gICgqIFJldHVybnMgMzAgcmFuZG9tIGJpdHMgYXMgYW4gaW50ZWdlciAwIDw9IHggPCAxMDczNzQxODI0ICopXG4gIGxldCBiaXRzIHMgPVxuICAgIHMuaWR4IDwtIChzLmlkeCArIDEpIG1vZCA1NTtcbiAgICBsZXQgY3VydmFsID0gcy5zdC4ocy5pZHgpIGluXG4gICAgbGV0IG5ld3ZhbCA9IHMuc3QuKChzLmlkeCArIDI0KSBtb2QgNTUpXG4gICAgICAgICAgICAgICAgICsgKGN1cnZhbCBseG9yICgoY3VydmFsIGxzciAyNSkgbGFuZCAweDFGKSkgaW5cbiAgICBsZXQgbmV3dmFsMzAgPSBuZXd2YWwgbGFuZCAweDNGRkZGRkZGIGluICAoKiBQUiM1NTc1ICopXG4gICAgcy5zdC4ocy5pZHgpIDwtIG5ld3ZhbDMwO1xuICAgIG5ld3ZhbDMwXG5cblxuICBsZXQgcmVjIGludGF1eCBzIG4gPVxuICAgIGxldCByID0gYml0cyBzIGluXG4gICAgbGV0IHYgPSByIG1vZCBuIGluXG4gICAgaWYgciAtIHYgPiAweDNGRkZGRkZGIC0gbiArIDEgdGhlbiBpbnRhdXggcyBuIGVsc2UgdlxuXG4gIGxldCBpbnQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPiAweDNGRkZGRkZGIHx8IGJvdW5kIDw9IDBcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludFwiXG4gICAgZWxzZSBpbnRhdXggcyBib3VuZFxuXG4gIGxldCByZWMgaW50NjNhdXggcyBuID1cbiAgICBsZXQgbWF4X2ludF8zMiA9ICgxIGxzbCAzMCkgKyAweDNGRkZGRkZGIGluICgqIDB4N0ZGRkZGRkYgKilcbiAgICBsZXQgYjEgPSBiaXRzIHMgaW5cbiAgICBsZXQgYjIgPSBiaXRzIHMgaW5cbiAgICBsZXQgKHIsIG1heF9pbnQpID1cbiAgICAgIGlmIG4gPD0gbWF4X2ludF8zMiB0aGVuXG4gICAgICAgICgqIDMxIHJhbmRvbSBiaXRzIG9uIGJvdGggNjQtYml0IE9DYW1sIGFuZCBKYXZhU2NyaXB0LlxuICAgICAgICAgICBVc2UgdXBwZXIgMTUgYml0cyBvZiBiMSBhbmQgMTYgYml0cyBvZiBiMi4gKilcbiAgICAgICAgbGV0IGJwb3MgPVxuICAgICAgICAgICgoKGIyIGxhbmQgMHgzRkZGQzAwMCkgbHNsIDEpIGxvciAoYjEgbHNyIDE1KSlcbiAgICAgICAgaW5cbiAgICAgICAgICAoYnBvcywgbWF4X2ludF8zMilcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IGIzID0gYml0cyBzIGluXG4gICAgICAgICgqIDYyIHJhbmRvbSBiaXRzIG9uIDY0LWJpdCBPQ2FtbDsgdW5yZWFjaGFibGUgb24gSmF2YVNjcmlwdC5cbiAgICAgICAgICAgVXNlIHVwcGVyIDIwIGJpdHMgb2YgYjEgYW5kIDIxIGJpdHMgb2YgYjIgYW5kIGIzLiAqKVxuICAgICAgICBsZXQgYnBvcyA9XG4gICAgICAgICAgKCgoKGIzIGxhbmQgMHgzRkZGRkUwMCkgbHNsIDEyKSBsb3IgKGIyIGxzciA5KSkgbHNsIDIwKVxuICAgICAgICAgICAgbG9yIChiMSBsc3IgMTApXG4gICAgICAgIGluXG4gICAgICAgICAgKGJwb3MsIG1heF9pbnQpXG4gICAgaW5cbiAgICBsZXQgdiA9IHIgbW9kIG4gaW5cbiAgICBpZiByIC0gdiA+IG1heF9pbnQgLSBuICsgMSB0aGVuIGludDYzYXV4IHMgbiBlbHNlIHZcblxuICBsZXQgZnVsbF9pbnQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMCB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIlJhbmRvbS5mdWxsX2ludFwiXG4gICAgZWxzZSBpZiBib3VuZCA+IDB4M0ZGRkZGRkYgdGhlblxuICAgICAgaW50NjNhdXggcyBib3VuZFxuICAgIGVsc2VcbiAgICAgIGludGF1eCBzIGJvdW5kXG5cblxuICBsZXQgcmVjIGludDMyYXV4IHMgbiA9XG4gICAgbGV0IGIxID0gSW50MzIub2ZfaW50IChiaXRzIHMpIGluXG4gICAgbGV0IGIyID0gSW50MzIuc2hpZnRfbGVmdCAoSW50MzIub2ZfaW50IChiaXRzIHMgbGFuZCAxKSkgMzAgaW5cbiAgICBsZXQgciA9IEludDMyLmxvZ29yIGIxIGIyIGluXG4gICAgbGV0IHYgPSBJbnQzMi5yZW0gciBuIGluXG4gICAgaWYgSW50MzIuc3ViIHIgdiA+IEludDMyLmFkZCAoSW50MzIuc3ViIEludDMyLm1heF9pbnQgbikgMWxcbiAgICB0aGVuIGludDMyYXV4IHMgblxuICAgIGVsc2UgdlxuXG4gIGxldCBpbnQzMiBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA8PSAwbFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50MzJcIlxuICAgIGVsc2UgaW50MzJhdXggcyBib3VuZFxuXG5cbiAgbGV0IHJlYyBpbnQ2NGF1eCBzIG4gPVxuICAgIGxldCBiMSA9IEludDY0Lm9mX2ludCAoYml0cyBzKSBpblxuICAgIGxldCBiMiA9IEludDY0LnNoaWZ0X2xlZnQgKEludDY0Lm9mX2ludCAoYml0cyBzKSkgMzAgaW5cbiAgICBsZXQgYjMgPSBJbnQ2NC5zaGlmdF9sZWZ0IChJbnQ2NC5vZl9pbnQgKGJpdHMgcyBsYW5kIDcpKSA2MCBpblxuICAgIGxldCByID0gSW50NjQubG9nb3IgYjEgKEludDY0LmxvZ29yIGIyIGIzKSBpblxuICAgIGxldCB2ID0gSW50NjQucmVtIHIgbiBpblxuICAgIGlmIEludDY0LnN1YiByIHYgPiBJbnQ2NC5hZGQgKEludDY0LnN1YiBJbnQ2NC5tYXhfaW50IG4pIDFMXG4gICAgdGhlbiBpbnQ2NGF1eCBzIG5cbiAgICBlbHNlIHZcblxuICBsZXQgaW50NjQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMExcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludDY0XCJcbiAgICBlbHNlIGludDY0YXV4IHMgYm91bmRcblxuXG4gIGxldCBuYXRpdmVpbnQgPVxuICAgIGlmIE5hdGl2ZWludC5zaXplID0gMzJcbiAgICB0aGVuIGZ1biBzIGJvdW5kIC0+IE5hdGl2ZWludC5vZl9pbnQzMiAoaW50MzIgcyAoTmF0aXZlaW50LnRvX2ludDMyIGJvdW5kKSlcbiAgICBlbHNlIGZ1biBzIGJvdW5kIC0+IEludDY0LnRvX25hdGl2ZWludCAoaW50NjQgcyAoSW50NjQub2ZfbmF0aXZlaW50IGJvdW5kKSlcblxuXG4gICgqIFJldHVybnMgYSBmbG9hdCAwIDw9IHggPD0gMSB3aXRoIGF0IG1vc3QgNjAgYml0cyBvZiBwcmVjaXNpb24uICopXG4gIGxldCByYXdmbG9hdCBzID1cbiAgICBsZXQgc2NhbGUgPSAxMDczNzQxODI0LjAgICgqIDJeMzAgKilcbiAgICBhbmQgcjEgPSBTdGRsaWIuZmxvYXQgKGJpdHMgcylcbiAgICBhbmQgcjIgPSBTdGRsaWIuZmxvYXQgKGJpdHMgcylcbiAgICBpbiAocjEgLy4gc2NhbGUgKy4gcjIpIC8uIHNjYWxlXG5cblxuICBsZXQgZmxvYXQgcyBib3VuZCA9IHJhd2Zsb2F0IHMgKi4gYm91bmRcblxuICBsZXQgYm9vbCBzID0gKGJpdHMgcyBsYW5kIDEgPSAwKVxuXG4gIGxldCBiaXRzMzIgcyA9XG4gICAgbGV0IGIxID0gSW50MzIuKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKG9mX2ludCAoYml0cyBzKSkgMTQpIGluICAoKiAxNiBiaXRzICopXG4gICAgbGV0IGIyID0gSW50MzIuKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKG9mX2ludCAoYml0cyBzKSkgMTQpIGluICAoKiAxNiBiaXRzICopXG4gICAgSW50MzIuKGxvZ29yIGIxIChzaGlmdF9sZWZ0IGIyIDE2KSlcblxuICBsZXQgYml0czY0IHMgPVxuICAgIGxldCBiMSA9IEludDY0LihzaGlmdF9yaWdodF9sb2dpY2FsIChvZl9pbnQgKGJpdHMgcykpIDkpIGluICAoKiAyMSBiaXRzICopXG4gICAgbGV0IGIyID0gSW50NjQuKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKG9mX2ludCAoYml0cyBzKSkgOSkgaW4gICgqIDIxIGJpdHMgKilcbiAgICBsZXQgYjMgPSBJbnQ2NC4oc2hpZnRfcmlnaHRfbG9naWNhbCAob2ZfaW50IChiaXRzIHMpKSA4KSBpbiAgKCogMjIgYml0cyAqKVxuICAgIEludDY0Lihsb2dvciBiMSAobG9nb3IgKHNoaWZ0X2xlZnQgYjIgMjEpIChzaGlmdF9sZWZ0IGIzIDQyKSkpXG5cbiAgbGV0IG5hdGl2ZWJpdHMgPVxuICAgIGlmIE5hdGl2ZWludC5zaXplID0gMzJcbiAgICB0aGVuIGZ1biBzIC0+IE5hdGl2ZWludC5vZl9pbnQzMiAoYml0czMyIHMpXG4gICAgZWxzZSBmdW4gcyAtPiBJbnQ2NC50b19uYXRpdmVpbnQgKGJpdHM2NCBzKVxuXG5lbmRcblxuKCogVGhpcyBpcyB0aGUgc3RhdGUgeW91IGdldCB3aXRoIFtpbml0IDI3MTgyODE4XSBhbmQgdGhlbiBhcHBseWluZ1xuICAgdGhlIFwibGFuZCAweDNGRkZGRkZGXCIgZmlsdGVyIHRvIHRoZW0uICBTZWUgIzU1NzUsICM1NzkzLCAjNTk3Ny4gKilcbmxldCBkZWZhdWx0ID0ge1xuICBTdGF0ZS5zdCA9IFt8XG4gICAgICAweDNhZTI1MjJiOyAweDFkOGQ0NjM0OyAweDE1YjRmYWQwOyAweDE4YjE0YWNlOyAweDEyZjhhM2M0OyAweDNiMDg2YzQ3O1xuICAgICAgMHgxNmQ0NjdkNjsgMHgxMDFkOTFjNzsgMHgzMjFkZjE3NzsgMHgwMTc2YzE5MzsgMHgxZmY3MmJmMTsgMHgxZTg4OTEwOTtcbiAgICAgIDB4MGI0NjRiMTg7IDB4MmI4NmI5N2M7IDB4MDg5MWRhNDg7IDB4MDMxMzc0NjM7IDB4MDg1YWM1YTE7IDB4MTVkNjFmMmY7XG4gICAgICAweDNiY2VkMzU5OyAweDI5YzFjMTMyOyAweDNhODY3NjZlOyAweDM2NmQ4Yzg2OyAweDFmNWI2MjIyOyAweDNjZTFiNTlmO1xuICAgICAgMHgyZWJmNzhlMTsgMHgyN2NkMWI4NjsgMHgyNThmM2RjMzsgMHgzODlhODE5NDsgMHgwMmU0YzQ0YzsgMHgxOGM0M2Y3ZDtcbiAgICAgIDB4MGY2ZTUzNGY7IDB4MWU3ZGYzNTk7IDB4MDU1ZDBiN2U7IDB4MTBlODRlN2U7IDB4MTI2MTk4ZTQ7IDB4MGU3NzIyY2I7XG4gICAgICAweDFjYmVkZTI4OyAweDMzOTFiOTY0OyAweDNkNDBlOTJhOyAweDBjNTk5MzNkOyAweDBiOGNkMGI3OyAweDI0ZWZmZjFjO1xuICAgICAgMHgyODAzZmRhYTsgMHgwOGViYzcyZTsgMHgwZjUyMmUzMjsgMHgwNTM5OGVkYzsgMHgyMTQ0YTA0YzsgMHgwYWVmM2NiZDtcbiAgICAgIDB4MDFhZDQ3MTk7IDB4MzViOTNjZDY7IDB4MmE1NTlkNGY7IDB4MWU2ZmQ3Njg7IDB4MjZlMjdmMzY7IDB4MTg2ZjE4YzM7XG4gICAgICAweDJmYmY5NjdhO1xuICAgIHxdO1xuICBTdGF0ZS5pZHggPSAwO1xufVxuXG5sZXQgYml0cyAoKSA9IFN0YXRlLmJpdHMgZGVmYXVsdFxubGV0IGludCBib3VuZCA9IFN0YXRlLmludCBkZWZhdWx0IGJvdW5kXG5sZXQgZnVsbF9pbnQgYm91bmQgPSBTdGF0ZS5mdWxsX2ludCBkZWZhdWx0IGJvdW5kXG5sZXQgaW50MzIgYm91bmQgPSBTdGF0ZS5pbnQzMiBkZWZhdWx0IGJvdW5kXG5sZXQgbmF0aXZlaW50IGJvdW5kID0gU3RhdGUubmF0aXZlaW50IGRlZmF1bHQgYm91bmRcbmxldCBpbnQ2NCBib3VuZCA9IFN0YXRlLmludDY0IGRlZmF1bHQgYm91bmRcbmxldCBmbG9hdCBzY2FsZSA9IFN0YXRlLmZsb2F0IGRlZmF1bHQgc2NhbGVcbmxldCBib29sICgpID0gU3RhdGUuYm9vbCBkZWZhdWx0XG5sZXQgYml0czMyICgpID0gU3RhdGUuYml0czMyIGRlZmF1bHRcbmxldCBiaXRzNjQgKCkgPSBTdGF0ZS5iaXRzNjQgZGVmYXVsdFxubGV0IG5hdGl2ZWJpdHMgKCkgPSBTdGF0ZS5uYXRpdmViaXRzIGRlZmF1bHRcblxubGV0IGZ1bGxfaW5pdCBzZWVkID0gU3RhdGUuZnVsbF9pbml0IGRlZmF1bHQgc2VlZFxubGV0IGluaXQgc2VlZCA9IFN0YXRlLmZ1bGxfaW5pdCBkZWZhdWx0IFt8IHNlZWQgfF1cbmxldCBzZWxmX2luaXQgKCkgPSBmdWxsX2luaXQgKHJhbmRvbV9zZWVkKCkpXG5cbigqIE1hbmlwdWxhdGluZyB0aGUgY3VycmVudCBzdGF0ZS4gKilcblxubGV0IGdldF9zdGF0ZSAoKSA9IFN0YXRlLmNvcHkgZGVmYXVsdFxubGV0IHNldF9zdGF0ZSBzID0gU3RhdGUuYXNzaWduIGRlZmF1bHQgc1xuXG4oKioqKioqKioqKioqKioqKioqKipcblxuKCogVGVzdCBmdW5jdGlvbnMuICBOb3QgaW5jbHVkZWQgaW4gdGhlIGxpYnJhcnkuXG4gICBUaGUgW2NoaXNxdWFyZV0gZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCB3aXRoIG4gPiAxMHIuXG4gICBJdCByZXR1cm5zIGEgdHJpcGxlIChsb3csIGFjdHVhbCwgaGlnaCkuXG4gICBJZiBsb3cgPD0gYWN0dWFsIDw9IGhpZ2gsIHRoZSBbZ10gZnVuY3Rpb24gcGFzc2VkIHRoZSB0ZXN0LFxuICAgb3RoZXJ3aXNlIGl0IGZhaWxlZC5cblxuICBTb21lIHJlc3VsdHM6XG5cbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgNTAwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAwIDEwMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMjRcbmluaXQgMjk5NzkyNjQzOyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDI0XG5pbml0IDE0MTQyMTM2OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDI0XG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYgMTAyNDsgY2hpc3F1YXJlIGRpZmYgMTAwMDAwIDEwMjRcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZiAxMDA7IGNoaXNxdWFyZSBkaWZmIDEwMDAwMCAxMDBcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZjIgMTAyNDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDI0XG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYyIDEwMDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDBcbmluaXQgMTQxNDIxMzY7IGluaXRfZGlmZjIgMTAwOyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMFxuaW5pdCAyOTk3OTI2NDM7IGluaXRfZGlmZjIgMTAwOyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMFxuLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5MzYuNzU0NDQ2Nzk2NjMyNDY1LCA5OTcuNSwgMTA2My4yNDU1NTMyMDMzNjc1NClcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDg5Ljc0MDAwMDAwMDAwNTIzODcsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoNDg1OC41Nzg2NDM3NjI2OSwgNTA0NS41LCA1MTQxLjQyMTM1NjIzNzMxKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID1cbig5MzYuNzU0NDQ2Nzk2NjMyNDY1LCA5NDQuODA1OTk5OTk5OTgyMzA1LCAxMDYzLjI0NTU1MzIwMzM2NzU0KVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwMTkuMTk3NDQwMDAwMDAzNTUsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwNTkuMzE3NzYwMDAwMDA1MzYsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwMzkuOTg0NjM5OTk5OTk1MTIsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwNTQuMzgyMDc5OTk5OTk1NzcsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgOTAuMDk2MDAwMDAwMDA1LCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwNzYuNzg3MjAwMDAwMDA2MTIsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODUuMTc2MDAwMDAwMDA2NzUyMSwgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDg1LjIxNjAwMDAwMDAwMDM0OTIsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4MC42MjIwMDAwMDAwMDMwMjY4LCAxMjAuKVxuXG4qKVxuXG4oKiBSZXR1cm4gdGhlIHN1bSBvZiB0aGUgc3F1YXJlcyBvZiB2W2kwLGkxWyAqKVxubGV0IHJlYyBzdW1zcSB2IGkwIGkxID1cbiAgaWYgaTAgPj0gaTEgdGhlbiAwLjBcbiAgZWxzZSBpZiBpMSA9IGkwICsgMSB0aGVuIFN0ZGxpYi5mbG9hdCB2LihpMCkgKi4gU3RkbGliLmZsb2F0IHYuKGkwKVxuICBlbHNlIHN1bXNxIHYgaTAgKChpMCtpMSkvMikgKy4gc3Vtc3EgdiAoKGkwK2kxKS8yKSBpMVxuXG5cbmxldCBjaGlzcXVhcmUgZyBuIHIgPVxuICBpZiBuIDw9IDEwICogciB0aGVuIGludmFsaWRfYXJnIFwiY2hpc3F1YXJlXCI7XG4gIGxldCBmID0gQXJyYXkubWFrZSByIDAgaW5cbiAgZm9yIGkgPSAxIHRvIG4gZG9cbiAgICBsZXQgdCA9IGcgciBpblxuICAgIGYuKHQpIDwtIGYuKHQpICsgMVxuICBkb25lO1xuICBsZXQgdCA9IHN1bXNxIGYgMCByXG4gIGFuZCByID0gU3RkbGliLmZsb2F0IHJcbiAgYW5kIG4gPSBTdGRsaWIuZmxvYXQgbiBpblxuICBsZXQgc3IgPSAyLjAgKi4gc3FydCByIGluXG4gIChyIC0uIHNyLCAgIChyICouIHQgLy4gbikgLS4gbiwgICByICsuIHNyKVxuXG5cbigqIFRoaXMgaXMgdG8gdGVzdCBmb3IgbGluZWFyIGRlcGVuZGVuY2llcyBiZXR3ZWVuIHN1Y2Nlc3NpdmUgcmFuZG9tIG51bWJlcnMuXG4qKVxubGV0IHN0ID0gcmVmIDBcbmxldCBpbml0X2RpZmYgciA9IHN0IDo9IGludCByXG5sZXQgZGlmZiByID1cbiAgbGV0IHgxID0gIXN0XG4gIGFuZCB4MiA9IGludCByXG4gIGluXG4gIHN0IDo9IHgyO1xuICBpZiB4MSA+PSB4MiB0aGVuXG4gICAgeDEgLSB4MlxuICBlbHNlXG4gICAgciArIHgxIC0geDJcblxuXG5sZXQgc3QxID0gcmVmIDBcbmFuZCBzdDIgPSByZWYgMFxuXG5cbigqIFRoaXMgaXMgdG8gdGVzdCBmb3IgcXVhZHJhdGljIGRlcGVuZGVuY2llcyBiZXR3ZWVuIHN1Y2Nlc3NpdmUgcmFuZG9tXG4gICBudW1iZXJzLlxuKilcbmxldCBpbml0X2RpZmYyIHIgPSBzdDEgOj0gaW50IHI7IHN0MiA6PSBpbnQgclxubGV0IGRpZmYyIHIgPVxuICBsZXQgeDEgPSAhc3QxXG4gIGFuZCB4MiA9ICFzdDJcbiAgYW5kIHgzID0gaW50IHJcbiAgaW5cbiAgc3QxIDo9IHgyO1xuICBzdDIgOj0geDM7XG4gICh4MyAtIHgyIC0geDIgKyB4MSArIDIqcikgbW9kIHJcblxuXG4qKioqKioqKioqKioqKioqKioqKilcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogSGFzaCB0YWJsZXMgKilcblxuKCogV2UgZG8gZHluYW1pYyBoYXNoaW5nLCBhbmQgcmVzaXplIHRoZSB0YWJsZSBhbmQgcmVoYXNoIHRoZSBlbGVtZW50c1xuICAgd2hlbiBidWNrZXRzIGJlY29tZSB0b28gbG9uZy4gKilcblxudHlwZSAoJ2EsICdiKSB0ID1cbiAgeyBtdXRhYmxlIHNpemU6IGludDsgICAgICAgICAgICAgICAgICAgICAgICAoKiBudW1iZXIgb2YgZW50cmllcyAqKVxuICAgIG11dGFibGUgZGF0YTogKCdhLCAnYikgYnVja2V0bGlzdCBhcnJheTsgICgqIHRoZSBidWNrZXRzICopXG4gICAgc2VlZDogaW50OyAgICAgICAgICAgICAgICAgICAgICAgICgqIGZvciByYW5kb21pemF0aW9uICopXG4gICAgbXV0YWJsZSBpbml0aWFsX3NpemU6IGludDsgICAgICAgICAgICAgICAgKCogaW5pdGlhbCBhcnJheSBzaXplICopXG4gIH1cblxuYW5kICgnYSwgJ2IpIGJ1Y2tldGxpc3QgPVxuICAgIEVtcHR5XG4gIHwgQ29ucyBvZiB7IG11dGFibGUga2V5OiAnYTtcbiAgICAgICAgICAgICAgbXV0YWJsZSBkYXRhOiAnYjtcbiAgICAgICAgICAgICAgbXV0YWJsZSBuZXh0OiAoJ2EsICdiKSBidWNrZXRsaXN0IH1cblxuKCogVGhlIHNpZ24gb2YgaW5pdGlhbF9zaXplIGVuY29kZXMgdGhlIGZhY3QgdGhhdCBhIHRyYXZlcnNhbCBpc1xuICAgb25nb2luZyBvciBub3QuXG5cbiAgIFRoaXMgZGlzYWJsZXMgdGhlIGVmZmljaWVudCBpbiBwbGFjZSBpbXBsZW1lbnRhdGlvbiBvZiByZXNpemluZy5cbiopXG5cbmxldCBvbmdvaW5nX3RyYXZlcnNhbCBoID1cbiAgT2JqLnNpemUgKE9iai5yZXByIGgpIDwgNCAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gIHx8IGguaW5pdGlhbF9zaXplIDwgMFxuXG5sZXQgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoID1cbiAgaC5pbml0aWFsX3NpemUgPC0gLSBoLmluaXRpYWxfc2l6ZVxuXG4oKiBUbyBwaWNrIHJhbmRvbSBzZWVkcyBpZiByZXF1ZXN0ZWQgKilcblxubGV0IHJhbmRvbWl6ZWRfZGVmYXVsdCA9XG4gIGxldCBwYXJhbXMgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiT0NBTUxSVU5QQVJBTVwiIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJDQU1MUlVOUEFSQU1cIiB3aXRoIE5vdF9mb3VuZCAtPiBcIlwiIGluXG4gIFN0cmluZy5jb250YWlucyBwYXJhbXMgJ1InXG5cbmxldCByYW5kb21pemVkID0gcmVmIHJhbmRvbWl6ZWRfZGVmYXVsdFxuXG5sZXQgcmFuZG9taXplICgpID0gcmFuZG9taXplZCA6PSB0cnVlXG5sZXQgaXNfcmFuZG9taXplZCAoKSA9ICFyYW5kb21pemVkXG5cbmxldCBwcm5nID0gbGF6eSAoUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0KCkpXG5cbigqIEZ1bmN0aW9ucyB3aGljaCBhcHBlYXIgYmVmb3JlIHRoZSBmdW5jdG9yaWFsIGludGVyZmFjZSBtdXN0IGVpdGhlciBiZVxuICAgaW5kZXBlbmRlbnQgb2YgdGhlIGhhc2ggZnVuY3Rpb24gb3IgdGFrZSBpdCBhcyBhIHBhcmFtZXRlciAoc2VlICMyMjAyIGFuZFxuICAgY29kZSBiZWxvdyB0aGUgZnVuY3RvciBkZWZpbml0aW9ucy4gKilcblxuKCogQ3JlYXRpbmcgYSBmcmVzaCwgZW1wdHkgdGFibGUgKilcblxubGV0IHJlYyBwb3dlcl8yX2Fib3ZlIHggbiA9XG4gIGlmIHggPj0gbiB0aGVuIHhcbiAgZWxzZSBpZiB4ICogMiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4geFxuICBlbHNlIHBvd2VyXzJfYWJvdmUgKHggKiAyKSBuXG5cbmxldCBjcmVhdGUgPyhyYW5kb20gPSAhcmFuZG9taXplZCkgaW5pdGlhbF9zaXplID1cbiAgbGV0IHMgPSBwb3dlcl8yX2Fib3ZlIDE2IGluaXRpYWxfc2l6ZSBpblxuICBsZXQgc2VlZCA9IGlmIHJhbmRvbSB0aGVuIFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpIGVsc2UgMCBpblxuICB7IGluaXRpYWxfc2l6ZSA9IHM7IHNpemUgPSAwOyBzZWVkID0gc2VlZDsgZGF0YSA9IEFycmF5Lm1ha2UgcyBFbXB0eSB9XG5cbmxldCBjbGVhciBoID1cbiAgaWYgaC5zaXplID4gMCB0aGVuIGJlZ2luXG4gICAgaC5zaXplIDwtIDA7XG4gICAgQXJyYXkuZmlsbCBoLmRhdGEgMCAoQXJyYXkubGVuZ3RoIGguZGF0YSkgRW1wdHlcbiAgZW5kXG5cbmxldCByZXNldCBoID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgaWYgT2JqLnNpemUgKE9iai5yZXByIGgpIDwgNCAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gICAgfHwgbGVuID0gYWJzIGguaW5pdGlhbF9zaXplIHRoZW5cbiAgICBjbGVhciBoXG4gIGVsc2UgYmVnaW5cbiAgICBoLnNpemUgPC0gMDtcbiAgICBoLmRhdGEgPC0gQXJyYXkubWFrZSAoYWJzIGguaW5pdGlhbF9zaXplKSBFbXB0eVxuICBlbmRcblxubGV0IGNvcHlfYnVja2V0bGlzdCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gRW1wdHlcbiAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICBsZXQgcmVjIGxvb3AgcHJlYyA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgICBsZXQgciA9IENvbnMge2tleTsgZGF0YTsgbmV4dH0gaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgIHwgQ29ucyBwcmVjIC0+ICBwcmVjLm5leHQgPC0gclxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgbG9vcCByIG5leHRcbiAgICAgIGluXG4gICAgICBsZXQgciA9IENvbnMge2tleTsgZGF0YTsgbmV4dH0gaW5cbiAgICAgIGxvb3AgciBuZXh0O1xuICAgICAgclxuXG5sZXQgY29weSBoID0geyBoIHdpdGggZGF0YSA9IEFycmF5Lm1hcCBjb3B5X2J1Y2tldGxpc3QgaC5kYXRhIH1cblxubGV0IGxlbmd0aCBoID0gaC5zaXplXG5cbmxldCBpbnNlcnRfYWxsX2J1Y2tldHMgaW5kZXhmdW4gaW5wbGFjZSBvZGF0YSBuZGF0YSA9XG4gIGxldCBuc2l6ZSA9IEFycmF5Lmxlbmd0aCBuZGF0YSBpblxuICBsZXQgbmRhdGFfdGFpbCA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgbGV0IHJlYyBpbnNlcnRfYnVja2V0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGFzIGNlbGwgLT5cbiAgICAgICAgbGV0IGNlbGwgPVxuICAgICAgICAgIGlmIGlucGxhY2UgdGhlbiBjZWxsXG4gICAgICAgICAgZWxzZSBDb25zIHtrZXk7IGRhdGE7IG5leHQgPSBFbXB0eX1cbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG5pZHggPSBpbmRleGZ1biBrZXkgaW5cbiAgICAgICAgYmVnaW4gbWF0Y2ggbmRhdGFfdGFpbC4obmlkeCkgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IG5kYXRhLihuaWR4KSA8LSBjZWxsO1xuICAgICAgICB8IENvbnMgdGFpbCAtPiB0YWlsLm5leHQgPC0gY2VsbDtcbiAgICAgICAgZW5kO1xuICAgICAgICBuZGF0YV90YWlsLihuaWR4KSA8LSBjZWxsO1xuICAgICAgICBpbnNlcnRfYnVja2V0IG5leHRcbiAgaW5cbiAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBvZGF0YSAtIDEgZG9cbiAgICBpbnNlcnRfYnVja2V0IG9kYXRhLihpKVxuICBkb25lO1xuICBpZiBpbnBsYWNlIHRoZW5cbiAgICBmb3IgaSA9IDAgdG8gbnNpemUgLSAxIGRvXG4gICAgICBtYXRjaCBuZGF0YV90YWlsLihpKSB3aXRoXG4gICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICB8IENvbnMgdGFpbCAtPiB0YWlsLm5leHQgPC0gRW1wdHlcbiAgICBkb25lXG5cbmxldCByZXNpemUgaW5kZXhmdW4gaCA9XG4gIGxldCBvZGF0YSA9IGguZGF0YSBpblxuICBsZXQgb3NpemUgPSBBcnJheS5sZW5ndGggb2RhdGEgaW5cbiAgbGV0IG5zaXplID0gb3NpemUgKiAyIGluXG4gIGlmIG5zaXplIDwgU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiBiZWdpblxuICAgIGxldCBuZGF0YSA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgICBsZXQgaW5wbGFjZSA9IG5vdCAob25nb2luZ190cmF2ZXJzYWwgaCkgaW5cbiAgICBoLmRhdGEgPC0gbmRhdGE7ICAgICAgICAgICgqIHNvIHRoYXQgaW5kZXhmdW4gc2VlcyB0aGUgbmV3IGJ1Y2tldCBjb3VudCAqKVxuICAgIGluc2VydF9hbGxfYnVja2V0cyAoaW5kZXhmdW4gaCkgaW5wbGFjZSBvZGF0YSBuZGF0YVxuICBlbmRcblxubGV0IGl0ZXIgZiBoID1cbiAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT5cbiAgICAgICAgKClcbiAgICB8IENvbnN7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICBmIGtleSBkYXRhOyBkb19idWNrZXQgbmV4dCBpblxuICBsZXQgb2xkX3RyYXYgPSBvbmdvaW5nX3RyYXZlcnNhbCBoIGluXG4gIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgdHJ5XG4gICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBkb19idWNrZXQgZC4oaSlcbiAgICBkb25lO1xuICAgIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgd2l0aCBleG4gd2hlbiBub3Qgb2xkX3RyYXYgLT5cbiAgICBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgcmFpc2UgZXhuXG5cbmxldCByZWMgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBwcmVjID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gRW1wdHlcbiAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBFbXB0eVxuICAgICAgZW5kXG4gIHwgKENvbnMgKHtrZXk7IGRhdGE7IG5leHR9IGFzIGMpKSBhcyBzbG90IC0+XG4gICAgICBiZWdpbiBtYXRjaCBmIGtleSBkYXRhIHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgcHJlYyBuZXh0XG4gICAgICB8IFNvbWUgZGF0YSAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBzbG90XG4gICAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIHNsb3RcbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgYy5kYXRhIDwtIGRhdGE7XG4gICAgICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBzbG90IG5leHRcbiAgICAgIGVuZFxuXG5sZXQgZmlsdGVyX21hcF9pbnBsYWNlIGYgaCA9XG4gIGxldCBkID0gaC5kYXRhIGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIEVtcHR5IGguZGF0YS4oaSlcbiAgICBkb25lO1xuICAgIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaFxuICB3aXRoIGV4biB3aGVuIG5vdCBvbGRfdHJhdiAtPlxuICAgIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICByYWlzZSBleG5cblxubGV0IGZvbGQgZiBoIGluaXQgPVxuICBsZXQgcmVjIGRvX2J1Y2tldCBiIGFjY3UgPVxuICAgIG1hdGNoIGIgd2l0aFxuICAgICAgRW1wdHkgLT5cbiAgICAgICAgYWNjdVxuICAgIHwgQ29uc3trZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIGRvX2J1Y2tldCBuZXh0IChmIGtleSBkYXRhIGFjY3UpIGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgIGxldCBhY2N1ID0gcmVmIGluaXQgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBhY2N1IDo9IGRvX2J1Y2tldCBkLihpKSAhYWNjdVxuICAgIGRvbmU7XG4gICAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgICFhY2N1XG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG50eXBlIHN0YXRpc3RpY3MgPSB7XG4gIG51bV9iaW5kaW5nczogaW50O1xuICBudW1fYnVja2V0czogaW50O1xuICBtYXhfYnVja2V0X2xlbmd0aDogaW50O1xuICBidWNrZXRfaGlzdG9ncmFtOiBpbnQgYXJyYXlcbn1cblxubGV0IHJlYyBidWNrZXRfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFjY3VcbiAgfCBDb25ze25leHR9IC0+IGJ1Y2tldF9sZW5ndGggKGFjY3UgKyAxKSBuZXh0XG5cbmxldCBzdGF0cyBoID1cbiAgbGV0IG1ibCA9XG4gICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gbSBiIC0+IEludC5tYXggbSAoYnVja2V0X2xlbmd0aCAwIGIpKSAwIGguZGF0YSBpblxuICBsZXQgaGlzdG8gPSBBcnJheS5tYWtlIChtYmwgKyAxKSAwIGluXG4gIEFycmF5Lml0ZXJcbiAgICAoZnVuIGIgLT5cbiAgICAgIGxldCBsID0gYnVja2V0X2xlbmd0aCAwIGIgaW5cbiAgICAgIGhpc3RvLihsKSA8LSBoaXN0by4obCkgKyAxKVxuICAgIGguZGF0YTtcbiAgeyBudW1fYmluZGluZ3MgPSBoLnNpemU7XG4gICAgbnVtX2J1Y2tldHMgPSBBcnJheS5sZW5ndGggaC5kYXRhO1xuICAgIG1heF9idWNrZXRfbGVuZ3RoID0gbWJsO1xuICAgIGJ1Y2tldF9oaXN0b2dyYW0gPSBoaXN0byB9XG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgdGJsID1cbiAgKCogY2FwdHVyZSBjdXJyZW50IGFycmF5LCBzbyB0aGF0IGV2ZW4gaWYgdGhlIHRhYmxlIGlzIHJlc2l6ZWQgd2VcbiAgICAga2VlcCBpdGVyYXRpbmcgb24gdGhlIHNhbWUgYXJyYXkgKilcbiAgbGV0IHRibF9kYXRhID0gdGJsLmRhdGEgaW5cbiAgKCogc3RhdGU6IGluZGV4ICogbmV4dCBidWNrZXQgdG8gdHJhdmVyc2UgKilcbiAgbGV0IHJlYyBhdXggaSBidWNrICgpID0gbWF0Y2ggYnVjayB3aXRoXG4gICAgfCBFbXB0eSAtPlxuICAgICAgICBpZiBpID0gQXJyYXkubGVuZ3RoIHRibF9kYXRhXG4gICAgICAgIHRoZW4gU2VxLk5pbFxuICAgICAgICBlbHNlIGF1eChpKzEpIHRibF9kYXRhLihpKSAoKVxuICAgIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICBTZXEuQ29ucyAoKGtleSwgZGF0YSksIGF1eCBpIG5leHQpXG4gIGluXG4gIGF1eCAwIEVtcHR5XG5cbmxldCB0b19zZXFfa2V5cyBtID0gU2VxLm1hcCBmc3QgKHRvX3NlcSBtKVxuXG5sZXQgdG9fc2VxX3ZhbHVlcyBtID0gU2VxLm1hcCBzbmQgKHRvX3NlcSBtKVxuXG4oKiBGdW5jdG9yaWFsIGludGVyZmFjZSAqKVxuXG5tb2R1bGUgdHlwZSBIYXNoZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBoYXNoOiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgU2VlZGVkSGFzaGVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgaGFzaDogaW50IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICEnYSB0XG4gICAgdmFsIGNyZWF0ZTogaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weTogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGFkZDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCByZW1vdmU6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2FsbDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICAgIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGxlbmd0aDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgc3RhdHM6ICdhIHQgLT4gc3RhdGlzdGljc1xuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2tleXMgOiBfIHQgLT4ga2V5IFNlcS50XG4gICAgdmFsIHRvX3NlcV92YWx1ZXMgOiAnYSB0IC0+ICdhIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCByZXBsYWNlX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICBlbmRcblxubW9kdWxlIHR5cGUgU2VlZGVkUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAhJ2EgdFxuICAgIHZhbCBjcmVhdGUgOiA/cmFuZG9tOmJvb2wgLT4gaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weSA6ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBhZGQgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIHJlbW92ZSA6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZCA6ICdhIHQgLT4ga2V5IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9hbGwgOiAnYSB0IC0+IGtleSAtPiAnYSBsaXN0XG4gICAgdmFsIHJlcGxhY2UgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIG1lbSA6ICdhIHQgLT4ga2V5IC0+IGJvb2xcbiAgICB2YWwgaXRlciA6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkIDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuICAgIHZhbCBzdGF0czogJ2EgdCAtPiBzdGF0aXN0aWNzXG4gICAgdmFsIHRvX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCB0b19zZXFfa2V5cyA6IF8gdCAtPiBrZXkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX3ZhbHVlcyA6ICdhIHQgLT4gJ2EgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIHJlcGxhY2Vfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZVNlZWRlZChIOiBTZWVkZWRIYXNoZWRUeXBlKTogKFNlZWRlZFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIGtleSA9IEgudFxuICAgIHR5cGUgJ2EgaGFzaHRibCA9IChrZXksICdhKSB0XG4gICAgdHlwZSAnYSB0ID0gJ2EgaGFzaHRibFxuICAgIGxldCBjcmVhdGUgPSBjcmVhdGVcbiAgICBsZXQgY2xlYXIgPSBjbGVhclxuICAgIGxldCByZXNldCA9IHJlc2V0XG4gICAgbGV0IGNvcHkgPSBjb3B5XG5cbiAgICBsZXQga2V5X2luZGV4IGgga2V5ID1cbiAgICAgIChILmhhc2ggaC5zZWVkIGtleSkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG5cbiAgICBsZXQgYWRkIGgga2V5IGRhdGEgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIGxldCBidWNrZXQgPSBDb25ze2tleTsgZGF0YTsgbmV4dD1oLmRhdGEuKGkpfSBpblxuICAgICAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcblxuICAgIGxldCByZWMgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IHByZWMgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICgpXG4gICAgICB8IChDb25zIHtrZXk9azsgbmV4dH0pIGFzIGMgLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGsga2V5XG4gICAgICAgICAgdGhlbiBiZWdpblxuICAgICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgICBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBuZXh0XG4gICAgICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gbmV4dFxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2UgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IGMgbmV4dFxuXG4gICAgbGV0IHJlbW92ZSBoIGtleSA9XG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICAgICAgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IEVtcHR5IGguZGF0YS4oaSlcblxuICAgIGxldCByZWMgZmluZF9yZWMga2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrIHRoZW4gZGF0YSBlbHNlIGZpbmRfcmVjIGtleSBuZXh0XG5cbiAgICBsZXQgZmluZCBoIGtleSA9XG4gICAgICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazEgdGhlbiBkMSBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazIgdGhlbiBkMiBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGszIHRoZW4gZDMgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dDNcblxuICAgIGxldCByZWMgZmluZF9yZWNfb3B0IGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsgdGhlbiBTb21lIGRhdGEgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHRcblxuICAgIGxldCBmaW5kX29wdCBoIGtleSA9XG4gICAgICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsxIHRoZW4gU29tZSBkMSBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsyIHRoZW4gU29tZSBkMiBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMyB0aGVuIFNvbWUgZDMgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHQzXG5cbiAgICBsZXQgZmluZF9hbGwgaCBrZXkgPVxuICAgICAgbGV0IHJlYyBmaW5kX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgW11cbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YT1kOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIGQgOjogZmluZF9pbl9idWNrZXQgbmV4dFxuICAgICAgICAgIGVsc2UgZmluZF9pbl9idWNrZXQgbmV4dCBpblxuICAgICAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbiAgICBsZXQgcmVjIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICB0cnVlXG4gICAgICB8IENvbnMgKHtrZXk9azsgbmV4dH0gYXMgc2xvdCkgLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGsga2V5XG4gICAgICAgICAgdGhlbiAoc2xvdC5rZXkgPC0ga2V5OyBzbG90LmRhdGEgPC0gZGF0YTsgZmFsc2UpXG4gICAgICAgICAgZWxzZSByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBuZXh0XG5cbiAgICBsZXQgcmVwbGFjZSBoIGtleSBkYXRhID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgICAgIGlmIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIGwgdGhlbiBiZWdpblxuICAgICAgICBoLmRhdGEuKGkpIDwtIENvbnN7a2V5OyBkYXRhOyBuZXh0PWx9O1xuICAgICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuICAgICAgZW5kXG5cbiAgICBsZXQgbWVtIGgga2V5ID1cbiAgICAgIGxldCByZWMgbWVtX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgQ29uc3trZXk9azsgbmV4dH0gLT5cbiAgICAgICAgICBILmVxdWFsIGsga2V5IHx8IG1lbV9pbl9idWNrZXQgbmV4dCBpblxuICAgICAgbWVtX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxuICAgIGxldCBhZGRfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gYWRkIHRibCBrIHYpIGlcblxuICAgIGxldCByZXBsYWNlX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG5cbiAgICBsZXQgaXRlciA9IGl0ZXJcbiAgICBsZXQgZmlsdGVyX21hcF9pbnBsYWNlID0gZmlsdGVyX21hcF9pbnBsYWNlXG4gICAgbGV0IGZvbGQgPSBmb2xkXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgIGxldCBzdGF0cyA9IHN0YXRzXG4gICAgbGV0IHRvX3NlcSA9IHRvX3NlcVxuICAgIGxldCB0b19zZXFfa2V5cyA9IHRvX3NlcV9rZXlzXG4gICAgbGV0IHRvX3NlcV92YWx1ZXMgPSB0b19zZXFfdmFsdWVzXG4gIGVuZFxuXG5tb2R1bGUgTWFrZShIOiBIYXNoZWRUeXBlKTogKFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWQoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgICBsZXQgZXF1YWwgPSBILmVxdWFsXG4gICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5cbigqIFBvbHltb3JwaGljIGhhc2ggZnVuY3Rpb24tYmFzZWQgdGFibGVzICopXG4oKiBDb2RlIGluY2x1ZGVkIGJlbG93IHRoZSBmdW5jdG9yaWFsIGludGVyZmFjZSB0byBndWFyZCBhZ2FpbnN0IGFjY2lkZW50YWxcbiAgIHVzZSAtIHNlZSAjMjIwMiAqKVxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6XG4gIGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGludCA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cblxubGV0IGhhc2ggeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCAwIHhcbmxldCBoYXNoX3BhcmFtIG4xIG4yIHggPSBzZWVkZWRfaGFzaF9wYXJhbSBuMSBuMiAwIHhcbmxldCBzZWVkZWRfaGFzaCBzZWVkIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgc2VlZCB4XG5cbmxldCBrZXlfaW5kZXggaCBrZXkgPVxuICBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPj0gNFxuICB0aGVuIChzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgaC5zZWVkIGtleSkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJIYXNodGJsOiB1bnN1cHBvcnRlZCBoYXNoIHRhYmxlIGZvcm1hdFwiXG5cbmxldCBhZGQgaCBrZXkgZGF0YSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIGxldCBidWNrZXQgPSBDb25ze2tleTsgZGF0YTsgbmV4dD1oLmRhdGEuKGkpfSBpblxuICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcblxubGV0IHJlYyByZW1vdmVfYnVja2V0IGggaSBrZXkgcHJlYyA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgICgpXG4gIHwgKENvbnMge2tleT1rOyBuZXh0fSkgYXMgYyAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gYmVnaW5cbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gbmV4dFxuICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gbmV4dFxuICAgICAgZW5kXG4gICAgICBlbHNlIHJlbW92ZV9idWNrZXQgaCBpIGtleSBjIG5leHRcblxubGV0IHJlbW92ZSBoIGtleSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIHJlbW92ZV9idWNrZXQgaCBpIGtleSBFbXB0eSBoLmRhdGEuKGkpXG5cbmxldCByZWMgZmluZF9yZWMga2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsgPSAwIHRoZW4gZGF0YSBlbHNlIGZpbmRfcmVjIGtleSBuZXh0XG5cbmxldCBmaW5kIGgga2V5ID1cbiAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsxID0gMCB0aGVuIGQxIGVsc2VcbiAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGsyID0gMCB0aGVuIGQyIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMyA9IDAgdGhlbiBkMyBlbHNlIGZpbmRfcmVjIGtleSBuZXh0M1xuXG5sZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBOb25lXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsgPSAwIHRoZW4gU29tZSBkYXRhIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0XG5cbmxldCBmaW5kX29wdCBoIGtleSA9XG4gIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gIHwgRW1wdHkgLT4gTm9uZVxuICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgaWYgY29tcGFyZSBrZXkgazEgPSAwIHRoZW4gU29tZSBkMSBlbHNlXG4gICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgaWYgY29tcGFyZSBrZXkgazIgPSAwIHRoZW4gU29tZSBkMiBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGszID0gMCB0aGVuIFNvbWUgZDMgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHQzXG5cbmxldCBmaW5kX2FsbCBoIGtleSA9XG4gIGxldCByZWMgZmluZF9pbl9idWNrZXQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBbXVxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGsga2V5ID0gMFxuICAgICAgdGhlbiBkYXRhIDo6IGZpbmRfaW5fYnVja2V0IG5leHRcbiAgICAgIGVsc2UgZmluZF9pbl9idWNrZXQgbmV4dCBpblxuICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxubGV0IHJlYyByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIHRydWVcbiAgfCBDb25zICh7a2V5PWs7IG5leHR9IGFzIHNsb3QpIC0+XG4gICAgICBpZiBjb21wYXJlIGsga2V5ID0gMFxuICAgICAgdGhlbiAoc2xvdC5rZXkgPC0ga2V5OyBzbG90LmRhdGEgPC0gZGF0YTsgZmFsc2UpXG4gICAgICBlbHNlIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIG5leHRcblxubGV0IHJlcGxhY2UgaCBrZXkgZGF0YSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIGxldCBsID0gaC5kYXRhLihpKSBpblxuICBpZiByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBsIHRoZW4gYmVnaW5cbiAgICBoLmRhdGEuKGkpIDwtIENvbnN7a2V5OyBkYXRhOyBuZXh0PWx9O1xuICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcbiAgZW5kXG5cbmxldCBtZW0gaCBrZXkgPVxuICBsZXQgcmVjIG1lbV9pbl9idWNrZXQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBmYWxzZVxuICB8IENvbnN7a2V5PWs7IG5leHR9IC0+XG4gICAgICBjb21wYXJlIGsga2V5ID0gMCB8fCBtZW1faW5fYnVja2V0IG5leHQgaW5cbiAgbWVtX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxubGV0IGFkZF9zZXEgdGJsIGkgPVxuICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IGFkZCB0YmwgayB2KSBpXG5cbmxldCByZXBsYWNlX3NlcSB0YmwgaSA9XG4gIFNlcS5pdGVyIChmdW4gKGssdikgLT4gcmVwbGFjZSB0YmwgayB2KSBpXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gIHRibFxuXG5sZXQgcmVidWlsZCA/KHJhbmRvbSA9ICFyYW5kb21pemVkKSBoID1cbiAgbGV0IHMgPSBwb3dlcl8yX2Fib3ZlIDE2IChBcnJheS5sZW5ndGggaC5kYXRhKSBpblxuICBsZXQgc2VlZCA9XG4gICAgaWYgcmFuZG9tIHRoZW4gUmFuZG9tLlN0YXRlLmJpdHMgKExhenkuZm9yY2UgcHJuZylcbiAgICBlbHNlIGlmIE9iai5zaXplIChPYmoucmVwciBoKSA+PSA0IHRoZW4gaC5zZWVkXG4gICAgZWxzZSAwIGluXG4gIGxldCBoJyA9IHtcbiAgICBzaXplID0gaC5zaXplO1xuICAgIGRhdGEgPSBBcnJheS5tYWtlIHMgRW1wdHk7XG4gICAgc2VlZCA9IHNlZWQ7XG4gICAgaW5pdGlhbF9zaXplID0gaWYgT2JqLnNpemUgKE9iai5yZXByIGgpID49IDQgdGhlbiBoLmluaXRpYWxfc2l6ZSBlbHNlIHNcbiAgfSBpblxuICBpbnNlcnRfYWxsX2J1Y2tldHMgKGtleV9pbmRleCBoJykgZmFsc2UgaC5kYXRhIGgnLmRhdGE7XG4gIGgnXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqKiBXZWFrIGFycmF5IG9wZXJhdGlvbnMgKilcblxudHlwZSAhJ2EgdFxuXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gJ2EgdCA9IFwiY2FtbF93ZWFrX2NyZWF0ZVwiXG5cbmxldCBjcmVhdGUgbCA9XG4gIGlmIG5vdCAoMCA8PSBsICYmIGwgPD0gT2JqLkVwaGVtZXJvbi5tYXhfZXBoZV9sZW5ndGgpIHRoZW5cbiAgICBpbnZhbGlkX2FyZyhcIldlYWsuY3JlYXRlXCIpO1xuICBjcmVhdGUgbFxuXG4oKiogbnVtYmVyIG9mIGFkZGl0aW9uYWwgdmFsdWVzIGluIGEgd2VhayBwb2ludGVyICopXG5sZXQgYWRkaXRpb25hbF92YWx1ZXMgPSAyXG5cbmxldCBsZW5ndGggeCA9IE9iai5zaXplKE9iai5yZXByIHgpIC0gYWRkaXRpb25hbF92YWx1ZXNcblxubGV0IHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBtc2cgPVxuICBpZiBub3QgKDAgPD0gbyAmJiBvIDwgbGVuZ3RoIGUpIHRoZW5cbiAgICBpbnZhbGlkX2FyZyhtc2cpXG5cbmV4dGVybmFsIHNldCcgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2tleVwiXG5leHRlcm5hbCB1bnNldCA6ICdhIHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9rZXlcIlxubGV0IHNldCBlIG8geCA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuc2V0XCI7XG4gIG1hdGNoIHggd2l0aFxuICB8IE5vbmUgLT4gdW5zZXQgZSBvXG4gIHwgU29tZSB4IC0+IHNldCcgZSBvIHhcblxuZXh0ZXJuYWwgZ2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2Egb3B0aW9uID0gXCJjYW1sX3dlYWtfZ2V0XCJcbmxldCBnZXQgZSBvID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5nZXRcIjtcbiAgZ2V0IGUgb1xuXG5leHRlcm5hbCBnZXRfY29weSA6ICdhIHQgLT4gaW50IC0+ICdhIG9wdGlvbiA9IFwiY2FtbF93ZWFrX2dldF9jb3B5XCJcbmxldCBnZXRfY29weSBlIG8gPVxuICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJXZWFrLmdldF9jb3B5XCI7XG4gIGdldF9jb3B5IGUgb1xuXG5leHRlcm5hbCBjaGVjayA6ICdhIHQgLT4gaW50IC0+IGJvb2wgPSBcImNhbWxfd2Vha19jaGVja1wiXG5sZXQgY2hlY2sgZSBvID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5jaGVja1wiO1xuICBjaGVjayBlIG9cblxuZXh0ZXJuYWwgYmxpdCA6ICdhIHQgLT4gaW50IC0+ICdhIHQgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX3dlYWtfYmxpdFwiXG5cbigqIGJsaXQ6IHNyYyBzcmNvZmYgZHN0IGRzdG9mZiBsZW4gKilcbmxldCBibGl0IGUxIG8xIGUyIG8yIGwgPVxuICBpZiBsIDwgMCB8fCBvMSA8IDAgfHwgbzEgPiBsZW5ndGggZTEgLSBsXG4gICAgIHx8IG8yIDwgMCB8fCBvMiA+IGxlbmd0aCBlMiAtIGxcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIldlYWsuYmxpdFwiXG4gIGVsc2UgaWYgbCA8PiAwIHRoZW4gYmxpdCBlMSBvMSBlMiBvMiBsXG5cbmxldCBmaWxsIGFyIG9mcyBsZW4geCA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYXIgLSBsZW5cbiAgdGhlbiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIldlYWsuZmlsbFwiKVxuICBlbHNlIGJlZ2luXG4gICAgZm9yIGkgPSBvZnMgdG8gKG9mcyArIGxlbiAtIDEpIGRvXG4gICAgICBzZXQgYXIgaSB4XG4gICAgZG9uZVxuICBlbmRcblxuXG4oKiogV2VhayBoYXNoIHRhYmxlcyAqKVxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgZGF0YVxuICB0eXBlIHRcbiAgdmFsIGNyZWF0ZSA6IGludCAtPiB0XG4gIHZhbCBjbGVhciA6IHQgLT4gdW5pdFxuICB2YWwgbWVyZ2UgOiB0IC0+IGRhdGEgLT4gZGF0YVxuICB2YWwgYWRkIDogdCAtPiBkYXRhIC0+IHVuaXRcbiAgdmFsIHJlbW92ZSA6IHQgLT4gZGF0YSAtPiB1bml0XG4gIHZhbCBmaW5kIDogdCAtPiBkYXRhIC0+IGRhdGFcbiAgdmFsIGZpbmRfb3B0IDogdCAtPiBkYXRhIC0+IGRhdGEgb3B0aW9uXG4gIHZhbCBmaW5kX2FsbCA6IHQgLT4gZGF0YSAtPiBkYXRhIGxpc3RcbiAgdmFsIG1lbSA6IHQgLT4gZGF0YSAtPiBib29sXG4gIHZhbCBpdGVyIDogKGRhdGEgLT4gdW5pdCkgLT4gdCAtPiB1bml0XG4gIHZhbCBmb2xkIDogKGRhdGEgLT4gJ2EgLT4gJ2EpIC0+IHQgLT4gJ2EgLT4gJ2FcbiAgdmFsIGNvdW50IDogdCAtPiBpbnRcbiAgdmFsIHN0YXRzIDogdCAtPiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgKiBpbnRcbmVuZFxuXG5tb2R1bGUgTWFrZSAoSCA6IEhhc2h0YmwuSGFzaGVkVHlwZSkgOiAoUyB3aXRoIHR5cGUgZGF0YSA9IEgudCkgPSBzdHJ1Y3RcblxuICB0eXBlICdhIHdlYWtfdCA9ICdhIHRcbiAgbGV0IHdlYWtfY3JlYXRlID0gY3JlYXRlXG4gIGxldCBlbXB0eWJ1Y2tldCA9IHdlYWtfY3JlYXRlIDBcblxuICB0eXBlIGRhdGEgPSBILnRcblxuICB0eXBlIHQgPSB7XG4gICAgbXV0YWJsZSB0YWJsZSA6IGRhdGEgd2Vha190IGFycmF5O1xuICAgIG11dGFibGUgaGFzaGVzIDogaW50IGFycmF5IGFycmF5O1xuICAgIG11dGFibGUgbGltaXQgOiBpbnQ7ICAgICAgICAgICAgICAgKCogYnVja2V0IHNpemUgbGltaXQgKilcbiAgICBtdXRhYmxlIG92ZXJzaXplIDogaW50OyAgICAgICAgICAgICgqIG51bWJlciBvZiBvdmVyc2l6ZSBidWNrZXRzICopXG4gICAgbXV0YWJsZSByb3ZlciA6IGludDsgICAgICAgICAgICAgICAoKiBmb3IgaW50ZXJuYWwgYm9va2tlZXBpbmcgKilcbiAgfVxuXG4gIGxldCBnZXRfaW5kZXggdCBoID0gKGggbGFuZCBtYXhfaW50KSBtb2QgKEFycmF5Lmxlbmd0aCB0LnRhYmxlKVxuXG4gIGxldCBsaW1pdCA9IDdcbiAgbGV0IG92ZXJfbGltaXQgPSAyXG5cbiAgbGV0IGNyZWF0ZSBzeiA9XG4gICAgbGV0IHN6ID0gaWYgc3ogPCA3IHRoZW4gNyBlbHNlIHN6IGluXG4gICAgbGV0IHN6ID0gaWYgc3ogPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIFN5cy5tYXhfYXJyYXlfbGVuZ3RoIGVsc2Ugc3ogaW5cbiAgICB7XG4gICAgICB0YWJsZSA9IEFycmF5Lm1ha2Ugc3ogZW1wdHlidWNrZXQ7XG4gICAgICBoYXNoZXMgPSBBcnJheS5tYWtlIHN6IFt8IHxdO1xuICAgICAgbGltaXQgPSBsaW1pdDtcbiAgICAgIG92ZXJzaXplID0gMDtcbiAgICAgIHJvdmVyID0gMDtcbiAgICB9XG5cbiAgbGV0IGNsZWFyIHQgPVxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdC50YWJsZSAtIDEgZG9cbiAgICAgIHQudGFibGUuKGkpIDwtIGVtcHR5YnVja2V0O1xuICAgICAgdC5oYXNoZXMuKGkpIDwtIFt8IHxdO1xuICAgIGRvbmU7XG4gICAgdC5saW1pdCA8LSBsaW1pdDtcbiAgICB0Lm92ZXJzaXplIDwtIDBcblxuXG4gIGxldCBmb2xkIGYgdCBpbml0ID1cbiAgICBsZXQgcmVjIGZvbGRfYnVja2V0IGkgYiBhY2N1ID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiBhY2N1IGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgICAgfCBTb21lIHYgLT4gZm9sZF9idWNrZXQgKGkrMSkgYiAoZiB2IGFjY3UpXG4gICAgICB8IE5vbmUgLT4gZm9sZF9idWNrZXQgKGkrMSkgYiBhY2N1XG4gICAgaW5cbiAgICBBcnJheS5mb2xkX3JpZ2h0IChmb2xkX2J1Y2tldCAwKSB0LnRhYmxlIGluaXRcblxuXG4gIGxldCBpdGVyIGYgdCA9XG4gICAgbGV0IHJlYyBpdGVyX2J1Y2tldCBpIGIgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuICgpIGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgICAgfCBTb21lIHYgLT4gZiB2OyBpdGVyX2J1Y2tldCAoaSsxKSBiXG4gICAgICB8IE5vbmUgLT4gaXRlcl9idWNrZXQgKGkrMSkgYlxuICAgIGluXG4gICAgQXJyYXkuaXRlciAoaXRlcl9idWNrZXQgMCkgdC50YWJsZVxuXG5cbiAgbGV0IGl0ZXJfd2VhayBmIHQgPVxuICAgIGxldCByZWMgaXRlcl9idWNrZXQgaSBqIGIgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuICgpIGVsc2VcbiAgICAgIG1hdGNoIGNoZWNrIGIgaSB3aXRoXG4gICAgICB8IHRydWUgLT4gZiBiIHQuaGFzaGVzLihqKSBpOyBpdGVyX2J1Y2tldCAoaSsxKSBqIGJcbiAgICAgIHwgZmFsc2UgLT4gaXRlcl9idWNrZXQgKGkrMSkgaiBiXG4gICAgaW5cbiAgICBBcnJheS5pdGVyaSAoaXRlcl9idWNrZXQgMCkgdC50YWJsZVxuXG5cbiAgbGV0IHJlYyBjb3VudF9idWNrZXQgaSBiIGFjY3UgPVxuICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiBhY2N1IGVsc2VcbiAgICBjb3VudF9idWNrZXQgKGkrMSkgYiAoYWNjdSArIChpZiBjaGVjayBiIGkgdGhlbiAxIGVsc2UgMCkpXG5cblxuICBsZXQgY291bnQgdCA9XG4gICAgQXJyYXkuZm9sZF9yaWdodCAoY291bnRfYnVja2V0IDApIHQudGFibGUgMFxuXG5cbiAgbGV0IG5leHRfc3ogbiA9IEludC5taW4gKDMgKiBuIC8gMiArIDMpIFN5cy5tYXhfYXJyYXlfbGVuZ3RoXG4gIGxldCBwcmV2X3N6IG4gPSAoKG4gLSAzKSAqIDIgKyAyKSAvIDNcblxuICBsZXQgdGVzdF9zaHJpbmtfYnVja2V0IHQgPVxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLih0LnJvdmVyKSBpblxuICAgIGxldCBoYnVja2V0ID0gdC5oYXNoZXMuKHQucm92ZXIpIGluXG4gICAgbGV0IGxlbiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcHJldl9sZW4gPSBwcmV2X3N6IGxlbiBpblxuICAgIGxldCBsaXZlID0gY291bnRfYnVja2V0IDAgYnVja2V0IDAgaW5cbiAgICBpZiBsaXZlIDw9IHByZXZfbGVuIHRoZW4gYmVnaW5cbiAgICAgIGxldCByZWMgbG9vcCBpIGogPVxuICAgICAgICBpZiBqID49IHByZXZfbGVuIHRoZW4gYmVnaW5cbiAgICAgICAgICBpZiBjaGVjayBidWNrZXQgaSB0aGVuIGxvb3AgKGkgKyAxKSBqXG4gICAgICAgICAgZWxzZSBpZiBjaGVjayBidWNrZXQgaiB0aGVuIGJlZ2luXG4gICAgICAgICAgICBibGl0IGJ1Y2tldCBqIGJ1Y2tldCBpIDE7XG4gICAgICAgICAgICBoYnVja2V0LihpKSA8LSBoYnVja2V0LihqKTtcbiAgICAgICAgICAgIGxvb3AgKGkgKyAxKSAoaiAtIDEpO1xuICAgICAgICAgIGVuZCBlbHNlIGxvb3AgaSAoaiAtIDEpO1xuICAgICAgICBlbmQ7XG4gICAgICBpblxuICAgICAgbG9vcCAwIChsZW5ndGggYnVja2V0IC0gMSk7XG4gICAgICBpZiBwcmV2X2xlbiA9IDAgdGhlbiBiZWdpblxuICAgICAgICB0LnRhYmxlLih0LnJvdmVyKSA8LSBlbXB0eWJ1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKHQucm92ZXIpIDwtIFt8IHxdO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IG5ld2J1Y2tldCA9IHdlYWtfY3JlYXRlIHByZXZfbGVuIGluXG4gICAgICAgIGJsaXQgYnVja2V0IDAgbmV3YnVja2V0IDAgcHJldl9sZW47XG4gICAgICAgIHQudGFibGUuKHQucm92ZXIpIDwtIG5ld2J1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKHQucm92ZXIpIDwtIEFycmF5LnN1YiBoYnVja2V0IDAgcHJldl9sZW5cbiAgICAgIGVuZDtcbiAgICAgIGlmIGxlbiA+IHQubGltaXQgJiYgcHJldl9sZW4gPD0gdC5saW1pdCB0aGVuIHQub3ZlcnNpemUgPC0gdC5vdmVyc2l6ZSAtIDE7XG4gICAgZW5kO1xuICAgIHQucm92ZXIgPC0gKHQucm92ZXIgKyAxKSBtb2QgKEFycmF5Lmxlbmd0aCB0LnRhYmxlKVxuXG5cbiAgbGV0IHJlYyByZXNpemUgdCA9XG4gICAgbGV0IG9sZGxlbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IG5ld2xlbiA9IG5leHRfc3ogb2xkbGVuIGluXG4gICAgaWYgbmV3bGVuID4gb2xkbGVuIHRoZW4gYmVnaW5cbiAgICAgIGxldCBuZXd0ID0gY3JlYXRlIG5ld2xlbiBpblxuICAgICAgbGV0IGFkZF93ZWFrIG9iIG9oIG9pID1cbiAgICAgICAgbGV0IHNldHRlciBuYiBuaSBfID0gYmxpdCBvYiBvaSBuYiBuaSAxIGluXG4gICAgICAgIGxldCBoID0gb2guKG9pKSBpblxuICAgICAgICBhZGRfYXV4IG5ld3Qgc2V0dGVyIE5vbmUgaCAoZ2V0X2luZGV4IG5ld3QgaCk7XG4gICAgICBpblxuICAgICAgaXRlcl93ZWFrIGFkZF93ZWFrIHQ7XG4gICAgICB0LnRhYmxlIDwtIG5ld3QudGFibGU7XG4gICAgICB0Lmhhc2hlcyA8LSBuZXd0Lmhhc2hlcztcbiAgICAgIHQubGltaXQgPC0gbmV3dC5saW1pdDtcbiAgICAgIHQub3ZlcnNpemUgPC0gbmV3dC5vdmVyc2l6ZTtcbiAgICAgIHQucm92ZXIgPC0gdC5yb3ZlciBtb2QgQXJyYXkubGVuZ3RoIG5ld3QudGFibGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHQubGltaXQgPC0gbWF4X2ludDsgICAgICAgICAgICAgKCogbWF4aW11bSBzaXplIGFscmVhZHkgcmVhY2hlZCAqKVxuICAgICAgdC5vdmVyc2l6ZSA8LSAwO1xuICAgIGVuZFxuXG4gIGFuZCBhZGRfYXV4IHQgc2V0dGVyIGQgaCBpbmRleCA9XG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBiZWdpblxuICAgICAgICBsZXQgbmV3c3ogPVxuICAgICAgICAgIEludC5taW4gKDMgKiBzeiAvIDIgKyAzKSAoU3lzLm1heF9hcnJheV9sZW5ndGggLSBhZGRpdGlvbmFsX3ZhbHVlcylcbiAgICAgICAgaW5cbiAgICAgICAgaWYgbmV3c3ogPD0gc3ogdGhlbiBmYWlsd2l0aCBcIldlYWsuTWFrZTogaGFzaCBidWNrZXQgY2Fubm90IGdyb3cgbW9yZVwiO1xuICAgICAgICBsZXQgbmV3YnVja2V0ID0gd2Vha19jcmVhdGUgbmV3c3ogaW5cbiAgICAgICAgbGV0IG5ld2hhc2hlcyA9IEFycmF5Lm1ha2UgbmV3c3ogMCBpblxuICAgICAgICBibGl0IGJ1Y2tldCAwIG5ld2J1Y2tldCAwIHN6O1xuICAgICAgICBBcnJheS5ibGl0IGhhc2hlcyAwIG5ld2hhc2hlcyAwIHN6O1xuICAgICAgICBzZXR0ZXIgbmV3YnVja2V0IHN6IGQ7XG4gICAgICAgIG5ld2hhc2hlcy4oc3opIDwtIGg7XG4gICAgICAgIHQudGFibGUuKGluZGV4KSA8LSBuZXdidWNrZXQ7XG4gICAgICAgIHQuaGFzaGVzLihpbmRleCkgPC0gbmV3aGFzaGVzO1xuICAgICAgICBpZiBzeiA8PSB0LmxpbWl0ICYmIG5ld3N6ID4gdC5saW1pdCB0aGVuIGJlZ2luXG4gICAgICAgICAgdC5vdmVyc2l6ZSA8LSB0Lm92ZXJzaXplICsgMTtcbiAgICAgICAgICBmb3IgX2kgPSAwIHRvIG92ZXJfbGltaXQgZG8gdGVzdF9zaHJpbmtfYnVja2V0IHQgZG9uZTtcbiAgICAgICAgZW5kO1xuICAgICAgICBpZiB0Lm92ZXJzaXplID4gQXJyYXkubGVuZ3RoIHQudGFibGUgLyBvdmVyX2xpbWl0IHRoZW4gcmVzaXplIHQ7XG4gICAgICBlbmQgZWxzZSBpZiBjaGVjayBidWNrZXQgaSB0aGVuIGJlZ2luXG4gICAgICAgIGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0dGVyIGJ1Y2tldCBpIGQ7XG4gICAgICAgIGhhc2hlcy4oaSkgPC0gaDtcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IGFkZCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBhZGRfYXV4IHQgc2V0IChTb21lIGQpIGggKGdldF9pbmRleCB0IGgpXG5cblxuICBsZXQgZmluZF9vciB0IGQgaWZub3Rmb3VuZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGlmbm90Zm91bmQgaCBpbmRleFxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZFxuICAgICAgICAgICAtPiBiZWdpbiBtYXRjaCBnZXQgYnVja2V0IGkgd2l0aFxuICAgICAgICAgICAgICB8IFNvbWUgdiAtPiB2XG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSlcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgbWVyZ2UgdCBkID1cbiAgICBmaW5kX29yIHQgZCAoZnVuIGggaW5kZXggLT4gYWRkX2F1eCB0IHNldCAoU29tZSBkKSBoIGluZGV4OyBkKVxuXG5cbiAgbGV0IGZpbmQgdCBkID0gZmluZF9vciB0IGQgKGZ1biBfaCBfaW5kZXggLT4gcmFpc2UgTm90X2ZvdW5kKVxuXG4gIGxldCBmaW5kX29wdCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBOb25lXG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkXG4gICAgICAgICAgIC0+IGJlZ2luIG1hdGNoIGdldCBidWNrZXQgaSB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSBfIGFzIHYgLT4gdlxuICAgICAgICAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IGZpbmRfc2hhZG93IHQgZCBpZmZvdW5kIGlmbm90Zm91bmQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBpZm5vdGZvdW5kXG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkIC0+IGlmZm91bmQgYnVja2V0IGlcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCByZW1vdmUgdCBkID0gZmluZF9zaGFkb3cgdCBkIChmdW4gdyBpIC0+IHNldCB3IGkgTm9uZSkgKClcblxuXG4gIGxldCBtZW0gdCBkID0gZmluZF9zaGFkb3cgdCBkIChmdW4gX3cgX2kgLT4gdHJ1ZSkgZmFsc2VcblxuXG4gIGxldCBmaW5kX2FsbCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpIGFjY3UgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGFjY3VcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGRcbiAgICAgICAgICAgLT4gYmVnaW4gbWF0Y2ggZ2V0IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIHYgLT4gbG9vcCAoaSArIDEpICh2IDo6IGFjY3UpXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSkgYWNjdVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKSBhY2N1XG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSkgYWNjdVxuICAgIGluXG4gICAgbG9vcCAwIFtdXG5cblxuICBsZXQgc3RhdHMgdCA9XG4gICAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IGxlbnMgPSBBcnJheS5tYXAgbGVuZ3RoIHQudGFibGUgaW5cbiAgICBBcnJheS5zb3J0IGNvbXBhcmUgbGVucztcbiAgICBsZXQgdG90bGVuID0gQXJyYXkuZm9sZF9sZWZ0ICggKyApIDAgbGVucyBpblxuICAgIChsZW4sIGNvdW50IHQsIHRvdGxlbiwgbGVucy4oMCksIGxlbnMuKGxlbi8yKSwgbGVucy4obGVuLTEpKVxuXG5cbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgUGllcnJlIFdlaXMsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBIHByZXR0eS1wcmludGluZyBmYWNpbGl0eSBhbmQgZGVmaW5pdGlvbiBvZiBmb3JtYXR0ZXJzIGZvciAncGFyYWxsZWwnXG4gICAoaS5lLiB1bnJlbGF0ZWQgb3IgaW5kZXBlbmRlbnQpIHByZXR0eS1wcmludGluZyBvbiBtdWx0aXBsZSBvdXQgY2hhbm5lbHMuICopXG5cbigqXG4gICBUaGUgcHJldHR5LXByaW50aW5nIGVuZ2luZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMuXG4qKVxuXG5sZXQgaWQgeCA9IHhcblxuKCogQSBkZXZvdGVkIHR5cGUgZm9yIHNpemVzIHRvIGF2b2lkIGNvbmZ1c2lvblxuICAgYmV0d2VlbiBzaXplcyBhbmQgbWVyZSBpbnRlZ2Vycy4gKilcbm1vZHVsZSBTaXplIDogc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCB0b19pbnQgOiB0IC0+IGludFxuICB2YWwgb2ZfaW50IDogaW50IC0+IHRcbiAgdmFsIHplcm8gOiB0XG4gIHZhbCB1bmtub3duIDogdFxuICB2YWwgaXNfa25vd24gOiB0IC0+IGJvb2xcbmVuZCAgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50XG5cbiAgbGV0IHRvX2ludCA9IGlkXG4gIGxldCBvZl9pbnQgPSBpZFxuICBsZXQgemVybyA9IDBcbiAgbGV0IHVua25vd24gPSAtMVxuICBsZXQgaXNfa25vd24gbiA9IG4gPj0gMFxuZW5kXG5cblxuXG4oKiBUaGUgcHJldHR5LXByaW50aW5nIGJveGVzIGRlZmluaXRpb246XG4gICBhIHByZXR0eS1wcmludGluZyBib3ggaXMgZWl0aGVyXG4gICAtIGhib3g6IGhvcml6b250YWwgYm94IChubyBsaW5lIHNwbGl0dGluZylcbiAgIC0gdmJveDogdmVydGljYWwgYm94IChldmVyeSBicmVhayBoaW50IHNwbGl0cyB0aGUgbGluZSlcbiAgIC0gaHZib3g6IGhvcml6b250YWwvdmVydGljYWwgYm94XG4gICAgICh0aGUgYm94IGJlaGF2ZXMgYXMgYW4gaG9yaXpvbnRhbCBib3ggaWYgaXQgZml0cyBvblxuICAgICAgdGhlIGN1cnJlbnQgbGluZSwgb3RoZXJ3aXNlIHRoZSBib3ggYmVoYXZlcyBhcyBhIHZlcnRpY2FsIGJveClcbiAgIC0gaG92Ym94OiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGNvbXBhY3RpbmcgYm94XG4gICAgICh0aGUgYm94IGlzIGNvbXBhY3RpbmcgbWF0ZXJpYWwsIHByaW50aW5nIGFzIG11Y2ggbWF0ZXJpYWwgYXMgcG9zc2libGVcbiAgICAgIG9uIGV2ZXJ5IGxpbmVzKVxuICAgLSBib3g6IGhvcml6b250YWwgb3IgdmVydGljYWwgY29tcGFjdGluZyBib3ggd2l0aCBlbmhhbmNlZCBib3ggc3RydWN0dXJlXG4gICAgICh0aGUgYm94IGJlaGF2ZXMgYXMgYW4gaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBib3ggYnV0IGJyZWFrIGhpbnRzIHNwbGl0XG4gICAgICB0aGUgbGluZSBpZiBzcGxpdHRpbmcgd291bGQgbW92ZSB0byB0aGUgbGVmdClcbiopXG50eXBlIGJveF90eXBlID0gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmJsb2NrX3R5cGUgPVxuICB8IFBwX2hib3ggfCBQcF92Ym94IHwgUHBfaHZib3ggfCBQcF9ob3Zib3ggfCBQcF9ib3ggfCBQcF9maXRzXG5cblxuKCogVGhlIHByZXR0eS1wcmludGluZyB0b2tlbnMgZGVmaW5pdGlvbjpcbiAgIGFyZSBlaXRoZXIgdGV4dCB0byBwcmludCBvciBwcmV0dHkgcHJpbnRpbmdcbiAgIGVsZW1lbnRzIHRoYXQgZHJpdmUgaW5kZW50YXRpb24gYW5kIGxpbmUgc3BsaXR0aW5nLiAqKVxudHlwZSBwcF90b2tlbiA9XG4gIHwgUHBfdGV4dCBvZiBzdHJpbmcgICAgICAgICAgKCogbm9ybWFsIHRleHQgKilcbiAgfCBQcF9icmVhayBvZiB7ICAgICAgICAgICAgICAoKiBjb21wbGV0ZSBicmVhayAqKVxuICAgICAgZml0czogc3RyaW5nICogaW50ICogc3RyaW5nOyAgICgqIGxpbmUgaXMgbm90IHNwbGl0ICopXG4gICAgICBicmVha3M6IHN0cmluZyAqIGludCAqIHN0cmluZzsgKCogbGluZSBpcyBzcGxpdCAqKVxuICAgIH1cbiAgfCBQcF90YnJlYWsgb2YgaW50ICogaW50ICAgICAoKiBnbyB0byBuZXh0IHRhYnVsYXRpb24gKilcbiAgfCBQcF9zdGFiICAgICAgICAgICAgICAgICAgICAoKiBzZXQgYSB0YWJ1bGF0aW9uICopXG4gIHwgUHBfYmVnaW4gb2YgaW50ICogYm94X3R5cGUgKCogYmVnaW5uaW5nIG9mIGEgYm94ICopXG4gIHwgUHBfZW5kICAgICAgICAgICAgICAgICAgICAgKCogZW5kIG9mIGEgYm94ICopXG4gIHwgUHBfdGJlZ2luIG9mIHRib3ggICAgICAgICAgKCogYmVnaW5uaW5nIG9mIGEgdGFidWxhdGlvbiBib3ggKilcbiAgfCBQcF90ZW5kICAgICAgICAgICAgICAgICAgICAoKiBlbmQgb2YgYSB0YWJ1bGF0aW9uIGJveCAqKVxuICB8IFBwX25ld2xpbmUgICAgICAgICAgICAgICAgICgqIHRvIGZvcmNlIGEgbmV3bGluZSBpbnNpZGUgYSBib3ggKilcbiAgfCBQcF9pZl9uZXdsaW5lICAgICAgICAgICAgICAoKiB0byBkbyBzb21ldGhpbmcgb25seSBpZiB0aGlzIHZlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lIGhhcyBiZWVuIGJyb2tlbiAqKVxuICB8IFBwX29wZW5fdGFnIG9mIHN0YWcgICAgICAgICAoKiBvcGVuaW5nIGEgdGFnIG5hbWUgKilcbiAgfCBQcF9jbG9zZV90YWcgICAgICAgICAgICAgICAoKiBjbG9zaW5nIHRoZSBtb3N0IHJlY2VudGx5IG9wZW4gdGFnICopXG5cbmFuZCBzdGFnID0gLi5cblxuYW5kIHRib3ggPSBQcF90Ym94IG9mIGludCBsaXN0IHJlZiAgKCogVGFidWxhdGlvbiBib3ggKilcblxudHlwZSB0YWcgPSBzdHJpbmdcbnR5cGUgc3RhZyArPSBTdHJpbmdfdGFnIG9mIHRhZ1xuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZTpcbiAgIHByZXR0eS1wcmludGluZyBtYXRlcmlhbCBpcyBub3Qgd3JpdHRlbiBpbiB0aGUgb3V0cHV0IGFzIHNvb24gYXMgZW1pdHRlZDtcbiAgIGluc3RlYWQsIHRoZSBtYXRlcmlhbCBpcyBzaW1wbHkgcmVjb3JkZWQgaW4gdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLFxuICAgdW50aWwgdGhlIGVuY2xvc2luZyBib3ggaGFzIGEga25vd24gY29tcHV0ZWQgc2l6ZSBhbmQgcHJvcGVyIHNwbGl0dGluZ1xuICAgZGVjaXNpb25zIGNhbiBiZSBtYWRlLlxuXG4gICBUaGUgcHJldHR5LXByaW50ZXIgcXVldWUgY29udGFpbnMgZm9ybWF0dGluZyBlbGVtZW50cyB0byBiZSBwcmludGVkLlxuICAgRWFjaCBmb3JtYXR0aW5nIGVsZW1lbnQgaXMgYSB0dXBsZSAoc2l6ZSwgdG9rZW4sIGxlbmd0aCksIHdoZXJlXG4gICAtIGxlbmd0aCBpcyB0aGUgZGVjbGFyZWQgbGVuZ3RoIG9mIHRoZSB0b2tlbixcbiAgIC0gc2l6ZSBpcyBlZmZlY3RpdmUgc2l6ZSBvZiB0aGUgdG9rZW4gd2hlbiBpdCBpcyBwcmludGVkXG4gICAgIChzaXplIGlzIHNldCB3aGVuIHRoZSBzaXplIG9mIHRoZSBib3ggaXMga25vd24sIHNvIHRoYXQgc2l6ZSBvZiBicmVha1xuICAgICAgaGludHMgYXJlIGRlZmluaXRpdmUpLiAqKVxudHlwZSBwcF9xdWV1ZV9lbGVtID0ge1xuICBtdXRhYmxlIHNpemUgOiBTaXplLnQ7XG4gIHRva2VuIDogcHBfdG9rZW47XG4gIGxlbmd0aCA6IGludDtcbn1cblxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWUgZGVmaW5pdGlvbi4gKilcbnR5cGUgcHBfcXVldWUgPSBwcF9xdWV1ZV9lbGVtIFF1ZXVlLnRcblxuKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLiAqKVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2s6IHNjYW5uaW5nIGVsZW1lbnQgZGVmaW5pdGlvbi4gKilcbnR5cGUgcHBfc2Nhbl9lbGVtID0ge1xuICBsZWZ0X3RvdGFsIDogaW50OyAoKiBWYWx1ZSBvZiBwcF9sZWZ0X3RvdGFsIHdoZW4gdGhlIGVsZW1lbnQgd2FzIGVucXVldWVkLiAqKVxuICBxdWV1ZV9lbGVtIDogcHBfcXVldWVfZWxlbVxufVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjazpcbiAgIHRoZSBmb3JtYXR0aW5nIHN0YWNrIGNvbnRhaW5zIHRoZSBkZXNjcmlwdGlvbiBvZiBhbGwgdGhlIGN1cnJlbnRseSBhY3RpdmVcbiAgIGJveGVzOyB0aGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjayBpcyB1c2VkIHRvIHNwbGl0IHRoZSBsaW5lc1xuICAgd2hpbGUgcHJpbnRpbmcgdG9rZW5zLiAqKVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjazogZm9ybWF0dGluZyBzdGFjayBlbGVtZW50IGRlZmluaXRpb24uXG4gICBFYWNoIHN0YWNrIGVsZW1lbnQgZGVzY3JpYmVzIGEgcHJldHR5LXByaW50aW5nIGJveC4gKilcbnR5cGUgcHBfZm9ybWF0X2VsZW0gPSB7IGJveF90eXBlIDogYm94X3R5cGU7IHdpZHRoIDogaW50IH1cblxuKCogVGhlIGZvcm1hdHRlciBkZWZpbml0aW9uLlxuICAgRWFjaCBmb3JtYXR0ZXIgdmFsdWUgaXMgYSBwcmV0dHktcHJpbnRlciBpbnN0YW5jZSB3aXRoIGFsbCBpdHNcbiAgIG1hY2hpbmVyeS4gKilcbnR5cGUgZm9ybWF0dGVyID0ge1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2suICopXG4gIHBwX3NjYW5fc3RhY2sgOiBwcF9zY2FuX2VsZW0gU3RhY2sudDtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2suICopXG4gIHBwX2Zvcm1hdF9zdGFjayA6IHBwX2Zvcm1hdF9lbGVtIFN0YWNrLnQ7XG4gIHBwX3Rib3hfc3RhY2sgOiB0Ym94IFN0YWNrLnQ7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBzZW1hbnRpY3MgdGFnIHN0YWNrLiAqKVxuICBwcF90YWdfc3RhY2sgOiBzdGFnIFN0YWNrLnQ7XG4gIHBwX21hcmtfc3RhY2sgOiBzdGFnIFN0YWNrLnQ7XG4gICgqIFZhbHVlIG9mIHJpZ2h0IG1hcmdpbi4gKilcbiAgbXV0YWJsZSBwcF9tYXJnaW4gOiBpbnQ7XG4gICgqIE1pbmltYWwgc3BhY2UgbGVmdCBiZWZvcmUgbWFyZ2luLCB3aGVuIG9wZW5pbmcgYSBib3guICopXG4gIG11dGFibGUgcHBfbWluX3NwYWNlX2xlZnQgOiBpbnQ7XG4gICgqIE1heGltdW0gdmFsdWUgb2YgaW5kZW50YXRpb246XG4gICAgIG5vIGJveCBjYW4gYmUgb3BlbmVkIGZ1cnRoZXIuICopXG4gIG11dGFibGUgcHBfbWF4X2luZGVudCA6IGludDtcbiAgKCogU3BhY2UgcmVtYWluaW5nIG9uIHRoZSBjdXJyZW50IGxpbmUuICopXG4gIG11dGFibGUgcHBfc3BhY2VfbGVmdCA6IGludDtcbiAgKCogQ3VycmVudCB2YWx1ZSBvZiBpbmRlbnRhdGlvbi4gKilcbiAgbXV0YWJsZSBwcF9jdXJyZW50X2luZGVudCA6IGludDtcbiAgKCogVHJ1ZSB3aGVuIHRoZSBsaW5lIGhhcyBiZWVuIGJyb2tlbiBieSB0aGUgcHJldHR5LXByaW50ZXIuICopXG4gIG11dGFibGUgcHBfaXNfbmV3X2xpbmUgOiBib29sO1xuICAoKiBUb3RhbCB3aWR0aCBvZiB0b2tlbnMgYWxyZWFkeSBwcmludGVkLiAqKVxuICBtdXRhYmxlIHBwX2xlZnRfdG90YWwgOiBpbnQ7XG4gICgqIFRvdGFsIHdpZHRoIG9mIHRva2VucyBldmVyIHB1dCBpbiBxdWV1ZS4gKilcbiAgbXV0YWJsZSBwcF9yaWdodF90b3RhbCA6IGludDtcbiAgKCogQ3VycmVudCBudW1iZXIgb2Ygb3BlbiBib3hlcy4gKilcbiAgbXV0YWJsZSBwcF9jdXJyX2RlcHRoIDogaW50O1xuICAoKiBNYXhpbXVtIG51bWJlciBvZiBib3hlcyB3aGljaCBjYW4gYmUgc2ltdWx0YW5lb3VzbHkgb3Blbi4gKilcbiAgbXV0YWJsZSBwcF9tYXhfYm94ZXMgOiBpbnQ7XG4gICgqIEVsbGlwc2lzIHN0cmluZy4gKilcbiAgbXV0YWJsZSBwcF9lbGxpcHNpcyA6IHN0cmluZztcbiAgKCogT3V0cHV0IGZ1bmN0aW9uLiAqKVxuICBtdXRhYmxlIHBwX291dF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0O1xuICAoKiBGbHVzaGluZyBmdW5jdGlvbi4gKilcbiAgbXV0YWJsZSBwcF9vdXRfZmx1c2ggOiB1bml0IC0+IHVuaXQ7XG4gICgqIE91dHB1dCBvZiBuZXcgbGluZXMuICopXG4gIG11dGFibGUgcHBfb3V0X25ld2xpbmUgOiB1bml0IC0+IHVuaXQ7XG4gICgqIE91dHB1dCBvZiBicmVhayBoaW50cyBzcGFjZXMuICopXG4gIG11dGFibGUgcHBfb3V0X3NwYWNlcyA6IGludCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgaW5kZW50YXRpb24gb2YgbmV3IGxpbmVzLiAqKVxuICBtdXRhYmxlIHBwX291dF9pbmRlbnQgOiBpbnQgLT4gdW5pdDtcbiAgKCogQXJlIHRhZ3MgcHJpbnRlZCA/ICopXG4gIG11dGFibGUgcHBfcHJpbnRfdGFncyA6IGJvb2w7XG4gICgqIEFyZSB0YWdzIG1hcmtlZCA/ICopXG4gIG11dGFibGUgcHBfbWFya190YWdzIDogYm9vbDtcbiAgKCogRmluZCBvcGVuaW5nIGFuZCBjbG9zaW5nIG1hcmtlcnMgb2YgdGFncy4gKilcbiAgbXV0YWJsZSBwcF9tYXJrX29wZW5fdGFnIDogc3RhZyAtPiBzdHJpbmc7XG4gIG11dGFibGUgcHBfbWFya19jbG9zZV90YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgbXV0YWJsZSBwcF9wcmludF9vcGVuX3RhZyA6IHN0YWcgLT4gdW5pdDtcbiAgbXV0YWJsZSBwcF9wcmludF9jbG9zZV90YWcgOiBzdGFnIC0+IHVuaXQ7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbiAgcHBfcXVldWUgOiBwcF9xdWV1ZTtcbn1cblxuXG4oKiBUaGUgZm9ybWF0dGVyIHNwZWNpZmljIHRhZyBoYW5kbGluZyBmdW5jdGlvbnMuICopXG50eXBlIGZvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyA9IHtcbiAgbWFya19vcGVuX3N0YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgbWFya19jbG9zZV9zdGFnIDogc3RhZyAtPiBzdHJpbmc7XG4gIHByaW50X29wZW5fc3RhZyA6IHN0YWcgLT4gdW5pdDtcbiAgcHJpbnRfY2xvc2Vfc3RhZyA6IHN0YWcgLT4gdW5pdDtcbn1cblxuXG4oKiBUaGUgZm9ybWF0dGVyIGZ1bmN0aW9ucyB0byBvdXRwdXQgbWF0ZXJpYWwuICopXG50eXBlIGZvcm1hdHRlcl9vdXRfZnVuY3Rpb25zID0ge1xuICBvdXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdDtcbiAgb3V0X2ZsdXNoIDogdW5pdCAtPiB1bml0O1xuICBvdXRfbmV3bGluZSA6IHVuaXQgLT4gdW5pdDtcbiAgb3V0X3NwYWNlcyA6IGludCAtPiB1bml0O1xuICBvdXRfaW5kZW50IDogaW50IC0+IHVuaXQ7XG59XG5cblxuKCpcblxuICBBdXhpbGlhcmllcyBhbmQgYmFzaWMgZnVuY3Rpb25zLlxuXG4qKVxuXG4oKiBFbnRlciBhIHRva2VuIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbmxldCBwcF9lbnF1ZXVlIHN0YXRlIHRva2VuID1cbiAgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gc3RhdGUucHBfcmlnaHRfdG90YWwgKyB0b2tlbi5sZW5ndGg7XG4gIFF1ZXVlLmFkZCB0b2tlbiBzdGF0ZS5wcF9xdWV1ZVxuXG5cbmxldCBwcF9jbGVhcl9xdWV1ZSBzdGF0ZSA9XG4gIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gMTsgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gMTtcbiAgUXVldWUuY2xlYXIgc3RhdGUucHBfcXVldWVcblxuXG4oKiBQcF9pbmZpbml0eTogbGFyZ2UgdmFsdWUgZm9yIGRlZmF1bHQgdG9rZW5zIHNpemUuXG5cbiAgIFBwX2luZmluaXR5IGlzIGRvY3VtZW50ZWQgYXMgYmVpbmcgZ3JlYXRlciB0aGFuIDFlMTA7IHRvIGF2b2lkXG4gICBjb25mdXNpb24gYWJvdXQgdGhlIHdvcmQgJ2dyZWF0ZXInLCB3ZSBjaG9vc2UgcHBfaW5maW5pdHkgZ3JlYXRlclxuICAgdGhhbiAxZTEwICsgMTsgZm9yIGNvcnJlY3QgaGFuZGxpbmcgb2YgdGVzdHMgaW4gdGhlIGFsZ29yaXRobSxcbiAgIHBwX2luZmluaXR5IG11c3QgYmUgZXZlbiBvbmUgbW9yZSB0aGFuIDFlMTAgKyAxOyBsZXQncyBzdGFuZCBvbiB0aGVcbiAgIHNhZmUgc2lkZSBieSBjaG9vc2luZyAxLmUxMCsxMC5cblxuICAgUHBfaW5maW5pdHkgY291bGQgcHJvYmFibHkgYmUgMTA3Mzc0MTgyMyB0aGF0IGlzIDJeMzAgLSAxLCB0aGF0IGlzXG4gICB0aGUgbWluaW1hbCB1cHBlciBib3VuZCBmb3IgaW50ZWdlcnM7IG5vdyB0aGF0IG1heF9pbnQgaXMgZGVmaW5lZCxcbiAgIHRoaXMgbGltaXQgY291bGQgYWxzbyBiZSBkZWZpbmVkIGFzIG1heF9pbnQgLSAxLlxuXG4gICBIb3dldmVyLCBiZWZvcmUgc2V0dGluZyBwcF9pbmZpbml0eSB0byBzb21ldGhpbmcgYXJvdW5kIG1heF9pbnQsIHdlXG4gICBtdXN0IGNhcmVmdWxseSBkb3VibGUtY2hlY2sgYWxsIHRoZSBpbnRlZ2VyIGFyaXRobWV0aWMgb3BlcmF0aW9uc1xuICAgdGhhdCBpbnZvbHZlIHBwX2luZmluaXR5LCBzaW5jZSBhbnkgb3ZlcmZsb3cgd291bGQgd3JlY2sgaGF2b2MgdGhlXG4gICBwcmV0dHktcHJpbnRpbmcgYWxnb3JpdGhtJ3MgaW52YXJpYW50cy4gR2l2ZW4gdGhhdCB0aGlzIGFyaXRobWV0aWNcbiAgIGNvcnJlY3RuZXNzIGNoZWNrIGlzIGRpZmZpY3VsdCBhbmQgZXJyb3IgcHJvbmUgYW5kIGdpdmVuIHRoYXQgMWUxMFxuICAgKyAxIGlzIGluIHByYWN0aWNlIGxhcmdlIGVub3VnaCwgdGhlcmUgaXMgbm8gbmVlZCB0byBhdHRlbXB0IHRvIHNldFxuICAgcHBfaW5maW5pdHkgdG8gdGhlIHRoZW9yZXRpY2FsbHkgbWF4aW11bSBsaW1pdC4gSXQgaXMgbm90IHdvcnRoIHRoZVxuICAgYnVyZGVuICEgKilcbmxldCBwcF9pbmZpbml0eSA9IDEwMDAwMDAwMTBcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBmb3IgdGhlIGZvcm1hdHRlci4gKilcbmxldCBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIHMgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nIHMgMCAoU3RyaW5nLmxlbmd0aCBzKVxuYW5kIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlID0gc3RhdGUucHBfb3V0X25ld2xpbmUgKClcbmFuZCBwcF9vdXRwdXRfc3BhY2VzIHN0YXRlIG4gPSBzdGF0ZS5wcF9vdXRfc3BhY2VzIG5cbmFuZCBwcF9vdXRwdXRfaW5kZW50IHN0YXRlIG4gPSBzdGF0ZS5wcF9vdXRfaW5kZW50IG5cblxuKCogRm9ybWF0IGEgdGV4dHVhbCB0b2tlbiAqKVxubGV0IGZvcm1hdF9wcF90ZXh0IHN0YXRlIHNpemUgdGV4dCA9XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCAtIHNpemU7XG4gIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgdGV4dDtcbiAgc3RhdGUucHBfaXNfbmV3X2xpbmUgPC0gZmFsc2VcblxuKCogRm9ybWF0IGEgc3RyaW5nIGJ5IGl0cyBsZW5ndGgsIGlmIG5vdCBlbXB0eSAqKVxubGV0IGZvcm1hdF9zdHJpbmcgc3RhdGUgcyA9XG4gIGlmIHMgPD4gXCJcIiB0aGVuIGZvcm1hdF9wcF90ZXh0IHN0YXRlIChTdHJpbmcubGVuZ3RoIHMpIHNcblxuKCogVG8gZm9ybWF0IGEgYnJlYWssIGluZGVudGluZyBhIG5ldyBsaW5lLiAqKVxubGV0IGJyZWFrX25ld19saW5lIHN0YXRlIChiZWZvcmUsIG9mZnNldCwgYWZ0ZXIpIHdpZHRoID1cbiAgZm9ybWF0X3N0cmluZyBzdGF0ZSBiZWZvcmU7XG4gIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlO1xuICBzdGF0ZS5wcF9pc19uZXdfbGluZSA8LSB0cnVlO1xuICBsZXQgaW5kZW50ID0gc3RhdGUucHBfbWFyZ2luIC0gd2lkdGggKyBvZmZzZXQgaW5cbiAgKCogRG9uJ3QgaW5kZW50IG1vcmUgdGhhbiBwcF9tYXhfaW5kZW50LiAqKVxuICBsZXQgcmVhbF9pbmRlbnQgPSBJbnQubWluIHN0YXRlLnBwX21heF9pbmRlbnQgaW5kZW50IGluXG4gIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50IDwtIHJlYWxfaW5kZW50O1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50O1xuICBwcF9vdXRwdXRfaW5kZW50IHN0YXRlIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50O1xuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGFmdGVyXG5cblxuKCogVG8gZm9yY2UgYSBsaW5lIGJyZWFrIGluc2lkZSBhIGJveDogbm8gb2Zmc2V0IGlzIGFkZGVkLiAqKVxubGV0IGJyZWFrX2xpbmUgc3RhdGUgd2lkdGggPSBicmVha19uZXdfbGluZSBzdGF0ZSAoXCJcIiwgMCwgXCJcIikgd2lkdGhcblxuKCogVG8gZm9ybWF0IGEgYnJlYWsgdGhhdCBmaXRzIG9uIHRoZSBjdXJyZW50IGxpbmUuICopXG5sZXQgYnJlYWtfc2FtZV9saW5lIHN0YXRlIChiZWZvcmUsIHdpZHRoLCBhZnRlcikgPVxuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGJlZm9yZTtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gd2lkdGg7XG4gIHBwX291dHB1dF9zcGFjZXMgc3RhdGUgd2lkdGg7XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYWZ0ZXJcblxuXG4oKiBUbyBpbmRlbnQgbm8gbW9yZSB0aGFuIHBwX21heF9pbmRlbnQsIGlmIG9uZSB0cmllcyB0byBvcGVuIGEgYm94XG4gICBiZXlvbmQgcHBfbWF4X2luZGVudCwgdGhlbiB0aGUgYm94IGlzIHJlamVjdGVkIG9uIHRoZSBsZWZ0XG4gICBieSBzaW11bGF0aW5nIGEgYnJlYWsuICopXG5sZXQgcHBfZm9yY2VfYnJlYWtfbGluZSBzdGF0ZSA9XG4gIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgfCBOb25lIC0+IHBwX291dHB1dF9uZXdsaW5lIHN0YXRlXG4gIHwgU29tZSB7IGJveF90eXBlOyB3aWR0aCB9IC0+XG4gICAgaWYgd2lkdGggPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0IHRoZW5cbiAgICAgIG1hdGNoIGJveF90eXBlIHdpdGhcbiAgICAgIHwgUHBfZml0cyB8IFBwX2hib3ggLT4gKClcbiAgICAgIHwgUHBfdmJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IC0+IGJyZWFrX2xpbmUgc3RhdGUgd2lkdGhcblxuXG4oKiBUbyBza2lwIGEgdG9rZW4sIGlmIHRoZSBwcmV2aW91cyBsaW5lIGhhcyBiZWVuIGJyb2tlbi4gKilcbmxldCBwcF9za2lwX3Rva2VuIHN0YXRlID1cbiAgbWF0Y2ggUXVldWUudGFrZV9vcHQgc3RhdGUucHBfcXVldWUgd2l0aFxuICB8IE5vbmUgLT4gKCkgKCogcHJpbnRfaWZfbmV3bGluZSBtdXN0IGhhdmUgYmVlbiB0aGUgbGFzdCBwcmludGluZyBjb21tYW5kICopXG4gIHwgU29tZSB7IHNpemU7IGxlbmd0aDsgXyB9IC0+XG4gICAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSBzdGF0ZS5wcF9sZWZ0X3RvdGFsIC0gbGVuZ3RoO1xuICAgIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCArIFNpemUudG9faW50IHNpemVcblxuXG4oKlxuXG4gIFRoZSBtYWluIHByZXR0eSBwcmludGluZyBmdW5jdGlvbnMuXG5cbiopXG5cbigqIEZvcm1hdHRpbmcgYSB0b2tlbiB3aXRoIGEgZ2l2ZW4gc2l6ZS4gKilcbmxldCBmb3JtYXRfcHBfdG9rZW4gc3RhdGUgc2l6ZSA9IGZ1bmN0aW9uXG5cbiAgfCBQcF90ZXh0IHMgLT5cbiAgICBmb3JtYXRfcHBfdGV4dCBzdGF0ZSBzaXplIHNcblxuICB8IFBwX2JlZ2luIChvZmYsIHR5KSAtPlxuICAgIGxldCBpbnNlcnRpb25fcG9pbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IGluXG4gICAgaWYgaW5zZXJ0aW9uX3BvaW50ID4gc3RhdGUucHBfbWF4X2luZGVudCB0aGVuXG4gICAgICAoKiBjYW4gbm90IG9wZW4gYSBib3ggcmlnaHQgdGhlcmUuICopXG4gICAgICBiZWdpbiBwcF9mb3JjZV9icmVha19saW5lIHN0YXRlIGVuZDtcbiAgICBsZXQgd2lkdGggPSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gb2ZmIGluXG4gICAgbGV0IGJveF90eXBlID1cbiAgICAgIG1hdGNoIHR5IHdpdGhcbiAgICAgIHwgUHBfdmJveCAtPiBQcF92Ym94XG4gICAgICB8IFBwX2hib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCB8IFBwX2ZpdHMgLT5cbiAgICAgICAgaWYgc2l6ZSA+IHN0YXRlLnBwX3NwYWNlX2xlZnQgdGhlbiB0eSBlbHNlIFBwX2ZpdHMgaW5cbiAgICBTdGFjay5wdXNoIHsgYm94X3R5cGU7IHdpZHRoIH0gc3RhdGUucHBfZm9ybWF0X3N0YWNrXG5cbiAgfCBQcF9lbmQgLT5cbiAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB8PiBpZ25vcmVcblxuICB8IFBwX3RiZWdpbiAoUHBfdGJveCBfIGFzIHRib3gpIC0+XG4gICAgU3RhY2sucHVzaCB0Ym94IHN0YXRlLnBwX3Rib3hfc3RhY2tcblxuICB8IFBwX3RlbmQgLT5cbiAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3Rib3hfc3RhY2sgfD4gaWdub3JlXG5cbiAgfCBQcF9zdGFiIC0+XG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF90Ym94X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gb3BlbiB0YWJ1bGF0aW9uIGJveC4gKilcbiAgICB8IFNvbWUgKFBwX3Rib3ggdGFicykgLT5cbiAgICAgIGxldCByZWMgYWRkX3RhYiBuID0gZnVuY3Rpb25cbiAgICAgICAgfCBbXSAtPiBbbl1cbiAgICAgICAgfCB4IDo6IGwgYXMgbHMgLT4gaWYgbiA8IHggdGhlbiBuIDo6IGxzIGVsc2UgeCA6OiBhZGRfdGFiIG4gbCBpblxuICAgICAgdGFicyA6PSBhZGRfdGFiIChzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0KSAhdGFic1xuICAgIGVuZFxuXG4gIHwgUHBfdGJyZWFrIChuLCBvZmYpIC0+XG4gICAgbGV0IGluc2VydGlvbl9wb2ludCA9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQgaW5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX3Rib3hfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBvcGVuIHRhYnVsYXRpb24gYm94LiAqKVxuICAgIHwgU29tZSAoUHBfdGJveCB0YWJzKSAtPlxuICAgICAgbGV0IHRhYiA9XG4gICAgICAgIG1hdGNoICF0YWJzIHdpdGhcbiAgICAgICAgfCBbXSAtPiBpbnNlcnRpb25fcG9pbnRcbiAgICAgICAgfCBmaXJzdCA6OiBfIC0+XG4gICAgICAgICAgbGV0IHJlYyBmaW5kID0gZnVuY3Rpb25cbiAgICAgICAgICAgIHwgaGVhZCA6OiB0YWlsIC0+XG4gICAgICAgICAgICAgIGlmIGhlYWQgPj0gaW5zZXJ0aW9uX3BvaW50IHRoZW4gaGVhZCBlbHNlIGZpbmQgdGFpbFxuICAgICAgICAgICAgfCBbXSAtPiBmaXJzdCBpblxuICAgICAgICAgIGZpbmQgIXRhYnMgaW5cbiAgICAgIGxldCBvZmZzZXQgPSB0YWIgLSBpbnNlcnRpb25fcG9pbnQgaW5cbiAgICAgIGlmIG9mZnNldCA+PSAwXG4gICAgICB0aGVuIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSAoXCJcIiwgb2Zmc2V0ICsgbiwgXCJcIilcbiAgICAgIGVsc2UgYnJlYWtfbmV3X2xpbmUgc3RhdGUgKFwiXCIsIHRhYiArIG9mZiwgXCJcIikgc3RhdGUucHBfbWFyZ2luXG4gICAgZW5kXG5cbiAgfCBQcF9uZXdsaW5lIC0+XG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZSAoKiBObyBvcGVuIGJveC4gKilcbiAgICB8IFNvbWUgeyB3aWR0aDsgX30gLT4gYnJlYWtfbGluZSBzdGF0ZSB3aWR0aFxuICAgIGVuZFxuXG4gIHwgUHBfaWZfbmV3bGluZSAtPlxuICAgIGlmIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50ICE9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnRcbiAgICB0aGVuIHBwX3NraXBfdG9rZW4gc3RhdGVcblxuICB8IFBwX2JyZWFrIHsgZml0czsgYnJlYWtzIH0gLT5cbiAgICBsZXQgYmVmb3JlLCBvZmYsIF8gPSBicmVha3MgaW5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG9wZW4gYm94LiAqKVxuICAgIHwgU29tZSB7IGJveF90eXBlOyB3aWR0aCB9IC0+XG4gICAgICBiZWdpbiBtYXRjaCBib3hfdHlwZSB3aXRoXG4gICAgICB8IFBwX2hvdmJveCAtPlxuICAgICAgICBpZiBzaXplICsgU3RyaW5nLmxlbmd0aCBiZWZvcmUgPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgICAgIHRoZW4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICAgIGVsc2UgYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIHwgUHBfYm94IC0+XG4gICAgICAgICgqIEhhdmUgdGhlIGxpbmUganVzdCBiZWVuIGJyb2tlbiBoZXJlID8gKilcbiAgICAgICAgaWYgc3RhdGUucHBfaXNfbmV3X2xpbmUgdGhlbiBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0cyBlbHNlXG4gICAgICAgIGlmIHNpemUgKyBTdHJpbmcubGVuZ3RoIGJlZm9yZSA+IHN0YXRlLnBwX3NwYWNlX2xlZnRcbiAgICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aCBlbHNlXG4gICAgICAgICgqIGJyZWFrIHRoZSBsaW5lIGhlcmUgbGVhZHMgdG8gbmV3IGluZGVudGF0aW9uID8gKilcbiAgICAgICAgaWYgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPiBzdGF0ZS5wcF9tYXJnaW4gLSB3aWR0aCArIG9mZlxuICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgICBlbHNlIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICB8IFBwX2h2Ym94IC0+IGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgfCBQcF9maXRzIC0+IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICB8IFBwX3Zib3ggLT4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICB8IFBwX2hib3ggLT4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICB8IFBwX29wZW5fdGFnIHRhZ19uYW1lIC0+XG4gICAgIGxldCBtYXJrZXIgPSBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnIHRhZ19uYW1lIGluXG4gICAgIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgbWFya2VyO1xuICAgICBTdGFjay5wdXNoIHRhZ19uYW1lIHN0YXRlLnBwX21hcmtfc3RhY2tcblxuICAgfCBQcF9jbG9zZV90YWcgLT5cbiAgICAgYmVnaW4gbWF0Y2ggU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9tYXJrX3N0YWNrIHdpdGhcbiAgICAgfCBOb25lIC0+ICgpICgqIE5vIG1vcmUgdGFnIHRvIGNsb3NlLiAqKVxuICAgICB8IFNvbWUgdGFnX25hbWUgLT5cbiAgICAgICBsZXQgbWFya2VyID0gc3RhdGUucHBfbWFya19jbG9zZV90YWcgdGFnX25hbWUgaW5cbiAgICAgICBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIG1hcmtlclxuICAgICBlbmRcblxuXG4oKiBQcmludCBpZiB0b2tlbiBzaXplIGlzIGtub3duIGVsc2UgcHJpbnRpbmcgaXMgZGVsYXllZC5cbiAgIFByaW50aW5nIGlzIGRlbGF5ZWQgd2hlbiB0aGUgdGV4dCB3YWl0aW5nIGluIHRoZSBxdWV1ZSByZXF1aXJlc1xuICAgbW9yZSByb29tIHRvIGZvcm1hdCB0aGFuIGV4aXN0cyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxubGV0IHJlYyBhZHZhbmNlX2xlZnQgc3RhdGUgPVxuICBtYXRjaCBRdWV1ZS5wZWVrX29wdCBzdGF0ZS5wcF9xdWV1ZSB3aXRoXG4gIHwgTm9uZSAtPiAoKSAoKiBObyB0b2tlbnMgdG8gcHJpbnQgKilcbiAgfCBTb21lIHsgc2l6ZTsgdG9rZW47IGxlbmd0aCB9IC0+XG4gICAgbGV0IHBlbmRpbmdfY291bnQgPSBzdGF0ZS5wcF9yaWdodF90b3RhbCAtIHN0YXRlLnBwX2xlZnRfdG90YWwgaW5cbiAgICBpZiBTaXplLmlzX2tub3duIHNpemUgfHwgcGVuZGluZ19jb3VudCA+PSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IHRoZW4gYmVnaW5cbiAgICAgIFF1ZXVlLnRha2Ugc3RhdGUucHBfcXVldWUgfD4gaWdub3JlOyAoKiBOb3QgZW1wdHk6IHdlIHBlZWsgaW50byBpdCAqKVxuICAgICAgbGV0IHNpemUgPSBpZiBTaXplLmlzX2tub3duIHNpemUgdGhlbiBTaXplLnRvX2ludCBzaXplIGVsc2UgcHBfaW5maW5pdHkgaW5cbiAgICAgIGZvcm1hdF9wcF90b2tlbiBzdGF0ZSBzaXplIHRva2VuO1xuICAgICAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSBsZW5ndGggKyBzdGF0ZS5wcF9sZWZ0X3RvdGFsO1xuICAgICAgKGFkdmFuY2VfbGVmdCBbQHRhaWxjYWxsXSkgc3RhdGVcbiAgICBlbmRcblxuXG4oKiBUbyBlbnF1ZXVlIGEgdG9rZW4gOiB0cnkgdG8gYWR2YW5jZS4gKilcbmxldCBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgdG9rID0gcHBfZW5xdWV1ZSBzdGF0ZSB0b2s7IGFkdmFuY2VfbGVmdCBzdGF0ZVxuXG5cbigqIFRvIGVucXVldWUgc3RyaW5ncy4gKilcbmxldCBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSBzaXplIHMgPVxuICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgeyBzaXplOyB0b2tlbiA9IFBwX3RleHQgczsgbGVuZ3RoID0gU2l6ZS50b19pbnQgc2l6ZSB9XG5cblxubGV0IGVucXVldWVfc3RyaW5nIHN0YXRlIHMgPVxuICBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSAoU2l6ZS5vZl9pbnQgKFN0cmluZy5sZW5ndGggcykpIHNcblxuXG4oKiBSb3V0aW5lcyBmb3Igc2NhbiBzdGFja1xuICAgZGV0ZXJtaW5lIHNpemUgb2YgYm94ZXMuICopXG5cbigqIFRoZSBzY2FuX3N0YWNrIGlzIG5ldmVyIGVtcHR5LiAqKVxubGV0IGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGFjayA9XG4gIFN0YWNrLmNsZWFyIHN0YWNrO1xuICBsZXQgcXVldWVfZWxlbSA9IHsgc2l6ZSA9IFNpemUudW5rbm93bjsgdG9rZW4gPSBQcF90ZXh0IFwiXCI7IGxlbmd0aCA9IDAgfSBpblxuICBTdGFjay5wdXNoIHsgbGVmdF90b3RhbCA9IC0xOyBxdWV1ZV9lbGVtIH0gc3RhY2tcblxuKCogU2V0dGluZyB0aGUgc2l6ZSBvZiBib3hlcyBvbiBzY2FuIHN0YWNrOlxuICAgaWYgdHkgPSB0cnVlIHRoZW4gc2l6ZSBvZiBicmVhayBpcyBzZXQgZWxzZSBzaXplIG9mIGJveCBpcyBzZXQ7XG4gICBpbiBlYWNoIGNhc2UgcHBfc2Nhbl9zdGFjayBpcyBwb3BwZWQuXG5cbiAgIE5vdGU6XG4gICBQYXR0ZXJuIG1hdGNoaW5nIG9uIHNjYW4gc3RhY2sgaXMgZXhoYXVzdGl2ZSwgc2luY2Ugc2Nhbl9zdGFjayBpcyBuZXZlclxuICAgZW1wdHkuXG4gICBQYXR0ZXJuIG1hdGNoaW5nIG9uIHRva2VuIGluIHNjYW4gc3RhY2sgaXMgYWxzbyBleGhhdXN0aXZlLFxuICAgc2luY2Ugc2Nhbl9wdXNoIGlzIHVzZWQgb24gYnJlYWtzIGFuZCBvcGVuaW5nIG9mIGJveGVzLiAqKVxubGV0IHNldF9zaXplIHN0YXRlIHR5ID1cbiAgbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9zY2FuX3N0YWNrIHdpdGhcbiAgfCBOb25lIC0+ICgpICgqIHNjYW5fc3RhY2sgaXMgbmV2ZXIgZW1wdHkuICopXG4gIHwgU29tZSB7IGxlZnRfdG90YWw7IHF1ZXVlX2VsZW0gfSAtPlxuICAgIGxldCBzaXplID0gU2l6ZS50b19pbnQgcXVldWVfZWxlbS5zaXplIGluXG4gICAgKCogdGVzdCBpZiBzY2FuIHN0YWNrIGNvbnRhaW5zIGFueSBkYXRhIHRoYXQgaXMgbm90IG9ic29sZXRlLiAqKVxuICAgIGlmIGxlZnRfdG90YWwgPCBzdGF0ZS5wcF9sZWZ0X3RvdGFsIHRoZW5cbiAgICAgIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGF0ZS5wcF9zY2FuX3N0YWNrXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggcXVldWVfZWxlbS50b2tlbiB3aXRoXG4gICAgICB8IFBwX2JyZWFrIF8gfCBQcF90YnJlYWsgKF8sIF8pIC0+XG4gICAgICAgIGlmIHR5IHRoZW4gYmVnaW5cbiAgICAgICAgICBxdWV1ZV9lbGVtLnNpemUgPC0gU2l6ZS5vZl9pbnQgKHN0YXRlLnBwX3JpZ2h0X3RvdGFsICsgc2l6ZSk7XG4gICAgICAgICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9zY2FuX3N0YWNrIHw+IGlnbm9yZVxuICAgICAgICBlbmRcbiAgICAgIHwgUHBfYmVnaW4gKF8sIF8pIC0+XG4gICAgICAgIGlmIG5vdCB0eSB0aGVuIGJlZ2luXG4gICAgICAgICAgcXVldWVfZWxlbS5zaXplIDwtIFNpemUub2ZfaW50IChzdGF0ZS5wcF9yaWdodF90b3RhbCArIHNpemUpO1xuICAgICAgICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfc2Nhbl9zdGFjayB8PiBpZ25vcmVcbiAgICAgICAgZW5kXG4gICAgICB8IFBwX3RleHQgXyB8IFBwX3N0YWIgfCBQcF90YmVnaW4gXyB8IFBwX3RlbmQgfCBQcF9lbmRcbiAgICAgIHwgUHBfbmV3bGluZSB8IFBwX2lmX25ld2xpbmUgfCBQcF9vcGVuX3RhZyBfIHwgUHBfY2xvc2VfdGFnIC0+XG4gICAgICAgICgpICgqIHNjYW5fcHVzaCBpcyBvbmx5IHVzZWQgZm9yIGJyZWFrcyBhbmQgYm94ZXMuICopXG5cblxuKCogUHVzaCBhIHRva2VuIG9uIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLlxuICAgSWYgYiBpcyB0cnVlIHNldF9zaXplIGlzIGNhbGxlZC4gKilcbmxldCBzY2FuX3B1c2ggc3RhdGUgYiB0b2tlbiA9XG4gIHBwX2VucXVldWUgc3RhdGUgdG9rZW47XG4gIGlmIGIgdGhlbiBzZXRfc2l6ZSBzdGF0ZSB0cnVlO1xuICBsZXQgZWxlbSA9IHsgbGVmdF90b3RhbCA9IHN0YXRlLnBwX3JpZ2h0X3RvdGFsOyBxdWV1ZV9lbGVtID0gdG9rZW4gfSBpblxuICBTdGFjay5wdXNoIGVsZW0gc3RhdGUucHBfc2Nhbl9zdGFja1xuXG5cbigqIFRvIG9wZW4gYSBuZXcgYm94IDpcbiAgIHRoZSB1c2VyIG1heSBzZXQgdGhlIGRlcHRoIGJvdW5kIHBwX21heF9ib3hlc1xuICAgYW55IHRleHQgbmVzdGVkIGRlZXBlciBpcyBwcmludGVkIGFzIHRoZSBlbGxpcHNpcyBzdHJpbmcuICopXG5sZXQgcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBicl90eSA9XG4gIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCArIDE7XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuID0gUHBfYmVnaW4gKGluZGVudCwgYnJfdHkpOyBsZW5ndGggPSAwIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgZmFsc2UgZWxlbSBlbHNlXG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPSBzdGF0ZS5wcF9tYXhfYm94ZXNcbiAgdGhlbiBlbnF1ZXVlX3N0cmluZyBzdGF0ZSBzdGF0ZS5wcF9lbGxpcHNpc1xuXG5cbigqIFRoZSBib3ggd2hpY2ggaXMgYWx3YXlzIG9wZW4uICopXG5sZXQgcHBfb3Blbl9zeXNfYm94IHN0YXRlID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIDAgUHBfaG92Ym94XG5cbigqIENsb3NlIGEgYm94LCBzZXR0aW5nIHNpemVzIG9mIGl0cyBzdWIgYm94ZXMuICopXG5sZXQgcHBfY2xvc2VfYm94IHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgdGhlblxuICBiZWdpblxuICAgIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGJlZ2luXG4gICAgICBwcF9lbnF1ZXVlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9lbmQ7IGxlbmd0aCA9IDAgfTtcbiAgICAgIHNldF9zaXplIHN0YXRlIHRydWU7IHNldF9zaXplIHN0YXRlIGZhbHNlXG4gICAgZW5kO1xuICAgIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCAtIDE7XG4gIGVuZFxuXG5cbigqIE9wZW4gYSB0YWcsIHB1c2hpbmcgaXQgb24gdGhlIHRhZyBzdGFjay4gKilcbmxldCBwcF9vcGVuX3N0YWcgc3RhdGUgdGFnX25hbWUgPVxuICBpZiBzdGF0ZS5wcF9wcmludF90YWdzIHRoZW5cbiAgYmVnaW5cbiAgICBTdGFjay5wdXNoIHRhZ19uYW1lIHN0YXRlLnBwX3RhZ19zdGFjaztcbiAgICBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZyB0YWdfbmFtZVxuICBlbmQ7XG4gIGlmIHN0YXRlLnBwX21hcmtfdGFncyB0aGVuXG4gICAgbGV0IHRva2VuID0gUHBfb3Blbl90YWcgdGFnX25hbWUgaW5cbiAgICBwcF9lbnF1ZXVlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW47IGxlbmd0aCA9IDAgfVxuXG5cbigqIENsb3NlIGEgdGFnLCBwb3BwaW5nIGl0IGZyb20gdGhlIHRhZyBzdGFjay4gKilcbmxldCBwcF9jbG9zZV9zdGFnIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfbWFya190YWdzIHRoZW5cbiAgICBwcF9lbnF1ZXVlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9jbG9zZV90YWc7IGxlbmd0aCA9IDAgfTtcbiAgaWYgc3RhdGUucHBfcHJpbnRfdGFncyB0aGVuXG4gICAgbWF0Y2ggU3RhY2sucG9wX29wdCBzdGF0ZS5wcF90YWdfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBtb3JlIHRhZyB0byBjbG9zZS4gKilcbiAgICB8IFNvbWUgdGFnX25hbWUgLT5cbiAgICAgIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyB0YWdfbmFtZVxuXG5sZXQgcHBfb3Blbl90YWcgc3RhdGUgcyA9IHBwX29wZW5fc3RhZyBzdGF0ZSAoU3RyaW5nX3RhZyBzKVxubGV0IHBwX2Nsb3NlX3RhZyBzdGF0ZSAoKSA9IHBwX2Nsb3NlX3N0YWcgc3RhdGUgKClcblxubGV0IHBwX3NldF9wcmludF90YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9wcmludF90YWdzIDwtIGJcbmxldCBwcF9zZXRfbWFya190YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9tYXJrX3RhZ3MgPC0gYlxubGV0IHBwX2dldF9wcmludF90YWdzIHN0YXRlICgpID0gc3RhdGUucHBfcHJpbnRfdGFnc1xubGV0IHBwX2dldF9tYXJrX3RhZ3Mgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXJrX3RhZ3NcbmxldCBwcF9zZXRfdGFncyBzdGF0ZSBiID1cbiAgcHBfc2V0X3ByaW50X3RhZ3Mgc3RhdGUgYjsgcHBfc2V0X21hcmtfdGFncyBzdGF0ZSBiXG5cblxuKCogSGFuZGxpbmcgdGFnIGhhbmRsaW5nIGZ1bmN0aW9uczogZ2V0L3NldCBmdW5jdGlvbnMuICopXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBzdGF0ZSAoKSA9IHtcbiAgbWFya19vcGVuX3N0YWcgPSBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnO1xuICBtYXJrX2Nsb3NlX3N0YWcgPSBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZztcbiAgcHJpbnRfb3Blbl9zdGFnID0gc3RhdGUucHBfcHJpbnRfb3Blbl90YWc7XG4gIHByaW50X2Nsb3NlX3N0YWcgPSBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWc7XG59XG5cblxubGV0IHBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RhdGUge1xuICAgICBtYXJrX29wZW5fc3RhZyA9IG1vdDtcbiAgICAgbWFya19jbG9zZV9zdGFnID0gbWN0O1xuICAgICBwcmludF9vcGVuX3N0YWcgPSBwb3Q7XG4gICAgIHByaW50X2Nsb3NlX3N0YWcgPSBwY3Q7XG4gIH0gPVxuICBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnIDwtIG1vdDtcbiAgc3RhdGUucHBfbWFya19jbG9zZV90YWcgPC0gbWN0O1xuICBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZyA8LSBwb3Q7XG4gIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyA8LSBwY3RcblxuXG4oKiBJbml0aWFsaXplIHByZXR0eS1wcmludGVyLiAqKVxubGV0IHBwX3Jpbml0IHN0YXRlID1cbiAgcHBfY2xlYXJfcXVldWUgc3RhdGU7XG4gIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGF0ZS5wcF9zY2FuX3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF9mb3JtYXRfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX3Rib3hfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX3RhZ19zdGFjaztcbiAgU3RhY2suY2xlYXIgc3RhdGUucHBfbWFya19zdGFjaztcbiAgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPC0gMDtcbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSAwO1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX21hcmdpbjtcbiAgcHBfb3Blbl9zeXNfYm94IHN0YXRlXG5cbmxldCBjbGVhcl90YWdfc3RhY2sgc3RhdGUgPVxuICBTdGFjay5pdGVyIChmdW4gXyAtPiBwcF9jbG9zZV90YWcgc3RhdGUgKCkpIHN0YXRlLnBwX3RhZ19zdGFja1xuXG5cbigqIEZsdXNoaW5nIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxubGV0IHBwX2ZsdXNoX3F1ZXVlIHN0YXRlIGIgPVxuICBjbGVhcl90YWdfc3RhY2sgc3RhdGU7XG4gIHdoaWxlIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIGRvXG4gICAgcHBfY2xvc2VfYm94IHN0YXRlICgpXG4gIGRvbmU7XG4gIHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIHBwX2luZmluaXR5O1xuICBhZHZhbmNlX2xlZnQgc3RhdGU7XG4gIGlmIGIgdGhlbiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZTtcbiAgcHBfcmluaXQgc3RhdGVcblxuKCpcblxuICBQcm9jZWR1cmVzIHRvIGZvcm1hdCB2YWx1ZXMgYW5kIHVzZSBib3hlcy5cblxuKilcblxuKCogVG8gZm9ybWF0IGEgc3RyaW5nLiAqKVxubGV0IHBwX3ByaW50X2FzX3NpemUgc3RhdGUgc2l6ZSBzID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlc1xuICB0aGVuIGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIHNpemUgc1xuXG5cbmxldCBwcF9wcmludF9hcyBzdGF0ZSBpc2l6ZSBzID1cbiAgcHBfcHJpbnRfYXNfc2l6ZSBzdGF0ZSAoU2l6ZS5vZl9pbnQgaXNpemUpIHNcblxuXG5sZXQgcHBfcHJpbnRfc3RyaW5nIHN0YXRlIHMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAoU3RyaW5nLmxlbmd0aCBzKSBzXG5cbmxldCBwcF9wcmludF9ieXRlcyBzdGF0ZSBzID1cbiAgcHBfcHJpbnRfYXMgc3RhdGUgKEJ5dGVzLmxlbmd0aCBzKSAoQnl0ZXMudG9fc3RyaW5nIHMpXG5cbigqIFRvIGZvcm1hdCBhbiBpbnRlZ2VyLiAqKVxubGV0IHBwX3ByaW50X2ludCBzdGF0ZSBpID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChJbnQudG9fc3RyaW5nIGkpXG5cbigqIFRvIGZvcm1hdCBhIGZsb2F0LiAqKVxubGV0IHBwX3ByaW50X2Zsb2F0IHN0YXRlIGYgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKHN0cmluZ19vZl9mbG9hdCBmKVxuXG4oKiBUbyBmb3JtYXQgYSBib29sZWFuLiAqKVxubGV0IHBwX3ByaW50X2Jvb2wgc3RhdGUgYiA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoc3RyaW5nX29mX2Jvb2wgYilcblxuKCogVG8gZm9ybWF0IGEgY2hhci4gKilcbmxldCBwcF9wcmludF9jaGFyIHN0YXRlIGMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAxIChTdHJpbmcubWFrZSAxIGMpXG5cblxuKCogT3BlbmluZyBib3hlcy4gKilcbmxldCBwcF9vcGVuX2hib3ggc3RhdGUgKCkgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgMCBQcF9oYm94XG5hbmQgcHBfb3Blbl92Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfdmJveFxuXG5hbmQgcHBfb3Blbl9odmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2h2Ym94XG5hbmQgcHBfb3Blbl9ob3Zib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF9ob3Zib3hcbmFuZCBwcF9vcGVuX2JveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2JveFxuXG5cbigqIFByaW50aW5nIHF1ZXVlZCB0ZXh0LlxuXG4gICBbcHBfcHJpbnRfZmx1c2hdIHByaW50cyBhbGwgcGVuZGluZyBpdGVtcyBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUgYW5kXG4gICB0aGVuIGZsdXNoZXMgdGhlIGxvdyBsZXZlbCBvdXRwdXQgZGV2aWNlIG9mIHRoZSBmb3JtYXR0ZXIgdG8gYWN0dWFsbHlcbiAgIGRpc3BsYXkgcHJpbnRpbmcgbWF0ZXJpYWwuXG5cbiAgIFtwcF9wcmludF9uZXdsaW5lXSBiZWhhdmVzIGFzIFtwcF9wcmludF9mbHVzaF0gYWZ0ZXIgcHJpbnRpbmcgYW4gYWRkaXRpb25hbFxuICAgbmV3IGxpbmUuICopXG5sZXQgcHBfcHJpbnRfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIHBwX2ZsdXNoX3F1ZXVlIHN0YXRlIHRydWU7IHN0YXRlLnBwX291dF9mbHVzaCAoKVxuYW5kIHBwX3ByaW50X2ZsdXNoIHN0YXRlICgpID1cbiAgcHBfZmx1c2hfcXVldWUgc3RhdGUgZmFsc2U7IHN0YXRlLnBwX291dF9mbHVzaCAoKVxuXG5cbigqIFRvIGdldCBhIG5ld2xpbmUgd2hlbiBvbmUgZG9lcyBub3Qgd2FudCB0byBjbG9zZSB0aGUgY3VycmVudCBib3guICopXG5sZXQgcHBfZm9yY2VfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfbmV3bGluZTsgbGVuZ3RoID0gMCB9XG5cblxuKCogVG8gZm9ybWF0IHNvbWV0aGluZywgb25seSBpbiBjYXNlIHRoZSBsaW5lIGhhcyBqdXN0IGJlZW4gYnJva2VuLiAqKVxubGV0IHBwX3ByaW50X2lmX25ld2xpbmUgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGVcbiAgICAgIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9pZl9uZXdsaW5lOyBsZW5ndGggPSAwIH1cblxuXG4oKiBHZW5lcmFsaXplZCBicmVhayBoaW50IHRoYXQgYWxsb3dzIHByaW50aW5nIHN0cmluZ3MgYmVmb3JlL2FmdGVyXG4gICBzYW1lLWxpbmUgb2Zmc2V0ICh3aWR0aCkgb3IgbmV3LWxpbmUgb2Zmc2V0ICopXG5sZXQgcHBfcHJpbnRfY3VzdG9tX2JyZWFrIHN0YXRlIH5maXRzIH5icmVha3MgPVxuICBsZXQgYmVmb3JlLCB3aWR0aCwgYWZ0ZXIgPSBmaXRzIGluXG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IHRva2VuID0gUHBfYnJlYWsgeyBmaXRzOyBicmVha3MgfSBpblxuICAgIGxldCBsZW5ndGggPSBTdHJpbmcubGVuZ3RoIGJlZm9yZSArIHdpZHRoICsgU3RyaW5nLmxlbmd0aCBhZnRlciBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbjsgbGVuZ3RoIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgdHJ1ZSBlbGVtXG5cbigqIFByaW50aW5nIGJyZWFrIGhpbnRzOlxuICAgQSBicmVhayBoaW50IGluZGljYXRlcyB3aGVyZSBhIGJveCBtYXkgYmUgYnJva2VuLlxuICAgSWYgbGluZSBpcyBicm9rZW4gdGhlbiBvZmZzZXQgaXMgYWRkZWQgdG8gdGhlIGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50XG4gICBib3ggZWxzZSAodGhlIHZhbHVlIG9mKSB3aWR0aCBibGFua3MgYXJlIHByaW50ZWQuICopXG5sZXQgcHBfcHJpbnRfYnJlYWsgc3RhdGUgd2lkdGggb2Zmc2V0ID1cbiAgcHBfcHJpbnRfY3VzdG9tX2JyZWFrIHN0YXRlXG4gICAgfmZpdHM6KFwiXCIsIHdpZHRoLCBcIlwiKSB+YnJlYWtzOihcIlwiLCBvZmZzZXQsIFwiXCIpXG5cblxuKCogUHJpbnQgYSBzcGFjZSA6XG4gICBhIHNwYWNlIGlzIGEgYnJlYWsgaGludCB0aGF0IHByaW50cyBhIHNpbmdsZSBzcGFjZSBpZiB0aGUgYnJlYWsgZG9lcyBub3RcbiAgIHNwbGl0IHRoZSBsaW5lO1xuICAgYSBjdXQgaXMgYSBicmVhayBoaW50IHRoYXQgcHJpbnRzIG5vdGhpbmcgaWYgdGhlIGJyZWFrIGRvZXMgbm90IHNwbGl0IHRoZVxuICAgbGluZS4gKilcbmxldCBwcF9wcmludF9zcGFjZSBzdGF0ZSAoKSA9IHBwX3ByaW50X2JyZWFrIHN0YXRlIDEgMFxuYW5kIHBwX3ByaW50X2N1dCBzdGF0ZSAoKSA9IHBwX3ByaW50X2JyZWFrIHN0YXRlIDAgMFxuXG5cbigqIFRhYnVsYXRpb24gYm94ZXMuICopXG5sZXQgcHBfb3Blbl90Ym94IHN0YXRlICgpID1cbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoICsgMTtcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLnplcm8gaW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZTsgdG9rZW4gPSBQcF90YmVnaW4gKFBwX3Rib3ggKHJlZiBbXSkpOyBsZW5ndGggPSAwIH0gaW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbVxuXG5cbigqIENsb3NlIGEgdGFidWxhdGlvbiBib3guICopXG5sZXQgcHBfY2xvc2VfdGJveCBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIHRoZW5cbiAgYmVnaW5cbiAgIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgICBsZXQgZWxlbSA9IHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF90ZW5kOyBsZW5ndGggPSAwIH0gaW5cbiAgICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIGVsZW07XG4gICAgIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCAtIDFcbiAgZW5kXG5cblxuKCogUHJpbnQgYSB0YWJ1bGF0aW9uIGJyZWFrLiAqKVxubGV0IHBwX3ByaW50X3RicmVhayBzdGF0ZSB3aWR0aCBvZmZzZXQgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUub2ZfaW50ICgtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsKSBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbiA9IFBwX3RicmVhayAod2lkdGgsIG9mZnNldCk7IGxlbmd0aCA9IHdpZHRoIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgdHJ1ZSBlbGVtXG5cblxubGV0IHBwX3ByaW50X3RhYiBzdGF0ZSAoKSA9IHBwX3ByaW50X3RicmVhayBzdGF0ZSAwIDBcblxubGV0IHBwX3NldF90YWIgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9zdGFiOyBsZW5ndGggPSAwIH0gaW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbVxuXG5cbigqXG5cbiAgUHJvY2VkdXJlcyB0byBjb250cm9sIHRoZSBwcmV0dHktcHJpbnRlcnNcblxuKilcblxuKCogU2V0X21heF9ib3hlcy4gKilcbmxldCBwcF9zZXRfbWF4X2JveGVzIHN0YXRlIG4gPSBpZiBuID4gMSB0aGVuIHN0YXRlLnBwX21heF9ib3hlcyA8LSBuXG5cbigqIFRvIGtub3cgdGhlIGN1cnJlbnQgbWF4aW11bSBudW1iZXIgb2YgYm94ZXMgYWxsb3dlZC4gKilcbmxldCBwcF9nZXRfbWF4X2JveGVzIHN0YXRlICgpID0gc3RhdGUucHBfbWF4X2JveGVzXG5cbmxldCBwcF9vdmVyX21heF9ib3hlcyBzdGF0ZSAoKSA9IHN0YXRlLnBwX2N1cnJfZGVwdGggPSBzdGF0ZS5wcF9tYXhfYm94ZXNcblxuKCogRWxsaXBzaXMuICopXG5sZXQgcHBfc2V0X2VsbGlwc2lzX3RleHQgc3RhdGUgcyA9IHN0YXRlLnBwX2VsbGlwc2lzIDwtIHNcbmFuZCBwcF9nZXRfZWxsaXBzaXNfdGV4dCBzdGF0ZSAoKSA9IHN0YXRlLnBwX2VsbGlwc2lzXG5cblxuKCogVG8gc2V0IHRoZSBtYXJnaW4gb2YgcHJldHR5LXByaW50ZXIuICopXG5sZXQgcHBfbGltaXQgbiA9XG4gIGlmIG4gPCBwcF9pbmZpbml0eSB0aGVuIG4gZWxzZSBwcmVkIHBwX2luZmluaXR5XG5cblxuKCogSW50ZXJuYWwgcHJldHR5LXByaW50ZXIgZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9taW5fc3BhY2VfbGVmdCBzdGF0ZSBuID1cbiAgaWYgbiA+PSAxIHRoZW5cbiAgICBsZXQgbiA9IHBwX2xpbWl0IG4gaW5cbiAgICBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdCA8LSBuO1xuICAgIHN0YXRlLnBwX21heF9pbmRlbnQgPC0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfcmluaXQgc3RhdGVcblxuXG4oKiBJbml0aWFsbHksIHdlIGhhdmUgOlxuICAgcHBfbWF4X2luZGVudCA9IHBwX21hcmdpbiAtIHBwX21pbl9zcGFjZV9sZWZ0LCBhbmRcbiAgIHBwX3NwYWNlX2xlZnQgPSBwcF9tYXJnaW4uICopXG5sZXQgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbiA9XG4gIGlmIG4gPiAxIHRoZW5cbiAgICBwcF9zZXRfbWluX3NwYWNlX2xlZnQgc3RhdGUgKHN0YXRlLnBwX21hcmdpbiAtIG4pXG5cblxubGV0IHBwX2dldF9tYXhfaW5kZW50IHN0YXRlICgpID0gc3RhdGUucHBfbWF4X2luZGVudFxuXG5sZXQgcHBfc2V0X21hcmdpbiBzdGF0ZSBuID1cbiAgaWYgbiA+PSAxIHRoZW5cbiAgICBsZXQgbiA9IHBwX2xpbWl0IG4gaW5cbiAgICBzdGF0ZS5wcF9tYXJnaW4gPC0gbjtcbiAgICBsZXQgbmV3X21heF9pbmRlbnQgPVxuICAgICAgKCogVHJ5IHRvIG1haW50YWluIG1heF9pbmRlbnQgdG8gaXRzIGFjdHVhbCB2YWx1ZS4gKilcbiAgICAgIGlmIHN0YXRlLnBwX21heF9pbmRlbnQgPD0gc3RhdGUucHBfbWFyZ2luXG4gICAgICB0aGVuIHN0YXRlLnBwX21heF9pbmRlbnQgZWxzZVxuICAgICAgKCogSWYgcG9zc2libGUgbWFpbnRhaW4gcHBfbWluX3NwYWNlX2xlZnQgdG8gaXRzIGFjdHVhbCB2YWx1ZSxcbiAgICAgICAgIGlmIHRoaXMgbGVhZHMgdG8gYSB0b28gc21hbGwgbWF4X2luZGVudCwgdGFrZSBoYWxmIG9mIHRoZVxuICAgICAgICAgbmV3IG1hcmdpbiwgaWYgaXQgaXMgZ3JlYXRlciB0aGFuIDEuICopXG4gICAgICAgSW50Lm1heCAoSW50Lm1heCAoc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfbWluX3NwYWNlX2xlZnQpXG4gICAgICAgICAgICAgICAgKHN0YXRlLnBwX21hcmdpbiAvIDIpKSAxIGluXG4gICAgKCogUmVidWlsZCBpbnZhcmlhbnRzLiAqKVxuICAgIHBwX3NldF9tYXhfaW5kZW50IHN0YXRlIG5ld19tYXhfaW5kZW50XG5cblxuKCoqIEdlb21ldHJ5IGZ1bmN0aW9ucyBhbmQgdHlwZXMgKilcbnR5cGUgZ2VvbWV0cnkgPSB7IG1heF9pbmRlbnQ6aW50OyBtYXJnaW46IGludH1cblxubGV0IHZhbGlkYXRlX2dlb21ldHJ5IHttYXJnaW47IG1heF9pbmRlbnR9ID1cbiAgaWYgbWF4X2luZGVudCA8IDIgdGhlblxuICAgIEVycm9yIFwibWF4X2luZGVudCA8IDJcIlxuICBlbHNlIGlmIG1hcmdpbiA8PSBtYXhfaW5kZW50IHRoZW5cbiAgICBFcnJvciBcIm1hcmdpbiA8PSBtYXhfaW5kZW50XCJcbiAgZWxzZSBPayAoKVxuXG5sZXQgY2hlY2tfZ2VvbWV0cnkgZ2VvbWV0cnkgPVxuICBtYXRjaCB2YWxpZGF0ZV9nZW9tZXRyeSBnZW9tZXRyeSB3aXRoXG4gIHwgT2sgKCkgLT4gdHJ1ZVxuICB8IEVycm9yIF8gLT4gZmFsc2VcblxubGV0IHBwX2dldF9tYXJnaW4gc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXJnaW5cblxubGV0IHBwX3NldF9mdWxsX2dlb21ldHJ5IHN0YXRlIHttYXJnaW47IG1heF9pbmRlbnR9ID1cbiAgcHBfc2V0X21hcmdpbiBzdGF0ZSBtYXJnaW47XG4gIHBwX3NldF9tYXhfaW5kZW50IHN0YXRlIG1heF9pbmRlbnQ7XG4gICgpXG5cbmxldCBwcF9zZXRfZ2VvbWV0cnkgc3RhdGUgfm1heF9pbmRlbnQgfm1hcmdpbiA9XG4gIGxldCBnZW9tZXRyeSA9IHsgbWF4X2luZGVudDsgbWFyZ2luIH0gaW5cbiAgbWF0Y2ggdmFsaWRhdGVfZ2VvbWV0cnkgZ2VvbWV0cnkgd2l0aFxuICB8IEVycm9yIG1zZyAtPlxuICAgIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IChcIkZvcm1hdC5wcF9zZXRfZ2VvbWV0cnk6IFwiIF4gbXNnKSlcbiAgfCBPayAoKSAtPlxuICAgIHBwX3NldF9mdWxsX2dlb21ldHJ5IHN0YXRlIGdlb21ldHJ5XG5cbmxldCBwcF9zYWZlX3NldF9nZW9tZXRyeSBzdGF0ZSB+bWF4X2luZGVudCB+bWFyZ2luID1cbiAgbGV0IGdlb21ldHJ5ID0geyBtYXhfaW5kZW50OyBtYXJnaW4gfSBpblxuICBtYXRjaCB2YWxpZGF0ZV9nZW9tZXRyeSBnZW9tZXRyeSB3aXRoXG4gIHwgRXJyb3IgX21zZyAtPlxuICAgICAoKVxuICB8IE9rICgpIC0+XG4gICAgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUgZ2VvbWV0cnlcblxubGV0IHBwX2dldF9nZW9tZXRyeSBzdGF0ZSAoKSA9XG4gIHsgbWFyZ2luID0gcHBfZ2V0X21hcmdpbiBzdGF0ZSAoKTsgbWF4X2luZGVudCA9IHBwX2dldF9tYXhfaW5kZW50IHN0YXRlICgpIH1cblxubGV0IHBwX3VwZGF0ZV9nZW9tZXRyeSBzdGF0ZSB1cGRhdGUgPVxuICBsZXQgZ2VvbWV0cnkgPSBwcF9nZXRfZ2VvbWV0cnkgc3RhdGUgKCkgaW5cbiAgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUgKHVwZGF0ZSBnZW9tZXRyeSlcblxuKCogU2V0dGluZyBhIGZvcm1hdHRlciBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGF0ZSB7XG4gICAgICBvdXRfc3RyaW5nID0gZjtcbiAgICAgIG91dF9mbHVzaCA9IGc7XG4gICAgICBvdXRfbmV3bGluZSA9IGg7XG4gICAgICBvdXRfc3BhY2VzID0gaTtcbiAgICAgIG91dF9pbmRlbnQgPSBqO1xuICAgIH0gPVxuICBzdGF0ZS5wcF9vdXRfc3RyaW5nIDwtIGY7XG4gIHN0YXRlLnBwX291dF9mbHVzaCA8LSBnO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBoO1xuICBzdGF0ZS5wcF9vdXRfc3BhY2VzIDwtIGk7XG4gIHN0YXRlLnBwX291dF9pbmRlbnQgPC0galxuXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0YXRlICgpID0ge1xuICBvdXRfc3RyaW5nID0gc3RhdGUucHBfb3V0X3N0cmluZztcbiAgb3V0X2ZsdXNoID0gc3RhdGUucHBfb3V0X2ZsdXNoO1xuICBvdXRfbmV3bGluZSA9IHN0YXRlLnBwX291dF9uZXdsaW5lO1xuICBvdXRfc3BhY2VzID0gc3RhdGUucHBfb3V0X3NwYWNlcztcbiAgb3V0X2luZGVudCA9IHN0YXRlLnBwX291dF9pbmRlbnQ7XG59XG5cblxuKCogU2V0dGluZyBhIGZvcm1hdHRlciBiYXNpYyBzdHJpbmcgb3V0cHV0IGFuZCBmbHVzaCBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlIGYgZyA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gZjsgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIGdcblxubGV0IHBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZSAoKSA9XG4gIChzdGF0ZS5wcF9vdXRfc3RyaW5nLCBzdGF0ZS5wcF9vdXRfZmx1c2gpXG5cblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IG5ldyBsaW5lcy4gKilcbmxldCBkaXNwbGF5X25ld2xpbmUgc3RhdGUgKCkgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nIFwiXFxuXCIgMCAgMVxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgc3BhY2VzLiAqKVxubGV0IGJsYW5rX2xpbmUgPSBTdHJpbmcubWFrZSA4MCAnICdcbmxldCByZWMgZGlzcGxheV9ibGFua3Mgc3RhdGUgbiA9XG4gIGlmIG4gPiAwIHRoZW5cbiAgaWYgbiA8PSA4MCB0aGVuIHN0YXRlLnBwX291dF9zdHJpbmcgYmxhbmtfbGluZSAwIG4gZWxzZVxuICBiZWdpblxuICAgIHN0YXRlLnBwX291dF9zdHJpbmcgYmxhbmtfbGluZSAwIDgwO1xuICAgIGRpc3BsYXlfYmxhbmtzIHN0YXRlIChuIC0gODApXG4gIGVuZFxuXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBpbmRlbnRhdGlvbiBvZiBuZXcgbGluZXMuICopXG5sZXQgZGlzcGxheV9pbmRlbnQgPSBkaXNwbGF5X2JsYW5rc1xuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIG91dHB1dCBmdW5jdGlvbnMgYXMgcHJpbnRpbmcgdG8gYSBnaXZlblxuICAgW1BlcnZhc2l2ZS5vdXRfY2hhbm5lbF0gdmFsdWUuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCBzdGF0ZSBvYyA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gb3V0cHV0X3N1YnN0cmluZyBvYztcbiAgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIChmdW4gKCkgLT4gZmx1c2ggb2MpO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgc3RhdGU7XG4gIHN0YXRlLnBwX291dF9zcGFjZXMgPC0gZGlzcGxheV9ibGFua3Mgc3RhdGU7XG4gIHN0YXRlLnBwX291dF9pbmRlbnQgPC0gZGlzcGxheV9pbmRlbnQgc3RhdGVcblxuKCpcblxuICBEZWZpbmluZyBzcGVjaWZpYyBmb3JtYXR0ZXJzXG5cbiopXG5cbmxldCBkZWZhdWx0X3BwX21hcmtfb3Blbl90YWcgPSBmdW5jdGlvblxuICB8IFN0cmluZ190YWcgcyAtPiBcIjxcIiBeIHMgXiBcIj5cIlxuICB8IF8gLT4gXCJcIlxubGV0IGRlZmF1bHRfcHBfbWFya19jbG9zZV90YWcgPSBmdW5jdGlvblxuICB8IFN0cmluZ190YWcgcyAtPiBcIjwvXCIgXiBzIF4gXCI+XCJcbiAgfCBfIC0+IFwiXCJcblxubGV0IGRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWcgPSBpZ25vcmVcbmxldCBkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZyA9IGlnbm9yZVxuXG4oKiBCdWlsZGluZyBhIGZvcm1hdHRlciBnaXZlbiBpdHMgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucy5cbiAgIE90aGVyIGZpZWxkcyBnZXQgcmVhc29uYWJsZSBkZWZhdWx0IHZhbHVlcy4gKilcbmxldCBwcF9tYWtlX2Zvcm1hdHRlciBmIGcgaCBpIGogPVxuICAoKiBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgZm9ybWF0dGVyIGNvbnRhaW5zIGEgZHVtbXkgYm94LiAqKVxuICBsZXQgcHBfcXVldWUgPSBRdWV1ZS5jcmVhdGUgKCkgaW5cbiAgbGV0IHN5c190b2sgPVxuICAgIHsgc2l6ZSA9IFNpemUudW5rbm93bjsgdG9rZW4gPSBQcF9iZWdpbiAoMCwgUHBfaG92Ym94KTsgbGVuZ3RoID0gMCB9IGluXG4gIFF1ZXVlLmFkZCBzeXNfdG9rIHBwX3F1ZXVlO1xuICBsZXQgc2Nhbl9zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKSBpblxuICBpbml0aWFsaXplX3NjYW5fc3RhY2sgc2Nhbl9zdGFjaztcbiAgU3RhY2sucHVzaCB7IGxlZnRfdG90YWwgPSAxOyBxdWV1ZV9lbGVtID0gc3lzX3RvayB9IHNjYW5fc3RhY2s7XG4gIGxldCBwcF9tYXJnaW4gPSA3OFxuICBhbmQgcHBfbWluX3NwYWNlX2xlZnQgPSAxMCBpblxuICB7XG4gICAgcHBfc2Nhbl9zdGFjayA9IHNjYW5fc3RhY2s7XG4gICAgcHBfZm9ybWF0X3N0YWNrID0gU3RhY2suY3JlYXRlICgpO1xuICAgIHBwX3Rib3hfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfdGFnX3N0YWNrID0gU3RhY2suY3JlYXRlICgpO1xuICAgIHBwX21hcmtfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfbWFyZ2luID0gcHBfbWFyZ2luO1xuICAgIHBwX21pbl9zcGFjZV9sZWZ0ID0gcHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfbWF4X2luZGVudCA9IHBwX21hcmdpbiAtIHBwX21pbl9zcGFjZV9sZWZ0O1xuICAgIHBwX3NwYWNlX2xlZnQgPSBwcF9tYXJnaW47XG4gICAgcHBfY3VycmVudF9pbmRlbnQgPSAwO1xuICAgIHBwX2lzX25ld19saW5lID0gdHJ1ZTtcbiAgICBwcF9sZWZ0X3RvdGFsID0gMTtcbiAgICBwcF9yaWdodF90b3RhbCA9IDE7XG4gICAgcHBfY3Vycl9kZXB0aCA9IDE7XG4gICAgcHBfbWF4X2JveGVzID0gbWF4X2ludDtcbiAgICBwcF9lbGxpcHNpcyA9IFwiLlwiO1xuICAgIHBwX291dF9zdHJpbmcgPSBmO1xuICAgIHBwX291dF9mbHVzaCA9IGc7XG4gICAgcHBfb3V0X25ld2xpbmUgPSBoO1xuICAgIHBwX291dF9zcGFjZXMgPSBpO1xuICAgIHBwX291dF9pbmRlbnQgPSBqO1xuICAgIHBwX3ByaW50X3RhZ3MgPSBmYWxzZTtcbiAgICBwcF9tYXJrX3RhZ3MgPSBmYWxzZTtcbiAgICBwcF9tYXJrX29wZW5fdGFnID0gZGVmYXVsdF9wcF9tYXJrX29wZW5fdGFnO1xuICAgIHBwX21hcmtfY2xvc2VfdGFnID0gZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZztcbiAgICBwcF9wcmludF9vcGVuX3RhZyA9IGRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWc7XG4gICAgcHBfcHJpbnRfY2xvc2VfdGFnID0gZGVmYXVsdF9wcF9wcmludF9jbG9zZV90YWc7XG4gICAgcHBfcXVldWUgPSBwcF9xdWV1ZTtcbiAgfVxuXG5cbigqIEJ1aWxkIGEgZm9ybWF0dGVyIG91dCBvZiBpdHMgb3V0IGZ1bmN0aW9ucy4gKilcbmxldCBmb3JtYXR0ZXJfb2Zfb3V0X2Z1bmN0aW9ucyBvdXRfZnVucyA9XG4gIHBwX21ha2VfZm9ybWF0dGVyXG4gICAgb3V0X2Z1bnMub3V0X3N0cmluZ1xuICAgIG91dF9mdW5zLm91dF9mbHVzaFxuICAgIG91dF9mdW5zLm91dF9uZXdsaW5lXG4gICAgb3V0X2Z1bnMub3V0X3NwYWNlc1xuICAgIG91dF9mdW5zLm91dF9pbmRlbnRcblxuXG4oKiBNYWtlIGEgZm9ybWF0dGVyIHdpdGggZGVmYXVsdCBmdW5jdGlvbnMgdG8gb3V0cHV0IHNwYWNlcyxcbiAgaW5kZW50YXRpb24sIGFuZCBuZXcgbGluZXMuICopXG5sZXQgbWFrZV9mb3JtYXR0ZXIgb3V0cHV0IGZsdXNoID1cbiAgbGV0IHBwZiA9IHBwX21ha2VfZm9ybWF0dGVyIG91dHB1dCBmbHVzaCBpZ25vcmUgaWdub3JlIGlnbm9yZSBpblxuICBwcGYucHBfb3V0X25ld2xpbmUgPC0gZGlzcGxheV9uZXdsaW5lIHBwZjtcbiAgcHBmLnBwX291dF9zcGFjZXMgPC0gZGlzcGxheV9ibGFua3MgcHBmO1xuICBwcGYucHBfb3V0X2luZGVudCA8LSBkaXNwbGF5X2luZGVudCBwcGY7XG4gIHBwZlxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd3JpdGluZyB0byBhIGdpdmVuIFtQZXJ2YXNpdmUub3V0X2NoYW5uZWxdIHZhbHVlLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCBvYyA9XG4gIG1ha2VfZm9ybWF0dGVyIChvdXRwdXRfc3Vic3RyaW5nIG9jKSAoZnVuICgpIC0+IGZsdXNoIG9jKVxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd3JpdGluZyB0byBhIGdpdmVuIFtCdWZmZXIudF0gdmFsdWUuICopXG5sZXQgZm9ybWF0dGVyX29mX2J1ZmZlciBiID1cbiAgbWFrZV9mb3JtYXR0ZXIgKEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGIpIGlnbm9yZVxuXG5cbigqIEFsbG9jYXRpbmcgYnVmZmVyIGZvciBwcmV0dHktcHJpbnRpbmcgcHVycG9zZXMuXG4gICBEZWZhdWx0IGJ1ZmZlciBzaXplIGlzIHBwX2J1ZmZlcl9zaXplIG9yIDUxMi5cbiopXG5sZXQgcHBfYnVmZmVyX3NpemUgPSA1MTJcbmxldCBwcF9tYWtlX2J1ZmZlciAoKSA9IEJ1ZmZlci5jcmVhdGUgcHBfYnVmZmVyX3NpemVcblxuKCogVGhlIHN0YW5kYXJkIChzaGFyZWQpIGJ1ZmZlci4gKilcbmxldCBzdGRidWYgPSBwcF9tYWtlX2J1ZmZlciAoKVxuXG4oKiBQcmVkZWZpbmVkIGZvcm1hdHRlcnMgc3RhbmRhcmQgZm9ybWF0dGVyIHRvIHByaW50XG4gICB0byBbU3RkbGliLnN0ZG91dF0sIFtTdGRsaWIuc3RkZXJyXSwgYW5kIHshc3RkYnVmfS4gKilcbmxldCBzdGRfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX291dF9jaGFubmVsIFN0ZGxpYi5zdGRvdXRcbmFuZCBlcnJfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX291dF9jaGFubmVsIFN0ZGxpYi5zdGRlcnJcbmFuZCBzdHJfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX2J1ZmZlciBzdGRidWZcblxuXG4oKiBbZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBidWYgcHBmXSBmbHVzaGVzIGZvcm1hdHRlciBbcHBmXSxcbiAgIHRoZW4gcmV0dXJucyB0aGUgY29udGVudHMgb2YgYnVmZmVyIFtidWZdIHRoYXQgaXMgcmVzZXQuXG4gICBGb3JtYXR0ZXIgW3BwZl0gaXMgc3VwcG9zZWQgdG8gcHJpbnQgdG8gYnVmZmVyIFtidWZdLCBvdGhlcndpc2UgdGhpc1xuICAgZnVuY3Rpb24gaXMgbm90IHJlYWxseSB1c2VmdWwuICopXG5sZXQgZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBidWYgcHBmID1cbiAgcHBfZmx1c2hfcXVldWUgcHBmIGZhbHNlO1xuICBsZXQgcyA9IEJ1ZmZlci5jb250ZW50cyBidWYgaW5cbiAgQnVmZmVyLnJlc2V0IGJ1ZjtcbiAgc1xuXG5cbigqIEZsdXNoIFtzdHJfZm9ybWF0dGVyXSBhbmQgZ2V0IHRoZSBjb250ZW50cyBvZiBbc3RkYnVmXS4gKilcbmxldCBmbHVzaF9zdHJfZm9ybWF0dGVyICgpID0gZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBzdGRidWYgc3RyX2Zvcm1hdHRlclxuXG4oKlxuICBTeW1ib2xpYyBwcmV0dHktcHJpbnRpbmdcbiopXG5cbigqXG4gIFN5bWJvbGljIHByZXR0eS1wcmludGluZyBpcyBwcmV0dHktcHJpbnRpbmcgd2l0aCBubyBsb3cgbGV2ZWwgb3V0cHV0LlxuXG4gIFdoZW4gdXNpbmcgYSBzeW1ib2xpYyBmb3JtYXR0ZXIsIGFsbCByZWd1bGFyIHByZXR0eS1wcmludGluZyBhY3Rpdml0aWVzXG4gIG9jY3VyIGJ1dCBvdXRwdXQgbWF0ZXJpYWwgaXMgc3ltYm9saWMgYW5kIHN0b3JlZCBpbiBhIGJ1ZmZlciBvZiBvdXRwdXRcbiAgaXRlbXMuIEF0IHRoZSBlbmQgb2YgcHJldHR5LXByaW50aW5nLCBmbHVzaGluZyB0aGUgb3V0cHV0IGJ1ZmZlciBhbGxvd3NcbiAgcG9zdC1wcm9jZXNzaW5nIG9mIHN5bWJvbGljIG91dHB1dCBiZWZvcmUgbG93IGxldmVsIG91dHB1dCBvcGVyYXRpb25zLlxuKilcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfaXRlbSA9XG4gIHwgT3V0cHV0X2ZsdXNoXG4gIHwgT3V0cHV0X25ld2xpbmVcbiAgfCBPdXRwdXRfc3RyaW5nIG9mIHN0cmluZ1xuICB8IE91dHB1dF9zcGFjZXMgb2YgaW50XG4gIHwgT3V0cHV0X2luZGVudCBvZiBpbnRcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfYnVmZmVyID0ge1xuICBtdXRhYmxlIHN5bWJvbGljX291dHB1dF9jb250ZW50cyA6IHN5bWJvbGljX291dHB1dF9pdGVtIGxpc3Q7XG59XG5cbmxldCBtYWtlX3N5bWJvbGljX291dHB1dF9idWZmZXIgKCkgPVxuICB7IHN5bWJvbGljX291dHB1dF9jb250ZW50cyA9IFtdIH1cblxubGV0IGNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50cyA8LSBbXVxuXG5sZXQgZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgTGlzdC5yZXYgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZmx1c2hfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBsZXQgaXRlbXMgPSBnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgaW5cbiAgY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2I7XG4gIGl0ZW1zXG5cbmxldCBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIGl0ZW0gPVxuICBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDwtIGl0ZW0gOjogc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZm9ybWF0dGVyX29mX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgbGV0IHN5bWJvbGljX2ZsdXNoIHNvYiAoKSA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiBPdXRwdXRfZmx1c2hcbiAgYW5kIHN5bWJvbGljX25ld2xpbmUgc29iICgpID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIE91dHB1dF9uZXdsaW5lXG4gIGFuZCBzeW1ib2xpY19zdHJpbmcgc29iIHMgaSBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfc3RyaW5nIChTdHJpbmcuc3ViIHMgaSBuKSlcbiAgYW5kIHN5bWJvbGljX3NwYWNlcyBzb2IgbiA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiAoT3V0cHV0X3NwYWNlcyBuKVxuICBhbmQgc3ltYm9saWNfaW5kZW50IHNvYiBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfaW5kZW50IG4pIGluXG5cbiAgbGV0IGYgPSBzeW1ib2xpY19zdHJpbmcgc29iXG4gIGFuZCBnID0gc3ltYm9saWNfZmx1c2ggc29iXG4gIGFuZCBoID0gc3ltYm9saWNfbmV3bGluZSBzb2JcbiAgYW5kIGkgPSBzeW1ib2xpY19zcGFjZXMgc29iXG4gIGFuZCBqID0gc3ltYm9saWNfaW5kZW50IHNvYiBpblxuICBwcF9tYWtlX2Zvcm1hdHRlciBmIGcgaCBpIGpcblxuKCpcblxuICBCYXNpYyBmdW5jdGlvbnMgb24gdGhlICdzdGFuZGFyZCcgZm9ybWF0dGVyXG4gICh0aGUgZm9ybWF0dGVyIHRoYXQgcHJpbnRzIHRvIFtTdGRsaWIuc3Rkb3V0XSkuXG5cbiopXG5cbmxldCBvcGVuX2hib3ggPSBwcF9vcGVuX2hib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fdmJveCA9IHBwX29wZW5fdmJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl9odmJveCA9IHBwX29wZW5faHZib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5faG92Ym94ID0gcHBfb3Blbl9ob3Zib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fYm94ID0gcHBfb3Blbl9ib3ggc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX2JveCA9IHBwX2Nsb3NlX2JveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl90YWcgPSBwcF9vcGVuX3RhZyBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2VfdGFnID0gcHBfY2xvc2VfdGFnIHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX3N0YWcgPSBwcF9vcGVuX3N0YWcgc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX3N0YWcgPSBwcF9jbG9zZV9zdGFnIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9hcyA9IHBwX3ByaW50X2FzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9zdHJpbmcgPSBwcF9wcmludF9zdHJpbmcgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2J5dGVzID0gcHBfcHJpbnRfYnl0ZXMgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2ludCA9IHBwX3ByaW50X2ludCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfZmxvYXQgPSBwcF9wcmludF9mbG9hdCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfY2hhciA9IHBwX3ByaW50X2NoYXIgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2Jvb2wgPSBwcF9wcmludF9ib29sIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9icmVhayA9IHBwX3ByaW50X2JyZWFrIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9jdXQgPSBwcF9wcmludF9jdXQgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3NwYWNlID0gcHBfcHJpbnRfc3BhY2Ugc3RkX2Zvcm1hdHRlclxuYW5kIGZvcmNlX25ld2xpbmUgPSBwcF9mb3JjZV9uZXdsaW5lIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9mbHVzaCA9IHBwX3ByaW50X2ZsdXNoIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9uZXdsaW5lID0gcHBfcHJpbnRfbmV3bGluZSBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfaWZfbmV3bGluZSA9IHBwX3ByaW50X2lmX25ld2xpbmUgc3RkX2Zvcm1hdHRlclxuXG5hbmQgb3Blbl90Ym94ID0gcHBfb3Blbl90Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBjbG9zZV90Ym94ID0gcHBfY2xvc2VfdGJveCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfdGJyZWFrID0gcHBfcHJpbnRfdGJyZWFrIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF90YWIgPSBwcF9zZXRfdGFiIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF90YWIgPSBwcF9wcmludF90YWIgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X21hcmdpbiA9IHBwX3NldF9tYXJnaW4gc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXJnaW4gPSBwcF9nZXRfbWFyZ2luIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9tYXhfaW5kZW50ID0gcHBfc2V0X21heF9pbmRlbnQgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXhfaW5kZW50ID0gcHBfZ2V0X21heF9pbmRlbnQgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2dlb21ldHJ5ID0gcHBfc2V0X2dlb21ldHJ5IHN0ZF9mb3JtYXR0ZXJcbmFuZCBzYWZlX3NldF9nZW9tZXRyeSA9IHBwX3NhZmVfc2V0X2dlb21ldHJ5IHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZ2VvbWV0cnkgPSBwcF9nZXRfZ2VvbWV0cnkgc3RkX2Zvcm1hdHRlclxuYW5kIHVwZGF0ZV9nZW9tZXRyeSA9IHBwX3VwZGF0ZV9nZW9tZXRyeSBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfbWF4X2JveGVzID0gcHBfc2V0X21heF9ib3hlcyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21heF9ib3hlcyA9IHBwX2dldF9tYXhfYm94ZXMgc3RkX2Zvcm1hdHRlclxuYW5kIG92ZXJfbWF4X2JveGVzID0gcHBfb3Zlcl9tYXhfYm94ZXMgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2VsbGlwc2lzX3RleHQgPSBwcF9zZXRfZWxsaXBzaXNfdGV4dCBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2VsbGlwc2lzX3RleHQgPSBwcF9nZXRfZWxsaXBzaXNfdGV4dCBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dF9jaGFubmVsID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF9wcmludF90YWdzID1cbiAgcHBfc2V0X3ByaW50X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9wcmludF90YWdzID1cbiAgcHBfZ2V0X3ByaW50X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF9tYXJrX3RhZ3MgPVxuICBwcF9zZXRfbWFya190YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWFya190YWdzID1cbiAgcHBfZ2V0X21hcmtfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgc2V0X3RhZ3MgPVxuICBwcF9zZXRfdGFncyBzdGRfZm9ybWF0dGVyXG5cblxuKCogQ29udmVuaWVuY2UgZnVuY3Rpb25zICopXG5cbigqIFRvIGZvcm1hdCBhIGxpc3QgKilcbmxldCByZWMgcHBfcHJpbnRfbGlzdCA/KHBwX3NlcCA9IHBwX3ByaW50X2N1dCkgcHBfdiBwcGYgPSBmdW5jdGlvblxuICB8IFtdIC0+ICgpXG4gIHwgW3ZdIC0+IHBwX3YgcHBmIHZcbiAgfCB2IDo6IHZzIC0+XG4gICAgcHBfdiBwcGYgdjtcbiAgICBwcF9zZXAgcHBmICgpO1xuICAgIHBwX3ByaW50X2xpc3QgfnBwX3NlcCBwcF92IHBwZiB2c1xuXG4oKiBUbyBmb3JtYXQgYSBzZXF1ZW5jZSAqKVxubGV0IHJlYyBwcF9wcmludF9zZXFfaW4gfnBwX3NlcCBwcF92IHBwZiBzZXEgPVxuICBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IFNlcS5OaWwgLT4gKClcbiAgfCBTZXEuQ29ucyAodiwgc2VxKSAtPlxuICAgIHBwX3NlcCBwcGYgKCk7XG4gICAgcHBfdiBwcGYgdjtcbiAgICBwcF9wcmludF9zZXFfaW4gfnBwX3NlcCBwcF92IHBwZiBzZXFcblxubGV0IHBwX3ByaW50X3NlcSA/KHBwX3NlcCA9IHBwX3ByaW50X2N1dCkgcHBfdiBwcGYgc2VxID1cbiAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBTZXEuTmlsIC0+ICgpXG4gIHwgU2VxLkNvbnMgKHYsIHNlcSkgLT5cbiAgICBwcF92IHBwZiB2O1xuICAgIHBwX3ByaW50X3NlcV9pbiB+cHBfc2VwIHBwX3YgcHBmIHNlcVxuXG4oKiBUbyBmb3JtYXQgZnJlZS1mbG93aW5nIHRleHQgKilcbmxldCBwcF9wcmludF90ZXh0IHBwZiBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgbGVmdCA9IHJlZiAwIGluXG4gIGxldCByaWdodCA9IHJlZiAwIGluXG4gIGxldCBmbHVzaCAoKSA9XG4gICAgcHBfcHJpbnRfc3RyaW5nIHBwZiAoU3RyaW5nLnN1YiBzICFsZWZ0ICghcmlnaHQgLSAhbGVmdCkpO1xuICAgIGluY3IgcmlnaHQ7IGxlZnQgOj0gIXJpZ2h0O1xuICBpblxuICB3aGlsZSAoIXJpZ2h0IDw+IGxlbikgZG9cbiAgICBtYXRjaCBzLlshcmlnaHRdIHdpdGhcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgZmx1c2ggKCk7XG4gICAgICAgIHBwX2ZvcmNlX25ld2xpbmUgcHBmICgpXG4gICAgICB8ICcgJyAtPlxuICAgICAgICBmbHVzaCAoKTsgcHBfcHJpbnRfc3BhY2UgcHBmICgpXG4gICAgICAoKiB0aGVyZSBpcyBubyBzcGVjaWZpYyBzdXBwb3J0IGZvciAnXFx0J1xuICAgICAgICAgYXMgaXQgaXMgdW5jbGVhciB3aGF0IGEgcmlnaHQgc2VtYW50aWNzIHdvdWxkIGJlICopXG4gICAgICB8IF8gLT4gaW5jciByaWdodFxuICBkb25lO1xuICBpZiAhbGVmdCA8PiBsZW4gdGhlbiBmbHVzaCAoKVxuXG5sZXQgcHBfcHJpbnRfb3B0aW9uID8obm9uZSA9IGZ1biBfICgpIC0+ICgpKSBwcF92IHBwZiA9IGZ1bmN0aW9uXG58IE5vbmUgLT4gbm9uZSBwcGYgKClcbnwgU29tZSB2IC0+IHBwX3YgcHBmIHZcblxubGV0IHBwX3ByaW50X3Jlc3VsdCB+b2sgfmVycm9yIHBwZiA9IGZ1bmN0aW9uXG58IE9rIHYgLT4gb2sgcHBmIHZcbnwgRXJyb3IgZSAtPiBlcnJvciBwcGYgZVxuXG5sZXQgcHBfcHJpbnRfZWl0aGVyIH5sZWZ0IH5yaWdodCBwcGYgPSBmdW5jdGlvblxufCBFaXRoZXIuTGVmdCBsIC0+IGxlZnQgcHBmIGxcbnwgRWl0aGVyLlJpZ2h0IHIgLT4gcmlnaHQgcHBmIHJcblxuICgqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGNvbXB1dGVfdGFnIG91dHB1dCB0YWdfYWNjID1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMTYgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYnVmIGluXG4gIG91dHB1dCBwcGYgdGFnX2FjYztcbiAgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICBsZXQgbGVuID0gQnVmZmVyLmxlbmd0aCBidWYgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIEJ1ZmZlci5jb250ZW50cyBidWZcbiAgZWxzZSBCdWZmZXIuc3ViIGJ1ZiAxIChsZW4gLSAyKVxuXG4gKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgRGVmaW5pbmcgY29udGludWF0aW9ucyB0byBiZSBwYXNzZWQgYXMgYXJndW1lbnRzIG9mXG4gIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi5cblxuICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbigqIEludGVycHJldCBhIGZvcm1hdHRpbmcgZW50aXR5IG9uIGEgZm9ybWF0dGVyLiAqKVxubGV0IG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZm10aW5nX2xpdCA9IG1hdGNoIGZtdGluZ19saXQgd2l0aFxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2VfYm94IHBwZiAoKVxuICB8IENsb3NlX3RhZyAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2VfdGFnIHBwZiAoKVxuICB8IEJyZWFrIChfLCB3aWR0aCwgb2Zmc2V0KSAgLT4gcHBfcHJpbnRfYnJlYWsgcHBmIHdpZHRoIG9mZnNldFxuICB8IEZGbHVzaCAgICAgICAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfZmx1c2ggcHBmICgpXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgICAgICAtPiBwcF9mb3JjZV9uZXdsaW5lIHBwZiAoKVxuICB8IEZsdXNoX25ld2xpbmUgICAgICAgICAgICAgLT4gcHBfcHJpbnRfbmV3bGluZSBwcGYgKClcbiAgfCBNYWdpY19zaXplIChfLCBfKSAgICAgICAgIC0+ICgpXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnQCdcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICclJ1xuICB8IFNjYW5faW5kaWMgYyAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJ0AnOyBwcF9wcmludF9jaGFyIHBwZiBjXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYW4gb3V0cHV0X3N0cmVhbS4gKilcbigqIERpZmZlciBmcm9tIFByaW50Zi5vdXRwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiBmb3JtYXR0aW5nLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuICopXG5sZXQgcmVjIG91dHB1dF9hY2MgcHBmIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgKFN0cmluZy5tYWtlIDEgYyk7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9vcGVuX3N0YWcgcHBmIChTdHJpbmdfdGFnIChjb21wdXRlX3RhZyBvdXRwdXRfYWNjIGFjYycpKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBsZXQgKGluZGVudCwgYnR5KSA9IG9wZW5fYm94X29mX3N0cmluZyAoY29tcHV0ZV90YWcgb3V0cHV0X2FjYyBhY2MnKSBpblxuICAgIHBwX29wZW5fYm94X2dlbiBwcGYgaW5kZW50IGJ0eVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2NoYXIgcHBmIGM7XG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IGYgcHBmO1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IG91dHB1dF9hY2MgcHBmIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIERpZmZlciBmcm9tIFByaW50Zi5idWZwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiBmb3JtYXR0aW5nLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuICopXG5sZXQgcmVjIHN0cnB1dF9hY2MgcHBmIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgKFN0cmluZy5tYWtlIDEgYyk7XG4gIHwgQWNjX2RlbGF5IChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgZikgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSAoZiAoKSk7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9vcGVuX3N0YWcgcHBmIChTdHJpbmdfdGFnIChjb21wdXRlX3RhZyBzdHJwdXRfYWNjIGFjYycpKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBsZXQgKGluZGVudCwgYnR5KSA9IG9wZW5fYm94X29mX3N0cmluZyAoY29tcHV0ZV90YWcgc3RycHV0X2FjYyBhY2MnKSBpblxuICAgIHBwX29wZW5fYm94X2dlbiBwcGYgaW5kZW50IGJ0eVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2NoYXIgcHBmIGM7XG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X3N0cmluZyBwcGYgKGYgKCkpO1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IHN0cnB1dF9hY2MgcHBmIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCpcblxuICBEZWZpbmluZyBbZnByaW50Zl0gYW5kIHZhcmlvdXMgZmxhdm9ycyBvZiBbZnByaW50Zl0uXG5cbiopXG5cbmxldCBrZnByaW50ZiBrIHBwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmXG4gICAgKGZ1biBhY2MgLT4gb3V0cHV0X2FjYyBwcGYgYWNjOyBrIHBwZilcbiAgICBFbmRfb2ZfYWNjIGZtdFxuXG5hbmQgaWtmcHJpbnRmIGsgcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9pcHJpbnRmIGsgcHBmIGZtdFxuXG5sZXQgaWZwcmludGYgX3BwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBpZ25vcmUgKCkgZm10XG5cbmxldCBmcHJpbnRmIHBwZiA9IGtmcHJpbnRmIGlnbm9yZSBwcGZcbmxldCBwcmludGYgZm10ID0gZnByaW50ZiBzdGRfZm9ybWF0dGVyIGZtdFxubGV0IGVwcmludGYgZm10ID0gZnByaW50ZiBlcnJfZm9ybWF0dGVyIGZtdFxuXG5sZXQga2RwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmXG4gICAgKGZ1biBhY2MgLT4gayAoZnVuIHBwZiAtPiBvdXRwdXRfYWNjIHBwZiBhY2MpKVxuICAgIEVuZF9vZl9hY2MgZm10XG5cbmxldCBkcHJpbnRmIGZtdCA9IGtkcHJpbnRmIChmdW4gaSAtPiBpKSBmbXRcblxubGV0IGtzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYiA9IHBwX21ha2VfYnVmZmVyICgpIGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgbGV0IGsgYWNjID1cbiAgICBzdHJwdXRfYWNjIHBwZiBhY2M7XG4gICAgayAoZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBiIHBwZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG5cbmxldCBzcHJpbnRmIGZtdCA9IGtzcHJpbnRmIGlkIGZtdFxuXG5sZXQga2FzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYiA9IHBwX21ha2VfYnVmZmVyICgpIGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgbGV0IGsgYWNjID1cbiAgICBvdXRwdXRfYWNjIHBwZiBhY2M7XG4gICAgayAoZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBiIHBwZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG5cbmxldCBhc3ByaW50ZiBmbXQgPSBrYXNwcmludGYgaWQgZm10XG5cbigqIEZsdXNoaW5nIHN0YW5kYXJkIGZvcm1hdHRlcnMgYXQgZW5kIG9mIGV4ZWN1dGlvbi4gKilcblxubGV0IGZsdXNoX3N0YW5kYXJkX2Zvcm1hdHRlcnMgKCkgPVxuICBwcF9wcmludF9mbHVzaCBzdGRfZm9ybWF0dGVyICgpO1xuICBwcF9wcmludF9mbHVzaCBlcnJfZm9ybWF0dGVyICgpXG5cbmxldCAoKSA9IGF0X2V4aXQgZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVyc1xuXG4oKlxuXG4gIERlcHJlY2F0ZWQgc3R1ZmYuXG5cbiopXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBwcF9zZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlXG4gICAgfm91dDpmIH5mbHVzaDpnIH5uZXdsaW5lOmggfnNwYWNlczppID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlIGYgZztcbiAgc3RhdGUucHBfb3V0X25ld2xpbmUgPC0gaDtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBpXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBwcF9nZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlICgpID1cbiAgKHN0YXRlLnBwX291dF9zdHJpbmcsIHN0YXRlLnBwX291dF9mbHVzaCxcbiAgIHN0YXRlLnBwX291dF9uZXdsaW5lLCBzdGF0ZS5wcF9vdXRfc3BhY2VzKVxuXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBzZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBzZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IGdldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IGdldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9nZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuXG4oKiBEZXByZWNhdGVkIDogZXJyb3IgcHJvbmUgZnVuY3Rpb24sIGRvIG5vdCB1c2UgaXQuXG4gICBUaGlzIGZ1bmN0aW9uIGlzIG5laXRoZXIgY29tcG9zaXRpb25hbCBub3IgaW5jcmVtZW50YWwsIHNpbmNlIGl0IGZsdXNoZXNcbiAgIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBhdCBlYWNoIGNhbGwuXG4gICBUbyBnZXQgdGhlIHNhbWUgZnVuY3Rpb25hbGl0eSwgZGVmaW5lIGEgZm9ybWF0dGVyIG9mIHlvdXIgb3duIHdyaXRpbmcgdG9cbiAgIHRoZSBidWZmZXIgYXJndW1lbnQsIGFzIGluXG4gICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiXG4gICB0aGVuIHVzZSB7IWZwcmludGYgcHBmfSBhcyB1c3VhbC4gKilcbmxldCBicHJpbnRmIGIgKEZvcm1hdCAoZm10LCBfKSA6ICgnYSwgZm9ybWF0dGVyLCB1bml0KSBmb3JtYXQpID1cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayBhY2MgPSBvdXRwdXRfYWNjIHBwZiBhY2M7IHBwX2ZsdXNoX3F1ZXVlIHBwZiBmYWxzZSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cblxuKCogRGVwcmVjYXRlZCA6IGFsaWFzIGZvciBrc3ByaW50Zi4gKilcbmxldCBrcHJpbnRmID0ga3NwcmludGZcblxuXG5cbigqIERlcHJlY2F0ZWQgdGFnIGZ1bmN0aW9ucyAqKVxuXG50eXBlIGZvcm1hdHRlcl90YWdfZnVuY3Rpb25zID0ge1xuICBtYXJrX29wZW5fdGFnIDogdGFnIC0+IHN0cmluZztcbiAgbWFya19jbG9zZV90YWcgOiB0YWcgLT4gc3RyaW5nO1xuICBwcmludF9vcGVuX3RhZyA6IHRhZyAtPiB1bml0O1xuICBwcmludF9jbG9zZV90YWcgOiB0YWcgLT4gdW5pdDtcbn1cblxuXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgbWFya19vcGVuX3RhZyA9IG1vdDtcbiAgICAgbWFya19jbG9zZV90YWcgPSBtY3Q7XG4gICAgIHByaW50X29wZW5fdGFnID0gcG90O1xuICAgICBwcmludF9jbG9zZV90YWcgPSBwY3Q7XG4gICB9ID1cbiAgbGV0IHN0cmluZ2lmeSBmIGUgPSBmdW5jdGlvbiBTdHJpbmdfdGFnIHMgLT4gZiBzIHwgXyAtPiBlIGluXG4gIHN0YXRlLnBwX21hcmtfb3Blbl90YWcgPC0gc3RyaW5naWZ5IG1vdCBcIlwiO1xuICBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZyA8LSBzdHJpbmdpZnkgbWN0IFwiXCI7XG4gIHN0YXRlLnBwX3ByaW50X29wZW5fdGFnIDwtIHN0cmluZ2lmeSBwb3QgKCk7XG4gIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyA8LSBzdHJpbmdpZnkgcGN0ICgpXG5cbmxldCBwcF9nZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgZm10ICgpID1cbiAgbGV0IGZ1bnMgPSBwcF9nZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIGZtdCAoKSBpblxuICBsZXQgbWFya19vcGVuX3RhZyBzID0gZnVucy5tYXJrX29wZW5fc3RhZyAoU3RyaW5nX3RhZyBzKSBpblxuICBsZXQgbWFya19jbG9zZV90YWcgcyA9IGZ1bnMubWFya19jbG9zZV9zdGFnIChTdHJpbmdfdGFnIHMpIGluXG4gIGxldCBwcmludF9vcGVuX3RhZyBzID0gZnVucy5wcmludF9vcGVuX3N0YWcgKFN0cmluZ190YWcgcykgaW5cbiAgbGV0IHByaW50X2Nsb3NlX3RhZyBzID0gZnVucy5wcmludF9jbG9zZV9zdGFnIChTdHJpbmdfdGFnIHMpIGluXG4gIHttYXJrX29wZW5fdGFnOyBtYXJrX2Nsb3NlX3RhZzsgcHJpbnRfb3Blbl90YWc7IHByaW50X2Nsb3NlX3RhZ31cblxubGV0IHNldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbiIsIigqKiBWZXJ5IHNtYWxsIHRvb2xpbmcgZm9yIGZvcm1hdCBwcmludGVycy4gKilcblxuaW5jbHVkZSBGb3JtYXRcblxudHlwZSAnYSB0ID0gRm9ybWF0LmZvcm1hdHRlciAtPiAnYSAtPiB1bml0XG5cbmxldCBsaXN0ID0gcHBfcHJpbnRfbGlzdFxubGV0IHN0ciA9IHBwX3ByaW50X3N0cmluZ1xubGV0IHNleHAgZm10IHMgcHAgeCA9IGZwcmludGYgZm10IFwiQFs8Mz4oJXNAICVhKUBdXCIgcyBwcCB4XG5sZXQgcGFpciBwcDEgcHAyIGZtdCAodjEsdjIpID1cbiAgcHAxIGZtdCB2MTsgcHBfcHJpbnRfc3BhY2UgZm10ICgpIDsgcHAyIGZtdCB2MlxubGV0IHRyaXBsZSBwcDEgcHAyIHBwMyBmbXQgKHYxLCB2MiwgdjMpID1cbiAgcHAxIGZtdCB2MTsgcHBfcHJpbnRfc3BhY2UgZm10ICgpIDtcbiAgcHAyIGZtdCB2MjsgcHBfcHJpbnRfc3BhY2UgZm10ICgpIDtcbiAgcHAzIGZtdCB2M1xubGV0IGludCA9IHBwX3ByaW50X2ludFxubGV0IG9wdGludCBmbXQgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIGkgLT4gZnByaW50ZiBmbXQgXCJAICVkXCIgaVxuXG5sZXQgcXVvdGUgZm10IHMgPSBGb3JtYXQuZnByaW50ZiBmbXQgXCJcXFwiJXNcXFwiXCIgc1xuXG5sZXQgcHBfb2xpc3QgcHBfZWxlbSBmbXQgPVxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJAWzwzPltAICVhQCBdQF1cIlxuICAgIChwcF9wcmludF9saXN0XG4gICAgICAgfnBwX3NlcDooZnVuIGZtdCAoKSAtPiBmcHJpbnRmIGZtdCBcIjtAIFwiKVxuICAgICAgIHBwX2VsZW0pXG5cbmxldCBwcF9zdHJfbGlzdCA9IHBwX29saXN0IHF1b3RlXG5cbmxldCB0b190b19zdHJpbmcgcHAgeCA9XG4gIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAxNiBpblxuICBsZXQgZm10ID0gRm9ybWF0LmZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBwcCBmbXQgeDtcbiAgQnVmZmVyLmNvbnRlbnRzIGJcbiIsIlxubW9kdWxlIFBtYXJrID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuICBsZXQgZXF1YWwgKHggOiBpbnQpICh5IDogaW50KSA9IHggPSB5XG4gIGxldCBjb21wYXJlICh4IDogaW50KSAoeSA6IGludCkgPSBjb21wYXJlIHggeVxuICBsZXQgciA9IHJlZiAwXG4gIGxldCBnZW4gKCkgPSBpbmNyIHIgOyAhclxuXG4gIGxldCBwcCA9IEZvcm1hdC5wcF9wcmludF9pbnRcbmVuZFxuXG5pbmNsdWRlIFBtYXJrXG5tb2R1bGUgU2V0ID0gU2V0Lk1ha2UoUG1hcmspXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBQaWVycmUgV2VpcywgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdFxuXG4oKiBhbGlhcyB0byBhdm9pZCB3YXJuaW5nIGZvciBhbWJpZ3VpdHkgYmV0d2VlblxuICAgU3RkbGliLmZvcm1hdDZcbiAgIGFuZCBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NlxuXG4gICAodGhlIGZvcm1lciBpcyBpbiBmYWN0IGFuIGFsaWFzIGZvciB0aGUgbGF0dGVyLFxuICAgIGJ1dCB0aGUgYW1iaWd1aXR5IHdhcm5pbmcgZG9lc24ndCBjYXJlKVxuKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPVxuICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgU3RkbGliLmZvcm1hdDZcblxuXG4oKiBUaGUgcnVuLXRpbWUgbGlicmFyeSBmb3Igc2Nhbm5lcnMuICopXG5cbigqIFNjYW5uaW5nIGJ1ZmZlcnMuICopXG5tb2R1bGUgdHlwZSBTQ0FOTklORyA9IHNpZ1xuXG4gIHR5cGUgaW5fY2hhbm5lbFxuXG4gIHR5cGUgc2NhbmJ1ZiA9IGluX2NoYW5uZWxcblxuICB0eXBlIGZpbGVfbmFtZSA9IHN0cmluZ1xuXG4gIHZhbCBzdGRpbiA6IGluX2NoYW5uZWxcbiAgKCogVGhlIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGZyb20gW1N0ZGxpYi5zdGRpbl0uXG4gICAgIFtzdGRpYl0gaXMgZXF1aXZhbGVudCB0byBbU2Nhbm5pbmcuZnJvbV9jaGFubmVsIFN0ZGxpYi5zdGRpbl0uICopXG5cbiAgdmFsIHN0ZGliIDogaW5fY2hhbm5lbFxuICAoKiBBbiBhbGlhcyBmb3IgW1NjYW5mLnN0ZGluXSwgdGhlIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGZyb21cbiAgICAgW1N0ZGxpYi5zdGRpbl0uICopXG5cbiAgdmFsIG5leHRfY2hhciA6IHNjYW5idWYgLT4gY2hhclxuICAoKiBbU2Nhbm5pbmcubmV4dF9jaGFyIGliXSBhZHZhbmNlIHRoZSBzY2FubmluZyBidWZmZXIgZm9yXG4gICAgIG9uZSBjaGFyYWN0ZXIuXG4gICAgIElmIG5vIG1vcmUgY2hhcmFjdGVyIGNhbiBiZSByZWFkLCBzZXRzIGEgZW5kIG9mIGZpbGUgY29uZGl0aW9uIGFuZFxuICAgICByZXR1cm5zICdcXDAwMCcuICopXG5cbiAgdmFsIGludmFsaWRhdGVfY3VycmVudF9jaGFyIDogc2NhbmJ1ZiAtPiB1bml0XG4gICgqIFtTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYl0gbWFyayB0aGUgY3VycmVudF9jaGFyIGFzIGFscmVhZHlcbiAgICAgc2Nhbm5lZC4gKilcblxuICB2YWwgcGVla19jaGFyIDogc2NhbmJ1ZiAtPiBjaGFyXG4gICgqIFtTY2FubmluZy5wZWVrX2NoYXIgaWJdIHJldHVybnMgdGhlIGN1cnJlbnQgY2hhciBhdmFpbGFibGUgaW5cbiAgICAgdGhlIGJ1ZmZlciBvciByZWFkcyBvbmUgaWYgbmVjZXNzYXJ5ICh3aGVuIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpc1xuICAgICBhbHJlYWR5IHNjYW5uZWQpLlxuICAgICBJZiBubyBjaGFyYWN0ZXIgY2FuIGJlIHJlYWQsIHNldHMgYW4gZW5kIG9mIGZpbGUgY29uZGl0aW9uIGFuZFxuICAgICByZXR1cm5zICdcXDAwMCcuICopXG5cbiAgdmFsIGNoZWNrZWRfcGVla19jaGFyIDogc2NhbmJ1ZiAtPiBjaGFyXG4gICgqIFNhbWUgYXMgW1NjYW5uaW5nLnBlZWtfY2hhcl0gYWJvdmUgYnV0IGFsd2F5cyByZXR1cm5zIGEgdmFsaWQgY2hhciBvclxuICAgICBmYWlsczogaW5zdGVhZCBvZiByZXR1cm5pbmcgYSBudWxsIGNoYXIgd2hlbiB0aGUgcmVhZGluZyBtZXRob2Qgb2YgdGhlXG4gICAgIGlucHV0IGJ1ZmZlciBoYXMgcmVhY2hlZCBhbiBlbmQgb2YgZmlsZSwgdGhlIGZ1bmN0aW9uIHJhaXNlcyBleGNlcHRpb25cbiAgICAgW0VuZF9vZl9maWxlXS4gKilcblxuICB2YWwgc3RvcmVfY2hhciA6IGludCAtPiBzY2FuYnVmIC0+IGNoYXIgLT4gaW50XG4gICgqIFtTY2FubmluZy5zdG9yZV9jaGFyIGxpbSBpYiBjXSBhZGRzIFtjXSB0byB0aGUgdG9rZW4gYnVmZmVyXG4gICAgIG9mIHRoZSBzY2FubmluZyBidWZmZXIgW2liXS4gSXQgYWxzbyBhZHZhbmNlcyB0aGUgc2Nhbm5pbmcgYnVmZmVyIGZvclxuICAgICBvbmUgY2hhcmFjdGVyIGFuZCByZXR1cm5zIFtsaW0gLSAxXSwgaW5kaWNhdGluZyB0aGUgbmV3IGxpbWl0IGZvciB0aGVcbiAgICAgbGVuZ3RoIG9mIHRoZSBjdXJyZW50IHRva2VuLiAqKVxuXG4gIHZhbCBza2lwX2NoYXIgOiBpbnQgLT4gc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnNraXBfY2hhciBsaW0gaWJdIGlnbm9yZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLiAqKVxuXG4gIHZhbCBpZ25vcmVfY2hhciA6IGludCAtPiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuaWdub3JlX2NoYXIgaWIgbGltXSBpZ25vcmVzIHRoZSBjdXJyZW50IGNoYXJhY3RlciBhbmRcbiAgICAgZGVjcmVtZW50cyB0aGUgbGltaXQuICopXG5cbiAgdmFsIHRva2VuIDogc2NhbmJ1ZiAtPiBzdHJpbmdcbiAgKCogW1NjYW5uaW5nLnRva2VuIGliXSByZXR1cm5zIHRoZSBzdHJpbmcgc3RvcmVkIGludG8gdGhlIHRva2VuXG4gICAgIGJ1ZmZlciBvZiB0aGUgc2Nhbm5pbmcgYnVmZmVyOiBpdCByZXR1cm5zIHRoZSB0b2tlbiBtYXRjaGVkIGJ5IHRoZVxuICAgICBmb3JtYXQuICopXG5cbiAgdmFsIHJlc2V0X3Rva2VuIDogc2NhbmJ1ZiAtPiB1bml0XG4gICgqIFtTY2FubmluZy5yZXNldF90b2tlbiBpYl0gcmVzZXRzIHRoZSB0b2tlbiBidWZmZXIgb2ZcbiAgICAgdGhlIGdpdmVuIHNjYW5uaW5nIGJ1ZmZlci4gKilcblxuICB2YWwgY2hhcl9jb3VudCA6IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5jaGFyX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVyc1xuICAgICByZWFkIHNvIGZhciBmcm9tIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIGxpbmVfY291bnQgOiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcubGluZV9jb3VudCBpYl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIG5ldyBsaW5lXG4gICAgIGNoYXJhY3RlcnMgcmVhZCBzbyBmYXIgZnJvbSB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCB0b2tlbl9jb3VudCA6IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy50b2tlbl9jb3VudCBpYl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIHRva2VucyByZWFkXG4gICAgIHNvIGZhciBmcm9tIFtpYl0uICopXG5cbiAgdmFsIGVvZiA6IHNjYW5idWYgLT4gYm9vbFxuICAoKiBbU2Nhbm5pbmcuZW9mIGliXSByZXR1cm5zIHRoZSBlbmQgb2YgaW5wdXQgY29uZGl0aW9uXG4gICAgIG9mIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIGVuZF9vZl9pbnB1dCA6IHNjYW5idWYgLT4gYm9vbFxuICAoKiBbU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliXSB0ZXN0cyB0aGUgZW5kIG9mIGlucHV0IGNvbmRpdGlvblxuICAgICBvZiB0aGUgZ2l2ZW4gYnVmZmVyIChpZiBubyBjaGFyIGhhcyBldmVyIGJlZW4gcmVhZCwgYW4gYXR0ZW1wdCB0b1xuICAgICByZWFkIG9uZSBpcyBwZXJmb3JtZWQpLiAqKVxuXG4gIHZhbCBiZWdpbm5pbmdfb2ZfaW5wdXQgOiBzY2FuYnVmIC0+IGJvb2xcbiAgKCogW1NjYW5uaW5nLmJlZ2lubmluZ19vZl9pbnB1dCBpYl0gdGVzdHMgdGhlIGJlZ2lubmluZyBvZiBpbnB1dFxuICAgICBjb25kaXRpb24gb2YgdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgbmFtZV9vZl9pbnB1dCA6IHNjYW5idWYgLT4gc3RyaW5nXG4gICgqIFtTY2FubmluZy5uYW1lX29mX2lucHV0IGliXSByZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBjaGFyYWN0ZXJcbiAgICAgc291cmNlIGZvciBpbnB1dCBidWZmZXIgW2liXS4gKilcblxuICB2YWwgb3Blbl9pbiA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBvcGVuX2luX2JpbiA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2ZpbGUgOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9maWxlX2JpbiA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX3N0cmluZyA6IHN0cmluZyAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2Z1bmN0aW9uIDogKHVuaXQgLT4gY2hhcikgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9jaGFubmVsIDogU3RkbGliLmluX2NoYW5uZWwgLT4gaW5fY2hhbm5lbFxuXG4gIHZhbCBjbG9zZV9pbiA6IGluX2NoYW5uZWwgLT4gdW5pdFxuXG4gIHZhbCBtZW1vX2Zyb21fY2hhbm5lbCA6IFN0ZGxpYi5pbl9jaGFubmVsIC0+IGluX2NoYW5uZWxcbiAgKCogT2Jzb2xldGUuICopXG5cbmVuZFxuXG5cbm1vZHVsZSBTY2FubmluZyA6IFNDQU5OSU5HID0gc3RydWN0XG5cbiAgKCogVGhlIHJ1bi10aW1lIGxpYnJhcnkgZm9yIHNjYW5mLiAqKVxuXG4gIHR5cGUgZmlsZV9uYW1lID0gc3RyaW5nXG5cbiAgdHlwZSBpbl9jaGFubmVsX25hbWUgPVxuICAgIHwgRnJvbV9jaGFubmVsIG9mIFN0ZGxpYi5pbl9jaGFubmVsXG4gICAgfCBGcm9tX2ZpbGUgb2YgZmlsZV9uYW1lICogU3RkbGliLmluX2NoYW5uZWxcbiAgICB8IEZyb21fZnVuY3Rpb25cbiAgICB8IEZyb21fc3RyaW5nXG5cblxuICB0eXBlIGluX2NoYW5uZWwgPSB7XG4gICAgbXV0YWJsZSBpY19lb2YgOiBib29sO1xuICAgIG11dGFibGUgaWNfY3VycmVudF9jaGFyIDogY2hhcjtcbiAgICBtdXRhYmxlIGljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA6IGJvb2w7XG4gICAgbXV0YWJsZSBpY19jaGFyX2NvdW50IDogaW50O1xuICAgIG11dGFibGUgaWNfbGluZV9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGljX3Rva2VuX2NvdW50IDogaW50O1xuICAgIGljX2dldF9uZXh0X2NoYXIgOiB1bml0IC0+IGNoYXI7XG4gICAgaWNfdG9rZW5fYnVmZmVyIDogQnVmZmVyLnQ7XG4gICAgaWNfaW5wdXRfbmFtZSA6IGluX2NoYW5uZWxfbmFtZTtcbiAgfVxuXG5cbiAgdHlwZSBzY2FuYnVmID0gaW5fY2hhbm5lbFxuXG4gIGxldCBudWxsX2NoYXIgPSAnXFwwMDAnXG5cbiAgKCogUmVhZHMgYSBuZXcgY2hhcmFjdGVyIGZyb20gaW5wdXQgYnVmZmVyLlxuICAgICBOZXh0X2NoYXIgbmV2ZXIgZmFpbHMsIGV2ZW4gaW4gY2FzZSBvZiBlbmQgb2YgaW5wdXQ6XG4gICAgIGl0IHRoZW4gc2ltcGx5IHNldHMgdGhlIGVuZCBvZiBmaWxlIGNvbmRpdGlvbi4gKilcbiAgbGV0IG5leHRfY2hhciBpYiA9XG4gICAgdHJ5XG4gICAgICBsZXQgYyA9IGliLmljX2dldF9uZXh0X2NoYXIgKCkgaW5cbiAgICAgIGliLmljX2N1cnJlbnRfY2hhciA8LSBjO1xuICAgICAgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDwtIHRydWU7XG4gICAgICBpYi5pY19jaGFyX2NvdW50IDwtIHN1Y2MgaWIuaWNfY2hhcl9jb3VudDtcbiAgICAgIGlmIGMgPSAnXFxuJyB0aGVuIGliLmljX2xpbmVfY291bnQgPC0gc3VjYyBpYi5pY19saW5lX2NvdW50O1xuICAgICAgYyB3aXRoXG4gICAgfCBFbmRfb2ZfZmlsZSAtPlxuICAgICAgbGV0IGMgPSBudWxsX2NoYXIgaW5cbiAgICAgIGliLmljX2N1cnJlbnRfY2hhciA8LSBjO1xuICAgICAgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDwtIGZhbHNlO1xuICAgICAgaWIuaWNfZW9mIDwtIHRydWU7XG4gICAgICBjXG5cblxuICBsZXQgcGVla19jaGFyIGliID1cbiAgICBpZiBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWRcbiAgICB0aGVuIGliLmljX2N1cnJlbnRfY2hhclxuICAgIGVsc2UgbmV4dF9jaGFyIGliXG5cblxuICAoKiBSZXR1cm5zIGEgdmFsaWQgY3VycmVudCBjaGFyIGZvciB0aGUgaW5wdXQgYnVmZmVyLiBJbiBwYXJ0aWN1bGFyXG4gICAgIG5vIGlycmVsZXZhbnQgbnVsbCBjaGFyYWN0ZXIgKGFzIHNldCBieSBbbmV4dF9jaGFyXSBpbiBjYXNlIG9mIGVuZFxuICAgICBvZiBpbnB1dCkgaXMgcmV0dXJuZWQsIHNpbmNlIFtFbmRfb2ZfZmlsZV0gaXMgcmFpc2VkIHdoZW5cbiAgICAgW25leHRfY2hhcl0gc2V0cyB0aGUgZW5kIG9mIGZpbGUgY29uZGl0aW9uIHdoaWxlIHRyeWluZyB0byByZWFkIGFcbiAgICAgbmV3IGNoYXJhY3Rlci4gKilcbiAgbGV0IGNoZWNrZWRfcGVla19jaGFyIGliID1cbiAgICBsZXQgYyA9IHBlZWtfY2hhciBpYiBpblxuICAgIGlmIGliLmljX2VvZiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlO1xuICAgIGNcblxuXG4gIGxldCBlbmRfb2ZfaW5wdXQgaWIgPVxuICAgIGlnbm9yZSAocGVla19jaGFyIGliKTtcbiAgICBpYi5pY19lb2ZcblxuXG4gIGxldCBlb2YgaWIgPSBpYi5pY19lb2ZcblxuICBsZXQgYmVnaW5uaW5nX29mX2lucHV0IGliID0gaWIuaWNfY2hhcl9jb3VudCA9IDBcblxuICBsZXQgbmFtZV9vZl9pbnB1dCBpYiA9XG4gICAgbWF0Y2ggaWIuaWNfaW5wdXRfbmFtZSB3aXRoXG4gICAgfCBGcm9tX2NoYW5uZWwgX2ljIC0+IFwidW5uYW1lZCBTdGRsaWIgaW5wdXQgY2hhbm5lbFwiXG4gICAgfCBGcm9tX2ZpbGUgKGZuYW1lLCBfaWMpIC0+IGZuYW1lXG4gICAgfCBGcm9tX2Z1bmN0aW9uIC0+IFwidW5uYW1lZCBmdW5jdGlvblwiXG4gICAgfCBGcm9tX3N0cmluZyAtPiBcInVubmFtZWQgY2hhcmFjdGVyIHN0cmluZ1wiXG5cblxuICBsZXQgY2hhcl9jb3VudCBpYiA9XG4gICAgaWYgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkXG4gICAgdGhlbiBpYi5pY19jaGFyX2NvdW50IC0gMVxuICAgIGVsc2UgaWIuaWNfY2hhcl9jb3VudFxuXG5cbiAgbGV0IGxpbmVfY291bnQgaWIgPSBpYi5pY19saW5lX2NvdW50XG5cbiAgbGV0IHJlc2V0X3Rva2VuIGliID0gQnVmZmVyLnJlc2V0IGliLmljX3Rva2VuX2J1ZmZlclxuXG4gIGxldCBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYiA9IGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA8LSBmYWxzZVxuXG4gIGxldCB0b2tlbiBpYiA9XG4gICAgbGV0IHRva2VuX2J1ZmZlciA9IGliLmljX3Rva2VuX2J1ZmZlciBpblxuICAgIGxldCB0b2sgPSBCdWZmZXIuY29udGVudHMgdG9rZW5fYnVmZmVyIGluXG4gICAgQnVmZmVyLmNsZWFyIHRva2VuX2J1ZmZlcjtcbiAgICBpYi5pY190b2tlbl9jb3VudCA8LSBzdWNjIGliLmljX3Rva2VuX2NvdW50O1xuICAgIHRva1xuXG5cbiAgbGV0IHRva2VuX2NvdW50IGliID0gaWIuaWNfdG9rZW5fY291bnRcblxuICBsZXQgc2tpcF9jaGFyIHdpZHRoIGliID1cbiAgICBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjtcbiAgICB3aWR0aFxuXG5cbiAgbGV0IGlnbm9yZV9jaGFyIHdpZHRoIGliID0gc2tpcF9jaGFyICh3aWR0aCAtIDEpIGliXG5cbiAgbGV0IHN0b3JlX2NoYXIgd2lkdGggaWIgYyA9XG4gICAgQnVmZmVyLmFkZF9jaGFyIGliLmljX3Rva2VuX2J1ZmZlciBjO1xuICAgIGlnbm9yZV9jaGFyIHdpZHRoIGliXG5cblxuICBsZXQgZGVmYXVsdF90b2tlbl9idWZmZXJfc2l6ZSA9IDEwMjRcblxuICBsZXQgY3JlYXRlIGluYW1lIG5leHQgPSB7XG4gICAgaWNfZW9mID0gZmFsc2U7XG4gICAgaWNfY3VycmVudF9jaGFyID0gbnVsbF9jaGFyO1xuICAgIGljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA9IGZhbHNlO1xuICAgIGljX2NoYXJfY291bnQgPSAwO1xuICAgIGljX2xpbmVfY291bnQgPSAwO1xuICAgIGljX3Rva2VuX2NvdW50ID0gMDtcbiAgICBpY19nZXRfbmV4dF9jaGFyID0gbmV4dDtcbiAgICBpY190b2tlbl9idWZmZXIgPSBCdWZmZXIuY3JlYXRlIGRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemU7XG4gICAgaWNfaW5wdXRfbmFtZSA9IGluYW1lO1xuICB9XG5cblxuICBsZXQgZnJvbV9zdHJpbmcgcyA9XG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICBsZXQgbmV4dCAoKSA9XG4gICAgICBpZiAhaSA+PSBsZW4gdGhlbiByYWlzZSBFbmRfb2ZfZmlsZSBlbHNlXG4gICAgICBsZXQgYyA9IHMuWyFpXSBpblxuICAgICAgaW5jciBpO1xuICAgICAgYyBpblxuICAgIGNyZWF0ZSBGcm9tX3N0cmluZyBuZXh0XG5cblxuICBsZXQgZnJvbV9mdW5jdGlvbiA9IGNyZWF0ZSBGcm9tX2Z1bmN0aW9uXG5cbiAgKCogU2Nhbm5pbmcgZnJvbSBhbiBpbnB1dCBjaGFubmVsLiAqKVxuXG4gICgqIFBvc2l0aW9uIG9mIHRoZSBwcm9ibGVtOlxuXG4gICAgIFdlIGNhbm5vdCBwcmV2ZW50IHRoZSBzY2FubmluZyBtZWNoYW5pc20gdG8gdXNlIG9uZSBsb29rYWhlYWQgY2hhcmFjdGVyLFxuICAgICBpZiBuZWVkZWQgYnkgdGhlIHNlbWFudGljcyBvZiB0aGUgZm9ybWF0IHN0cmluZyBzcGVjaWZpY2F0aW9ucyAoZS5nLiBhXG4gICAgIHRyYWlsaW5nICdza2lwIHNwYWNlJyBzcGVjaWZpY2F0aW9uIGluIHRoZSBmb3JtYXQgc3RyaW5nKTsgaW4gdGhpcyBjYXNlLFxuICAgICB0aGUgbWFuZGF0b3J5IGxvb2thaGVhZCBjaGFyYWN0ZXIgaXMgaW5kZWVkIHJlYWQgZnJvbSB0aGUgaW5wdXQgYW5kIG5vdFxuICAgICB1c2VkIHRvIHJldHVybiB0aGUgdG9rZW4gcmVhZC4gSXQgaXMgdGh1cyBtYW5kYXRvcnkgdG8gYmUgYWJsZSB0byBzdG9yZVxuICAgICBhbiB1bnVzZWQgbG9va2FoZWFkIGNoYXJhY3RlciBzb21ld2hlcmUgdG8gZ2V0IGl0IGFzIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAgICAgb2YgdGhlIG5leHQgc2Nhbi5cblxuICAgICBUbyBjaXJjdW12ZW50IHRoaXMgcHJvYmxlbSwgYWxsIHRoZSBzY2FubmluZyBmdW5jdGlvbnMgZ2V0IGEgbG93IGxldmVsXG4gICAgIGlucHV0IGJ1ZmZlciBhcmd1bWVudCB3aGVyZSB0aGV5IHN0b3JlIHRoZSBsb29rYWhlYWQgY2hhcmFjdGVyIHdoZW5cbiAgICAgbmVlZGVkOyBhZGRpdGlvbmFsbHksIHRoZSBpbnB1dCBidWZmZXIgaXMgdGhlIG9ubHkgc291cmNlIG9mIGNoYXJhY3RlciBvZlxuICAgICBhIHNjYW5uZXIuIFRoZSBbc2NhbmJ1Zl0gaW5wdXQgYnVmZmVycyBhcmUgZGVmaW5lZCBpbiBtb2R1bGUgeyFTY2FubmluZ30uXG5cbiAgICAgTm93IHdlIHVuZGVyc3RhbmQgdGhhdCBpdCBpcyBleHRyZW1lbHkgaW1wb3J0YW50IHRoYXQgcmVsYXRlZCBhbmRcbiAgICAgc3VjY2Vzc2l2ZSBjYWxscyB0byBzY2FubmVycyBpbmRlZWQgcmVhZCBmcm9tIHRoZSBzYW1lIGlucHV0IGJ1ZmZlci5cbiAgICAgSW4gZWZmZWN0LCBpZiBhIHNjYW5uZXIgW3NjYW4xXSBpcyByZWFkaW5nIGZyb20gW2liMV0gYW5kIHN0b3JlcyBhblxuICAgICB1bnVzZWQgbG9va2FoZWFkIGNoYXJhY3RlciBbYzFdIGludG8gaXRzIGlucHV0IGJ1ZmZlciBbaWIxXSwgdGhlblxuICAgICBhbm90aGVyIHNjYW5uZXIgW3NjYW4yXSBub3QgcmVhZGluZyBmcm9tIHRoZSBzYW1lIGJ1ZmZlciBbaWIxXSB3aWxsIG1pc3NcbiAgICAgdGhlIGNoYXJhY3RlciBbYzFdLCBzZWVtaW5nbHkgdmFuaXNoZWQgaW4gdGhlIGFpciBmcm9tIHRoZSBwb2ludCBvZiB2aWV3XG4gICAgIG9mIFtzY2FuMl0uXG5cbiAgICAgVGhpcyBtZWNoYW5pc20gd29ya3MgcGVyZmVjdGx5IHRvIHJlYWQgZnJvbSBzdHJpbmdzLCBmcm9tIGZpbGVzLCBhbmQgZnJvbVxuICAgICBmdW5jdGlvbnMsIHNpbmNlIGluIHRob3NlIGNhc2VzLCBhbGxvY2F0aW5nIHR3byBidWZmZXJzIHJlYWRpbmcgZnJvbSB0aGVcbiAgICAgc2FtZSBzb3VyY2UgaXMgdW5uYXR1cmFsLlxuXG4gICAgIFN0aWxsLCB0aGVyZSBpcyBhIGRpZmZpY3VsdHkgaW4gdGhlIGNhc2Ugb2Ygc2Nhbm5pbmcgZnJvbSBhbiBpbnB1dFxuICAgICBjaGFubmVsLiBJbiBlZmZlY3QsIHdoZW4gc2Nhbm5pbmcgZnJvbSBhbiBpbnB1dCBjaGFubmVsIFtpY10sIHRoaXMgY2hhbm5lbFxuICAgICBtYXkgbm90IGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB3aXRoaW4gdGhpcyBsaWJyYXJ5LiBIZW5jZSwgaXQgbWF5IGJlXG4gICAgIHNoYXJlZCAodHdvIGZ1bmN0aW9ucyBvZiB0aGUgdXNlcidzIHByb2dyYW0gbWF5IHN1Y2Nlc3NpdmVseSByZWFkIGZyb21cbiAgICAgW2ljXSkuIFRoaXMgaXMgaGlnaGx5IGVycm9yIHByb25lIHNpbmNlLCBvbmUgb2YgdGhlIGZ1bmN0aW9uIG1heSBzZWVrIHRoZVxuICAgICBpbnB1dCBjaGFubmVsLCB3aGlsZSB0aGUgb3RoZXIgZnVuY3Rpb24gaGFzIHN0aWxsIGFuIHVudXNlZCBsb29rYWhlYWRcbiAgICAgY2hhcmFjdGVyIGluIGl0cyBpbnB1dCBidWZmZXIuIEluIGNvbmNsdXNpb24sIHlvdSBzaG91bGQgbmV2ZXIgbWl4IGRpcmVjdFxuICAgICBsb3cgbGV2ZWwgcmVhZGluZyBhbmQgaGlnaCBsZXZlbCBzY2FubmluZyBmcm9tIHRoZSBzYW1lIGlucHV0IGNoYW5uZWwuXG5cbiAgKilcblxuICAoKiBQZXJmb3JtIGJ1ZmZlcml6ZWQgaW5wdXQgdG8gaW1wcm92ZSBlZmZpY2llbmN5LiAqKVxuICBsZXQgZmlsZV9idWZmZXJfc2l6ZSA9IHJlZiAxMDI0XG5cbiAgKCogVGhlIHNjYW5uZXIgY2xvc2VzIHRoZSBpbnB1dCBjaGFubmVsIGF0IGVuZCBvZiBpbnB1dC4gKilcbiAgbGV0IHNjYW5fY2xvc2VfYXRfZW5kIGljID0gU3RkbGliLmNsb3NlX2luIGljOyByYWlzZSBFbmRfb2ZfZmlsZVxuXG4gICgqIFRoZSBzY2FubmVyIGRvZXMgbm90IGNsb3NlIHRoZSBpbnB1dCBjaGFubmVsIGF0IGVuZCBvZiBpbnB1dDpcbiAgICAgaXQganVzdCByYWlzZXMgW0VuZF9vZl9maWxlXS4gKilcbiAgbGV0IHNjYW5fcmFpc2VfYXRfZW5kIF9pYyA9IHJhaXNlIEVuZF9vZl9maWxlXG5cbiAgbGV0IGZyb21faWMgc2Nhbl9jbG9zZV9pYyBpbmFtZSBpYyA9XG4gICAgbGV0IGxlbiA9ICFmaWxlX2J1ZmZlcl9zaXplIGluXG4gICAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IGxpbSA9IHJlZiAwIGluXG4gICAgbGV0IGVvZiA9IHJlZiBmYWxzZSBpblxuICAgIGxldCBuZXh0ICgpID1cbiAgICAgIGlmICFpIDwgIWxpbSB0aGVuIGJlZ2luIGxldCBjID0gQnl0ZXMuZ2V0IGJ1ZiAhaSBpbiBpbmNyIGk7IGMgZW5kIGVsc2VcbiAgICAgIGlmICFlb2YgdGhlbiByYWlzZSBFbmRfb2ZfZmlsZSBlbHNlIGJlZ2luXG4gICAgICAgIGxpbSA6PSBpbnB1dCBpYyBidWYgMCBsZW47XG4gICAgICAgIGlmICFsaW0gPSAwIHRoZW4gYmVnaW4gZW9mIDo9IHRydWU7IHNjYW5fY2xvc2VfaWMgaWMgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICBpIDo9IDE7XG4gICAgICAgICAgQnl0ZXMuZ2V0IGJ1ZiAwXG4gICAgICAgIGVuZFxuICAgICAgZW5kIGluXG4gICAgY3JlYXRlIGluYW1lIG5leHRcblxuXG4gIGxldCBmcm9tX2ljX2Nsb3NlX2F0X2VuZCA9IGZyb21faWMgc2Nhbl9jbG9zZV9hdF9lbmRcbiAgbGV0IGZyb21faWNfcmFpc2VfYXRfZW5kID0gZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuXG4gICgqIFRoZSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBmcm9tIFtTdGRsaWIuc3RkaW5dLlxuICAgICBPbmUgY291bGQgdHJ5IHRvIGRlZmluZSBbc3RkaWJdIGFzIGEgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgYSBjaGFyYWN0ZXJcbiAgICAgYXQgYSB0aW1lIChubyBidWZmZXJpemF0aW9uIGF0IGFsbCksIGJ1dCB1bmZvcnR1bmF0ZWx5IHRoZSB0b3AtbGV2ZWxcbiAgICAgaW50ZXJhY3Rpb24gd291bGQgYmUgd3JvbmcuIFRoaXMgaXMgZHVlIHRvIHNvbWUga2luZCBvZlxuICAgICAncmFjZSBjb25kaXRpb24nIHdoZW4gcmVhZGluZyBmcm9tIFtTdGRsaWIuc3RkaW5dLFxuICAgICBzaW5jZSB0aGUgaW50ZXJhY3RpdmUgY29tcGlsZXIgYW5kIFtTY2FuZi5zY2FuZl0gd2lsbCBzaW11bHRhbmVvdXNseVxuICAgICByZWFkIHRoZSBtYXRlcmlhbCB0aGV5IG5lZWQgZnJvbSBbU3RkbGliLnN0ZGluXTsgdGhlbiwgY29uZnVzaW9uXG4gICAgIHdpbGwgcmVzdWx0IGZyb20gd2hhdCBzaG91bGQgYmUgcmVhZCBieSB0aGUgdG9wLWxldmVsIGFuZCB3aGF0IHNob3VsZCBiZVxuICAgICByZWFkIGJ5IFtTY2FuZi5zY2FuZl0uXG4gICAgIFRoaXMgaXMgZXZlbiBtb3JlIGNvbXBsaWNhdGVkIGJ5IHRoZSBvbmUgY2hhcmFjdGVyIGxvb2thaGVhZCB0aGF0XG4gICAgIFtTY2FuZi5zY2FuZl0gaXMgc29tZXRpbWVzIG9ibGlnZWQgdG8gbWFpbnRhaW46IHRoZSBsb29rYWhlYWQgY2hhcmFjdGVyXG4gICAgIHdpbGwgYmUgYXZhaWxhYmxlIGZvciB0aGUgbmV4dCBbU2NhbmYuc2NhbmZdIGVudHJ5LCBzZWVtaW5nbHkgY29taW5nIGZyb21cbiAgICAgbm93aGVyZS5cbiAgICAgQWxzbyBubyBbRW5kX29mX2ZpbGVdIGlzIHJhaXNlZCB3aGVuIHJlYWRpbmcgZnJvbSBzdGRpbjogaWYgbm90IGVub3VnaFxuICAgICBjaGFyYWN0ZXJzIGhhdmUgYmVlbiByZWFkLCB3ZSBzaW1wbHkgYXNrIHRvIHJlYWQgbW9yZS4gKilcbiAgbGV0IHN0ZGluID1cbiAgICBmcm9tX2ljIHNjYW5fcmFpc2VfYXRfZW5kXG4gICAgICAoRnJvbV9maWxlIChcIi1cIiwgU3RkbGliLnN0ZGluKSkgU3RkbGliLnN0ZGluXG5cblxuICBsZXQgc3RkaWIgPSBzdGRpblxuXG4gIGxldCBvcGVuX2luX2ZpbGUgb3Blbl9pbiBmbmFtZSA9XG4gICAgbWF0Y2ggZm5hbWUgd2l0aFxuICAgIHwgXCItXCIgLT4gc3RkaW5cbiAgICB8IGZuYW1lIC0+XG4gICAgICBsZXQgaWMgPSBvcGVuX2luIGZuYW1lIGluXG4gICAgICBmcm9tX2ljX2Nsb3NlX2F0X2VuZCAoRnJvbV9maWxlIChmbmFtZSwgaWMpKSBpY1xuXG5cbiAgbGV0IG9wZW5faW4gPSBvcGVuX2luX2ZpbGUgU3RkbGliLm9wZW5faW5cbiAgbGV0IG9wZW5faW5fYmluID0gb3Blbl9pbl9maWxlIFN0ZGxpYi5vcGVuX2luX2JpblxuXG4gIGxldCBmcm9tX2ZpbGUgPSBvcGVuX2luXG4gIGxldCBmcm9tX2ZpbGVfYmluID0gb3Blbl9pbl9iaW5cblxuICBsZXQgZnJvbV9jaGFubmVsIGljID1cbiAgICBmcm9tX2ljX3JhaXNlX2F0X2VuZCAoRnJvbV9jaGFubmVsIGljKSBpY1xuXG5cbiAgbGV0IGNsb3NlX2luIGliID1cbiAgICBtYXRjaCBpYi5pY19pbnB1dF9uYW1lIHdpdGhcbiAgICB8IEZyb21fY2hhbm5lbCBpYyAtPlxuICAgICAgU3RkbGliLmNsb3NlX2luIGljXG4gICAgfCBGcm9tX2ZpbGUgKF9mbmFtZSwgaWMpIC0+IFN0ZGxpYi5jbG9zZV9pbiBpY1xuICAgIHwgRnJvbV9mdW5jdGlvbiB8IEZyb21fc3RyaW5nIC0+ICgpXG5cblxuICAoKlxuICAgICBPYnNvbGV0ZTogYSBtZW1vIFtmcm9tX2NoYW5uZWxdIHZlcnNpb24gdG8gYnVpbGQgYSBbU2Nhbm5pbmcuaW5fY2hhbm5lbF1cbiAgICAgc2Nhbm5pbmcgYnVmZmVyIG91dCBvZiBhIFtTdGRsaWIuaW5fY2hhbm5lbF0uXG4gICAgIFRoaXMgZnVuY3Rpb24gd2FzIHVzZWQgdG8gdHJ5IHRvIHByZXNlcnZlIHRoZSBzY2FubmluZ1xuICAgICBzZW1hbnRpY3MgZm9yIHRoZSAobm93IG9ic29sZXRlKSBmdW5jdGlvbiBbZnNjYW5mXS5cbiAgICAgR2l2ZW4gdGhhdCBhbGwgc2Nhbm5lciBtdXN0IHJlYWQgZnJvbSBhIFtTY2FubmluZy5pbl9jaGFubmVsXSBzY2FubmluZ1xuICAgICBidWZmZXIsIFtmc2NhbmZdIG11c3QgcmVhZCBmcm9tIG9uZSFcbiAgICAgTW9yZSBwcmVjaXNlbHksIGdpdmVuIFtpY10sIGFsbCBzdWNjZXNzaXZlIGNhbGxzIFtmc2NhbmYgaWNdIG11c3QgcmVhZFxuICAgICBmcm9tIHRoZSBzYW1lIHNjYW5uaW5nIGJ1ZmZlci5cbiAgICAgVGhpcyBvYmxpZ2VkIHRoaXMgbGlicmFyeSB0byBhbGxvY2F0ZWQgc2Nhbm5pbmcgYnVmZmVycyB0aGF0IHdlcmVcbiAgICAgbm90IHByb3Blcmx5IGdhcmJhZ2UgY29sbGVjdGFibGUsIGhlbmNlIGxlYWRpbmcgdG8gbWVtb3J5IGxlYWtzLlxuICAgICBJZiB5b3UgbmVlZCB0byByZWFkIGZyb20gYSBbU3RkbGliLmluX2NoYW5uZWxdIGlucHV0IGNoYW5uZWxcbiAgICAgW2ljXSwgc2ltcGx5IGRlZmluZSBhIFtTY2FubmluZy5pbl9jaGFubmVsXSBmb3JtYXR0ZWQgaW5wdXQgY2hhbm5lbCBhcyBpblxuICAgICBbbGV0IGliID0gU2Nhbm5pbmcuZnJvbV9jaGFubmVsIGljXSwgdGhlbiB1c2UgW1NjYW5mLmJzY2FuZiBpYl0gYXMgdXN1YWwuXG4gICopXG4gIGxldCBtZW1vX2Zyb21faWMgPVxuICAgIGxldCBtZW1vID0gcmVmIFtdIGluXG4gICAgKGZ1biBzY2FuX2Nsb3NlX2ljIGljIC0+XG4gICAgIHRyeSBMaXN0LmFzc3EgaWMgIW1lbW8gd2l0aFxuICAgICB8IE5vdF9mb3VuZCAtPlxuICAgICAgIGxldCBpYiA9XG4gICAgICAgICBmcm9tX2ljIHNjYW5fY2xvc2VfaWMgKEZyb21fY2hhbm5lbCBpYykgaWMgaW5cbiAgICAgICBtZW1vIDo9IChpYywgaWIpIDo6ICFtZW1vO1xuICAgICAgIGliKVxuXG5cbiAgKCogT2Jzb2xldGU6IHNlZSB7IW1lbW9fZnJvbV9pY30gYWJvdmUuICopXG4gIGxldCBtZW1vX2Zyb21fY2hhbm5lbCA9IG1lbW9fZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuXG5lbmRcblxuXG4oKiBGb3JtYXR0ZWQgaW5wdXQgZnVuY3Rpb25zLiAqKVxuXG50eXBlICgnYSwgJ2IsICdjLCAnZCkgc2Nhbm5lciA9XG4gICAgICgnYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgJ2IsICdjLCAnYSAtPiAnZCwgJ2QpIGZvcm1hdDYgLT4gJ2NcblxuXG4oKiBSZXBvcnRpbmcgZXJyb3JzLiAqKVxuZXhjZXB0aW9uIFNjYW5fZmFpbHVyZSBvZiBzdHJpbmdcblxubGV0IGJhZF9pbnB1dCBzID0gcmFpc2UgKFNjYW5fZmFpbHVyZSBzKVxuXG5sZXQgYmFkX2lucHV0X2VzY2FwZSBjID1cbiAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImlsbGVnYWwgZXNjYXBlIGNoYXJhY3RlciAlQ1wiIGMpXG5cblxubGV0IGJhZF90b2tlbl9sZW5ndGggbWVzc2FnZSA9XG4gIGJhZF9pbnB1dFxuICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgIFwic2Nhbm5pbmcgb2YgJXMgZmFpbGVkOiBcXFxuICAgICAgICB0aGUgc3BlY2lmaWVkIGxlbmd0aCB3YXMgdG9vIHNob3J0IGZvciB0b2tlblwiXG4gICAgICAgbWVzc2FnZSlcblxuXG5sZXQgYmFkX2VuZF9vZl9pbnB1dCBtZXNzYWdlID1cbiAgYmFkX2lucHV0XG4gICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgXCJzY2FubmluZyBvZiAlcyBmYWlsZWQ6IFxcXG4gICAgICAgIHByZW1hdHVyZSBlbmQgb2YgZmlsZSBvY2N1cnJlZCBiZWZvcmUgZW5kIG9mIHRva2VuXCJcbiAgICAgICBtZXNzYWdlKVxuXG5cbmxldCBiYWRfZmxvYXQgKCkgPVxuICBiYWRfaW5wdXQgXCJubyBkb3Qgb3IgZXhwb25lbnQgcGFydCBmb3VuZCBpbiBmbG9hdCB0b2tlblwiXG5cblxubGV0IGJhZF9oZXhfZmxvYXQgKCkgPVxuICBiYWRfaW5wdXQgXCJub3QgYSB2YWxpZCBmbG9hdCBpbiBoZXhhZGVjaW1hbCBub3RhdGlvblwiXG5cblxubGV0IGNoYXJhY3Rlcl9taXNtYXRjaF9lcnIgYyBjaSA9XG4gIFByaW50Zi5zcHJpbnRmIFwibG9va2luZyBmb3IgJUMsIGZvdW5kICVDXCIgYyBjaVxuXG5cbmxldCBjaGFyYWN0ZXJfbWlzbWF0Y2ggYyBjaSA9XG4gIGJhZF9pbnB1dCAoY2hhcmFjdGVyX21pc21hdGNoX2VyciBjIGNpKVxuXG5cbmxldCByZWMgc2tpcF93aGl0ZXMgaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBub3QgKFNjYW5uaW5nLmVvZiBpYikgdGhlbiBiZWdpblxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJyAnIHwgJ1xcdCcgfCAnXFxuJyB8ICdcXHInIC0+XG4gICAgICBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjsgc2tpcF93aGl0ZXMgaWJcbiAgICB8IF8gLT4gKClcbiAgZW5kXG5cblxuKCogQ2hlY2tpbmcgdGhhdCBbY10gaXMgaW5kZWVkIGluIHRoZSBpbnB1dCwgdGhlbiBza2lwcyBpdC5cbiAgIEluIHRoaXMgY2FzZSwgdGhlIGNoYXJhY3RlciBbY10gaGFzIGJlZW4gZXhwbGljaXRseSBzcGVjaWZpZWQgaW4gdGhlXG4gICBmb3JtYXQgYXMgYmVpbmcgbWFuZGF0b3J5IGluIHRoZSBpbnB1dDsgaGVuY2Ugd2Ugc2hvdWxkIGZhaWwgd2l0aFxuICAgW0VuZF9vZl9maWxlXSBpbiBjYXNlIG9mIGVuZF9vZl9pbnB1dC5cbiAgIChSZW1lbWJlciB0aGF0IFtTY2FuX2ZhaWx1cmVdIGlzIHJhaXNlZCBvbmx5IHdoZW4gKHdlIGNhbiBwcm92ZSBieVxuICAgZXZpZGVuY2UpIHRoYXQgdGhlIGlucHV0IGRvZXMgbm90IG1hdGNoIHRoZSBmb3JtYXQgc3RyaW5nIGdpdmVuLiBXZSBtdXN0XG4gICB0aHVzIGRpZmZlcmVudGlhdGUgW0VuZF9vZl9maWxlXSBhcyBhbiBlcnJvciBkdWUgdG8gbGFjayBvZiBpbnB1dCwgYW5kXG4gICBbU2Nhbl9mYWlsdXJlXSB3aGljaCBpcyBkdWUgdG8gcHJvdmFibHkgd3JvbmcgaW5wdXQuIEkgYW0gbm90IHN1cmUgdGhpcyBpc1xuICAgd29ydGggdGhlIGJ1cmRlbjogaXQgaXMgY29tcGxleCBhbmQgc29tZWhvdyBzdWJsaW1pbmFsOyBzaG91bGQgYmUgY2xlYXJlclxuICAgdG8gZmFpbCB3aXRoIFNjYW5fZmFpbHVyZSBcIk5vdCBlbm91Z2ggaW5wdXQgdG8gY29tcGxldGUgc2Nhbm5pbmdcIiEpXG5cbiAgIFRoYXQncyB3aHksIHdhaXRpbmcgZm9yIGEgYmV0dGVyIHNvbHV0aW9uLCB3ZSB1c2UgY2hlY2tlZF9wZWVrX2NoYXIgaGVyZS5cbiAgIFdlIGFyZSBhbHNvIGNhcmVmdWwgdG8gdHJlYXQgXCJcXHJcXG5cIiBpbiB0aGUgaW5wdXQgYXMgYW4gZW5kIG9mIGxpbmUgbWFya2VyOlxuICAgaXQgYWx3YXlzIG1hdGNoZXMgYSAnXFxuJyBzcGVjaWZpY2F0aW9uIGluIHRoZSBpbnB1dCBmb3JtYXQgc3RyaW5nLiAqKVxubGV0IHJlYyBjaGVja19jaGFyIGliIGMgPVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnICcgLT4gc2tpcF93aGl0ZXMgaWJcbiAgfCAnXFxuJyAtPiBjaGVja19uZXdsaW5lIGliXG4gIHwgYyAtPiBjaGVja190aGlzX2NoYXIgaWIgY1xuXG5hbmQgY2hlY2tfdGhpc19jaGFyIGliIGMgPVxuICBsZXQgY2kgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBpZiBjaSA9IGMgdGhlbiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYiBlbHNlXG4gIGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpXG5cbmFuZCBjaGVja19uZXdsaW5lIGliID1cbiAgbGV0IGNpID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggY2kgd2l0aFxuICB8ICdcXG4nIC0+IFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXG4gIHwgJ1xccicgLT4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWI7IGNoZWNrX3RoaXNfY2hhciBpYiAnXFxuJ1xuICB8IF8gLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXG4nIGNpXG5cblxuKCogRXh0cmFjdGluZyB0b2tlbnMgZnJvbSB0aGUgb3V0cHV0IHRva2VuIGJ1ZmZlci4gKilcblxubGV0IHRva2VuX2NoYXIgaWIgPSAoU2Nhbm5pbmcudG9rZW4gaWIpLlswXVxuXG5sZXQgdG9rZW5fc3RyaW5nID0gU2Nhbm5pbmcudG9rZW5cblxubGV0IHRva2VuX2Jvb2wgaWIgPVxuICBtYXRjaCBTY2FubmluZy50b2tlbiBpYiB3aXRoXG4gIHwgXCJ0cnVlXCIgLT4gdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBmYWxzZVxuICB8IHMgLT4gYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImludmFsaWQgYm9vbGVhbiAnJXMnXCIgcylcblxuXG4oKiBUaGUgdHlwZSBvZiBpbnRlZ2VyIGNvbnZlcnNpb25zLiAqKVxudHlwZSBpbnRlZ2VyX2NvbnZlcnNpb24gPVxuICB8IEJfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBiaW5hcnkgY29udmVyc2lvbiAqKVxuICB8IERfY29udmVyc2lvbiAoKiBTaWduZWQgZGVjaW1hbCBjb252ZXJzaW9uICopXG4gIHwgSV9jb252ZXJzaW9uICgqIFNpZ25lZCBpbnRlZ2VyIGNvbnZlcnNpb24gKilcbiAgfCBPX2NvbnZlcnNpb24gKCogVW5zaWduZWQgb2N0YWwgY29udmVyc2lvbiAqKVxuICB8IFVfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBkZWNpbWFsIGNvbnZlcnNpb24gKilcbiAgfCBYX2NvbnZlcnNpb24gKCogVW5zaWduZWQgaGV4YWRlY2ltYWwgY29udmVyc2lvbiAqKVxuXG5cbmxldCBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciA9IGZ1bmN0aW9uXG4gIHwgJ2InIC0+IEJfY29udmVyc2lvblxuICB8ICdkJyAtPiBEX2NvbnZlcnNpb25cbiAgfCAnaScgLT4gSV9jb252ZXJzaW9uXG4gIHwgJ28nIC0+IE9fY29udmVyc2lvblxuICB8ICd1JyAtPiBVX2NvbnZlcnNpb25cbiAgfCAneCcgfCAnWCcgLT4gWF9jb252ZXJzaW9uXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuXG4oKiBFeHRyYWN0IGFuIGludGVnZXIgbGl0ZXJhbCB0b2tlbi5cbiAgIFNpbmNlIHRoZSBmdW5jdGlvbnMgU3RkbGliLippbnQqX29mX3N0cmluZyBkbyBub3QgYWNjZXB0IGEgbGVhZGluZyArLFxuICAgd2Ugc2tpcCBpdCBpZiBuZWNlc3NhcnkuICopXG5sZXQgdG9rZW5faW50X2xpdGVyYWwgY29udiBpYiA9XG4gIGxldCB0b2sgPVxuICAgIG1hdGNoIGNvbnYgd2l0aFxuICAgIHwgRF9jb252ZXJzaW9uIHwgSV9jb252ZXJzaW9uIC0+IFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBVX2NvbnZlcnNpb24gLT4gXCIwdVwiIF4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IE9fY29udmVyc2lvbiAtPiBcIjBvXCIgXiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgWF9jb252ZXJzaW9uIC0+IFwiMHhcIiBeIFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBCX2NvbnZlcnNpb24gLT4gXCIwYlwiIF4gU2Nhbm5pbmcudG9rZW4gaWIgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHRvayBpblxuICBpZiBsID0gMCB8fCB0b2suWzBdIDw+ICcrJyB0aGVuIHRvayBlbHNlIFN0cmluZy5zdWIgdG9rIDEgKGwgLSAxKVxuXG5cbigqIEFsbCB0aGUgZnVuY3Rpb25zIHRoYXQgY29udmVydCBhIHN0cmluZyB0byBhIG51bWJlciByYWlzZSB0aGUgZXhjZXB0aW9uXG4gICBGYWlsdXJlIHdoZW4gdGhlIGNvbnZlcnNpb24gaXMgbm90IHBvc3NpYmxlLlxuICAgVGhpcyBleGNlcHRpb24gaXMgdGhlbiB0cmFwcGVkIGluIFtrc2NhbmZdLiAqKVxubGV0IHRva2VuX2ludCBjb252IGliID0gaW50X29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcblxubGV0IHRva2VuX2Zsb2F0IGliID0gZmxvYXRfb2Zfc3RyaW5nIChTY2FubmluZy50b2tlbiBpYilcblxuKCogVG8gc2NhbiBuYXRpdmUgaW50cywgaW50MzIgYW5kIGludDY0IGludGVnZXJzLlxuICAgV2UgY2Fubm90IGFjY2VzcyB0byBjb252ZXJzaW9ucyB0by9mcm9tIHN0cmluZ3MgZm9yIHRob3NlIHR5cGVzLFxuICAgTmF0aXZlaW50Lm9mX3N0cmluZywgSW50MzIub2Zfc3RyaW5nLCBhbmQgSW50NjQub2Zfc3RyaW5nLFxuICAgc2luY2UgdGhvc2UgbW9kdWxlcyBhcmUgbm90IGF2YWlsYWJsZSB0byBbU2NhbmZdLlxuICAgSG93ZXZlciwgd2UgY2FuIGJpbmQgYW5kIHVzZSB0aGUgY29ycmVzcG9uZGluZyBwcmltaXRpdmVzIHRoYXQgYXJlXG4gICBhdmFpbGFibGUgaW4gdGhlIHJ1bnRpbWUuICopXG5leHRlcm5hbCBuYXRpdmVpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IG5hdGl2ZWludFxuICA9IFwiY2FtbF9uYXRpdmVpbnRfb2Zfc3RyaW5nXCJcblxuZXh0ZXJuYWwgaW50MzJfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIGludDY0X29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQ2NFxuICA9IFwiY2FtbF9pbnQ2NF9vZl9zdHJpbmdcIlxuXG5cbmxldCB0b2tlbl9uYXRpdmVpbnQgY29udiBpYiA9IG5hdGl2ZWludF9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5sZXQgdG9rZW5faW50MzIgY29udiBpYiA9IGludDMyX29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcbmxldCB0b2tlbl9pbnQ2NCBjb252IGliID0gaW50NjRfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxuXG4oKiBTY2FubmluZyBudW1iZXJzLiAqKVxuXG4oKiBEaWdpdHMgc2Nhbm5pbmcgZnVuY3Rpb25zIHN1cHBvc2UgdGhhdCBvbmUgY2hhcmFjdGVyIGhhcyBiZWVuIGNoZWNrZWQgYW5kXG4gICBpcyBhdmFpbGFibGUsIHNpbmNlIHRoZXkgcmV0dXJuIGF0IGVuZCBvZiBmaWxlIHdpdGggdGhlIGN1cnJlbnRseSBmb3VuZFxuICAgdG9rZW4gc2VsZWN0ZWQuXG5cbiAgIFB1dCBpdCBpbiBhbm90aGVyIHdheSwgdGhlIGRpZ2l0cyBzY2FubmluZyBmdW5jdGlvbnMgc2NhbiBmb3IgYSBwb3NzaWJseVxuICAgZW1wdHkgc2VxdWVuY2Ugb2YgZGlnaXRzLCAoaGVuY2UsIGEgc3VjY2Vzc2Z1bCBzY2FubmluZyBmcm9tIG9uZSBvZiB0aG9zZVxuICAgZnVuY3Rpb25zIGRvZXMgbm90IGltcGx5IHRoYXQgdGhlIHRva2VuIGlzIGEgd2VsbC1mb3JtZWQgbnVtYmVyOiB0byBnZXQgYVxuICAgdHJ1ZSBudW1iZXIsIGl0IGlzIG1hbmRhdG9yeSB0byBjaGVjayB0aGF0IGF0IGxlYXN0IG9uZSB2YWxpZCBkaWdpdCBpc1xuICAgYXZhaWxhYmxlIGJlZm9yZSBjYWxsaW5nIG9uZSBvZiB0aGUgZGlnaXQgc2Nhbm5pbmcgZnVuY3Rpb25zKS4gKilcblxuKCogVGhlIGRlY2ltYWwgY2FzZSBpcyB0cmVhdGVkIGVzcGVjaWFsbHkgZm9yIG9wdGltaXphdGlvbiBwdXJwb3Nlcy4gKilcbmxldCByZWMgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcbiAgfCAnXycgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYiBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbmxldCBzY2FuX2RlY2ltYWxfZGlnaXRfcGx1cyB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggXCJkZWNpbWFsIGRpZ2l0c1wiIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjIHdpdGhcbiAgfCAnMCcgLi4gJzknIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcbiAgfCBjIC0+XG4gICAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImNoYXJhY3RlciAlQyBpcyBub3QgYSBkZWNpbWFsIGRpZ2l0XCIgYylcblxuXG4oKiBUbyBzY2FuIG51bWJlcnMgZnJvbSBvdGhlciBiYXNlcywgd2UgdXNlIGEgcHJlZGljYXRlIGFyZ3VtZW50IHRvXG4gICBzY2FuIGRpZ2l0cy4gKilcbmxldCBzY2FuX2RpZ2l0X3N0YXIgZGlnaXRwIHdpZHRoIGliID1cbiAgbGV0IHJlYyBzY2FuX2RpZ2l0cyB3aWR0aCBpYiA9XG4gICAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgYyB3aGVuIGRpZ2l0cCBjIC0+XG4gICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgIHNjYW5fZGlnaXRzIHdpZHRoIGliXG4gICAgfCAnXycgLT5cbiAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliIGluXG4gICAgICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuICAgIHwgXyAtPiB3aWR0aCBpblxuICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX2RpZ2l0X3BsdXMgYmFzaXMgZGlnaXRwIHdpZHRoIGliID1cbiAgKCogRW5zdXJlIHdlIGhhdmUgZ290IGVub3VnaCB3aWR0aCBsZWZ0LFxuICAgICBhbmQgcmVhZCBhdCBsZWFzdCBvbmUgZGlnaXQuICopXG4gIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggXCJkaWdpdHNcIiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgaWYgZGlnaXRwIGMgdGhlblxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGlnaXRfc3RhciBkaWdpdHAgd2lkdGggaWJcbiAgZWxzZVxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJjaGFyYWN0ZXIgJUMgaXMgbm90IGEgdmFsaWQgJXMgZGlnaXRcIiBjIGJhc2lzKVxuXG5cbmxldCBpc19iaW5hcnlfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnMScgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9iaW5hcnlfaW50ID0gc2Nhbl9kaWdpdF9wbHVzIFwiYmluYXJ5XCIgaXNfYmluYXJ5X2RpZ2l0XG5cbmxldCBpc19vY3RhbF9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc3JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5cbmxldCBzY2FuX29jdGFsX2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcIm9jdGFsXCIgaXNfb2N0YWxfZGlnaXRcblxubGV0IGlzX2hleGFfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIHwgJ0EnIC4uICdGJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5cbmxldCBzY2FuX2hleGFkZWNpbWFsX2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcImhleGFkZWNpbWFsXCIgaXNfaGV4YV9kaWdpdFxuXG4oKiBTY2FuIGEgZGVjaW1hbCBpbnRlZ2VyLiAqKVxubGV0IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgPSBzY2FuX2RlY2ltYWxfZGlnaXRfcGx1c1xuXG5sZXQgc2Nhbl9zaWduIHdpZHRoIGliID1cbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjIHdpdGhcbiAgfCAnKycgLT4gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjXG4gIHwgJy0nIC0+IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgY1xuICB8IF8gLT4gd2lkdGhcblxuXG5sZXQgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG5cblxuKCogU2NhbiBhbiB1bnNpZ25lZCBpbnRlZ2VyIHRoYXQgY291bGQgYmUgZ2l2ZW4gaW4gYW55IChjb21tb24pIGJhc2lzLlxuICAgSWYgZGlnaXRzIGFyZSBwcmVmaXhlZCBieSBvbmUgb2YgMHgsIDBYLCAwbywgb3IgMGIsIHRoZSBudW1iZXIgaXNcbiAgIGFzc3VtZWQgdG8gYmUgd3JpdHRlbiByZXNwZWN0aXZlbHkgaW4gaGV4YWRlY2ltYWwsIGhleGFkZWNpbWFsLFxuICAgb2N0YWwsIG9yIGJpbmFyeS4gKilcbmxldCBzY2FuX3Vuc2lnbmVkX2ludCB3aWR0aCBpYiA9XG4gIG1hdGNoIFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIHdpdGhcbiAgfCAnMCcgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICBiZWdpbiBtYXRjaCBjIHdpdGhcbiAgICB8ICd4JyB8ICdYJyAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgJ28nIC0+IHNjYW5fb2N0YWxfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gICAgfCAnYicgLT4gc2Nhbl9iaW5hcnlfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gICAgfCBfIC0+IHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliIGVuZFxuICB8IF8gLT4gc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2ludCB3aWR0aCBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBzY2FuX3Vuc2lnbmVkX2ludCB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX2ludF9jb252ZXJzaW9uIGNvbnYgd2lkdGggaWIgPVxuICBtYXRjaCBjb252IHdpdGhcbiAgfCBCX2NvbnZlcnNpb24gLT4gc2Nhbl9iaW5hcnlfaW50IHdpZHRoIGliXG4gIHwgRF9jb252ZXJzaW9uIC0+IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgfCBJX2NvbnZlcnNpb24gLT4gc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9pbnQgd2lkdGggaWJcbiAgfCBPX2NvbnZlcnNpb24gLT4gc2Nhbl9vY3RhbF9pbnQgd2lkdGggaWJcbiAgfCBVX2NvbnZlcnNpb24gLT4gc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICB8IFhfY29udmVyc2lvbiAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbigqIFNjYW5uaW5nIGZsb2F0aW5nIHBvaW50IG51bWJlcnMuICopXG5cbigqIEZyYWN0aW9uYWwgcGFydCBpcyBvcHRpb25hbCBhbmQgY2FuIGJlIHJlZHVjZWQgdG8gMCBkaWdpdHMuICopXG5sZXQgc2Nhbl9mcmFjdGlvbmFsX3BhcnQgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgfCBfIC0+IHdpZHRoXG5cblxuKCogRXhwIHBhcnQgaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSByZWR1Y2VkIHRvIDAgZGlnaXRzLiAqKVxubGV0IHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnZScgfCAnRScgYXMgYyAtPlxuICAgIHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgfCBfIC0+IHdpZHRoXG5cblxuKCogU2NhbiB0aGUgaW50ZWdlciBwYXJ0IG9mIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLCAobm90IHVzaW5nIHRoZVxuICAgT0NhbWwgbGV4aWNhbCBjb252ZW50aW9uIHNpbmNlIHRoZSBpbnRlZ2VyIHBhcnQgY2FuIGJlIGVtcHR5KTpcbiAgIGFuIG9wdGlvbmFsIHNpZ24sIGZvbGxvd2VkIGJ5IGEgcG9zc2libHkgZW1wdHkgc2VxdWVuY2Ugb2YgZGVjaW1hbFxuICAgZGlnaXRzIChlLmcuIC0uMSkuICopXG5sZXQgc2Nhbl9pbnRlZ2VyX3BhcnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcblxuXG4oKlxuICAgRm9yIHRoZSB0aW1lIGJlaW5nIHdlIGhhdmUgKGFzIGZvdW5kIGluIHNjYW5mLm1saSk6XG4gICB0aGUgZmllbGQgd2lkdGggaXMgY29tcG9zZWQgb2YgYW4gb3B0aW9uYWwgaW50ZWdlciBsaXRlcmFsXG4gICBpbmRpY2F0aW5nIHRoZSBtYXhpbWFsIHdpZHRoIG9mIHRoZSB0b2tlbiB0byByZWFkLlxuICAgVW5mb3J0dW5hdGVseSwgdGhlIHR5cGUtY2hlY2tlciBsZXQgdGhlIHVzZXIgd3JpdGUgYW4gb3B0aW9uYWwgcHJlY2lzaW9uLFxuICAgc2luY2UgdGhpcyBpcyB2YWxpZCBmb3IgcHJpbnRmIGZvcm1hdCBzdHJpbmdzLlxuXG4gICBUaHVzLCB0aGUgbmV4dCBzdGVwIGZvciBTY2FuZiBpcyB0byBzdXBwb3J0IGEgZnVsbCB3aWR0aCBhbmQgcHJlY2lzaW9uXG4gICBpbmRpY2F0aW9uLCBtb3JlIG9yIGxlc3Mgc2ltaWxhciB0byB0aGUgb25lIGZvciBwcmludGYsIHBvc3NpYmx5IGV4dGVuZGVkXG4gICB0byB0aGUgc3BlY2lmaWNhdGlvbiBvZiBhIFttYXgsIG1pbl0gcmFuZ2UgZm9yIHRoZSB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZFxuICAgZm9yIHN0cmluZ3MuIFNvbWV0aGluZyBsaWtlIHRoZSBmb2xsb3dpbmcgc3BlYyBmb3Igc2NhbmYubWxpOlxuXG4gICBUaGUgb3B0aW9uYWwgW3dpZHRoXSBpcyBhbiBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIG1heGltYWxcbiAgIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkLiBGb3IgaW5zdGFuY2UsIFslNmRdIHJlYWRzIGFuIGludGVnZXIsXG4gICBoYXZpbmcgYXQgbW9zdCA2IGNoYXJhY3RlcnMuXG5cbiAgIFRoZSBvcHRpb25hbCBbcHJlY2lzaW9uXSBpcyBhIGRvdCBbLl0gZm9sbG93ZWQgYnkgYW4gaW50ZWdlcjpcblxuICAgLSBpbiB0aGUgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGNvbnZlcnNpb25zIChbJWZdLCBbJWVdLCBbJWddLCBbJUZdLCBbJUVdLFxuICAgYW5kIFslRl0gY29udmVyc2lvbnMsIHRoZSBbcHJlY2lzaW9uXSBpbmRpY2F0ZXMgdGhlIG1heGltdW0gbnVtYmVyIG9mXG4gICBkaWdpdHMgdGhhdCBtYXkgZm9sbG93IHRoZSBkZWNpbWFsIHBvaW50LiBGb3IgaW5zdGFuY2UsIFslLjRmXSByZWFkcyBhXG4gICBbZmxvYXRdIHdpdGggYXQgbW9zdCA0IGZyYWN0aW9uYWwgZGlnaXRzLFxuXG4gICAtIGluIHRoZSBzdHJpbmcgY29udmVyc2lvbnMgKFslc10sIFslU10sIFslXFxbIHJhbmdlIFxcXV0pLCBhbmQgaW4gdGhlXG4gICBpbnRlZ2VyIG51bWJlciBjb252ZXJzaW9ucyAoWyVpXSwgWyVkXSwgWyV1XSwgWyV4XSwgWyVvXSwgYW5kIHRoZWlyXG4gICBbaW50MzJdLCBbaW50NjRdLCBhbmQgW25hdGl2ZV9pbnRdIGNvcnJlc3BvbmRlbnQpLCB0aGUgW3ByZWNpc2lvbl1cbiAgIGluZGljYXRlcyB0aGUgcmVxdWlyZWQgbWluaW11bSB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZCxcblxuICAgLSBvbiBhbGwgb3RoZXIgY29udmVyc2lvbnMsIHRoZSB3aWR0aCBhbmQgcHJlY2lzaW9uIHNwZWNpZnkgdGhlIFttYXgsIG1pbl1cbiAgIHJhbmdlIGZvciB0aGUgd2lkdGggb2YgdGhlIHRva2VuIHJlYWQuXG4qKVxubGV0IHNjYW5fZmxvYXQgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9pbnRlZ2VyX3BhcnQgd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGgsIHByZWNpc2lvbiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoLCBwcmVjaXNpb24gZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnLicgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBsZXQgcHJlY2lzaW9uID0gSW50Lm1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICBsZXQgd2lkdGggPSB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2ZyYWN0aW9uYWxfcGFydCBwcmVjaXNpb24gaWIpIGluXG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliLCBwcmVjaXNpb25cbiAgfCBfIC0+XG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliLCBwcmVjaXNpb25cblxuXG5sZXQgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgZXJyb3Igc3RyID1cbiAgbGV0IGxvd2VyY2FzZSBjID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICdBJyAuLiAnWicgLT5cbiAgICAgIGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJ0EnICsgaW50X29mX2NoYXIgJ2EnKVxuICAgIHwgXyAtPiBjIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgd2lkdGggPSByZWYgd2lkdGggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIGxvd2VyY2FzZSBjIDw+IGxvd2VyY2FzZSBzdHIuW2ldIHRoZW4gZXJyb3IgKCk7XG4gICAgaWYgIXdpZHRoID0gMCB0aGVuIGVycm9yICgpO1xuICAgIHdpZHRoIDo9IFNjYW5uaW5nLnN0b3JlX2NoYXIgIXdpZHRoIGliIGM7XG4gIGRvbmU7XG4gICF3aWR0aFxuXG5cbmxldCBzY2FuX2hleF9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICB8ICcwJyBhcyBjIC0+IChcbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICBsZXQgd2lkdGggPSBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBiYWRfaGV4X2Zsb2F0IFwieFwiIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgIGxldCB3aWR0aCA9IG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJy4nIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYiBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICB8ICcuJyBhcyBjIC0+IChcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICAgICAgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IEludC5taW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgICAgICAgICAgICAgd2lkdGggLSAocHJlY2lzaW9uIC0gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgcHJlY2lzaW9uIGliKVxuICAgICAgICAgIClcbiAgICAgICAgICB8IF8gLT4gd2lkdGggaW5cbiAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgIHwgJ3AnIHwgJ1AnIGFzIGMgLT5cbiAgICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgICAgICAgICBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gICAgICAgICAgfCBfIC0+IHdpZHRoXG4gIClcbiAgfCAnbicgfCAnTicgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJhblwiXG4gIHwgJ2knIHwgJ0knIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBiYWRfaGV4X2Zsb2F0IFwibmZpbml0eVwiXG4gIHwgXyAtPiBiYWRfaGV4X2Zsb2F0ICgpXG5cblxubGV0IHNjYW5fY2FtbF9mbG9hdF9yZXN0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIGxldCB3aWR0aCA9IHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcuJyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICgqIFRoZSBlZmZlY3RpdmUgd2lkdGggYXZhaWxhYmxlIGZvciBzY2FubmluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0IGlzXG4gICAgICAgdGhlIG1pbmltdW0gb2YgZGVjbGFyZWQgcHJlY2lzaW9uIGFuZCB3aWR0aCBsZWZ0LiAqKVxuICAgIGxldCBwcmVjaXNpb24gPSBJbnQubWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgICgqIEFmdGVyIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgd2l0aCBbcHJlY2lzaW9uXSBwcm92aXNpb25hbCB3aWR0aCxcbiAgICAgICBbd2lkdGhfcHJlY2lzaW9uXSBpcyBsZWZ0LiAqKVxuICAgIGxldCB3aWR0aF9wcmVjaXNpb24gPSBzY2FuX2ZyYWN0aW9uYWxfcGFydCBwcmVjaXNpb24gaWIgaW5cbiAgICAoKiBIZW5jZSwgc2Nhbm5pbmcgdGhlIGZyYWN0aW9uYWwgcGFydCB0b29rIGV4YWN0bHlcbiAgICAgICBbcHJlY2lzaW9uIC0gd2lkdGhfcHJlY2lzaW9uXSBjaGFycy4gKilcbiAgICBsZXQgZnJhY193aWR0aCA9IHByZWNpc2lvbiAtIHdpZHRoX3ByZWNpc2lvbiBpblxuICAgICgqIEFuZCBuZXcgcHJvdmlzaW9uYWwgd2lkdGggaXMgW3dpZHRoIC0gd2lkdGhfcHJlY2lzaW9uLiAqKVxuICAgIGxldCB3aWR0aCA9IHdpZHRoIC0gZnJhY193aWR0aCBpblxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYlxuICB8ICdlJyB8ICdFJyAtPlxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYlxuICB8IF8gLT4gYmFkX2Zsb2F0ICgpXG5cblxubGV0IHNjYW5fY2FtbF9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgfCAnMCcgYXMgYyAtPiAoXG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ3gnIHwgJ1gnIGFzIGMgLT4gKFxuICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgICAgbGV0IHdpZHRoID0gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgd2lkdGggaWIgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgICBsZXQgd2lkdGggPSBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICB8ICcuJyBhcyBjIC0+IChcbiAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICAgIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IEludC5taW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgICAgICAgICAgIHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5faGV4YWRlY2ltYWxfaW50IHByZWNpc2lvbiBpYilcbiAgICAgICAgKVxuICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gYmFkX2Zsb2F0ICgpIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICB8ICdwJyB8ICdQJyBhcyBjIC0+XG4gICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgICAgICAgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICAgICAgICB8IF8gLT4gd2lkdGhcbiAgICApXG4gICAgfCBfIC0+XG4gICAgICBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWJcbiAgKVxuICB8ICcxJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliXG4oKiBTcGVjaWFsIGNhc2Ugb2YgbmFuIGFuZCBpbmZpbml0eTpcbiAgfCAnaScgLT5cbiAgfCAnbicgLT5cbiopXG4gIHwgXyAtPiBiYWRfZmxvYXQgKClcblxuXG4oKiBTY2FuIGEgcmVndWxhciBzdHJpbmc6XG4gICBzdG9wcyB3aGVuIGVuY291bnRlcmluZyBhIHNwYWNlLCBpZiBubyBzY2FubmluZyBpbmRpY2F0aW9uIGhhcyBiZWVuIGdpdmVuO1xuICAgb3RoZXJ3aXNlLCBzdG9wcyB3aGVuIGVuY291bnRlcmluZyB0aGUgY2hhcmFjdGVycyBpbiB0aGUgc2Nhbm5pbmdcbiAgIGluZGljYXRpb24gW3N0cF0uXG4gICBJdCBhbHNvIHN0b3BzIGF0IGVuZCBvZiBmaWxlIG9yIHdoZW4gdGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgaGFzXG4gICBiZWVuIHJlYWQuICopXG5sZXQgc2Nhbl9zdHJpbmcgc3RwIHdpZHRoIGliID1cbiAgbGV0IHJlYyBsb29wIHdpZHRoID1cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICBtYXRjaCBzdHAgd2l0aFxuICAgICAgfCBTb21lIGMnIHdoZW4gYyA9IGMnIC0+IFNjYW5uaW5nLnNraXBfY2hhciB3aWR0aCBpYlxuICAgICAgfCBTb21lIF8gLT4gbG9vcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgICB8ICcgJyB8ICdcXHQnIHwgJ1xcbicgfCAnXFxyJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gbG9vcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpblxuICBsb29wIHdpZHRoXG5cblxuKCogU2NhbiBhIGNoYXI6IHBlZWsgc3RyaWN0bHkgb25lIGNoYXJhY3RlciBpbiB0aGUgaW5wdXQsIHdoYXRzb2V2ZXIuICopXG5sZXQgc2Nhbl9jaGFyIHdpZHRoIGliID1cbiAgKCogVGhlIGNhc2Ugd2lkdGggPSAwIGNvdWxkIG5vdCBoYXBwZW4gaGVyZSwgc2luY2UgaXQgaXMgdGVzdGVkIGJlZm9yZVxuICAgICBjYWxsaW5nIHNjYW5fY2hhciwgaW4gdGhlIG1haW4gc2Nhbm5pbmcgZnVuY3Rpb24uXG4gICAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBcImEgY2hhcmFjdGVyXCIgZWxzZSAqKVxuICBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIChTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYilcblxuXG5sZXQgY2hhcl9mb3JfYmFja3NsYXNoID0gZnVuY3Rpb25cbiAgfCAnbicgLT4gJ1xcMDEwJ1xuICB8ICdyJyAtPiAnXFwwMTMnXG4gIHwgJ2InIC0+ICdcXDAwOCdcbiAgfCAndCcgLT4gJ1xcMDA5J1xuICB8IGMgLT4gY1xuXG5cbigqIFRoZSBpbnRlZ2VyIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZhY2lhbCB2YWx1ZSBvZiBhIHZhbGlkXG4gICBkZWNpbWFsIGRpZ2l0IGNoYXJhY3Rlci4gKilcbmxldCBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYyA9IGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnMCdcblxubGV0IGNoYXJfZm9yX2RlY2ltYWxfY29kZSBjMCBjMSBjMiA9XG4gIGxldCBjID1cbiAgICAxMDAgKiBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzAgK1xuICAgICAxMCAqIGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMSArXG4gICAgICAgICAgZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMyIGluXG4gIGlmIGMgPCAwIHx8IGMgPiAyNTUgdGhlblxuICAgIGJhZF9pbnB1dFxuICAgICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgICBcImJhZCBjaGFyYWN0ZXIgZGVjaW1hbCBlbmNvZGluZyBcXFxcJWMlYyVjXCIgYzAgYzEgYzIpIGVsc2VcbiAgY2hhcl9vZl9pbnQgY1xuXG5cbigqIFRoZSBpbnRlZ2VyIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZhY2lhbCB2YWx1ZSBvZiBhIHZhbGlkXG4gICBoZXhhZGVjaW1hbCBkaWdpdCBjaGFyYWN0ZXIuICopXG5sZXQgaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjID1cbiAgbGV0IGQgPSBpbnRfb2ZfY2hhciBjIGluXG4gICgqIENvdWxkIGFsc28gYmU6XG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnOScgdGhlbiBkIC0gaW50X29mX2NoYXIgJzAnIGVsc2VcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICdGJyB0aGVuIDEwICsgZCAtIGludF9vZl9jaGFyICdBJyBlbHNlXG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnZicgdGhlbiAxMCArIGQgLSBpbnRfb2ZfY2hhciAnYScgZWxzZSBhc3NlcnQgZmFsc2VcbiAgKilcbiAgaWYgZCA+PSBpbnRfb2ZfY2hhciAnYScgdGhlblxuICAgIGQgLSA4NyAoKiAxMCArIGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnYScgKikgZWxzZVxuICBpZiBkID49IGludF9vZl9jaGFyICdBJyB0aGVuXG4gICAgZCAtIDU1ICAoKiAxMCArIGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnQScgKikgZWxzZVxuICAgIGQgLSBpbnRfb2ZfY2hhciAnMCdcblxuXG5sZXQgY2hhcl9mb3JfaGV4YWRlY2ltYWxfY29kZSBjMSBjMiA9XG4gIGxldCBjID1cbiAgICAxNiAqIGhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzEgK1xuICAgICAgICAgaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMiBpblxuICBpZiBjIDwgMCB8fCBjID4gMjU1IHRoZW5cbiAgICBiYWRfaW5wdXRcbiAgICAgIChQcmludGYuc3ByaW50ZiBcImJhZCBjaGFyYWN0ZXIgaGV4YWRlY2ltYWwgZW5jb2RpbmcgXFxcXCVjJWNcIiBjMSBjMikgZWxzZVxuICBjaGFyX29mX2ludCBjXG5cblxuKCogQ2FsbGVkIGluIHBhcnRpY3VsYXIgd2hlbiBlbmNvdW50ZXJpbmcgJ1xcXFwnIGFzIHN0YXJ0ZXIgb2YgYSBjaGFyLlxuICAgU3RvcHMgYmVmb3JlIHRoZSBjb3JyZXNwb25kaW5nICdcXCcnLiAqKVxubGV0IGNoZWNrX25leHRfY2hhciBtZXNzYWdlIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBtZXNzYWdlIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gYmFkX2VuZF9vZl9pbnB1dCBtZXNzYWdlIGVsc2VcbiAgY1xuXG5cbmxldCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgPSBjaGVja19uZXh0X2NoYXIgXCJhIENoYXJcIlxubGV0IGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nID0gY2hlY2tfbmV4dF9jaGFyIFwiYSBTdHJpbmdcIlxuXG5sZXQgc2Nhbl9iYWNrc2xhc2hfY2hhciB3aWR0aCBpYiA9XG4gIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gIHwgJ1xcXFwnIHwgJ1xcJycgfCAnXFxcIicgfCAnbicgfCAndCcgfCAnYicgfCAncicgYXMgYyAtPlxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgKGNoYXJfZm9yX2JhY2tzbGFzaCBjKVxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCBnZXRfZGlnaXQgKCkgPVxuICAgICAgbGV0IGMgPSBTY2FubmluZy5uZXh0X2NoYXIgaWIgaW5cbiAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIGFzIGMgLT4gY1xuICAgICAgfCBjIC0+IGJhZF9pbnB1dF9lc2NhcGUgYyBpblxuICAgIGxldCBjMCA9IGMgaW5cbiAgICBsZXQgYzEgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBsZXQgYzIgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyICh3aWR0aCAtIDIpIGliIChjaGFyX2Zvcl9kZWNpbWFsX2NvZGUgYzAgYzEgYzIpXG4gIHwgJ3gnIC0+XG4gICAgbGV0IGdldF9kaWdpdCAoKSA9XG4gICAgICBsZXQgYyA9IFNjYW5uaW5nLm5leHRfY2hhciBpYiBpblxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgfCAnQScgLi4gJ0YnIHwgJ2EnIC4uICdmJyBhcyBjIC0+IGNcbiAgICAgIHwgYyAtPiBiYWRfaW5wdXRfZXNjYXBlIGMgaW5cbiAgICBsZXQgYzEgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBsZXQgYzIgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyICh3aWR0aCAtIDIpIGliIChjaGFyX2Zvcl9oZXhhZGVjaW1hbF9jb2RlIGMxIGMyKVxuICB8IGMgLT5cbiAgICBiYWRfaW5wdXRfZXNjYXBlIGNcblxuXG4oKiBTY2FuIGEgY2hhcmFjdGVyIChhbiBPQ2FtbCB0b2tlbikuICopXG5sZXQgc2Nhbl9jYW1sX2NoYXIgd2lkdGggaWIgPVxuXG4gIGxldCByZWMgZmluZF9zdGFydCB3aWR0aCA9XG4gICAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ1xcJycgLT4gZmluZF9jaGFyIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXCcnIGNcblxuICBhbmQgZmluZF9jaGFyIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcXFwnIC0+XG4gICAgICBmaW5kX3N0b3AgKHNjYW5fYmFja3NsYXNoX2NoYXIgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKSBpYilcbiAgICB8IGMgLT5cbiAgICAgIGZpbmRfc3RvcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuXG4gIGFuZCBmaW5kX3N0b3Agd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFwnJyAtPiBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYlxuICAgIHwgYyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcJycgYyBpblxuXG4gIGZpbmRfc3RhcnQgd2lkdGhcblxuXG4oKiBTY2FuIGEgZGVsaW1pdGVkIHN0cmluZyAoYW4gT0NhbWwgdG9rZW4pLiAqKVxubGV0IHNjYW5fY2FtbF9zdHJpbmcgd2lkdGggaWIgPVxuXG4gIGxldCByZWMgZmluZF9zdGFydCB3aWR0aCA9XG4gICAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ1xcXCInIC0+IGZpbmRfc3RvcCAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBjIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFxcIicgY1xuXG4gIGFuZCBmaW5kX3N0b3Agd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXFwiJyAtPiBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYlxuICAgIHwgJ1xcXFwnIC0+IHNjYW5fYmFja3NsYXNoIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gZmluZF9zdG9wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG5cbiAgYW5kIHNjYW5fYmFja3NsYXNoIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxyJyAtPiBza2lwX25ld2xpbmUgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgJ1xcbicgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3AgKHNjYW5fYmFja3NsYXNoX2NoYXIgd2lkdGggaWIpXG5cbiAgYW5kIHNraXBfbmV3bGluZSB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcbicgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgJ1xccicpXG5cbiAgYW5kIHNraXBfc3BhY2VzIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnICcgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3Agd2lkdGggaW5cblxuICBmaW5kX3N0YXJ0IHdpZHRoXG5cblxuKCogU2NhbiBhIGJvb2xlYW4gKGFuIE9DYW1sIHRva2VuKS4gKilcbmxldCBzY2FuX2Jvb2wgaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGxldCBtID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICd0JyAtPiA0XG4gICAgfCAnZicgLT4gNVxuICAgIHwgYyAtPlxuICAgICAgYmFkX2lucHV0XG4gICAgICAgIChQcmludGYuc3ByaW50ZiBcInRoZSBjaGFyYWN0ZXIgJUMgY2Fubm90IHN0YXJ0IGEgYm9vbGVhblwiIGMpIGluXG4gIHNjYW5fc3RyaW5nIE5vbmUgbSBpYlxuXG5cbigqIFNjYW4gYSBzdHJpbmcgY29udGFpbmluZyBlbGVtZW50cyBpbiBjaGFyX3NldCBhbmQgdGVybWluYXRlZCBieSBzY2FuX2luZGljXG4gICBpZiBwcm92aWRlZC4gKilcbmxldCBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IHNjYW5faW5kaWMgd2lkdGggaWIgPVxuICBsZXQgcmVjIHNjYW5fY2hhcnMgaSBzdHAgPVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgaSA+IDAgJiYgbm90IChTY2FubmluZy5lb2YgaWIpICYmXG4gICAgICAgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyAmJlxuICAgICAgIGludF9vZl9jaGFyIGMgPD4gc3RwIHRoZW5cbiAgICAgIGxldCBfID0gU2Nhbm5pbmcuc3RvcmVfY2hhciBtYXhfaW50IGliIGMgaW5cbiAgICAgIHNjYW5fY2hhcnMgKGkgLSAxKSBzdHAgaW5cbiAgbWF0Y2ggc2Nhbl9pbmRpYyB3aXRoXG4gIHwgTm9uZSAtPiBzY2FuX2NoYXJzIHdpZHRoICgtMSk7XG4gIHwgU29tZSBjIC0+XG4gICAgc2Nhbl9jaGFycyB3aWR0aCAoaW50X29mX2NoYXIgYyk7XG4gICAgaWYgbm90IChTY2FubmluZy5lb2YgaWIpIHRoZW5cbiAgICAgIGxldCBjaSA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgICAgaWYgYyA9IGNpXG4gICAgICB0aGVuIFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXG4gICAgICBlbHNlIGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpXG5cblxuKCogVGhlIGdsb2JhbCBlcnJvciByZXBvcnQgZnVuY3Rpb24gZm9yIFtTY2FuZl0uICopXG5sZXQgc2NhbmZfYmFkX2lucHV0IGliID0gZnVuY3Rpb25cbiAgfCBTY2FuX2ZhaWx1cmUgcyB8IEZhaWx1cmUgcyAtPlxuICAgIGxldCBpID0gU2Nhbm5pbmcuY2hhcl9jb3VudCBpYiBpblxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJzY2FuZjogYmFkIGlucHV0IGF0IGNoYXIgbnVtYmVyICVpOiAlc1wiIGkgcylcbiAgfCB4IC0+IHJhaXNlIHhcblxuXG4oKiBHZXQgdGhlIGNvbnRlbnQgb2YgYSBjb3VudGVyIGZyb20gYW4gaW5wdXQgYnVmZmVyLiAqKVxubGV0IGdldF9jb3VudGVyIGliIGNvdW50ZXIgPVxuICBtYXRjaCBjb3VudGVyIHdpdGhcbiAgfCBMaW5lX2NvdW50ZXIgLT4gU2Nhbm5pbmcubGluZV9jb3VudCBpYlxuICB8IENoYXJfY291bnRlciAtPiBTY2FubmluZy5jaGFyX2NvdW50IGliXG4gIHwgVG9rZW5fY291bnRlciAtPiBTY2FubmluZy50b2tlbl9jb3VudCBpYlxuXG5cbigqIENvbXB1dGUgdGhlIHdpZHRoIG9mIGEgcGFkZGluZyBvcHRpb24gKHNlZSBcIiU0MntcIiBhbmQgXCIlMTIzKFwiKS4gKilcbmxldCB3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+IG1heF9pbnRcbiAgfCBTb21lIHdpZHRoIC0+IHdpZHRoXG5cblxubGV0IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nID1cbiAgaWYgZm10aW5nID0gRXNjYXBlZF9wZXJjZW50IHRoZW4gJyUnLCBcIlwiIGVsc2VcbiAgICBsZXQgc3RyID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZyBpblxuICAgIGxldCBzdHAgPSBzdHIuWzFdIGluXG4gICAgbGV0IHN1Yl9zdHIgPSBTdHJpbmcuc3ViIHN0ciAyIChTdHJpbmcubGVuZ3RoIHN0ciAtIDIpIGluXG4gICAgc3RwLCBzdWJfc3RyXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFJlYWRlciBtYW5hZ2VtZW50ICopXG5cbigqIEEgY2FsbCB0byB0YWtlX2Zvcm1hdF9yZWFkZXJzIG9uIGEgZm9ybWF0IGlzIGV2YWx1YXRlZCBpbnRvIGZ1bmN0aW9uc1xuICAgdGFraW5nIHJlYWRlcnMgYXMgYXJndW1lbnRzIGFuZCBhZ2dyZWdhdGUgdGhlbSBpbnRvIGFuIGhldGVyb2dlbmVvdXMgbGlzdCAqKVxuKCogV2hlbiBhbGwgcmVhZGVycyBhcmUgdGFrZW4sIGZpbmFsbHkgcGFzcyB0aGUgbGlzdCBvZiB0aGUgcmVhZGVycyB0byB0aGVcbiAgIGNvbnRpbnVhdGlvbiBrLiAqKVxubGV0IHJlYyB0YWtlX2Zvcm1hdF9yZWFkZXJzIDogdHlwZSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgZCA9XG5mdW4gayBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBSZWFkZXIgZm10X3Jlc3QgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRfcmVzdFxuICB8IENoYXIgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ2FtbF9jaGFyIHJlc3QgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTdHJpbmcgKF8sIHJlc3QpICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IENhbWxfc3RyaW5nIChfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50IChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQzMiAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IE5hdGl2ZWludCAoXywgXywgXywgcmVzdCkgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50NjQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGbG9hdCAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEJvb2wgKF8sIHJlc3QpICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQWxwaGEgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBUaGV0YSByZXN0ICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZsdXNoIHJlc3QgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEN1c3RvbSAoXywgXywgcmVzdCkgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcblxuICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCwgXykpLCByZXN0KSAtPlxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10IGZtdCByZXN0KVxuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQsIF8pKSwgcmVzdCkgLT5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgayAoY29uY2F0X2ZtdCBmbXQgcmVzdClcblxuICB8IEZvcm1hdF9hcmcgKF8sIF8sIHJlc3QpICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgICAgLT5cbiAgICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKSByZXN0XG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAgICAgICAgLT4gdGFrZV9pZ25vcmVkX2Zvcm1hdF9yZWFkZXJzIGsgaWduIHJlc3RcblxuICB8IEVuZF9vZl9mb3JtYXQgICAgICAgICAgICAgICAgICAgIC0+IGsgTmlsXG5cbigqIFRha2UgcmVhZGVycyBhc3NvY2lhdGVkIHRvIGFuIGZtdHR5IGNvbWluZyBmcm9tIGEgRm9ybWF0X3N1YnN0IFwiJSguLi4lKVwiLiAqKVxuYW5kIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgOiB0eXBlIHggeSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgeCwgeSkgZm10dHkgLT5cbiAgICAgICh5LCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCB4LCBlLCBmKSBmbXQgLT4gZCA9XG5mdW4gayBmbXR0eSBmbXQgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IFJlYWRlcl90eSBmbXRfcmVzdCAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdF9yZXN0IGZtdFxuICB8IElnbm9yZWRfcmVhZGVyX3R5IGZtdF9yZXN0IC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10X3Jlc3QgZm10XG4gIHwgQ2hhcl90eSByZXN0ICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IFN0cmluZ190eSByZXN0ICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IE5hdGl2ZWludF90eSByZXN0ICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEJvb2xfdHkgcmVzdCAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBBbHBoYV90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEFueV90eSByZXN0ICAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBGb3JtYXRfYXJnX3R5IChfLCByZXN0KSAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRW5kX29mX2ZtdHR5ICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10dHkgdHkgcmVzdCkgZm10XG5cbigqIFRha2UgcmVhZGVycyBhc3NvY2lhdGVkIHRvIGFuIGlnbm9yZWQgcGFyYW1ldGVyLiAqKVxuYW5kIHRha2VfaWdub3JlZF9mb3JtYXRfcmVhZGVycyA6IHR5cGUgeCB5IGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCB4LCB5KSBpZ25vcmVkIC0+XG4gICAgICAoeSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgeCwgZSwgZikgZm10IC0+IGQgPVxuZnVuIGsgaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfcmVhZGVyIC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10XG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgZm10dHkgZm10XG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEdlbmVyaWMgc2Nhbm5pbmcgKilcblxuKCogTWFrZSBhIGdlbmVyaWMgc2Nhbm5pbmcgZnVuY3Rpb24uICopXG4oKiBTY2FuIGEgc3RyZWFtIGFjY29yZGluZyB0byBhIGZvcm1hdCBhbmQgcmVhZGVycyBvYnRhaW5lZCBieVxuICAgdGFrZV9mb3JtYXRfcmVhZGVycywgYW5kIGFnZ3JlZ2F0ZSBzY2FubmVkIHZhbHVlcyBpbnRvIGFuXG4gICBoZXRlcm9nZW5lb3VzIGxpc3QuICopXG4oKiBSZXR1cm4gdGhlIGhldGVyb2dlbmVvdXMgbGlzdCBvZiBzY2FubmVkIHZhbHVlcy4gKilcbmxldCByZWMgbWFrZV9zY2FuZiA6IHR5cGUgYSBjIGQgZSBmLlxuICAgIFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKGQsIGUpIGhldGVyX2xpc3QgLT4gKGEsIGYpIGhldGVyX2xpc3QgPVxuZnVuIGliIGZtdCByZWFkZXJzIC0+IG1hdGNoIGZtdCB3aXRoXG4gIHwgQ2hhciByZXN0IC0+XG4gICAgbGV0IF8gPSBzY2FuX2NoYXIgMCBpYiBpblxuICAgIGxldCBjID0gdG9rZW5fY2hhciBpYiBpblxuICAgIENvbnMgKGMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfY2hhciAwIGliIGluXG4gICAgbGV0IGMgPSB0b2tlbl9jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG5cbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpKSAtPlxuICAgIGxldCBzdHAsIHN0ciA9IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSBzdHApIHdpZHRoIGliIGluXG4gICAgbGV0IHN0cl9yZXN0ID0gU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiBzdHJfcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lICd7Jykgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuXG4gICAgICAgICAgICAgICAgICAgdG9rZW5fc3RyaW5nXG4gIHwgU3RyaW5nIChwYWQsIEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpKSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSAnWycpIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhblxuICAgICAgICAgICAgICAgICAgIHRva2VuX3N0cmluZ1xuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyBOb25lIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcblxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fY2FtbF9zdHJpbmcgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50IGMpXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX2ludDMyIGMpXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9uYXRpdmVpbnQgYylcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50NjQgYylcbiAgfCBGbG9hdCAoKF8sIChGbG9hdF9GIHwgRmxvYXRfQ0YpKSwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuX2NhbWxfZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBGbG9hdCAoKF8sIChGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfRykpLFxuICAgICAgICAgICBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5fZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBGbG9hdCAoKF8sIChGbG9hdF9oIHwgRmxvYXRfSCkpLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5faGV4X2Zsb2F0IHRva2VuX2Zsb2F0XG4gIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgIGxldCBzY2FuIF8gXyBpYiA9IHNjYW5fYm9vbCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fYm9vbFxuICB8IEFscGhhIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJWFcXFwiXCJcbiAgfCBUaGV0YSBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiV0XFxcIlwiXG4gIHwgQ3VzdG9tIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJT9cXFwiIChjdXN0b20gY29udmVydGVyKVwiXG4gIHwgUmVhZGVyIGZtdF9yZXN0IC0+XG4gICAgYmVnaW4gbWF0Y2ggcmVhZGVycyB3aXRoXG4gICAgfCBDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkgLT5cbiAgICAgICAgbGV0IHggPSByZWFkZXIgaWIgaW5cbiAgICAgICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXRfcmVzdCByZWFkZXJzX3Jlc3QpXG4gICAgfCBOaWwgLT5cbiAgICAgICAgaW52YWxpZF9hcmcgXCJzY2FuZjogbWlzc2luZyByZWFkZXJcIlxuICAgIGVuZFxuICB8IEZsdXNoIHJlc3QgLT5cbiAgICBpZiBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICAgIGVsc2UgYmFkX2lucHV0IFwiZW5kIG9mIGlucHV0IG5vdCBmb3VuZFwiXG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIFN0cmluZy5pdGVyIChjaGVja19jaGFyIGliKSBzdHI7XG4gICAgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnNcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliIGNocjtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuXG4gIHwgRm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nICh3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQpIGliIGluXG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgZm10ID1cbiAgICAgIHRyeSBmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IHMgZm10dHlcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZ1xuICAgIGluXG4gICAgQ29ucyAoZm10LCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX3N0cmluZyAod2lkdGhfb2ZfcGFkX29wdCBwYWRfb3B0KSBpYiBpblxuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IGZtdCwgZm10JyA9XG4gICAgICB0cnlcbiAgICAgICAgbGV0IEZtdF9FQkIgZm10ID0gZm10X2ViYl9vZl9zdHJpbmcgcyBpblxuICAgICAgICBsZXQgRm10X0VCQiBmbXQnID0gZm10X2ViYl9vZl9zdHJpbmcgcyBpblxuICAgICAgICAoKiBUT0RPOiBmaW5kIGEgd2F5IHRvIGF2b2lkIHJlcGFyc2luZyB0d2ljZSAqKVxuXG4gICAgICAgICgqIFRPRE86IHRoZXNlIHR5cGUtY2hlY2tzIGJlbG93ICpjYW4qIGZhaWwgYmVjYXVzZSBvZiB0eXBlXG4gICAgICAgICAgIGFtYmlndWl0eSBpbiBwcmVzZW5jZSBvZiBpZ25vcmVkLXJlYWRlcnM6IFwiJV9yJWRcIiBhbmQgXCIlZCVfclwiXG4gICAgICAgICAgIGFyZSB0eXBlZCBpbiB0aGUgc2FtZSB3YXkuXG5cbiAgICAgICAgICAgIyBTY2FuZi5zc2NhbmYgXCJcXFwiJV9yJWRcXFwiM1wiIFwiJSglZCVfciUpXCIgaWdub3JlXG4gICAgICAgICAgICAgKGZ1biBmbXQgbiAtPiBzdHJpbmdfb2ZfZm9ybWF0IGZtdCwgbilcbiAgICAgICAgICAgRXhjZXB0aW9uOiBDYW1saW50ZXJuYWxGb3JtYXQuVHlwZV9taXNtYXRjaC5cblxuICAgICAgICAgICBXZSBzaG91bGQgcHJvcGVybHkgY2F0Y2ggdGhpcyBleGNlcHRpb24uXG4gICAgICAgICopXG4gICAgICAgIHR5cGVfZm9ybWF0IGZtdCAoZXJhc2VfcmVsIGZtdHR5KSxcbiAgICAgICAgdHlwZV9mb3JtYXQgZm10JyAoZXJhc2VfcmVsIChzeW1tIGZtdHR5KSlcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZ1xuICAgIGluXG4gICAgQ29ucyAoRm9ybWF0IChmbXQsIHMpLFxuICAgICAgICAgIG1ha2Vfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzKVxuXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpKSAtPlxuICAgIGxldCBzdHAsIHN0ciA9IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGxldCB3aWR0aCA9IHdpZHRoX29mX3BhZF9vcHQgd2lkdGhfb3B0IGluXG4gICAgc2Nhbl9jaGFyc19pbl9jaGFyX3NldCBjaGFyX3NldCAoU29tZSBzdHApIHdpZHRoIGliO1xuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IHN0cl9yZXN0ID0gU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgaW5cbiAgICBDb25zIChzLCBtYWtlX3NjYW5mIGliIHN0cl9yZXN0IHJlYWRlcnMpXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICBsZXQgd2lkdGggPSB3aWR0aF9vZl9wYWRfb3B0IHdpZHRoX29wdCBpblxuICAgIHNjYW5fY2hhcnNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgTm9uZSB3aWR0aCBpYjtcbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIENvbnMgKHMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgbGV0IGNvdW50ID0gZ2V0X2NvdW50ZXIgaWIgY291bnRlciBpblxuICAgIENvbnMgKGNvdW50LCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICAgIENvbnMgKGMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuXG4gIHwgRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCByZXN0KSAtPlxuICAgIFN0cmluZy5pdGVyIChjaGVja19jaGFyIGliKSAoc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZvcm1hdHRpbmdfbGl0KTtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgY2hlY2tfY2hhciBpYiAnQCc7IGNoZWNrX2NoYXIgaWIgJ3snO1xuICAgIG1ha2Vfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliICdAJzsgY2hlY2tfY2hhciBpYiAnWyc7XG4gICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnNcblxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBsZXQgUGFyYW1fZm9ybWF0X0VCQiBmbXQnID0gcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IGlnbiByZXN0IGluXG4gICAgYmVnaW4gbWF0Y2ggbWFrZV9zY2FuZiBpYiBmbXQnIHJlYWRlcnMgd2l0aFxuICAgIHwgQ29ucyAoXywgYXJnX3Jlc3QpIC0+IGFyZ19yZXN0XG4gICAgfCBOaWwgLT4gYXNzZXJ0IGZhbHNlXG4gICAgZW5kXG5cbiAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgTmlsXG5cbigqIENhc2UgYW5hbHlzaXMgb24gcGFkZGluZyBhbmQgcHJlY2lzaW9uLiAqKVxuKCogUmVqZWN0IGZvcm1hdHMgY29udGFpbmluZyBcIiUqXCIgb3IgXCIlLipcIi4gKilcbigqIFBhc3MgcGFkZGluZyBhbmQgcHJlY2lzaW9uIHRvIHRoZSBnZW5lcmljIHNjYW5uZXIgYHNjYW4nLiAqKVxuYW5kIHBhZF9wcmVjX3NjYW5mIDogdHlwZSBhIGMgZCBlIGYgeCB5IHogdCAuXG4gICAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgICAoZCwgZSkgaGV0ZXJfbGlzdCAtPiAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeiAtPiBhKSBwcmVjaXNpb24gLT5cbiAgICAgIChpbnQgLT4gaW50IC0+IFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gdCkgLT5cbiAgICAgIChTY2FubmluZy5pbl9jaGFubmVsIC0+IHopIC0+XG4gICAgICAoeCwgZikgaGV0ZXJfbGlzdCA9XG5mdW4gaWIgZm10IHJlYWRlcnMgcGFkIHByZWMgc2NhbiB0b2tlbiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGxldCBfID0gc2NhbiBtYXhfaW50IG1heF9pbnQgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBsZXQgXyA9IHNjYW4gbWF4X2ludCBwIGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTGl0X3BhZGRpbmcgKChSaWdodCB8IFplcm9zKSwgdyksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGxldCBfID0gc2NhbiB3IG1heF9pbnQgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBMaXRfcGFkZGluZyAoKFJpZ2h0IHwgWmVyb3MpLCB3KSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgbGV0IF8gPSBzY2FuIHcgcCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IExpdF9wYWRkaW5nIChMZWZ0LCBfKSwgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlLVxcXCJcIlxuICB8IExpdF9wYWRkaW5nICgoUmlnaHQgfCBaZXJvcyksIF8pLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUqXFxcIlwiXG4gIHwgQXJnX3BhZGRpbmcgXywgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlKlxcXCJcIlxuICB8IE5vX3BhZGRpbmcsIEFyZ19wcmVjaXNpb24gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJSpcXFwiXCJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICgqIERlZmluaW5nIFtzY2FuZl0gYW5kIHZhcmlvdXMgZmxhdm9ycyBvZiBbc2NhbmZdICopXG5cbnR5cGUgJ2Ega3NjYW5mX3Jlc3VsdCA9IEFyZ3Mgb2YgJ2EgfCBFeGMgb2YgZXhuXG5cbmxldCBrc2NhbmYgaWIgZWYgKEZvcm1hdCAoZm10LCBzdHIpKSA9XG4gIGxldCByZWMgYXBwbHkgOiB0eXBlIGEgYiAuIGEgLT4gKGEsIGIpIGhldGVyX2xpc3QgLT4gYiA9XG4gICAgZnVuIGYgYXJncyAtPiBtYXRjaCBhcmdzIHdpdGhcbiAgICB8IENvbnMgKHgsIHIpIC0+IGFwcGx5IChmIHgpIHJcbiAgICB8IE5pbCAtPiBmXG4gIGluXG4gIGxldCBrIHJlYWRlcnMgZiA9XG4gICAgU2Nhbm5pbmcucmVzZXRfdG9rZW4gaWI7XG4gICAgbWF0Y2ggdHJ5IEFyZ3MgKG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpIHdpdGhcbiAgICAgIHwgKFNjYW5fZmFpbHVyZSBfIHwgRmFpbHVyZSBfIHwgRW5kX29mX2ZpbGUpIGFzIGV4YyAtPiBFeGMgZXhjXG4gICAgICB8IEludmFsaWRfYXJndW1lbnQgbXNnIC0+XG4gICAgICAgIGludmFsaWRfYXJnIChtc2cgXiBcIiBpbiBmb3JtYXQgXFxcIlwiIF4gU3RyaW5nLmVzY2FwZWQgc3RyIF4gXCJcXFwiXCIpXG4gICAgd2l0aFxuICAgICAgfCBBcmdzIGFyZ3MgLT4gYXBwbHkgZiBhcmdzXG4gICAgICB8IEV4YyBleGMgLT4gZWYgaWIgZXhjXG4gIGluXG4gIHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcblxuKCoqKilcblxubGV0IGtic2NhbmYgPSBrc2NhbmZcbmxldCBic2NhbmYgaWIgZm10ID0ga2JzY2FuZiBpYiBzY2FuZl9iYWRfaW5wdXQgZm10XG5cbmxldCBrc3NjYW5mIHMgZWYgZm10ID0ga2JzY2FuZiAoU2Nhbm5pbmcuZnJvbV9zdHJpbmcgcykgZWYgZm10XG5sZXQgc3NjYW5mIHMgZm10ID0ga2JzY2FuZiAoU2Nhbm5pbmcuZnJvbV9zdHJpbmcgcykgc2NhbmZfYmFkX2lucHV0IGZtdFxuXG5sZXQgc2NhbmYgZm10ID0ga3NjYW5mIFNjYW5uaW5nLnN0ZGliIHNjYW5mX2JhZF9pbnB1dCBmbXRcblxuKCoqKilcblxuKCogU2Nhbm5pbmcgZm9ybWF0IHN0cmluZ3MuICopXG5sZXQgYnNjYW5mX2Zvcm1hdCA6XG4gIFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAgKCgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICdnKSAtPiAnZyA9XG4gIGZ1biBpYiBmb3JtYXQgZiAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX3N0cmluZyBtYXhfaW50IGliIGluXG4gICAgbGV0IHN0ciA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBmbXQnID1cbiAgICAgIHRyeSBmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCBzdHIgZm9ybWF0XG4gICAgICB3aXRoIEZhaWx1cmUgbXNnIC0+IGJhZF9pbnB1dCBtc2cgaW5cbiAgICBmIGZtdCdcblxuXG5sZXQgc3NjYW5mX2Zvcm1hdCA6XG4gIHN0cmluZyAtPiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICAoKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gJ2cpIC0+ICdnID1cbiAgZnVuIHMgZm9ybWF0IGYgLT4gYnNjYW5mX2Zvcm1hdCAoU2Nhbm5pbmcuZnJvbV9zdHJpbmcgcykgZm9ybWF0IGZcblxuXG5sZXQgZm9ybWF0X2Zyb21fc3RyaW5nIHMgZm10ID1cbiAgc3NjYW5mX2Zvcm1hdCAoXCJcXFwiXCIgXiBTdHJpbmcuZXNjYXBlZCBzIF4gXCJcXFwiXCIpIGZtdCAoZnVuIHggLT4geClcblxuXG5sZXQgdW5lc2NhcGVkIHMgPVxuICBzc2NhbmYgKFwiXFxcIlwiIF4gcyBeIFwiXFxcIlwiKSBcIiVTJSFcIiAoZnVuIHggLT4geClcblxuXG4oKiBEZXByZWNhdGVkICopXG5sZXQga2ZzY2FuZiBpYyBlZiBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5tZW1vX2Zyb21fY2hhbm5lbCBpYykgZWYgZm10XG5sZXQgZnNjYW5mIGljIGZtdCA9IGtzY2FuZiAoU2Nhbm5pbmcubWVtb19mcm9tX2NoYW5uZWwgaWMpIHNjYW5mX2JhZF9pbnB1dCBmbXRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUmVnaXN0ZXJpbmcgT0NhbWwgdmFsdWVzIHdpdGggdGhlIEMgcnVudGltZSBmb3IgbGF0ZXIgY2FsbGJhY2tzICopXG5cbmV4dGVybmFsIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIDogc3RyaW5nIC0+IE9iai50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlXCJcblxubGV0IHJlZ2lzdGVyIG5hbWUgdiA9XG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIG5hbWUgKE9iai5yZXByIHYpXG5cbmxldCByZWdpc3Rlcl9leGNlcHRpb24gbmFtZSAoZXhuIDogZXhuKSA9XG4gIGxldCBleG4gPSBPYmoucmVwciBleG4gaW5cbiAgbGV0IHNsb3QgPSBpZiBPYmoudGFnIGV4biA9IE9iai5vYmplY3RfdGFnIHRoZW4gZXhuIGVsc2UgT2JqLmZpZWxkIGV4biAwIGluXG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIG5hbWUgc2xvdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgSmVyb21lIFZvdWlsbG9uLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIE9ialxuXG4oKioqKiBPYmplY3QgcmVwcmVzZW50YXRpb24gKioqKilcblxuZXh0ZXJuYWwgc2V0X2lkOiAnYSAtPiAnYSA9IFwiY2FtbF9zZXRfb29faWRcIiBbQEBub2FsbG9jXVxuXG4oKioqKiBPYmplY3QgY29weSAqKioqKVxuXG5sZXQgY29weSBvID1cbiAgbGV0IG8gPSAoT2JqLm9iaiAoT2JqLmR1cCAoT2JqLnJlcHIgbykpKSBpblxuICBzZXRfaWQgb1xuXG4oKioqKiBDb21wcmVzc2lvbiBvcHRpb25zICoqKiopXG4oKiBQYXJhbWV0ZXJzICopXG50eXBlIHBhcmFtcyA9IHtcbiAgICBtdXRhYmxlIGNvbXBhY3RfdGFibGUgOiBib29sO1xuICAgIG11dGFibGUgY29weV9wYXJlbnQgOiBib29sO1xuICAgIG11dGFibGUgY2xlYW5fd2hlbl9jb3B5aW5nIDogYm9vbDtcbiAgICBtdXRhYmxlIHJldHJ5X2NvdW50IDogaW50O1xuICAgIG11dGFibGUgYnVja2V0X3NtYWxsX3NpemUgOiBpbnRcbiAgfVxuXG5sZXQgcGFyYW1zID0ge1xuICBjb21wYWN0X3RhYmxlID0gdHJ1ZTtcbiAgY29weV9wYXJlbnQgPSB0cnVlO1xuICBjbGVhbl93aGVuX2NvcHlpbmcgPSB0cnVlO1xuICByZXRyeV9jb3VudCA9IDM7XG4gIGJ1Y2tldF9zbWFsbF9zaXplID0gMTZcbn1cblxuKCoqKiogUGFyYW1ldGVycyAqKioqKVxuXG5sZXQgaW5pdGlhbF9vYmplY3Rfc2l6ZSA9IDJcblxuKCoqKiogSXRlbXMgKioqKilcblxudHlwZSBpdGVtID0gRHVtbXlBIHwgRHVtbXlCIHwgRHVtbXlDIG9mIGludFxubGV0IF8gPSBbRHVtbXlBOyBEdW1teUI7IER1bW15QyAwXSAoKiB0byBhdm9pZCB3YXJuaW5ncyAqKVxuXG5sZXQgZHVtbXlfaXRlbSA9IChtYWdpYyAoKSA6IGl0ZW0pXG5cbigqKioqIFR5cGVzICoqKiopXG5cbnR5cGUgdGFnXG50eXBlIGxhYmVsID0gaW50XG50eXBlIGNsb3N1cmUgPSBpdGVtXG50eXBlIHQgPSBEdW1teUEgfCBEdW1teUIgfCBEdW1teUMgb2YgaW50XG5sZXQgXyA9IFtEdW1teUE7IER1bW15QjsgRHVtbXlDIDBdICgqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5cbnR5cGUgb2JqID0gdCBhcnJheVxuZXh0ZXJuYWwgcmV0IDogKG9iaiAtPiAnYSkgLT4gY2xvc3VyZSA9IFwiJWlkZW50aXR5XCJcblxuKCoqKiogTGFiZWxzICoqKiopXG5cbmxldCBwdWJsaWNfbWV0aG9kX2xhYmVsIHMgOiB0YWcgPVxuICBsZXQgYWNjdSA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgYWNjdSA6PSAyMjMgKiAhYWNjdSArIENoYXIuY29kZSBzLltpXVxuICBkb25lO1xuICAoKiByZWR1Y2UgdG8gMzEgYml0cyAqKVxuICBhY2N1IDo9ICFhY2N1IGxhbmQgKDEgbHNsIDMxIC0gMSk7XG4gICgqIG1ha2UgaXQgc2lnbmVkIGZvciA2NCBiaXRzIGFyY2hpdGVjdHVyZXMgKilcbiAgbGV0IHRhZyA9IGlmICFhY2N1ID4gMHgzRkZGRkZGRiB0aGVuICFhY2N1IC0gKDEgbHNsIDMxKSBlbHNlICFhY2N1IGluXG4gICgqIFByaW50Zi5lcHJpbnRmIFwiJXMgPSAlZFxcblwiIHMgdGFnOyBmbHVzaCBzdGRlcnI7ICopXG4gIG1hZ2ljIHRhZ1xuXG4oKioqKiBTcGFyc2UgYXJyYXkgKioqKilcblxubW9kdWxlIFZhcnMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gc3RyaW5nIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIHZhcnMgPSBpbnQgVmFycy50XG5cbm1vZHVsZSBNZXRocyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBzdHJpbmcgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgbWV0aHMgPSBsYWJlbCBNZXRocy50XG5tb2R1bGUgTGFicyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBsYWJlbCBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSBsYWJzID0gYm9vbCBMYWJzLnRcblxuKCogVGhlIGNvbXBpbGVyIGFzc3VtZXMgdGhhdCB0aGUgZmlyc3QgZmllbGQgb2YgdGhpcyBzdHJ1Y3R1cmUgaXMgW3NpemVdLiAqKVxudHlwZSB0YWJsZSA9XG4geyBtdXRhYmxlIHNpemU6IGludDtcbiAgIG11dGFibGUgbWV0aG9kczogY2xvc3VyZSBhcnJheTtcbiAgIG11dGFibGUgbWV0aG9kc19ieV9uYW1lOiBtZXRocztcbiAgIG11dGFibGUgbWV0aG9kc19ieV9sYWJlbDogbGFicztcbiAgIG11dGFibGUgcHJldmlvdXNfc3RhdGVzOlxuICAgICAobWV0aHMgKiBsYWJzICogKGxhYmVsICogaXRlbSkgbGlzdCAqIHZhcnMgKlxuICAgICAgbGFiZWwgbGlzdCAqIHN0cmluZyBsaXN0KSBsaXN0O1xuICAgbXV0YWJsZSBoaWRkZW5fbWV0aHM6IChsYWJlbCAqIGl0ZW0pIGxpc3Q7XG4gICBtdXRhYmxlIHZhcnM6IHZhcnM7XG4gICBtdXRhYmxlIGluaXRpYWxpemVyczogKG9iaiAtPiB1bml0KSBsaXN0IH1cblxubGV0IGR1bW15X3RhYmxlID1cbiAgeyBtZXRob2RzID0gW3wgZHVtbXlfaXRlbSB8XTtcbiAgICBtZXRob2RzX2J5X25hbWUgPSBNZXRocy5lbXB0eTtcbiAgICBtZXRob2RzX2J5X2xhYmVsID0gTGFicy5lbXB0eTtcbiAgICBwcmV2aW91c19zdGF0ZXMgPSBbXTtcbiAgICBoaWRkZW5fbWV0aHMgPSBbXTtcbiAgICB2YXJzID0gVmFycy5lbXB0eTtcbiAgICBpbml0aWFsaXplcnMgPSBbXTtcbiAgICBzaXplID0gMCB9XG5cbmxldCB0YWJsZV9jb3VudCA9IHJlZiAwXG5cbigqIGR1bW15X21ldCBzaG91bGQgYmUgYSBwb2ludGVyLCBzbyB1c2UgYW4gYXRvbSAqKVxubGV0IGR1bW15X21ldCA6IGl0ZW0gPSBvYmogKE9iai5uZXdfYmxvY2sgMCAwKVxuKCogaWYgZGVidWdnaW5nIGlzIG5lZWRlZCwgdGhpcyBjb3VsZCBiZSBhIGdvb2QgaWRlYTogKilcbigqIGxldCBkdW1teV9tZXQgKCkgPSBmYWlsd2l0aCBcIlVuZGVmaW5lZCBtZXRob2RcIiAqKVxuXG5sZXQgcmVjIGZpdF9zaXplIG4gPVxuICBpZiBuIDw9IDIgdGhlbiBuIGVsc2VcbiAgZml0X3NpemUgKChuKzEpLzIpICogMlxuXG5sZXQgbmV3X3RhYmxlIHB1Yl9sYWJlbHMgPVxuICBpbmNyIHRhYmxlX2NvdW50O1xuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIHB1Yl9sYWJlbHMgaW5cbiAgbGV0IG1ldGhvZHMgPSBBcnJheS5tYWtlIChsZW4qMisyKSBkdW1teV9tZXQgaW5cbiAgbWV0aG9kcy4oMCkgPC0gbWFnaWMgbGVuO1xuICBtZXRob2RzLigxKSA8LSBtYWdpYyAoZml0X3NpemUgbGVuICogU3lzLndvcmRfc2l6ZSAvIDggLSAxKTtcbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG8gbWV0aG9kcy4oaSoyKzMpIDwtIG1hZ2ljIHB1Yl9sYWJlbHMuKGkpIGRvbmU7XG4gIHsgbWV0aG9kcyA9IG1ldGhvZHM7XG4gICAgbWV0aG9kc19ieV9uYW1lID0gTWV0aHMuZW1wdHk7XG4gICAgbWV0aG9kc19ieV9sYWJlbCA9IExhYnMuZW1wdHk7XG4gICAgcHJldmlvdXNfc3RhdGVzID0gW107XG4gICAgaGlkZGVuX21ldGhzID0gW107XG4gICAgdmFycyA9IFZhcnMuZW1wdHk7XG4gICAgaW5pdGlhbGl6ZXJzID0gW107XG4gICAgc2l6ZSA9IGluaXRpYWxfb2JqZWN0X3NpemUgfVxuXG5sZXQgcmVzaXplIGFycmF5IG5ld19zaXplID1cbiAgbGV0IG9sZF9zaXplID0gQXJyYXkubGVuZ3RoIGFycmF5Lm1ldGhvZHMgaW5cbiAgaWYgbmV3X3NpemUgPiBvbGRfc2l6ZSB0aGVuIGJlZ2luXG4gICAgbGV0IG5ld19idWNrID0gQXJyYXkubWFrZSBuZXdfc2l6ZSBkdW1teV9tZXQgaW5cbiAgICBBcnJheS5ibGl0IGFycmF5Lm1ldGhvZHMgMCBuZXdfYnVjayAwIG9sZF9zaXplO1xuICAgIGFycmF5Lm1ldGhvZHMgPC0gbmV3X2J1Y2tcbiBlbmRcblxubGV0IHB1dCBhcnJheSBsYWJlbCBlbGVtZW50ID1cbiAgcmVzaXplIGFycmF5IChsYWJlbCArIDEpO1xuICBhcnJheS5tZXRob2RzLihsYWJlbCkgPC0gZWxlbWVudFxuXG4oKioqKiBDbGFzc2VzICoqKiopXG5cbmxldCBtZXRob2RfY291bnQgPSByZWYgMFxubGV0IGluc3RfdmFyX2NvdW50ID0gcmVmIDBcblxuKCogdHlwZSB0ICopXG50eXBlIG1ldGggPSBpdGVtXG5cbmxldCBuZXdfbWV0aG9kIHRhYmxlID1cbiAgbGV0IGluZGV4ID0gQXJyYXkubGVuZ3RoIHRhYmxlLm1ldGhvZHMgaW5cbiAgcmVzaXplIHRhYmxlIChpbmRleCArIDEpO1xuICBpbmRleFxuXG5sZXQgZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSBuYW1lID1cbiAgdHJ5XG4gICAgTWV0aHMuZmluZCBuYW1lIHRhYmxlLm1ldGhvZHNfYnlfbmFtZVxuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGxldCBsYWJlbCA9IG5ld19tZXRob2QgdGFibGUgaW5cbiAgICB0YWJsZS5tZXRob2RzX2J5X25hbWUgPC0gTWV0aHMuYWRkIG5hbWUgbGFiZWwgdGFibGUubWV0aG9kc19ieV9uYW1lO1xuICAgIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gTGFicy5hZGQgbGFiZWwgdHJ1ZSB0YWJsZS5tZXRob2RzX2J5X2xhYmVsO1xuICAgIGxhYmVsXG5cbmxldCBnZXRfbWV0aG9kX2xhYmVscyB0YWJsZSBuYW1lcyA9XG4gIEFycmF5Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgbmFtZXNcblxubGV0IHNldF9tZXRob2QgdGFibGUgbGFiZWwgZWxlbWVudCA9XG4gIGluY3IgbWV0aG9kX2NvdW50O1xuICBpZiBMYWJzLmZpbmQgbGFiZWwgdGFibGUubWV0aG9kc19ieV9sYWJlbCB0aGVuXG4gICAgcHV0IHRhYmxlIGxhYmVsIGVsZW1lbnRcbiAgZWxzZVxuICAgIHRhYmxlLmhpZGRlbl9tZXRocyA8LSAobGFiZWwsIGVsZW1lbnQpIDo6IHRhYmxlLmhpZGRlbl9tZXRoc1xuXG5sZXQgZ2V0X21ldGhvZCB0YWJsZSBsYWJlbCA9XG4gIHRyeSBMaXN0LmFzc29jIGxhYmVsIHRhYmxlLmhpZGRlbl9tZXRoc1xuICB3aXRoIE5vdF9mb3VuZCAtPiB0YWJsZS5tZXRob2RzLihsYWJlbClcblxubGV0IHRvX2xpc3QgYXJyID1cbiAgaWYgYXJyID09IG1hZ2ljIDAgdGhlbiBbXSBlbHNlIEFycmF5LnRvX2xpc3QgYXJyXG5cbmxldCBuYXJyb3cgdGFibGUgdmFycyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzID1cbiAgbGV0IHZhcnMgPSB0b19saXN0IHZhcnNcbiAgYW5kIHZpcnRfbWV0aHMgPSB0b19saXN0IHZpcnRfbWV0aHNcbiAgYW5kIGNvbmNyX21ldGhzID0gdG9fbGlzdCBjb25jcl9tZXRocyBpblxuICBsZXQgdmlydF9tZXRoX2xhYnMgPSBMaXN0Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgdmlydF9tZXRocyBpblxuICBsZXQgY29uY3JfbWV0aF9sYWJzID0gTGlzdC5tYXAgKGdldF9tZXRob2RfbGFiZWwgdGFibGUpIGNvbmNyX21ldGhzIGluXG4gIHRhYmxlLnByZXZpb3VzX3N0YXRlcyA8LVxuICAgICAodGFibGUubWV0aG9kc19ieV9uYW1lLCB0YWJsZS5tZXRob2RzX2J5X2xhYmVsLCB0YWJsZS5oaWRkZW5fbWV0aHMsXG4gICAgICB0YWJsZS52YXJzLCB2aXJ0X21ldGhfbGFicywgdmFycylcbiAgICAgOjogdGFibGUucHJldmlvdXNfc3RhdGVzO1xuICB0YWJsZS52YXJzIDwtXG4gICAgVmFycy5mb2xkXG4gICAgICAoZnVuIGxhYiBpbmZvIHR2YXJzIC0+XG4gICAgICAgIGlmIExpc3QubWVtIGxhYiB2YXJzIHRoZW4gVmFycy5hZGQgbGFiIGluZm8gdHZhcnMgZWxzZSB0dmFycylcbiAgICAgIHRhYmxlLnZhcnMgVmFycy5lbXB0eTtcbiAgbGV0IGJ5X25hbWUgPSByZWYgTWV0aHMuZW1wdHkgaW5cbiAgbGV0IGJ5X2xhYmVsID0gcmVmIExhYnMuZW1wdHkgaW5cbiAgTGlzdC5pdGVyMlxuICAgIChmdW4gbWV0IGxhYmVsIC0+XG4gICAgICAgYnlfbmFtZSA6PSBNZXRocy5hZGQgbWV0IGxhYmVsICFieV9uYW1lO1xuICAgICAgIGJ5X2xhYmVsIDo9XG4gICAgICAgICAgTGFicy5hZGQgbGFiZWxcbiAgICAgICAgICAgICh0cnkgTGFicy5maW5kIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgd2l0aCBOb3RfZm91bmQgLT4gdHJ1ZSlcbiAgICAgICAgICAgICFieV9sYWJlbClcbiAgICBjb25jcl9tZXRocyBjb25jcl9tZXRoX2xhYnM7XG4gIExpc3QuaXRlcjJcbiAgICAoZnVuIG1ldCBsYWJlbCAtPlxuICAgICAgIGJ5X25hbWUgOj0gTWV0aHMuYWRkIG1ldCBsYWJlbCAhYnlfbmFtZTtcbiAgICAgICBieV9sYWJlbCA6PSBMYWJzLmFkZCBsYWJlbCBmYWxzZSAhYnlfbGFiZWwpXG4gICAgdmlydF9tZXRocyB2aXJ0X21ldGhfbGFicztcbiAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtICFieV9uYW1lO1xuICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtICFieV9sYWJlbDtcbiAgdGFibGUuaGlkZGVuX21ldGhzIDwtXG4gICAgIExpc3QuZm9sZF9yaWdodFxuICAgICAgIChmdW4gKChsYWIsIF8pIGFzIG1ldCkgaG0gLT5cbiAgICAgICAgICBpZiBMaXN0Lm1lbSBsYWIgdmlydF9tZXRoX2xhYnMgdGhlbiBobSBlbHNlIG1ldDo6aG0pXG4gICAgICAgdGFibGUuaGlkZGVuX21ldGhzXG4gICAgICAgW11cblxubGV0IHdpZGVuIHRhYmxlID1cbiAgbGV0IChieV9uYW1lLCBieV9sYWJlbCwgc2F2ZWRfaGlkZGVuX21ldGhzLCBzYXZlZF92YXJzLCB2aXJ0X21ldGhzLCB2YXJzKSA9XG4gICAgTGlzdC5oZCB0YWJsZS5wcmV2aW91c19zdGF0ZXNcbiAgaW5cbiAgdGFibGUucHJldmlvdXNfc3RhdGVzIDwtIExpc3QudGwgdGFibGUucHJldmlvdXNfc3RhdGVzO1xuICB0YWJsZS52YXJzIDwtXG4gICAgIExpc3QuZm9sZF9sZWZ0XG4gICAgICAgKGZ1biBzIHYgLT4gVmFycy5hZGQgdiAoVmFycy5maW5kIHYgdGFibGUudmFycykgcylcbiAgICAgICBzYXZlZF92YXJzIHZhcnM7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSA8LSBieV9uYW1lO1xuICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIGJ5X2xhYmVsO1xuICB0YWJsZS5oaWRkZW5fbWV0aHMgPC1cbiAgICAgTGlzdC5mb2xkX3JpZ2h0XG4gICAgICAgKGZ1biAoKGxhYiwgXykgYXMgbWV0KSBobSAtPlxuICAgICAgICAgIGlmIExpc3QubWVtIGxhYiB2aXJ0X21ldGhzIHRoZW4gaG0gZWxzZSBtZXQ6OmhtKVxuICAgICAgIHRhYmxlLmhpZGRlbl9tZXRoc1xuICAgICAgIHNhdmVkX2hpZGRlbl9tZXRoc1xuXG5sZXQgbmV3X3Nsb3QgdGFibGUgPVxuICBsZXQgaW5kZXggPSB0YWJsZS5zaXplIGluXG4gIHRhYmxlLnNpemUgPC0gaW5kZXggKyAxO1xuICBpbmRleFxuXG5sZXQgbmV3X3ZhcmlhYmxlIHRhYmxlIG5hbWUgPVxuICB0cnkgVmFycy5maW5kIG5hbWUgdGFibGUudmFyc1xuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGxldCBpbmRleCA9IG5ld19zbG90IHRhYmxlIGluXG4gICAgaWYgbmFtZSA8PiBcIlwiIHRoZW4gdGFibGUudmFycyA8LSBWYXJzLmFkZCBuYW1lIGluZGV4IHRhYmxlLnZhcnM7XG4gICAgaW5kZXhcblxubGV0IHRvX2FycmF5IGFyciA9XG4gIGlmIGFyciA9IE9iai5tYWdpYyAwIHRoZW4gW3x8XSBlbHNlIGFyclxuXG5sZXQgbmV3X21ldGhvZHNfdmFyaWFibGVzIHRhYmxlIG1ldGhzIHZhbHMgPVxuICBsZXQgbWV0aHMgPSB0b19hcnJheSBtZXRocyBpblxuICBsZXQgbm1ldGhzID0gQXJyYXkubGVuZ3RoIG1ldGhzIGFuZCBudmFscyA9IEFycmF5Lmxlbmd0aCB2YWxzIGluXG4gIGxldCByZXMgPSBBcnJheS5tYWtlIChubWV0aHMgKyBudmFscykgMCBpblxuICBmb3IgaSA9IDAgdG8gbm1ldGhzIC0gMSBkb1xuICAgIHJlcy4oaSkgPC0gZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSBtZXRocy4oaSlcbiAgZG9uZTtcbiAgZm9yIGkgPSAwIHRvIG52YWxzIC0gMSBkb1xuICAgIHJlcy4oaStubWV0aHMpIDwtIG5ld192YXJpYWJsZSB0YWJsZSB2YWxzLihpKVxuICBkb25lO1xuICByZXNcblxubGV0IGdldF92YXJpYWJsZSB0YWJsZSBuYW1lID1cbiAgdHJ5IFZhcnMuZmluZCBuYW1lIHRhYmxlLnZhcnMgd2l0aCBOb3RfZm91bmQgLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBnZXRfdmFyaWFibGVzIHRhYmxlIG5hbWVzID1cbiAgQXJyYXkubWFwIChnZXRfdmFyaWFibGUgdGFibGUpIG5hbWVzXG5cbmxldCBhZGRfaW5pdGlhbGl6ZXIgdGFibGUgZiA9XG4gIHRhYmxlLmluaXRpYWxpemVycyA8LSBmOjp0YWJsZS5pbml0aWFsaXplcnNcblxuKCpcbm1vZHVsZSBLZXlzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IHRhZyBhcnJheSBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxubGV0IGtleV9tYXAgPSByZWYgS2V5cy5lbXB0eVxubGV0IGdldF9rZXkgdGFncyA6IGl0ZW0gPVxuICB0cnkgbWFnaWMgKEtleXMuZmluZCB0YWdzICFrZXlfbWFwIDogdGFnIGFycmF5KVxuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGtleV9tYXAgOj0gS2V5cy5hZGQgdGFncyB0YWdzICFrZXlfbWFwO1xuICAgIG1hZ2ljIHRhZ3NcbiopXG5cbmxldCBjcmVhdGVfdGFibGUgcHVibGljX21ldGhvZHMgPVxuICBpZiBwdWJsaWNfbWV0aG9kcyA9PSBtYWdpYyAwIHRoZW4gbmV3X3RhYmxlIFt8fF0gZWxzZVxuICAoKiBbcHVibGljX21ldGhvZHNdIG11c3QgYmUgaW4gYXNjZW5kaW5nIG9yZGVyIGZvciBieXRlY29kZSAqKVxuICBsZXQgdGFncyA9IEFycmF5Lm1hcCBwdWJsaWNfbWV0aG9kX2xhYmVsIHB1YmxpY19tZXRob2RzIGluXG4gIGxldCB0YWJsZSA9IG5ld190YWJsZSB0YWdzIGluXG4gIEFycmF5Lml0ZXJpXG4gICAgKGZ1biBpIG1ldCAtPlxuICAgICAgbGV0IGxhYiA9IGkqMisyIGluXG4gICAgICB0YWJsZS5tZXRob2RzX2J5X25hbWUgIDwtIE1ldGhzLmFkZCBtZXQgbGFiIHRhYmxlLm1ldGhvZHNfYnlfbmFtZTtcbiAgICAgIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gTGFicy5hZGQgbGFiIHRydWUgdGFibGUubWV0aG9kc19ieV9sYWJlbClcbiAgICBwdWJsaWNfbWV0aG9kcztcbiAgdGFibGVcblxubGV0IGluaXRfY2xhc3MgdGFibGUgPVxuICBpbnN0X3Zhcl9jb3VudCA6PSAhaW5zdF92YXJfY291bnQgKyB0YWJsZS5zaXplIC0gMTtcbiAgdGFibGUuaW5pdGlhbGl6ZXJzIDwtIExpc3QucmV2IHRhYmxlLmluaXRpYWxpemVycztcbiAgcmVzaXplIHRhYmxlICgzICsgbWFnaWMgdGFibGUubWV0aG9kcy4oMSkgKiAxNiAvIFN5cy53b3JkX3NpemUpXG5cbmxldCBpbmhlcml0cyBjbGEgdmFscyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzIChfLCBzdXBlciwgXywgZW52KSB0b3AgPVxuICBuYXJyb3cgY2xhIHZhbHMgdmlydF9tZXRocyBjb25jcl9tZXRocztcbiAgbGV0IGluaXQgPVxuICAgIGlmIHRvcCB0aGVuIHN1cGVyIGNsYSBlbnYgZWxzZSBPYmoucmVwciAoc3VwZXIgY2xhKSBpblxuICB3aWRlbiBjbGE7XG4gIEFycmF5LmNvbmNhdFxuICAgIFtbfCByZXByIGluaXQgfF07XG4gICAgIG1hZ2ljIChBcnJheS5tYXAgKGdldF92YXJpYWJsZSBjbGEpICh0b19hcnJheSB2YWxzKSA6IGludCBhcnJheSk7XG4gICAgIEFycmF5Lm1hcFxuICAgICAgIChmdW4gbm0gLT4gcmVwciAoZ2V0X21ldGhvZCBjbGEgKGdldF9tZXRob2RfbGFiZWwgY2xhIG5tKSA6IGNsb3N1cmUpKVxuICAgICAgICh0b19hcnJheSBjb25jcl9tZXRocykgXVxuXG5sZXQgbWFrZV9jbGFzcyBwdWJfbWV0aHMgY2xhc3NfaW5pdCA9XG4gIGxldCB0YWJsZSA9IGNyZWF0ZV90YWJsZSBwdWJfbWV0aHMgaW5cbiAgbGV0IGVudl9pbml0ID0gY2xhc3NfaW5pdCB0YWJsZSBpblxuICBpbml0X2NsYXNzIHRhYmxlO1xuICAoZW52X2luaXQgKE9iai5yZXByIDApLCBjbGFzc19pbml0LCBlbnZfaW5pdCwgT2JqLnJlcHIgMClcblxudHlwZSBpbml0X3RhYmxlID0geyBtdXRhYmxlIGVudl9pbml0OiB0OyBtdXRhYmxlIGNsYXNzX2luaXQ6IHRhYmxlIC0+IHQgfVxuW0BAd2FybmluZyBcIi11bnVzZWQtZmllbGRcIl1cblxubGV0IG1ha2VfY2xhc3Nfc3RvcmUgcHViX21ldGhzIGNsYXNzX2luaXQgaW5pdF90YWJsZSA9XG4gIGxldCB0YWJsZSA9IGNyZWF0ZV90YWJsZSBwdWJfbWV0aHMgaW5cbiAgbGV0IGVudl9pbml0ID0gY2xhc3NfaW5pdCB0YWJsZSBpblxuICBpbml0X2NsYXNzIHRhYmxlO1xuICBpbml0X3RhYmxlLmNsYXNzX2luaXQgPC0gY2xhc3NfaW5pdDtcbiAgaW5pdF90YWJsZS5lbnZfaW5pdCA8LSBlbnZfaW5pdFxuXG5sZXQgZHVtbXlfY2xhc3MgbG9jID1cbiAgbGV0IHVuZGVmID0gZnVuIF8gLT4gcmFpc2UgKFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlIGxvYykgaW5cbiAgKE9iai5tYWdpYyB1bmRlZiwgdW5kZWYsIHVuZGVmLCBPYmoucmVwciAwKVxuXG4oKioqKiBPYmplY3RzICoqKiopXG5cbmxldCBjcmVhdGVfb2JqZWN0IHRhYmxlID1cbiAgKCogWFhYIEFwcGVsIGRlIFtvYmpfYmxvY2tdIHwgQ2FsbCB0byBbb2JqX2Jsb2NrXSAgKilcbiAgbGV0IG9iaiA9IE9iai5uZXdfYmxvY2sgT2JqLm9iamVjdF90YWcgdGFibGUuc2l6ZSBpblxuICAoKiBYWFggQXBwZWwgZGUgW2NhbWxfbW9kaWZ5XSB8IENhbGwgdG8gW2NhbWxfbW9kaWZ5XSAqKVxuICBPYmouc2V0X2ZpZWxkIG9iaiAwIChPYmoucmVwciB0YWJsZS5tZXRob2RzKTtcbiAgT2JqLm9iaiAoc2V0X2lkIG9iailcblxubGV0IGNyZWF0ZV9vYmplY3Rfb3B0IG9ial8wIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqXzAgZWxzZSBiZWdpblxuICAgICgqIFhYWCBBcHBlbCBkZSBbb2JqX2Jsb2NrXSB8IENhbGwgdG8gW29ial9ibG9ja10gICopXG4gICAgbGV0IG9iaiA9IE9iai5uZXdfYmxvY2sgT2JqLm9iamVjdF90YWcgdGFibGUuc2l6ZSBpblxuICAgICgqIFhYWCBBcHBlbCBkZSBbY2FtbF9tb2RpZnldIHwgQ2FsbCB0byBbY2FtbF9tb2RpZnldICopXG4gICAgT2JqLnNldF9maWVsZCBvYmogMCAoT2JqLnJlcHIgdGFibGUubWV0aG9kcyk7XG4gICAgT2JqLm9iaiAoc2V0X2lkIG9iailcbiAgZW5kXG5cbmxldCByZWMgaXRlcl9mIG9iaiA9XG4gIGZ1bmN0aW9uXG4gICAgW10gICAtPiAoKVxuICB8IGY6OmwgLT4gZiBvYmo7IGl0ZXJfZiBvYmogbFxuXG5sZXQgcnVuX2luaXRpYWxpemVycyBvYmogdGFibGUgPVxuICBsZXQgaW5pdHMgPSB0YWJsZS5pbml0aWFsaXplcnMgaW5cbiAgaWYgaW5pdHMgPD4gW10gdGhlblxuICAgIGl0ZXJfZiBvYmogaW5pdHNcblxubGV0IHJ1bl9pbml0aWFsaXplcnNfb3B0IG9ial8wIG9iaiB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9iaiBlbHNlIGJlZ2luXG4gICAgbGV0IGluaXRzID0gdGFibGUuaW5pdGlhbGl6ZXJzIGluXG4gICAgaWYgaW5pdHMgPD4gW10gdGhlbiBpdGVyX2Ygb2JqIGluaXRzO1xuICAgIG9ialxuICBlbmRcblxubGV0IGNyZWF0ZV9vYmplY3RfYW5kX3J1bl9pbml0aWFsaXplcnMgb2JqXzAgdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmpfMCBlbHNlIGJlZ2luXG4gICAgbGV0IG9iaiA9IGNyZWF0ZV9vYmplY3QgdGFibGUgaW5cbiAgICBydW5faW5pdGlhbGl6ZXJzIG9iaiB0YWJsZTtcbiAgICBvYmpcbiAgZW5kXG5cbigqIEVxdWl2YWxlbnQgcHJpbWl0aXZlIGJlbG93XG5sZXQgc2VuZHNlbGYgb2JqIGxhYiA9XG4gIChtYWdpYyBvYmogOiAob2JqIC0+IHQpIGFycmF5IGFycmF5KS4oMCkuKGxhYikgb2JqXG4qKVxuZXh0ZXJuYWwgc2VuZCA6IG9iaiAtPiB0YWcgLT4gJ2EgPSBcIiVzZW5kXCJcbmV4dGVybmFsIHNlbmRjYWNoZSA6IG9iaiAtPiB0YWcgLT4gdCAtPiBpbnQgLT4gJ2EgPSBcIiVzZW5kY2FjaGVcIlxuZXh0ZXJuYWwgc2VuZHNlbGYgOiBvYmogLT4gbGFiZWwgLT4gJ2EgPSBcIiVzZW5kc2VsZlwiXG5leHRlcm5hbCBnZXRfcHVibGljX21ldGhvZCA6IG9iaiAtPiB0YWcgLT4gY2xvc3VyZVxuICAgID0gXCJjYW1sX2dldF9wdWJsaWNfbWV0aG9kXCIgW0BAbm9hbGxvY11cblxuKCoqKiogdGFibGUgY29sbGVjdGlvbiBhY2Nlc3MgKioqKilcblxudHlwZSB0YWJsZXMgPVxuICB8IEVtcHR5XG4gIHwgQ29ucyBvZiB7a2V5IDogY2xvc3VyZTsgbXV0YWJsZSBkYXRhOiB0YWJsZXM7IG11dGFibGUgbmV4dDogdGFibGVzfVxuXG5sZXQgc2V0X2RhdGEgdGFibGVzIHYgPSBtYXRjaCB0YWJsZXMgd2l0aFxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5kYXRhIDwtIHZcbmxldCBzZXRfbmV4dCB0YWJsZXMgdiA9IG1hdGNoIHRhYmxlcyB3aXRoXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLm5leHQgPC0gdlxubGV0IGdldF9rZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5rZXlcbmxldCBnZXRfZGF0YSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmRhdGFcbmxldCBnZXRfbmV4dCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLm5leHRcblxubGV0IGJ1aWxkX3BhdGggbiBrZXlzIHRhYmxlcyA9XG4gIGxldCByZXMgPSBDb25zIHtrZXkgPSBPYmoubWFnaWMgMDsgZGF0YSA9IEVtcHR5OyBuZXh0ID0gRW1wdHl9IGluXG4gIGxldCByID0gcmVmIHJlcyBpblxuICBmb3IgaSA9IDAgdG8gbiBkb1xuICAgIHIgOj0gQ29ucyB7a2V5ID0ga2V5cy4oaSk7IGRhdGEgPSAhcjsgbmV4dCA9IEVtcHR5fVxuICBkb25lO1xuICBzZXRfZGF0YSB0YWJsZXMgIXI7XG4gIHJlc1xuXG5sZXQgcmVjIGxvb2t1cF9rZXlzIGkga2V5cyB0YWJsZXMgPVxuICBpZiBpIDwgMCB0aGVuIHRhYmxlcyBlbHNlXG4gIGxldCBrZXkgPSBrZXlzLihpKSBpblxuICBsZXQgcmVjIGxvb2t1cF9rZXkgKHRhYmxlczp0YWJsZXMpID1cbiAgICBpZiBnZXRfa2V5IHRhYmxlcyA9PSBrZXkgdGhlblxuICAgICAgbWF0Y2ggZ2V0X2RhdGEgdGFibGVzIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IENvbnMgXyBhcyB0YWJsZXNfZGF0YSAtPlxuICAgICAgICAgIGxvb2t1cF9rZXlzIChpLTEpIGtleXMgdGFibGVzX2RhdGFcbiAgICBlbHNlXG4gICAgICBtYXRjaCBnZXRfbmV4dCB0YWJsZXMgd2l0aFxuICAgICAgfCBDb25zIF8gYXMgbmV4dCAtPiBsb29rdXBfa2V5IG5leHRcbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBsZXQgbmV4dCA6IHRhYmxlcyA9IENvbnMge2tleTsgZGF0YSA9IEVtcHR5OyBuZXh0ID0gRW1wdHl9IGluXG4gICAgICAgICAgc2V0X25leHQgdGFibGVzIG5leHQ7XG4gICAgICAgICAgYnVpbGRfcGF0aCAoaS0xKSBrZXlzIG5leHRcbiAgaW5cbiAgbG9va3VwX2tleSB0YWJsZXNcblxubGV0IGxvb2t1cF90YWJsZXMgcm9vdCBrZXlzID1cbiAgbWF0Y2ggZ2V0X2RhdGEgcm9vdCB3aXRoXG4gIHwgQ29ucyBfIGFzIHJvb3RfZGF0YSAtPlxuICAgIGxvb2t1cF9rZXlzIChBcnJheS5sZW5ndGgga2V5cyAtIDEpIGtleXMgcm9vdF9kYXRhXG4gIHwgRW1wdHkgLT5cbiAgICBidWlsZF9wYXRoIChBcnJheS5sZW5ndGgga2V5cyAtIDEpIGtleXMgcm9vdFxuXG4oKioqKiBidWlsdGluIG1ldGhvZHMgKioqKilcblxubGV0IGdldF9jb25zdCB4ID0gcmV0IChmdW4gX29iaiAtPiB4KVxubGV0IGdldF92YXIgbiAgID0gcmV0IChmdW4gb2JqIC0+IEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pXG5sZXQgZ2V0X2VudiBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKVxubGV0IGdldF9tZXRoIG4gID0gcmV0IChmdW4gb2JqIC0+IHNlbmRzZWxmIG9iaiBuKVxubGV0IHNldF92YXIgbiAgID0gcmV0IChmdW4gb2JqIHggLT4gQXJyYXkudW5zYWZlX3NldCBvYmogbiB4KVxubGV0IGFwcF9jb25zdCBmIHggPSByZXQgKGZ1biBfb2JqIC0+IGYgeClcbmxldCBhcHBfdmFyIGYgbiAgID0gcmV0IChmdW4gb2JqIC0+IGYgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pKVxubGV0IGFwcF9lbnYgZiBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSlcbmxldCBhcHBfbWV0aCBmIG4gID0gcmV0IChmdW4gb2JqIC0+IGYgKHNlbmRzZWxmIG9iaiBuKSlcbmxldCBhcHBfY29uc3RfY29uc3QgZiB4IHkgPSByZXQgKGZ1biBfb2JqIC0+IGYgeCB5KVxubGV0IGFwcF9jb25zdF92YXIgZiB4IG4gICA9IHJldCAoZnVuIG9iaiAtPiBmIHggKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pKVxubGV0IGFwcF9jb25zdF9tZXRoIGYgeCBuID0gcmV0IChmdW4gb2JqIC0+IGYgeCAoc2VuZHNlbGYgb2JqIG4pKVxubGV0IGFwcF92YXJfY29uc3QgZiBuIHggPSByZXQgKGZ1biBvYmogLT4gZiAoQXJyYXkudW5zYWZlX2dldCBvYmogbikgeClcbmxldCBhcHBfbWV0aF9jb25zdCBmIG4geCA9IHJldCAoZnVuIG9iaiAtPiBmIChzZW5kc2VsZiBvYmogbikgeClcbmxldCBhcHBfY29uc3RfZW52IGYgeCBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIHggKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pKVxubGV0IGFwcF9lbnZfY29uc3QgZiBlIG4geCA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pIHgpXG5sZXQgbWV0aF9hcHBfY29uc3QgbiB4ID0gcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgeClcbmxldCBtZXRoX2FwcF92YXIgbiBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG0pKVxubGV0IG1ldGhfYXBwX2VudiBuIGUgbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pXG4gICAgICAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbSkpXG5sZXQgbWV0aF9hcHBfbWV0aCBuIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSAoc2VuZHNlbGYgb2JqIG0pKVxubGV0IHNlbmRfY29uc3QgbSB4IGMgPVxuICByZXQgKGZ1biBvYmogLT4gc2VuZGNhY2hlIHggbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX3ZhciBtIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZSAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSA6IG9iaikgbVxuICAgICAgKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF9lbnYgbSBlIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZVxuICAgICAgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldFxuICAgICAgICAgICAgICAgICAgICAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikgOiBvYmopXG4gICAgICBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfbWV0aCBtIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZSAoc2VuZHNlbGYgb2JqIG4pIG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgbmV3X2NhY2hlIHRhYmxlID1cbiAgbGV0IG4gPSBuZXdfbWV0aG9kIHRhYmxlIGluXG4gIGxldCBuID1cbiAgICBpZiBuIG1vZCAyID0gMCB8fCBuID4gMiArIG1hZ2ljIHRhYmxlLm1ldGhvZHMuKDEpICogMTYgLyBTeXMud29yZF9zaXplXG4gICAgdGhlbiBuIGVsc2UgbmV3X21ldGhvZCB0YWJsZVxuICBpblxuICB0YWJsZS5tZXRob2RzLihuKSA8LSBPYmoubWFnaWMgMDtcbiAgblxuXG50eXBlIGltcGwgPVxuICAgIEdldENvbnN0XG4gIHwgR2V0VmFyXG4gIHwgR2V0RW52XG4gIHwgR2V0TWV0aFxuICB8IFNldFZhclxuICB8IEFwcENvbnN0XG4gIHwgQXBwVmFyXG4gIHwgQXBwRW52XG4gIHwgQXBwTWV0aFxuICB8IEFwcENvbnN0Q29uc3RcbiAgfCBBcHBDb25zdFZhclxuICB8IEFwcENvbnN0RW52XG4gIHwgQXBwQ29uc3RNZXRoXG4gIHwgQXBwVmFyQ29uc3RcbiAgfCBBcHBFbnZDb25zdFxuICB8IEFwcE1ldGhDb25zdFxuICB8IE1ldGhBcHBDb25zdFxuICB8IE1ldGhBcHBWYXJcbiAgfCBNZXRoQXBwRW52XG4gIHwgTWV0aEFwcE1ldGhcbiAgfCBTZW5kQ29uc3RcbiAgfCBTZW5kVmFyXG4gIHwgU2VuZEVudlxuICB8IFNlbmRNZXRoXG4gIHwgQ2xvc3VyZSBvZiBjbG9zdXJlXG5cbmxldCBtZXRob2RfaW1wbCB0YWJsZSBpIGFyciA9XG4gIGxldCBuZXh0ICgpID0gaW5jciBpOyBtYWdpYyBhcnIuKCFpKSBpblxuICBtYXRjaCBuZXh0KCkgd2l0aFxuICAgIEdldENvbnN0IC0+IGxldCB4IDogdCA9IG5leHQoKSBpbiBnZXRfY29uc3QgeFxuICB8IEdldFZhciAgIC0+IGxldCBuID0gbmV4dCgpIGluIGdldF92YXIgblxuICB8IEdldEVudiAgIC0+IGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGdldF9lbnYgZSBuXG4gIHwgR2V0TWV0aCAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X21ldGggblxuICB8IFNldFZhciAgIC0+IGxldCBuID0gbmV4dCgpIGluIHNldF92YXIgblxuICB8IEFwcENvbnN0IC0+IGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGFwcF9jb25zdCBmIHhcbiAgfCBBcHBWYXIgICAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gYXBwX3ZhciBmIG5cbiAgfCBBcHBFbnYgICAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gIGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfZW52IGYgZSBuXG4gIHwgQXBwTWV0aCAgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIGFwcF9tZXRoIGYgblxuICB8IEFwcENvbnN0Q29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCB5ID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfY29uc3QgZiB4IHlcbiAgfCBBcHBDb25zdFZhciAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF92YXIgZiB4IG5cbiAgfCBBcHBDb25zdEVudiAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0ICgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfZW52IGYgeCBlIG5cbiAgfCBBcHBDb25zdE1ldGggLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfbWV0aCBmIHggblxuICB8IEFwcFZhckNvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX3Zhcl9jb25zdCBmIG4geFxuICB8IEFwcEVudkNvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQgKCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9lbnZfY29uc3QgZiBlIG4geFxuICB8IEFwcE1ldGhDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9tZXRoX2NvbnN0IGYgbiB4XG4gIHwgTWV0aEFwcENvbnN0IC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBtZXRoX2FwcF9jb25zdCBuIHhcbiAgfCBNZXRoQXBwVmFyIC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpbiBtZXRoX2FwcF92YXIgbiBtXG4gIHwgTWV0aEFwcEVudiAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW5cbiAgICAgIG1ldGhfYXBwX2VudiBuIGUgbVxuICB8IE1ldGhBcHBNZXRoIC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpbiBtZXRoX2FwcF9tZXRoIG4gbVxuICB8IFNlbmRDb25zdCAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gc2VuZF9jb25zdCBtIHggKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kVmFyIC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gc2VuZF92YXIgbSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZEVudiAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIHNlbmRfZW52IG0gZSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZE1ldGggLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBzZW5kX21ldGggbSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgQ2xvc3VyZSBfIGFzIGNsbyAtPiBtYWdpYyBjbG9cblxubGV0IHNldF9tZXRob2RzIHRhYmxlIG1ldGhvZHMgPVxuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIG1ldGhvZHMgaW4gbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IGxlbiBkb1xuICAgIGxldCBsYWJlbCA9IG1ldGhvZHMuKCFpKSBpbiBsZXQgY2xvID0gbWV0aG9kX2ltcGwgdGFibGUgaSBtZXRob2RzIGluXG4gICAgc2V0X21ldGhvZCB0YWJsZSBsYWJlbCBjbG87XG4gICAgaW5jciBpXG4gIGRvbmVcblxuKCoqKiogU3RhdGlzdGljcyAqKioqKVxuXG50eXBlIHN0YXRzID1cbiAgeyBjbGFzc2VzOiBpbnQ7IG1ldGhvZHM6IGludDsgaW5zdF92YXJzOiBpbnQ7IH1cblxubGV0IHN0YXRzICgpID1cbiAgeyBjbGFzc2VzID0gIXRhYmxlX2NvdW50O1xuICAgIG1ldGhvZHMgPSAhbWV0aG9kX2NvdW50OyBpbnN0X3ZhcnMgPSAhaW5zdF92YXJfY291bnQ7IH1cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBYYXZpZXIgTGVyb3kgYW5kIERhbWllbiBEb2xpZ2V6LCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGdlbmVyaWNfcXVvdGUgcXVvdGVxdW90ZSBzID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChsICsgMjApIGluXG4gIEJ1ZmZlci5hZGRfY2hhciBiICdcXCcnO1xuICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICBpZiBzLltpXSA9ICdcXCcnXG4gICAgdGhlbiBCdWZmZXIuYWRkX3N0cmluZyBiIHF1b3RlcXVvdGVcbiAgICBlbHNlIEJ1ZmZlci5hZGRfY2hhciBiICBzLltpXVxuICBkb25lO1xuICBCdWZmZXIuYWRkX2NoYXIgYiAnXFwnJztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1sxXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Jhc2VuYW1lLmh0bWxcbiAgSW4gc3RlcCAxIG9mIFtbMV1dLCB3ZSBjaG9vc2UgdG8gcmV0dXJuIFwiLlwiIGZvciBlbXB0eSBpbnB1dC5cbiAgICAoZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBPQ2FtbClcbiAgSW4gc3RlcCAyLCB3ZSBjaG9vc2UgdG8gcHJvY2VzcyBcIi8vXCIgbm9ybWFsbHkuXG4gIFN0ZXAgNiBpcyBub3QgaW1wbGVtZW50ZWQ6IHdlIGNvbnNpZGVyIHRoYXQgdGhlIFtzdWZmaXhdIG9wZXJhbmQgaXNcbiAgICBhbHdheXMgYWJzZW50LiAgU3VmZml4ZXMgYXJlIGhhbmRsZWQgYnkgW2Nob3Bfc3VmZml4XSBhbmQgW2Nob3BfZXh0ZW5zaW9uXS5cbiopXG5sZXQgZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgbmFtZSA9XG4gIGxldCByZWMgZmluZF9lbmQgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGZpbmRfZW5kIChuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIG4gKG4gKyAxKVxuICBhbmQgZmluZF9iZWcgbiBwID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIHBcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gU3RyaW5nLnN1YiBuYW1lIChuICsgMSkgKHAgLSBuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIChuIC0gMSkgcFxuICBpblxuICBpZiBuYW1lID0gXCJcIlxuICB0aGVuIGN1cnJlbnRfZGlyX25hbWVcbiAgZWxzZSBmaW5kX2VuZCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1syXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Rpcm5hbWUuaHRtbFxuICBJbiBzdGVwIDYgb2YgW1syXV0sIHdlIGNob29zZSB0byBwcm9jZXNzIFwiLy9cIiBub3JtYWxseS5cbiopXG5sZXQgZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBuYW1lID1cbiAgbGV0IHJlYyB0cmFpbGluZ19zZXAgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIHRyYWlsaW5nX3NlcCAobiAtIDEpXG4gICAgZWxzZSBiYXNlIG5cbiAgYW5kIGJhc2UgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGludGVybWVkaWF0ZV9zZXAgblxuICAgIGVsc2UgYmFzZSAobiAtIDEpXG4gIGFuZCBpbnRlcm1lZGlhdGVfc2VwIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgMVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBpbnRlcm1lZGlhdGVfc2VwIChuIC0gMSlcbiAgICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChuICsgMSlcbiAgaW5cbiAgaWYgbmFtZSA9IFwiXCJcbiAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gIGVsc2UgdHJhaWxpbmdfc2VwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5tb2R1bGUgdHlwZSBTWVNERVBTID0gc2lnXG4gIHZhbCBudWxsIDogc3RyaW5nXG4gIHZhbCBjdXJyZW50X2Rpcl9uYW1lIDogc3RyaW5nXG4gIHZhbCBwYXJlbnRfZGlyX25hbWUgOiBzdHJpbmdcbiAgdmFsIGRpcl9zZXAgOiBzdHJpbmdcbiAgdmFsIGlzX2Rpcl9zZXAgOiBzdHJpbmcgLT4gaW50IC0+IGJvb2xcbiAgdmFsIGlzX3JlbGF0aXZlIDogc3RyaW5nIC0+IGJvb2xcbiAgdmFsIGlzX2ltcGxpY2l0IDogc3RyaW5nIC0+IGJvb2xcbiAgdmFsIGNoZWNrX3N1ZmZpeCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbFxuICB2YWwgY2hvcF9zdWZmaXhfb3B0IDogc3VmZml4OnN0cmluZyAtPiBzdHJpbmcgLT4gc3RyaW5nIG9wdGlvblxuICB2YWwgdGVtcF9kaXJfbmFtZSA6IHN0cmluZ1xuICB2YWwgcXVvdGUgOiBzdHJpbmcgLT4gc3RyaW5nXG4gIHZhbCBxdW90ZV9jb21tYW5kIDpcbiAgICBzdHJpbmcgLT4gP3N0ZGluOiBzdHJpbmcgLT4gP3N0ZG91dDogc3RyaW5nIC0+ID9zdGRlcnI6IHN0cmluZ1xuICAgICAgICAgICAtPiBzdHJpbmcgbGlzdCAtPiBzdHJpbmdcbiAgdmFsIGJhc2VuYW1lIDogc3RyaW5nIC0+IHN0cmluZ1xuICB2YWwgZGlybmFtZSA6IHN0cmluZyAtPiBzdHJpbmdcbmVuZFxuXG5tb2R1bGUgVW5peCA6IFNZU0RFUFMgPSBzdHJ1Y3RcbiAgbGV0IG51bGwgPSBcIi9kZXYvbnVsbFwiXG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiL1wiXG4gIGxldCBpc19kaXJfc2VwIHMgaSA9IHMuW2ldID0gJy8nXG4gIGxldCBpc19yZWxhdGl2ZSBuID0gU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnLydcbiAgbGV0IGlzX2ltcGxpY2l0IG4gPVxuICAgIGlzX3JlbGF0aXZlIG5cbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi4vXCIpXG4gIGxldCBjaGVja19zdWZmaXggbmFtZSBzdWZmID1cbiAgICBTdHJpbmcuZW5kc193aXRoIH5zdWZmaXg6c3VmZiBuYW1lXG5cbiAgbGV0IGNob3Bfc3VmZml4X29wdCB+c3VmZml4IGZpbGVuYW1lID1cbiAgICBsZXQgbGVuX3MgPSBTdHJpbmcubGVuZ3RoIHN1ZmZpeCBhbmQgbGVuX2YgPSBTdHJpbmcubGVuZ3RoIGZpbGVuYW1lIGluXG4gICAgaWYgbGVuX2YgPj0gbGVuX3MgdGhlblxuICAgICAgbGV0IHIgPSBTdHJpbmcuc3ViIGZpbGVuYW1lIChsZW5fZiAtIGxlbl9zKSBsZW5fcyBpblxuICAgICAgaWYgciA9IHN1ZmZpeCB0aGVuXG4gICAgICAgIFNvbWUgKFN0cmluZy5zdWIgZmlsZW5hbWUgMCAobGVuX2YgLSBsZW5fcykpXG4gICAgICBlbHNlXG4gICAgICAgIE5vbmVcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbiAgbGV0IHRlbXBfZGlyX25hbWUgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiVE1QRElSXCIgd2l0aCBOb3RfZm91bmQgLT4gXCIvdG1wXCJcbiAgbGV0IHF1b3RlID0gZ2VuZXJpY19xdW90ZSBcIidcXFxcJydcIlxuICBsZXQgcXVvdGVfY29tbWFuZCBjbWQgP3N0ZGluID9zdGRvdXQgP3N0ZGVyciBhcmdzID1cbiAgICBTdHJpbmcuY29uY2F0IFwiIFwiIChMaXN0Lm1hcCBxdW90ZSAoY21kIDo6IGFyZ3MpKVxuICAgIF4gKG1hdGNoIHN0ZGluICB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA8XCIgXiBxdW90ZSBmKVxuICAgIF4gKG1hdGNoIHN0ZG91dCB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA+XCIgXiBxdW90ZSBmKVxuICAgIF4gKG1hdGNoIHN0ZGVyciB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBpZiBzdGRlcnIgPSBzdGRvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gXCIgMj4mMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIFwiIDI+XCIgXiBxdW90ZSBmKVxuICBsZXQgYmFzZW5hbWUgPSBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuICBsZXQgZGlybmFtZSA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbmVuZFxuXG5tb2R1bGUgV2luMzIgOiBTWVNERVBTID0gc3RydWN0XG4gIGxldCBudWxsID0gXCJOVUxcIlxuICBsZXQgY3VycmVudF9kaXJfbmFtZSA9IFwiLlwiXG4gIGxldCBwYXJlbnRfZGlyX25hbWUgPSBcIi4uXCJcbiAgbGV0IGRpcl9zZXAgPSBcIlxcXFxcIlxuICBsZXQgaXNfZGlyX3NlcCBzIGkgPSBsZXQgYyA9IHMuW2ldIGluIGMgPSAnLycgfHwgYyA9ICdcXFxcJyB8fCBjID0gJzonXG4gIGxldCBpc19yZWxhdGl2ZSBuID1cbiAgICAoU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnLycpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJ1xcXFwnKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IG4uWzFdIDw+ICc6JylcbiAgbGV0IGlzX2ltcGxpY2l0IG4gPVxuICAgIGlzX3JlbGF0aXZlIG5cbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLlxcXFxcIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uXFxcXFwiKVxuICBsZXQgY2hlY2tfc3VmZml4IG5hbWUgc3VmZiA9XG4gICBTdHJpbmcubGVuZ3RoIG5hbWUgPj0gU3RyaW5nLmxlbmd0aCBzdWZmICYmXG4gICAobGV0IHMgPSBTdHJpbmcuc3ViIG5hbWUgKFN0cmluZy5sZW5ndGggbmFtZSAtIFN0cmluZy5sZW5ndGggc3VmZilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoU3RyaW5nLmxlbmd0aCBzdWZmKSBpblxuICAgIFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgcyA9IFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgc3VmZilcblxuICBsZXQgY2hvcF9zdWZmaXhfb3B0IH5zdWZmaXggZmlsZW5hbWUgPVxuICAgIGxldCBsZW5fcyA9IFN0cmluZy5sZW5ndGggc3VmZml4IGFuZCBsZW5fZiA9IFN0cmluZy5sZW5ndGggZmlsZW5hbWUgaW5cbiAgICBpZiBsZW5fZiA+PSBsZW5fcyB0aGVuXG4gICAgICBsZXQgciA9IFN0cmluZy5zdWIgZmlsZW5hbWUgKGxlbl9mIC0gbGVuX3MpIGxlbl9zIGluXG4gICAgICBpZiBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHIgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHN1ZmZpeCB0aGVuXG4gICAgICAgIFNvbWUgKFN0cmluZy5zdWIgZmlsZW5hbWUgMCAobGVuX2YgLSBsZW5fcykpXG4gICAgICBlbHNlXG4gICAgICAgIE5vbmVcbiAgICBlbHNlXG4gICAgICBOb25lXG5cblxuICBsZXQgdGVtcF9kaXJfbmFtZSA9XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJURU1QXCIgd2l0aCBOb3RfZm91bmQgLT4gXCIuXCJcbiAgbGV0IHF1b3RlIHMgPVxuICAgIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChsICsgMjApIGluXG4gICAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInO1xuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBsIHRoZW4gQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInIGVsc2VcbiAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgIHwgJ1xcXCInIC0+IGxvb3BfYnMgMCBpO1xuICAgICAgfCAnXFxcXCcgLT4gbG9vcF9icyAwIGk7XG4gICAgICB8IGMgICAgLT4gQnVmZmVyLmFkZF9jaGFyIGIgYzsgbG9vcCAoaSsxKTtcbiAgICBhbmQgbG9vcF9icyBuIGkgPVxuICAgICAgaWYgaSA9IGwgdGhlbiBiZWdpblxuICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7XG4gICAgICAgIGFkZF9icyBuO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgICB8ICdcXFwiJyAtPiBhZGRfYnMgKDIqbisxKTsgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInOyBsb29wIChpKzEpO1xuICAgICAgICB8ICdcXFxcJyAtPiBsb29wX2JzIChuKzEpIChpKzEpO1xuICAgICAgICB8IF8gICAgLT4gYWRkX2JzIG47IGxvb3AgaVxuICAgICAgZW5kXG4gICAgYW5kIGFkZF9icyBuID0gZm9yIF9qID0gMSB0byBuIGRvIEJ1ZmZlci5hZGRfY2hhciBiICdcXFxcJzsgZG9uZVxuICAgIGluXG4gICAgbG9vcCAwO1xuICAgIEJ1ZmZlci5jb250ZW50cyBiXG4oKlxuUXVvdGluZyBjb21tYW5kcyBmb3IgZXhlY3V0aW9uIGJ5IGNtZC5leGUgaXMgZGlmZmljdWx0LlxuMS0gRWFjaCBhcmd1bWVudCBpcyBmaXJzdCBxdW90ZWQgdXNpbmcgdGhlIFwicXVvdGVcIiBmdW5jdGlvbiBhYm92ZSwgdG9cbiAgIHByb3RlY3QgaXQgYWdhaW5zdCB0aGUgcHJvY2Vzc2luZyBwZXJmb3JtZWQgYnkgdGhlIEMgcnVudGltZSBzeXN0ZW0sXG4gICB0aGVuIGNtZC5leGUncyBzcGVjaWFsIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQgd2l0aCAnXicsIHVzaW5nXG4gICB0aGUgXCJxdW90ZV9jbWRcIiBmdW5jdGlvbiBiZWxvdy4gIEZvciBtb3JlIGRldGFpbHMsIHNlZVxuICAgaHR0cHM6Ly9ibG9ncy5tc2RuLm1pY3Jvc29mdC5jb20vdHdpc3R5bGl0dGxlcGFzc2FnZXNhbGxhbGlrZS8yMDExLzA0LzIzXG4yLSBUaGUgY29tbWFuZCBhbmQgdGhlIHJlZGlyZWN0aW9uIGZpbGVzLCBpZiBhbnksIG11c3QgYmUgZG91YmxlLXF1b3RlZFxuICAgaW4gY2FzZSB0aGV5IGNvbnRhaW4gc3BhY2VzLiAgVGhpcyBxdW90aW5nIGlzIGludGVycHJldGVkIGJ5IGNtZC5leGUsXG4gICBub3QgYnkgdGhlIEMgcnVudGltZSBzeXN0ZW0sIGhlbmNlIHRoZSBcInF1b3RlXCIgZnVuY3Rpb24gYWJvdmVcbiAgIGNhbm5vdCBiZSB1c2VkLiAgVGhlIHR3byBjaGFyYWN0ZXJzIHdlIGRvbid0IGtub3cgaG93IHRvIHF1b3RlXG4gICBpbnNpZGUgYSBkb3VibGUtcXVvdGVkIGNtZC5leGUgc3RyaW5nIGFyZSBkb3VibGUtcXVvdGUgYW5kIHBlcmNlbnQuXG4gICBXZSBqdXN0IGZhaWwgaWYgdGhlIGNvbW1hbmQgbmFtZSBvciB0aGUgcmVkaXJlY3Rpb24gZmlsZSBuYW1lc1xuICAgY29udGFpbiBhIGRvdWJsZSBxdW90ZSAobm90IGFsbG93ZWQgaW4gV2luZG93cyBmaWxlIG5hbWVzLCBhbnl3YXkpXG4gICBvciBhIHBlcmNlbnQuICBTZWUgZnVuY3Rpb24gXCJxdW90ZV9jbWRfZmlsZW5hbWVcIiBiZWxvdy5cbjMtIFRoZSB3aG9sZSBzdHJpbmcgcGFzc2VkIHRvIFN5cy5jb21tYW5kIGlzIHRoZW4gZW5jbG9zZWQgaW4gZG91YmxlXG4gICBxdW90ZXMsIHdoaWNoIGFyZSBpbW1lZGlhdGVseSBzdHJpcHBlZCBieSBjbWQuZXhlLiAgT3RoZXJ3aXNlLFxuICAgc29tZSBvZiB0aGUgZG91YmxlIHF1b3RlcyBmcm9tIHN0ZXAgMiBhYm92ZSBjYW4gYmUgbWlzcGFyc2VkLlxuICAgU2VlIGUuZy4gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzk5NjUxNDFcbiopXG4gIGxldCBxdW90ZV9jbWQgcyA9XG4gICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChTdHJpbmcubGVuZ3RoIHMgKyAyMCkgaW5cbiAgICBTdHJpbmcuaXRlclxuICAgICAgKGZ1biBjIC0+XG4gICAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgICB8ICcoJyB8ICcpJyB8ICchJyB8ICdeJyB8ICclJyB8ICdcXFwiJyB8ICc8JyB8ICc+JyB8ICcmJyB8ICd8JyAtPlxuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgJ14nOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgYylcbiAgICAgIHM7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJcbiAgbGV0IHF1b3RlX2NtZF9maWxlbmFtZSBmID1cbiAgICBpZiBTdHJpbmcuY29udGFpbnMgZiAnXFxcIicgfHwgU3RyaW5nLmNvbnRhaW5zIGYgJyUnIHRoZW5cbiAgICAgIGZhaWx3aXRoIChcIkZpbGVuYW1lLnF1b3RlX2NvbW1hbmQ6IGJhZCBmaWxlIG5hbWUgXCIgXiBmKVxuICAgIGVsc2UgaWYgU3RyaW5nLmNvbnRhaW5zIGYgJyAnIHRoZW5cbiAgICAgIFwiXFxcIlwiIF4gZiBeIFwiXFxcIlwiXG4gICAgZWxzZVxuICAgICAgZlxuICAoKiBSZWRpcmVjdGlvbnMgaW4gY21kLmV4ZTogc2VlIGh0dHBzOi8vc3M2NC5jb20vbnQvc3ludGF4LXJlZGlyZWN0aW9uLmh0bWxcbiAgICAgYW5kIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3ByZXZpb3VzLXZlcnNpb25zL3dpbmRvd3MvaXQtcHJvL3dpbmRvd3MteHAvYmI0OTA5ODIodj10ZWNobmV0LjEwKVxuICAqKVxuICBsZXQgcXVvdGVfY29tbWFuZCBjbWQgP3N0ZGluID9zdGRvdXQgP3N0ZGVyciBhcmdzID1cbiAgICBTdHJpbmcuY29uY2F0IFwiXCIgW1xuICAgICAgXCJcXFwiXCI7XG4gICAgICBxdW90ZV9jbWRfZmlsZW5hbWUgY21kO1xuICAgICAgXCIgXCI7XG4gICAgICBxdW90ZV9jbWQgKFN0cmluZy5jb25jYXQgXCIgXCIgKExpc3QubWFwIHF1b3RlIGFyZ3MpKTtcbiAgICAgIChtYXRjaCBzdGRpbiAgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gXCIgPFwiIF4gcXVvdGVfY21kX2ZpbGVuYW1lIGYpO1xuICAgICAgKG1hdGNoIHN0ZG91dCB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA+XCIgXiBxdW90ZV9jbWRfZmlsZW5hbWUgZik7XG4gICAgICAobWF0Y2ggc3RkZXJyIHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgc3RkZXJyID0gc3Rkb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiBcIiAyPiYxXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIFwiIDI+XCIgXiBxdW90ZV9jbWRfZmlsZW5hbWUgZik7XG4gICAgICBcIlxcXCJcIlxuICAgIF1cbiAgbGV0IGhhc19kcml2ZSBzID1cbiAgICBsZXQgaXNfbGV0dGVyID0gZnVuY3Rpb25cbiAgICAgIHwgJ0EnIC4uICdaJyB8ICdhJyAuLiAneicgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG4gICAgaW5cbiAgICBTdHJpbmcubGVuZ3RoIHMgPj0gMiAmJiBpc19sZXR0ZXIgcy5bMF0gJiYgcy5bMV0gPSAnOidcbiAgbGV0IGRyaXZlX2FuZF9wYXRoIHMgPVxuICAgIGlmIGhhc19kcml2ZSBzXG4gICAgdGhlbiAoU3RyaW5nLnN1YiBzIDAgMiwgU3RyaW5nLnN1YiBzIDIgKFN0cmluZy5sZW5ndGggcyAtIDIpKVxuICAgIGVsc2UgKFwiXCIsIHMpXG4gIGxldCBkaXJuYW1lIHMgPVxuICAgIGxldCAoZHJpdmUsIHBhdGgpID0gZHJpdmVfYW5kX3BhdGggcyBpblxuICAgIGxldCBkaXIgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIHBhdGggaW5cbiAgICBkcml2ZSBeIGRpclxuICBsZXQgYmFzZW5hbWUgcyA9XG4gICAgbGV0IChfZHJpdmUsIHBhdGgpID0gZHJpdmVfYW5kX3BhdGggcyBpblxuICAgIGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIHBhdGhcbmVuZFxuXG5tb2R1bGUgQ3lnd2luIDogU1lTREVQUyA9IHN0cnVjdFxuICBsZXQgbnVsbCA9IFwiL2Rldi9udWxsXCJcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCIvXCJcbiAgbGV0IGlzX2Rpcl9zZXAgPSBXaW4zMi5pc19kaXJfc2VwXG4gIGxldCBpc19yZWxhdGl2ZSA9IFdpbjMyLmlzX3JlbGF0aXZlXG4gIGxldCBpc19pbXBsaWNpdCA9IFdpbjMyLmlzX2ltcGxpY2l0XG4gIGxldCBjaGVja19zdWZmaXggPSBXaW4zMi5jaGVja19zdWZmaXhcbiAgbGV0IGNob3Bfc3VmZml4X29wdCA9IFdpbjMyLmNob3Bfc3VmZml4X29wdFxuICBsZXQgdGVtcF9kaXJfbmFtZSA9IFVuaXgudGVtcF9kaXJfbmFtZVxuICBsZXQgcXVvdGUgPSBVbml4LnF1b3RlXG4gIGxldCBxdW90ZV9jb21tYW5kID0gVW5peC5xdW90ZV9jb21tYW5kXG4gIGxldCBiYXNlbmFtZSA9IGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG4gIGxldCBkaXJuYW1lID0gZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuZW5kXG5cbm1vZHVsZSBTeXNkZXBzID1cbiAgKHZhbCAobWF0Y2ggU3lzLm9zX3R5cGUgd2l0aFxuICAgICAgIHwgXCJXaW4zMlwiIC0+IChtb2R1bGUgV2luMzI6IFNZU0RFUFMpXG4gICAgICAgfCBcIkN5Z3dpblwiIC0+IChtb2R1bGUgQ3lnd2luOiBTWVNERVBTKVxuICAgICAgIHwgXyAtPiAobW9kdWxlIFVuaXg6IFNZU0RFUFMpKSlcblxuaW5jbHVkZSBTeXNkZXBzXG5cbmxldCBjb25jYXQgZGlybmFtZSBmaWxlbmFtZSA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBkaXJuYW1lIGluXG4gIGlmIGwgPSAwIHx8IGlzX2Rpcl9zZXAgZGlybmFtZSAobC0xKVxuICB0aGVuIGRpcm5hbWUgXiBmaWxlbmFtZVxuICBlbHNlIGRpcm5hbWUgXiBkaXJfc2VwIF4gZmlsZW5hbWVcblxubGV0IGNob3Bfc3VmZml4IG5hbWUgc3VmZiA9XG4gIGlmIGNoZWNrX3N1ZmZpeCBuYW1lIHN1ZmZcbiAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gU3RyaW5nLmxlbmd0aCBzdWZmKVxuICBlbHNlIGludmFsaWRfYXJnIFwiRmlsZW5hbWUuY2hvcF9zdWZmaXhcIlxuXG5sZXQgZXh0ZW5zaW9uX2xlbiBuYW1lID1cbiAgbGV0IHJlYyBjaGVjayBpMCBpID1cbiAgICBpZiBpIDwgMCB8fCBpc19kaXJfc2VwIG5hbWUgaSB0aGVuIDBcbiAgICBlbHNlIGlmIG5hbWUuW2ldID0gJy4nIHRoZW4gY2hlY2sgaTAgKGkgLSAxKVxuICAgIGVsc2UgU3RyaW5nLmxlbmd0aCBuYW1lIC0gaTBcbiAgaW5cbiAgbGV0IHJlYyBzZWFyY2hfZG90IGkgPVxuICAgIGlmIGkgPCAwIHx8IGlzX2Rpcl9zZXAgbmFtZSBpIHRoZW4gMFxuICAgIGVsc2UgaWYgbmFtZS5baV0gPSAnLicgdGhlbiBjaGVjayBpIChpIC0gMSlcbiAgICBlbHNlIHNlYXJjaF9kb3QgKGkgLSAxKVxuICBpblxuICBzZWFyY2hfZG90IChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5sZXQgZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIFwiXCIgZWxzZSBTdHJpbmcuc3ViIG5hbWUgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpIGxcblxubGV0IGNob3BfZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIGludmFsaWRfYXJnIFwiRmlsZW5hbWUuY2hvcF9leHRlbnNpb25cIlxuICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKVxuXG5sZXQgcmVtb3ZlX2V4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBuYW1lIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpXG5cbmV4dGVybmFsIG9wZW5fZGVzYzogc3RyaW5nIC0+IG9wZW5fZmxhZyBsaXN0IC0+IGludCAtPiBpbnQgPSBcImNhbWxfc3lzX29wZW5cIlxuZXh0ZXJuYWwgY2xvc2VfZGVzYzogaW50IC0+IHVuaXQgPSBcImNhbWxfc3lzX2Nsb3NlXCJcblxubGV0IHBybmcgPSBsYXp5KFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCAoKSlcblxubGV0IHRlbXBfZmlsZV9uYW1lIHRlbXBfZGlyIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcm5kID0gKFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpKSBsYW5kIDB4RkZGRkZGIGluXG4gIGNvbmNhdCB0ZW1wX2RpciAoUHJpbnRmLnNwcmludGYgXCIlcyUwNnglc1wiIHByZWZpeCBybmQgc3VmZml4KVxuXG5cbmxldCBjdXJyZW50X3RlbXBfZGlyX25hbWUgPSByZWYgdGVtcF9kaXJfbmFtZVxuXG5sZXQgc2V0X3RlbXBfZGlyX25hbWUgcyA9IGN1cnJlbnRfdGVtcF9kaXJfbmFtZSA6PSBzXG5sZXQgZ2V0X3RlbXBfZGlyX25hbWUgKCkgPSAhY3VycmVudF90ZW1wX2Rpcl9uYW1lXG5cbmxldCB0ZW1wX2ZpbGUgPyh0ZW1wX2RpciA9ICFjdXJyZW50X3RlbXBfZGlyX25hbWUpIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcmVjIHRyeV9uYW1lIGNvdW50ZXIgPVxuICAgIGxldCBuYW1lID0gdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCBpblxuICAgIHRyeVxuICAgICAgY2xvc2VfZGVzYyhvcGVuX2Rlc2MgbmFtZSBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fZXhjbF0gMG82MDApO1xuICAgICAgbmFtZVxuICAgIHdpdGggU3lzX2Vycm9yIF8gYXMgZSAtPlxuICAgICAgaWYgY291bnRlciA+PSAxMDAwIHRoZW4gcmFpc2UgZSBlbHNlIHRyeV9uYW1lIChjb3VudGVyICsgMSlcbiAgaW4gdHJ5X25hbWUgMFxuXG5sZXQgb3Blbl90ZW1wX2ZpbGUgPyhtb2RlID0gW09wZW5fdGV4dF0pID8ocGVybXMgPSAwbzYwMClcbiAgICAgICAgICAgICAgICAgICA/KHRlbXBfZGlyID0gIWN1cnJlbnRfdGVtcF9kaXJfbmFtZSkgcHJlZml4IHN1ZmZpeCA9XG4gIGxldCByZWMgdHJ5X25hbWUgY291bnRlciA9XG4gICAgbGV0IG5hbWUgPSB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4IGluXG4gICAgdHJ5XG4gICAgICAobmFtZSxcbiAgICAgICBvcGVuX291dF9nZW4gKE9wZW5fd3Jvbmx5OjpPcGVuX2NyZWF0OjpPcGVuX2V4Y2w6Om1vZGUpIHBlcm1zIG5hbWUpXG4gICAgd2l0aCBTeXNfZXJyb3IgXyBhcyBlIC0+XG4gICAgICBpZiBjb3VudGVyID49IDEwMDAgdGhlbiByYWlzZSBlIGVsc2UgdHJ5X25hbWUgKGNvdW50ZXIgKyAxKVxuICBpbiB0cnlfbmFtZSAwXG4iLCJtb2R1bGUgR2VuZXJhbCA9IHN0cnVjdFxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IElucmlhLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgICAgICopXG4oKiAgIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExpYnJhcnkgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIsIHdpdGggYSAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nLCBhcyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuKCogTGlzdHMuICopXG5cbmxldCByZWMgdGFrZSBuIHhzID1cbiAgbWF0Y2ggbiwgeHMgd2l0aFxuICB8IDAsIF9cbiAgfCBfLCBbXSAtPlxuICAgICAgW11cbiAgfCBfLCAoeCA6OiB4cyBhcyBpbnB1dCkgLT5cbiAgICAgbGV0IHhzJyA9IHRha2UgKG4gLSAxKSB4cyBpblxuICAgICBpZiB4cyA9PSB4cycgdGhlblxuICAgICAgIGlucHV0XG4gICAgIGVsc2VcbiAgICAgICB4IDo6IHhzJ1xuXG5sZXQgcmVjIGRyb3AgbiB4cyA9XG4gIG1hdGNoIG4sIHhzIHdpdGhcbiAgfCAwLCBfIC0+XG4gICAgICB4c1xuICB8IF8sIFtdIC0+XG4gICAgICBbXVxuICB8IF8sIF8gOjogeHMgLT5cbiAgICAgIGRyb3AgKG4gLSAxKSB4c1xuXG5sZXQgcmVjIHVuaXExIGNtcCB4IHlzID1cbiAgbWF0Y2ggeXMgd2l0aFxuICB8IFtdIC0+XG4gICAgICBbXVxuICB8IHkgOjogeXMgLT5cbiAgICAgIGlmIGNtcCB4IHkgPSAwIHRoZW5cbiAgICAgICAgdW5pcTEgY21wIHggeXNcbiAgICAgIGVsc2VcbiAgICAgICAgeSA6OiB1bmlxMSBjbXAgeSB5c1xuXG5sZXQgdW5pcSBjbXAgeHMgPVxuICBtYXRjaCB4cyB3aXRoXG4gIHwgW10gLT5cbiAgICAgIFtdXG4gIHwgeCA6OiB4cyAtPlxuICAgICAgeCA6OiB1bmlxMSBjbXAgeCB4c1xuXG5sZXQgd2VlZCBjbXAgeHMgPVxuICB1bmlxIGNtcCAoTGlzdC5zb3J0IGNtcCB4cylcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbigqIFN0cmVhbXMuICopXG5cbnR5cGUgJ2Egc3RyZWFtID1cbiAgICAnYSBoZWFkIExhenkudFxuXG5hbmQgJ2EgaGVhZCA9XG4gIHwgTmlsXG4gIHwgQ29ucyBvZiAnYSAqICdhIHN0cmVhbVxuXG4oKiBUaGUgbGVuZ3RoIG9mIGEgc3RyZWFtLiAqKVxuXG5sZXQgcmVjIGxlbmd0aCB4cyA9XG4gIG1hdGNoIExhenkuZm9yY2UgeHMgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgMFxuICB8IENvbnMgKF8sIHhzKSAtPlxuICAgICAgMSArIGxlbmd0aCB4c1xuXG4oKiBGb2xkaW5nIG92ZXIgYSBzdHJlYW0uICopXG5cbmxldCByZWMgZm9sZHIgZiB4cyBhY2N1ID1cbiAgbWF0Y2ggTGF6eS5mb3JjZSB4cyB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBhY2N1XG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBmIHggKGZvbGRyIGYgeHMgYWNjdSlcbmVuZFxubW9kdWxlIENvbnZlcnQgPSBzdHJ1Y3RcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCBJbnJpYS4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyICAgICAqKVxuKCogICB0aGUgdGVybXMgb2YgdGhlIEdOVSBMaWJyYXJ5IEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLCB3aXRoIGEgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZywgYXMgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQW4gb2NhbWx5YWNjLXN0eWxlLCBvciBNZW5oaXItc3R5bGUsIHBhcnNlciByZXF1aXJlcyBhY2Nlc3MgdG9cbiAgIHRoZSBsZXhlciwgd2hpY2ggbXVzdCBiZSBwYXJhbWV0ZXJpemVkIHdpdGggYSBsZXhpbmcgYnVmZmVyLCBhbmRcbiAgIHRvIHRoZSBsZXhpbmcgYnVmZmVyIGl0c2VsZiwgd2hlcmUgaXQgcmVhZHMgcG9zaXRpb24gaW5mb3JtYXRpb24uICopXG5cbigqIFRoaXMgdHJhZGl0aW9uYWwgQVBJIGlzIGNvbnZlbmllbnQgd2hlbiB1c2VkIHdpdGggb2NhbWxsZXgsIGJ1dFxuICAgaW5lbGVnYW50IHdoZW4gdXNlZCB3aXRoIG90aGVyIGxleGVyIGdlbmVyYXRvcnMuICopXG5cbnR5cGUgKCd0b2tlbiwgJ3NlbWFudGljX3ZhbHVlKSB0cmFkaXRpb25hbCA9XG4gICAgKExleGluZy5sZXhidWYgLT4gJ3Rva2VuKSAtPiBMZXhpbmcubGV4YnVmIC0+ICdzZW1hbnRpY192YWx1ZVxuXG4oKiBUaGlzIHJldmlzZWQgQVBJIGlzIGluZGVwZW5kZW50IG9mIGFueSBsZXhlciBnZW5lcmF0b3IuIEhlcmUsIHRoZVxuICAgcGFyc2VyIG9ubHkgcmVxdWlyZXMgYWNjZXNzIHRvIHRoZSBsZXhlciwgYW5kIHRoZSBsZXhlciB0YWtlcyBub1xuICAgcGFyYW1ldGVycy4gVGhlIHRva2VucyByZXR1cm5lZCBieSB0aGUgbGV4ZXIgbWF5IGNvbnRhaW4gcG9zaXRpb25cbiAgIGluZm9ybWF0aW9uLiAqKVxuXG50eXBlICgndG9rZW4sICdzZW1hbnRpY192YWx1ZSkgcmV2aXNlZCA9XG4gICAgKHVuaXQgLT4gJ3Rva2VuKSAtPiAnc2VtYW50aWNfdmFsdWVcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbigqIENvbnZlcnRpbmcgYSB0cmFkaXRpb25hbCBwYXJzZXIsIHByb2R1Y2VkIGJ5IG9jYW1seWFjYyBvciBNZW5oaXIsXG4gICBpbnRvIGEgcmV2aXNlZCBwYXJzZXIuICopXG5cbigqIEEgdG9rZW4gb2YgdGhlIHJldmlzZWQgbGV4ZXIgaXMgZXNzZW50aWFsbHkgYSB0cmlwbGUgb2YgYSB0b2tlblxuICAgb2YgdGhlIHRyYWRpdGlvbmFsIGxleGVyIChvciByYXcgdG9rZW4pLCBhIHN0YXJ0IHBvc2l0aW9uLCBhbmRcbiAgIGFuZCBlbmQgcG9zaXRpb24uIFRoZSB0aHJlZSBbZ2V0XSBmdW5jdGlvbnMgYXJlIGFjY2Vzc29ycy4gKilcblxuKCogV2UgZG8gbm90IHJlcXVpcmUgdGhlIHR5cGUgWyd0b2tlbl0gdG8gYWN0dWFsbHkgYmUgYSB0cmlwbGUgdHlwZS5cbiAgIFRoaXMgZW5hYmxlcyBjb21wbGV4IGFwcGxpY2F0aW9ucyB3aGVyZSBpdCBpcyBhIHJlY29yZCB0eXBlIHdpdGhcbiAgIG1vcmUgdGhhbiB0aHJlZSBmaWVsZHMuIEl0IGFsc28gZW5hYmxlcyBzaW1wbGUgYXBwbGljYXRpb25zIHdoZXJlXG4gICBwb3NpdGlvbnMgYXJlIG9mIG5vIGludGVyZXN0LCBzbyBbJ3Rva2VuXSBpcyBqdXN0IFsncmF3X3Rva2VuXVxuICAgYW5kIFtnZXRfc3RhcnRwXSBhbmQgW2dldF9lbmRwXSByZXR1cm4gZHVtbXkgcG9zaXRpb25zLiAqKVxuXG5sZXQgdHJhZGl0aW9uYWwycmV2aXNlZFxuICAoZ2V0X3Jhd190b2tlbiA6ICd0b2tlbiAtPiAncmF3X3Rva2VuKVxuICAoZ2V0X3N0YXJ0cCAgICA6ICd0b2tlbiAtPiBMZXhpbmcucG9zaXRpb24pXG4gIChnZXRfZW5kcCAgICAgIDogJ3Rva2VuIC0+IExleGluZy5wb3NpdGlvbilcbiAgKHBhcnNlciA6ICgncmF3X3Rva2VuLCAnc2VtYW50aWNfdmFsdWUpIHRyYWRpdGlvbmFsKVxuOiAoJ3Rva2VuLCAnc2VtYW50aWNfdmFsdWUpIHJldmlzZWQgPVxuXG4gICgqIEFjY2VwdCBhIHJldmlzZWQgbGV4ZXIuICopXG5cbiAgZnVuIChsZXhlciA6IHVuaXQgLT4gJ3Rva2VuKSAtPlxuXG4gICAgKCogQ3JlYXRlIGEgZHVtbXkgbGV4aW5nIGJ1ZmZlci4gKilcblxuICAgIGxldCBsZXhidWYgOiBMZXhpbmcubGV4YnVmID1cbiAgICAgIExleGluZy5mcm9tX3N0cmluZyBcIlwiXG4gICAgaW5cblxuICAgICgqIFdyYXAgdGhlIHJldmlzZWQgbGV4ZXIgYXMgYSB0cmFkaXRpb25hbCBsZXhlci4gQSB0cmFkaXRpb25hbFxuICAgICAgIGxleGVyIHJldHVybnMgYSByYXcgdG9rZW4gYW5kIHVwZGF0ZXMgdGhlIGZpZWxkcyBvZiB0aGUgbGV4aW5nXG4gICAgICAgYnVmZmVyIHdpdGggbmV3IHBvc2l0aW9ucywgd2hpY2ggd2lsbCBiZSByZWFkIGJ5IHRoZSBwYXJzZXIuICopXG5cbiAgICBsZXQgbGV4ZXIgKGxleGJ1ZiA6IExleGluZy5sZXhidWYpIDogJ3Jhd190b2tlbiA9XG4gICAgICBsZXQgdG9rZW4gOiAndG9rZW4gPSBsZXhlcigpIGluXG4gICAgICBsZXhidWYuTGV4aW5nLmxleF9zdGFydF9wIDwtIGdldF9zdGFydHAgdG9rZW47XG4gICAgICBsZXhidWYuTGV4aW5nLmxleF9jdXJyX3AgPC0gZ2V0X2VuZHAgdG9rZW47XG4gICAgICBnZXRfcmF3X3Rva2VuIHRva2VuXG4gICAgaW5cblxuICAgICgqIEludm9rZSB0aGUgdHJhZGl0aW9uYWwgcGFyc2VyLiAqKVxuXG4gICAgcGFyc2VyIGxleGVyIGxleGJ1ZlxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuKCogQ29udmVydGluZyBhIHJldmlzZWQgcGFyc2VyIGJhY2sgdG8gYSB0cmFkaXRpb25hbCBwYXJzZXIuICopXG5cbmxldCByZXZpc2VkMnRyYWRpdGlvbmFsXG4gIChtYWtlX3Rva2VuIDogJ3Jhd190b2tlbiAtPiBMZXhpbmcucG9zaXRpb24gLT4gTGV4aW5nLnBvc2l0aW9uIC0+ICd0b2tlbilcbiAgKHBhcnNlciA6ICgndG9rZW4sICdzZW1hbnRpY192YWx1ZSkgcmV2aXNlZClcbjogKCdyYXdfdG9rZW4sICdzZW1hbnRpY192YWx1ZSkgdHJhZGl0aW9uYWwgPVxuXG4gICgqIEFjY2VwdCBhIHRyYWRpdGlvbmFsIGxleGVyIGFuZCBhIGxleGluZyBidWZmZXIuICopXG5cbiAgZnVuIChsZXhlciA6IExleGluZy5sZXhidWYgLT4gJ3Jhd190b2tlbikgKGxleGJ1ZiA6IExleGluZy5sZXhidWYpIC0+XG5cbiAgICAoKiBXcmFwIHRoZSB0cmFkaXRpb25hbCBsZXhlciBhcyBhIHJldmlzZWQgbGV4ZXIuICopXG5cbiAgICBsZXQgbGV4ZXIgKCkgOiAndG9rZW4gPVxuICAgICAgbGV0IHRva2VuIDogJ3Jhd190b2tlbiA9IGxleGVyIGxleGJ1ZiBpblxuICAgICAgbWFrZV90b2tlbiB0b2tlbiBsZXhidWYuTGV4aW5nLmxleF9zdGFydF9wIGxleGJ1Zi5MZXhpbmcubGV4X2N1cnJfcFxuICAgIGluXG5cbiAgICAoKiBJbnZva2UgdGhlIHJldmlzZWQgcGFyc2VyLiAqKVxuXG4gICAgcGFyc2VyIGxleGVyXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4oKiBTaW1wbGlmaWVkIHZlcnNpb25zIG9mIHRoZSBhYm92ZSwgd2hlcmUgY29uY3JldGUgdHJpcGxlcyBhcmUgdXNlZC4gKilcblxubW9kdWxlIFNpbXBsaWZpZWQgPSBzdHJ1Y3RcblxuICBsZXQgdHJhZGl0aW9uYWwycmV2aXNlZCBwYXJzZXIgPVxuICAgIHRyYWRpdGlvbmFsMnJldmlzZWRcbiAgICAgIChmdW4gKHRva2VuLCBfLCBfKSAgLT4gdG9rZW4pXG4gICAgICAoZnVuIChfLCBzdGFydHAsIF8pIC0+IHN0YXJ0cClcbiAgICAgIChmdW4gKF8sIF8sIGVuZHApICAgLT4gZW5kcClcbiAgICAgIHBhcnNlclxuXG4gIGxldCByZXZpc2VkMnRyYWRpdGlvbmFsIHBhcnNlciA9XG4gICAgcmV2aXNlZDJ0cmFkaXRpb25hbFxuICAgICAgKGZ1biB0b2tlbiBzdGFydHAgZW5kcCAtPiAodG9rZW4sIHN0YXJ0cCwgZW5kcCkpXG4gICAgICBwYXJzZXJcblxuZW5kXG5lbmRcbm1vZHVsZSBJbmNyZW1lbnRhbEVuZ2luZSA9IHN0cnVjdFxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IElucmlhLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgICAgICopXG4oKiAgIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExpYnJhcnkgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIsIHdpdGggYSAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nLCBhcyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHBvc2l0aW9uID0gTGV4aW5nLnBvc2l0aW9uXG5cbm9wZW4gR2VuZXJhbFxuXG4oKiBUaGlzIHNpZ25hdHVyZSBkZXNjcmliZXMgdGhlIGluY3JlbWVudGFsIExSIGVuZ2luZS4gKilcblxuKCogSW4gdGhpcyBtb2RlLCB0aGUgdXNlciBjb250cm9scyB0aGUgbGV4ZXIsIGFuZCB0aGUgcGFyc2VyIHN1c3BlbmRzXG4gICBpdHNlbGYgd2hlbiBpdCBuZWVkcyB0byByZWFkIGEgbmV3IHRva2VuLiAqKVxuXG5tb2R1bGUgdHlwZSBJTkNSRU1FTlRBTF9FTkdJTkUgPSBzaWdcblxuICB0eXBlIHRva2VuXG5cbiAgKCogQSB2YWx1ZSBvZiB0eXBlIFtwcm9kdWN0aW9uXSBpcyAoYW4gaW5kZXggZm9yKSBhIHByb2R1Y3Rpb24uIFRoZSBzdGFydFxuICAgICBwcm9kdWN0aW9ucyAod2hpY2ggZG8gbm90IGV4aXN0IGluIGFuIFxcbWx5IGZpbGUsIGJ1dCBhcmUgY29uc3RydWN0ZWQgYnlcbiAgICAgTWVuaGlyIGludGVybmFsbHkpIGFyZSBub3QgcGFydCBvZiB0aGlzIHR5cGUuICopXG5cbiAgdHlwZSBwcm9kdWN0aW9uXG5cbiAgKCogVGhlIHR5cGUgWydhIGNoZWNrcG9pbnRdIHJlcHJlc2VudHMgYW4gaW50ZXJtZWRpYXRlIG9yIGZpbmFsIHN0YXRlIG9mIHRoZVxuICAgICBwYXJzZXIuIEFuIGludGVybWVkaWF0ZSBjaGVja3BvaW50IGlzIGEgc3VzcGVuc2lvbjogaXQgcmVjb3JkcyB0aGUgcGFyc2VyJ3NcbiAgICAgY3VycmVudCBzdGF0ZSwgYW5kIGFsbG93cyBwYXJzaW5nIHRvIGJlIHJlc3VtZWQuIFRoZSBwYXJhbWV0ZXIgWydhXSBpc1xuICAgICB0aGUgdHlwZSBvZiB0aGUgc2VtYW50aWMgdmFsdWUgdGhhdCB3aWxsIGV2ZW50dWFsbHkgYmUgcHJvZHVjZWQgaWYgdGhlXG4gICAgIHBhcnNlciBzdWNjZWVkcy4gKilcblxuICAoKiBbQWNjZXB0ZWRdIGFuZCBbUmVqZWN0ZWRdIGFyZSBmaW5hbCBjaGVja3BvaW50cy4gW0FjY2VwdGVkXSBjYXJyaWVzIGFcbiAgICAgc2VtYW50aWMgdmFsdWUuICopXG5cbiAgKCogW0lucHV0TmVlZGVkXSBpcyBhbiBpbnRlcm1lZGlhdGUgY2hlY2twb2ludC4gSXQgbWVhbnMgdGhhdCB0aGUgcGFyc2VyIHdpc2hlc1xuICAgICB0byByZWFkIG9uZSB0b2tlbiBiZWZvcmUgY29udGludWluZy4gKilcblxuICAoKiBbU2hpZnRpbmddIGlzIGFuIGludGVybWVkaWF0ZSBjaGVja3BvaW50LiBJdCBtZWFucyB0aGF0IHRoZSBwYXJzZXIgaXMgdGFraW5nXG4gICAgIGEgc2hpZnQgdHJhbnNpdGlvbi4gSXQgZXhwb3NlcyB0aGUgc3RhdGUgb2YgdGhlIHBhcnNlciBiZWZvcmUgYW5kIGFmdGVyXG4gICAgIHRoZSB0cmFuc2l0aW9uLiBUaGUgQm9vbGVhbiBwYXJhbWV0ZXIgdGVsbHMgd2hldGhlciB0aGUgcGFyc2VyIGludGVuZHMgdG9cbiAgICAgcmVxdWVzdCBhIG5ldyB0b2tlbiBhZnRlciB0aGlzIHRyYW5zaXRpb24uIChJdCBhbHdheXMgZG9lcywgZXhjZXB0IHdoZW5cbiAgICAgaXQgaXMgYWJvdXQgdG8gYWNjZXB0LikgKilcblxuICAoKiBbQWJvdXRUb1JlZHVjZV0gaXMgYW4gaW50ZXJtZWRpYXRlIGNoZWNrcG9pbnQuIEl0IG1lYW5zIHRoYXQgdGhlIHBhcnNlciBpc1xuICAgICBhYm91dCB0byBwZXJmb3JtIGEgcmVkdWN0aW9uIHN0ZXAuIEl0IGV4cG9zZXMgdGhlIHBhcnNlcidzIGN1cnJlbnRcbiAgICAgc3RhdGUgYXMgd2VsbCBhcyB0aGUgcHJvZHVjdGlvbiB0aGF0IGlzIGFib3V0IHRvIGJlIHJlZHVjZWQuICopXG5cbiAgKCogW0hhbmRsaW5nRXJyb3JdIGlzIGFuIGludGVybWVkaWF0ZSBjaGVja3BvaW50LiBJdCBtZWFucyB0aGF0IHRoZSBwYXJzZXIgaGFzXG4gICAgIGRldGVjdGVkIGFuIGVycm9yIGFuZCBpcyBjdXJyZW50bHkgaGFuZGxpbmcgaXQsIGluIHNldmVyYWwgc3RlcHMuICopXG5cbiAgKCogQSB2YWx1ZSBvZiB0eXBlIFsnYSBlbnZdIHJlcHJlc2VudHMgYSBjb25maWd1cmF0aW9uIG9mIHRoZSBhdXRvbWF0b246XG4gICAgIGN1cnJlbnQgc3RhdGUsIHN0YWNrLCBsb29rYWhlYWQgdG9rZW4sIGV0Yy4gVGhlIHBhcmFtZXRlciBbJ2FdIGlzIHRoZVxuICAgICB0eXBlIG9mIHRoZSBzZW1hbnRpYyB2YWx1ZSB0aGF0IHdpbGwgZXZlbnR1YWxseSBiZSBwcm9kdWNlZCBpZiB0aGUgcGFyc2VyXG4gICAgIHN1Y2NlZWRzLiAqKVxuXG4gICgqIEluIG5vcm1hbCBvcGVyYXRpb24sIHRoZSBwYXJzZXIgd29ya3Mgd2l0aCBjaGVja3BvaW50czogc2VlIHRoZSBmdW5jdGlvbnNcbiAgICAgW29mZmVyXSBhbmQgW3Jlc3VtZV0uIEhvd2V2ZXIsIGl0IGlzIGFsc28gcG9zc2libGUgdG8gd29yayBkaXJlY3RseSB3aXRoXG4gICAgIGVudmlyb25tZW50cyAoc2VlIHRoZSBmdW5jdGlvbnMgW3BvcF0sIFtmb3JjZV9yZWR1Y3Rpb25dLCBhbmQgW2ZlZWRdKSBhbmRcbiAgICAgdG8gcmVjb25zdHJ1Y3QgYSBjaGVja3BvaW50IG91dCBvZiBhbiBlbnZpcm9ubWVudCAoc2VlIFtpbnB1dF9uZWVkZWRdKS5cbiAgICAgVGhpcyBpcyBjb25zaWRlcmVkIGFkdmFuY2VkIGZ1bmN0aW9uYWxpdHk7IGl0cyBwdXJwb3NlIGlzIHRvIGFsbG93IGVycm9yXG4gICAgIHJlY292ZXJ5IHN0cmF0ZWdpZXMgdG8gYmUgcHJvZ3JhbW1lZCBieSB0aGUgdXNlci4gKilcblxuICB0eXBlICdhIGVudlxuXG4gIHR5cGUgJ2EgY2hlY2twb2ludCA9IHByaXZhdGVcbiAgICB8IElucHV0TmVlZGVkIG9mICdhIGVudlxuICAgIHwgU2hpZnRpbmcgb2YgJ2EgZW52ICogJ2EgZW52ICogYm9vbFxuICAgIHwgQWJvdXRUb1JlZHVjZSBvZiAnYSBlbnYgKiBwcm9kdWN0aW9uXG4gICAgfCBIYW5kbGluZ0Vycm9yIG9mICdhIGVudlxuICAgIHwgQWNjZXB0ZWQgb2YgJ2FcbiAgICB8IFJlamVjdGVkXG5cbiAgKCogW29mZmVyXSBhbGxvd3MgdGhlIHVzZXIgdG8gcmVzdW1lIHRoZSBwYXJzZXIgYWZ0ZXIgaXQgaGFzIHN1c3BlbmRlZFxuICAgICBpdHNlbGYgd2l0aCBhIGNoZWNrcG9pbnQgb2YgdGhlIGZvcm0gW0lucHV0TmVlZGVkIGVudl0uIFtvZmZlcl0gZXhwZWN0c1xuICAgICB0aGUgb2xkIGNoZWNrcG9pbnQgYXMgd2VsbCBhcyBhIG5ldyB0b2tlbiBhbmQgcHJvZHVjZXMgYSBuZXcgY2hlY2twb2ludC5cbiAgICAgSXQgZG9lcyBub3QgcmFpc2UgYW55IGV4Y2VwdGlvbi4gKilcblxuICB2YWwgb2ZmZXI6XG4gICAgJ2EgY2hlY2twb2ludCAtPlxuICAgIHRva2VuICogcG9zaXRpb24gKiBwb3NpdGlvbiAtPlxuICAgICdhIGNoZWNrcG9pbnRcblxuICAoKiBbcmVzdW1lXSBhbGxvd3MgdGhlIHVzZXIgdG8gcmVzdW1lIHRoZSBwYXJzZXIgYWZ0ZXIgaXQgaGFzIHN1c3BlbmRlZFxuICAgICBpdHNlbGYgd2l0aCBhIGNoZWNrcG9pbnQgb2YgdGhlIGZvcm0gW0Fib3V0VG9SZWR1Y2UgKGVudiwgcHJvZCldIG9yXG4gICAgIFtIYW5kbGluZ0Vycm9yIGVudl0uIFtyZXN1bWVdIGV4cGVjdHMgdGhlIG9sZCBjaGVja3BvaW50IGFuZCBwcm9kdWNlcyBhXG4gICAgIG5ldyBjaGVja3BvaW50LiBJdCBkb2VzIG5vdCByYWlzZSBhbnkgZXhjZXB0aW9uLiAqKVxuXG4gICgqIFRoZSBvcHRpb25hbCBhcmd1bWVudCBbc3RyYXRlZ3ldIGluZmx1ZW5jZXMgdGhlIG1hbm5lciBpbiB3aGljaCBbcmVzdW1lXVxuICAgICBkZWFscyB3aXRoIGNoZWNrcG9pbnRzIG9mIHRoZSBmb3JtIFtFcnJvckhhbmRsaW5nIF9dLiBJdHMgZGVmYXVsdCB2YWx1ZVxuICAgICBpcyBbYExlZ2FjeV0uIEl0IGNhbiBiZSBicmllZmx5IGRlc2NyaWJlZCBhcyBmb2xsb3dzOlxuXG4gICAgIC0gSWYgdGhlIFtlcnJvcl0gdG9rZW4gaXMgdXNlZCBvbmx5IHRvIHJlcG9ydCBlcnJvcnMgKHRoYXQgaXMsIGlmIHRoZVxuICAgICAgIFtlcnJvcl0gdG9rZW4gYXBwZWFycyBvbmx5IGF0IHRoZSBlbmQgb2YgYSBwcm9kdWN0aW9uLCB3aG9zZSBzZW1hbnRpY1xuICAgICAgIGFjdGlvbiByYWlzZXMgYW4gZXhjZXB0aW9uKSB0aGVuIHRoZSBzaW1wbGlmaWVkIHN0cmF0ZWd5IHNob3VsZCBiZVxuICAgICAgIHByZWZlcnJlZC4gKFRoaXMgaW5jbHVkZXMgdGhlIGNhc2Ugd2hlcmUgdGhlIFtlcnJvcl0gdG9rZW4gZG9lcyBub3RcbiAgICAgICBhcHBlYXIgYXQgYWxsIGluIHRoZSBncmFtbWFyLilcblxuICAgICAtIElmIHRoZSBbZXJyb3JdIHRva2VuIGlzIHVzZWQgdG8gcmVjb3ZlciBhZnRlciBhbiBlcnJvciwgb3IgaWZcbiAgICAgICBwZXJmZWN0IGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgaXMgcmVxdWlyZWQsIHRoZSBsZWdhY3kgc3RyYXRlZ3lcbiAgICAgICBzaG91bGQgYmUgc2VsZWN0ZWQuXG5cbiAgICAgTW9yZSBkZXRhaWxzIG9uIHRoZXNlIHN0cmF0ZWdpZXMgYXBwZWFyIGluIHRoZSBmaWxlIFtFbmdpbmUubWxdLiAqKVxuXG4gIHR5cGUgc3RyYXRlZ3kgPVxuICAgIFsgYExlZ2FjeSB8IGBTaW1wbGlmaWVkIF1cblxuICB2YWwgcmVzdW1lOlxuICAgID9zdHJhdGVneTpzdHJhdGVneSAtPlxuICAgICdhIGNoZWNrcG9pbnQgLT5cbiAgICAnYSBjaGVja3BvaW50XG5cbiAgKCogQSB0b2tlbiBzdXBwbGllciBpcyBhIGZ1bmN0aW9uIG9mIG5vIGFyZ3VtZW50cyB3aGljaCBkZWxpdmVycyBhIG5ldyB0b2tlblxuICAgICAodG9nZXRoZXIgd2l0aCBpdHMgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMpIGV2ZXJ5IHRpbWUgaXQgaXMgY2FsbGVkLiAqKVxuXG4gIHR5cGUgc3VwcGxpZXIgPVxuICAgIHVuaXQgLT4gdG9rZW4gKiBwb3NpdGlvbiAqIHBvc2l0aW9uXG5cbiAgKCogQSBwYWlyIG9mIGEgbGV4ZXIgYW5kIGEgbGV4aW5nIGJ1ZmZlciBjYW4gYmUgZWFzaWx5IHR1cm5lZCBpbnRvIGFcbiAgICAgc3VwcGxpZXIuICopXG5cbiAgdmFsIGxleGVyX2xleGJ1Zl90b19zdXBwbGllcjpcbiAgICAoTGV4aW5nLmxleGJ1ZiAtPiB0b2tlbikgLT5cbiAgICBMZXhpbmcubGV4YnVmIC0+XG4gICAgc3VwcGxpZXJcblxuICAoKiBUaGUgZnVuY3Rpb25zIFtvZmZlcl0gYW5kIFtyZXN1bWVdIGFyZSBzdWZmaWNpZW50IHRvIHdyaXRlIGEgcGFyc2VyIGxvb3AuXG4gICAgIE9uZSBjYW4gaW1hZ2luZSBtYW55IHZhcmlhdGlvbnMgKHdoaWNoIGlzIHdoeSB3ZSBleHBvc2UgdGhlc2UgZnVuY3Rpb25zXG4gICAgIGluIHRoZSBmaXJzdCBwbGFjZSEpLiBIZXJlLCB3ZSBleHBvc2UgYSBmZXcgdmFyaWF0aW9ucyBvZiB0aGUgbWFpbiBsb29wLFxuICAgICByZWFkeSBmb3IgdXNlLiAqKVxuXG4gICgqIFtsb29wIHN1cHBsaWVyIGNoZWNrcG9pbnRdIGJlZ2lucyBwYXJzaW5nIGZyb20gW2NoZWNrcG9pbnRdLCByZWFkaW5nXG4gICAgIHRva2VucyBmcm9tIFtzdXBwbGllcl0uIEl0IGNvbnRpbnVlcyBwYXJzaW5nIHVudGlsIGl0IHJlYWNoZXMgYVxuICAgICBjaGVja3BvaW50IG9mIHRoZSBmb3JtIFtBY2NlcHRlZCB2XSBvciBbUmVqZWN0ZWRdLiBJbiB0aGUgZm9ybWVyIGNhc2UsIGl0XG4gICAgIHJldHVybnMgW3ZdLiBJbiB0aGUgbGF0dGVyIGNhc2UsIGl0IHJhaXNlcyB0aGUgZXhjZXB0aW9uIFtFcnJvcl0uXG4gICAgIFRoZSBvcHRpb25hbCBhcmd1bWVudCBbc3RyYXRlZ3ldLCB3aG9zZSBkZWZhdWx0IHZhbHVlIGlzIFtMZWdhY3ldLFxuICAgICBpcyBwYXNzZWQgdG8gW3Jlc3VtZV0gYW5kIGluZmx1ZW5jZXMgdGhlIGVycm9yLWhhbmRsaW5nIHN0cmF0ZWd5LiAqKVxuXG4gIHZhbCBsb29wOiA/c3RyYXRlZ3k6c3RyYXRlZ3kgLT4gc3VwcGxpZXIgLT4gJ2EgY2hlY2twb2ludCAtPiAnYVxuXG4gICgqIFtsb29wX2hhbmRsZSBzdWNjZWVkIGZhaWwgc3VwcGxpZXIgY2hlY2twb2ludF0gYmVnaW5zIHBhcnNpbmcgZnJvbVxuICAgICBbY2hlY2twb2ludF0sIHJlYWRpbmcgdG9rZW5zIGZyb20gW3N1cHBsaWVyXS4gSXQgY29udGludWVzIHBhcnNpbmcgdW50aWxcbiAgICAgaXQgcmVhY2hlcyBhIGNoZWNrcG9pbnQgb2YgdGhlIGZvcm0gW0FjY2VwdGVkIHZdIG9yIFtIYW5kbGluZ0Vycm9yIGVudl1cbiAgICAgKG9yIFtSZWplY3RlZF0sIGJ1dCB0aGF0IHNob3VsZCBub3QgaGFwcGVuLCBhcyBbSGFuZGxpbmdFcnJvciBfXSB3aWxsIGJlXG4gICAgIG9ic2VydmVkIGZpcnN0KS4gSW4gdGhlIGZvcm1lciBjYXNlLCBpdCBjYWxscyBbc3VjY2VlZCB2XS4gSW4gdGhlIGxhdHRlclxuICAgICBjYXNlLCBpdCBjYWxscyBbZmFpbF0gd2l0aCB0aGlzIGNoZWNrcG9pbnQuIEl0IGNhbm5vdCByYWlzZSBbRXJyb3JdLlxuXG4gICAgIFRoaXMgbWVhbnMgdGhhdCBNZW5oaXIncyBlcnJvci1oYW5kbGluZyBwcm9jZWR1cmUgZG9lcyBub3QgZ2V0IGEgY2hhbmNlXG4gICAgIHRvIHJ1bi4gRm9yIHRoaXMgcmVhc29uLCB0aGVyZSBpcyBubyBbc3RyYXRlZ3ldIHBhcmFtZXRlci4gSW5zdGVhZCwgdGhlXG4gICAgIHVzZXIgY2FuIGltcGxlbWVudCBoZXIgb3duIGVycm9yIGhhbmRsaW5nIGNvZGUsIGluIHRoZSBbZmFpbF1cbiAgICAgY29udGludWF0aW9uLiAqKVxuXG4gIHZhbCBsb29wX2hhbmRsZTpcbiAgICAoJ2EgLT4gJ2Fuc3dlcikgLT5cbiAgICAoJ2EgY2hlY2twb2ludCAtPiAnYW5zd2VyKSAtPlxuICAgIHN1cHBsaWVyIC0+ICdhIGNoZWNrcG9pbnQgLT4gJ2Fuc3dlclxuXG4gICgqIFtsb29wX2hhbmRsZV91bmRvXSBpcyBhbmFsb2dvdXMgdG8gW2xvb3BfaGFuZGxlXSwgZXhjZXB0IGl0IHBhc3NlcyBhIHBhaXJcbiAgICAgb2YgY2hlY2twb2ludHMgdG8gdGhlIGZhaWx1cmUgY29udGludWF0aW9uLlxuXG4gICAgIFRoZSBmaXJzdCAoYW5kIG9sZGVzdCkgY2hlY2twb2ludCBpcyB0aGUgbGFzdCBbSW5wdXROZWVkZWRdIGNoZWNrcG9pbnQgdGhhdFxuICAgICB3YXMgZW5jb3VudGVyZWQgYmVmb3JlIHRoZSBlcnJvciB3YXMgZGV0ZWN0ZWQuIFRoZSBzZWNvbmQgKGFuZCBuZXdlc3QpXG4gICAgIGNoZWNrcG9pbnQgaXMgd2hlcmUgdGhlIGVycm9yIHdhcyBkZXRlY3RlZCwgYXMgaW4gW2xvb3BfaGFuZGxlXS4gR29pbmcgYmFja1xuICAgICB0byB0aGUgZmlyc3QgY2hlY2twb2ludCBjYW4gYmUgdGhvdWdodCBvZiBhcyB1bmRvaW5nIGFueSByZWR1Y3Rpb25zIHRoYXRcbiAgICAgd2VyZSBwZXJmb3JtZWQgYWZ0ZXIgc2VlaW5nIHRoZSBwcm9ibGVtYXRpYyB0b2tlbi4gKFRoZXNlIHJlZHVjdGlvbnMgbXVzdFxuICAgICBiZSBkZWZhdWx0IHJlZHVjdGlvbnMgb3Igc3B1cmlvdXMgcmVkdWN0aW9ucy4pXG5cbiAgICAgW2xvb3BfaGFuZGxlX3VuZG9dIG11c3QgaW5pdGlhbGx5IGJlIGFwcGxpZWQgdG8gYW4gW0lucHV0TmVlZGVkXSBjaGVja3BvaW50LlxuICAgICBUaGUgcGFyc2VyJ3MgaW5pdGlhbCBjaGVja3BvaW50cyBzYXRpc2Z5IHRoaXMgY29uc3RyYWludC4gKilcblxuICB2YWwgbG9vcF9oYW5kbGVfdW5kbzpcbiAgICAoJ2EgLT4gJ2Fuc3dlcikgLT5cbiAgICAoJ2EgY2hlY2twb2ludCAtPiAnYSBjaGVja3BvaW50IC0+ICdhbnN3ZXIpIC0+XG4gICAgc3VwcGxpZXIgLT4gJ2EgY2hlY2twb2ludCAtPiAnYW5zd2VyXG5cbiAgKCogW3NoaWZ0cyBjaGVja3BvaW50XSBhc3N1bWVzIHRoYXQgW2NoZWNrcG9pbnRdIGhhcyBiZWVuIG9idGFpbmVkIGJ5XG4gICAgIHN1Ym1pdHRpbmcgYSB0b2tlbiB0byB0aGUgcGFyc2VyLiBJdCBydW5zIHRoZSBwYXJzZXIgZnJvbSBbY2hlY2twb2ludF0sXG4gICAgIHRocm91Z2ggYW4gYXJiaXRyYXJ5IG51bWJlciBvZiByZWR1Y3Rpb25zLCB1bnRpbCB0aGUgcGFyc2VyIGVpdGhlclxuICAgICBhY2NlcHRzIHRoaXMgdG9rZW4gKGkuZS4sIHNoaWZ0cykgb3IgcmVqZWN0cyBpdCAoaS5lLiwgc2lnbmFscyBhbiBlcnJvcikuXG4gICAgIElmIHRoZSBwYXJzZXIgZGVjaWRlcyB0byBzaGlmdCwgdGhlbiBbU29tZSBlbnZdIGlzIHJldHVybmVkLCB3aGVyZSBbZW52XVxuICAgICBpcyB0aGUgcGFyc2VyJ3Mgc3RhdGUganVzdCBiZWZvcmUgc2hpZnRpbmcuIE90aGVyd2lzZSwgW05vbmVdIGlzXG4gICAgIHJldHVybmVkLiAqKVxuXG4gICgqIEl0IGlzIGRlc2lyYWJsZSB0aGF0IHRoZSBzZW1hbnRpYyBhY3Rpb25zIGJlIHNpZGUtZWZmZWN0IGZyZWUsIG9yIHRoYXRcbiAgICAgdGhlaXIgc2lkZS1lZmZlY3RzIGJlIGhhcm1sZXNzIChyZXBsYXlhYmxlKS4gKilcblxuICB2YWwgc2hpZnRzOiAnYSBjaGVja3BvaW50IC0+ICdhIGVudiBvcHRpb25cblxuICAoKiBUaGUgZnVuY3Rpb24gW2FjY2VwdGFibGVdIGFsbG93cyB0ZXN0aW5nLCBhZnRlciBhbiBlcnJvciBoYXMgYmVlblxuICAgICBkZXRlY3RlZCwgd2hpY2ggdG9rZW5zIHdvdWxkIGhhdmUgYmVlbiBhY2NlcHRlZCBhdCB0aGlzIHBvaW50LiBJdCBpc1xuICAgICBpbXBsZW1lbnRlZCB1c2luZyBbc2hpZnRzXS4gSXRzIGFyZ3VtZW50IHNob3VsZCBiZSBhbiBbSW5wdXROZWVkZWRdXG4gICAgIGNoZWNrcG9pbnQuICopXG5cbiAgKCogRm9yIGNvbXBsZXRlbmVzcywgb25lIG11c3QgdW5kbyBhbnkgc3B1cmlvdXMgcmVkdWN0aW9ucyBiZWZvcmUgY2Fycnlpbmcgb3V0XG4gICAgIHRoaXMgdGVzdCAtLSB0aGF0IGlzLCBvbmUgbXVzdCBhcHBseSBbYWNjZXB0YWJsZV0gdG8gdGhlIEZJUlNUIGNoZWNrcG9pbnRcbiAgICAgdGhhdCBpcyBwYXNzZWQgYnkgW2xvb3BfaGFuZGxlX3VuZG9dIHRvIGl0cyBmYWlsdXJlIGNvbnRpbnVhdGlvbi4gKilcblxuICAoKiBUaGlzIHRlc3QgY2F1c2VzIHNvbWUgc2VtYW50aWMgYWN0aW9ucyB0byBiZSBydW4hIFRoZSBzZW1hbnRpYyBhY3Rpb25zXG4gICAgIHNob3VsZCBiZSBzaWRlLWVmZmVjdCBmcmVlLCBvciB0aGVpciBzaWRlLWVmZmVjdHMgc2hvdWxkIGJlIGhhcm1sZXNzLiAqKVxuXG4gICgqIFRoZSBwb3NpdGlvbiBbcG9zXSBpcyB1c2VkIGFzIHRoZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucyBvZiB0aGVcbiAgICAgaHlwb3RoZXRpY2FsIHRva2VuLCBhbmQgbWF5IGJlIHBpY2tlZCB1cCBieSB0aGUgc2VtYW50aWMgYWN0aW9ucy4gV2VcbiAgICAgc3VnZ2VzdCB1c2luZyB0aGUgcG9zaXRpb24gd2hlcmUgdGhlIGVycm9yIHdhcyBkZXRlY3RlZC4gKilcblxuICB2YWwgYWNjZXB0YWJsZTogJ2EgY2hlY2twb2ludCAtPiB0b2tlbiAtPiBwb3NpdGlvbiAtPiBib29sXG5cbiAgKCogVGhlIGFic3RyYWN0IHR5cGUgWydhIGxyMXN0YXRlXSBkZXNjcmliZXMgdGhlIG5vbi1pbml0aWFsIHN0YXRlcyBvZiB0aGVcbiAgICAgTFIoMSkgYXV0b21hdG9uLiBUaGUgaW5kZXggWydhXSByZXByZXNlbnRzIHRoZSB0eXBlIG9mIHRoZSBzZW1hbnRpYyB2YWx1ZVxuICAgICBhc3NvY2lhdGVkIHdpdGggdGhpcyBzdGF0ZSdzIGluY29taW5nIHN5bWJvbC4gKilcblxuICB0eXBlICdhIGxyMXN0YXRlXG5cbiAgKCogVGhlIHN0YXRlcyBvZiB0aGUgTFIoMSkgYXV0b21hdG9uIGFyZSBudW1iZXJlZCAoZnJvbSAwIGFuZCB1cCkuICopXG5cbiAgdmFsIG51bWJlcjogXyBscjFzdGF0ZSAtPiBpbnRcblxuICAoKiBQcm9kdWN0aW9ucyBhcmUgbnVtYmVyZWQuICopXG5cbiAgKCogW2ZpbmRfcHJvZHVjdGlvbiBpXSByZXF1aXJlcyB0aGUgaW5kZXggW2ldIHRvIGJlIHZhbGlkLiBVc2Ugd2l0aCBjYXJlLiAqKVxuXG4gIHZhbCBwcm9kdWN0aW9uX2luZGV4OiBwcm9kdWN0aW9uIC0+IGludFxuICB2YWwgZmluZF9wcm9kdWN0aW9uOiBpbnQgLT4gcHJvZHVjdGlvblxuXG4gICgqIEFuIGVsZW1lbnQgaXMgYSBwYWlyIG9mIGEgbm9uLWluaXRpYWwgc3RhdGUgW3NdIGFuZCBhIHNlbWFudGljIHZhbHVlIFt2XVxuICAgICBhc3NvY2lhdGVkIHdpdGggdGhlIGluY29taW5nIHN5bWJvbCBvZiB0aGlzIHN0YXRlLiBUaGUgaWRlYSBpcywgdGhlIHZhbHVlXG4gICAgIFt2XSB3YXMgcHVzaGVkIG9udG8gdGhlIHN0YWNrIGp1c3QgYmVmb3JlIHRoZSBzdGF0ZSBbc10gd2FzIGVudGVyZWQuIFRodXMsXG4gICAgIGZvciBzb21lIHR5cGUgWydhXSwgdGhlIHN0YXRlIFtzXSBoYXMgdHlwZSBbJ2EgbHIxc3RhdGVdIGFuZCB0aGUgdmFsdWUgW3ZdXG4gICAgIGhhcyB0eXBlIFsnYV0uIEluIG90aGVyIHdvcmRzLCB0aGUgdHlwZSBbZWxlbWVudF0gaXMgYW4gZXhpc3RlbnRpYWwgdHlwZS4gKilcblxuICB0eXBlIGVsZW1lbnQgPVxuICAgIHwgRWxlbWVudDogJ2EgbHIxc3RhdGUgKiAnYSAqIHBvc2l0aW9uICogcG9zaXRpb24gLT4gZWxlbWVudFxuXG4gICgqIFRoZSBwYXJzZXIncyBzdGFjayBpcyAob3IsIG1vcmUgcHJlY2lzZWx5LCBjYW4gYmUgdmlld2VkIGFzKSBhIHN0cmVhbSBvZlxuICAgICBlbGVtZW50cy4gVGhlIHR5cGUgW3N0cmVhbV0gaXMgZGVmaW5lZCBieSB0aGUgbW9kdWxlIFtHZW5lcmFsXS4gKilcblxuICAoKiBBcyBvZiAyMDE3LzAzLzMxLCB0aGUgdHlwZXMgW3N0cmVhbV0gYW5kIFtzdGFja10gYW5kIHRoZSBmdW5jdGlvbiBbc3RhY2tdXG4gICAgIGFyZSBERVBSRUNBVEVELiBUaGV5IG1pZ2h0IGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS4gQW4gYWx0ZXJuYXRpdmUgd2F5XG4gICAgIG9mIGluc3BlY3RpbmcgdGhlIHN0YWNrIGlzIHZpYSB0aGUgZnVuY3Rpb25zIFt0b3BdIGFuZCBbcG9wXS4gKilcblxuICB0eXBlIHN0YWNrID0gKCogREVQUkVDQVRFRCAqKVxuICAgIGVsZW1lbnQgc3RyZWFtXG5cbiAgKCogVGhpcyBpcyB0aGUgcGFyc2VyJ3Mgc3RhY2ssIGEgc3RyZWFtIG9mIGVsZW1lbnRzLiBUaGlzIHN0cmVhbSBpcyBlbXB0eSBpZlxuICAgICB0aGUgcGFyc2VyIGlzIGluIGFuIGluaXRpYWwgc3RhdGU7IG90aGVyd2lzZSwgaXQgaXMgbm9uLWVtcHR5LiAgVGhlIExSKDEpXG4gICAgIGF1dG9tYXRvbidzIGN1cnJlbnQgc3RhdGUgaXMgdGhlIG9uZSBmb3VuZCBpbiB0aGUgdG9wIGVsZW1lbnQgb2YgdGhlXG4gICAgIHN0YWNrLiAqKVxuXG4gIHZhbCBzdGFjazogJ2EgZW52IC0+IHN0YWNrICgqIERFUFJFQ0FURUQgKilcblxuICAoKiBbdG9wIGVudl0gcmV0dXJucyB0aGUgcGFyc2VyJ3MgdG9wIHN0YWNrIGVsZW1lbnQuIFRoZSBzdGF0ZSBjb250YWluZWQgaW5cbiAgICAgdGhpcyBzdGFjayBlbGVtZW50IGlzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBhdXRvbWF0b24uIElmIHRoZSBzdGFjayBpc1xuICAgICBlbXB0eSwgW05vbmVdIGlzIHJldHVybmVkLiBJbiB0aGF0IGNhc2UsIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZVxuICAgICBhdXRvbWF0b24gbXVzdCBiZSBhbiBpbml0aWFsIHN0YXRlLiAqKVxuXG4gIHZhbCB0b3A6ICdhIGVudiAtPiBlbGVtZW50IG9wdGlvblxuXG4gICgqIFtwb3BfbWFueSBpIGVudl0gcG9wcyBbaV0gY2VsbHMgb2ZmIHRoZSBhdXRvbWF0b24ncyBzdGFjay4gVGhpcyBpcyBkb25lXG4gICAgIHZpYSBbaV0gc3VjY2Vzc2l2ZSBpbnZvY2F0aW9ucyBvZiBbcG9wXS4gVGh1cywgW3BvcF9tYW55IDFdIGlzIFtwb3BdLiBUaGVcbiAgICAgaW5kZXggW2ldIG11c3QgYmUgbm9ubmVnYXRpdmUuIFRoZSB0aW1lIGNvbXBsZXhpdHkgaXMgTyhpKS4gKilcblxuICB2YWwgcG9wX21hbnk6IGludCAtPiAnYSBlbnYgLT4gJ2EgZW52IG9wdGlvblxuXG4gICgqIFtnZXQgaSBlbnZdIHJldHVybnMgdGhlIHBhcnNlcidzIFtpXS10aCBzdGFjayBlbGVtZW50LiBUaGUgaW5kZXggW2ldIGlzXG4gICAgIDAtYmFzZWQ6IHRodXMsIFtnZXQgMF0gaXMgW3RvcF0uIElmIFtpXSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlXG4gICAgIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgc3RhY2ssIFtOb25lXSBpcyByZXR1cm5lZC4gVGhlIHRpbWUgY29tcGxleGl0eVxuICAgICBpcyBPKGkpLiAqKVxuXG4gIHZhbCBnZXQ6IGludCAtPiAnYSBlbnYgLT4gZWxlbWVudCBvcHRpb25cblxuICAoKiBbY3VycmVudF9zdGF0ZV9udW1iZXIgZW52XSBpcyAodGhlIGludGVnZXIgbnVtYmVyIG9mKSB0aGUgYXV0b21hdG9uJ3NcbiAgICAgY3VycmVudCBzdGF0ZS4gVGhpcyB3b3JrcyBldmVuIGlmIHRoZSBhdXRvbWF0b24ncyBzdGFjayBpcyBlbXB0eSwgaW5cbiAgICAgd2hpY2ggY2FzZSB0aGUgY3VycmVudCBzdGF0ZSBpcyBhbiBpbml0aWFsIHN0YXRlLiBUaGlzIG51bWJlciBjYW4gYmVcbiAgICAgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIGEgW21lc3NhZ2VdIGZ1bmN0aW9uIGdlbmVyYXRlZCBieSBbbWVuaGlyXG4gICAgIC0tY29tcGlsZS1lcnJvcnNdLiAqKVxuXG4gIHZhbCBjdXJyZW50X3N0YXRlX251bWJlcjogJ2EgZW52IC0+IGludFxuXG4gICgqIFtlcXVhbCBlbnYxIGVudjJdIHRlbGxzIHdoZXRoZXIgdGhlIHBhcnNlciBjb25maWd1cmF0aW9ucyBbZW52MV0gYW5kXG4gICAgIFtlbnYyXSBhcmUgZXF1YWwgaW4gdGhlIHNlbnNlIHRoYXQgdGhlIGF1dG9tYXRvbidzIGN1cnJlbnQgc3RhdGUgaXMgdGhlXG4gICAgIHNhbWUgaW4gW2VudjFdIGFuZCBbZW52Ml0gYW5kIHRoZSBzdGFjayBpcyAqcGh5c2ljYWxseSogdGhlIHNhbWUgaW5cbiAgICAgW2VudjFdIGFuZCBbZW52Ml0uIElmIFtlcXVhbCBlbnYxIGVudjJdIGlzIFt0cnVlXSwgdGhlbiB0aGUgc2VxdWVuY2Ugb2ZcbiAgICAgdGhlIHN0YWNrIGVsZW1lbnRzLCBhcyBvYnNlcnZlZCB2aWEgW3BvcF0gYW5kIFt0b3BdLCBtdXN0IGJlIHRoZSBzYW1lIGluXG4gICAgIFtlbnYxXSBhbmQgW2VudjJdLiBBbHNvLCBpZiBbZXF1YWwgZW52MSBlbnYyXSBob2xkcywgdGhlbiB0aGUgY2hlY2twb2ludHNcbiAgICAgW2lucHV0X25lZWRlZCBlbnYxXSBhbmQgW2lucHV0X25lZWRlZCBlbnYyXSBtdXN0IGJlIGVxdWl2YWxlbnQuIFRoZVxuICAgICBmdW5jdGlvbiBbZXF1YWxdIGhhcyB0aW1lIGNvbXBsZXhpdHkgTygxKS4gKilcblxuICB2YWwgZXF1YWw6ICdhIGVudiAtPiAnYSBlbnYgLT4gYm9vbFxuXG4gICgqIFRoZXNlIGFyZSB0aGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMgb2YgdGhlIGN1cnJlbnQgbG9va2FoZWFkIHRva2VuLiBJZlxuICAgICBpbnZva2VkIGluIGFuIGluaXRpYWwgc3RhdGUsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHBhaXIgb2YgdHdpY2UgdGhlXG4gICAgIGluaXRpYWwgcG9zaXRpb24uICopXG5cbiAgdmFsIHBvc2l0aW9uczogJ2EgZW52IC0+IHBvc2l0aW9uICogcG9zaXRpb25cblxuICAoKiBXaGVuIGFwcGxpZWQgdG8gYW4gZW52aXJvbm1lbnQgdGFrZW4gZnJvbSBhIGNoZWNrcG9pbnQgb2YgdGhlIGZvcm1cbiAgICAgW0Fib3V0VG9SZWR1Y2UgKGVudiwgcHJvZCldLCB0aGUgZnVuY3Rpb24gW2Vudl9oYXNfZGVmYXVsdF9yZWR1Y3Rpb25dXG4gICAgIHRlbGxzIHdoZXRoZXIgdGhlIHJlZHVjdGlvbiB0aGF0IGlzIGFib3V0IHRvIHRha2UgcGxhY2UgaXMgYSBkZWZhdWx0XG4gICAgIHJlZHVjdGlvbi4gKilcblxuICB2YWwgZW52X2hhc19kZWZhdWx0X3JlZHVjdGlvbjogJ2EgZW52IC0+IGJvb2xcblxuICAoKiBbc3RhdGVfaGFzX2RlZmF1bHRfcmVkdWN0aW9uIHNdIHRlbGxzIHdoZXRoZXIgdGhlIHN0YXRlIFtzXSBoYXMgYSBkZWZhdWx0XG4gICAgIHJlZHVjdGlvbi4gVGhpcyBpbmNsdWRlcyB0aGUgY2FzZSB3aGVyZSBbc10gaXMgYW4gYWNjZXB0aW5nIHN0YXRlLiAqKVxuXG4gIHZhbCBzdGF0ZV9oYXNfZGVmYXVsdF9yZWR1Y3Rpb246IF8gbHIxc3RhdGUgLT4gYm9vbFxuXG4gICgqIFtwb3AgZW52XSByZXR1cm5zIGEgbmV3IGVudmlyb25tZW50LCB3aGVyZSB0aGUgcGFyc2VyJ3MgdG9wIHN0YWNrIGNlbGxcbiAgICAgaGFzIGJlZW4gcG9wcGVkIG9mZi4gKElmIHRoZSBzdGFjayBpcyBlbXB0eSwgW05vbmVdIGlzIHJldHVybmVkLikgVGhpc1xuICAgICBhbW91bnRzIHRvIHByZXRlbmRpbmcgdGhhdCB0aGUgKHRlcm1pbmFsIG9yIG5vbnRlcm1pbmFsKSBzeW1ib2wgdGhhdFxuICAgICBjb3JyZXNwb25kcyB0byB0aGlzIHN0YWNrIGNlbGwgaGFzIG5vdCBiZWVuIHJlYWQuICopXG5cbiAgdmFsIHBvcDogJ2EgZW52IC0+ICdhIGVudiBvcHRpb25cblxuICAoKiBbZm9yY2VfcmVkdWN0aW9uIHByb2QgZW52XSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgaWYgaW4gdGhlIHN0YXRlIFtlbnZdXG4gICAgIHRoZSBwYXJzZXIgaXMgY2FwYWJsZSBvZiByZWR1Y2luZyB0aGUgcHJvZHVjdGlvbiBbcHJvZF0uIElmIHRoaXNcbiAgICAgY29uZGl0aW9uIGlzIHNhdGlzZmllZCwgdGhlbiB0aGlzIHByb2R1Y3Rpb24gaXMgcmVkdWNlZCwgd2hpY2ggbWVhbnMgdGhhdFxuICAgICBpdHMgc2VtYW50aWMgYWN0aW9uIGlzIGV4ZWN1dGVkICh0aGlzIGNhbiBoYXZlIHNpZGUgZWZmZWN0cyEpIGFuZCB0aGVcbiAgICAgYXV0b21hdG9uIG1ha2VzIGEgZ290byAobm9udGVybWluYWwpIHRyYW5zaXRpb24uIElmIHRoaXMgY29uZGl0aW9uIGlzIG5vdFxuICAgICBzYXRpc2ZpZWQsIFtJbnZhbGlkX2FyZ3VtZW50IF9dIGlzIHJhaXNlZC4gKilcblxuICB2YWwgZm9yY2VfcmVkdWN0aW9uOiBwcm9kdWN0aW9uIC0+ICdhIGVudiAtPiAnYSBlbnZcblxuICAoKiBbaW5wdXRfbmVlZGVkIGVudl0gcmV0dXJucyBbSW5wdXROZWVkZWQgZW52XS4gVGhhdCBpcywgb3V0IG9mIGFuIFtlbnZdXG4gICAgIHRoYXQgbWlnaHQgaGF2ZSBiZWVuIG9idGFpbmVkIHZpYSBhIHNlcmllcyBvZiBjYWxscyB0byB0aGUgZnVuY3Rpb25zXG4gICAgIFtwb3BdLCBbZm9yY2VfcmVkdWN0aW9uXSwgW2ZlZWRdLCBldGMuLCBpdCBwcm9kdWNlcyBhIGNoZWNrcG9pbnQsIHdoaWNoXG4gICAgIGNhbiBiZSB1c2VkIHRvIHJlc3VtZSBub3JtYWwgcGFyc2luZywgYnkgc3VwcGx5aW5nIHRoaXMgY2hlY2twb2ludCBhcyBhblxuICAgICBhcmd1bWVudCB0byBbb2ZmZXJdLiAqKVxuXG4gICgqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIHVzZWQgd2l0aCBzb21lIGNhcmUuIEl0IGNvdWxkIFwibWVzcyB1cCB0aGVcbiAgICAgbG9va2FoZWFkXCIgaW4gdGhlIHNlbnNlIHRoYXQgaXQgYWxsb3dzIHBhcnNpbmcgdG8gcmVzdW1lIGluIGFuIGFyYml0cmFyeVxuICAgICBzdGF0ZSBbc10gd2l0aCBhbiBhcmJpdHJhcnkgbG9va2FoZWFkIHN5bWJvbCBbdF0sIGV2ZW4gdGhvdWdoIE1lbmhpcidzXG4gICAgIHJlYWNoYWJpbGl0eSBhbmFseXNpcyAobWVuaGlyIC0tbGlzdC1lcnJvcnMpIG1pZ2h0IHdlbGwgdGhpbmsgdGhhdCBpdCBpc1xuICAgICBpbXBvc3NpYmxlIHRvIHJlYWNoIHRoaXMgcGFydGljdWxhciBjb25maWd1cmF0aW9uLiBJZiBvbmUgaXMgdXNpbmdcbiAgICAgTWVuaGlyJ3MgbmV3IGVycm9yIHJlcG9ydGluZyBmYWNpbGl0eSwgdGhpcyBjb3VsZCBjYXVzZSB0aGUgcGFyc2VyIHRvXG4gICAgIHJlYWNoIGFuIGVycm9yIHN0YXRlIGZvciB3aGljaCBubyBlcnJvciBtZXNzYWdlIGhhcyBiZWVuIHByZXBhcmVkLiAqKVxuXG4gIHZhbCBpbnB1dF9uZWVkZWQ6ICdhIGVudiAtPiAnYSBjaGVja3BvaW50XG5cbmVuZFxuXG4oKiBUaGlzIHNpZ25hdHVyZSBpcyBhIGZyYWdtZW50IG9mIHRoZSBpbnNwZWN0aW9uIEFQSSB0aGF0IGlzIG1hZGUgYXZhaWxhYmxlXG4gICB0byB0aGUgdXNlciB3aGVuIFstLWluc3BlY3Rpb25dIGlzIHVzZWQuIFRoaXMgZnJhZ21lbnQgY29udGFpbnMgdHlwZVxuICAgZGVmaW5pdGlvbnMgZm9yIHN5bWJvbHMuICopXG5cbm1vZHVsZSB0eXBlIFNZTUJPTFMgPSBzaWdcblxuICAoKiBUaGUgdHlwZSBbJ2EgdGVybWluYWxdIHJlcHJlc2VudHMgYSB0ZXJtaW5hbCBzeW1ib2wuIFRoZSB0eXBlIFsnYVxuICAgICBub250ZXJtaW5hbF0gcmVwcmVzZW50cyBhIG5vbnRlcm1pbmFsIHN5bWJvbC4gSW4gYm90aCBjYXNlcywgdGhlIGluZGV4XG4gICAgIFsnYV0gcmVwcmVzZW50cyB0aGUgdHlwZSBvZiB0aGUgc2VtYW50aWMgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzXG4gICAgIHN5bWJvbC4gVGhlIGNvbmNyZXRlIGRlZmluaXRpb25zIG9mIHRoZXNlIHR5cGVzIGFyZSBnZW5lcmF0ZWQuICopXG5cbiAgdHlwZSAnYSB0ZXJtaW5hbFxuICB0eXBlICdhIG5vbnRlcm1pbmFsXG5cbiAgKCogVGhlIHR5cGUgWydhIHN5bWJvbF0gcmVwcmVzZW50cyBhIHRlcm1pbmFsIG9yIG5vbnRlcm1pbmFsIHN5bWJvbC4gSXQgaXNcbiAgICAgdGhlIGRpc2pvaW50IHVuaW9uIG9mIHRoZSB0eXBlcyBbJ2EgdGVybWluYWxdIGFuZCBbJ2Egbm9udGVybWluYWxdLiAqKVxuXG4gIHR5cGUgJ2Egc3ltYm9sID1cbiAgICB8IFQgOiAnYSB0ZXJtaW5hbCAtPiAnYSBzeW1ib2xcbiAgICB8IE4gOiAnYSBub250ZXJtaW5hbCAtPiAnYSBzeW1ib2xcblxuICAoKiBUaGUgdHlwZSBbeHN5bWJvbF0gaXMgYW4gZXhpc3RlbnRpYWxseSBxdWFudGlmaWVkIHZlcnNpb24gb2YgdGhlIHR5cGVcbiAgICAgWydhIHN5bWJvbF0uIFRoaXMgdHlwZSBpcyB1c2VmdWwgaW4gc2l0dWF0aW9ucyB3aGVyZSB0aGUgaW5kZXggWydhXVxuICAgICBpcyBub3Qgc3RhdGljYWxseSBrbm93bi4gKilcblxuICB0eXBlIHhzeW1ib2wgPVxuICAgIHwgWCA6ICdhIHN5bWJvbCAtPiB4c3ltYm9sXG5cbmVuZFxuXG4oKiBUaGlzIHNpZ25hdHVyZSBkZXNjcmliZXMgdGhlIGluc3BlY3Rpb24gQVBJIHRoYXQgaXMgbWFkZSBhdmFpbGFibGUgdG8gdGhlXG4gICB1c2VyIHdoZW4gWy0taW5zcGVjdGlvbl0gaXMgdXNlZC4gKilcblxubW9kdWxlIHR5cGUgSU5TUEVDVElPTiA9IHNpZ1xuXG4gICgqIFRoZSB0eXBlcyBvZiBzeW1ib2xzIGFyZSBkZXNjcmliZWQgYWJvdmUuICopXG5cbiAgaW5jbHVkZSBTWU1CT0xTXG5cbiAgKCogVGhlIHR5cGUgWydhIGxyMXN0YXRlXSBpcyBtZWFudCB0byBiZSB0aGUgc2FtZSBhcyBpbiBbSU5DUkVNRU5UQUxfRU5HSU5FXS4gKilcblxuICB0eXBlICdhIGxyMXN0YXRlXG5cbiAgKCogVGhlIHR5cGUgW3Byb2R1Y3Rpb25dIGlzIG1lYW50IHRvIGJlIHRoZSBzYW1lIGFzIGluIFtJTkNSRU1FTlRBTF9FTkdJTkVdLlxuICAgICBJdCByZXByZXNlbnRzIGEgcHJvZHVjdGlvbiBvZiB0aGUgZ3JhbW1hci4gQSBwcm9kdWN0aW9uIGNhbiBiZSBleGFtaW5lZFxuICAgICB2aWEgdGhlIGZ1bmN0aW9ucyBbbGhzXSBhbmQgW3Joc10gYmVsb3cuICopXG5cbiAgdHlwZSBwcm9kdWN0aW9uXG5cbiAgKCogQW4gTFIoMCkgaXRlbSBpcyBhIHBhaXIgb2YgYSBwcm9kdWN0aW9uIFtwcm9kXSBhbmQgYSB2YWxpZCBpbmRleCBbaV0gaW50b1xuICAgICB0aGlzIHByb2R1Y3Rpb24uIFRoYXQgaXMsIGlmIHRoZSBsZW5ndGggb2YgW3JocyBwcm9kXSBpcyBbbl0sIHRoZW4gW2ldIGlzXG4gICAgIGNvbXByaXNlZCBiZXR3ZWVuIDAgYW5kIFtuXSwgaW5jbHVzaXZlLiAqKVxuXG4gIHR5cGUgaXRlbSA9XG4gICAgICBwcm9kdWN0aW9uICogaW50XG5cbiAgKCogT3JkZXJpbmcgZnVuY3Rpb25zLiAqKVxuXG4gIHZhbCBjb21wYXJlX3Rlcm1pbmFsczogXyB0ZXJtaW5hbCAtPiBfIHRlcm1pbmFsIC0+IGludFxuICB2YWwgY29tcGFyZV9ub250ZXJtaW5hbHM6IF8gbm9udGVybWluYWwgLT4gXyBub250ZXJtaW5hbCAtPiBpbnRcbiAgdmFsIGNvbXBhcmVfc3ltYm9sczogeHN5bWJvbCAtPiB4c3ltYm9sIC0+IGludFxuICB2YWwgY29tcGFyZV9wcm9kdWN0aW9uczogcHJvZHVjdGlvbiAtPiBwcm9kdWN0aW9uIC0+IGludFxuICB2YWwgY29tcGFyZV9pdGVtczogaXRlbSAtPiBpdGVtIC0+IGludFxuXG4gICgqIFtpbmNvbWluZ19zeW1ib2wgc10gaXMgdGhlIGluY29taW5nIHN5bWJvbCBvZiB0aGUgc3RhdGUgW3NdLCB0aGF0IGlzLFxuICAgICB0aGUgc3ltYm9sIHRoYXQgdGhlIHBhcnNlciBtdXN0IHJlY29nbml6ZSBiZWZvcmUgKGhhcyByZWNvZ25pemVkIHdoZW4pXG4gICAgIGl0IGVudGVycyB0aGUgc3RhdGUgW3NdLiBUaGlzIGZ1bmN0aW9uIGdpdmVzIGFjY2VzcyB0byB0aGUgc2VtYW50aWNcbiAgICAgdmFsdWUgW3ZdIHN0b3JlZCBpbiBhIHN0YWNrIGVsZW1lbnQgW0VsZW1lbnQgKHMsIHYsIF8sIF8pXS4gSW5kZWVkLFxuICAgICBieSBjYXNlIGFuYWx5c2lzIG9uIHRoZSBzeW1ib2wgW2luY29taW5nX3N5bWJvbCBzXSwgb25lIGRpc2NvdmVycyB0aGVcbiAgICAgdHlwZSBbJ2FdIG9mIHRoZSB2YWx1ZSBbdl0uICopXG5cbiAgdmFsIGluY29taW5nX3N5bWJvbDogJ2EgbHIxc3RhdGUgLT4gJ2Egc3ltYm9sXG5cbiAgKCogW2l0ZW1zIHNdIGlzIHRoZSBzZXQgb2YgdGhlIExSKDApIGl0ZW1zIGluIHRoZSBMUigwKSBjb3JlIG9mIHRoZSBMUigxKVxuICAgICBzdGF0ZSBbc10uIFRoaXMgc2V0IGlzIG5vdCBlcHNpbG9uLWNsb3NlZC4gVGhpcyBzZXQgaXMgcHJlc2VudGVkIGFzIGFcbiAgICAgbGlzdCwgaW4gYW4gYXJiaXRyYXJ5IG9yZGVyLiAqKVxuXG4gIHZhbCBpdGVtczogXyBscjFzdGF0ZSAtPiBpdGVtIGxpc3RcblxuICAoKiBbbGhzIHByb2RdIGlzIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiB0aGUgcHJvZHVjdGlvbiBbcHJvZF0uIFRoaXMgaXNcbiAgICAgYWx3YXlzIGEgbm9uLXRlcm1pbmFsIHN5bWJvbC4gKilcblxuICB2YWwgbGhzOiBwcm9kdWN0aW9uIC0+IHhzeW1ib2xcblxuICAoKiBbcmhzIHByb2RdIGlzIHRoZSByaWdodC1oYW5kIHNpZGUgb2YgdGhlIHByb2R1Y3Rpb24gW3Byb2RdLiBUaGlzIGlzXG4gICAgIGEgKHBvc3NpYmx5IGVtcHR5KSBzZXF1ZW5jZSBvZiAodGVybWluYWwgb3Igbm9udGVybWluYWwpIHN5bWJvbHMuICopXG5cbiAgdmFsIHJoczogcHJvZHVjdGlvbiAtPiB4c3ltYm9sIGxpc3RcblxuICAoKiBbbnVsbGFibGUgbnRdIHRlbGxzIHdoZXRoZXIgdGhlIG5vbi10ZXJtaW5hbCBzeW1ib2wgW250XSBpcyBudWxsYWJsZS5cbiAgICAgVGhhdCBpcywgaXQgaXMgdHJ1ZSBpZiBhbmQgb25seSBpZiB0aGlzIHN5bWJvbCBwcm9kdWNlcyB0aGUgZW1wdHlcbiAgICAgd29yZCBbZXBzaWxvbl0uICopXG5cbiAgdmFsIG51bGxhYmxlOiBfIG5vbnRlcm1pbmFsIC0+IGJvb2xcblxuICAoKiBbZmlyc3QgbnQgdF0gdGVsbHMgd2hldGhlciB0aGUgRklSU1Qgc2V0IG9mIHRoZSBub250ZXJtaW5hbCBzeW1ib2wgW250XVxuICAgICBjb250YWlucyB0aGUgdGVybWluYWwgc3ltYm9sIFt0XS4gVGhhdCBpcywgaXQgaXMgdHJ1ZSBpZiBhbmQgb25seSBpZlxuICAgICBbbnRdIHByb2R1Y2VzIGEgd29yZCB0aGF0IGJlZ2lucyB3aXRoIFt0XS4gKilcblxuICB2YWwgZmlyc3Q6IF8gbm9udGVybWluYWwgLT4gXyB0ZXJtaW5hbCAtPiBib29sXG5cbiAgKCogW3hmaXJzdF0gaXMgYW5hbG9nb3VzIHRvIFtmaXJzdF0sIGJ1dCBleHBlY3RzIGEgZmlyc3QgYXJndW1lbnQgb2YgdHlwZVxuICAgICBbeHN5bWJvbF0gaW5zdGVhZCBvZiBbXyB0ZXJtaW5hbF0uICopXG5cbiAgdmFsIHhmaXJzdDogeHN5bWJvbCAtPiBfIHRlcm1pbmFsIC0+IGJvb2xcblxuICAoKiBbZm9yZWFjaF90ZXJtaW5hbF0gZW51bWVyYXRlcyB0aGUgdGVybWluYWwgc3ltYm9scywgaW5jbHVkaW5nIFtlcnJvcl0uXG4gICAgIFtmb3JlYWNoX3Rlcm1pbmFsX2J1dF9lcnJvcl0gZW51bWVyYXRlcyB0aGUgdGVybWluYWwgc3ltYm9scywgZXhjbHVkaW5nXG4gICAgIFtlcnJvcl0uICopXG5cbiAgdmFsIGZvcmVhY2hfdGVybWluYWw6ICAgICAgICAgICAoeHN5bWJvbCAtPiAnYSAtPiAnYSkgLT4gJ2EgLT4gJ2FcbiAgdmFsIGZvcmVhY2hfdGVybWluYWxfYnV0X2Vycm9yOiAoeHN5bWJvbCAtPiAnYSAtPiAnYSkgLT4gJ2EgLT4gJ2FcblxuICAoKiBUaGUgdHlwZSBbZW52XSBpcyBtZWFudCB0byBiZSB0aGUgc2FtZSBhcyBpbiBbSU5DUkVNRU5UQUxfRU5HSU5FXS4gKilcblxuICB0eXBlICdhIGVudlxuXG4gICgqIFtmZWVkIHN5bWJvbCBzdGFydHAgc2VtdiBlbmRwIGVudl0gY2F1c2VzIHRoZSBwYXJzZXIgdG8gY29uc3VtZSB0aGVcbiAgICAgKHRlcm1pbmFsIG9yIG5vbnRlcm1pbmFsKSBzeW1ib2wgW3N5bWJvbF0sIGFjY29tcGFuaWVkIHdpdGggdGhlIHNlbWFudGljXG4gICAgIHZhbHVlIFtzZW12XSBhbmQgd2l0aCB0aGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMgW3N0YXJ0cF0gYW5kIFtlbmRwXS5cbiAgICAgVGh1cywgdGhlIGF1dG9tYXRvbiBtYWtlcyBhIHRyYW5zaXRpb24sIGFuZCByZWFjaGVzIGEgbmV3IHN0YXRlLiBUaGVcbiAgICAgc3RhY2sgZ3Jvd3MgYnkgb25lIGNlbGwuIFRoaXMgb3BlcmF0aW9uIGlzIHBlcm1pdHRlZCBvbmx5IGlmIHRoZSBjdXJyZW50XG4gICAgIHN0YXRlIChhcyBkZXRlcm1pbmVkIGJ5IFtlbnZdKSBoYXMgYW4gb3V0Z29pbmcgdHJhbnNpdGlvbiBsYWJlbGVkIHdpdGhcbiAgICAgW3N5bWJvbF0uIE90aGVyd2lzZSwgW0ludmFsaWRfYXJndW1lbnQgX10gaXMgcmFpc2VkLiAqKVxuXG4gIHZhbCBmZWVkOiAnYSBzeW1ib2wgLT4gcG9zaXRpb24gLT4gJ2EgLT4gcG9zaXRpb24gLT4gJ2IgZW52IC0+ICdiIGVudlxuXG5lbmRcblxuKCogVGhpcyBzaWduYXR1cmUgY29tYmluZXMgdGhlIGluY3JlbWVudGFsIEFQSSBhbmQgdGhlIGluc3BlY3Rpb24gQVBJLiAqKVxuXG5tb2R1bGUgdHlwZSBFVkVSWVRISU5HID0gc2lnXG5cbiAgaW5jbHVkZSBJTkNSRU1FTlRBTF9FTkdJTkVcblxuICBpbmNsdWRlIElOU1BFQ1RJT05cbiAgICB3aXRoIHR5cGUgJ2EgbHIxc3RhdGUgOj0gJ2EgbHIxc3RhdGVcbiAgICB3aXRoIHR5cGUgcHJvZHVjdGlvbiA6PSBwcm9kdWN0aW9uXG4gICAgd2l0aCB0eXBlICdhIGVudiA6PSAnYSBlbnZcblxuZW5kXG5lbmRcbm1vZHVsZSBFbmdpbmVUeXBlcyA9IHN0cnVjdFxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IElucmlhLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgICAgICopXG4oKiAgIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExpYnJhcnkgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIsIHdpdGggYSAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nLCBhcyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBUaGlzIGZpbGUgZGVmaW5lcyBzZXZlcmFsIHR5cGVzIGFuZCBtb2R1bGUgdHlwZXMgdGhhdCBhcmUgdXNlZCBpbiB0aGVcbiAgIHNwZWNpZmljYXRpb24gb2YgbW9kdWxlIFtFbmdpbmVdLiAqKVxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuKCogSXQgd291bGQgYmUgbmljZSBpZiB3ZSBjb3VsZCBrZWVwIHRoZSBzdHJ1Y3R1cmUgb2Ygc3RhY2tzIGFuZCBlbnZpcm9ubWVudHNcbiAgIGhpZGRlbi4gSG93ZXZlciwgc3RhY2tzIGFuZCBlbnZpcm9ubWVudHMgbXVzdCBiZSBhY2Nlc3NpYmxlIHRvIHNlbWFudGljXG4gICBhY3Rpb25zLCBzbyB0aGUgZm9sbG93aW5nIGRhdGEgc3RydWN0dXJlIGRlZmluaXRpb25zIG11c3QgYmUgcHVibGljLiAqKVxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuKCogQSBzdGFjayBpcyBhIGxpbmtlZCBsaXN0IG9mIGNlbGxzLiBBIHNlbnRpbmVsIGNlbGwgLS0gd2hpY2ggaXMgaXRzIG93blxuICAgc3VjY2Vzc29yIC0tIGlzIHVzZWQgdG8gbWFyayB0aGUgYm90dG9tIG9mIHRoZSBzdGFjay4gVGhlIHNlbnRpbmVsIGNlbGxcbiAgIGl0c2VsZiBpcyBub3Qgc2lnbmlmaWNhbnQgLS0gaXQgY29udGFpbnMgZHVtbXkgdmFsdWVzLiAqKVxuXG50eXBlICgnc3RhdGUsICdzZW1hbnRpY192YWx1ZSkgc3RhY2sgPSB7XG5cbiAgKCogVGhlIHN0YXRlIHRoYXQgd2Ugc2hvdWxkIGdvIGJhY2sgdG8gaWYgd2UgcG9wIHRoaXMgc3RhY2sgY2VsbC4gKilcblxuICAoKiBUaGlzIGNvbnZlbnRpb24gbWVhbnMgdGhhdCB0aGUgc3RhdGUgY29udGFpbmVkIGluIHRoZSB0b3Agc3RhY2sgY2VsbCBpc1xuICAgICBub3QgdGhlIGN1cnJlbnQgc3RhdGUgW2Vudi5jdXJyZW50XS4gSXQgYWxzbyBtZWFucyB0aGF0IHRoZSBzdGF0ZSBmb3VuZFxuICAgICB3aXRoaW4gdGhlIHNlbnRpbmVsIGlzIGEgZHVtbXkgLS0gaXQgaXMgbmV2ZXIgY29uc3VsdGVkLiBUaGlzIGNvbnZlbnRpb25cbiAgICAgaXMgdGhlIHNhbWUgYXMgdGhhdCBhZG9wdGVkIGJ5IHRoZSBjb2RlLWJhc2VkIGJhY2stZW5kLiAqKVxuXG4gIHN0YXRlOiAnc3RhdGU7XG5cbiAgKCogVGhlIHNlbWFudGljIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2h1bmsgb2YgaW5wdXQgdGhhdCB0aGlzIGNlbGxcbiAgICAgcmVwcmVzZW50cy4gKilcblxuICBzZW12OiAnc2VtYW50aWNfdmFsdWU7XG5cbiAgKCogVGhlIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25zIG9mIHRoZSBjaHVuayBvZiBpbnB1dCB0aGF0IHRoaXMgY2VsbFxuICAgICByZXByZXNlbnRzLiAqKVxuXG4gIHN0YXJ0cDogTGV4aW5nLnBvc2l0aW9uO1xuICBlbmRwOiBMZXhpbmcucG9zaXRpb247XG5cbiAgKCogVGhlIG5leHQgY2VsbCBkb3duIGluIHRoZSBzdGFjay4gSWYgdGhpcyBpcyBhIHNlbGYtcG9pbnRlciwgdGhlbiB0aGlzXG4gICAgIGNlbGwgaXMgdGhlIHNlbnRpbmVsLCBhbmQgdGhlIHN0YWNrIGlzIGNvbmNlcHR1YWxseSBlbXB0eS4gKilcblxuICBuZXh0OiAoJ3N0YXRlLCAnc2VtYW50aWNfdmFsdWUpIHN0YWNrO1xuXG59XG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4oKiBBIHBhcnNpbmcgZW52aXJvbm1lbnQgY29udGFpbnMgYWxsIG9mIHRoZSBwYXJzZXIncyBzdGF0ZSAoZXhjZXB0IGZvciB0aGVcbiAgIGN1cnJlbnQgcHJvZ3JhbSBwb2ludCkuICopXG5cbnR5cGUgKCdzdGF0ZSwgJ3NlbWFudGljX3ZhbHVlLCAndG9rZW4pIGVudiA9IHtcblxuICAoKiBJZiB0aGlzIGZsYWcgaXMgdHJ1ZSwgdGhlbiB0aGUgZmlyc3QgY29tcG9uZW50IG9mIFtlbnYudHJpcGxlXSBzaG91bGRcbiAgICAgYmUgaWdub3JlZCwgYXMgaXQgaGFzIGJlZW4gbG9naWNhbGx5IG92ZXJ3cml0dGVuIHdpdGggdGhlIFtlcnJvcl1cbiAgICAgcHNldWRvLXRva2VuLiAqKVxuXG4gIGVycm9yOiBib29sO1xuXG4gICgqIFRoZSBsYXN0IHRva2VuIHRoYXQgd2FzIG9idGFpbmVkIGZyb20gdGhlIGxleGVyLCB0b2dldGhlciB3aXRoIGl0cyBzdGFydFxuICAgICBhbmQgZW5kIHBvc2l0aW9ucy4gV2FybmluZzogYmVmb3JlIHRoZSBmaXJzdCBjYWxsIHRvIHRoZSBsZXhlciBoYXMgdGFrZW5cbiAgICAgcGxhY2UsIGEgZHVtbXkgKGFuZCBwb3NzaWJseSBpbnZhbGlkKSB0b2tlbiBpcyBzdG9yZWQgaGVyZS4gKilcblxuICB0cmlwbGU6ICd0b2tlbiAqIExleGluZy5wb3NpdGlvbiAqIExleGluZy5wb3NpdGlvbjtcblxuICAoKiBUaGUgc3RhY2suIEluIFtDb2RlQmFja2VuZF0sIGl0IGlzIHBhc3NlZCBhcm91bmQgb24gaXRzIG93bixcbiAgICAgd2hlcmVhcywgaGVyZSwgaXQgaXMgYWNjZXNzZWQgdmlhIHRoZSBlbnZpcm9ubWVudC4gKilcblxuICBzdGFjazogKCdzdGF0ZSwgJ3NlbWFudGljX3ZhbHVlKSBzdGFjaztcblxuICAoKiBUaGUgY3VycmVudCBzdGF0ZS4gSW4gW0NvZGVCYWNrZW5kXSwgaXQgaXMgcGFzc2VkIGFyb3VuZCBvbiBpdHNcbiAgICAgb3duLCB3aGVyZWFzLCBoZXJlLCBpdCBpcyBhY2Nlc3NlZCB2aWEgdGhlIGVudmlyb25tZW50LiAqKVxuXG4gIGN1cnJlbnQ6ICdzdGF0ZTtcblxufVxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuKCogQSBudW1iZXIgb2YgbG9nZ2luZyBob29rcyBhcmUgdXNlZCB0byAob3B0aW9uYWxseSkgZW1pdCBsb2dnaW5nIG1lc3NhZ2VzLiAqKVxuXG4oKiBUaGUgY29tbWVudHMgaW5kaWNhdGUgdGhlIGNvbnZlbnRpb25hbCBtZXNzYWdlcyB0aGF0IGNvcnJlc3BvbmRcbiAgIHRvIHRoZXNlIGhvb2tzIGluIHRoZSBjb2RlLWJhc2VkIGJhY2stZW5kOyBzZWUgW0NvZGVCYWNrZW5kXS4gKilcblxubW9kdWxlIHR5cGUgTE9HID0gc2lnXG5cbiAgdHlwZSBzdGF0ZVxuICB0eXBlIHRlcm1pbmFsXG4gIHR5cGUgcHJvZHVjdGlvblxuXG4gICgqIFN0YXRlICVkOiAqKVxuXG4gIHZhbCBzdGF0ZTogc3RhdGUgLT4gdW5pdFxuXG4gICgqIFNoaWZ0aW5nICg8dGVybWluYWw+KSB0byBzdGF0ZSA8c3RhdGU+ICopXG5cbiAgdmFsIHNoaWZ0OiB0ZXJtaW5hbCAtPiBzdGF0ZSAtPiB1bml0XG5cbiAgKCogUmVkdWNpbmcgYSBwcm9kdWN0aW9uIHNob3VsZCBiZSBsb2dnZWQgZWl0aGVyIGFzIGEgcmVkdWN0aW9uXG4gICAgIGV2ZW50IChmb3IgcmVndWxhciBwcm9kdWN0aW9ucykgb3IgYXMgYW4gYWNjZXB0YW5jZSBldmVudCAoZm9yXG4gICAgIHN0YXJ0IHByb2R1Y3Rpb25zKS4gKilcblxuICAoKiBSZWR1Y2luZyBwcm9kdWN0aW9uIDxwcm9kdWN0aW9uPiAvIEFjY2VwdGluZyAqKVxuXG4gIHZhbCByZWR1Y2Vfb3JfYWNjZXB0OiBwcm9kdWN0aW9uIC0+IHVuaXRcblxuICAoKiBMb29rYWhlYWQgdG9rZW4gaXMgbm93IDx0ZXJtaW5hbD4gKDxwb3M+LTxwb3M+KSAqKVxuXG4gIHZhbCBsb29rYWhlYWRfdG9rZW46IHRlcm1pbmFsIC0+IExleGluZy5wb3NpdGlvbiAtPiBMZXhpbmcucG9zaXRpb24gLT4gdW5pdFxuXG4gICgqIEluaXRpYXRpbmcgZXJyb3IgaGFuZGxpbmcgKilcblxuICB2YWwgaW5pdGlhdGluZ19lcnJvcl9oYW5kbGluZzogdW5pdCAtPiB1bml0XG5cbiAgKCogUmVzdW1pbmcgZXJyb3IgaGFuZGxpbmcgKilcblxuICB2YWwgcmVzdW1pbmdfZXJyb3JfaGFuZGxpbmc6IHVuaXQgLT4gdW5pdFxuXG4gICgqIEhhbmRsaW5nIGVycm9yIGluIHN0YXRlIDxzdGF0ZT4gKilcblxuICB2YWwgaGFuZGxpbmdfZXJyb3I6IHN0YXRlIC0+IHVuaXRcblxuZW5kXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4oKiBUaGlzIHNpZ25hdHVyZSBkZXNjcmliZXMgdGhlIHBhcmFtZXRlcnMgdGhhdCBtdXN0IGJlIHN1cHBsaWVkIHRvIHRoZSBMUlxuICAgZW5naW5lLiAqKVxuXG5tb2R1bGUgdHlwZSBUQUJMRSA9IHNpZ1xuXG4gICgqIFRoZSB0eXBlIG9mIGF1dG9tYXRvbiBzdGF0ZXMuICopXG5cbiAgdHlwZSBzdGF0ZVxuXG4gICgqIFN0YXRlcyBhcmUgbnVtYmVyZWQuICopXG5cbiAgdmFsIG51bWJlcjogc3RhdGUgLT4gaW50XG5cbiAgKCogVGhlIHR5cGUgb2YgdG9rZW5zLiBUaGVzZSBjYW4gYmUgdGhvdWdodCBvZiBhcyByZWFsIHRva2VucywgdGhhdCBpcyxcbiAgICAgdG9rZW5zIHJldHVybmVkIGJ5IHRoZSBsZXhlci4gVGhleSBjYXJyeSBhIHNlbWFudGljIHZhbHVlLiBUaGlzIHR5cGVcbiAgICAgZG9lcyBub3QgaW5jbHVkZSB0aGUgW2Vycm9yXSBwc2V1ZG8tdG9rZW4uICopXG5cbiAgdHlwZSB0b2tlblxuXG4gICgqIFRoZSB0eXBlIG9mIHRlcm1pbmFsIHN5bWJvbHMuIFRoZXNlIGNhbiBiZSB0aG91Z2h0IG9mIGFzIGludGVnZXIgY29kZXMuXG4gICAgIFRoZXkgZG8gbm90IGNhcnJ5IGEgc2VtYW50aWMgdmFsdWUuIFRoaXMgdHlwZSBkb2VzIGluY2x1ZGUgdGhlIFtlcnJvcl1cbiAgICAgcHNldWRvLXRva2VuLiAqKVxuXG4gIHR5cGUgdGVybWluYWxcblxuICAoKiBUaGUgdHlwZSBvZiBub250ZXJtaW5hbCBzeW1ib2xzLiAqKVxuXG4gIHR5cGUgbm9udGVybWluYWxcblxuICAoKiBUaGUgdHlwZSBvZiBzZW1hbnRpYyB2YWx1ZXMuICopXG5cbiAgdHlwZSBzZW1hbnRpY192YWx1ZVxuXG4gICgqIEEgdG9rZW4gaXMgY29uY2VwdHVhbGx5IGEgcGFpciBvZiBhIChub24tW2Vycm9yXSkgdGVybWluYWwgc3ltYm9sIGFuZFxuICAgICBhIHNlbWFudGljIHZhbHVlLiBUaGUgZm9sbG93aW5nIHR3byBmdW5jdGlvbnMgYXJlIHRoZSBwYWlyIHByb2plY3Rpb25zLiAqKVxuXG4gIHZhbCB0b2tlbjJ0ZXJtaW5hbDogdG9rZW4gLT4gdGVybWluYWxcbiAgdmFsIHRva2VuMnZhbHVlOiB0b2tlbiAtPiBzZW1hbnRpY192YWx1ZVxuXG4gICgqIEV2ZW4gdGhvdWdoIHRoZSBbZXJyb3JdIHBzZXVkby10b2tlbiBpcyBub3QgYSByZWFsIHRva2VuLCBpdCBpcyBhXG4gICAgIHRlcm1pbmFsIHN5bWJvbC4gRnVydGhlcm1vcmUsIGZvciByZWd1bGFyaXR5LCBpdCBtdXN0IGhhdmUgYSBzZW1hbnRpY1xuICAgICB2YWx1ZS4gKilcblxuICB2YWwgZXJyb3JfdGVybWluYWw6IHRlcm1pbmFsXG4gIHZhbCBlcnJvcl92YWx1ZTogc2VtYW50aWNfdmFsdWVcblxuICAoKiBbZm9yZWFjaF90ZXJtaW5hbF0gYWxsb3dzIGl0ZXJhdGluZyBvdmVyIGFsbCB0ZXJtaW5hbCBzeW1ib2xzLiAqKVxuXG4gIHZhbCBmb3JlYWNoX3Rlcm1pbmFsOiAodGVybWluYWwgLT4gJ2EgLT4gJ2EpIC0+ICdhIC0+ICdhXG5cbiAgKCogVGhlIHR5cGUgb2YgcHJvZHVjdGlvbnMuICopXG5cbiAgdHlwZSBwcm9kdWN0aW9uXG5cbiAgdmFsIHByb2R1Y3Rpb25faW5kZXg6IHByb2R1Y3Rpb24gLT4gaW50XG4gIHZhbCBmaW5kX3Byb2R1Y3Rpb246IGludCAtPiBwcm9kdWN0aW9uXG5cbiAgKCogSWYgYSBzdGF0ZSBbc10gaGFzIGEgZGVmYXVsdCByZWR1Y3Rpb24gb24gcHJvZHVjdGlvbiBbcHJvZF0sIHRoZW4sIHVwb25cbiAgICAgZW50ZXJpbmcgW3NdLCB0aGUgYXV0b21hdG9uIHNob3VsZCByZWR1Y2UgW3Byb2RdIHdpdGhvdXQgY29uc3VsdGluZyB0aGVcbiAgICAgbG9va2FoZWFkIHRva2VuLiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9uIGFsbG93cyBkZXRlcm1pbmluZyB3aGljaCBzdGF0ZXNcbiAgICAgaGF2ZSBkZWZhdWx0IHJlZHVjdGlvbnMuICopXG5cbiAgKCogSW5zdGVhZCBvZiByZXR1cm5pbmcgYSB2YWx1ZSBvZiBhIHN1bSB0eXBlIC0tIGVpdGhlciBbRGVmUmVkIHByb2RdLCBvclxuICAgICBbTm9EZWZSZWRdIC0tIGl0IGFjY2VwdHMgdHdvIGNvbnRpbnVhdGlvbnMsIGFuZCBpbnZva2VzIGp1c3Qgb25lIG9mXG4gICAgIHRoZW0uIFRoaXMgbWVjaGFuaXNtIGFsbG93cyBhdm9pZGluZyBhIG1lbW9yeSBhbGxvY2F0aW9uLiAqKVxuXG4gIHZhbCBkZWZhdWx0X3JlZHVjdGlvbjpcbiAgICBzdGF0ZSAtPlxuICAgICgnZW52IC0+IHByb2R1Y3Rpb24gLT4gJ2Fuc3dlcikgLT5cbiAgICAoJ2VudiAtPiAnYW5zd2VyKSAtPlxuICAgICdlbnYgLT4gJ2Fuc3dlclxuXG4gICgqIEFuIExSIGF1dG9tYXRvbiBjYW4gbm9ybWFsbHkgdGFrZSB0aHJlZSBraW5kcyBvZiBhY3Rpb25zOiBzaGlmdCwgcmVkdWNlLFxuICAgICBvciBmYWlsLiAoQWNjZXB0YW5jZSBpcyBhIHBhcnRpY3VsYXIgY2FzZSBvZiByZWR1Y3Rpb246IGl0IGNvbnNpc3RzIGluXG4gICAgIHJlZHVjaW5nIGEgc3RhcnQgcHJvZHVjdGlvbi4pICopXG5cbiAgKCogVGhlcmUgYXJlIHR3byB2YXJpYW50cyBvZiB0aGUgc2hpZnQgYWN0aW9uLiBbc2hpZnQvZGlzY2FyZCBzXSBpbnN0cnVjdHNcbiAgICAgdGhlIGF1dG9tYXRvbiB0byBkaXNjYXJkIHRoZSBjdXJyZW50IHRva2VuLCByZXF1ZXN0IGEgbmV3IG9uZSBmcm9tIHRoZVxuICAgICBsZXhlciwgYW5kIG1vdmUgdG8gc3RhdGUgW3NdLiBbc2hpZnQvbm9kaXNjYXJkIHNdIGluc3RydWN0cyBpdCB0byBtb3ZlIHRvXG4gICAgIHN0YXRlIFtzXSB3aXRob3V0IHJlcXVlc3RpbmcgYSBuZXcgdG9rZW4uIFRoaXMgaW5zdHJ1Y3Rpb24gc2hvdWxkIGJlIHVzZWRcbiAgICAgd2hlbiBbc10gaGFzIGEgZGVmYXVsdCByZWR1Y3Rpb24gb24gWyNdLiBTZWUgW0NvZGVCYWNrZW5kLmdldHRva2VuXSBmb3JcbiAgICAgZGV0YWlscy4gKilcblxuICAoKiBUaGlzIGlzIHRoZSBhdXRvbWF0b24ncyBhY3Rpb24gdGFibGUuIEl0IG1hcHMgYSBwYWlyIG9mIGEgc3RhdGUgYW5kIGFcbiAgICAgdGVybWluYWwgc3ltYm9sIHRvIGFuIGFjdGlvbi4gKilcblxuICAoKiBJbnN0ZWFkIG9mIHJldHVybmluZyBhIHZhbHVlIG9mIGEgc3VtIHR5cGUgLS0gb25lIG9mIHNoaWZ0L2Rpc2NhcmQsXG4gICAgIHNoaWZ0L25vZGlzY2FyZCwgcmVkdWNlLCBvciBmYWlsIC0tIHRoaXMgZnVuY3Rpb24gYWNjZXB0cyB0aHJlZVxuICAgICBjb250aW51YXRpb25zLCBhbmQgaW52b2tlcyBqdXN0IG9uZSB0aGVtLiBUaGlzIG1lY2hhbmlzbSBhbGxvd3MgYXZvaWRpbmdcbiAgICAgYSBtZW1vcnkgYWxsb2NhdGlvbi4gKilcblxuICAoKiBJbiBzdW1tYXJ5LCB0aGUgcGFyYW1ldGVycyB0byBbYWN0aW9uXSBhcmUgYXMgZm9sbG93czpcblxuICAgICAtIHRoZSBmaXJzdCB0d28gcGFyYW1ldGVycywgYSBzdGF0ZSBhbmQgYSB0ZXJtaW5hbCBzeW1ib2wsIGFyZSB1c2VkIHRvXG4gICAgICAgbG9vayB1cCB0aGUgYWN0aW9uIHRhYmxlO1xuXG4gICAgIC0gdGhlIG5leHQgcGFyYW1ldGVyIGlzIHRoZSBzZW1hbnRpYyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGFib3ZlXG4gICAgICAgdGVybWluYWwgc3ltYm9sOyBpdCBpcyBub3QgdXNlZCwgb25seSBwYXNzZWQgYWxvbmcgdG8gdGhlIHNoaWZ0XG4gICAgICAgY29udGludWF0aW9uLCBhcyBleHBsYWluZWQgYmVsb3c7XG5cbiAgICAgLSB0aGUgc2hpZnQgY29udGludWF0aW9uIGV4cGVjdHMgYW4gZW52aXJvbm1lbnQ7IGEgZmxhZyB0aGF0IHRlbGxzXG4gICAgICAgd2hldGhlciB0byBkaXNjYXJkIHRoZSBjdXJyZW50IHRva2VuOyB0aGUgdGVybWluYWwgc3ltYm9sIHRoYXRcbiAgICAgICBpcyBiZWluZyBzaGlmdGVkOyBpdHMgc2VtYW50aWMgdmFsdWU7IGFuZCB0aGUgdGFyZ2V0IHN0YXRlIG9mXG4gICAgICAgdGhlIHRyYW5zaXRpb247XG5cbiAgICAgLSB0aGUgcmVkdWNlIGNvbnRpbnVhdGlvbiBleHBlY3RzIGFuIGVudmlyb25tZW50IGFuZCBhIHByb2R1Y3Rpb247XG5cbiAgICAgLSB0aGUgZmFpbCBjb250aW51YXRpb24gZXhwZWN0cyBhbiBlbnZpcm9ubWVudDtcblxuICAgICAtIHRoZSBsYXN0IHBhcmFtZXRlciBpcyB0aGUgZW52aXJvbm1lbnQ7IGl0IGlzIG5vdCB1c2VkLCBvbmx5IHBhc3NlZFxuICAgICAgIGFsb25nIHRvIHRoZSBzZWxlY3RlZCBjb250aW51YXRpb24uICopXG5cbiAgdmFsIGFjdGlvbjpcbiAgICBzdGF0ZSAtPlxuICAgIHRlcm1pbmFsIC0+XG4gICAgc2VtYW50aWNfdmFsdWUgLT5cbiAgICAoJ2VudiAtPiBib29sIC0+IHRlcm1pbmFsIC0+IHNlbWFudGljX3ZhbHVlIC0+IHN0YXRlIC0+ICdhbnN3ZXIpIC0+XG4gICAgKCdlbnYgLT4gcHJvZHVjdGlvbiAtPiAnYW5zd2VyKSAtPlxuICAgICgnZW52IC0+ICdhbnN3ZXIpIC0+XG4gICAgJ2VudiAtPiAnYW5zd2VyXG5cbiAgKCogVGhpcyBpcyB0aGUgYXV0b21hdG9uJ3MgZ290byB0YWJsZS4gVGhpcyB0YWJsZSBtYXBzIGEgcGFpciBvZiBhIHN0YXRlXG4gICAgIGFuZCBhIG5vbnRlcm1pbmFsIHN5bWJvbCB0byBhIG5ldyBzdGF0ZS4gQnkgZXh0ZW5zaW9uLCBpdCBhbHNvIG1hcHMgYVxuICAgICBwYWlyIG9mIGEgc3RhdGUgYW5kIGEgcHJvZHVjdGlvbiB0byBhIG5ldyBzdGF0ZS4gKilcblxuICAoKiBUaGUgZnVuY3Rpb24gW2dvdG9fbnRdIGNhbiBiZSBhcHBsaWVkIHRvIFtzXSBhbmQgW250XSBPTkxZIGlmIHRoZSBzdGF0ZVxuICAgICBbc10gaGFzIGFuIG91dGdvaW5nIHRyYW5zaXRpb24gbGFiZWxlZCBbbnRdLiBPdGhlcndpc2UsIGl0cyByZXN1bHQgaXNcbiAgICAgdW5kZWZpbmVkLiBTaW1pbGFybHksIHRoZSBjYWxsIFtnb3RvX3Byb2QgcHJvZCBzXSBpcyBwZXJtaXR0ZWQgT05MWSBpZlxuICAgICB0aGUgc3RhdGUgW3NdIGhhcyBhbiBvdXRnb2luZyB0cmFuc2l0aW9uIGxhYmVsZWQgd2l0aCB0aGUgbm9udGVybWluYWxcbiAgICAgc3ltYm9sIFtsaHMgcHJvZF0uIFRoZSBmdW5jdGlvbiBbbWF5YmVfZ290b19udF0gaW52b2x2ZXMgYW4gYWRkaXRpb25hbFxuICAgICBkeW5hbWljIGNoZWNrIGFuZCBDQU4gYmUgY2FsbGVkIGV2ZW4gaWYgdGhlcmUgaXMgbm8gb3V0Z29pbmcgdHJhbnNpdGlvbi4gKilcblxuICB2YWwgICAgICAgZ290b19udCAgOiBzdGF0ZSAtPiBub250ZXJtaW5hbCAtPiBzdGF0ZVxuICB2YWwgICAgICAgZ290b19wcm9kOiBzdGF0ZSAtPiBwcm9kdWN0aW9uICAtPiBzdGF0ZVxuICB2YWwgbWF5YmVfZ290b19udDogICBzdGF0ZSAtPiBub250ZXJtaW5hbCAtPiBzdGF0ZSBvcHRpb25cblxuICAoKiBbaXNfc3RhcnQgcHJvZF0gdGVsbHMgd2hldGhlciB0aGUgcHJvZHVjdGlvbiBbcHJvZF0gaXMgYSBzdGFydCBwcm9kdWN0aW9uLiAqKVxuXG4gIHZhbCBpc19zdGFydDogcHJvZHVjdGlvbiAtPiBib29sXG5cbiAgKCogQnkgY29udmVudGlvbiwgYSBzZW1hbnRpYyBhY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yOlxuXG4gICAgIDEuIGZldGNoaW5nIHdoYXRldmVyIHNlbWFudGljIHZhbHVlcyBhbmQgcG9zaXRpb25zIGl0IG5lZWRzIG9mZiB0aGUgc3RhY2s7XG5cbiAgICAgMi4gcG9wcGluZyBhbiBhcHByb3ByaWF0ZSBudW1iZXIgb2YgY2VsbHMgb2ZmIHRoZSBzdGFjaywgYXMgZGljdGF0ZWRcbiAgICAgICAgYnkgdGhlIGxlbmd0aCBvZiB0aGUgcmlnaHQtaGFuZCBzaWRlIG9mIHRoZSBwcm9kdWN0aW9uO1xuXG4gICAgIDMuIGNvbXB1dGluZyBhIG5ldyBzZW1hbnRpYyB2YWx1ZSwgYXMgd2VsbCBhcyBuZXcgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnM7XG5cbiAgICAgNC4gcHVzaGluZyBhIG5ldyBzdGFjayBjZWxsLCB3aGljaCBjb250YWlucyB0aGUgdGhyZWUgdmFsdWVzXG4gICAgICAgIGNvbXB1dGVkIGluIHN0ZXAgMztcblxuICAgICA1LiByZXR1cm5pbmcgdGhlIG5ldyBzdGFjayBjb21wdXRlZCBpbiBzdGVwcyAyIGFuZCA0LlxuXG4gICAgIFBvaW50IDEgaXMgZXNzZW50aWFsbHkgZm9yY2VkIHVwb24gdXM6IGlmIHNlbWFudGljIHZhbHVlcyB3ZXJlIGZldGNoZWRcbiAgICAgb2ZmIHRoZSBzdGFjayBieSB0aGlzIGludGVycHJldGVyLCB0aGVuIHRoZSBjYWxsaW5nIGNvbnZlbnRpb24gZm9yXG4gICAgIHNlbWFudGljIGFjdGlvbnMgd291bGQgYmUgdmFyaWFkaWM6IG5vdCBhbGwgc2VtYW50aWMgYWN0aW9ucyB3b3VsZCBoYXZlXG4gICAgIHRoZSBzYW1lIG51bWJlciBvZiBhcmd1bWVudHMuIFRoZSByZXN0IGZvbGxvd3MgcmF0aGVyIG5hdHVyYWxseS4gKilcblxuICAoKiBTZW1hbnRpYyBhY3Rpb25zIGFyZSBhbGxvd2VkIHRvIHJhaXNlIFtFcnJvcl0uICopXG5cbiAgZXhjZXB0aW9uIEVycm9yXG5cbiAgdHlwZSBzZW1hbnRpY19hY3Rpb24gPVxuICAgICAgKHN0YXRlLCBzZW1hbnRpY192YWx1ZSwgdG9rZW4pIGVudiAtPiAoc3RhdGUsIHNlbWFudGljX3ZhbHVlKSBzdGFja1xuXG4gIHZhbCBzZW1hbnRpY19hY3Rpb246IHByb2R1Y3Rpb24gLT4gc2VtYW50aWNfYWN0aW9uXG5cbiAgKCogW21heV9yZWR1Y2Ugc3RhdGUgcHJvZF0gdGVzdHMgd2hldGhlciB0aGUgc3RhdGUgW3N0YXRlXSBpcyBjYXBhYmxlIG9mXG4gICAgIHJlZHVjaW5nIHRoZSBwcm9kdWN0aW9uIFtwcm9kXS4gVGhpcyBmdW5jdGlvbiBpcyBjdXJyZW50bHkgY29zdGx5IGFuZFxuICAgICBpcyBub3QgdXNlZCBieSB0aGUgY29yZSBMUiBlbmdpbmUuIEl0IGlzIHVzZWQgaW4gdGhlIGltcGxlbWVudGF0aW9uXG4gICAgIG9mIGNlcnRhaW4gZnVuY3Rpb25zLCBzdWNoIGFzIFtmb3JjZV9yZWR1Y3Rpb25dLCB3aGljaCBhbGxvdyB0aGUgZW5naW5lXG4gICAgIHRvIGJlIGRyaXZlbiBwcm9ncmFtbWF0aWNhbGx5LiAqKVxuXG4gIHZhbCBtYXlfcmVkdWNlOiBzdGF0ZSAtPiBwcm9kdWN0aW9uIC0+IGJvb2xcblxuICAoKiBJZiB0aGUgZmxhZyBbbG9nXSBpcyBmYWxzZSwgdGhlbiB0aGUgbG9nZ2luZyBmdW5jdGlvbnMgYXJlIG5vdCBjYWxsZWQuXG4gICAgIElmIGl0IGlzIFt0cnVlXSwgdGhlbiB0aGV5IGFyZSBjYWxsZWQuICopXG5cbiAgdmFsIGxvZyA6IGJvb2xcblxuICAoKiBUaGUgbG9nZ2luZyBob29rcyByZXF1aXJlZCBieSB0aGUgTFIgZW5naW5lLiAqKVxuXG4gIG1vZHVsZSBMb2cgOiBMT0dcbiAgICB3aXRoIHR5cGUgc3RhdGUgOj0gc3RhdGVcbiAgICAgYW5kIHR5cGUgdGVybWluYWwgOj0gdGVybWluYWxcbiAgICAgYW5kIHR5cGUgcHJvZHVjdGlvbiA6PSBwcm9kdWN0aW9uXG5cbmVuZFxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuKCogVGhpcyBzaWduYXR1cmUgZGVzY3JpYmVzIHRoZSBtb25vbGl0aGljICh0cmFkaXRpb25hbCkgTFIgZW5naW5lLiAqKVxuXG4oKiBJbiB0aGlzIGludGVyZmFjZSwgdGhlIHBhcnNlciBjb250cm9scyB0aGUgbGV4ZXIuICopXG5cbm1vZHVsZSB0eXBlIE1PTk9MSVRISUNfRU5HSU5FID0gc2lnXG5cbiAgdHlwZSBzdGF0ZVxuXG4gIHR5cGUgdG9rZW5cblxuICB0eXBlIHNlbWFudGljX3ZhbHVlXG5cbiAgKCogQW4gZW50cnkgcG9pbnQgdG8gdGhlIGVuZ2luZSByZXF1aXJlcyBhIHN0YXJ0IHN0YXRlLCBhIGxleGVyLCBhbmQgYSBsZXhpbmdcbiAgICAgYnVmZmVyLiBJdCBlaXRoZXIgc3VjY2VlZHMgYW5kIHByb2R1Y2VzIGEgc2VtYW50aWMgdmFsdWUsIG9yIGZhaWxzIGFuZFxuICAgICByYWlzZXMgW0Vycm9yXS4gKilcblxuICBleGNlcHRpb24gRXJyb3JcblxuICB2YWwgZW50cnk6XG4gICAgKCogc3RyYXRlZ3k6ICopIFsgYExlZ2FjeSB8IGBTaW1wbGlmaWVkIF0gLT4gKCogc2VlIFtJbmNyZW1lbnRhbEVuZ2luZV0gKilcbiAgICBzdGF0ZSAtPlxuICAgIChMZXhpbmcubGV4YnVmIC0+IHRva2VuKSAtPlxuICAgIExleGluZy5sZXhidWYgLT5cbiAgICBzZW1hbnRpY192YWx1ZVxuXG5lbmRcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbigqIFRoZSBmb2xsb3dpbmcgc2lnbmF0dXJlcyBkZXNjcmliZSB0aGUgaW5jcmVtZW50YWwgTFIgZW5naW5lLiAqKVxuXG4oKiBGaXJzdCwgc2VlIFtJTkNSRU1FTlRBTF9FTkdJTkVdIGluIHRoZSBmaWxlIFtJbmNyZW1lbnRhbEVuZ2luZS5tbF0uICopXG5cbigqIFRoZSBbc3RhcnRdIGZ1bmN0aW9uIGlzIHNldCBhcGFydCBiZWNhdXNlIHdlIGRvIG5vdCB3aXNoIHRvIHB1Ymxpc2hcbiAgIGl0IGFzIHBhcnQgb2YgdGhlIGdlbmVyYXRlZCBbcGFyc2VyLm1saV0gZmlsZS4gSW5zdGVhZCwgdGhlIHRhYmxlXG4gICBiYWNrLWVuZCB3aWxsIHB1Ymxpc2ggc3BlY2lhbGl6ZWQgdmVyc2lvbnMgb2YgaXQsIHdpdGggYSBzdWl0YWJsZVxuICAgdHlwZSBjYXN0LiAqKVxuXG5tb2R1bGUgdHlwZSBJTkNSRU1FTlRBTF9FTkdJTkVfU1RBUlQgPSBzaWdcblxuICAoKiBbc3RhcnRdIGlzIGFuIGVudHJ5IHBvaW50LiBJdCByZXF1aXJlcyBhIHN0YXJ0IHN0YXRlIGFuZCBhIHN0YXJ0IHBvc2l0aW9uXG4gICAgIGFuZCBiZWdpbnMgdGhlIHBhcnNpbmcgcHJvY2Vzcy4gSWYgdGhlIGxleGVyIGlzIGJhc2VkIG9uIGFuIE9DYW1sIGxleGluZ1xuICAgICBidWZmZXIsIHRoZSBzdGFydCBwb3NpdGlvbiBzaG91bGQgYmUgW2xleGJ1Zi5sZXhfY3Vycl9wXS4gW3N0YXJ0XSBwcm9kdWNlc1xuICAgICBhIGNoZWNrcG9pbnQsIHdoaWNoIHVzdWFsbHkgd2lsbCBiZSBhbiBbSW5wdXROZWVkZWRdIGNoZWNrcG9pbnQuIChJdCBjb3VsZFxuICAgICBiZSBbQWNjZXB0ZWRdIGlmIHRoaXMgc3RhcnRpbmcgc3RhdGUgYWNjZXB0cyBvbmx5IHRoZSBlbXB0eSB3b3JkLiBJdCBjb3VsZFxuICAgICBiZSBbUmVqZWN0ZWRdIGlmIHRoaXMgc3RhcnRpbmcgc3RhdGUgYWNjZXB0cyBubyB3b3JkIGF0IGFsbC4pIEl0IGRvZXMgbm90XG4gICAgIHJhaXNlIGFueSBleGNlcHRpb24uICopXG5cbiAgKCogW3N0YXJ0IHMgcG9zXSBzaG91bGQgcmVhbGx5IHByb2R1Y2UgYSBjaGVja3BvaW50IG9mIHR5cGUgWydhIGNoZWNrcG9pbnRdLFxuICAgICBmb3IgYSBmaXhlZCBbJ2FdIHRoYXQgZGVwZW5kcyBvbiB0aGUgc3RhdGUgW3NdLiBXZSBjYW5ub3QgZXhwcmVzcyB0aGlzLCBzb1xuICAgICB3ZSB1c2UgW3NlbWFudGljX3ZhbHVlIGNoZWNrcG9pbnRdLCB3aGljaCBpcyBzYWZlLiBUaGUgdGFibGUgYmFjay1lbmQgdXNlc1xuICAgICBbT2JqLm1hZ2ljXSB0byBwcm9kdWNlIHNhZmUgc3BlY2lhbGl6ZWQgdmVyc2lvbnMgb2YgW3N0YXJ0XS4gKilcblxuICB0eXBlIHN0YXRlXG4gIHR5cGUgc2VtYW50aWNfdmFsdWVcbiAgdHlwZSAnYSBjaGVja3BvaW50XG5cbiAgdmFsIHN0YXJ0OlxuICAgIHN0YXRlIC0+XG4gICAgTGV4aW5nLnBvc2l0aW9uIC0+XG4gICAgc2VtYW50aWNfdmFsdWUgY2hlY2twb2ludFxuXG5lbmRcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbigqIFRoaXMgc2lnbmF0dXJlIGRlc2NyaWJlcyB0aGUgTFIgZW5naW5lLCB3aGljaCBjb21iaW5lcyB0aGUgbW9ub2xpdGhpY1xuICAgYW5kIGluY3JlbWVudGFsIGludGVyZmFjZXMuICopXG5cbm1vZHVsZSB0eXBlIEVOR0lORSA9IHNpZ1xuXG4gIGluY2x1ZGUgTU9OT0xJVEhJQ19FTkdJTkVcblxuICBpbmNsdWRlIEluY3JlbWVudGFsRW5naW5lLklOQ1JFTUVOVEFMX0VOR0lORVxuICAgIHdpdGggdHlwZSB0b2tlbiA6PSB0b2tlblxuICAgICBhbmQgdHlwZSAnYSBscjFzdGF0ZSA9IHN0YXRlICgqIHVzZWZ1bCBmb3IgdXM7IGhpZGRlbiBmcm9tIHRoZSBlbmQgdXNlciAqKVxuXG4gIGluY2x1ZGUgSU5DUkVNRU5UQUxfRU5HSU5FX1NUQVJUXG4gICAgd2l0aCB0eXBlIHN0YXRlIDo9IHN0YXRlXG4gICAgIGFuZCB0eXBlIHNlbWFudGljX3ZhbHVlIDo9IHNlbWFudGljX3ZhbHVlXG4gICAgIGFuZCB0eXBlICdhIGNoZWNrcG9pbnQgOj0gJ2EgY2hlY2twb2ludFxuXG5lbmRcbmVuZFxubW9kdWxlIEVuZ2luZSA9IHN0cnVjdFxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IElucmlhLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgICAgICopXG4oKiAgIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExpYnJhcnkgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIsIHdpdGggYSAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nLCBhcyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHBvc2l0aW9uID0gTGV4aW5nLnBvc2l0aW9uXG5vcGVuIEVuZ2luZVR5cGVzXG5cbigqIFRoZSBMUiBwYXJzaW5nIGVuZ2luZS4gKilcblxuKCogVGhpcyBtb2R1bGUgaXMgdXNlZDpcblxuICAgLSBhdCBjb21waWxlIHRpbWUsIGlmIHNvIHJlcXVlc3RlZCBieSB0aGUgdXNlciwgdmlhIHRoZSAtLWludGVycHJldCBvcHRpb25zO1xuICAgLSBhdCBydW4gdGltZSwgaW4gdGhlIHRhYmxlLWJhc2VkIGJhY2stZW5kLiAqKVxuXG5tb2R1bGUgTWFrZSAoVCA6IFRBQkxFKSA9IHN0cnVjdFxuXG4gICgqIFRoaXMgcHJvcGFnYXRlcyB0eXBlIGFuZCBleGNlcHRpb24gZGVmaW5pdGlvbnMuIFRoZSBmdW5jdGlvbnMgW251bWJlcl0sXG4gICAgIFtwcm9kdWN0aW9uX2luZGV4XSwgW2ZpbmRfcHJvZHVjdGlvbl0sIHRvbywgYXJlIGRlZmluZWQgYnkgdGhpcyBbaW5jbHVkZV1cbiAgICAgZGVjbGFyYXRpb24uICopXG5cbiAgaW5jbHVkZSBUXG5cbiAgdHlwZSAnYSBlbnYgPVxuICAgICAgKHN0YXRlLCBzZW1hbnRpY192YWx1ZSwgdG9rZW4pIEVuZ2luZVR5cGVzLmVudlxuXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4gICgqIFRoZSB0eXBlIFtjaGVja3BvaW50XSByZXByZXNlbnRzIGFuIGludGVybWVkaWF0ZSBvciBmaW5hbCByZXN1bHQgb2YgdGhlXG4gICAgIHBhcnNlci4gU2VlIFtFbmdpbmVUeXBlc10uICopXG5cbiAgKCogVGhlIHR5cGUgW2NoZWNrcG9pbnRdIGlzIHByZXNlbnRlZCB0byB0aGUgdXNlciBhcyBhIHByaXZhdGUgdHlwZSAoc2VlXG4gICAgIFtJbmNyZW1lbnRhbEVuZ2luZV0pLiBUaGlzIHByZXZlbnRzIHRoZSB1c2VyIGZyb20gbWFudWZhY3R1cmluZ1xuICAgICBjaGVja3BvaW50cyAoaS5lLiwgY29udGludWF0aW9ucykgdGhhdCBkbyBub3QgbWFrZSBzZW5zZS4gKFN1Y2hcbiAgICAgY29udGludWF0aW9ucyBjb3VsZCBwb3RlbnRpYWxseSB2aW9sYXRlIHRoZSBMUiBpbnZhcmlhbnQgYW5kIGxlYWQgdG9cbiAgICAgY3Jhc2hlcy4pICopXG5cbiAgKCogMjAxNy8wMy8yOSBBbHRob3VnaCBbY2hlY2twb2ludF0gaXMgYSBwcml2YXRlIHR5cGUsIHdlIG5vdyBleHBvc2UgYVxuICAgICBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgW2lucHV0X25lZWRlZF0uIFRoaXMgZnVuY3Rpb24gYWxsb3dzIG1hbnVmYWN0dXJpbmdcbiAgICAgYSBjaGVja3BvaW50IG91dCBvZiBhbiBlbnZpcm9ubWVudC4gRm9yIHRoaXMgcmVhc29uLCB0aGUgdHlwZSBbZW52XSBtdXN0XG4gICAgIGFsc28gYmUgcGFyYW1ldGVyaXplZCB3aXRoIFsnYV0uICopXG5cbiAgdHlwZSAnYSBjaGVja3BvaW50ID1cbiAgICB8IElucHV0TmVlZGVkIG9mICdhIGVudlxuICAgIHwgU2hpZnRpbmcgb2YgJ2EgZW52ICogJ2EgZW52ICogYm9vbFxuICAgIHwgQWJvdXRUb1JlZHVjZSBvZiAnYSBlbnYgKiBwcm9kdWN0aW9uXG4gICAgfCBIYW5kbGluZ0Vycm9yIG9mICdhIGVudlxuICAgIHwgQWNjZXB0ZWQgb2YgJ2FcbiAgICB8IFJlamVjdGVkXG5cbiAgKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbiAgKCogQXMgb2YgMjAyMC8xMi8xNiwgd2UgaW50cm9kdWNlIGEgY2hvaWNlIGJldHdlZW4gbXVsdGlwbGUgZXJyb3IgaGFuZGxpbmdcbiAgICAgc3RyYXRlZ2llcy4gKilcblxuICAoKiBSZWdhcmRsZXNzIG9mIHRoZSBzdHJhdGVneSwgd2hlbiBhIHN5bnRheCBlcnJvciBpcyBlbmNvdW50ZXJlZCwgdGhlXG4gICAgIGZ1bmN0aW9uIFtpbml0aWF0ZV0gaXMgY2FsbGVkLCBhIFtIYW5kbGluZ0Vycm9yXSBjaGVja3BvaW50IGlzIHByb2R1Y2VkLFxuICAgICBhbmQgKGFmdGVyIHJlc3VtaW5nKSB0aGUgZnVuY3Rpb24gW2Vycm9yXSBpcyBjYWxsZWQuIFRoaXMgZnVuY3Rpb24gY2hlY2tzXG4gICAgIHdoZXRoZXIgdGhlIGN1cnJlbnQgc3RhdGUgYWxsb3dzIHNoaWZ0aW5nLCByZWR1Y2luZywgb3IgbmVpdGhlciwgd2hlbiB0aGVcbiAgICAgbG9va2FoZWFkIHRva2VuIGlzIFtlcnJvcl0uIEl0cyBiZWhhdmlvciwgdGhlbiwgZGVwZW5kcyBvbiB0aGUgc3RyYXRlZ3ksXG4gICAgIGFzIGZvbGxvd3MuICopXG5cbiAgKCogSW4gdGhlIGxlZ2FjeSBzdHJhdGVneSwgd2hpY2ggdW50aWwgbm93IHdhcyB0aGUgb25seSBzdHJhdGVneSxcblxuICAgICAtIElmIHNoaWZ0aW5nIGlzIHBvc3NpYmxlLCB0aGVuIGEgW1NoaWZ0aW5nXSBjaGVja3BvaW50IGlzIHByb2R1Y2VkLFxuICAgICAgIHdob3NlIGZpZWxkIFtwbGVhc2VfZGlzY2FyZF0gaXMgW3RydWVdLCBzbyAoYWZ0ZXIgcmVzdW1pbmcpIGFuXG4gICAgICAgW0lucHV0TmVlZGVkXSBjaGVja3BvaW50IGlzIHByb2R1Y2VkLCBhbmQgKGFmdGVyIGEgbmV3IHRva2VuXG4gICAgICAgaGFzIGJlZW4gcHJvdmlkZWQpIHRoZSBwYXJzZXIgbGVhdmVzIGVycm9yLWhhbmRsaW5nIG1vZGUgYW5kXG4gICAgICAgcmV0dXJucyB0byBub3JtYWwgbW9kZS5cblxuICAgICAtIElmIHJlZHVjaW5nIGlzIHBvc3NpYmxlLCB0aGVuIG9uZSBvciBtb3JlIHJlZHVjdGlvbnMgYXJlIHBlcmZvcm1lZC5cbiAgICAgICBEZWZhdWx0IHJlZHVjdGlvbnMgYXJlIGFubm91bmNlZCB2aWEgW0Fib3V0VG9SZWR1Y2VdIGNoZWNrcG9pbnRzLFxuICAgICAgIHdoZXJlYXMgb3JkaW5hcnkgcmVkdWN0aW9ucyBhcmUgcGVyZm9ybWVkIHNpbGVudGx5LiAoSXQgaXMgdW5jbGVhclxuICAgICAgIHdoeSB0aGlzIGlzIHNvLikgVGhlIHBhcnNlciByZW1haW5zIGluIGVycm9yLWhhbmRsaW5nIG1vZGUsIHNvXG4gICAgICAgYW5vdGhlciBbSGFuZGxpbmdFcnJvcl0gY2hlY2twb2ludCBpcyBwcm9kdWNlZCwgYW5kIHRoZSBmdW5jdGlvblxuICAgICAgIFtlcnJvcl0gaXMgY2FsbGVkIGFnYWluLlxuXG4gICAgIC0gSWYgbmVpdGhlciBhY3Rpb24gaXMgcG9zc2libGUgYW5kIGlmIHRoZSBzdGFjayBpcyBub25lbXB0eSwgdGhlbiBhXG4gICAgICAgY2VsbCBpcyBwb3BwZWQgb2ZmIHRoZSBzdGFjaywgdGhlbiBhIFtIYW5kbGluZ0Vycm9yXSBjaGVja3BvaW50IGlzXG4gICAgICAgcHJvZHVjZWQsIGFuZCB0aGUgZnVuY3Rpb24gW2Vycm9yXSBpcyBjYWxsZWQgYWdhaW4uXG5cbiAgICAgLSBJZiBuZWl0aGVyIGFjdGlvbiBpcyBwb3NzaWJsZSBhbmQgaWYgdGhlIHN0YWNrIGlzIGVtcHR5LCB0aGVuIHRoZVxuICAgICAgIHBhcnNlIGRpZXMgd2l0aCBhIFtSZWplY3RdIGNoZWNrcG9pbnQuICopXG5cbiAgKCogVGhlIHNpbXBsaWZpZWQgc3RyYXRlZ3kgZGlmZmVycyBmcm9tIHRoZSBsZWdhY3kgc3RyYXRlZ3kgYXMgZm9sbG93czpcblxuICAgICAtIFdoZW4gc2hpZnRpbmcsIGEgW1NoaWZ0aW5nXSBjaGVja3BvaW50IGlzIHByb2R1Y2VkLCB3aG9zZSBmaWVsZFxuICAgICAgIFtwbGVhc2VfZGlzY2FyZF0gaXMgW2ZhbHNlXSwgc28gdGhlIHBhcnNlciBkb2VzIG5vdCByZXF1ZXN0IGFub3RoZXJcbiAgICAgICB0b2tlbiwgYW5kIHRoZSBwYXJzZXIgcmVtYWlucyBpbiBlcnJvci1oYW5kbGluZyBtb2RlLiAoSWYgdGhlXG4gICAgICAgZGVzdGluYXRpb24gc3RhdGUgb2YgdGhpcyBzaGlmdCB0cmFuc2l0aW9uIGhhcyBhIGRlZmF1bHQgcmVkdWN0aW9uLFxuICAgICAgIHRoZW4gdGhlIHBhcnNlciB3aWxsIHBlcmZvcm0gdGhpcyByZWR1Y3Rpb24gYXMgaXRzIG5leHQgc3RlcC4pXG5cbiAgICAgLSBXaGVuIHJlZHVjaW5nLCBhbGwgcmVkdWN0aW9ucyBhcmUgYW5ub3VuY2VkIGJ5IFtBYm91dFRvUmVkdWNlXVxuICAgICAgIGNoZWNrcG9pbnRzLlxuXG4gICAgIC0gSWYgbmVpdGhlciBzaGlmdGluZyBbZXJyb3JdIG5vciByZWR1Y2luZyBvbiBbZXJyb3JdIGlzIHBvc3NpYmxlLFxuICAgICAgIHRoZW4gdGhlIHBhcnNlciBkaWVzIHdpdGggYSBbUmVqZWN0XSBjaGVja3BvaW50LiAoVGhlIHBhcnNlciBkb2VzXG4gICAgICAgbm90IGF0dGVtcHQgdG8gcG9wIGNlbGxzIG9mZiB0aGUgc3RhY2sgb25lIGJ5IG9uZS4pXG5cbiAgICAgVGhpcyBzaW1wbGlmaWVkIHN0cmF0ZWd5IGlzIGFwcHJvcHJpYXRlIHdoZW4gdGhlIGdyYW1tYXIgdXNlcyB0aGUgW2Vycm9yXVxuICAgICB0b2tlbiBpbiBhIGxpbWl0ZWQgd2F5LCB3aGVyZSB0aGUgW2Vycm9yXSB0b2tlbiBhbHdheXMgYXBwZWFycyBhdCB0aGUgZW5kXG4gICAgIG9mIGEgcHJvZHVjdGlvbiB3aG9zZSBzZW1hbnRpYyBhY3Rpb24gcmFpc2VzIGFuIGV4Y2VwdGlvbiAod2hvc2UgcHVycG9zZVxuICAgICBpcyB0byBzaWduYWwgYSBzeW50YXggZXJyb3IgYW5kIHBlcmhhcHMgcHJvZHVjZSBhIGN1c3RvbSBtZXNzYWdlKS4gVGhlbixcbiAgICAgdGhlIHBhcnNlciBtdXN0IG5vdCByZXF1ZXN0IG9uZSB0b2tlbiBwYXN0IHRoZSBzeW50YXggZXJyb3IuIChJbiBhIFJFUEwsXG4gICAgIHRoYXQgd291bGQgYmUgdW5kZXNpcmFibGUuKSBJdCBtdXN0IHBlcmZvcm0gYXMgbWFueSByZWR1Y3Rpb25zIG9uIFtlcnJvcl1cbiAgICAgYXMgcG9zc2libGUsIHRoZW4gKGlmIHBvc3NpYmxlKSBzaGlmdCB0aGUgW2Vycm9yXSB0b2tlbiBhbmQgbW92ZSB0byBhIG5ld1xuICAgICBzdGF0ZSB3aGVyZSBhIGRlZmF1bHQgcmVkdWN0aW9uIHdpbGwgYmUgcG9zc2libGUuIChCZWNhdXNlIHRoZSBbZXJyb3JdXG4gICAgIHRva2VuIGFsd2F5cyBhcHBlYXJzIGF0IHRoZSBlbmQgb2YgYSBwcm9kdWN0aW9uLCBubyBvdGhlciBhY3Rpb24gY2FuXG4gICAgIGV4aXN0IGluIHRoYXQgc3RhdGUsIHNvIGEgZGVmYXVsdCByZWR1Y3Rpb24gbXVzdCBleGlzdC4pIFRoZSBzZW1hbnRpY1xuICAgICBhY3Rpb24gcmFpc2VzIGFuIGV4Y2VwdGlvbiwgYW5kIHRoYXQgaXMgaXQuICopXG5cbiAgKCogTGV0IHVzIG5vdGUgdGhhdCBpdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHBlcmZvcm0gbm8gZXJyb3IgaGFuZGxpbmcgYXRcbiAgICAgYWxsLCBvciB0byBwZXJmb3JtIGN1c3RvbWl6ZWQgZXJyb3IgaGFuZGxpbmcsIGJ5IHN0b3BwaW5nIGFzIHNvb24gYXNcbiAgICAgdGhlIGZpcnN0IFtFcnJvckhhbmRsaW5nXSBjaGVja3BvaW50IGFwcGVhcnMuICopXG5cbiAgdHlwZSBzdHJhdGVneSA9XG4gICAgWyBgTGVnYWN5IHwgYFNpbXBsaWZpZWQgXVxuXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4gICgqIEluIHRoZSBjb2RlLWJhc2VkIGJhY2stZW5kLCB0aGUgW3J1bl0gZnVuY3Rpb24gaXMgc29tZXRpbWVzIHJlc3BvbnNpYmxlXG4gICAgIGZvciBwdXNoaW5nIGEgbmV3IGNlbGwgb24gdGhlIHN0YWNrLiBUaGlzIGlzIG1vdGl2YXRlZCBieSBjb2RlIHNoYXJpbmdcbiAgICAgY29uY2VybnMuIEluIHRoaXMgaW50ZXJwcmV0ZXIsIHRoZXJlIGlzIG5vIHN1Y2ggY29uY2VybjsgW3J1bl0ncyBjYWxsZXJcbiAgICAgaXMgYWx3YXlzIHJlc3BvbnNpYmxlIGZvciB1cGRhdGluZyB0aGUgc3RhY2suICopXG5cbiAgKCogSW4gdGhlIGNvZGUtYmFzZWQgYmFjay1lbmQsIHRoZXJlIGlzIGEgW3J1bl0gZnVuY3Rpb24gZm9yIGVhY2ggc3RhdGVcbiAgICAgW3NdLiBUaGlzIGZ1bmN0aW9uIGNhbiBiZWhhdmUgaW4gdHdvIHNsaWdodGx5IGRpZmZlcmVudCB3YXlzLCBkZXBlbmRpbmdcbiAgICAgb24gd2hlbiBpdCBpcyBpbnZva2VkLCBvciAoZXF1aXZhbGVudGx5KSBkZXBlbmRpbmcgb24gW3NdLlxuXG4gICAgIElmIFtydW5dIGlzIGludm9rZWQgYWZ0ZXIgc2hpZnRpbmcgYSB0ZXJtaW5hbCBzeW1ib2wgKG9yLCBlcXVpdmFsZW50bHksXG4gICAgIGlmIFtzXSBoYXMgYSB0ZXJtaW5hbCBpbmNvbWluZyBzeW1ib2wpLCB0aGVuIFtydW5dIGRpc2NhcmRzIGEgdG9rZW4sXG4gICAgIHVubGVzcyBbc10gaGFzIGEgZGVmYXVsdCByZWR1Y3Rpb24gb24gWyNdLiAoSW5kZWVkLCBpbiB0aGF0IGNhc2UsXG4gICAgIHJlcXVlc3RpbmcgdGhlIG5leHQgdG9rZW4gbWlnaHQgZHJpdmUgdGhlIGxleGVyIG9mZiB0aGUgZW5kIG9mIHRoZSBpbnB1dFxuICAgICBzdHJlYW0uKVxuXG4gICAgIElmLCBvbiB0aGUgb3RoZXIgaGFuZCwgW3J1bl0gaXMgaW52b2tlZCBhZnRlciBwZXJmb3JtaW5nIGEgZ290b1xuICAgICB0cmFuc2l0aW9uLCBvciBpbnZva2VkIGRpcmVjdGx5IGJ5IGFuIGVudHJ5IHBvaW50LCB0aGVuIHRoZXJlIGlzIG5vdGhpbmdcbiAgICAgdG8gZGlzY2FyZC5cblxuICAgICBUaGVzZSB0d28gY2FzZXMgYXJlIHJlZmxlY3RlZCBpbiBbQ29kZUJhY2tlbmQuZ2V0dG9rZW5dLlxuXG4gICAgIEhlcmUsIHRoZSBjb2RlIGlzIHN0cnVjdHVyZWQgaW4gYSBzbGlnaHRseSBkaWZmZXJlbnQgd2F5LiBJdCBpcyB1cCB0byB0aGVcbiAgICAgY2FsbGVyIG9mIFtydW5dIHRvIGluZGljYXRlIHdoZXRoZXIgdG8gZGlzY2FyZCBhIHRva2VuLCB2aWEgdGhlIHBhcmFtZXRlclxuICAgICBbcGxlYXNlX2Rpc2NhcmRdLiBUaGlzIGZsYWcgaXMgc2V0IHdoZW4gW3NdIGlzIGJlaW5nIGVudGVyZWQgYnkgc2hpZnRpbmdcbiAgICAgYSB0ZXJtaW5hbCBzeW1ib2wgYW5kIFtzXSBkb2VzIG5vdCBoYXZlIGEgZGVmYXVsdCByZWR1Y3Rpb24gb24gWyNdLiAqKVxuXG4gICgqIFRoZSBmb2xsb3dpbmcgcmVjdXJzaXZlIGdyb3VwIG9mIGZ1bmN0aW9ucyBhcmUgdGFpbCByZWN1cnNpdmUsIHByb2R1Y2UgYVxuICAgICBjaGVja3BvaW50IG9mIHR5cGUgW3NlbWFudGljX3ZhbHVlIGNoZWNrcG9pbnRdLCBhbmQgY2Fubm90IHJhaXNlIGFuXG4gICAgIGV4Y2VwdGlvbi4gKilcblxuICBsZXQgcmVjIHJ1biBlbnYgcGxlYXNlX2Rpc2NhcmQgOiBzZW1hbnRpY192YWx1ZSBjaGVja3BvaW50ID1cblxuICAgICgqIExvZyB0aGUgZmFjdCB0aGF0IHdlIGp1c3QgZW50ZXJlZCB0aGlzIHN0YXRlLiAqKVxuXG4gICAgaWYgbG9nIHRoZW5cbiAgICAgIExvZy5zdGF0ZSBlbnYuY3VycmVudDtcblxuICAgICgqIElmIFtwbGVhc2VfZGlzY2FyZF0gaXMgc2V0LCB3ZSBkaXNjYXJkIHRoZSBjdXJyZW50IGxvb2thaGVhZCB0b2tlbiBhbmRcbiAgICAgICBmZXRjaCB0aGUgbmV4dCBvbmUuIEluIG9yZGVyIHRvIHJlcXVlc3QgYSB0b2tlbiBmcm9tIHRoZSB1c2VyLCB3ZVxuICAgICAgIHJldHVybiBhbiBbSW5wdXROZWVkZWRdIGNvbnRpbnVhdGlvbiwgd2hpY2gsIHdoZW4gaW52b2tlZCBieSB0aGUgdXNlcixcbiAgICAgICB3aWxsIHRha2UgdXMgdG8gW2Rpc2NhcmRdLiBJZiBbcGxlYXNlX2Rpc2NhcmRdIGlzIG5vdCBzZXQsIHdlIHNraXAgdGhpc1xuICAgICAgIHN0ZXAgYW5kIGp1bXAgZGlyZWN0bHkgdG8gW2NoZWNrX2Zvcl9kZWZhdWx0X3JlZHVjdGlvbl0uICopXG5cbiAgICBpZiBwbGVhc2VfZGlzY2FyZCB0aGVuXG4gICAgICBJbnB1dE5lZWRlZCBlbnZcbiAgICBlbHNlXG4gICAgICBjaGVja19mb3JfZGVmYXVsdF9yZWR1Y3Rpb24gZW52XG5cbiAgKCogW2Rpc2NhcmQgZW52IHRyaXBsZV0gc3RvcmVzIFt0cmlwbGVdIGludG8gW2Vudl0sIG92ZXJ3cml0aW5nIHRoZSBwcmV2aW91c1xuICAgICB0b2tlbi4gSXQgaXMgaW52b2tlZCBieSBbb2ZmZXJdLCB3aGljaCBpdHNlbGYgaXMgaW52b2tlZCBieSB0aGUgdXNlciBpblxuICAgICByZXNwb25zZSB0byBhbiBbSW5wdXROZWVkZWRdIGNoZWNrcG9pbnQuICopXG5cbiAgYW5kIGRpc2NhcmQgZW52IHRyaXBsZSA9XG4gICAgaWYgbG9nIHRoZW4gYmVnaW5cbiAgICAgIGxldCAodG9rZW4sIHN0YXJ0cCwgZW5kcCkgPSB0cmlwbGUgaW5cbiAgICAgIExvZy5sb29rYWhlYWRfdG9rZW4gKFQudG9rZW4ydGVybWluYWwgdG9rZW4pIHN0YXJ0cCBlbmRwXG4gICAgZW5kO1xuICAgIGxldCBlbnYgPSB7IGVudiB3aXRoIGVycm9yID0gZmFsc2U7IHRyaXBsZSB9IGluXG4gICAgY2hlY2tfZm9yX2RlZmF1bHRfcmVkdWN0aW9uIGVudlxuXG4gIGFuZCBjaGVja19mb3JfZGVmYXVsdF9yZWR1Y3Rpb24gZW52ID1cblxuICAgICgqIEV4YW1pbmUgd2hhdCBzaXR1YXRpb24gd2UgYXJlIGluLiBUaGlzIGNhc2UgYW5hbHlzaXMgaXMgYW5hbG9nb3VzIHRvXG4gICAgICAgdGhhdCBwZXJmb3JtZWQgaW4gW0NvZGVCYWNrZW5kLmdldHRva2VuXSwgaW4gdGhlIHN1Yi1jYXNlIHdoZXJlIHdlIGRvXG4gICAgICAgbm90IGhhdmUgYSB0ZXJtaW5hbCBpbmNvbWluZyBzeW1ib2wuICopXG5cbiAgICBULmRlZmF1bHRfcmVkdWN0aW9uXG4gICAgICBlbnYuY3VycmVudFxuICAgICAgYW5ub3VuY2VfcmVkdWNlICAgICAgICgqIHRoZXJlIGlzIGEgZGVmYXVsdCByZWR1Y3Rpb247IHBlcmZvcm0gaXQgKilcbiAgICAgIGNoZWNrX2Zvcl9lcnJvcl90b2tlbiAoKiB0aGVyZSBpcyBub25lOyBjb250aW51ZSBiZWxvdyAqKVxuICAgICAgZW52XG5cbiAgYW5kIGNoZWNrX2Zvcl9lcnJvcl90b2tlbiBlbnYgPVxuXG4gICAgKCogVGhlcmUgaXMgbm8gZGVmYXVsdCByZWR1Y3Rpb24uIENvbnN1bHQgdGhlIGN1cnJlbnQgbG9va2FoZWFkIHRva2VuXG4gICAgICAgc28gYXMgdG8gZGV0ZXJtaW5lIHdoaWNoIGFjdGlvbiBzaG91bGQgYmUgdGFrZW4uICopXG5cbiAgICAoKiBQZWVraW5nIGF0IHRoZSBmaXJzdCBpbnB1dCB0b2tlbiwgd2l0aG91dCB0YWtpbmcgaXQgb2ZmIHRoZSBpbnB1dFxuICAgICAgIHN0cmVhbSwgaXMgZG9uZSBieSByZWFkaW5nIFtlbnYudHJpcGxlXS4gV2UgYXJlIGNhcmVmdWwgdG8gZmlyc3RcbiAgICAgICBjaGVjayBbZW52LmVycm9yXS4gKilcblxuICAgICgqIE5vdGUgdGhhdCwgaWYgW3BsZWFzZV9kaXNjYXJkXSB3YXMgdHJ1ZSwgdGhlbiB3ZSBoYXZlIGp1c3QgY2FsbGVkXG4gICAgICAgW2Rpc2NhcmRdLCBzbyB0aGUgbG9va2FoZWFkIHRva2VuIGNhbm5vdCBiZSBbZXJyb3JdLiAqKVxuXG4gICAgKCogUmV0dXJuaW5nIFtIYW5kbGluZ0Vycm9yIGVudl0gaXMgbGlrZSBjYWxsaW5nIFtlcnJvciB+c3RyYXRlZ3kgZW52XVxuICAgICAgIGRpcmVjdGx5LCBleGNlcHQgaXQgYWxsb3dzIHRoZSB1c2VyIHRvIHJlZ2FpbiBjb250cm9sIGFuZCBjaG9vc2UgYW5cbiAgICAgICBlcnJvci1oYW5kbGluZyBzdHJhdGVneS4gKilcblxuICAgIGlmIGVudi5lcnJvciB0aGVuIGJlZ2luXG4gICAgICBpZiBsb2cgdGhlblxuICAgICAgICBMb2cucmVzdW1pbmdfZXJyb3JfaGFuZGxpbmcoKTtcbiAgICAgIEhhbmRsaW5nRXJyb3IgZW52XG4gICAgZW5kXG4gICAgZWxzZVxuICAgICAgbGV0ICh0b2tlbiwgXywgXykgPSBlbnYudHJpcGxlIGluXG5cbiAgICAgICgqIFdlIGNvbnN1bHQgdGhlIHR3by1kaW1lbnNpb25hbCBhY3Rpb24gdGFibGUsIGluZGV4ZWQgYnkgdGhlXG4gICAgICAgICBjdXJyZW50IHN0YXRlIGFuZCB0aGUgY3VycmVudCBsb29rYWhlYWQgdG9rZW4sIGluIG9yZGVyIHRvXG4gICAgICAgICBkZXRlcm1pbmUgd2hpY2ggYWN0aW9uIHNob3VsZCBiZSB0YWtlbi4gKilcblxuICAgICAgVC5hY3Rpb25cbiAgICAgICAgZW52LmN1cnJlbnQgICAgICAgICAgICAgICAgICAgICgqIGRldGVybWluZXMgYSByb3cgKilcbiAgICAgICAgKFQudG9rZW4ydGVybWluYWwgdG9rZW4pICAgICAgICgqIGRldGVybWluZXMgYSBjb2x1bW4gKilcbiAgICAgICAgKFQudG9rZW4ydmFsdWUgdG9rZW4pXG4gICAgICAgIHNoaWZ0ICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBzaGlmdCBjb250aW51YXRpb24gKilcbiAgICAgICAgYW5ub3VuY2VfcmVkdWNlICAgICAgICAgICAgICAgICgqIHJlZHVjZSBjb250aW51YXRpb24gKilcbiAgICAgICAgaW5pdGlhdGUgICAgICAgICAgICAgICAgICAgICAgICgqIGZhaWx1cmUgY29udGludWF0aW9uICopXG4gICAgICAgIGVudlxuXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4gICgqIFRoaXMgZnVuY3Rpb24gdGFrZXMgY2FyZSBvZiBzaGlmdCB0cmFuc2l0aW9ucyBhbG9uZyBhIHRlcm1pbmFsIHN5bWJvbC5cbiAgICAgKEdvdG8gdHJhbnNpdGlvbnMgYXJlIHRha2VuIGNhcmUgb2Ygd2l0aGluIFtyZWR1Y2VdIGJlbG93LikgVGhlIHN5bWJvbFxuICAgICBjYW4gYmUgZWl0aGVyIGFuIGFjdHVhbCB0b2tlbiBvciB0aGUgW2Vycm9yXSBwc2V1ZG8tdG9rZW4uICopXG5cbiAgKCogSGVyZSwgdGhlIGxvb2thaGVhZCB0b2tlbiBDQU4gYmUgW2Vycm9yXS4gKilcblxuICBhbmQgc2hpZnQgZW52XG4gICAgICAocGxlYXNlX2Rpc2NhcmQgOiBib29sKVxuICAgICAgKHRlcm1pbmFsIDogdGVybWluYWwpXG4gICAgICAodmFsdWUgOiBzZW1hbnRpY192YWx1ZSlcbiAgICAgIChzJyA6IHN0YXRlKSA9XG5cbiAgICAoKiBMb2cgdGhlIHRyYW5zaXRpb24uICopXG5cbiAgICBpZiBsb2cgdGhlblxuICAgICAgTG9nLnNoaWZ0IHRlcm1pbmFsIHMnO1xuXG4gICAgKCogUHVzaCBhIG5ldyBjZWxsIG9udG8gdGhlIHN0YWNrLCBjb250YWluaW5nIHRoZSBpZGVudGl0eSBvZiB0aGVcbiAgICAgICBzdGF0ZSB0aGF0IHdlIGFyZSBsZWF2aW5nLiAqKVxuXG4gICAgbGV0IChfLCBzdGFydHAsIGVuZHApID0gZW52LnRyaXBsZSBpblxuICAgIGxldCBzdGFjayA9IHtcbiAgICAgIHN0YXRlID0gZW52LmN1cnJlbnQ7XG4gICAgICBzZW12ID0gdmFsdWU7XG4gICAgICBzdGFydHA7XG4gICAgICBlbmRwO1xuICAgICAgbmV4dCA9IGVudi5zdGFjaztcbiAgICB9IGluXG5cbiAgICAoKiBTd2l0Y2ggdG8gc3RhdGUgW3MnXS4gKilcblxuICAgIGxldCBuZXdfZW52ID0geyBlbnYgd2l0aCBzdGFjazsgY3VycmVudCA9IHMnIH0gaW5cblxuICAgICgqIEV4cG9zZSB0aGUgdHJhbnNpdGlvbiB0byB0aGUgdXNlci4gKEluIHByaW5jaXBsZSwgd2UgaGF2ZSBhIGNob2ljZVxuICAgICAgIGJldHdlZW4gZXhwb3NpbmcgdGhlIHRyYW5zaXRpb24gYmVmb3JlIHdlIHRha2UgaXQsIGFmdGVyIHdlIHRha2VcbiAgICAgICBpdCwgb3IgYXQgc29tZSBwb2ludCBpbiBiZXR3ZWVuLiBUaGlzIGFmZmVjdHMgdGhlIG51bWJlciBhbmQgdHlwZVxuICAgICAgIG9mIHRoZSBwYXJhbWV0ZXJzIGNhcnJpZWQgYnkgW1NoaWZ0aW5nXS4gSGVyZSwgd2UgY2hvb3NlIHRvIGV4cG9zZVxuICAgICAgIHRoZSB0cmFuc2l0aW9uIGFmdGVyIHdlIHRha2UgaXQ7IHRoaXMgYWxsb3dzIFtTaGlmdGluZ10gdG8gY2FycnlcbiAgICAgICBvbmx5IHRocmVlIHBhcmFtZXRlcnMsIHdob3NlIG1lYW5pbmcgaXMgc2ltcGxlLikgKilcblxuICAgIFNoaWZ0aW5nIChlbnYsIG5ld19lbnYsIHBsZWFzZV9kaXNjYXJkKVxuXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4gICgqIFRoZSBmdW5jdGlvbiBbYW5ub3VuY2VfcmVkdWNlXSBzdG9wcyB0aGUgcGFyc2VyIGFuZCByZXR1cm5zIGEgY2hlY2twb2ludFxuICAgICB3aGljaCBhbGxvd3MgdGhlIHBhcnNlciB0byBiZSByZXN1bWVkIGJ5IGNhbGxpbmcgW3JlZHVjZV0uICopXG5cbiAgKCogT25seSBvcmRpbmFyeSBwcm9kdWN0aW9ucyBhcmUgZXhwb3NlZCB0byB0aGUgdXNlci4gU3RhcnQgcHJvZHVjdGlvbnNcbiAgICAgYXJlIG5vdCBleHBvc2VkIHRvIHRoZSB1c2VyLiBSZWR1Y2luZyBhIHN0YXJ0IHByb2R1Y3Rpb24gc2ltcGx5IGxlYWRzXG4gICAgIHRvIHRoZSBzdWNjZXNzZnVsIHRlcm1pbmF0aW9uIG9mIHRoZSBwYXJzZXIuICopXG5cbiAgYW5kIGFubm91bmNlX3JlZHVjZSBlbnYgKHByb2QgOiBwcm9kdWN0aW9uKSA9XG4gICAgaWYgVC5pc19zdGFydCBwcm9kIHRoZW5cbiAgICAgIGFjY2VwdCBlbnYgcHJvZFxuICAgIGVsc2VcbiAgICAgIEFib3V0VG9SZWR1Y2UgKGVudiwgcHJvZClcblxuICAoKiBUaGUgZnVuY3Rpb24gW3JlZHVjZV0gdGFrZXMgY2FyZSBvZiByZWR1Y3Rpb25zLiBJdCBpcyBpbnZva2VkIGJ5XG4gICAgIFtyZXN1bWVdIGFmdGVyIGFuIFtBYm91dFRvUmVkdWNlXSBldmVudCBoYXMgYmVlbiBwcm9kdWNlZC4gKilcblxuICAoKiBIZXJlLCB0aGUgbG9va2FoZWFkIHRva2VuIENBTiBiZSBbZXJyb3JdLiAqKVxuXG4gICgqIFRoZSBwcm9kdWN0aW9uIFtwcm9kXSBDQU5OT1QgYmUgYSBzdGFydCBwcm9kdWN0aW9uLiAqKVxuXG4gIGFuZCByZWR1Y2UgZW52IChwcm9kIDogcHJvZHVjdGlvbikgPVxuXG4gICAgKCogTG9nIGEgcmVkdWN0aW9uIGV2ZW50LiAqKVxuXG4gICAgaWYgbG9nIHRoZW5cbiAgICAgIExvZy5yZWR1Y2Vfb3JfYWNjZXB0IHByb2Q7XG5cbiAgICAoKiBJbnZva2UgdGhlIHNlbWFudGljIGFjdGlvbi4gVGhlIHNlbWFudGljIGFjdGlvbiBpcyByZXNwb25zaWJsZSBmb3JcbiAgICAgICB0cnVuY2F0aW5nIHRoZSBzdGFjayBhbmQgcHVzaGluZyBhIG5ldyBjZWxsIG9udG8gdGhlIHN0YWNrLCB3aGljaFxuICAgICAgIGNvbnRhaW5zIGEgbmV3IHNlbWFudGljIHZhbHVlLiBUaGUgc2VtYW50aWMgYWN0aW9uIHJldHVybnMgYSBuZXcgc3RhY2ssXG4gICAgICAgd2hpY2ggYmVjb21lcyB0aGUgY3VycmVudCBzdGFjay4gKilcblxuICAgIGxldCBzdGFjayA9IFQuc2VtYW50aWNfYWN0aW9uIHByb2QgZW52IGluXG5cbiAgICAoKiBCeSBvdXIgY29udmVudGlvbiwgdGhlIHNlbWFudGljIGFjdGlvbiBoYXMgcHJvZHVjZWQgYW4gdXBkYXRlZFxuICAgICAgIHN0YWNrLiBUaGUgc3RhdGUgbm93IGZvdW5kIGluIHRoZSB0b3Agc3RhY2sgY2VsbCBpcyB0aGUgcmV0dXJuXG4gICAgICAgc3RhdGUuICopXG5cbiAgICAoKiBQZXJmb3JtIGEgZ290byB0cmFuc2l0aW9uLiBUaGUgdGFyZ2V0IHN0YXRlIGlzIGRldGVybWluZWRcbiAgICAgICBieSBjb25zdWx0aW5nIHRoZSBnb3RvIHRhYmxlIGF0IHRoZSByZXR1cm4gc3RhdGUgYW5kIGF0XG4gICAgICAgcHJvZHVjdGlvbiBbcHJvZF0uICopXG5cbiAgICBsZXQgY3VycmVudCA9IFQuZ290b19wcm9kIHN0YWNrLnN0YXRlIHByb2QgaW5cbiAgICBsZXQgZW52ID0geyBlbnYgd2l0aCBzdGFjazsgY3VycmVudCB9IGluXG4gICAgcnVuIGVudiBmYWxzZVxuXG4gIGFuZCBhY2NlcHQgZW52IHByb2QgPVxuICAgICgqIExvZyBhbiBhY2NlcHQgZXZlbnQuICopXG4gICAgaWYgbG9nIHRoZW5cbiAgICAgIExvZy5yZWR1Y2Vfb3JfYWNjZXB0IHByb2Q7XG4gICAgKCogRXh0cmFjdCB0aGUgc2VtYW50aWMgdmFsdWUgb3V0IG9mIHRoZSBzdGFjay4gKilcbiAgICBsZXQgdiA9IGVudi5zdGFjay5zZW12IGluXG4gICAgKCogRmluaXNoLiAqKVxuICAgIEFjY2VwdGVkIHZcblxuICAoKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuICAoKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBkZWFsIHdpdGggZXJyb3JzLiAqKVxuXG4gICgqIFtpbml0aWF0ZV0gaW5pdGlhdGVzIG9yIHJlc3VtZXMgZXJyb3IgaGFuZGxpbmcuICopXG5cbiAgKCogSGVyZSwgdGhlIGxvb2thaGVhZCB0b2tlbiBDQU4gYmUgW2Vycm9yXS4gKilcblxuICBhbmQgaW5pdGlhdGUgZW52ID1cbiAgICBpZiBsb2cgdGhlblxuICAgICAgTG9nLmluaXRpYXRpbmdfZXJyb3JfaGFuZGxpbmcoKTtcbiAgICBsZXQgZW52ID0geyBlbnYgd2l0aCBlcnJvciA9IHRydWUgfSBpblxuICAgIEhhbmRsaW5nRXJyb3IgZW52XG5cbiAgKCogW2Vycm9yXSBoYW5kbGVzIGVycm9ycy4gKilcblxuICBhbmQgZXJyb3IgfnN0cmF0ZWd5IGVudiA9XG4gICAgYXNzZXJ0IGVudi5lcnJvcjtcblxuICAgICgqIENvbnN1bHQgdGhlIGNvbHVtbiBhc3NvY2lhdGVkIHdpdGggdGhlIFtlcnJvcl0gcHNldWRvLXRva2VuIGluIHRoZVxuICAgICAgIGFjdGlvbiB0YWJsZS4gKilcblxuICAgIFQuYWN0aW9uXG4gICAgICBlbnYuY3VycmVudCAgICAgICAgICAgICAgICAgICAgKCogZGV0ZXJtaW5lcyBhIHJvdyAqKVxuICAgICAgVC5lcnJvcl90ZXJtaW5hbCAgICAgICAgICAgICAgICgqIGRldGVybWluZXMgYSBjb2x1bW4gKilcbiAgICAgIFQuZXJyb3JfdmFsdWVcbiAgICAgIChlcnJvcl9zaGlmdCB+c3RyYXRlZ3kpICAgICAgICAoKiBzaGlmdCBjb250aW51YXRpb24gKilcbiAgICAgIChlcnJvcl9yZWR1Y2UgfnN0cmF0ZWd5KSAgICAgICAoKiByZWR1Y2UgY29udGludWF0aW9uICopXG4gICAgICAoZXJyb3JfZmFpbCB+c3RyYXRlZ3kpICAgICAgICAgKCogZmFpbHVyZSBjb250aW51YXRpb24gKilcbiAgICAgIGVudlxuXG4gIGFuZCBlcnJvcl9zaGlmdCB+c3RyYXRlZ3kgZW52IHBsZWFzZV9kaXNjYXJkIHRlcm1pbmFsIHZhbHVlIHMnID1cbiAgICBhc3NlcnQgKHRlcm1pbmFsID0gVC5lcnJvcl90ZXJtaW5hbCAmJiB2YWx1ZSA9IFQuZXJyb3JfdmFsdWUpO1xuXG4gICAgKCogVGhpcyBzdGF0ZSBpcyBjYXBhYmxlIG9mIHNoaWZ0aW5nIHRoZSBbZXJyb3JdIHRva2VuLiAqKVxuXG4gICAgaWYgbG9nIHRoZW5cbiAgICAgIExvZy5oYW5kbGluZ19lcnJvciBlbnYuY3VycmVudDtcblxuICAgICgqIEluIHRoZSBzaW1wbGlmaWVkIHN0cmF0ZWd5LCB3ZSBjaGFuZ2UgW3BsZWFzZV9kaXNjYXJkXSB0byBbZmFsc2VdLFxuICAgICAgIHdoaWNoIG1lYW5zIHRoYXQgd2Ugd29uJ3QgcmVxdWVzdCB0aGUgbmV4dCB0b2tlbiBhbmQgKHRoZXJlZm9yZSlcbiAgICAgICB3ZSB3aWxsIHJlbWFpbiBpbiBlcnJvci1oYW5kbGluZyBtb2RlIGFmdGVyIHNoaWZ0aW5nIHRoZSBbZXJyb3JdXG4gICAgICAgdG9rZW4uICopXG5cbiAgICBsZXQgcGxlYXNlX2Rpc2NhcmQgPVxuICAgICAgbWF0Y2ggc3RyYXRlZ3kgd2l0aCBgTGVnYWN5IC0+IHBsZWFzZV9kaXNjYXJkIHwgYFNpbXBsaWZpZWQgLT4gZmFsc2VcbiAgICBpblxuXG4gICAgc2hpZnQgZW52IHBsZWFzZV9kaXNjYXJkIHRlcm1pbmFsIHZhbHVlIHMnXG5cbiAgYW5kIGVycm9yX3JlZHVjZSB+c3RyYXRlZ3kgZW52IHByb2QgPVxuXG4gICAgKCogVGhpcyBzdGF0ZSBpcyBjYXBhYmxlIG9mIHBlcmZvcm1pbmcgYSByZWR1Y3Rpb24gb24gW2Vycm9yXS4gKilcblxuICAgIGlmIGxvZyB0aGVuXG4gICAgICBMb2cuaGFuZGxpbmdfZXJyb3IgZW52LmN1cnJlbnQ7XG5cbiAgICAoKiBJbiB0aGUgbGVnYWN5IHN0cmF0ZWd5LCB3ZSBjYWxsIFtyZWR1Y2VdIGluc3RlYWQgb2YgW2Fubm91bmNlX3JlZHVjZV0sXG4gICAgICAgYXBwYXJlbnRseSBpbiBhbiBhdHRlbXB0IHRvIGhpZGUgdGhlIHJlZHVjdGlvbiBzdGVwcyBwZXJmb3JtZWQgZHVyaW5nXG4gICAgICAgZXJyb3IgaGFuZGxpbmcuIEluIHRoZSBzaW1wbGlmaWVkIHN0cmF0ZWd5LCBhbGwgcmVkdWN0aW9ucyBzdGVwcyBhcmVcbiAgICAgICBhbm5vdW5jZWQuICopXG5cbiAgICBtYXRjaCBzdHJhdGVneSB3aXRoXG4gICAgfCBgTGVnYWN5IC0+XG4gICAgICAgIHJlZHVjZSBlbnYgcHJvZFxuICAgIHwgYFNpbXBsaWZpZWQgLT5cbiAgICAgICAgYW5ub3VuY2VfcmVkdWNlIGVudiBwcm9kXG5cbiAgYW5kIGVycm9yX2ZhaWwgfnN0cmF0ZWd5IGVudiA9XG5cbiAgICAoKiBUaGlzIHN0YXRlIGlzIHVuYWJsZSB0byBoYW5kbGUgZXJyb3JzLiBJbiB0aGUgc2ltcGxpZmllZCBzdHJhdGVneSwgd2VcbiAgICAgICBkaWUgaW1tZWRpYXRlbHkuIEluIHRoZSBsZWdhY3kgc3RyYXRlZ3ksIHdlIGF0dGVtcHQgdG8gcG9wIGEgc3RhY2tcbiAgICAgICBjZWxsLiAoVGhpcyBhbW91bnRzIHRvIGZvcmdldHRpbmcgcGFydCBvZiB3aGF0IHdlIGhhdmUganVzdCByZWFkLCBpblxuICAgICAgIHRoZSBob3BlIG9mIHJlYWNoaW5nIGEgc3RhdGUgd2hlcmUgd2UgY2FuIHNoaWZ0IHRoZSBbZXJyb3JdIHRva2VuIGFuZFxuICAgICAgIHJlc3VtZSBwYXJzaW5nIGluIG5vcm1hbCBtb2RlLiBGb3JnZXR0aW5nIHBhc3QgaW5wdXQgaXMgbm90IGFwcHJvcHJpYXRlXG4gICAgICAgd2hlbiB0aGUgZ29hbCBpcyBtZXJlbHkgdG8gcHJvZHVjZSBhIGdvb2Qgc3ludGF4IGVycm9yIG1lc3NhZ2UuKSAqKVxuXG4gICAgbWF0Y2ggc3RyYXRlZ3kgd2l0aFxuICAgIHwgYFNpbXBsaWZpZWQgLT5cbiAgICAgICAgUmVqZWN0ZWRcbiAgICB8IGBMZWdhY3kgLT5cblxuICAgICgqIEF0dGVtcHQgdG8gcG9wIGEgc3RhY2sgY2VsbC4gKilcblxuICAgIGxldCBjZWxsID0gZW52LnN0YWNrIGluXG4gICAgbGV0IG5leHQgPSBjZWxsLm5leHQgaW5cbiAgICBpZiBuZXh0ID09IGNlbGwgdGhlblxuXG4gICAgICAoKiBUaGUgc3RhY2sgaXMgZW1wdHkuIERpZS4gKilcblxuICAgICAgUmVqZWN0ZWRcblxuICAgIGVsc2UgYmVnaW5cblxuICAgICAgKCogVGhlIHN0YWNrIGlzIG5vbmVtcHR5LiBQb3AgYSBjZWxsLCB1cGRhdGluZyB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAgICAgdG8gdGhlIHN0YXRlIFtjZWxsLnN0YXRlXSBmb3VuZCBpbiB0aGUgcG9wcGVkIGNlbGwsIGFuZCBjb250aW51ZVxuICAgICAgICAgZXJyb3IgaGFuZGxpbmcgdGhlcmUuICopXG5cbiAgICAgICgqIEkgbm90ZSB0aGF0IGlmIHRoZSBuZXcgc3RhdGUgW2NlbGwuc3RhdGVdIGhhcyBhIGRlZmF1bHQgcmVkdWN0aW9uLFxuICAgICAgICAgdGhlbiBpdCBpcyBpZ25vcmVkLiBJdCBpcyB1bmNsZWFyIHdoZXRoZXIgdGhpcyBpcyBpbnRlbnRpb25hbC4gSXRcbiAgICAgICAgIGNvdWxkIGJlIGEgZ29vZCB0aGluZywgYXMgaXQgYXZvaWRzIGEgc2NlbmFyaW8gd2hlcmUgdGhlIHBhcnNlclxuICAgICAgICAgZGl2ZXJnZXMgYnkgcmVwZWF0ZWRseSBwb3BwaW5nLCBwZXJmb3JtaW5nIGEgZGVmYXVsdCByZWR1Y3Rpb24gb2ZcbiAgICAgICAgIGFuIGVwc2lsb24gcHJvZHVjdGlvbiwgcG9wcGluZywgZXRjLiBTdGlsbCwgdGhlIHF1ZXN0aW9uIG9mIHdoZXRoZXJcbiAgICAgICAgIHRvIG9iZXkgZGVmYXVsdCByZWR1Y3Rpb25zIHdoaWxlIGVycm9yIGhhbmRsaW5nIHNlZW1zIG9ic2N1cmUuICopXG5cbiAgICAgIGxldCBlbnYgPSB7IGVudiB3aXRoXG4gICAgICAgIHN0YWNrID0gbmV4dDtcbiAgICAgICAgY3VycmVudCA9IGNlbGwuc3RhdGVcbiAgICAgIH0gaW5cbiAgICAgIEhhbmRsaW5nRXJyb3IgZW52XG5cbiAgICBlbmRcblxuICAoKiBFbmQgb2YgdGhlIG5lc3Qgb2YgdGFpbCByZWN1cnNpdmUgZnVuY3Rpb25zLiAqKVxuXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuICAoKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuICAoKiBUaGUgaW5jcmVtZW50YWwgaW50ZXJmYWNlLiBTZWUgW0VuZ2luZVR5cGVzXS4gKilcblxuICAoKiBbc3RhcnQgc10gYmVnaW5zIHRoZSBwYXJzaW5nIHByb2Nlc3MuICopXG5cbiAgbGV0IHN0YXJ0IChzIDogc3RhdGUpIChpbml0aWFsIDogcG9zaXRpb24pIDogc2VtYW50aWNfdmFsdWUgY2hlY2twb2ludCA9XG5cbiAgICAoKiBCdWlsZCBhbiBlbXB0eSBzdGFjay4gVGhpcyBpcyBhIGR1bW15IGNlbGwsIHdoaWNoIGlzIGl0cyBvd24gc3VjY2Vzc29yLlxuICAgICAgIEl0cyBbbmV4dF0gZmllbGQgV0lMTCBiZSBhY2Nlc3NlZCBieSBbZXJyb3JfZmFpbF0gaWYgYW4gZXJyb3Igb2NjdXJzIGFuZFxuICAgICAgIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgdW50aWwgdGhlIHN0YWNrIGlzIGVtcHR5LiBJdHMgW2VuZHBdIGZpZWxkIFdJTExcbiAgICAgICBiZSBhY2Nlc3NlZCAoYnkgYSBzZW1hbnRpYyBhY3Rpb24pIGlmIGFuIGVwc2lsb24gcHJvZHVjdGlvbiBpcyByZWR1Y2VkXG4gICAgICAgd2hlbiB0aGUgc3RhY2sgaXMgZW1wdHkuICopXG5cbiAgICBsZXQgcmVjIGVtcHR5ID0ge1xuICAgICAgc3RhdGUgPSBzOyAgICAgICAgICAgICAgICAgICAgICAgICAgKCogZHVtbXkgKilcbiAgICAgIHNlbXYgPSBULmVycm9yX3ZhbHVlOyAgICAgICAgICAgICAgICgqIGR1bW15ICopXG4gICAgICBzdGFydHAgPSBpbml0aWFsOyAgICAgICAgICAgICAgICAgICAoKiBkdW1teSAqKVxuICAgICAgZW5kcCA9IGluaXRpYWw7XG4gICAgICBuZXh0ID0gZW1wdHk7XG4gICAgfSBpblxuXG4gICAgKCogQnVpbGQgYW4gaW5pdGlhbCBlbnZpcm9ubWVudC4gKilcblxuICAgICgqIFVuZm9ydHVuYXRlbHksIHRoZXJlIGlzIG5vIHR5cGUtc2FmZSB3YXkgb2YgY29uc3RydWN0aW5nIGFcbiAgICAgICBkdW1teSB0b2tlbi4gVG9rZW5zIGNhcnJ5IHNlbWFudGljIHZhbHVlcywgd2hpY2ggaW4gZ2VuZXJhbFxuICAgICAgIHdlIGNhbm5vdCBtYW51ZmFjdHVyZS4gVGhpcyBpbnN0YW5jZSBvZiBbT2JqLm1hZ2ljXSBjb3VsZFxuICAgICAgIGJlIGF2b2lkZWQgYnkgYWRvcHRpbmcgYSBkaWZmZXJlbnQgcmVwcmVzZW50YXRpb24gKGUuZy4sIG5vXG4gICAgICAgW2Vudi5lcnJvcl0gZmllbGQsIGFuZCBhbiBvcHRpb24gaW4gdGhlIGZpcnN0IGNvbXBvbmVudCBvZlxuICAgICAgIFtlbnYudHJpcGxlXSksIGJ1dCBJIGxpa2UgdGhpcyByZXByZXNlbnRhdGlvbiBiZXR0ZXIuICopXG5cbiAgICBsZXQgZHVtbXlfdG9rZW4gPSBPYmoubWFnaWMgKCkgaW5cbiAgICBsZXQgZW52ID0ge1xuICAgICAgZXJyb3IgPSBmYWxzZTtcbiAgICAgIHRyaXBsZSA9IChkdW1teV90b2tlbiwgaW5pdGlhbCwgaW5pdGlhbCk7ICgqIGR1bW15ICopXG4gICAgICBzdGFjayA9IGVtcHR5O1xuICAgICAgY3VycmVudCA9IHM7XG4gICAgfSBpblxuXG4gICAgKCogQmVnaW4gcGFyc2luZy4gKilcblxuICAgICgqIFRoZSBwYXJhbWV0ZXIgW3BsZWFzZV9kaXNjYXJkXSBoZXJlIGlzIFt0cnVlXSwgd2hpY2ggbWVhbnMgd2Uga25vd1xuICAgICAgIHRoYXQgd2UgbXVzdCByZWFkIGF0IGxlYXN0IG9uZSB0b2tlbi4gVGhpcyBjbGFpbSByZWxpZXMgb24gdGhlIGZhY3RcbiAgICAgICB0aGF0IHdlIGhhdmUgcnVsZWQgb3V0IHRoZSB0d28gc3BlY2lhbCBjYXNlcyB3aGVyZSBhIHN0YXJ0IHN5bWJvbFxuICAgICAgIHJlY29nbml6ZXMgdGhlIGVtcHR5IGxhbmd1YWdlIG9yIHRoZSBzaW5nbGV0b24gbGFuZ3VhZ2Uge2Vwc2lsb259LiAqKVxuXG4gICAgcnVuIGVudiB0cnVlXG5cbiAgKCogW29mZmVyIGNoZWNrcG9pbnQgdHJpcGxlXSBpcyBpbnZva2VkIGJ5IHRoZSB1c2VyIGluIHJlc3BvbnNlIHRvIGFcbiAgICAgY2hlY2twb2ludCBvZiB0aGUgZm9ybSBbSW5wdXROZWVkZWQgZW52XS4gSXQgY2hlY2tzIHRoYXQgW2NoZWNrcG9pbnRdIGlzXG4gICAgIGluZGVlZCBvZiB0aGlzIGZvcm0sIGFuZCBpbnZva2VzIFtkaXNjYXJkXS4gKilcblxuICAoKiBbcmVzdW1lIGNoZWNrcG9pbnRdIGlzIGludm9rZWQgYnkgdGhlIHVzZXIgaW4gcmVzcG9uc2UgdG8gYSBjaGVja3BvaW50IG9mXG4gICAgIHRoZSBmb3JtIFtBYm91dFRvUmVkdWNlIChlbnYsIHByb2QpXSBvciBbSGFuZGxpbmdFcnJvciBlbnZdLiBJdCBjaGVja3NcbiAgICAgdGhhdCBbY2hlY2twb2ludF0gaXMgaW5kZWVkIG9mIHRoaXMgZm9ybSwgYW5kIGludm9rZXMgW3JlZHVjZV0gb3JcbiAgICAgW2Vycm9yXSwgYXMgYXBwcm9wcmlhdGUuICopXG5cbiAgKCogSW4gcmVhbGl0eSwgW29mZmVyXSBhbmQgW3Jlc3VtZV0gYWNjZXB0IGFuIGFyZ3VtZW50IG9mIHR5cGVcbiAgICAgW3NlbWFudGljX3ZhbHVlIGNoZWNrcG9pbnRdIGFuZCBwcm9kdWNlIGEgY2hlY2twb2ludCBvZiB0aGUgc2FtZSB0eXBlLlxuICAgICBUaGUgY2hvaWNlIG9mIFtzZW1hbnRpY192YWx1ZV0gaXMgZm9yY2VkIGJ5IHRoZSBmYWN0IHRoYXQgdGhpcyBpcyB0aGVcbiAgICAgcGFyYW1ldGVyIG9mIHRoZSBjaGVja3BvaW50IFtBY2NlcHRlZF0uICopXG5cbiAgKCogV2UgY2hhbmdlIHRoaXMgYXMgZm9sbG93cy4gKilcblxuICAoKiBXZSBjaGFuZ2UgdGhlIGFyZ3VtZW50IGFuZCByZXN1bHQgdHlwZSBvZiBbb2ZmZXJdIGFuZCBbcmVzdW1lXSBmcm9tXG4gICAgIFtzZW1hbnRpY192YWx1ZSBjaGVja3BvaW50XSB0byBbJ2EgY2hlY2twb2ludF0uIFRoaXMgaXMgc2FmZSwgaW4gdGhpc1xuICAgICBjYXNlLCBiZWNhdXNlIHdlIGdpdmUgdGhlIHVzZXIgYWNjZXNzIHRvIHZhbHVlcyBvZiB0eXBlIFt0IGNoZWNrcG9pbnRdXG4gICAgIG9ubHkgaWYgW3RdIGlzIGluZGVlZCB0aGUgdHlwZSBvZiB0aGUgZXZlbnR1YWwgc2VtYW50aWMgdmFsdWUgZm9yIHRoaXNcbiAgICAgcnVuLiAoTW9yZSBwcmVjaXNlbHksIGJ5IGV4YW1pbmluZyB0aGUgc2lnbmF0dXJlcyBbSU5DUkVNRU5UQUxfRU5HSU5FXVxuICAgICBhbmQgW0lOQ1JFTUVOVEFMX0VOR0lORV9TVEFSVF0sIG9uZSBmaW5kcyB0aGF0IHRoZSB1c2VyIGNhbiBidWlsZCBhIHZhbHVlXG4gICAgIG9mIHR5cGUgWydhIGNoZWNrcG9pbnRdIG9ubHkgaWYgWydhXSBpcyBbc2VtYW50aWNfdmFsdWVdLiBUaGUgdGFibGVcbiAgICAgYmFjay1lbmQgZ29lcyBmdXJ0aGVyIHRoYW4gdGhpcyBhbmQgcHJvZHVjZXMgdmVyc2lvbnMgb2YgW3N0YXJ0XSBjb21wb3NlZFxuICAgICB3aXRoIGEgc3VpdGFibGUgY2FzdCwgd2hpY2ggZ2l2ZSB0aGUgdXNlciBhY2Nlc3MgdG8gYSB2YWx1ZSBvZiB0eXBlXG4gICAgIFt0IGNoZWNrcG9pbnRdIHdoZXJlIFt0XSBpcyB0aGUgdHlwZSBvZiB0aGUgc3RhcnQgc3ltYm9sLikgKilcblxuICBsZXQgb2ZmZXIgOiAnYSAuICdhIGNoZWNrcG9pbnQgLT5cbiAgICAgICAgICAgICAgICAgICB0b2tlbiAqIHBvc2l0aW9uICogcG9zaXRpb24gLT5cbiAgICAgICAgICAgICAgICAgICAnYSBjaGVja3BvaW50XG4gID0gZnVuY3Rpb25cbiAgICB8IElucHV0TmVlZGVkIGVudiAtPlxuICAgICAgICBPYmoubWFnaWMgZGlzY2FyZCBlbnZcbiAgICB8IF8gLT5cbiAgICAgICAgaW52YWxpZF9hcmcgXCJvZmZlciBleHBlY3RzIElucHV0TmVlZGVkXCJcblxuICBsZXQgcmVzdW1lIDogJ2EgLiA/c3RyYXRlZ3k6c3RyYXRlZ3kgLT4gJ2EgY2hlY2twb2ludCAtPiAnYSBjaGVja3BvaW50ID1cbiAgZnVuID8oc3RyYXRlZ3k9YExlZ2FjeSkgY2hlY2twb2ludCAtPlxuICAgIG1hdGNoIGNoZWNrcG9pbnQgd2l0aFxuICAgIHwgSGFuZGxpbmdFcnJvciBlbnYgLT5cbiAgICAgICAgT2JqLm1hZ2ljIGVycm9yIH5zdHJhdGVneSBlbnZcbiAgICB8IFNoaWZ0aW5nIChfLCBlbnYsIHBsZWFzZV9kaXNjYXJkKSAtPlxuICAgICAgICBPYmoubWFnaWMgcnVuIGVudiBwbGVhc2VfZGlzY2FyZFxuICAgIHwgQWJvdXRUb1JlZHVjZSAoZW52LCBwcm9kKSAtPlxuICAgICAgICBPYmoubWFnaWMgcmVkdWNlIGVudiBwcm9kXG4gICAgfCBfIC0+XG4gICAgICAgIGludmFsaWRfYXJnIFwicmVzdW1lIGV4cGVjdHMgSGFuZGxpbmdFcnJvciB8IFNoaWZ0aW5nIHwgQWJvdXRUb1JlZHVjZVwiXG5cbiAgKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4gICgqIFRoZSB0cmFkaXRpb25hbCBpbnRlcmZhY2UuIFNlZSBbRW5naW5lVHlwZXNdLiAqKVxuXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4gICgqIFdyYXBwaW5nIGEgbGV4ZXIgYW5kIGxleGJ1ZiBhcyBhIHRva2VuIHN1cHBsaWVyLiAqKVxuXG4gIHR5cGUgc3VwcGxpZXIgPVxuICAgIHVuaXQgLT4gdG9rZW4gKiBwb3NpdGlvbiAqIHBvc2l0aW9uXG5cbiAgbGV0IGxleGVyX2xleGJ1Zl90b19zdXBwbGllclxuICAgICAgKGxleGVyIDogTGV4aW5nLmxleGJ1ZiAtPiB0b2tlbilcbiAgICAgIChsZXhidWYgOiBMZXhpbmcubGV4YnVmKVxuICA6IHN1cHBsaWVyID1cbiAgICBmdW4gKCkgLT5cbiAgICAgIGxldCB0b2tlbiA9IGxleGVyIGxleGJ1ZiBpblxuICAgICAgbGV0IHN0YXJ0cCA9IGxleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgIGFuZCBlbmRwID0gbGV4YnVmLkxleGluZy5sZXhfY3Vycl9wIGluXG4gICAgICB0b2tlbiwgc3RhcnRwLCBlbmRwXG5cbiAgKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbiAgKCogVGhlIG1haW4gbG9vcCByZXBlYXRlZGx5IGhhbmRsZXMgaW50ZXJtZWRpYXRlIGNoZWNrcG9pbnRzLCB1bnRpbCBhIGZpbmFsXG4gICAgIGNoZWNrcG9pbnQgaXMgb2J0YWluZWQuIFRoaXMgYWxsb3dzIGltcGxlbWVudGluZyB0aGUgbW9ub2xpdGhpYyBpbnRlcmZhY2VcbiAgICAgKFtlbnRyeV0pIGluIHRlcm1zIG9mIHRoZSBpbmNyZW1lbnRhbCBpbnRlcmZhY2UgKFtzdGFydF0sIFtvZmZlcl0sXG4gICAgIFtoYW5kbGVdLCBbcmVkdWNlXSkuICopXG5cbiAgKCogQnkgY29udmVudGlvbiwgYWNjZXB0YW5jZSBpcyByZXBvcnRlZCBieSByZXR1cm5pbmcgYSBzZW1hbnRpYyB2YWx1ZSxcbiAgICAgd2hlcmVhcyByZWplY3Rpb24gaXMgcmVwb3J0ZWQgYnkgcmFpc2luZyBbRXJyb3JdLiAqKVxuXG4gICgqIFtsb29wXSBpcyBwb2x5bW9ycGhpYyBpbiBbJ2FdLiBObyBjaGVhdGluZyBpcyBpbnZvbHZlZCBpbiBhY2hpZXZpbmcgdGhpcy5cbiAgICAgQWxsIG9mIHRoZSBjaGVhdGluZyByZXNpZGVzIGluIHRoZSB0eXBlcyBhc3NpZ25lZCB0byBbb2ZmZXJdIGFuZCBbaGFuZGxlXVxuICAgICBhYm92ZS4gKilcblxuICBsZXQgcmVjIGxvb3AgOiAnYSAuID9zdHJhdGVneTpzdHJhdGVneSAtPiBzdXBwbGllciAtPiAnYSBjaGVja3BvaW50IC0+ICdhID1cbiAgICBmdW4gPyhzdHJhdGVneT1gTGVnYWN5KSByZWFkIGNoZWNrcG9pbnQgLT5cbiAgICBtYXRjaCBjaGVja3BvaW50IHdpdGhcbiAgICB8IElucHV0TmVlZGVkIF8gLT5cbiAgICAgICAgKCogVGhlIHBhcnNlciBuZWVkcyBhIHRva2VuLiBSZXF1ZXN0IG9uZSBmcm9tIHRoZSBsZXhlcixcbiAgICAgICAgICAgYW5kIG9mZmVyIGl0IHRvIHRoZSBwYXJzZXIsIHdoaWNoIHdpbGwgcHJvZHVjZSBhIG5ld1xuICAgICAgICAgICBjaGVja3BvaW50LiBUaGVuLCByZXBlYXQuICopXG4gICAgICAgIGxldCB0cmlwbGUgPSByZWFkKCkgaW5cbiAgICAgICAgbGV0IGNoZWNrcG9pbnQgPSBvZmZlciBjaGVja3BvaW50IHRyaXBsZSBpblxuICAgICAgICBsb29wIH5zdHJhdGVneSByZWFkIGNoZWNrcG9pbnRcbiAgICB8IFNoaWZ0aW5nIF9cbiAgICB8IEFib3V0VG9SZWR1Y2UgX1xuICAgIHwgSGFuZGxpbmdFcnJvciBfIC0+XG4gICAgICAgICgqIFRoZSBwYXJzZXIgaGFzIHN1c3BlbmRlZCBpdHNlbGYsIGJ1dCBkb2VzIG5vdCBuZWVkXG4gICAgICAgICAgIG5ldyBpbnB1dC4gSnVzdCByZXN1bWUgdGhlIHBhcnNlci4gVGhlbiwgcmVwZWF0LiAqKVxuICAgICAgICBsZXQgY2hlY2twb2ludCA9IHJlc3VtZSB+c3RyYXRlZ3kgY2hlY2twb2ludCBpblxuICAgICAgICBsb29wIH5zdHJhdGVneSByZWFkIGNoZWNrcG9pbnRcbiAgICB8IEFjY2VwdGVkIHYgLT5cbiAgICAgICAgKCogVGhlIHBhcnNlciBoYXMgc3VjY2VlZGVkIGFuZCBwcm9kdWNlZCBhIHNlbWFudGljIHZhbHVlLlxuICAgICAgICAgICBSZXR1cm4gdGhpcyBzZW1hbnRpYyB2YWx1ZSB0byB0aGUgdXNlci4gKilcbiAgICAgICAgdlxuICAgIHwgUmVqZWN0ZWQgLT5cbiAgICAgICAgKCogVGhlIHBhcnNlciByZWplY3RzIHRoaXMgaW5wdXQuIFJhaXNlIGFuIGV4Y2VwdGlvbi4gKilcbiAgICAgICAgcmFpc2UgRXJyb3JcblxuICBsZXQgZW50cnkgc3RyYXRlZ3kgKHMgOiBzdGF0ZSkgbGV4ZXIgbGV4YnVmIDogc2VtYW50aWNfdmFsdWUgPVxuICAgIGxldCBpbml0aWFsID0gbGV4YnVmLkxleGluZy5sZXhfY3Vycl9wIGluXG4gICAgbG9vcCB+c3RyYXRlZ3kgKGxleGVyX2xleGJ1Zl90b19zdXBwbGllciBsZXhlciBsZXhidWYpIChzdGFydCBzIGluaXRpYWwpXG5cbiAgKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbiAgKCogW2xvb3BfaGFuZGxlXSBzdG9wcyBpZiBpdCBlbmNvdW50ZXJzIGFuIGVycm9yLCBhbmQgYXQgdGhpcyBwb2ludCwgaW52b2tlc1xuICAgICBpdHMgZmFpbHVyZSBjb250aW51YXRpb24sIHdpdGhvdXQgbGV0dGluZyBNZW5oaXIgZG8gaXRzIG93biB0cmFkaXRpb25hbFxuICAgICBlcnJvci1oYW5kbGluZyAod2hpY2ggaW52b2x2ZXMgcG9wcGluZyB0aGUgc3RhY2ssIGV0Yy4pLiAqKVxuXG4gIGxldCByZWMgbG9vcF9oYW5kbGUgc3VjY2VlZCBmYWlsIHJlYWQgY2hlY2twb2ludCA9XG4gICAgbWF0Y2ggY2hlY2twb2ludCB3aXRoXG4gICAgfCBJbnB1dE5lZWRlZCBfIC0+XG4gICAgICAgIGxldCB0cmlwbGUgPSByZWFkKCkgaW5cbiAgICAgICAgbGV0IGNoZWNrcG9pbnQgPSBvZmZlciBjaGVja3BvaW50IHRyaXBsZSBpblxuICAgICAgICBsb29wX2hhbmRsZSBzdWNjZWVkIGZhaWwgcmVhZCBjaGVja3BvaW50XG4gICAgfCBTaGlmdGluZyBfXG4gICAgfCBBYm91dFRvUmVkdWNlIF8gLT5cbiAgICAgICAgKCogV2hpY2ggc3RyYXRlZ3kgaXMgcGFzc2VkIHRvIFtyZXN1bWVdIGhlcmUgaXMgaXJyZWxldmFudCxcbiAgICAgICAgICAgc2luY2UgdGhpcyBjaGVja3BvaW50IGlzIG5vdCBbSGFuZGxpbmdFcnJvciBfXS4gKilcbiAgICAgICAgbGV0IGNoZWNrcG9pbnQgPSByZXN1bWUgY2hlY2twb2ludCBpblxuICAgICAgICBsb29wX2hhbmRsZSBzdWNjZWVkIGZhaWwgcmVhZCBjaGVja3BvaW50XG4gICAgfCBIYW5kbGluZ0Vycm9yIF9cbiAgICB8IFJlamVjdGVkIC0+XG4gICAgICAgICgqIFRoZSBwYXJzZXIgaGFzIGRldGVjdGVkIGFuIGVycm9yLiBJbnZva2UgdGhlIGZhaWx1cmUgY29udGludWF0aW9uLiAqKVxuICAgICAgICBmYWlsIGNoZWNrcG9pbnRcbiAgICB8IEFjY2VwdGVkIHYgLT5cbiAgICAgICAgKCogVGhlIHBhcnNlciBoYXMgc3VjY2VlZGVkIGFuZCBwcm9kdWNlZCBhIHNlbWFudGljIHZhbHVlLiBJbnZva2UgdGhlXG4gICAgICAgICAgIHN1Y2Nlc3MgY29udGludWF0aW9uLiAqKVxuICAgICAgICBzdWNjZWVkIHZcblxuICAoKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuICAoKiBbbG9vcF9oYW5kbGVfdW5kb10gaXMgYW5hbG9nb3VzIHRvIFtsb29wX2hhbmRsZV0sIGV4Y2VwdCBpdCBwYXNzZXMgYSBwYWlyXG4gICAgIG9mIGNoZWNrcG9pbnRzIHRvIHRoZSBmYWlsdXJlIGNvbnRpbnVhdGlvbi5cblxuICAgICBUaGUgZmlyc3QgKGFuZCBvbGRlc3QpIGNoZWNrcG9pbnQgaXMgdGhlIGxhc3QgW0lucHV0TmVlZGVkXSBjaGVja3BvaW50XG4gICAgIHRoYXQgd2FzIGVuY291bnRlcmVkIGJlZm9yZSB0aGUgZXJyb3Igd2FzIGRldGVjdGVkLiBUaGUgc2Vjb25kIChhbmRcbiAgICAgbmV3ZXN0KSBjaGVja3BvaW50IGlzIHdoZXJlIHRoZSBlcnJvciB3YXMgZGV0ZWN0ZWQsIGFzIGluIFtsb29wX2hhbmRsZV0uXG4gICAgIEdvaW5nIGJhY2sgdG8gdGhlIGZpcnN0IGNoZWNrcG9pbnQgY2FuIGJlIHRob3VnaHQgb2YgYXMgdW5kb2luZyBhbnlcbiAgICAgcmVkdWN0aW9ucyB0aGF0IHdlcmUgcGVyZm9ybWVkIGFmdGVyIHNlZWluZyB0aGUgcHJvYmxlbWF0aWMgdG9rZW4uIChUaGVzZVxuICAgICByZWR1Y3Rpb25zIG11c3QgYmUgZGVmYXVsdCByZWR1Y3Rpb25zIG9yIHNwdXJpb3VzIHJlZHVjdGlvbnMuKSAqKVxuXG4gIGxldCByZWMgbG9vcF9oYW5kbGVfdW5kbyBzdWNjZWVkIGZhaWwgcmVhZCAoaW5wdXRuZWVkZWQsIGNoZWNrcG9pbnQpID1cbiAgICBtYXRjaCBjaGVja3BvaW50IHdpdGhcbiAgICB8IElucHV0TmVlZGVkIF8gLT5cbiAgICAgICAgKCogVXBkYXRlIHRoZSBsYXN0IHJlY29yZGVkIFtJbnB1dE5lZWRlZF0gY2hlY2twb2ludC4gKilcbiAgICAgICAgbGV0IGlucHV0bmVlZGVkID0gY2hlY2twb2ludCBpblxuICAgICAgICBsZXQgdHJpcGxlID0gcmVhZCgpIGluXG4gICAgICAgIGxldCBjaGVja3BvaW50ID0gb2ZmZXIgY2hlY2twb2ludCB0cmlwbGUgaW5cbiAgICAgICAgbG9vcF9oYW5kbGVfdW5kbyBzdWNjZWVkIGZhaWwgcmVhZCAoaW5wdXRuZWVkZWQsIGNoZWNrcG9pbnQpXG4gICAgfCBTaGlmdGluZyBfXG4gICAgfCBBYm91dFRvUmVkdWNlIF8gLT5cbiAgICAgICAgKCogV2hpY2ggc3RyYXRlZ3kgaXMgcGFzc2VkIHRvIFtyZXN1bWVdIGhlcmUgaXMgaXJyZWxldmFudCxcbiAgICAgICAgICAgc2luY2UgdGhpcyBjaGVja3BvaW50IGlzIG5vdCBbSGFuZGxpbmdFcnJvciBfXS4gKilcbiAgICAgICAgbGV0IGNoZWNrcG9pbnQgPSByZXN1bWUgY2hlY2twb2ludCBpblxuICAgICAgICBsb29wX2hhbmRsZV91bmRvIHN1Y2NlZWQgZmFpbCByZWFkIChpbnB1dG5lZWRlZCwgY2hlY2twb2ludClcbiAgICB8IEhhbmRsaW5nRXJyb3IgX1xuICAgIHwgUmVqZWN0ZWQgLT5cbiAgICAgICAgZmFpbCBpbnB1dG5lZWRlZCBjaGVja3BvaW50XG4gICAgfCBBY2NlcHRlZCB2IC0+XG4gICAgICAgIHN1Y2NlZWQgdlxuXG4gICgqIEZvciBzaW1wbGljaXR5LCB3ZSBwdWJsaXNoIGEgdmVyc2lvbiBvZiBbbG9vcF9oYW5kbGVfdW5kb10gdGhhdCB0YWtlcyBhXG4gICAgIHNpbmdsZSBjaGVja3BvaW50IGFzIGFuIGFyZ3VtZW50LCBpbnN0ZWFkIG9mIGEgcGFpciBvZiBjaGVja3BvaW50cy4gV2VcbiAgICAgY2hlY2sgdGhhdCB0aGUgYXJndW1lbnQgaXMgW0lucHV0TmVlZGVkIF9dLCBhbmQgZHVwbGljYXRlIGl0LiAqKVxuXG4gICgqIFRoZSBwYXJzZXIgY2Fubm90IGFjY2VwdCBvciByZWplY3QgYmVmb3JlIGl0IGFza3MgZm9yIHRoZSB2ZXJ5IGZpcnN0XG4gICAgIGNoYXJhY3RlciBvZiBpbnB1dC4gKEluZGVlZCwgd2Ugc3RhdGljYWxseSByZWplY3QgYSBzeW1ib2wgdGhhdFxuICAgICBnZW5lcmF0ZXMgdGhlIGVtcHR5IGxhbmd1YWdlIG9yIHRoZSBzaW5nbGV0b24gbGFuZ3VhZ2Uge2Vwc2lsb259LilcbiAgICAgU28sIHRoZSBbc3RhcnRdIGNoZWNrcG9pbnQgbXVzdCBtYXRjaCBbSW5wdXROZWVkZWQgX10uIEhlbmNlLCBpdCBpc1xuICAgICBwZXJtaXR0ZWQgdG8gY2FsbCBbbG9vcF9oYW5kbGVfdW5kb10gd2l0aCBhIFtzdGFydF0gY2hlY2twb2ludC4gKilcblxuICBsZXQgbG9vcF9oYW5kbGVfdW5kbyBzdWNjZWVkIGZhaWwgcmVhZCBjaGVja3BvaW50ID1cbiAgICBhc3NlcnQgKG1hdGNoIGNoZWNrcG9pbnQgd2l0aCBJbnB1dE5lZWRlZCBfIC0+IHRydWUgfCBfIC0+IGZhbHNlKTtcbiAgICBsb29wX2hhbmRsZV91bmRvIHN1Y2NlZWQgZmFpbCByZWFkIChjaGVja3BvaW50LCBjaGVja3BvaW50KVxuXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4gIGxldCByZWMgc2hpZnRzIGNoZWNrcG9pbnQgPVxuICAgIG1hdGNoIGNoZWNrcG9pbnQgd2l0aFxuICAgIHwgU2hpZnRpbmcgKGVudiwgXywgXykgLT5cbiAgICAgICAgKCogVGhlIHBhcnNlciBpcyBhYm91dCB0byBzaGlmdCwgd2hpY2ggbWVhbnMgaXQgaXMgd2lsbGluZyB0b1xuICAgICAgICAgICBjb25zdW1lIHRoZSB0ZXJtaW5hbCBzeW1ib2wgdGhhdCB3ZSBoYXZlIGZlZCBpdC4gUmV0dXJuIHRoZVxuICAgICAgICAgICBzdGF0ZSBqdXN0IGJlZm9yZSB0aGlzIHRyYW5zaXRpb24uICopXG4gICAgICAgIFNvbWUgZW52XG4gICAgfCBBYm91dFRvUmVkdWNlIF8gLT5cbiAgICAgICAgKCogVGhlIHBhcnNlciB3aXNoZXMgdG8gcmVkdWNlLiBKdXN0IGZvbGxvdy4gKilcbiAgICAgICAgKCogV2hpY2ggc3RyYXRlZ3kgaXMgcGFzc2VkIHRvIFtyZXN1bWVdIGhlcmUgaXMgaXJyZWxldmFudCxcbiAgICAgICAgICAgc2luY2UgdGhpcyBjaGVja3BvaW50IGlzIG5vdCBbSGFuZGxpbmdFcnJvciBfXS4gKilcbiAgICAgICAgc2hpZnRzIChyZXN1bWUgY2hlY2twb2ludClcbiAgICB8IEhhbmRsaW5nRXJyb3IgXyAtPlxuICAgICAgICAoKiBUaGUgcGFyc2VyIGZhaWxzLCB3aGljaCBtZWFucyBpdCByZWplY3RzIHRoZSB0ZXJtaW5hbCBzeW1ib2xcbiAgICAgICAgICAgdGhhdCB3ZSBoYXZlIGZlZCBpdC4gKilcbiAgICAgICAgTm9uZVxuICAgIHwgSW5wdXROZWVkZWQgX1xuICAgIHwgQWNjZXB0ZWQgX1xuICAgIHwgUmVqZWN0ZWQgLT5cbiAgICAgICAgKCogTm9uZSBvZiB0aGVzZSBjYXNlcyBjYW4gYXJpc2UuIEluZGVlZCwgYWZ0ZXIgYSB0b2tlbiBpcyBzdWJtaXR0ZWRcbiAgICAgICAgICAgdG8gaXQsIHRoZSBwYXJzZXIgbXVzdCBzaGlmdCwgcmVkdWNlLCBvciBzaWduYWwgYW4gZXJyb3IsIGJlZm9yZVxuICAgICAgICAgICBpdCBjYW4gcmVxdWVzdCBhbm90aGVyIHRva2VuIG9yIHRlcm1pbmF0ZS4gKilcbiAgICAgICAgYXNzZXJ0IGZhbHNlXG5cbiAgbGV0IGFjY2VwdGFibGUgY2hlY2twb2ludCB0b2tlbiBwb3MgPVxuICAgIGxldCB0cmlwbGUgPSAodG9rZW4sIHBvcywgcG9zKSBpblxuICAgIGxldCBjaGVja3BvaW50ID0gb2ZmZXIgY2hlY2twb2ludCB0cmlwbGUgaW5cbiAgICBtYXRjaCBzaGlmdHMgY2hlY2twb2ludCB3aXRoXG4gICAgfCBOb25lICAgICAgLT4gZmFsc2VcbiAgICB8IFNvbWUgX2VudiAtPiB0cnVlXG5cbiAgKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbiAgKCogVGhlIHR5cGUgWydhIGxyMXN0YXRlXSBkZXNjcmliZXMgdGhlIChub24taW5pdGlhbCkgc3RhdGVzIG9mIHRoZSBMUigxKVxuICAgICBhdXRvbWF0b24uIFRoZSBpbmRleCBbJ2FdIHJlcHJlc2VudHMgdGhlIHR5cGUgb2YgdGhlIHNlbWFudGljIHZhbHVlXG4gICAgIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3RhdGUncyBpbmNvbWluZyBzeW1ib2wuICopXG5cbiAgKCogVGhlIHR5cGUgWydhIGxyMXN0YXRlXSBpcyBkZWZpbmVkIGFzIGFuIGFsaWFzIGZvciBbc3RhdGVdLCB3aGljaCBpdHNlbGZcbiAgICAgaXMgdXN1YWxseSBkZWZpbmVkIGFzIFtpbnRdIChzZWUgW1RhYmxlSW50ZXJwcmV0ZXJdKS4gU28sIFsnYSBscjFzdGF0ZV1cbiAgICAgaXMgdGVjaG5pY2FsbHkgYSBwaGFudG9tIHR5cGUsIGJ1dCBzaG91bGQgcmVhbGx5IGJlIHRob3VnaHQgb2YgYXMgYSBHQURUXG4gICAgIHdob3NlIGRhdGEgY29uc3RydWN0b3JzIGhhcHBlbiB0byBiZSByZXByZXNlbnRlZCBhcyBpbnRlZ2Vycy4gSXQgaXNcbiAgICAgcHJlc2VudGVkIHRvIHRoZSB1c2VyIGFzIGFuIGFic3RyYWN0IHR5cGUgKHNlZSBbSW5jcmVtZW50YWxFbmdpbmVdKS4gKilcblxuICB0eXBlICdhIGxyMXN0YXRlID1cbiAgICAgIHN0YXRlXG5cbiAgKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbiAgKCogU3RhY2sgaW5zcGVjdGlvbi4gKilcblxuICAoKiBXZSBvZmZlciBhIHJlYWQtb25seSB2aWV3IG9mIHRoZSBwYXJzZXIncyBzdGF0ZSBhcyBhIHN0cmVhbSBvZiBlbGVtZW50cy5cbiAgICAgRWFjaCBlbGVtZW50IGNvbnRhaW5zIGEgcGFpciBvZiBhIChub24taW5pdGlhbCkgc3RhdGUgYW5kIGEgc2VtYW50aWNcbiAgICAgdmFsdWUgYXNzb2NpYXRlZCB3aXRoICh0aGUgaW5jb21pbmcgc3ltYm9sIG9mKSB0aGlzIHN0YXRlLiBOb3RlIHRoYXQgdGhlXG4gICAgIHR5cGUgW2VsZW1lbnRdIGlzIGFuIGV4aXN0ZW50aWFsIHR5cGUuICopXG5cbiAgKCogQXMgb2YgMjAxNy8wMy8zMSwgdGhlIHR5cGUgW3N0YWNrXSBhbmQgdGhlIGZ1bmN0aW9uIFtzdGFja10gYXJlIERFUFJFQ0FURUQuXG4gICAgIElmIGRlc2lyZWQsIHRoZXkgY291bGQgbm93IGJlIGltcGxlbWVudGVkIG91dHNpZGUgTWVuaGlyLCBieSByZWx5aW5nIG9uXG4gICAgIHRoZSBmdW5jdGlvbnMgW3RvcF0gYW5kIFtwb3BdLiAqKVxuXG4gIHR5cGUgZWxlbWVudCA9XG4gICAgfCBFbGVtZW50OiAnYSBscjFzdGF0ZSAqICdhICogcG9zaXRpb24gKiBwb3NpdGlvbiAtPiBlbGVtZW50XG5cbiAgb3BlbiBHZW5lcmFsXG5cbiAgdHlwZSBzdGFjayA9XG4gICAgZWxlbWVudCBzdHJlYW1cblxuICAoKiBJZiBbY3VycmVudF0gaXMgdGhlIGN1cnJlbnQgc3RhdGUgYW5kIFtjZWxsXSBpcyB0aGUgdG9wIHN0YWNrIGNlbGwsXG4gICAgIHRoZW4gW3N0YWNrIGNlbGwgY3VycmVudF0gaXMgYSB2aWV3IG9mIHRoZSBwYXJzZXIncyBzdGF0ZSBhcyBhIHN0cmVhbVxuICAgICBvZiBlbGVtZW50cy4gKilcblxuICBsZXQgcmVjIHN0YWNrIGNlbGwgY3VycmVudCA6IGVsZW1lbnQgc3RyZWFtID1cbiAgICBsYXp5IChcbiAgICAgICgqIFRoZSBzdGFjayBpcyBlbXB0eSBpZmYgdGhlIHRvcCBzdGFjayBjZWxsIGlzIGl0cyBvd24gc3VjY2Vzc29yLiBJblxuICAgICAgICAgdGhhdCBjYXNlLCB0aGUgY3VycmVudCBzdGF0ZSBbY3VycmVudF0gc2hvdWxkIGJlIGFuIGluaXRpYWwgc3RhdGVcbiAgICAgICAgICh3aGljaCBoYXMgbm8gaW5jb21pbmcgc3ltYm9sKS5cbiAgICAgICAgIFdlIGRvIG5vdCBhbGxvdyB0aGUgdXNlciB0byBpbnNwZWN0IHRoaXMgc3RhdGUuICopXG4gICAgICBsZXQgbmV4dCA9IGNlbGwubmV4dCBpblxuICAgICAgaWYgbmV4dCA9PSBjZWxsIHRoZW5cbiAgICAgICAgTmlsXG4gICAgICBlbHNlXG4gICAgICAgICgqIENvbnN0cnVjdCBhbiBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIGN1cnJlbnQgc3RhdGUgW2N1cnJlbnRdIGFzIHdlbGxcbiAgICAgICAgICAgYXMgdGhlIHNlbWFudGljIHZhbHVlIGNvbnRhaW5lZCBpbiB0aGUgdG9wIHN0YWNrIGNlbGwuIFRoaXMgc2VtYW50aWNcbiAgICAgICAgICAgdmFsdWUgaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBpbmNvbWluZyBzeW1ib2wgb2YgdGhpcyBzdGF0ZSwgc28gaXRcbiAgICAgICAgICAgbWFrZXMgc2Vuc2UgdG8gcGFpciB0aGVtIHRvZ2V0aGVyLiBUaGUgc3RhdGUgaGFzIHR5cGUgWydhIHN0YXRlXSBhbmRcbiAgICAgICAgICAgdGhlIHNlbWFudGljIHZhbHVlIGhhcyB0eXBlIFsnYV0sIGZvciBzb21lIHR5cGUgWydhXS4gSGVyZSwgdGhlIE9DYW1sXG4gICAgICAgICAgIHR5cGUtY2hlY2tlciB0aGlua3MgWydhXSBpcyBbc2VtYW50aWNfdmFsdWVdIGFuZCBjb25zaWRlcnMgdGhpcyBjb2RlXG4gICAgICAgICAgIHdlbGwtdHlwZWQuIE91dHNpZGUsIHdlIHdpbGwgdXNlIG1hZ2ljIHRvIHByb3ZpZGUgdGhlIHVzZXIgd2l0aCBhIHdheVxuICAgICAgICAgICBvZiBpbnNwZWN0aW5nIHN0YXRlcyBhbmQgcmVjb3ZlcmluZyB0aGUgdmFsdWUgb2YgWydhXS4gKilcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBFbGVtZW50IChcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIGNlbGwuc2VtdixcbiAgICAgICAgICBjZWxsLnN0YXJ0cCxcbiAgICAgICAgICBjZWxsLmVuZHBcbiAgICAgICAgKSBpblxuICAgICAgICBDb25zIChlbGVtZW50LCBzdGFjayBuZXh0IGNlbGwuc3RhdGUpXG4gICAgKVxuXG4gIGxldCBzdGFjayBlbnYgOiBlbGVtZW50IHN0cmVhbSA9XG4gICAgc3RhY2sgZW52LnN0YWNrIGVudi5jdXJyZW50XG5cbiAgKCogQXMgZXhwbGFpbmVkIGFib3ZlLCB0aGUgZnVuY3Rpb24gW3RvcF0gYWxsb3dzIGFjY2VzcyB0byB0aGUgdG9wIHN0YWNrXG4gICAgIGVsZW1lbnQgb25seSBpZiB0aGUgc3RhY2sgaXMgbm9uZW1wdHksIGkuZS4sIG9ubHkgaWYgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgaXMgbm90IGFuIGluaXRpYWwgc3RhdGUuICopXG5cbiAgbGV0IHRvcCBlbnYgOiBlbGVtZW50IG9wdGlvbiA9XG4gICAgbGV0IGNlbGwgPSBlbnYuc3RhY2sgaW5cbiAgICBsZXQgbmV4dCA9IGNlbGwubmV4dCBpblxuICAgIGlmIG5leHQgPT0gY2VsbCB0aGVuXG4gICAgICBOb25lXG4gICAgZWxzZVxuICAgICAgU29tZSAoRWxlbWVudCAoZW52LmN1cnJlbnQsIGNlbGwuc2VtdiwgY2VsbC5zdGFydHAsIGNlbGwuZW5kcCkpXG5cbiAgKCogW2VxdWFsXSBjb21wYXJlcyB0aGUgc3RhY2tzIGZvciBwaHlzaWNhbCBlcXVhbGl0eSwgYW5kIGNvbXBhcmVzIHRoZVxuICAgICBjdXJyZW50IHN0YXRlcyB2aWEgdGhlaXIgbnVtYmVycyAodGhpcyBzZWVtcyBjbGVhbmVyIHRoYW4gdXNpbmcgT0NhbWwnc1xuICAgICBwb2x5bW9ycGhpYyBlcXVhbGl0eSkuICopXG5cbiAgKCogVGhlIHR3byBmaWVsZHMgdGhhdCBhcmUgbm90IGNvbXBhcmVkIGJ5IFtlcXVhbF0sIG5hbWVseSBbZXJyb3JdIGFuZFxuICAgICBbdHJpcGxlXSwgYXJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBmdW5jdGlvbiBbZGlzY2FyZF0sIHdoaWNoIGhhbmRsZXNcbiAgICAgW0lucHV0TmVlZGVkXSBjaGVja3BvaW50cy4gVGh1cywgaWYgW2VxdWFsIGVudjEgZW52Ml0gaG9sZHMsIHRoZW4gdGhlXG4gICAgIGNoZWNrcG9pbnRzIFtpbnB1dF9uZWVkZWQgZW52MV0gYW5kIFtpbnB1dF9uZWVkZWQgZW52Ml0gYXJlXG4gICAgIGVxdWl2YWxlbnQ6IHRoZXkgbGVhZCB0aGUgcGFyc2VyIHRvIGJlaGF2ZSBpbiB0aGUgc2FtZSB3YXkuICopXG5cbiAgbGV0IGVxdWFsIGVudjEgZW52MiA9XG4gICAgZW52MS5zdGFjayA9PSBlbnYyLnN0YWNrICYmXG4gICAgbnVtYmVyIGVudjEuY3VycmVudCA9IG51bWJlciBlbnYyLmN1cnJlbnRcblxuICBsZXQgY3VycmVudF9zdGF0ZV9udW1iZXIgZW52ID1cbiAgICBudW1iZXIgZW52LmN1cnJlbnRcblxuICAoKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuICAoKiBBY2Nlc3MgdG8gdGhlIHBvc2l0aW9uIG9mIHRoZSBsb29rYWhlYWQgdG9rZW4uICopXG5cbiAgbGV0IHBvc2l0aW9ucyB7IHRyaXBsZSA9IChfLCBzdGFydHAsIGVuZHApOyBfIH0gPVxuICAgIHN0YXJ0cCwgZW5kcFxuXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4gICgqIEFjY2VzcyB0byBpbmZvcm1hdGlvbiBhYm91dCBkZWZhdWx0IHJlZHVjdGlvbnMuICopXG5cbiAgKCogVGhpcyBjYW4gYmUgYSBmdW5jdGlvbiBvZiBzdGF0ZXMsIG9yIGEgZnVuY3Rpb24gb2YgZW52aXJvbm1lbnRzLlxuICAgICBXZSBvZmZlciBib3RoLiAqKVxuXG4gICgqIEluc3RlYWQgb2YgYSBCb29sZWFuIHJlc3VsdCwgd2UgY291bGQgcmV0dXJuIGEgW3Byb2R1Y3Rpb24gb3B0aW9uXS5cbiAgICAgSG93ZXZlciwgd2Ugd291bGQgaGF2ZSB0byBleHBsaWNpdGx5IHRlc3Qgd2hldGhlciBbcHJvZF0gaXMgYSBzdGFydFxuICAgICBwcm9kdWN0aW9uLCBhbmQgaW4gdGhhdCBjYXNlLCByZXR1cm4gW05vbmVdLCBJIHN1cHBvc2UuIEluZGVlZCwgd2VcbiAgICAgaGF2ZSBkZWNpZGVkIG5vdCB0byBleHBvc2UgdGhlIHN0YXJ0IHByb2R1Y3Rpb25zLiAqKVxuXG4gIGxldCBzdGF0ZV9oYXNfZGVmYXVsdF9yZWR1Y3Rpb24gKHN0YXRlIDogXyBscjFzdGF0ZSkgOiBib29sID1cbiAgICBULmRlZmF1bHRfcmVkdWN0aW9uIHN0YXRlXG4gICAgICAoZnVuIF9lbnYgX3Byb2QgLT4gdHJ1ZSlcbiAgICAgIChmdW4gX2VudiAtPiBmYWxzZSlcbiAgICAgICgpXG5cbiAgbGV0IGVudl9oYXNfZGVmYXVsdF9yZWR1Y3Rpb24gZW52ID1cbiAgICBzdGF0ZV9oYXNfZGVmYXVsdF9yZWR1Y3Rpb24gZW52LmN1cnJlbnRcblxuICAoKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuICAoKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyB3b3JrIGF0IHRoZSBsZXZlbCBvZiBlbnZpcm9ubWVudHMgKGFzIG9wcG9zZWQgdG9cbiAgICAgY2hlY2twb2ludHMpLiBUaGUgZnVuY3Rpb24gW3BvcF0gY2F1c2VzIHRoZSBhdXRvbWF0b24gdG8gZ28gYmFjayBpbnRvIHRoZVxuICAgICBwYXN0LCBwcmV0ZW5kaW5nIHRoYXQgdGhlIGxhc3QgaW5wdXQgc3ltYm9sIGhhcyBuZXZlciBiZWVuIHJlYWQuIFRoZVxuICAgICBmdW5jdGlvbiBbZm9yY2VfcmVkdWN0aW9uXSBjYXVzZXMgdGhlIGF1dG9tYXRvbiB0byByZS1pbnRlcnByZXQgdGhlIHBhc3QsXG4gICAgIGJ5IHJlY29nbml6aW5nIHRoZSByaWdodC1oYW5kIHNpZGUgb2YgYSBwcm9kdWN0aW9uIGFuZCByZWR1Y2luZyB0aGlzXG4gICAgIHByb2R1Y3Rpb24uIFRoZSBmdW5jdGlvbiBbZmVlZF0gY2F1c2VzIHRoZSBhdXRvbWF0b24gdG8gcHJvZ3Jlc3MgaW50byB0aGVcbiAgICAgZnV0dXJlIGJ5IHByZXRlbmRpbmcgdGhhdCBhICh0ZXJtaW5hbCBvciBub250ZXJtaW5hbCkgc3ltYm9sIGhhcyBiZWVuXG4gICAgIHJlYWQuICopXG5cbiAgKCogVGhlIGZ1bmN0aW9uIFtmZWVkXSB3b3VsZCBpZGVhbGx5IGJlIGRlZmluZWQgaGVyZS4gSG93ZXZlciwgZm9yIHRoaXNcbiAgICAgZnVuY3Rpb24gdG8gYmUgdHlwZS1zYWZlLCB0aGUgR0FEVCBbJ2Egc3ltYm9sXSBpcyBuZWVkZWQuIEZvciB0aGlzXG4gICAgIHJlYXNvbiwgd2UgbW92ZSBpdHMgZGVmaW5pdGlvbiB0byBbSW5zcGVjdGlvblRhYmxlSW50ZXJwcmV0ZXJdLCB3aGVyZVxuICAgICB0aGUgaW5zcGVjdGlvbiBBUEkgaXMgYXZhaWxhYmxlLiAqKVxuXG4gICgqIFtwb3BdIHBvcHMgb25lIHN0YWNrIGNlbGwuIEl0IGNhbm5vdCBnbyB3cm9uZy4gKilcblxuICBsZXQgcG9wIChlbnYgOiAnYSBlbnYpIDogJ2EgZW52IG9wdGlvbiA9XG4gICAgbGV0IGNlbGwgPSBlbnYuc3RhY2sgaW5cbiAgICBsZXQgbmV4dCA9IGNlbGwubmV4dCBpblxuICAgIGlmIG5leHQgPT0gY2VsbCB0aGVuXG4gICAgICAoKiBUaGUgc3RhY2sgaXMgZW1wdHkuICopXG4gICAgICBOb25lXG4gICAgZWxzZVxuICAgICAgKCogVGhlIHN0YWNrIGlzIG5vbmVtcHR5LiBQb3Agb2ZmIG9uZSBjZWxsLiAqKVxuICAgICAgU29tZSB7IGVudiB3aXRoIHN0YWNrID0gbmV4dDsgY3VycmVudCA9IGNlbGwuc3RhdGUgfVxuXG4gICgqIFtmb3JjZV9yZWR1Y3Rpb25dIGlzIGFuYWxvZ291cyB0byBbcmVkdWNlXSwgZXhjZXB0IHRoYXQgaXQgZG9lcyBub3RcbiAgICAgY29udGludWUgYnkgY2FsbGluZyBbcnVuIGVudl0gb3IgW2luaXRpYXRlIGVudl0uIEluc3RlYWQsIGl0IHJldHVybnNcbiAgICAgW2Vudl0gdG8gdGhlIHVzZXIuICopXG5cbiAgKCogW2ZvcmNlX3JlZHVjdGlvbl0gaXMgZGFuZ2Vyb3VzIGluc29mYXIgYXMgaXQgZXhlY3V0ZXMgYSBzZW1hbnRpYyBhY3Rpb24uXG4gICAgIFRoaXMgc2VtYW50aWMgYWN0aW9uIGNvdWxkIGhhdmUgc2lkZSBlZmZlY3RzOiBub250ZXJtaW5hdGlvbiwgc3RhdGUsXG4gICAgIGV4Y2VwdGlvbnMsIGlucHV0L291dHB1dCwgZXRjLiAqKVxuXG4gIGxldCBmb3JjZV9yZWR1Y3Rpb24gcHJvZCAoZW52IDogJ2EgZW52KSA6ICdhIGVudiA9XG4gICAgKCogQ2hlY2sgaWYgdGhpcyByZWR1Y3Rpb24gaXMgcGVybWl0dGVkLiBUaGlzIGNoZWNrIGlzIFJFQUxMWSBpbXBvcnRhbnQuXG4gICAgICAgVGhlIHN0YWNrIG11c3QgaGF2ZSB0aGUgY29ycmVjdCBzaGFwZTogdGhhdCBpcywgaXQgbXVzdCBiZSBzdWZmaWNpZW50bHlcbiAgICAgICBoaWdoLCBhbmQgbXVzdCBjb250YWluIHNlbWFudGljIHZhbHVlcyBvZiBhcHByb3ByaWF0ZSB0eXBlcywgb3RoZXJ3aXNlXG4gICAgICAgdGhlIHNlbWFudGljIGFjdGlvbiB3aWxsIGNyYXNoIGFuZCBidXJuLiAqKVxuICAgICgqIFdlIGN1cnJlbnRseSBjaGVjayB3aGV0aGVyIHRoZSBjdXJyZW50IHN0YXRlIGlzIFdJTExJTkcgdG8gcmVkdWNlIHRoaXNcbiAgICAgICBwcm9kdWN0aW9uIChpLmUuLCB0aGVyZSBpcyBhIHJlZHVjdGlvbiBhY3Rpb24gaW4gdGhlIGFjdGlvbiB0YWJsZSByb3dcbiAgICAgICBhc3NvY2lhdGVkIHdpdGggdGhpcyBzdGF0ZSksIHdoZXJlYXMgaXQgd291bGQgYmUgbW9yZSBsaWJlcmFsIHRvIGNoZWNrXG4gICAgICAgd2hldGhlciB0aGlzIHN0YXRlIGlzIENBUEFCTEUgb2YgcmVkdWNpbmcgdGhpcyBwcm9kdWN0aW9uIChpLmUuLCB0aGVcbiAgICAgICBzdGFjayBoYXMgYW4gYXBwcm9wcmlhdGUgc2hhcGUpLiBXZSBjdXJyZW50bHkgaGF2ZSBubyBtZWFucyBvZlxuICAgICAgIHBlcmZvcm1pbmcgc3VjaCBhIGNoZWNrLiAqKVxuICAgIGlmIG5vdCAoVC5tYXlfcmVkdWNlIGVudi5jdXJyZW50IHByb2QpIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiZm9yY2VfcmVkdWN0aW9uOiB0aGlzIHJlZHVjdGlvbiBpcyBub3QgcGVybWl0dGVkIGluIHRoaXMgc3RhdGVcIlxuICAgIGVsc2UgYmVnaW5cbiAgICAgICgqIFdlIGRvIG5vdCBleHBvc2UgdGhlIHN0YXJ0IHByb2R1Y3Rpb25zIHRvIHRoZSB1c2VyLCBzbyB0aGlzIGNhbm5vdCBiZVxuICAgICAgICAgYSBzdGFydCBwcm9kdWN0aW9uLiBIZW5jZSwgaXQgaGFzIGEgc2VtYW50aWMgYWN0aW9uLiAqKVxuICAgICAgYXNzZXJ0IChub3QgKFQuaXNfc3RhcnQgcHJvZCkpO1xuICAgICAgKCogSW52b2tlIHRoZSBzZW1hbnRpYyBhY3Rpb24uICopXG4gICAgICBsZXQgc3RhY2sgPSBULnNlbWFudGljX2FjdGlvbiBwcm9kIGVudiBpblxuICAgICAgKCogUGVyZm9ybSBhIGdvdG8gdHJhbnNpdGlvbi4gKilcbiAgICAgIGxldCBjdXJyZW50ID0gVC5nb3RvX3Byb2Qgc3RhY2suc3RhdGUgcHJvZCBpblxuICAgICAgeyBlbnYgd2l0aCBzdGFjazsgY3VycmVudCB9XG4gICAgZW5kXG5cbiAgKCogVGhlIGVudmlyb25tZW50IG1hbmlwdWxhdGlvbiBmdW5jdGlvbnMgLS0gW3BvcF0gYW5kIFtmb3JjZV9yZWR1Y3Rpb25dXG4gICAgIGFib3ZlLCBwbHVzIFtmZWVkXSAtLSBtYW5pcHVsYXRlIHRoZSBhdXRvbWF0b24ncyBzdGFjayBhbmQgY3VycmVudCBzdGF0ZSxcbiAgICAgYnV0IGRvIG5vdCBhZmZlY3QgdGhlIGF1dG9tYXRvbidzIGxvb2thaGVhZCBzeW1ib2wuIFdoZW4gdGhlIGZ1bmN0aW9uXG4gICAgIFtpbnB1dF9uZWVkZWRdIGlzIHVzZWQgdG8gZ28gYmFjayBmcm9tIGFuIGVudmlyb25tZW50IHRvIGEgY2hlY2twb2ludFxuICAgICAoYW5kIHRoZXJlZm9yZSwgcmVzdW1lIG5vcm1hbCBwYXJzaW5nKSwgdGhlIGxvb2thaGVhZCBzeW1ib2wgaXMgY2xvYmJlcmVkXG4gICAgIGFueXdheSwgc2luY2UgdGhlIG9ubHkgYWN0aW9uIHRoYXQgdGhlIHVzZXIgY2FuIHRha2UgaXMgdG8gY2FsbCBbb2ZmZXJdLlxuICAgICBTbyBmYXIsIHNvIGdvb2QuIE9uZSBwcm9ibGVtLCB0aG91Z2gsIGlzIHRoYXQgdGhpcyBjYWxsIHRvIFtvZmZlcl0gbWF5XG4gICAgIHdlbGwgcGxhY2UgdGhlIGF1dG9tYXRvbiBpbiBhIGNvbmZpZ3VyYXRpb24gb2YgYSBzdGF0ZSBbc10gYW5kIGFcbiAgICAgbG9va2FoZWFkIHN5bWJvbCBbdF0gdGhhdCBpcyBub3JtYWxseSB1bnJlYWNoYWJsZS4gQWxzbywgcGVyaGFwcyB0aGVcbiAgICAgc3RhdGUgW3NdIGlzIGEgc3RhdGUgd2hlcmUgYW4gaW5wdXQgc3ltYm9sIG5vcm1hbGx5IGlzIG5ldmVyIGRlbWFuZGVkLCBzb1xuICAgICB0aGlzIFtJbnB1dE5lZWRlZF0gY2hlY2twb2ludCBpcyBmaXNoeS4gVGhlcmUgZG9lcyBub3Qgc2VlbSB0byBiZSBhIGRlZXBcbiAgICAgcHJvYmxlbSBoZXJlLCBidXQsIHdoZW4gcHJvZ3JhbW1pbmcgYW4gZXJyb3IgcmVjb3Zlcnkgc3RyYXRlZ3ksIG9uZVxuICAgICBzaG91bGQgcGF5IHNvbWUgYXR0ZW50aW9uIHRvIHRoaXMgaXNzdWUuIElkZWFsbHksIHBlcmhhcHMsIG9uZSBzaG91bGQgdXNlXG4gICAgIFtpbnB1dF9uZWVkZWRdIG9ubHkgaW4gYSBzdGF0ZSBbc10gd2hlcmUgYW4gaW5wdXQgc3ltYm9sIGlzIG5vcm1hbGx5XG4gICAgIGRlbWFuZGVkLCB0aGF0IGlzLCBhIHN0YXRlIFtzXSB3aG9zZSBpbmNvbWluZyBzeW1ib2wgaXMgYSB0ZXJtaW5hbCBzeW1ib2xcbiAgICAgYW5kIHdoaWNoIGRvZXMgbm90IGhhdmUgYSBkZWZhdWx0IHJlZHVjdGlvbiBvbiBbI10uICopXG5cbiAgbGV0IGlucHV0X25lZWRlZCAoZW52IDogJ2EgZW52KSA6ICdhIGNoZWNrcG9pbnQgPVxuICAgIElucHV0TmVlZGVkIGVudlxuXG4gICgqIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGFyZSBjb21wb3NpdGlvbnMgb2YgW3RvcF0gYW5kIFtwb3BdLiAqKVxuXG4gIGxldCByZWMgcG9wX21hbnkgaSBlbnYgPVxuICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgIFNvbWUgZW52XG4gICAgZWxzZSBtYXRjaCBwb3AgZW52IHdpdGhcbiAgICB8IE5vbmUgLT5cbiAgICAgICAgTm9uZVxuICAgIHwgU29tZSBlbnYgLT5cbiAgICAgICAgcG9wX21hbnkgKGkgLSAxKSBlbnZcblxuICBsZXQgZ2V0IGkgZW52ID1cbiAgICBtYXRjaCBwb3BfbWFueSBpIGVudiB3aXRoXG4gICAgfCBOb25lIC0+XG4gICAgICAgIE5vbmVcbiAgICB8IFNvbWUgZW52IC0+XG4gICAgICAgIHRvcCBlbnZcblxuZW5kXG5lbmRcbm1vZHVsZSBFcnJvclJlcG9ydHMgPSBzdHJ1Y3RcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCBJbnJpYS4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyICAgICAqKVxuKCogICB0aGUgdGVybXMgb2YgdGhlIEdOVSBMaWJyYXJ5IEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLCB3aXRoIGEgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZywgYXMgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuKCogQSB0d28tcGxhY2UgYnVmZmVyIHN0b3JlcyB6ZXJvLCBvbmUsIG9yIHR3byBlbGVtZW50cy4gKilcblxudHlwZSAnYSBjb250ZW50ID1cbnwgWmVyb1xufCBPbmUgb2YgJ2FcbnwgVHdvIG9mICdhICogKCogbW9zdCByZWNlbnQ6ICopICdhXG5cbnR5cGUgJ2EgYnVmZmVyID1cbiAgJ2EgY29udGVudCByZWZcblxuKCogW3VwZGF0ZSBidWZmZXIgeF0gcHVzaGVzIFt4XSBpbnRvIFtidWZmZXJdLCBjYXVzaW5nIHRoZSBidWZmZXIgdG8gc2xpZGUuICopXG5cbmxldCB1cGRhdGUgYnVmZmVyIHggPVxuICBidWZmZXIgOj1cbiAgICBtYXRjaCAhYnVmZmVyLCB4IHdpdGhcbiAgICB8IFplcm8sIF8gLT5cbiAgICAgICAgT25lIHhcbiAgICB8IE9uZSB4MSwgeDJcbiAgICB8IFR3byAoXywgeDEpLCB4MiAtPlxuICAgICAgICBUd28gKHgxLCB4MilcblxubGV0IHNob3cgZiBidWZmZXIgOiBzdHJpbmcgPVxuICBtYXRjaCAhYnVmZmVyIHdpdGhcbiAgfCBaZXJvIC0+XG4gICAgICAoKiBUaGUgYnVmZmVyIGNhbm5vdCBiZSBlbXB0eS4gSWYgd2UgaGF2ZSByZWFkIG5vIHRva2VucyxcbiAgICAgICAgIHdlIGNhbm5vdCBoYXZlIGRldGVjdGVkIGEgc3ludGF4IGVycm9yLiAqKVxuICAgICAgYXNzZXJ0IGZhbHNlXG4gIHwgT25lIGludmFsaWQgLT5cbiAgICAgICgqIEl0IGlzIHVubGlrZWx5LCBidXQgcG9zc2libGUsIHRoYXQgd2UgaGF2ZSByZWFkIGp1c3Qgb25lIHRva2VuLiAqKVxuICAgICAgUHJpbnRmLnNwcmludGYgXCJiZWZvcmUgJyVzJ1wiIChmIGludmFsaWQpXG4gIHwgVHdvICh2YWxpZCwgaW52YWxpZCkgLT5cbiAgICAgICgqIEluIHRoZSBtb3N0IGxpa2VseSBjYXNlLCB3ZSBoYXZlIHJlYWQgdHdvIHRva2Vucy4gKilcbiAgICAgIFByaW50Zi5zcHJpbnRmIFwiYWZ0ZXIgJyVzJyBhbmQgYmVmb3JlICclcydcIiAoZiB2YWxpZCkgKGYgaW52YWxpZClcblxubGV0IGxhc3QgYnVmZmVyID1cbiAgbWF0Y2ggIWJ1ZmZlciB3aXRoXG4gIHwgWmVybyAtPlxuICAgICAgKCogVGhlIGJ1ZmZlciBjYW5ub3QgYmUgZW1wdHkuIElmIHdlIGhhdmUgcmVhZCBubyB0b2tlbnMsXG4gICAgICAgICB3ZSBjYW5ub3QgaGF2ZSBkZXRlY3RlZCBhIHN5bnRheCBlcnJvci4gKilcbiAgICAgIGFzc2VydCBmYWxzZVxuICB8IE9uZSBpbnZhbGlkXG4gIHwgVHdvIChfLCBpbnZhbGlkKSAtPlxuICAgICAgaW52YWxpZFxuXG5vcGVuIExleGluZ1xuXG5sZXQgd3JhcCBsZXhlciA9XG4gIGxldCBidWZmZXIgPSByZWYgWmVybyBpblxuICBidWZmZXIsXG4gIGZ1biBsZXhidWYgLT5cbiAgICBsZXQgdG9rZW4gPSBsZXhlciBsZXhidWYgaW5cbiAgICB1cGRhdGUgYnVmZmVyIChsZXhidWYubGV4X3N0YXJ0X3AsIGxleGJ1Zi5sZXhfY3Vycl9wKTtcbiAgICB0b2tlblxuXG5sZXQgd3JhcF9zdXBwbGllciBzdXBwbGllciA9XG4gIGxldCBidWZmZXIgPSByZWYgWmVybyBpblxuICBidWZmZXIsXG4gIGZ1biAoKSAtPlxuICAgIGxldCAoX3Rva2VuLCBwb3MxLCBwb3MyKSBhcyB0cmlwbGUgPSBzdXBwbGllcigpIGluXG4gICAgdXBkYXRlIGJ1ZmZlciAocG9zMSwgcG9zMik7XG4gICAgdHJpcGxlXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbmxldCBleHRyYWN0IHRleHQgKHBvczEsIHBvczIpIDogc3RyaW5nID1cbiAgbGV0IG9mczEgPSBwb3MxLnBvc19jbnVtXG4gIGFuZCBvZnMyID0gcG9zMi5wb3NfY251bSBpblxuICBsZXQgbGVuID0gb2ZzMiAtIG9mczEgaW5cbiAgdHJ5XG4gICAgU3RyaW5nLnN1YiB0ZXh0IG9mczEgbGVuXG4gIHdpdGggSW52YWxpZF9hcmd1bWVudCBfIC0+XG4gICAgKCogSW4gcHJpbmNpcGxlLCB0aGlzIHNob3VsZCBub3QgaGFwcGVuLCBidXQgaWYgaXQgZG9lcywgbGV0J3MgbWFrZSB0aGlzXG4gICAgICAgYSBub24tZmF0YWwgZXJyb3IuICopXG4gICAgXCI/Pz9cIlxuXG5sZXQgc2FuaXRpemUgdGV4dCA9XG4gIFN0cmluZy5tYXAgKGZ1biBjIC0+XG4gICAgaWYgQ2hhci5jb2RlIGMgPCAzMiB0aGVuICcgJyBlbHNlIGNcbiAgKSB0ZXh0XG5cbigqIElmIHdlIHdlcmUgd2lsbGluZyB0byBkZXBlbmQgb24gW1N0cl0sIHdlIGNvdWxkIGltcGxlbWVudCBbY29tcHJlc3NdIGFzXG4gICBmb2xsb3dzOlxuXG4gICBsZXQgY29tcHJlc3MgdGV4dCA9XG4gICAgIFN0ci5nbG9iYWxfcmVwbGFjZSAoU3RyLnJlZ2V4cCBcIlsgXFx0XFxuXFxyXStcIikgXCIgXCIgdGV4dFxuXG4gKilcblxubGV0IHJlYyBjb21wcmVzcyBuIGIgaSBqIHNraXBwaW5nID1cbiAgaWYgaiA8IG4gdGhlblxuICAgIGxldCBjLCBqID0gQnl0ZXMuZ2V0IGIgaiwgaiArIDEgaW5cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICcgJyB8ICdcXHQnIHwgJ1xcbicgfCAnXFxyJyAtPlxuICAgICAgICBsZXQgaSA9IGlmIG5vdCBza2lwcGluZyB0aGVuIChCeXRlcy5zZXQgYiBpICcgJzsgaSArIDEpIGVsc2UgaSBpblxuICAgICAgICBsZXQgc2tpcHBpbmcgPSB0cnVlIGluXG4gICAgICAgIGNvbXByZXNzIG4gYiBpIGogc2tpcHBpbmdcbiAgICB8IF8gLT5cbiAgICAgICAgbGV0IGkgPSBCeXRlcy5zZXQgYiBpIGM7IGkgKyAxIGluXG4gICAgICAgIGxldCBza2lwcGluZyA9IGZhbHNlIGluXG4gICAgICAgIGNvbXByZXNzIG4gYiBpIGogc2tpcHBpbmdcbiAgZWxzZVxuICAgIEJ5dGVzLnN1Yl9zdHJpbmcgYiAwIGlcblxubGV0IGNvbXByZXNzIHRleHQgPVxuICBsZXQgYiA9IEJ5dGVzLm9mX3N0cmluZyB0ZXh0IGluXG4gIGxldCBuID0gQnl0ZXMubGVuZ3RoIGIgaW5cbiAgY29tcHJlc3MgbiBiIDAgMCBmYWxzZVxuXG5sZXQgc2hvcnRlbiBrIHRleHQgPVxuICBsZXQgbiA9IFN0cmluZy5sZW5ndGggdGV4dCBpblxuICBpZiBuIDw9IDIgKiBrICsgMyB0aGVuXG4gICAgdGV4dFxuICBlbHNlXG4gICAgU3RyaW5nLnN1YiB0ZXh0IDAgayBeXG4gICAgXCIuLi5cIiBeXG4gICAgU3RyaW5nLnN1YiB0ZXh0IChuIC0gaykga1xuXG5sZXQgaXNfZGlnaXQgYyA9XG4gIGxldCBjID0gQ2hhci5jb2RlIGMgaW5cbiAgQ2hhci5jb2RlICcwJyA8PSBjICYmIGMgPD0gQ2hhci5jb2RlICc5J1xuXG5leGNlcHRpb24gQ29weVxuXG5sZXQgZXhwYW5kIGYgdGV4dCA9XG4gIGxldCBuID0gU3RyaW5nLmxlbmd0aCB0ZXh0IGluXG4gIGxldCBiID0gQnVmZmVyLmNyZWF0ZSBuIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpIDwgbiB0aGVuIGJlZ2luXG4gICAgICBsZXQgYywgaSA9IHRleHQuW2ldLCBpICsgMSBpblxuICAgICAgbG9vcCAoXG4gICAgICAgIHRyeVxuICAgICAgICAgIGlmIGMgPD4gJyQnIHRoZW4gcmFpc2UgQ29weTtcbiAgICAgICAgICBsZXQgaiA9IHJlZiBpIGluXG4gICAgICAgICAgd2hpbGUgIWogPCBuICYmIGlzX2RpZ2l0IHRleHQuWyFqXSBkbyBpbmNyIGogZG9uZTtcbiAgICAgICAgICBpZiBpID0gIWogdGhlbiByYWlzZSBDb3B5O1xuICAgICAgICAgIGxldCBrID0gaW50X29mX3N0cmluZyAoU3RyaW5nLnN1YiB0ZXh0IGkgKCFqIC0gaSkpIGluXG4gICAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYiAoZiBrKTtcbiAgICAgICAgICAhalxuICAgICAgICB3aXRoIENvcHkgLT5cbiAgICAgICAgICAoKiBXZSByZWFjaCB0aGlzIHBvaW50IGlmIGVpdGhlciBbY10gaXMgbm90ICckJyBvciBbY10gaXMgJyQnXG4gICAgICAgICAgICAgYnV0IGlzIG5vdCBmb2xsb3dlZCBieSBhbiBpbnRlZ2VyIGxpdGVyYWwuICopXG4gICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgYztcbiAgICAgICAgICBpXG4gICAgICApXG4gICAgZW5kXG4gICAgZWxzZVxuICAgICAgQnVmZmVyLmNvbnRlbnRzIGJcbiAgaW5cbiAgbG9vcCAwXG5lbmRcbm1vZHVsZSBMZXhlclV0aWwgPSBzdHJ1Y3RcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCBJbnJpYS4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyICAgICAqKVxuKCogICB0aGUgdGVybXMgb2YgdGhlIEdOVSBMaWJyYXJ5IEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLCB3aXRoIGEgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZywgYXMgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBMZXhpbmdcbm9wZW4gUHJpbnRmXG5cbmxldCBpbml0IGZpbGVuYW1lIGxleGJ1ZiA9XG4gIGxleGJ1Zi5sZXhfY3Vycl9wIDwtIHtcbiAgICBwb3NfZm5hbWUgPSBmaWxlbmFtZTtcbiAgICBwb3NfbG51bSAgPSAxO1xuICAgIHBvc19ib2wgICA9IDA7XG4gICAgcG9zX2NudW0gID0gMFxuICB9O1xuICBsZXhidWZcblxubGV0IHJlYWQgZmlsZW5hbWUgPVxuICBsZXQgYyA9IG9wZW5faW4gZmlsZW5hbWUgaW5cbiAgbGV0IHRleHQgPSByZWFsbHlfaW5wdXRfc3RyaW5nIGMgKGluX2NoYW5uZWxfbGVuZ3RoIGMpIGluXG4gIGNsb3NlX2luIGM7XG4gIGxldCBsZXhidWYgPSBMZXhpbmcuZnJvbV9zdHJpbmcgdGV4dCBpblxuICB0ZXh0LCBpbml0IGZpbGVuYW1lIGxleGJ1ZlxuXG5sZXQgbmV3bGluZSBsZXhidWYgPVxuICBsZXQgcG9zID0gbGV4YnVmLmxleF9jdXJyX3AgaW5cbiAgbGV4YnVmLmxleF9jdXJyX3AgPC0geyBwb3Mgd2l0aFxuICAgIHBvc19sbnVtID0gcG9zLnBvc19sbnVtICsgMTtcbiAgICBwb3NfYm9sID0gcG9zLnBvc19jbnVtO1xuICB9XG5cbmxldCBpc19kdW1teSAocG9zMSwgcG9zMikgPVxuICBwb3MxID09IGR1bW15X3BvcyB8fCBwb3MyID09IGR1bW15X3Bvc1xuXG5sZXQgcmFuZ2UgKChwb3MxLCBwb3MyKSBhcyByYW5nZSkgPVxuICBpZiBpc19kdW1teSByYW5nZSB0aGVuXG4gICAgc3ByaW50ZiBcIkF0IGFuIHVua25vd24gbG9jYXRpb246XFxuXCJcbiAgZWxzZVxuICAgIGxldCBmaWxlID0gcG9zMS5wb3NfZm5hbWUgaW5cbiAgICBsZXQgbGluZSA9IHBvczEucG9zX2xudW0gaW5cbiAgICBsZXQgY2hhcjEgPSBwb3MxLnBvc19jbnVtIC0gcG9zMS5wb3NfYm9sIGluXG4gICAgbGV0IGNoYXIyID0gcG9zMi5wb3NfY251bSAtIHBvczEucG9zX2JvbCBpbiAoKiB5ZXMsIFtwb3MxLnBvc19ib2xdICopXG4gICAgc3ByaW50ZiBcIkZpbGUgXFxcIiVzXFxcIiwgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZDpcXG5cIlxuICAgICAgZmlsZSBsaW5lIGNoYXIxIGNoYXIyXG4gICAgICAoKiB1c2UgW2NoYXIxICsgMV0gYW5kIFtjaGFyMiArIDFdIGlmICpub3QqIHVzaW5nIENhbWwgbW9kZSAqKVxuZW5kXG5tb2R1bGUgUHJpbnRlcnMgPSBzdHJ1Y3RcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCBJbnJpYS4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyICAgICAqKVxuKCogICB0aGUgdGVybXMgb2YgdGhlIEdOVSBMaWJyYXJ5IEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLCB3aXRoIGEgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZywgYXMgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIE1ha2VcbiAgKEkgOiBJbmNyZW1lbnRhbEVuZ2luZS5FVkVSWVRISU5HKVxuICAoVXNlciA6IHNpZ1xuICAgIHZhbCBwcmludDogc3RyaW5nIC0+IHVuaXRcbiAgICB2YWwgcHJpbnRfc3ltYm9sOiBJLnhzeW1ib2wgLT4gdW5pdFxuICAgIHZhbCBwcmludF9lbGVtZW50OiAoSS5lbGVtZW50IC0+IHVuaXQpIG9wdGlvblxuICBlbmQpXG49IHN0cnVjdFxuXG4gIGxldCBhcnJvdyA9IFwiIC0+IFwiXG4gIGxldCBkb3QgPSBcIi5cIlxuICBsZXQgc3BhY2UgPSBcIiBcIlxuICBsZXQgbmV3bGluZSA9IFwiXFxuXCJcblxuICBvcGVuIFVzZXJcbiAgb3BlbiBJXG5cbiAgKCogUHJpbnRpbmcgYSBsaXN0IG9mIHN5bWJvbHMuIEFuIG9wdGlvbmFsIGRvdCBpcyBwcmludGVkIGF0IG9mZnNldFxuICAgICBbaV0gaW50byB0aGUgbGlzdCBbc3ltYm9sc10sIGlmIHRoaXMgb2Zmc2V0IGxpZXMgYmV0d2VlbiBbMF0gYW5kXG4gICAgIHRoZSBsZW5ndGggb2YgdGhlIGxpc3QgKGluY2x1ZGVkKS4gKilcblxuICBsZXQgcmVjIHByaW50X3N5bWJvbHMgaSBzeW1ib2xzID1cbiAgICBpZiBpID0gMCB0aGVuIGJlZ2luXG4gICAgICBwcmludCBkb3Q7XG4gICAgICBwcmludCBzcGFjZTtcbiAgICAgIHByaW50X3N5bWJvbHMgKC0xKSBzeW1ib2xzXG4gICAgZW5kXG4gICAgZWxzZSBiZWdpblxuICAgICAgbWF0Y2ggc3ltYm9scyB3aXRoXG4gICAgICB8IFtdIC0+XG4gICAgICAgICAgKClcbiAgICAgIHwgc3ltYm9sIDo6IHN5bWJvbHMgLT5cbiAgICAgICAgICBwcmludF9zeW1ib2wgc3ltYm9sO1xuICAgICAgICAgIHByaW50IHNwYWNlO1xuICAgICAgICAgIHByaW50X3N5bWJvbHMgKGkgLSAxKSBzeW1ib2xzXG4gICAgZW5kXG5cbiAgKCogUHJpbnRpbmcgYW4gZWxlbWVudCBhcyBhIHN5bWJvbC4gKilcblxuICBsZXQgcHJpbnRfZWxlbWVudF9hc19zeW1ib2wgZWxlbWVudCA9XG4gICAgbWF0Y2ggZWxlbWVudCB3aXRoXG4gICAgfCBFbGVtZW50IChzLCBfLCBfLCBfKSAtPlxuICAgICAgICBwcmludF9zeW1ib2wgKFggKGluY29taW5nX3N5bWJvbCBzKSlcblxuICAoKiBTb21lIG9mIHRoZSBmdW5jdGlvbnMgdGhhdCBmb2xsb3cgbmVlZCBhbiBlbGVtZW50IHByaW50ZXIuIFRoZXkgdXNlXG4gICAgIFtwcmludF9lbGVtZW50XSBpZiBwcm92aWRlZCBieSB0aGUgdXNlcjsgb3RoZXJ3aXNlIHRoZXkgdXNlXG4gICAgIFtwcmludF9lbGVtZW50X2FzX3N5bWJvbF0uICopXG5cbiAgbGV0IHByaW50X2VsZW1lbnQgPVxuICAgIG1hdGNoIHByaW50X2VsZW1lbnQgd2l0aFxuICAgIHwgU29tZSBwcmludF9lbGVtZW50IC0+XG4gICAgICAgIHByaW50X2VsZW1lbnRcbiAgICB8IE5vbmUgLT5cbiAgICAgICAgcHJpbnRfZWxlbWVudF9hc19zeW1ib2xcblxuICAoKiBQcmludGluZyBhIHN0YWNrIGFzIGEgbGlzdCBvZiBzeW1ib2xzLiBTdGFjayBib3R0b20gb24gdGhlIGxlZnQsXG4gICAgIHN0YWNrIHRvcCBvbiB0aGUgcmlnaHQuICopXG5cbiAgbGV0IHJlYyBwcmludF9zdGFjayBlbnYgPVxuICAgIG1hdGNoIHRvcCBlbnYsIHBvcCBlbnYgd2l0aFxuICAgIHwgU29tZSBlbGVtZW50LCBTb21lIGVudiAtPlxuICAgICAgICBwcmludF9zdGFjayBlbnY7XG4gICAgICAgIHByaW50IHNwYWNlO1xuICAgICAgICBwcmludF9lbGVtZW50IGVsZW1lbnRcbiAgICB8IF8sIF8gLT5cbiAgICAgICAgKClcblxuICBsZXQgcHJpbnRfc3RhY2sgZW52ID1cbiAgICBwcmludF9zdGFjayBlbnY7XG4gICAgcHJpbnQgbmV3bGluZVxuXG4gICgqIFByaW50aW5nIGFuIGl0ZW0uICopXG5cbiAgbGV0IHByaW50X2l0ZW0gKHByb2QsIGkpID1cbiAgICBwcmludF9zeW1ib2wgKGxocyBwcm9kKTtcbiAgICBwcmludCBhcnJvdztcbiAgICBwcmludF9zeW1ib2xzIGkgKHJocyBwcm9kKTtcbiAgICBwcmludCBuZXdsaW5lXG5cbiAgKCogUHJpbnRpbmcgYSBsaXN0IG9mIHN5bWJvbHMgKHB1YmxpYyB2ZXJzaW9uKS4gKilcblxuICBsZXQgcHJpbnRfc3ltYm9scyBzeW1ib2xzID1cbiAgICBwcmludF9zeW1ib2xzICgtMSkgc3ltYm9sc1xuXG4gICgqIFByaW50aW5nIGEgcHJvZHVjdGlvbiAod2l0aG91dCBhIGRvdCkuICopXG5cbiAgbGV0IHByaW50X3Byb2R1Y3Rpb24gcHJvZCA9XG4gICAgcHJpbnRfaXRlbSAocHJvZCwgLTEpXG5cbiAgKCogUHJpbnRpbmcgdGhlIGN1cnJlbnQgTFIoMSkgc3RhdGUuICopXG5cbiAgbGV0IHByaW50X2N1cnJlbnRfc3RhdGUgZW52ID1cbiAgICBwcmludCBcIkN1cnJlbnQgTFIoMSkgc3RhdGU6IFwiO1xuICAgIG1hdGNoIHRvcCBlbnYgd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgICBwcmludCBcIjxzb21lIGluaXRpYWwgc3RhdGU+XCI7ICgqIFRFTVBPUkFSWSB1bnNhdGlzZmFjdG9yeSAqKVxuICAgICAgICBwcmludCBuZXdsaW5lXG4gICAgfCBTb21lIChFbGVtZW50IChjdXJyZW50LCBfLCBfLCBfKSkgLT5cbiAgICAgICAgcHJpbnQgKHN0cmluZ19vZl9pbnQgKG51bWJlciBjdXJyZW50KSk7XG4gICAgICAgIHByaW50IG5ld2xpbmU7XG4gICAgICAgIExpc3QuaXRlciBwcmludF9pdGVtIChpdGVtcyBjdXJyZW50KVxuXG4gIGxldCBwcmludF9lbnYgZW52ID1cbiAgICBwcmludF9zdGFjayBlbnY7XG4gICAgcHJpbnRfY3VycmVudF9zdGF0ZSBlbnY7XG4gICAgcHJpbnQgbmV3bGluZVxuXG5lbmRcbmVuZFxubW9kdWxlIEluZmluaXRlQXJyYXkgPSBzdHJ1Y3RcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCBJbnJpYS4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyICAgICAqKVxuKCogICB0aGUgdGVybXMgb2YgdGhlIEdOVSBMaWJyYXJ5IEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLCB3aXRoIGEgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZywgYXMgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCoqIFRoaXMgbW9kdWxlIGltcGxlbWVudHMgaW5maW5pdGUgYXJyYXlzLCB0aGF0IGlzLCBhcnJheXMgdGhhdCBncm93XG4gICAgdHJhbnNwYXJlbnRseSB1cG9uIGRlbWFuZC4gKilcblxudHlwZSAnYSB0ID0ge1xuICAgIGRlZmF1bHQ6ICdhO1xuICAgIG11dGFibGUgdGFibGU6ICdhIGFycmF5O1xuICAgIG11dGFibGUgZXh0ZW50OiBpbnQ7ICgqIHRoZSBpbmRleCBvZiB0aGUgZ3JlYXRlc3QgW3NldF0gZXZlciwgcGx1cyBvbmUgKilcbiAgfVxuXG5sZXQgZGVmYXVsdF9zaXplID1cbiAgMTYzODQgKCogbXVzdCBiZSBub24temVybyAqKVxuXG5sZXQgbWFrZSB4ID0ge1xuICBkZWZhdWx0ID0geDtcbiAgdGFibGUgPSBBcnJheS5tYWtlIGRlZmF1bHRfc2l6ZSB4O1xuICBleHRlbnQgPSAwO1xufVxuXG5sZXQgcmVjIG5ld19sZW5ndGggbGVuZ3RoIGkgPVxuICBpZiBpIDwgbGVuZ3RoIHRoZW5cbiAgICBsZW5ndGhcbiAgZWxzZVxuICAgIG5ld19sZW5ndGggKDIgKiBsZW5ndGgpIGlcblxubGV0IGVuc3VyZSBhIGkgPVxuICBhc3NlcnQgKDAgPD0gaSk7XG4gIGxldCB0YWJsZSA9IGEudGFibGUgaW5cbiAgbGV0IGxlbmd0aCA9IEFycmF5Lmxlbmd0aCB0YWJsZSBpblxuICBpZiBpID49IGxlbmd0aCB0aGVuIGJlZ2luXG4gICAgbGV0IHRhYmxlJyA9IEFycmF5Lm1ha2UgKG5ld19sZW5ndGggKDIgKiBsZW5ndGgpIGkpIGEuZGVmYXVsdCBpblxuICAgIEFycmF5LmJsaXQgdGFibGUgMCB0YWJsZScgMCBsZW5ndGg7XG4gICAgYS50YWJsZSA8LSB0YWJsZSdcbiAgZW5kXG5cbmxldCBnZXQgYSBpID1cbiAgZW5zdXJlIGEgaTtcbiAgQXJyYXkudW5zYWZlX2dldCBhLnRhYmxlIChpKVxuXG5sZXQgc2V0IGEgaSB4ID1cbiAgZW5zdXJlIGEgaTtcbiAgQXJyYXkudW5zYWZlX3NldCBhLnRhYmxlIChpKSB4O1xuICBpZiBhLmV4dGVudCA8PSBpIHRoZW5cbiAgICBhLmV4dGVudCA8LSBpICsgMVxuXG5sZXQgZXh0ZW50IGEgPVxuICBhLmV4dGVudFxuXG5sZXQgZG9tYWluIGEgPVxuICBBcnJheS5zdWIgYS50YWJsZSAwIGEuZXh0ZW50XG5cbmVuZFxubW9kdWxlIFBhY2tlZEludEFycmF5ID0gc3RydWN0XG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgSW5yaWEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciAgICAgKilcbigqICAgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGlicmFyeSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMiwgd2l0aCBhICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcsIGFzIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEEgcGFja2VkIGludGVnZXIgYXJyYXkgaXMgcmVwcmVzZW50ZWQgYXMgYSBwYWlyIG9mIGFuIGludGVnZXIgW2tdIGFuZFxuICAgYSBzdHJpbmcgW3NdLiBUaGUgaW50ZWdlciBba10gaXMgdGhlIG51bWJlciBvZiBiaXRzIHBlciBpbnRlZ2VyIHRoYXQgd2VcbiAgIHVzZS4gVGhlIHN0cmluZyBbc10gaXMganVzdCBhbiBhcnJheSBvZiBiaXRzLCB3aGljaCBpcyByZWFkIGluIDgtYml0XG4gICBjaHVua3MuICopXG5cbigqIFRoZSBvY2FtbCBwcm9ncmFtbWluZyBsYW5ndWFnZSB0cmVhdHMgc3RyaW5nIGxpdGVyYWxzIGFuZCBhcnJheSBsaXRlcmFsc1xuICAgaW4gc2xpZ2h0bHkgZGlmZmVyZW50IHdheXM6IHRoZSBmb3JtZXIgYXJlIHN0YXRpY2FsbHkgYWxsb2NhdGVkLCB3aGlsZVxuICAgdGhlIGxhdHRlciBhcmUgZHluYW1pY2FsbHkgYWxsb2NhdGVkLiAoVGhpcyBpcyByYXRoZXIgYXJiaXRyYXJ5LikgSW4gdGhlXG4gICBjb250ZXh0IG9mIE1lbmhpcidzIHRhYmxlLWJhc2VkIGJhY2stZW5kLCB3aGVyZSBjb21wYWN0LCBpbW11dGFibGVcbiAgIGludGVnZXIgYXJyYXlzIGFyZSBuZWVkZWQsIG9jYW1sIHN0cmluZ3MgYXJlIHByZWZlcmFibGUgdG8gb2NhbWwgYXJyYXlzLiAqKVxuXG50eXBlIHQgPVxuICBpbnQgKiBzdHJpbmdcblxuKCogVGhlIG1hZ25pdHVkZSBba10gb2YgYW4gaW50ZWdlciBbdl0gaXMgdGhlIG51bWJlciBvZiBiaXRzIHJlcXVpcmVkXG4gICB0byByZXByZXNlbnQgW3ZdLiBJdCBpcyByb3VuZGVkIHVwIHRvIHRoZSBuZWFyZXN0IHBvd2VyIG9mIHR3bywgc29cbiAgIHRoYXQgW2tdIGRpdmlkZXMgW1N5cy53b3JkX3NpemVdLiAqKVxuXG5sZXQgbWFnbml0dWRlICh2IDogaW50KSA9XG4gIGlmIHYgPCAwIHRoZW5cbiAgICBTeXMud29yZF9zaXplXG4gIGVsc2VcbiAgICBsZXQgcmVjIGNoZWNrIGsgbWF4ID0gKCogW21heF0gZXF1YWxzIFsyXmtdICopXG4gICAgICBpZiAobWF4IDw9IDApIHx8ICh2IDwgbWF4KSB0aGVuXG4gICAgICAgIGtcbiAgICAgICAgICAoKiBpZiBbbWF4XSBqdXN0IG92ZXJmbGV3LCB0aGVuIFt2XSByZXF1aXJlcyBhIGZ1bGwgb2NhbWxcbiAgICAgICAgICAgICBpbnRlZ2VyLCBhbmQgW2tdIGlzIHRoZSBudW1iZXIgb2YgYml0cyBpbiBhbiBvY2FtbCBpbnRlZ2VyXG4gICAgICAgICAgICAgcGx1cyBvbmUsIHRoYXQgaXMsIFtTeXMud29yZF9zaXplXS4gKilcbiAgICAgIGVsc2VcbiAgICAgICAgY2hlY2sgKDIgKiBrKSAobWF4ICogbWF4KVxuICAgIGluXG4gICAgY2hlY2sgMSAyXG5cbigqIFtwYWNrIGFdIHR1cm5zIGFuIGFycmF5IG9mIGludGVnZXJzIGludG8gYSBwYWNrZWQgaW50ZWdlciBhcnJheS4gKilcblxuKCogQmVjYXVzZSB0aGUgc2lnbiBiaXQgaXMgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0LCB0aGUgbWFnbml0dWRlIG9mXG4gICBhbnkgbmVnYXRpdmUgbnVtYmVyIGlzIHRoZSB3b3JkIHNpemUuIEluIG90aGVyIHdvcmRzLCBbcGFja10gZG9lc1xuICAgbm90IGFjaGlldmUgYW55IHNwYWNlIHNhdmluZ3MgYXMgc29vbiBhcyBbYV0gY29udGFpbnMgYW55IG5lZ2F0aXZlXG4gICBudW1iZXJzLCBldmVuIGlmIHRoZXkgYXJlIGBgc21hbGwnJy4gKilcblxubGV0IHBhY2sgKGEgOiBpbnQgYXJyYXkpIDogdCA9XG5cbiAgbGV0IG0gPSBBcnJheS5sZW5ndGggYSBpblxuXG4gICgqIENvbXB1dGUgdGhlIG1heGltdW0gbWFnbml0dWRlIG9mIHRoZSBhcnJheSBlbGVtZW50cy4gVGhpcyB0ZWxsc1xuICAgICB1cyBob3cgbWFueSBiaXRzIHBlciBlbGVtZW50IHdlIGFyZSBnb2luZyB0byB1c2UuICopXG5cbiAgbGV0IGsgPVxuICAgIEFycmF5LmZvbGRfbGVmdCAoZnVuIGsgdiAtPlxuICAgICAgbWF4IGsgKG1hZ25pdHVkZSB2KVxuICAgICkgMSBhXG4gIGluXG5cbiAgKCogQmVjYXVzZSBhY2Nlc3MgdG8gb2NhbWwgc3RyaW5ncyBpcyBwZXJmb3JtZWQgb24gYW4gOC1iaXQgYmFzaXMsXG4gICAgIHR3byBjYXNlcyBhcmlzZS4gSWYgW2tdIGlzIGxlc3MgdGhhbiA4LCB0aGVuIHdlIGNhbiBwYWNrIG11bHRpcGxlXG4gICAgIGFycmF5IGVudHJpZXMgaW50byBhIHNpbmdsZSBjaGFyYWN0ZXIuIElmIFtrXSBpcyBncmVhdGVyIHRoYW4gOCxcbiAgICAgdGhlbiB3ZSBtdXN0IHVzZSBtdWx0aXBsZSBjaGFyYWN0ZXJzIHRvIHJlcHJlc2VudCBhIHNpbmdsZSBhcnJheVxuICAgICBlbnRyeS4gKilcblxuICBpZiBrIDw9IDggdGhlbiBiZWdpblxuXG4gICAgKCogW3ddIGlzIHRoZSBudW1iZXIgb2YgYXJyYXkgZW50cmllcyB0aGF0IHdlIHBhY2sgaW4gYSBjaGFyYWN0ZXIuICopXG5cbiAgICBhc3NlcnQgKDggbW9kIGsgPSAwKTtcbiAgICBsZXQgdyA9IDggLyBrIGluXG5cbiAgICAoKiBbbl0gaXMgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIHRoYXQgd2UgYWxsb2NhdGUuICopXG5cbiAgICBsZXQgbiA9XG4gICAgICBpZiBtIG1vZCB3ID0gMCB0aGVuXG4gICAgICAgIG0gLyB3XG4gICAgICBlbHNlXG4gICAgICAgIG0gLyB3ICsgMVxuICAgIGluXG5cbiAgICBsZXQgcyA9XG4gICAgICBCeXRlcy5jcmVhdGUgblxuICAgIGluXG5cbiAgICAoKiBEZWZpbmUgYSByZWFkZXIgZm9yIHRoZSBzb3VyY2UgYXJyYXkuIFRoZSByZWFkZXIgbWlnaHQgcnVuIG9mZlxuICAgICAgIHRoZSBlbmQgaWYgW3ddIGRvZXMgbm90IGRpdmlkZSBbbV0uICopXG5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IG5leHQgKCkgPVxuICAgICAgbGV0IGlpID0gIWkgaW5cbiAgICAgIGlmIGlpID0gbSB0aGVuXG4gICAgICAgIDAgKCogcmFuIG9mZiB0aGUgZW5kLCBwYWQgd2l0aCB6ZXJvZXMgKilcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IHYgPSBhLihpaSkgaW5cbiAgICAgICAgaSA6PSBpaSArIDE7XG4gICAgICAgIHZcbiAgICBpblxuXG4gICAgKCogRmlsbCB1cCB0aGUgc3RyaW5nLiAqKVxuXG4gICAgZm9yIGogPSAwIHRvIG4gLSAxIGRvXG4gICAgICBsZXQgYyA9IHJlZiAwIGluXG4gICAgICBmb3IgX3ggPSAxIHRvIHcgZG9cbiAgICAgICAgYyA6PSAoIWMgbHNsIGspIGxvciBuZXh0KClcbiAgICAgIGRvbmU7XG4gICAgICBCeXRlcy5zZXQgcyBqIChDaGFyLmNociAhYylcbiAgICBkb25lO1xuXG4gICAgKCogRG9uZS4gKilcblxuICAgIGssIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgc1xuXG4gIGVuZFxuICBlbHNlIGJlZ2luICgqIGsgPiA4ICopXG5cbiAgICAoKiBbd10gaXMgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgd2UgdXNlIHRvIGVuY29kZSBhbiBhcnJheSBlbnRyeS4gKilcblxuICAgIGFzc2VydCAoayBtb2QgOCA9IDApO1xuICAgIGxldCB3ID0gayAvIDggaW5cblxuICAgICgqIFtuXSBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgdGhhdCB3ZSBhbGxvY2F0ZS4gKilcblxuICAgIGxldCBuID1cbiAgICAgIG0gKiB3XG4gICAgaW5cblxuICAgIGxldCBzID1cbiAgICAgIEJ5dGVzLmNyZWF0ZSBuXG4gICAgaW5cblxuICAgICgqIEZpbGwgdXAgdGhlIHN0cmluZy4gKilcblxuICAgIGZvciBpID0gMCB0byBtIC0gMSBkb1xuICAgICAgbGV0IHYgPSByZWYgYS4oaSkgaW5cbiAgICAgIGZvciB4ID0gMSB0byB3IGRvXG4gICAgICAgIEJ5dGVzLnNldCBzICgoaSArIDEpICogdyAtIHgpIChDaGFyLmNociAoIXYgbGFuZCAyNTUpKTtcbiAgICAgICAgdiA6PSAhdiBsc3IgOFxuICAgICAgZG9uZVxuICAgIGRvbmU7XG5cbiAgICAoKiBEb25lLiAqKVxuXG4gICAgaywgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzXG5cbiAgZW5kXG5cbigqIEFjY2VzcyB0byBhIHN0cmluZy4gKilcblxubGV0IHJlYWQgKHMgOiBzdHJpbmcpIChpIDogaW50KSA6IGludCA9XG4gIENoYXIuY29kZSAoU3RyaW5nLnVuc2FmZV9nZXQgcyBpKVxuXG4oKiBbZ2V0MSB0IGldIHJldHVybnMgdGhlIGludGVnZXIgc3RvcmVkIGluIHRoZSBwYWNrZWQgYXJyYXkgW3RdIGF0IGluZGV4IFtpXS5cbiAgIEl0IGFzc3VtZXMgKGFuZCBkb2VzIG5vdCBjaGVjaykgdGhhdCB0aGUgYXJyYXkncyBiaXQgd2lkdGggaXMgWzFdLiBUaGVcbiAgIHBhcmFtZXRlciBbdF0gaXMganVzdCBhIHN0cmluZy4gKilcblxubGV0IGdldDEgKHMgOiBzdHJpbmcpIChpIDogaW50KSA6IGludCA9XG4gIGxldCBjID0gcmVhZCBzIChpIGxzciAzKSBpblxuICBsZXQgYyA9IGMgbHNyICgobG5vdCBpKSBsYW5kIDBiMTExKSBpblxuICBsZXQgYyA9IGMgbGFuZCAwYjEgaW5cbiAgY1xuXG4oKiBbZ2V0IHQgaV0gcmV0dXJucyB0aGUgaW50ZWdlciBzdG9yZWQgaW4gdGhlIHBhY2tlZCBhcnJheSBbdF0gYXQgaW5kZXggW2ldLiAqKVxuXG4oKiBUb2dldGhlciwgW3BhY2tdIGFuZCBbZ2V0XSBzYXRpc2Z5IHRoZSBmb2xsb3dpbmcgcHJvcGVydHk6IGlmIHRoZSBpbmRleCBbaV1cbiAgIGlzIHdpdGhpbiBib3VuZHMsIHRoZW4gW2dldCAocGFjayBhKSBpXSBlcXVhbHMgW2EuKGkpXS4gKilcblxubGV0IGdldCAoKGssIHMpIDogdCkgKGkgOiBpbnQpIDogaW50ID1cbiAgbWF0Y2ggayB3aXRoXG4gIHwgMSAtPlxuICAgICAgZ2V0MSBzIGlcbiAgfCAyIC0+XG4gICAgICBsZXQgYyA9IHJlYWQgcyAoaSBsc3IgMikgaW5cbiAgICAgIGxldCBjID0gYyBsc3IgKDIgKiAoKGxub3QgaSkgbGFuZCAwYjExKSkgaW5cbiAgICAgIGxldCBjID0gYyBsYW5kIDBiMTEgaW5cbiAgICAgIGNcbiAgfCA0IC0+XG4gICAgICBsZXQgYyA9IHJlYWQgcyAoaSBsc3IgMSkgaW5cbiAgICAgIGxldCBjID0gYyBsc3IgKDQgKiAoKGxub3QgaSkgbGFuZCAwYjEpKSBpblxuICAgICAgbGV0IGMgPSBjIGxhbmQgMGIxMTExIGluXG4gICAgICBjXG4gIHwgOCAtPlxuICAgICAgcmVhZCBzIGlcbiAgfCAxNiAtPlxuICAgICAgbGV0IGogPSAyICogaSBpblxuICAgICAgKHJlYWQgcyBqKSBsc2wgOCArIHJlYWQgcyAoaiArIDEpXG4gIHwgXyAtPlxuICAgICAgYXNzZXJ0IChrID0gMzIpOyAoKiA2NCBiaXRzIHVubGlrZWx5LCBub3Qgc3VwcG9ydGVkICopXG4gICAgICBsZXQgaiA9IDQgKiBpIGluXG4gICAgICAoKChyZWFkIHMgaiBsc2wgOCkgKyByZWFkIHMgKGogKyAxKSkgbHNsIDggKyByZWFkIHMgKGogKyAyKSkgbHNsIDggKyByZWFkIHMgKGogKyAzKVxuXG4oKiBbdW5mbGF0dGVuMSAobiwgZGF0YSkgaSBqXSBhY2Nlc3NlcyB0aGUgdHdvLWRpbWVuc2lvbmFsIGJpdG1hcFxuICAgcmVwcmVzZW50ZWQgYnkgWyhuLCBkYXRhKV0gYXQgaW5kaWNlcyBbaV0gYW5kIFtqXS4gVGhlIGludGVnZXJcbiAgIFtuXSBpcyB0aGUgd2lkdGggb2YgdGhlIGJpdG1hcDsgdGhlIHN0cmluZyBbZGF0YV0gaXMgdGhlIHNlY29uZFxuICAgY29tcG9uZW50IG9mIHRoZSBwYWNrZWQgYXJyYXkgb2J0YWluZWQgYnkgZW5jb2RpbmcgdGhlIHRhYmxlIGFzXG4gICBhIG9uZS1kaW1lbnNpb25hbCBhcnJheS4gKilcblxubGV0IHVuZmxhdHRlbjEgKG4sIGRhdGEpIGkgaiA9XG4gICBnZXQxIGRhdGEgKG4gKiBpICsgailcblxuZW5kXG5tb2R1bGUgUm93RGlzcGxhY2VtZW50ID0gc3RydWN0XG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgSW5yaWEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciAgICAgKilcbigqICAgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGlicmFyeSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMiwgd2l0aCBhICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcsIGFzIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFRoaXMgbW9kdWxlIGNvbXByZXNzZXMgYSB0d28tZGltZW5zaW9uYWwgdGFibGUsIHdoZXJlIHNvbWUgdmFsdWVzXG4gICBhcmUgY29uc2lkZXJlZCBpbnNpZ25pZmljYW50LCB2aWEgcm93IGRpc3BsYWNlbWVudC4gKilcblxuKCogVGhpcyBpZGVhIHJlcG9ydGVkbHkgYXBwZWFycyBpbiBBaG8gYW5kIFVsbG1hbidzIGBgUHJpbmNpcGxlc1xuICAgb2YgQ29tcGlsZXIgRGVzaWduJycgKDE5NzcpLiBJdCBpcyBldmFsdWF0ZWQgaW4gVGFyamFuIGFuZCBZYW8nc1xuICAgYGBTdG9yaW5nIGEgU3BhcnNlIFRhYmxlJycgKDE5NzkpIGFuZCBpbiBEZW5ja2VyLCBEw7xycmUsIGFuZCBIZXVmdCdzXG4gICBgYE9wdGltaXphdGlvbiBvZiBQYXJzZXIgVGFibGVzIGZvciBQb3J0YWJsZSBDb21waWxlcnMnJyAoMTk4NCkuICopXG5cbigqIEEgY29tcHJlc3NlZCB0YWJsZSBpcyByZXByZXNlbnRlZCBhcyBhIHBhaXIgb2YgYXJyYXlzLiBUaGVcbiAgIGRpc3BsYWNlbWVudCBhcnJheSBpcyBhbiBhcnJheSBvZiBvZmZzZXRzIGludG8gdGhlIGRhdGEgYXJyYXkuICopXG5cbnR5cGUgJ2EgdGFibGUgPVxuICAgIGludCBhcnJheSAqICgqIGRpc3BsYWNlbWVudCAqKVxuICAgICAnYSBhcnJheSAgICgqIGRhdGEgKilcblxuKCogSW4gYSBuYXR1cmFsIHZlcnNpb24gb2YgdGhpcyBhbGdvcml0aG0sIGRpc3BsYWNlbWVudHMgd291bGQgYmUgZ3JlYXRlclxuICAgdGhhbiAob3IgZXF1YWwgdG8pIFstbl0uIEhvd2V2ZXIsIGluIHRoZSBwYXJ0aWN1bGFyIHNldHRpbmcgb2YgTWVuaGlyLFxuICAgYm90aCBhcnJheXMgYXJlIGludGVuZGVkIHRvIGJlIGNvbXByZXNzZWQgd2l0aCBbUGFja2VkSW50QXJyYXldLCB3aGljaFxuICAgZG9lcyBub3QgZWZmaWNpZW50bHkgc3VwcG9ydCBuZWdhdGl2ZSBudW1iZXJzLiBGb3IgdGhpcyByZWFzb24sIHdlIGFyZVxuICAgY2FyZWZ1bCBub3QgdG8gcHJvZHVjZSBuZWdhdGl2ZSBkaXNwbGFjZW1lbnRzLiAqKVxuXG4oKiBJbiBvcmRlciB0byBhdm9pZCBwcm9kdWNpbmcgbmVnYXRpdmUgZGlzcGxhY2VtZW50cywgd2Ugc2ltcGx5IHVzZSB0aGVcbiAgIGxlYXN0IHNpZ25pZmljYW50IGJpdCBhcyB0aGUgc2lnbiBiaXQuIFRoaXMgaXMgaW1wbGVtZW50ZWQgYnkgW2VuY29kZV1cbiAgIGFuZCBbZGVjb2RlXSBiZWxvdy4gKilcblxuKCogT25lIGNvdWxkIGFsc28gdGhpbmssIHNheSwgb2YgYWRkaW5nIFtuXSB0byBldmVyeSBkaXNwbGFjZW1lbnQsIHNvIGFzXG4gICB0byBlbnN1cmUgdGhhdCBhbGwgZGlzcGxhY2VtZW50cyBhcmUgbm9ubmVnYXRpdmUuIFRoaXMgd291bGQgd29yaywgYnV0XG4gICB3b3VsZCByZXF1aXJlIFtuXSB0byBiZSBwdWJsaXNoZWQsIGZvciB1c2UgYnkgdGhlIGRlY29kZXIuICopXG5cbmxldCBlbmNvZGUgKGRpc3BsYWNlbWVudCA6IGludCkgOiBpbnQgPVxuICBpZiBkaXNwbGFjZW1lbnQgPj0gMCB0aGVuXG4gICAgZGlzcGxhY2VtZW50IGxzbCAxXG4gIGVsc2VcbiAgICAoLWRpc3BsYWNlbWVudCkgbHNsIDEgKyAxXG5cbmxldCBkZWNvZGUgKGRpc3BsYWNlbWVudCA6IGludCkgOiBpbnQgPVxuICBpZiBkaXNwbGFjZW1lbnQgbGFuZCAxID0gMCB0aGVuXG4gICAgZGlzcGxhY2VtZW50IGxzciAxXG4gIGVsc2VcbiAgICAtKGRpc3BsYWNlbWVudCBsc3IgMSlcblxuKCogSXQgaXMgcmVhc29uYWJsZSB0byBhc3N1bWUgdGhhdCwgYXMgbWF0cmljZXMgZ3JvdyBsYXJnZSwgdGhlaXJcbiAgIGRlbnNpdHkgYmVjb21lcyBsb3csIGkuZS4sIHRoZXkgaGF2ZSBtYW55IGluc2lnbmlmaWNhbnQgZW50cmllcy5cbiAgIEFzIGEgcmVzdWx0LCBpdCBpcyBpbXBvcnRhbnQgdG8gd29yayB3aXRoIGEgc3BhcnNlIGRhdGEgc3RydWN0dXJlXG4gICBmb3Igcm93cy4gV2UgaW50ZXJuYWxseSByZXByZXNlbnQgYSByb3cgYXMgYSBsaXN0IG9mIGl0c1xuICAgc2lnbmlmaWNhbnQgZW50cmllcywgd2hlcmUgZWFjaCBlbnRyeSBpcyBhIHBhaXIgb2YgYSBbal0gaW5kZXggYW5kXG4gICBhbiBlbGVtZW50LiAqKVxuXG50eXBlICdhIHJvdyA9XG4gICAgKGludCAqICdhKSBsaXN0XG5cbigqIFtjb21wcmVzcyBlcXVhbCBpbnNpZ25pZmljYW50IGR1bW15IG0gbiB0XSB0dXJucyB0aGUgdHdvLWRpbWVuc2lvbmFsIHRhYmxlXG4gICBbdF0gaW50byBhIGNvbXByZXNzZWQgdGFibGUuIFRoZSBwYXJhbWV0ZXIgW2VxdWFsXSBpcyBlcXVhbGl0eSBvZiBkYXRhXG4gICB2YWx1ZXMuIFRoZSBwYXJhbWV0ZXIgW3dpbGRjYXJkXSB0ZWxscyB3aGljaCBkYXRhIHZhbHVlcyBhcmUgaW5zaWduaWZpY2FudCxcbiAgIGFuZCBjYW4gdGh1cyBiZSBvdmVyd3JpdHRlbiB3aXRoIG90aGVyIHZhbHVlcy4gVGhlIHBhcmFtZXRlciBbZHVtbXldIGlzXG4gICB1c2VkIHRvIGZpbGwgaG9sZXMgaW4gdGhlIGRhdGEgYXJyYXkuIFttXSBhbmQgW25dIGFyZSB0aGUgaW50ZWdlclxuICAgZGltZW5zaW9ucyBvZiB0aGUgdGFibGUgW3RdLiAqKVxuXG5sZXQgY29tcHJlc3NcbiAgICAoZXF1YWwgOiAnYSAtPiAnYSAtPiBib29sKVxuICAgIChpbnNpZ25pZmljYW50IDogJ2EgLT4gYm9vbClcbiAgICAoZHVtbXkgOiAnYSlcbiAgICAobSA6IGludCkgKG4gOiBpbnQpXG4gICAgKHQgOiAnYSBhcnJheSBhcnJheSlcbiAgICA6ICdhIHRhYmxlID1cblxuICAoKiBCZSBkZWZlbnNpdmUuICopXG5cbiAgYXNzZXJ0IChBcnJheS5sZW5ndGggdCA9IG0pO1xuICBhc3NlcnQgYmVnaW5cbiAgICBmb3IgaSA9IDAgdG8gbSAtIDEgZG9cbiAgICAgIGFzc2VydCAoQXJyYXkubGVuZ3RoIHQuKGkpID0gbilcbiAgICBkb25lO1xuICAgIHRydWVcbiAgZW5kO1xuXG4gICgqIFRoaXMgdHVybnMgYSByb3ctYXMtYXJyYXkgaW50byBhIHJvdy1hcy1zcGFyc2UtbGlzdC4gVGhlIHJvdyBpc1xuICAgICBhY2NvbXBhbmllZCBieSBpdHMgaW5kZXggW2ldIGFuZCBieSBpdHMgcmFuayAodGhlIG51bWJlciBvZiBpdHNcbiAgICAgc2lnbmlmaWNhbnQgZW50cmllcywgdGhhdCBpcywgdGhlIGxlbmd0aCBvZiB0aGUgcm93LWFzLWEtbGlzdC4gKilcblxuICBsZXQgc3BhcnNlIChpIDogaW50KSAobGluZSA6ICdhIGFycmF5KSA6IGludCAqIGludCAqICdhIHJvdyAoKiBpbmRleCwgcmFuaywgcm93ICopID1cblxuICAgIGxldCByZWMgbG9vcCAoaiA6IGludCkgKHJhbmsgOiBpbnQpIChyb3cgOiAnYSByb3cpID1cbiAgICAgIGlmIGogPCAwIHRoZW5cbiAgICAgICAgaSwgcmFuaywgcm93XG4gICAgICBlbHNlXG4gICAgICAgIGxldCB4ID0gbGluZS4oaikgaW5cbiAgICAgICAgaWYgaW5zaWduaWZpY2FudCB4IHRoZW5cbiAgICAgICAgICBsb29wIChqIC0gMSkgcmFuayByb3dcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxvb3AgKGogLSAxKSAoMSArIHJhbmspICgoaiwgeCkgOjogcm93KVxuICAgIGluXG5cbiAgICBsb29wIChuIC0gMSkgMCBbXVxuXG4gIGluXG5cbiAgKCogQ29uc3RydWN0IGFuIGFycmF5IG9mIGFsbCByb3dzLCB0b2dldGhlciB3aXRoIHRoZWlyIGluZGV4IGFuZCByYW5rLiAqKVxuXG4gIGxldCByb3dzIDogKGludCAqIGludCAqICdhIHJvdykgYXJyYXkgPSAoKiBpbmRleCwgcmFuaywgcm93ICopXG4gICAgQXJyYXkubWFwaSBzcGFyc2UgdFxuICBpblxuXG4gICgqIFNvcnQgdGhpcyBhcnJheSBieSBkZWNyZWFzaW5nIHJhbmsuIFRoaXMgZG9lcyBub3QgaGF2ZSBhbnkgaW1wYWN0XG4gICAgIG9uIGNvcnJlY3RuZXNzLCBidXQgcmVwb3J0ZWRseSBpbXByb3ZlcyBjb21wcmVzc2lvbi4gVGhlXG4gICAgIGludHVpdGl2ZSBpZGVhIGlzIHRoYXQgcm93cyB3aXRoIGZldyBzaWduaWZpY2FudCBlbGVtZW50cyBhcmVcbiAgICAgZWFzeSB0byBmaXQsIHNvIHRoZXkgc2hvdWxkIGJlIGluc2VydGVkIGxhc3QsIGFmdGVyIHRoZSBwcm9ibGVtXG4gICAgIGhhcyBiZWNvbWUgcXVpdGUgY29uc3RyYWluZWQgYnkgZml0dGluZyB0aGUgaGVhdmllciByb3dzLiBUaGlzXG4gICAgIGhldXJpc3RpYyBpcyBhdHRyaWJ1dGVkIHRvIFppZWdsZXIuICopXG5cbiAgQXJyYXkuZmFzdF9zb3J0IChmdW4gKF8sIHJhbmsxLCBfKSAoXywgcmFuazIsIF8pIC0+XG4gICAgY29tcGFyZSByYW5rMiByYW5rMVxuICApIHJvd3M7XG5cbiAgKCogQWxsb2NhdGUgYSBvbmUtZGltZW5zaW9uYWwgYXJyYXkgb2YgZGlzcGxhY2VtZW50cy4gKilcblxuICBsZXQgZGlzcGxhY2VtZW50IDogaW50IGFycmF5ID1cbiAgICBBcnJheS5tYWtlIG0gMFxuICBpblxuXG4gICgqIEFsbG9jYXRlIGEgb25lLWRpbWVuc2lvbmFsLCBpbmZpbml0ZSBhcnJheSBvZiB2YWx1ZXMuIEluZGljZXNcbiAgICAgaW50byB0aGlzIGFycmF5IGFyZSB3cml0dGVuIFtrXS4gKilcblxuICBsZXQgZGF0YSA6ICdhIEluZmluaXRlQXJyYXkudCA9XG4gICAgSW5maW5pdGVBcnJheS5tYWtlIGR1bW15XG4gIGluXG5cbiAgKCogRGV0ZXJtaW5lIHdoZXRoZXIgW3Jvd10gZml0cyBhdCBvZmZzZXQgW2tdIHdpdGhpbiB0aGUgY3VycmVudCBbZGF0YV1cbiAgICAgYXJyYXksIHVwIHRvIGV4dGVuc2lvbiBvZiB0aGlzIGFycmF5LiAqKVxuXG4gICgqIE5vdGUgdGhhdCB0aGlzIGNoZWNrIGFsd2F5cyBzdWNjZWVkcyB3aGVuIFtrXSBlcXVhbHMgdGhlIGxlbmd0aCBvZlxuICAgICB0aGUgW2RhdGFdIGFycmF5LiBJbmRlZWQsIHRoZSBsb29wIGlzIHRoZW4gc2tpcHBlZC4gVGhpcyBwcm9wZXJ0eVxuICAgICBndWFyYW50ZWVzIHRoZSB0ZXJtaW5hdGlvbiBvZiB0aGUgcmVjdXJzaXZlIGZ1bmN0aW9uIFtmaXRdIGJlbG93LiAqKVxuXG4gIGxldCBmaXRzIGsgKHJvdyA6ICdhIHJvdykgOiBib29sID1cblxuICAgIGxldCBkID0gSW5maW5pdGVBcnJheS5leHRlbnQgZGF0YSBpblxuXG4gICAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT5cbiAgICAgICAgICB0cnVlXG4gICAgICB8IChqLCB4KSA6OiByb3cgLT5cblxuICAgICAgICAgICgqIFt4XSBpcyBhIHNpZ25pZmljYW50IGVsZW1lbnQuICopXG5cbiAgICAgICAgICAoKiBCeSBoeXBvdGhlc2lzLCBbayArIGpdIGlzIG5vbm5lZ2F0aXZlLiBJZiBpdCBpcyBncmVhdGVyIHRoYW4gb3JcbiAgICAgICAgICAgICBlcXVhbCB0byB0aGUgY3VycmVudCBsZW5ndGggb2YgdGhlIGRhdGEgYXJyYXksIHN0b3AgLS0gdGhlIHJvd1xuICAgICAgICAgICAgIGZpdHMuICopXG5cbiAgICAgICAgICBhc3NlcnQgKGsgKyBqID49IDApO1xuXG4gICAgICAgICAgaWYgayArIGogPj0gZCB0aGVuXG4gICAgICAgICAgICB0cnVlXG5cbiAgICAgICAgICAoKiBXZSBub3cga25vdyB0aGF0IFtrICsgal0gaXMgd2l0aGluIGJvdW5kcyBvZiB0aGUgZGF0YVxuICAgICAgICAgICAgIGFycmF5LiBDaGVjayB3aGV0aGVyIGl0IGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgZWxlbWVudCBbeV0gZm91bmRcbiAgICAgICAgICAgICB0aGVyZS4gSWYgaXQgaXMsIGNvbnRpbnVlLiBJZiBpdCBpc24ndCwgc3RvcCAtLSB0aGUgcm93IGRvZXMgbm90XG4gICAgICAgICAgICAgZml0LiAqKVxuXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHkgPSBJbmZpbml0ZUFycmF5LmdldCBkYXRhIChrICsgaikgaW5cbiAgICAgICAgICAgIGlmIGluc2lnbmlmaWNhbnQgeSB8fCBlcXVhbCB4IHkgdGhlblxuICAgICAgICAgICAgICBsb29wIHJvd1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBmYWxzZVxuXG4gICAgaW5cbiAgICBsb29wIHJvd1xuXG4gIGluXG5cbiAgKCogRmluZCB0aGUgbGVmdG1vc3QgcG9zaXRpb24gd2hlcmUgYSByb3cgZml0cy4gKilcblxuICAoKiBJZiB0aGUgbGVmdG1vc3Qgc2lnbmlmaWNhbnQgZWxlbWVudCBpbiB0aGlzIHJvdyBpcyBhdCBvZmZzZXQgW2pdLFxuICAgICB0aGVuIHdlIGNhbiBob3BlIHRvIGZpdCBhcyBmYXIgbGVmdCBhcyBbLWpdIC0tIHNvIHRoaXMgZWxlbWVudFxuICAgICBsYW5kcyBhdCBvZmZzZXQgWzBdIGluIHRoZSBkYXRhIGFycmF5LiAqKVxuXG4gICgqIE5vdGUgdGhhdCBkaXNwbGFjZW1lbnRzIG1heSBiZSBuZWdhdGl2ZS4gVGhpcyBtZWFucyB0aGF0LCBmb3JcbiAgICAgaW5zaWduaWZpY2FudCBlbGVtZW50cywgYWNjZXNzZXMgdG8gdGhlIGRhdGEgYXJyYXkgY291bGQgZmFpbDogdGhleSBjb3VsZFxuICAgICBiZSBvdXQgb2YgYm91bmRzLCBlaXRoZXIgdG93YXJkcyB0aGUgbGVmdCBvciB0b3dhcmRzIHRoZSByaWdodC4gVGhpcyBpc1xuICAgICBub3QgYSBwcm9ibGVtLCBhcyBsb25nIGFzIFtnZXRdIGlzIGludm9rZWQgb25seSBhdCBzaWduaWZpY2FudFxuICAgICBlbGVtZW50cy4gKilcblxuICBsZXQgcmVjIGZpdCBrIHJvdyA6IGludCA9XG4gICAgaWYgZml0cyBrIHJvdyB0aGVuXG4gICAgICBrXG4gICAgZWxzZVxuICAgICAgZml0IChrICsgMSkgcm93XG4gIGluXG5cbiAgbGV0IGZpdCByb3cgPVxuICAgIG1hdGNoIHJvdyB3aXRoXG4gICAgfCBbXSAtPlxuICAgICAgICAwICgqIGlycmVsZXZhbnQgKilcbiAgICB8IChqLCBfKSA6OiBfIC0+XG4gICAgICAgIGZpdCAoLWopIHJvd1xuICBpblxuXG4gICgqIFdyaXRlIFtyb3ddIGF0IChjb21wYXRpYmxlKSBvZmZzZXQgW2tdLiAqKVxuXG4gIGxldCByZWMgd3JpdGUgayA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPlxuICAgICAgICAoKVxuICAgIHwgKGosIHgpIDo6IHJvdyAtPlxuICAgICAgICBJbmZpbml0ZUFycmF5LnNldCBkYXRhIChrICsgaikgeDtcbiAgICAgICAgd3JpdGUgayByb3dcbiAgaW5cblxuICAoKiBJdGVyYXRlIG92ZXIgdGhlIHNvcnRlZCBhcnJheSBvZiByb3dzLiBGaXQgYW5kIHdyaXRlIGVhY2ggcm93IGF0XG4gICAgIHRoZSBsZWZ0bW9zdCBjb21wYXRpYmxlIG9mZnNldC4gVXBkYXRlIHRoZSBkaXNwbGFjZW1lbnQgdGFibGUuICopXG5cbiAgQXJyYXkuaXRlciAoZnVuIChpLCBfLCByb3cpIC0+XG4gICAgbGV0IGsgPSBmaXQgcm93IGluICgqIGlmIFtyb3ddIGhhcyBsZWFkaW5nIGluc2lnbmlmaWNhbnQgZWxlbWVudHMsIHRoZW4gW2tdIGNhbiBiZSBuZWdhdGl2ZSAqKVxuICAgIHdyaXRlIGsgcm93O1xuICAgIGRpc3BsYWNlbWVudC4oaSkgPC0gZW5jb2RlIGtcbiAgKSByb3dzO1xuXG4gICgqIFJldHVybiB0aGUgY29tcHJlc3NlZCB0YWJsZXMuICopXG5cbiAgZGlzcGxhY2VtZW50LCBJbmZpbml0ZUFycmF5LmRvbWFpbiBkYXRhXG5cbigqIFtnZXQgY3QgaSBqXSByZXR1cm5zIHRoZSB2YWx1ZSBmb3VuZCBhdCBpbmRpY2VzIFtpXSBhbmQgW2pdIGluIHRoZVxuICAgY29tcHJlc3NlZCB0YWJsZSBbY3RdLiBUaGlzIGZ1bmN0aW9uIGNhbGwgaXMgcGVybWl0dGVkIG9ubHkgaWYgdGhlXG4gICB2YWx1ZSBmb3VuZCBhdCBpbmRpY2VzIFtpXSBhbmQgW2pdIGluIHRoZSBvcmlnaW5hbCB0YWJsZSBpc1xuICAgc2lnbmlmaWNhbnQgLS0gb3RoZXJ3aXNlLCBpdCBjb3VsZCBmYWlsIGFicnVwdGx5LiAqKVxuXG4oKiBUb2dldGhlciwgW2NvbXByZXNzXSBhbmQgW2dldF0gaGF2ZSB0aGUgcHJvcGVydHkgdGhhdCwgaWYgdGhlIHZhbHVlXG4gICBmb3VuZCBhdCBpbmRpY2VzIFtpXSBhbmQgW2pdIGluIGFuIHVuY29tcHJlc3NlZCB0YWJsZSBbdF0gaXNcbiAgIHNpZ25pZmljYW50LCB0aGVuIFtnZXQgKGNvbXByZXNzIHQpIGkgal0gaXMgZXF1YWwgdG8gdGhhdCB2YWx1ZS4gKilcblxubGV0IGdldCAoZGlzcGxhY2VtZW50LCBkYXRhKSBpIGogPVxuICBhc3NlcnQgKDAgPD0gaSAmJiBpIDwgQXJyYXkubGVuZ3RoIGRpc3BsYWNlbWVudCk7XG4gIGxldCBrID0gZGVjb2RlIGRpc3BsYWNlbWVudC4oaSkgaW5cbiAgYXNzZXJ0ICgwIDw9IGsgKyBqICYmIGsgKyBqIDwgQXJyYXkubGVuZ3RoIGRhdGEpO1xuICAgICgqIGZhaWx1cmUgb2YgdGhpcyBhc3NlcnRpb24gaW5kaWNhdGVzIGFuIGF0dGVtcHQgdG8gYWNjZXNzIGFuXG4gICAgICAgaW5zaWduaWZpY2FudCBlbGVtZW50IHRoYXQgaGFwcGVucyB0byBiZSBtYXBwZWQgb3V0IG9mIHRoZSBib3VuZHNcbiAgICAgICBvZiB0aGUgW2RhdGFdIGFycmF5LiAqKVxuICBkYXRhLihrICsgailcblxuKCogW2dldGdldF0gaXMgYSB2YXJpYW50IG9mIFtnZXRdIHdoaWNoIG9ubHkgcmVxdWlyZXMgcmVhZCBhY2Nlc3MsXG4gICB2aWEgYWNjZXNzb3JzLCB0byB0aGUgdHdvIGNvbXBvbmVudHMgb2YgdGhlIHRhYmxlLiAqKVxuXG5sZXQgZ2V0Z2V0IGdldF9kaXNwbGFjZW1lbnQgZ2V0X2RhdGEgKGRpc3BsYWNlbWVudCwgZGF0YSkgaSBqID1cbiAgbGV0IGsgPSBkZWNvZGUgKGdldF9kaXNwbGFjZW1lbnQgZGlzcGxhY2VtZW50IGkpIGluXG4gIGdldF9kYXRhIGRhdGEgKGsgKyBqKVxuZW5kXG5tb2R1bGUgTGluZWFyaXplZEFycmF5ID0gc3RydWN0XG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgSW5yaWEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciAgICAgKilcbigqICAgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGlicmFyeSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMiwgd2l0aCBhICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcsIGFzIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFRoZSBbZW50cnldIGFycmF5IGNvbnRhaW5zIG9mZnNldHMgaW50byB0aGUgW2RhdGFdIGFycmF5LiBJdCBoYXMgW24rMV1cbiAgIGVsZW1lbnRzIGlmIHRoZSBvcmlnaW5hbCAodW5lbmNvZGVkKSBhcnJheSBoYXMgW25dIGVsZW1lbnRzLiBUaGUgdmFsdWVcbiAgIG9mIFtlbnRyeS4obildIGlzIHRoZSBsZW5ndGggb2YgdGhlIFtkYXRhXSBhcnJheS4gVGhpcyBjb252ZW50aW9uIGlzXG4gICBuYXR1cmFsIGFuZCBhbGxvd3MgYXZvaWRpbmcgYSBzcGVjaWFsIGNhc2UuICopXG5cbnR5cGUgJ2EgdCA9XG4gICgqIGRhdGE6ICopICAgJ2EgYXJyYXkgKlxuICAoKiBlbnRyeTogKikgaW50IGFycmF5XG5cbmxldCBtYWtlIChhIDogJ2EgYXJyYXkgYXJyYXkpIDogJ2EgdCA9XG4gIGxldCBuID0gQXJyYXkubGVuZ3RoIGEgaW5cbiAgKCogQnVpbGQgdGhlIGVudHJ5IGFycmF5LiAqKVxuICBsZXQgc2l6ZSA9IHJlZiAwIGluXG4gIGxldCBlbnRyeSA9IEFycmF5LmluaXQgKG4gKyAxKSAoZnVuIGkgLT5cbiAgICBsZXQgcyA9ICFzaXplIGluXG4gICAgaWYgaSA8IG4gdGhlblxuICAgICAgc2l6ZSA6PSBzICsgQXJyYXkubGVuZ3RoIGEuKGkpO1xuICAgIHNcbiAgKSBpblxuICBhc3NlcnQgKGVudHJ5LihuKSA9ICFzaXplKTtcbiAgKCogQnVpbGQgdGhlIGRhdGEgYXJyYXkuICopXG4gIGxldCBpID0gcmVmIDBcbiAgYW5kIGogPSByZWYgMCBpblxuICBsZXQgZGF0YSA9IEFycmF5LmluaXQgIXNpemUgKGZ1biBfIC0+XG4gICAgd2hpbGUgIWogPSBBcnJheS5sZW5ndGggYS4oIWkpIGRvXG4gICAgICBpIDo9ICFpICsgMTtcbiAgICAgIGogOj0gMDtcbiAgICBkb25lO1xuICAgIGxldCB4ID0gYS4oIWkpLighaikgaW5cbiAgICBqIDo9ICFqICsgMTtcbiAgICB4XG4gICkgaW5cbiAgZGF0YSwgZW50cnlcblxubGV0IGxlbmd0aCAoKF8sIGVudHJ5KSA6ICdhIHQpIDogaW50ID1cbiAgQXJyYXkubGVuZ3RoIGVudHJ5XG5cbmxldCByb3dfbGVuZ3RoICgoXywgZW50cnkpIDogJ2EgdCkgaSA6IGludCA9XG4gIGVudHJ5LihpICsgMSkgLSBlbnRyeS4oaSlcblxubGV0IHJvd19sZW5ndGhfdmlhIGdldF9lbnRyeSBpID1cbiAgZ2V0X2VudHJ5IChpICsgMSkgLSBnZXRfZW50cnkgaVxuXG5sZXQgcmVhZCAoKGRhdGEsIGVudHJ5KSBhcyBsYSA6ICdhIHQpIGkgaiA6ICdhID1cbiAgYXNzZXJ0ICgwIDw9IGogJiYgaiA8IHJvd19sZW5ndGggbGEgaSk7XG4gIGRhdGEuKGVudHJ5LihpKSArIGopXG5cbmxldCByZWFkX3ZpYSBnZXRfZGF0YSBnZXRfZW50cnkgaSBqID1cbiAgYXNzZXJ0ICgwIDw9IGogJiYgaiA8IHJvd19sZW5ndGhfdmlhIGdldF9lbnRyeSBpKTtcbiAgZ2V0X2RhdGEgKGdldF9lbnRyeSBpICsgailcblxubGV0IHdyaXRlICgoZGF0YSwgZW50cnkpIGFzIGxhIDogJ2EgdCkgaSBqICh2IDogJ2EpIDogdW5pdCA9XG4gIGFzc2VydCAoMCA8PSBqICYmIGogPCByb3dfbGVuZ3RoIGxhIGkpO1xuICBkYXRhLihlbnRyeS4oaSkgKyBqKSA8LSB2XG5cbmxldCByZWMgcmVhZF9pbnRlcnZhbF92aWEgZ2V0X2RhdGEgaSBqID1cbiAgaWYgaSA9IGogdGhlblxuICAgIFtdXG4gIGVsc2VcbiAgICBnZXRfZGF0YSBpIDo6IHJlYWRfaW50ZXJ2YWxfdmlhIGdldF9kYXRhIChpICsgMSkgalxuXG5sZXQgcmVhZF9yb3dfdmlhIGdldF9kYXRhIGdldF9lbnRyeSBpID1cbiAgcmVhZF9pbnRlcnZhbF92aWEgZ2V0X2RhdGEgKGdldF9lbnRyeSBpKSAoZ2V0X2VudHJ5IChpICsgMSkpXG5cbmxldCByZWFkX3JvdyAoKGRhdGEsIGVudHJ5KSA6ICdhIHQpIGkgOiAnYSBsaXN0ID1cbiAgcmVhZF9yb3dfdmlhIChBcnJheS5nZXQgZGF0YSkgKEFycmF5LmdldCBlbnRyeSkgaVxuXG5lbmRcbm1vZHVsZSBUYWJsZUZvcm1hdCA9IHN0cnVjdFxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IElucmlhLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgICAgICopXG4oKiAgIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExpYnJhcnkgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIsIHdpdGggYSAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nLCBhcyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBUaGlzIHNpZ25hdHVyZSBkZWZpbmVzIHRoZSBmb3JtYXQgb2YgdGhlIHBhcnNlIHRhYmxlcy4gSXQgaXMgdXNlZCBhc1xuICAgYW4gYXJndW1lbnQgdG8gW1RhYmxlSW50ZXJwcmV0ZXIuTWFrZV0uICopXG5cbm1vZHVsZSB0eXBlIFRBQkxFUyA9IHNpZ1xuXG4gICgqIFRoaXMgaXMgdGhlIHBhcnNlcidzIHR5cGUgb2YgdG9rZW5zLiAqKVxuXG4gIHR5cGUgdG9rZW5cblxuICAoKiBUaGlzIG1hcHMgYSB0b2tlbiB0byBpdHMgaW50ZXJuYWwgKGdlbmVyYXRpb24tdGltZSkgaW50ZWdlciBjb2RlLiAqKVxuXG4gIHZhbCB0b2tlbjJ0ZXJtaW5hbDogdG9rZW4gLT4gaW50XG5cbiAgKCogVGhpcyBpcyB0aGUgaW50ZWdlciBjb2RlIGZvciB0aGUgZXJyb3IgcHNldWRvLXRva2VuLiAqKVxuXG4gIHZhbCBlcnJvcl90ZXJtaW5hbDogaW50XG5cbiAgKCogVGhpcyBtYXBzIGEgdG9rZW4gdG8gaXRzIHNlbWFudGljIHZhbHVlLiAqKVxuXG4gIHZhbCB0b2tlbjJ2YWx1ZTogdG9rZW4gLT4gT2JqLnRcblxuICAoKiBUcmFkaXRpb25hbGx5LCBhbiBMUiBhdXRvbWF0b24gaXMgZGVzY3JpYmVkIGJ5IHR3byB0YWJsZXMsIG5hbWVseSwgYW5cbiAgICAgYWN0aW9uIHRhYmxlIGFuZCBhIGdvdG8gdGFibGUuIFNlZSwgZm9yIGluc3RhbmNlLCB0aGUgRHJhZ29uIGJvb2suXG5cbiAgICAgVGhlIGFjdGlvbiB0YWJsZSBpcyBhIHR3by1kaW1lbnNpb25hbCBtYXRyaXggdGhhdCBtYXBzIGEgc3RhdGUgYW5kIGFcbiAgICAgbG9va2FoZWFkIHRva2VuIHRvIGFuIGFjdGlvbi4gQW4gYWN0aW9uIGlzIG9uZSBvZjogc2hpZnQgdG8gYSBjZXJ0YWluXG4gICAgIHN0YXRlLCByZWR1Y2UgYSBjZXJ0YWluIHByb2R1Y3Rpb24sIGFjY2VwdCwgb3IgZmFpbC5cblxuICAgICBUaGUgZ290byB0YWJsZSBpcyBhIHR3by1kaW1lbnNpb25hbCBtYXRyaXggdGhhdCBtYXBzIGEgc3RhdGUgYW5kIGFcbiAgICAgbm9uLXRlcm1pbmFsIHN5bWJvbCB0byBlaXRoZXIgYSBzdGF0ZSBvciB1bmRlZmluZWQuIEJ5IGNvbnN0cnVjdGlvbiwgdGhpc1xuICAgICB0YWJsZSBpcyBzcGFyc2U6IGl0cyB1bmRlZmluZWQgZW50cmllcyBhcmUgbmV2ZXIgbG9va2VkIHVwLiBBIGNvbXByZXNzaW9uXG4gICAgIHRlY2huaXF1ZSBpcyBmcmVlIHRvIG92ZXJsYXAgdGhlbSB3aXRoIG90aGVyIGVudHJpZXMuXG5cbiAgICAgSW4gTWVuaGlyLCB0aGluZ3MgYXJlIHNsaWdodGx5IGRpZmZlcmVudC4gSWYgYSBzdGF0ZSBoYXMgYSBkZWZhdWx0XG4gICAgIHJlZHVjdGlvbiBvbiB0b2tlbiBbI10sIHRoZW4gdGhhdCByZWR1Y3Rpb24gbXVzdCBiZSBwZXJmb3JtZWQgd2l0aG91dFxuICAgICBjb25zdWx0aW5nIHRoZSBsb29rYWhlYWQgdG9rZW4uIEFzIGEgcmVzdWx0LCB3ZSBtdXN0IGZpcnN0IGRldGVybWluZVxuICAgICB3aGV0aGVyIHRoYXQgaXMgdGhlIGNhc2UsIGJlZm9yZSB3ZSBjYW4gb2J0YWluIGEgbG9va2FoZWFkIHRva2VuIGFuZCB1c2UgaXRcbiAgICAgYXMgYW4gaW5kZXggaW4gdGhlIGFjdGlvbiB0YWJsZS5cblxuICAgICBUaHVzLCBNZW5oaXIncyB0YWJsZXMgYXJlIGFzIGZvbGxvd3MuXG5cbiAgICAgQSBvbmUtZGltZW5zaW9uYWwgZGVmYXVsdCByZWR1Y3Rpb24gdGFibGUgbWFwcyBhIHN0YXRlIHRvIGVpdGhlciBgYG5vXG4gICAgIGRlZmF1bHQgcmVkdWN0aW9uJycgKGVuY29kZWQgYXM6IDApIG9yIGBgYnkgZGVmYXVsdCwgcmVkdWNlIHByb2QnJ1xuICAgICAoZW5jb2RlZCBhczogMSArIHByb2QpLiBUaGUgYWN0aW9uIHRhYmxlIGlzIGxvb2tlZCB1cCBvbmx5IHdoZW4gdGhlcmVcbiAgICAgaXMgbm8gZGVmYXVsdCByZWR1Y3Rpb24uICopXG5cbiAgdmFsIGRlZmF1bHRfcmVkdWN0aW9uOiBQYWNrZWRJbnRBcnJheS50XG5cbiAgKCogTWVuaGlyIGZvbGxvd3MgRGVuY2tlciwgRMO8cnJlIGFuZCBIZXVmdCwgd2hvIHBvaW50IG91dCB0aGF0LCBhbHRob3VnaCB0aGVcbiAgICAgYWN0aW9uIHRhYmxlIGlzIG5vdCBzcGFyc2UgYnkgbmF0dXJlIChpLmUuLCB0aGUgZXJyb3IgZW50cmllcyBhcmVcbiAgICAgc2lnbmlmaWNhbnQpLCBpdCBjYW4gYmUgbWFkZSBzcGFyc2UgYnkgZmlyc3QgZmFjdG9yaW5nIG91dCBhIGJpbmFyeSBlcnJvclxuICAgICBtYXRyaXgsIHRoZW4gcmVwbGFjaW5nIHRoZSBlcnJvciBlbnRyaWVzIGluIHRoZSBhY3Rpb24gdGFibGUgd2l0aCB1bmRlZmluZWRcbiAgICAgZW50cmllcy4gVGh1czpcblxuICAgICBBIHR3by1kaW1lbnNpb25hbCBlcnJvciBiaXRtYXAgbWFwcyBhIHN0YXRlIGFuZCBhIHRlcm1pbmFsIHRvIGVpdGhlclxuICAgICBgYGZhaWwnJyAoZW5jb2RlZCBhczogMCkgb3IgYGBkbyBub3QgZmFpbCcnIChlbmNvZGVkIGFzOiAxKS4gVGhlIGFjdGlvblxuICAgICB0YWJsZSwgd2hpY2ggaXMgbm93IHNwYXJzZSwgaXMgbG9va2VkIHVwIG9ubHkgaW4gdGhlIGxhdHRlciBjYXNlLiAqKVxuXG4gICgqIFRoZSBlcnJvciBiaXRtYXAgaXMgZmxhdHRlbmVkIGludG8gYSBvbmUtZGltZW5zaW9uYWwgdGFibGU7IGl0cyB3aWR0aCBpc1xuICAgICByZWNvcmRlZCBzbyBhcyB0byBhbGxvdyBpbmRleGluZy4gVGhlIHRhYmxlIGlzIHRoZW4gY29tcHJlc3NlZCB2aWFcbiAgICAgW1BhY2tlZEludEFycmF5XS4gVGhlIGJpdCB3aWR0aCBvZiB0aGUgcmVzdWx0aW5nIHBhY2tlZCBhcnJheSBtdXN0IGJlXG4gICAgIFsxXSwgc28gaXQgaXMgbm90IGV4cGxpY2l0bHkgcmVjb3JkZWQuICopXG5cbiAgKCogVGhlIGVycm9yIGJpdG1hcCBkb2VzIG5vdCBjb250YWluIGEgY29sdW1uIGZvciB0aGUgWyNdIHBzZXVkby10ZXJtaW5hbC5cbiAgICAgVGh1cywgaXRzIHdpZHRoIGlzIFtUZXJtaW5hbC5uIC0gMV0uIFdlIGV4cGxvaXQgdGhlIGZhY3QgdGhhdCB0aGUgaW50ZWdlclxuICAgICBjb2RlIGFzc2lnbmVkIHRvIFsjXSBpcyBncmVhdGVzdDogdGhlIGZhY3QgdGhhdCB0aGUgcmlnaHQtbW9zdCBjb2x1bW5cbiAgICAgaW4gdGhlIGJpdG1hcCBpcyBtaXNzaW5nIGRvZXMgbm90IGFmZmVjdCB0aGUgY29kZSBmb3IgYWNjZXNzaW5nIGl0LiAqKVxuXG4gIHZhbCBlcnJvcjogaW50ICgqIHdpZHRoIG9mIHRoZSBiaXRtYXAgKikgKiBzdHJpbmcgKCogc2Vjb25kIGNvbXBvbmVudCBvZiBbUGFja2VkSW50QXJyYXkudF0gKilcblxuICAoKiBBIHR3by1kaW1lbnNpb25hbCBhY3Rpb24gdGFibGUgbWFwcyBhIHN0YXRlIGFuZCBhIHRlcm1pbmFsIHRvIG9uZSBvZlxuICAgICBgYHNoaWZ0IHRvIHN0YXRlIHMgYW5kIGRpc2NhcmQgdGhlIGN1cnJlbnQgdG9rZW4nJyAoZW5jb2RlZCBhczogcyB8IDEwKSxcbiAgICAgYGBzaGlmdCB0byBzdGF0ZSBzIHdpdGhvdXQgZGlzY2FyZGluZyB0aGUgY3VycmVudCB0b2tlbicnIChlbmNvZGVkIGFzOiBzIHxcbiAgICAgMTEpLCBvciBgYHJlZHVjZSBwcm9kJycgKGVuY29kZWQgYXM6IHByb2QgfCAwMSkuICopXG5cbiAgKCogVGhlIGFjdGlvbiB0YWJsZSBpcyBmaXJzdCBjb21wcmVzc2VkIHZpYSBbUm93RGlzcGxhY2VtZW50XSwgdGhlbiBwYWNrZWRcbiAgICAgdmlhIFtQYWNrZWRJbnRBcnJheV0uICopXG5cbiAgKCogTGlrZSB0aGUgZXJyb3IgYml0bWFwLCB0aGUgYWN0aW9uIHRhYmxlIGRvZXMgbm90IGNvbnRhaW4gYSBjb2x1bW4gZm9yIHRoZVxuICAgICBbI10gcHNldWRvLXRlcm1pbmFsLiAqKVxuXG4gIHZhbCBhY3Rpb246IFBhY2tlZEludEFycmF5LnQgKiBQYWNrZWRJbnRBcnJheS50XG5cbiAgKCogQSBvbmUtZGltZW5zaW9uYWwgbGhzIHRhYmxlIG1hcHMgYSBwcm9kdWN0aW9uIHRvIGl0cyBsZWZ0LWhhbmQgc2lkZSAoYVxuICAgICBub24tdGVybWluYWwgc3ltYm9sKS4gKilcblxuICB2YWwgbGhzOiBQYWNrZWRJbnRBcnJheS50XG5cbiAgKCogQSB0d28tZGltZW5zaW9uYWwgZ290byB0YWJsZSBtYXBzIGEgc3RhdGUgYW5kIGEgbm9uLXRlcm1pbmFsIHN5bWJvbCB0b1xuICAgICBlaXRoZXIgdW5kZWZpbmVkIChlbmNvZGVkIGFzOiAwKSBvciBhIG5ldyBzdGF0ZSBzIChlbmNvZGVkIGFzOiAxICsgcykuICopXG5cbiAgKCogVGhlIGdvdG8gdGFibGUgaXMgZmlyc3QgY29tcHJlc3NlZCB2aWEgW1Jvd0Rpc3BsYWNlbWVudF0sIHRoZW4gcGFja2VkXG4gICAgIHZpYSBbUGFja2VkSW50QXJyYXldLiAqKVxuXG4gIHZhbCBnb3RvOiBQYWNrZWRJbnRBcnJheS50ICogUGFja2VkSW50QXJyYXkudFxuXG4gICgqIFRoZSBudW1iZXIgb2Ygc3RhcnQgcHJvZHVjdGlvbnMuIEEgcHJvZHVjdGlvbiBbcHJvZF0gaXMgYSBzdGFydFxuICAgICBwcm9kdWN0aW9uIGlmIGFuZCBvbmx5IGlmIFtwcm9kIDwgc3RhcnRdIGhvbGRzLiBUaGlzIGlzIGFsc28gdGhlXG4gICAgIG51bWJlciBvZiBzdGFydCBzeW1ib2xzLiBBIG5vbnRlcm1pbmFsIHN5bWJvbCBbbnRdIGlzIGEgc3RhcnRcbiAgICAgc3ltYm9sIGlmIGFuZCBvbmx5IGlmIFtudCA8IHN0YXJ0XSBob2xkcy4gKilcblxuICB2YWwgc3RhcnQ6IGludFxuXG4gICgqIEEgb25lLWRpbWVuc2lvbmFsIHNlbWFudGljIGFjdGlvbiB0YWJsZSBtYXBzIHByb2R1Y3Rpb25zIHRvIHNlbWFudGljXG4gICAgIGFjdGlvbnMuIFRoZSBjYWxsaW5nIGNvbnZlbnRpb24gZm9yIHNlbWFudGljIGFjdGlvbnMgaXMgZGVzY3JpYmVkIGluXG4gICAgIFtFbmdpbmVUeXBlc10uIFRoaXMgdGFibGUgY29udGFpbnMgT05MWSBOT04tU1RBUlQgUFJPRFVDVElPTlMsIHNvIHRoZVxuICAgICBpbmRleGluZyBpcyBvZmYgYnkgW3N0YXJ0XS4gQmUgY2FyZWZ1bC4gKilcblxuICB2YWwgc2VtYW50aWNfYWN0aW9uOiAoKGludCwgT2JqLnQsIHRva2VuKSBFbmdpbmVUeXBlcy5lbnYgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIChpbnQsIE9iai50KSAgICAgICAgRW5naW5lVHlwZXMuc3RhY2spIGFycmF5XG5cbiAgKCogVGhlIHBhcnNlciBkZWZpbmVzIGl0cyBvd24gW0Vycm9yXSBleGNlcHRpb24uIFRoaXMgZXhjZXB0aW9uIGNhbiBiZVxuICAgICByYWlzZWQgYnkgc2VtYW50aWMgYWN0aW9ucyBhbmQgY2F1Z2h0IGJ5IHRoZSBlbmdpbmUsIGFuZCByYWlzZWQgYnkgdGhlXG4gICAgIGVuZ2luZSB0b3dhcmRzIHRoZSBmaW5hbCB1c2VyLiAqKVxuXG4gIGV4Y2VwdGlvbiBFcnJvclxuXG4gICgqIFRoZSBwYXJzZXIgaW5kaWNhdGVzIHdoZXRoZXIgdG8gZ2VuZXJhdGUgYSB0cmFjZS4gR2VuZXJhdGluZyBhXG4gICAgIHRyYWNlIHJlcXVpcmVzIHR3byBleHRyYSB0YWJsZXMsIHdoaWNoIHJlc3BlY3RpdmVseSBtYXAgYVxuICAgICB0ZXJtaW5hbCBzeW1ib2wgYW5kIGEgcHJvZHVjdGlvbiB0byBhIHN0cmluZy4gKilcblxuICB2YWwgdHJhY2U6IChzdHJpbmcgYXJyYXkgKiBzdHJpbmcgYXJyYXkpIG9wdGlvblxuXG5lbmRcbmVuZFxubW9kdWxlIEluc3BlY3Rpb25UYWJsZUZvcm1hdCA9IHN0cnVjdFxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IElucmlhLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgICAgICopXG4oKiAgIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExpYnJhcnkgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIsIHdpdGggYSAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nLCBhcyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBUaGlzIHNpZ25hdHVyZSBkZWZpbmVzIHRoZSBmb3JtYXQgb2YgdGhlIHRhYmxlcyB0aGF0IGFyZSBwcm9kdWNlZCAoaW5cbiAgIGFkZGl0aW9uIHRvIHRoZSB0YWJsZXMgZGVzY3JpYmVkIGluIFtUYWJsZUZvcm1hdF0pIHdoZW4gdGhlIGNvbW1hbmQgbGluZVxuICAgc3dpdGNoIFstLWluc3BlY3Rpb25dIGlzIGVuYWJsZWQuIEl0IGlzIHVzZWQgYXMgYW4gYXJndW1lbnQgdG9cbiAgIFtJbnNwZWN0aW9uVGFibGVJbnRlcnByZXRlci5NYWtlXS4gKilcblxubW9kdWxlIHR5cGUgVEFCTEVTID0gc2lnXG5cbiAgKCogVGhlIHR5cGVzIG9mIHN5bWJvbHMuICopXG5cbiAgaW5jbHVkZSBJbmNyZW1lbnRhbEVuZ2luZS5TWU1CT0xTXG5cbiAgKCogVGhlIHR5cGUgWydhIGxyMXN0YXRlXSBkZXNjcmliZXMgYW4gTFIoMSkgc3RhdGUuIFRoZSBnZW5lcmF0ZWQgcGFyc2VyIGRlZmluZXNcbiAgICAgaXQgaW50ZXJuYWxseSBhcyBbaW50XS4gKilcblxuICB0eXBlICdhIGxyMXN0YXRlXG5cbiAgKCogU29tZSBvZiB0aGUgdGFibGVzIHRoYXQgZm9sbG93IHVzZSBlbmNvZGluZ3Mgb2YgKHRlcm1pbmFsIGFuZFxuICAgICBub250ZXJtaW5hbCkgc3ltYm9scyBhcyBpbnRlZ2Vycy4gU28sIHdlIG5lZWQgZnVuY3Rpb25zIHRoYXRcbiAgICAgbWFwIHRoZSBpbnRlZ2VyIGVuY29kaW5nIG9mIGEgc3ltYm9sIHRvIGl0cyBhbGdlYnJhaWMgZW5jb2RpbmcuICopXG5cbiAgdmFsICAgIHRlcm1pbmFsOiBpbnQgLT4geHN5bWJvbFxuICB2YWwgbm9udGVybWluYWw6IGludCAtPiB4c3ltYm9sXG5cbiAgKCogVGhlIGxlZnQtaGFuZCBzaWRlIG9mIGV2ZXJ5IHByb2R1Y3Rpb24gYWxyZWFkeSBhcHBlYXJzIGluIHRoZVxuICAgICBzaWduYXR1cmUgW1RhYmxlRm9ybWF0LlRBQkxFU10sIHNvIHdlIG5lZWQgbm90IHJlcGVhdCBpdCBoZXJlLiAqKVxuXG4gICgqIFRoZSByaWdodC1oYW5kIHNpZGUgb2YgZXZlcnkgcHJvZHVjdGlvbi4gVGhpcyBhIGxpbmVhcml6ZWQgYXJyYXlcbiAgICAgb2YgYXJyYXlzIG9mIGludGVnZXJzLCB3aG9zZSBbZGF0YV0gYW5kIFtlbnRyeV0gY29tcG9uZW50cyBoYXZlXG4gICAgIGJlZW4gcGFja2VkLiBUaGUgZW5jb2Rpbmcgb2Ygc3ltYm9scyBhcyBpbnRlZ2VycyBpbiBkZXNjcmliZWQgaW5cbiAgICAgW1RhYmxlQmFja2VuZF0uICopXG5cbiAgdmFsIHJoczogUGFja2VkSW50QXJyYXkudCAqIFBhY2tlZEludEFycmF5LnRcblxuICAoKiBBIG1hcHBpbmcgb2YgZXZlcnkgKG5vbi1pbml0aWFsKSBzdGF0ZSB0byBpdHMgTFIoMCkgY29yZS4gKilcblxuICB2YWwgbHIwX2NvcmU6IFBhY2tlZEludEFycmF5LnRcblxuICAoKiBBIG1hcHBpbmcgb2YgZXZlcnkgTFIoMCkgc3RhdGUgdG8gaXRzIHNldCBvZiBMUigwKSBpdGVtcy4gRWFjaCBpdGVtIGlzXG4gICAgIHJlcHJlc2VudGVkIGluIGl0cyBwYWNrZWQgZm9ybSAoc2VlIFtJdGVtXSkgYXMgYW4gaW50ZWdlci4gVGh1cyB0aGVcbiAgICAgbWFwcGluZyBpcyBhbiBhcnJheSBvZiBhcnJheXMgb2YgaW50ZWdlcnMsIHdoaWNoIGlzIGxpbmVhcml6ZWQgYW5kXG4gICAgIHBhY2tlZCwgbGlrZSBbcmhzXS4gKilcblxuICB2YWwgbHIwX2l0ZW1zOiBQYWNrZWRJbnRBcnJheS50ICogUGFja2VkSW50QXJyYXkudFxuXG4gICgqIEEgbWFwcGluZyBvZiBldmVyeSBMUigwKSBzdGF0ZSB0byBpdHMgaW5jb21pbmcgc3ltYm9sLCBpZiBpdCBoYXMgb25lLiAqKVxuXG4gIHZhbCBscjBfaW5jb21pbmc6IFBhY2tlZEludEFycmF5LnRcblxuICAoKiBBIHRhYmxlIHRoYXQgdGVsbHMgd2hpY2ggbm9uLXRlcm1pbmFsIHN5bWJvbHMgYXJlIG51bGxhYmxlLiAqKVxuXG4gIHZhbCBudWxsYWJsZTogc3RyaW5nXG4gICAgKCogVGhpcyBpcyBhIHBhY2tlZCBpbnQgYXJyYXkgb2YgYml0IHdpZHRoIDEuIEl0IGNhbiBiZSByZWFkXG4gICAgICAgdXNpbmcgW1BhY2tlZEludEFycmF5LmdldDFdLiAqKVxuXG4gICgqIEEgdHdvLXRhYmxlIGRpbWVuc2lvbmFsIHRhYmxlLCBpbmRleGVkIGJ5IGEgbm9udGVybWluYWwgc3ltYm9sIGFuZFxuICAgICBieSBhIHRlcm1pbmFsIHN5bWJvbCAob3RoZXIgdGhhbiBbI10pLCBlbmNvZGVzIHRoZSBGSVJTVCBzZXRzLiAqKVxuXG4gIHZhbCBmaXJzdDogaW50ICgqIHdpZHRoIG9mIHRoZSBiaXRtYXAgKikgKiBzdHJpbmcgKCogc2Vjb25kIGNvbXBvbmVudCBvZiBbUGFja2VkSW50QXJyYXkudF0gKilcblxuZW5kXG5cbmVuZFxubW9kdWxlIEluc3BlY3Rpb25UYWJsZUludGVycHJldGVyID0gc3RydWN0XG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgSW5yaWEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciAgICAgKilcbigqICAgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGlicmFyeSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMiwgd2l0aCBhICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcsIGFzIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbigqIFRoZSB0eXBlIGZ1bmN0b3IuICopXG5cbm1vZHVsZSBTeW1ib2xzIChUIDogc2lnXG5cbiAgdHlwZSAnYSB0ZXJtaW5hbFxuICB0eXBlICdhIG5vbnRlcm1pbmFsXG5cbmVuZCkgPSBzdHJ1Y3RcblxuICBvcGVuIFRcblxuICAoKiBUaGlzIHNob3VsZCBiZSB0aGUgb25seSBwbGFjZSBpbiB0aGUgd2hvbGUgbGlicmFyeSAoYW5kIGdlbmVyYXRvciEpXG4gICAgIHdoZXJlIHRoZXNlIHR5cGVzIGFyZSBkZWZpbmVkLiAqKVxuXG4gIHR5cGUgJ2Egc3ltYm9sID1cbiAgICB8IFQgOiAnYSB0ZXJtaW5hbCAtPiAnYSBzeW1ib2xcbiAgICB8IE4gOiAnYSBub250ZXJtaW5hbCAtPiAnYSBzeW1ib2xcblxuICB0eXBlIHhzeW1ib2wgPVxuICAgIHwgWCA6ICdhIHN5bWJvbCAtPiB4c3ltYm9sXG5cbmVuZFxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4oKiBUaGUgY29kZSBmdW5jdG9yLiAqKVxuXG5tb2R1bGUgTWFrZVxuICAoVFQgOiBUYWJsZUZvcm1hdC5UQUJMRVMpXG4gIChJVCA6IEluc3BlY3Rpb25UYWJsZUZvcm1hdC5UQUJMRVNcbiAgICAgICAgd2l0aCB0eXBlICdhIGxyMXN0YXRlID0gaW50KVxuICAoRVQgOiBFbmdpbmVUeXBlcy5UQUJMRVxuICAgICAgICB3aXRoIHR5cGUgdGVybWluYWwgPSBpbnRcbiAgICAgICAgIGFuZCB0eXBlIG5vbnRlcm1pbmFsID0gaW50XG4gICAgICAgICBhbmQgdHlwZSBzZW1hbnRpY192YWx1ZSA9IE9iai50KVxuICAoRSA6IHNpZ1xuICAgICB0eXBlICdhIGVudiA9IChFVC5zdGF0ZSwgRVQuc2VtYW50aWNfdmFsdWUsIEVULnRva2VuKSBFbmdpbmVUeXBlcy5lbnZcbiAgIGVuZClcbj0gc3RydWN0XG5cbiAgKCogSW5jbHVkaW5nIFtJVF0gaXMgYW4gZWFzeSB3YXkgb2YgaW5oZXJpdGluZyB0aGUgZGVmaW5pdGlvbnMgb2YgdGhlIHR5cGVzXG4gICAgIFtzeW1ib2xdIGFuZCBbeHN5bWJvbF0uICopXG5cbiAgaW5jbHVkZSBJVFxuXG4gICgqIFRoaXMgYXV4aWxpYXJ5IGZ1bmN0aW9uIGRlY29kZXMgYSBwYWNrZWQgbGluZWFyaXplZCBhcnJheSwgYXMgY3JlYXRlZCBieVxuICAgICBbVGFibGVCYWNrZW5kLmxpbmVhcml6ZV9hbmRfbWFyc2hhbDFdLiBIZXJlLCB3ZSByZWFkIGEgcm93IGFsbCBhdCBvbmNlLiAqKVxuXG4gIGxldCByZWFkX3BhY2tlZF9saW5lYXJpemVkXG4gICAgKGRhdGEsIGVudHJ5IDogUGFja2VkSW50QXJyYXkudCAqIFBhY2tlZEludEFycmF5LnQpIChpIDogaW50KSA6IGludCBsaXN0XG4gID1cbiAgICBMaW5lYXJpemVkQXJyYXkucmVhZF9yb3dfdmlhXG4gICAgICAoUGFja2VkSW50QXJyYXkuZ2V0IGRhdGEpXG4gICAgICAoUGFja2VkSW50QXJyYXkuZ2V0IGVudHJ5KVxuICAgICAgaVxuXG4gICgqIFRoaXMgYXV4aWxpYXJ5IGZ1bmN0aW9uIGRlY29kZXMgYSBzeW1ib2wuIFRoZSBlbmNvZGluZyB3YXMgZG9uZSBieVxuICAgICBbZW5jb2RlX3N5bWJvbF0gb3IgW2VuY29kZV9zeW1ib2xfb3B0aW9uXSBpbiB0aGUgdGFibGUgYmFjay1lbmQuICopXG5cbiAgbGV0IGRlY29kZV9zeW1ib2wgKHN5bWJvbCA6IGludCkgOiBJVC54c3ltYm9sID1cbiAgICAoKiBJZiBbc3ltYm9sXSBpcyAwLCB0aGVuIHdlIGhhdmUgbm8gc3ltYm9sLiBUaGlzIGNvdWxkIG1lYW4gZS5nLlxuICAgICAgIHRoYXQgdGhlIGZ1bmN0aW9uIFtpbmNvbWluZ19zeW1ib2xdIGhhcyBiZWVuIGFwcGxpZWQgdG8gYW5cbiAgICAgICBpbml0aWFsIHN0YXRlLiBJbiBwcmluY2lwbGUsIHRoaXMgY2Fubm90IGhhcHBlbi4gKilcbiAgICBhc3NlcnQgKHN5bWJvbCA+IDApO1xuICAgICgqIFRoZSBsb3ctb3JkZXIgYml0IGRpc3Rpbmd1aXNoZXMgdGVybWluYWwgYW5kIG5vbnRlcm1pbmFsIHN5bWJvbHMuICopXG4gICAgbGV0IGtpbmQgPSBzeW1ib2wgbGFuZCAxIGluXG4gICAgbGV0IHN5bWJvbCA9IHN5bWJvbCBsc3IgMSBpblxuICAgIGlmIGtpbmQgPSAwIHRoZW5cbiAgICAgIElULnRlcm1pbmFsIChzeW1ib2wgLSAxKVxuICAgIGVsc2VcbiAgICAgIElULm5vbnRlcm1pbmFsIHN5bWJvbFxuXG4gICgqIFRoZXNlIGF1eGlsaWFyeSBmdW5jdGlvbnMgY29udmVydCBhIHN5bWJvbCB0byBpdHMgaW50ZWdlciBjb2RlLiBGb3Igc3BlZWRcbiAgICAgYW5kIGZvciBjb252ZW5pZW5jZSwgd2UgdXNlIGFuIHVuc2FmZSB0eXBlIGNhc3QuIFRoaXMgcmVsaWVzIG9uIHRoZSBmYWN0XG4gICAgIHRoYXQgdGhlIGRhdGEgY29uc3RydWN0b3JzIG9mIHRoZSBbdGVybWluYWxdIGFuZCBbbm9udGVybWluYWxdIEdBRFRzIGFyZVxuICAgICBkZWNsYXJlZCBpbiBhbiBvcmRlciB0aGF0IHJlZmxlY3RzIHRoZWlyIGludGVybmFsIGNvZGUuIEluIHRoZSBjYXNlIG9mXG4gICAgIG5vbnRlcm1pbmFsIHN5bWJvbHMsIHdlIGFkZCBbc3RhcnRdIHRvIGFjY291bnQgZm9yIHRoZSBwcmVzZW5jZSBvZiB0aGVcbiAgICAgc3RhcnQgc3ltYm9scy4gKilcblxuICBsZXQgbjJpIChudCA6ICdhIElULm5vbnRlcm1pbmFsKSA6IGludCA9XG4gICAgbGV0IGFuc3dlciA9IFRULnN0YXJ0ICsgT2JqLm1hZ2ljIG50IGluXG4gICAgKCogRm9yIHNhZmV0eSwgY2hlY2sgdGhhdCB0aGUgYWJvdmUgY2FzdCBwcm9kdWNlZCBhIGNvcnJlY3QgcmVzdWx0LiAqKVxuICAgIGFzc2VydCAoSVQubm9udGVybWluYWwgYW5zd2VyID0gWCAoTiBudCkpO1xuICAgIGFuc3dlclxuXG4gIGxldCB0MmkgKHQgOiAnYSBJVC50ZXJtaW5hbCkgOiBpbnQgPVxuICAgIGxldCBhbnN3ZXIgPSBPYmoubWFnaWMgdCBpblxuICAgICgqIEZvciBzYWZldHksIGNoZWNrIHRoYXQgdGhlIGFib3ZlIGNhc3QgcHJvZHVjZWQgYSBjb3JyZWN0IHJlc3VsdC4gKilcbiAgICBhc3NlcnQgKElULnRlcm1pbmFsIGFuc3dlciA9IFggKFQgdCkpO1xuICAgIGFuc3dlclxuXG4gICgqIE9yZGVyaW5nIGZ1bmN0aW9ucy4gKilcblxuICBsZXQgY29tcGFyZV90ZXJtaW5hbHMgdDEgdDIgPVxuICAgICgqIFN1YnRyYWN0aW9uIGlzIHNhZmUgYmVjYXVzZSBvdmVyZmxvdyBpcyBpbXBvc3NpYmxlLiAqKVxuICAgIHQyaSB0MSAtIHQyaSB0MlxuXG4gIGxldCBjb21wYXJlX25vbnRlcm1pbmFscyBudDEgbnQyID1cbiAgICAoKiBTdWJ0cmFjdGlvbiBpcyBzYWZlIGJlY2F1c2Ugb3ZlcmZsb3cgaXMgaW1wb3NzaWJsZS4gKilcbiAgICBuMmkgbnQxIC0gbjJpIG50MlxuXG4gIGxldCBjb21wYXJlX3N5bWJvbHMgc3ltYm9sMSBzeW1ib2wyID1cbiAgICBtYXRjaCBzeW1ib2wxLCBzeW1ib2wyIHdpdGhcbiAgICB8IFggKFQgXyksIFggKE4gXykgLT5cbiAgICAgICAgLTFcbiAgICB8IFggKE4gXyksIFggKFQgXykgLT5cbiAgICAgICAgMVxuICAgIHwgWCAoVCB0MSksIFggKFQgdDIpIC0+XG4gICAgICAgIGNvbXBhcmVfdGVybWluYWxzIHQxIHQyXG4gICAgfCBYIChOIG50MSksIFggKE4gbnQyKSAtPlxuICAgICAgICBjb21wYXJlX25vbnRlcm1pbmFscyBudDEgbnQyXG5cbiAgbGV0IGNvbXBhcmVfcHJvZHVjdGlvbnMgcHJvZDEgcHJvZDIgPVxuICAgICgqIFN1YnRyYWN0aW9uIGlzIHNhZmUgYmVjYXVzZSBvdmVyZmxvdyBpcyBpbXBvc3NpYmxlLiAqKVxuICAgIHByb2QxIC0gcHJvZDJcblxuICBsZXQgY29tcGFyZV9pdGVtcyAocHJvZDEsIGluZGV4MSkgKHByb2QyLCBpbmRleDIpID1cbiAgICBsZXQgYyA9IGNvbXBhcmVfcHJvZHVjdGlvbnMgcHJvZDEgcHJvZDIgaW5cbiAgICAoKiBTdWJ0cmFjdGlvbiBpcyBzYWZlIGJlY2F1c2Ugb3ZlcmZsb3cgaXMgaW1wb3NzaWJsZS4gKilcbiAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2UgaW5kZXgxIC0gaW5kZXgyXG5cbiAgKCogVGhlIGZ1bmN0aW9uIFtpbmNvbWluZ19zeW1ib2xdIGdvZXMgdGhyb3VnaCB0aGUgdGFibGVzIFtJVC5scjBfY29yZV0gYW5kXG4gICAgIFtJVC5scjBfaW5jb21pbmddLiBUaGlzIHlpZWxkcyBhIHJlcHJlc2VudGF0aW9uIG9mIHR5cGUgW3hzeW1ib2xdLCBvdXQgb2ZcbiAgICAgd2hpY2ggd2Ugc3RyaXAgdGhlIFtYXSBxdWFudGlmaWVyLCBzbyBhcyB0byBnZXQgYSBuYWtlZCBzeW1ib2wuIFRoaXMgbGFzdFxuICAgICBzdGVwIGlzIGlsbC10eXBlZCBhbmQgcG90ZW50aWFsbHkgZGFuZ2Vyb3VzLiBJdCBpcyBzYWZlIG9ubHkgYmVjYXVzZSB0aGlzXG4gICAgIGZ1bmN0aW9uIGlzIHVzZWQgYXQgdHlwZSBbJ2EgbHIxc3RhdGUgLT4gJ2Egc3ltYm9sXSwgd2hpY2ggZm9yY2VzIGFuXG4gICAgIGFwcHJvcHJpYXRlIGNob2ljZSBvZiBbJ2FdLiAqKVxuXG4gIGxldCBpbmNvbWluZ19zeW1ib2wgKHMgOiAnYSBJVC5scjFzdGF0ZSkgOiAnYSBJVC5zeW1ib2wgPVxuICAgIGxldCBjb3JlID0gUGFja2VkSW50QXJyYXkuZ2V0IElULmxyMF9jb3JlIHMgaW5cbiAgICBsZXQgc3ltYm9sID0gZGVjb2RlX3N5bWJvbCAoUGFja2VkSW50QXJyYXkuZ2V0IElULmxyMF9pbmNvbWluZyBjb3JlKSBpblxuICAgIG1hdGNoIHN5bWJvbCB3aXRoXG4gICAgfCBJVC5YIHN5bWJvbCAtPlxuICAgICAgICBPYmoubWFnaWMgc3ltYm9sXG5cbiAgKCogVGhlIGZ1bmN0aW9uIFtsaHNdIHJlYWRzIHRoZSB0YWJsZSBbVFQubGhzXSBhbmQgdXNlcyBbSVQubm9udGVybWluYWxdXG4gICAgIHRvIGRlY29kZSB0aGUgc3ltYm9sLiAqKVxuXG4gIGxldCBsaHMgcHJvZCA9XG4gICAgSVQubm9udGVybWluYWwgKFBhY2tlZEludEFycmF5LmdldCBUVC5saHMgcHJvZClcblxuICAoKiBUaGUgZnVuY3Rpb24gW3Joc10gcmVhZHMgdGhlIHRhYmxlIFtJVC5yaHNdIGFuZCB1c2VzIFtkZWNvZGVfc3ltYm9sXVxuICAgICB0byBkZWNvZGUgdGhlIHN5bWJvbC4gKilcblxuICBsZXQgcmhzIHByb2QgPVxuICAgIExpc3QubWFwIGRlY29kZV9zeW1ib2wgKHJlYWRfcGFja2VkX2xpbmVhcml6ZWQgSVQucmhzIHByb2QpXG5cbiAgKCogVGhlIGZ1bmN0aW9uIFtpdGVtc10gbWFwcyB0aGUgTFIoMSkgc3RhdGUgW3NdIHRvIGl0cyBMUigwKSBjb3JlLFxuICAgICB0aGVuIHVzZXMgW2NvcmVdIGFzIGFuIGluZGV4IGludG8gdGhlIHRhYmxlIFtJVC5scjBfaXRlbXNdLiBUaGVcbiAgICAgaXRlbXMgYXJlIHRoZW4gZGVjb2RlZCBieSB0aGUgZnVuY3Rpb24gW2V4cG9ydF0gYmVsb3csIHdoaWNoIGlzXG4gICAgIGVzc2VudGlhbGx5IGEgY29weSBvZiBbSXRlbS5leHBvcnRdLiAqKVxuXG4gIHR5cGUgaXRlbSA9XG4gICAgICBpbnQgKiBpbnRcblxuICBsZXQgbG93X2JpdHMgPVxuICAgIDEwXG5cbiAgbGV0IGxvd19saW1pdCA9XG4gICAgMSBsc2wgbG93X2JpdHNcblxuICBsZXQgZXhwb3J0IHQgOiBpdGVtID1cbiAgICAodCBsc3IgbG93X2JpdHMsIHQgbW9kIGxvd19saW1pdClcblxuICBsZXQgaXRlbXMgcyA9XG4gICAgKCogTWFwIFtzXSB0byBpdHMgTFIoMCkgY29yZS4gKilcbiAgICBsZXQgY29yZSA9IFBhY2tlZEludEFycmF5LmdldCBJVC5scjBfY29yZSBzIGluXG4gICAgKCogTm93IHVzZSBbY29yZV0gdG8gbG9vayB1cCB0aGUgdGFibGUgW0lULmxyMF9pdGVtc10uICopXG4gICAgTGlzdC5tYXAgZXhwb3J0IChyZWFkX3BhY2tlZF9saW5lYXJpemVkIElULmxyMF9pdGVtcyBjb3JlKVxuXG4gICgqIFRoZSBmdW5jdGlvbiBbbnVsbGFibGVdIG1hcHMgdGhlIG5vbnRlcm1pbmFsIHN5bWJvbCBbbnRdIHRvIGl0c1xuICAgICBpbnRlZ2VyIGNvZGUsIHdoaWNoIGl0IHVzZXMgdG8gbG9vayB1cCB0aGUgYXJyYXkgW0lULm51bGxhYmxlXS5cbiAgICAgVGhpcyB5aWVsZHMgMCBvciAxLCB3aGljaCB3ZSBtYXAgYmFjayB0byBhIEJvb2xlYW4gcmVzdWx0LiAqKVxuXG4gIGxldCBkZWNvZGVfYm9vbCBpID1cbiAgICBhc3NlcnQgKGkgPSAwIHx8IGkgPSAxKTtcbiAgICBpID0gMVxuXG4gIGxldCBudWxsYWJsZSBudCA9XG4gICAgZGVjb2RlX2Jvb2wgKFBhY2tlZEludEFycmF5LmdldDEgSVQubnVsbGFibGUgKG4yaSBudCkpXG5cbiAgKCogVGhlIGZ1bmN0aW9uIFtmaXJzdF0gbWFwcyB0aGUgc3ltYm9scyBbbnRdIGFuZCBbdF0gdG8gdGhlaXIgaW50ZWdlclxuICAgICBjb2Rlcywgd2hpY2ggaXQgdXNlcyB0byBsb29rIHVwIHRoZSBtYXRyaXggW0lULmZpcnN0XS4gKilcblxuICBsZXQgZmlyc3QgbnQgdCA9XG4gICAgZGVjb2RlX2Jvb2wgKFBhY2tlZEludEFycmF5LnVuZmxhdHRlbjEgSVQuZmlyc3QgKG4yaSBudCkgKHQyaSB0KSlcblxuICBsZXQgeGZpcnN0IHN5bWJvbCB0ID1cbiAgICBtYXRjaCBzeW1ib2wgd2l0aFxuICAgIHwgWCAoVCB0JykgLT5cbiAgICAgICAgY29tcGFyZV90ZXJtaW5hbHMgdCB0JyA9IDBcbiAgICB8IFggKE4gbnQpIC0+XG4gICAgICAgIGZpcnN0IG50IHRcblxuICAoKiBUaGUgZnVuY3Rpb24gW2ZvcmVhY2hfdGVybWluYWxdIGV4cGxvaXRzIHRoZSBmYWN0IHRoYXQgdGhlXG4gICAgIGZpcnN0IGNvbXBvbmVudCBvZiBbVFQuZXJyb3JdIGlzIFtUZXJtaW5hbC5uIC0gMV0sIGkuZS4sIHRoZVxuICAgICBudW1iZXIgb2YgdGVybWluYWwgc3ltYm9scywgaW5jbHVkaW5nIFtlcnJvcl0gYnV0IG5vdCBbI10uICopXG5cbiAgbGV0IHJlYyBmb2xkaWogaSBqIGYgYWNjdSA9XG4gICAgaWYgaSA9IGogdGhlblxuICAgICAgYWNjdVxuICAgIGVsc2VcbiAgICAgIGZvbGRpaiAoaSArIDEpIGogZiAoZiBpIGFjY3UpXG5cbiAgbGV0IGZvcmVhY2hfdGVybWluYWwgZiBhY2N1ID1cbiAgICBsZXQgbiwgXyA9IFRULmVycm9yIGluXG4gICAgZm9sZGlqIDAgbiAoZnVuIGkgYWNjdSAtPlxuICAgICAgZiAoSVQudGVybWluYWwgaSkgYWNjdVxuICAgICkgYWNjdVxuXG4gIGxldCBmb3JlYWNoX3Rlcm1pbmFsX2J1dF9lcnJvciBmIGFjY3UgPVxuICAgIGxldCBuLCBfID0gVFQuZXJyb3IgaW5cbiAgICBmb2xkaWogMCBuIChmdW4gaSBhY2N1IC0+XG4gICAgICBpZiBpID0gVFQuZXJyb3JfdGVybWluYWwgdGhlblxuICAgICAgICBhY2N1XG4gICAgICBlbHNlXG4gICAgICAgIGYgKElULnRlcm1pbmFsIGkpIGFjY3VcbiAgICApIGFjY3VcblxuICAoKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuICAoKiBUaGUgZm9sbG93aW5nIGlzIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgZnVuY3Rpb24gW2ZlZWRdLiBUaGlzIGZ1bmN0aW9uXG4gICAgIGlzIGxvZ2ljYWxseSBwYXJ0IG9mIHRoZSBMUiBlbmdpbmUsIHNvIGl0IHdvdWxkIGJlIG5pY2UgaWYgaXQgd2VyZSBwbGFjZWRcbiAgICAgaW4gdGhlIG1vZHVsZSBbRW5naW5lXSwgYnV0IGl0IG11c3QgYmUgcGxhY2VkIGhlcmUgYmVjYXVzZSwgdG8gZW5zdXJlXG4gICAgIHR5cGUgc2FmZXR5LCBpdHMgYXJndW1lbnRzIG11c3QgYmUgYSBzeW1ib2wgb2YgdHlwZSBbJ2Egc3ltYm9sXSBhbmQgYVxuICAgICBzZW1hbnRpYyB2YWx1ZSBvZiB0eXBlIFsnYV0uIFRoZSB0eXBlIFsnYSBzeW1ib2xdIGlzIG5vdCBhdmFpbGFibGUgaW5cbiAgICAgW0VuZ2luZV0uIEl0IGlzIGF2YWlsYWJsZSBoZXJlLiAqKVxuXG4gIG9wZW4gRW5naW5lVHlwZXNcbiAgb3BlbiBFVFxuICBvcGVuIEVcblxuICAoKiBbZmVlZF0gZmFpbHMgaWYgdGhlIGN1cnJlbnQgc3RhdGUgZG9lcyBub3QgaGF2ZSBhbiBvdXRnb2luZyB0cmFuc2l0aW9uXG4gICAgIGxhYmVsZWQgd2l0aCB0aGUgZGVzaXJlZCBzeW1ib2wuIFRoaXMgY2hlY2sgaXMgY2FycmllZCBvdXQgYXQgcnVudGltZS4gKilcblxuICBsZXQgZmVlZF9mYWlsdXJlICgpID1cbiAgICBpbnZhbGlkX2FyZyBcImZlZWQ6IG91dGdvaW5nIHRyYW5zaXRpb24gZG9lcyBub3QgZXhpc3RcIlxuXG4gICgqIEZlZWRpbmcgYSBub250ZXJtaW5hbCBzeW1ib2wgW250XS4gSGVyZSwgW250XSBoYXMgdHlwZSBbbm9udGVybWluYWxdLFxuICAgICB3aGljaCBpcyBhIHN5bm9ueW0gZm9yIFtpbnRdLCBhbmQgW3NlbXZdIGhhcyB0eXBlIFtzZW1hbnRpY192YWx1ZV0sXG4gICAgIHdoaWNoIGlzIGEgc3lub255bSBmb3IgW09iai50XS4gVGhpcyB0eXBlIGlzIHVuc2FmZSwgYmVjYXVzZSBwdXNoaW5nXG4gICAgIGEgc2VtYW50aWMgdmFsdWUgb2YgYXJiaXRyYXJ5IHR5cGUgaW50byB0aGUgc3RhY2sgY2FuIGxhdGVyIGNhdXNlIGFcbiAgICAgc2VtYW50aWMgYWN0aW9uIHRvIGNyYXNoIGFuZCBidXJuLiBUaGUgZnVuY3Rpb24gW2ZlZWRdIGlzIGdpdmVuIGEgc2FmZVxuICAgICB0eXBlIGJlbG93LiAqKVxuXG4gIGxldCBmZWVkX25vbnRlcm1pbmFsXG4gICAgICAgIChudCA6IG5vbnRlcm1pbmFsKSBzdGFydHAgKHNlbXYgOiBzZW1hbnRpY192YWx1ZSkgZW5kcCAoZW52IDogJ2IgZW52KVxuICAgICAgOiAnYiBlbnZcbiAgPVxuICAgICgqIENoZWNrIGlmIHRoZSBzb3VyY2Ugc3RhdGUgaGFzIGFuIG91dGdvaW5nIHRyYW5zaXRpb24gbGFiZWxlZCBbbnRdLlxuICAgICAgIFRoaXMgaXMgZG9uZSBieSBjb25zdWx0aW5nIHRoZSBbZ290b10gdGFibGUuICopXG4gICAgbGV0IHNvdXJjZSA9IGVudi5jdXJyZW50IGluXG4gICAgbWF0Y2ggRVQubWF5YmVfZ290b19udCBzb3VyY2UgbnQgd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgICBmZWVkX2ZhaWx1cmUoKVxuICAgIHwgU29tZSB0YXJnZXQgLT5cbiAgICAgICAgKCogUHVzaCBhIG5ldyBjZWxsIG9udG8gdGhlIHN0YWNrLCBjb250YWluaW5nIHRoZSBpZGVudGl0eSBvZiB0aGUgc3RhdGVcbiAgICAgICAgICAgdGhhdCB3ZSBhcmUgbGVhdmluZy4gVGhlIHNlbWFudGljIHZhbHVlIFtzZW12XSBhbmQgcG9zaXRpb25zIFtzdGFydHBdXG4gICAgICAgICAgIGFuZCBbZW5kcF0gY29udGFpbmVkIGluIHRoZSBuZXcgY2VsbCBhcmUgcHJvdmlkZWQgYnkgdGhlIGNhbGxlci4gKilcbiAgICAgICAgbGV0IHN0YWNrID0geyBzdGF0ZSA9IHNvdXJjZTsgc2Vtdjsgc3RhcnRwOyBlbmRwOyBuZXh0ID0gZW52LnN0YWNrIH0gaW5cbiAgICAgICAgKCogTW92ZSB0byB0aGUgdGFyZ2V0IHN0YXRlLiAqKVxuICAgICAgICB7IGVudiB3aXRoIHN0YWNrOyBjdXJyZW50ID0gdGFyZ2V0IH1cblxuICBsZXQgcmVkdWNlICAgX2VudiBfcHJvZCA9IGZlZWRfZmFpbHVyZSgpXG4gIGxldCBpbml0aWF0ZSBfZW52ICAgICAgID0gZmVlZF9mYWlsdXJlKClcblxuICBsZXQgZmVlZF90ZXJtaW5hbFxuICAgICAgICAodGVybWluYWwgOiB0ZXJtaW5hbCkgc3RhcnRwIChzZW12IDogc2VtYW50aWNfdmFsdWUpIGVuZHAgKGVudiA6ICdiIGVudilcbiAgICAgIDogJ2IgZW52XG4gID1cbiAgICAoKiBDaGVjayBpZiB0aGUgc291cmNlIHN0YXRlIGhhcyBhbiBvdXRnb2luZyB0cmFuc2l0aW9uIGxhYmVsZWQgW3Rlcm1pbmFsXS5cbiAgICAgICBUaGlzIGlzIGRvbmUgYnkgY29uc3VsdGluZyB0aGUgW2FjdGlvbl0gdGFibGUuICopXG4gICAgbGV0IHNvdXJjZSA9IGVudi5jdXJyZW50IGluXG4gICAgRVQuYWN0aW9uIHNvdXJjZSB0ZXJtaW5hbCBzZW12XG4gICAgICAoZnVuIGVudiBfcGxlYXNlX2Rpc2NhcmQgX3Rlcm1pbmFsIHNlbXYgdGFyZ2V0IC0+XG4gICAgICAgICgqIFRoZXJlIGlzIGluZGVlZCBhIHRyYW5zaXRpb24gdG93YXJkIHRoZSBzdGF0ZSBbdGFyZ2V0XS5cbiAgICAgICAgICAgUHVzaCBhIG5ldyBjZWxsIG9udG8gdGhlIHN0YWNrIGFuZCBtb3ZlIHRvIHRoZSB0YXJnZXQgc3RhdGUuICopXG4gICAgICAgIGxldCBzdGFjayA9IHsgc3RhdGUgPSBzb3VyY2U7IHNlbXY7IHN0YXJ0cDsgZW5kcDsgbmV4dCA9IGVudi5zdGFjayB9IGluXG4gICAgICAgIHsgZW52IHdpdGggc3RhY2s7IGN1cnJlbnQgPSB0YXJnZXQgfVxuICAgICAgKSByZWR1Y2UgaW5pdGlhdGUgZW52XG5cbiAgKCogVGhlIHR5cGUgYXNzaWduZWQgdG8gW2ZlZWRdIGVuc3VyZXMgdGhhdCB0aGUgdHlwZSBvZiB0aGUgc2VtYW50aWMgdmFsdWVcbiAgICAgW3NlbXZdIGlzIGFwcHJvcHJpYXRlOiBpdCBtdXN0IGJlIHRoZSBzZW1hbnRpYy12YWx1ZSB0eXBlIG9mIHRoZSBzeW1ib2xcbiAgICAgW3N5bWJvbF0uICopXG5cbiAgbGV0IGZlZWQgKHN5bWJvbCA6ICdhIHN5bWJvbCkgc3RhcnRwIChzZW12IDogJ2EpIGVuZHAgZW52ID1cbiAgICBsZXQgc2VtdiA6IHNlbWFudGljX3ZhbHVlID0gT2JqLnJlcHIgc2VtdiBpblxuICAgIG1hdGNoIHN5bWJvbCB3aXRoXG4gICAgfCBOIG50IC0+XG4gICAgICAgIGZlZWRfbm9udGVybWluYWwgKG4yaSBudCkgc3RhcnRwIHNlbXYgZW5kcCBlbnZcbiAgICB8IFQgdGVybWluYWwgLT5cbiAgICAgICAgZmVlZF90ZXJtaW5hbCAodDJpIHRlcm1pbmFsKSBzdGFydHAgc2VtdiBlbmRwIGVudlxuXG5lbmRcbmVuZFxubW9kdWxlIFRhYmxlSW50ZXJwcmV0ZXIgPSBzdHJ1Y3RcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCBJbnJpYS4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyICAgICAqKVxuKCogICB0aGUgdGVybXMgb2YgdGhlIEdOVSBMaWJyYXJ5IEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLCB3aXRoIGEgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZywgYXMgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIE1ha2VFbmdpbmVUYWJsZSAoVCA6IFRhYmxlRm9ybWF0LlRBQkxFUykgPSBzdHJ1Y3RcblxuICB0eXBlIHN0YXRlID1cbiAgICAgIGludFxuXG4gIGxldCBudW1iZXIgcyA9IHNcblxuICB0eXBlIHRva2VuID1cbiAgICAgIFQudG9rZW5cblxuICB0eXBlIHRlcm1pbmFsID1cbiAgICAgIGludFxuXG4gIHR5cGUgbm9udGVybWluYWwgPVxuICAgICAgaW50XG5cbiAgdHlwZSBzZW1hbnRpY192YWx1ZSA9XG4gICAgICBPYmoudFxuXG4gIGxldCB0b2tlbjJ0ZXJtaW5hbCA9XG4gICAgVC50b2tlbjJ0ZXJtaW5hbFxuXG4gIGxldCB0b2tlbjJ2YWx1ZSA9XG4gICAgVC50b2tlbjJ2YWx1ZVxuXG4gIGxldCBlcnJvcl90ZXJtaW5hbCA9XG4gICAgVC5lcnJvcl90ZXJtaW5hbFxuXG4gIGxldCBlcnJvcl92YWx1ZSA9XG4gICAgT2JqLnJlcHIgKClcblxuICAoKiBUaGUgZnVuY3Rpb24gW2ZvcmVhY2hfdGVybWluYWxdIGV4cGxvaXRzIHRoZSBmYWN0IHRoYXQgdGhlXG4gICAgIGZpcnN0IGNvbXBvbmVudCBvZiBbVC5lcnJvcl0gaXMgW1Rlcm1pbmFsLm4gLSAxXSwgaS5lLiwgdGhlXG4gICAgIG51bWJlciBvZiB0ZXJtaW5hbCBzeW1ib2xzLCBpbmNsdWRpbmcgW2Vycm9yXSBidXQgbm90IFsjXS4gKilcblxuICAoKiBUaGVyZSBpcyBzaW1pbGFyIGNvZGUgaW4gW0luc3BlY3Rpb25UYWJsZUludGVycHJldGVyXS4gVGhlXG4gICAgIGNvZGUgdGhlcmUgY29udGFpbnMgYW4gYWRkaXRpb25hbCBjb252ZXJzaW9uIG9mIHRoZSB0eXBlXG4gICAgIFt0ZXJtaW5hbF0gdG8gdGhlIHR5cGUgW3hzeW1ib2xdLiAqKVxuXG4gIGxldCByZWMgZm9sZGlqIGkgaiBmIGFjY3UgPVxuICAgIGlmIGkgPSBqIHRoZW5cbiAgICAgIGFjY3VcbiAgICBlbHNlXG4gICAgICBmb2xkaWogKGkgKyAxKSBqIGYgKGYgaSBhY2N1KVxuXG4gIGxldCBmb3JlYWNoX3Rlcm1pbmFsIGYgYWNjdSA9XG4gICAgbGV0IG4sIF8gPSBULmVycm9yIGluXG4gICAgZm9sZGlqIDAgbiAoZnVuIGkgYWNjdSAtPlxuICAgICAgZiBpIGFjY3VcbiAgICApIGFjY3VcblxuICB0eXBlIHByb2R1Y3Rpb24gPVxuICAgICAgaW50XG5cbiAgKCogSW4gcHJpbmNpcGxlLCBvbmx5IG5vbi1zdGFydCBwcm9kdWN0aW9ucyBhcmUgZXhwb3NlZCB0byB0aGUgdXNlcixcbiAgICAgYXQgdHlwZSBbcHJvZHVjdGlvbl0gb3IgYXQgdHlwZSBbaW50XS4gVGhpcyBpcyBjaGVja2VkIGR5bmFtaWNhbGx5LiAqKVxuICBsZXQgbm9uX3N0YXJ0X3Byb2R1Y3Rpb24gaSA9XG4gICAgYXNzZXJ0IChULnN0YXJ0IDw9IGkgJiYgaSAtIFQuc3RhcnQgPCBBcnJheS5sZW5ndGggVC5zZW1hbnRpY19hY3Rpb24pXG5cbiAgbGV0IHByb2R1Y3Rpb25faW5kZXggaSA9XG4gICAgbm9uX3N0YXJ0X3Byb2R1Y3Rpb24gaTtcbiAgICBpXG5cbiAgbGV0IGZpbmRfcHJvZHVjdGlvbiBpID1cbiAgICBub25fc3RhcnRfcHJvZHVjdGlvbiBpO1xuICAgIGlcblxuICBsZXQgZGVmYXVsdF9yZWR1Y3Rpb24gc3RhdGUgZGVmcmVkIG5vZGVmcmVkIGVudiA9XG4gICAgbGV0IGNvZGUgPSBQYWNrZWRJbnRBcnJheS5nZXQgVC5kZWZhdWx0X3JlZHVjdGlvbiBzdGF0ZSBpblxuICAgIGlmIGNvZGUgPSAwIHRoZW5cbiAgICAgIG5vZGVmcmVkIGVudlxuICAgIGVsc2VcbiAgICAgIGRlZnJlZCBlbnYgKGNvZGUgLSAxKVxuXG4gIGxldCBpc19zdGFydCBwcm9kID1cbiAgICBwcm9kIDwgVC5zdGFydFxuXG4gICgqIFRoaXMgYXV4aWxpYXJ5IGZ1bmN0aW9uIGhlbHBzIGFjY2VzcyBhIGNvbXByZXNzZWQsIHR3by1kaW1lbnNpb25hbFxuICAgICBtYXRyaXgsIGxpa2UgdGhlIGFjdGlvbiBhbmQgZ290byB0YWJsZXMuICopXG5cbiAgbGV0IHVubWFyc2hhbDIgdGFibGUgaSBqID1cbiAgICBSb3dEaXNwbGFjZW1lbnQuZ2V0Z2V0XG4gICAgICBQYWNrZWRJbnRBcnJheS5nZXRcbiAgICAgIFBhY2tlZEludEFycmF5LmdldFxuICAgICAgdGFibGVcbiAgICAgIGkgalxuXG4gIGxldCBhY3Rpb24gc3RhdGUgdGVybWluYWwgdmFsdWUgc2hpZnQgcmVkdWNlIGZhaWwgZW52ID1cbiAgICBtYXRjaCBQYWNrZWRJbnRBcnJheS51bmZsYXR0ZW4xIFQuZXJyb3Igc3RhdGUgdGVybWluYWwgd2l0aFxuICAgIHwgMSAtPlxuICAgICAgICBsZXQgYWN0aW9uID0gdW5tYXJzaGFsMiBULmFjdGlvbiBzdGF0ZSB0ZXJtaW5hbCBpblxuICAgICAgICBsZXQgb3Bjb2RlID0gYWN0aW9uIGxhbmQgMGIxMVxuICAgICAgICBhbmQgcGFyYW0gPSBhY3Rpb24gbHNyIDIgaW5cbiAgICAgICAgaWYgb3Bjb2RlID49IDBiMTAgdGhlblxuICAgICAgICAgICgqIDBiMTAgOiBzaGlmdC9kaXNjYXJkICopXG4gICAgICAgICAgKCogMGIxMSA6IHNoaWZ0L25vZGlzY2FyZCAqKVxuICAgICAgICAgIGxldCBwbGVhc2VfZGlzY2FyZCA9IChvcGNvZGUgPSAwYjEwKSBpblxuICAgICAgICAgIHNoaWZ0IGVudiBwbGVhc2VfZGlzY2FyZCB0ZXJtaW5hbCB2YWx1ZSBwYXJhbVxuICAgICAgICBlbHNlXG4gICAgICAgICAgKCogMGIwMSA6IHJlZHVjZSAqKVxuICAgICAgICAgICgqIDBiMDAgOiBjYW5ub3QgaGFwcGVuICopXG4gICAgICAgICAgcmVkdWNlIGVudiBwYXJhbVxuICAgIHwgYyAtPlxuICAgICAgICBhc3NlcnQgKGMgPSAwKTtcbiAgICAgICAgZmFpbCBlbnZcblxuICBsZXQgZ290b19udCBzdGF0ZSBudCA9XG4gICAgbGV0IGNvZGUgPSB1bm1hcnNoYWwyIFQuZ290byBzdGF0ZSBudCBpblxuICAgICgqIGNvZGUgPSAxICsgc3RhdGUgKilcbiAgICBjb2RlIC0gMVxuXG4gIGxldCBnb3RvX3Byb2Qgc3RhdGUgcHJvZCA9XG4gICAgZ290b19udCBzdGF0ZSAoUGFja2VkSW50QXJyYXkuZ2V0IFQubGhzIHByb2QpXG5cbiAgbGV0IG1heWJlX2dvdG9fbnQgc3RhdGUgbnQgPVxuICAgIGxldCBjb2RlID0gdW5tYXJzaGFsMiBULmdvdG8gc3RhdGUgbnQgaW5cbiAgICAoKiBJZiBbY29kZV0gaXMgMCwgdGhlcmUgaXMgbm8gb3V0Z29pbmcgdHJhbnNpdGlvbi5cbiAgICAgICBJZiBbY29kZV0gaXMgWzEgKyBzdGF0ZV0sIHRoZXJlIGlzIGEgdHJhbnNpdGlvbiB0b3dhcmRzIFtzdGF0ZV0uICopXG4gICAgYXNzZXJ0ICgwIDw9IGNvZGUpO1xuICAgIGlmIGNvZGUgPSAwIHRoZW4gTm9uZSBlbHNlIFNvbWUgKGNvZGUgLSAxKVxuXG4gIGV4Y2VwdGlvbiBFcnJvciA9XG4gICAgICAgIFQuRXJyb3JcblxuICB0eXBlIHNlbWFudGljX2FjdGlvbiA9XG4gICAgICAoc3RhdGUsIHNlbWFudGljX3ZhbHVlLCB0b2tlbikgRW5naW5lVHlwZXMuZW52IC0+XG4gICAgICAoc3RhdGUsIHNlbWFudGljX3ZhbHVlKSAgICAgICAgRW5naW5lVHlwZXMuc3RhY2tcblxuICBsZXQgc2VtYW50aWNfYWN0aW9uIHByb2QgPVxuICAgICgqIEluZGV4aW5nIGludG8gdGhlIGFycmF5IFtULnNlbWFudGljX2FjdGlvbl0gaXMgb2ZmIGJ5IFtULnN0YXJ0XSxcbiAgICAgICBiZWNhdXNlIHRoZSBzdGFydCBwcm9kdWN0aW9ucyBkbyBub3QgaGF2ZSBlbnRyaWVzIGluIHRoaXMgYXJyYXkuICopXG4gICAgVC5zZW1hbnRpY19hY3Rpb24uKHByb2QgLSBULnN0YXJ0KVxuXG4gICgqIFttYXlfcmVkdWNlIHN0YXRlIHByb2RdIHRlc3RzIHdoZXRoZXIgdGhlIHN0YXRlIFtzdGF0ZV0gaXMgY2FwYWJsZSBvZlxuICAgICByZWR1Y2luZyB0aGUgcHJvZHVjdGlvbiBbcHJvZF0uIFRoaXMgaW5mb3JtYXRpb24gY291bGQgYmUgZGV0ZXJtaW5lZFxuICAgICBpbiBjb25zdGFudCB0aW1lIGlmIHdlIHdlcmUgd2lsbGluZyB0byBjcmVhdGUgYSBiaXRtYXAgZm9yIGl0LCBidXRcbiAgICAgdGhhdCB3b3VsZCB0YWtlIHVwIGEgbG90IG9mIHNwYWNlLiBJbnN0ZWFkLCB3ZSBvYnRhaW4gdGhpcyBpbmZvcm1hdGlvblxuICAgICBieSBpdGVyYXRpbmcgb3ZlciBhIGxpbmUgaW4gdGhlIGFjdGlvbiB0YWJsZS4gVGhpcyBpcyBjb3N0bHksIGJ1dCB0aGlzXG4gICAgIGZ1bmN0aW9uIGlzIG5vdCBub3JtYWxseSB1c2VkIGJ5IHRoZSBMUiBlbmdpbmUgYW55d2F5OyBpdCBpcyBzdXBwb3NlZFxuICAgICB0byBiZSB1c2VkIG9ubHkgYnkgcHJvZ3JhbW1lcnMgd2hvIHdpc2ggdG8gZGV2ZWxvcCBlcnJvciByZWNvdmVyeVxuICAgICBzdHJhdGVnaWVzLiAqKVxuXG4gICgqIEluIHRoZSBmdXR1cmUsIGlmIGRlc2lyZWQsIHdlIGNvdWxkIG1lbW9pemUgdGhpcyBmdW5jdGlvbiwgc28gYXNcbiAgICAgdG8gcGF5IHRoZSBjb3N0IGluIChtZW1vcnkpIHNwYWNlIG9ubHkgaWYgYW5kIHdoZXJlIHRoaXMgZnVuY3Rpb25cbiAgICAgaXMgYWN0dWFsbHkgdXNlZC4gV2UgY291bGQgYWxzbyByZXBsYWNlIFtmb3JlYWNoX3Rlcm1pbmFsXSB3aXRoIGFcbiAgICAgZnVuY3Rpb24gW2V4aXN0c190ZXJtaW5hbF0gd2hpY2ggc3RvcHMgYXMgc29vbiBhcyB0aGUgYWNjdW11bGF0b3JcbiAgICAgaXMgW3RydWVdLiAqKVxuXG4gIGxldCBtYXlfcmVkdWNlIHN0YXRlIHByb2QgPVxuICAgICgqIFRlc3QgaWYgdGhlcmUgaXMgYSBkZWZhdWx0IHJlZHVjdGlvbiBvZiBbcHJvZF0uICopXG4gICAgZGVmYXVsdF9yZWR1Y3Rpb24gc3RhdGVcbiAgICAgIChmdW4gKCkgcHJvZCcgLT4gcHJvZCA9IHByb2QnKVxuICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAoKiBJZiBub3QsIHRoZW4gZm9yIGVhY2ggdGVybWluYWwgW3RdLCAuLi4gKilcbiAgICAgICAgZm9yZWFjaF90ZXJtaW5hbCAoZnVuIHQgYWNjdSAtPlxuICAgICAgICAgIGFjY3UgfHxcbiAgICAgICAgICAoKiAuLi4gdGVzdCBpZiB0aGVyZSBpcyBhIHJlZHVjdGlvbiBvZiBbcHJvZF0gb24gW3RdLiAqKVxuICAgICAgICAgIGFjdGlvbiBzdGF0ZSB0ICgpXG4gICAgICAgICAgICAoKiBzaGlmdDogICopIChmdW4gKCkgXyBfICgpIF8gLT4gZmFsc2UpXG4gICAgICAgICAgICAoKiByZWR1Y2U6ICopIChmdW4gKCkgcHJvZCcgLT4gcHJvZCA9IHByb2QnKVxuICAgICAgICAgICAgKCogZmFpbDogICAqKSAoZnVuICgpIC0+IGZhbHNlKVxuICAgICAgICAgICAgKClcbiAgICAgICAgKSBmYWxzZVxuICAgICAgKVxuICAgICAgKClcblxuICAoKiBJZiBbVC50cmFjZV0gaXMgW05vbmVdLCB0aGVuIHRoZSBsb2dnaW5nIGZ1bmN0aW9ucyBkbyBub3RoaW5nLiAqKVxuXG4gIGxldCBsb2cgPVxuICAgIG1hdGNoIFQudHJhY2Ugd2l0aCBTb21lIF8gLT4gdHJ1ZSB8IE5vbmUgLT4gZmFsc2VcblxuICBtb2R1bGUgTG9nID0gc3RydWN0XG5cbiAgICBvcGVuIFByaW50ZlxuXG4gICAgbGV0IHN0YXRlIHN0YXRlID1cbiAgICAgIG1hdGNoIFQudHJhY2Ugd2l0aFxuICAgICAgfCBTb21lIF8gLT5cbiAgICAgICAgICBmcHJpbnRmIHN0ZGVyciBcIlN0YXRlICVkOlxcbiUhXCIgc3RhdGVcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICgpXG5cbiAgICBsZXQgc2hpZnQgdGVybWluYWwgc3RhdGUgPVxuICAgICAgbWF0Y2ggVC50cmFjZSB3aXRoXG4gICAgICB8IFNvbWUgKHRlcm1pbmFscywgXykgLT5cbiAgICAgICAgICBmcHJpbnRmIHN0ZGVyciBcIlNoaWZ0aW5nICglcykgdG8gc3RhdGUgJWRcXG4lIVwiIHRlcm1pbmFscy4odGVybWluYWwpIHN0YXRlXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAoKVxuXG4gICAgbGV0IHJlZHVjZV9vcl9hY2NlcHQgcHJvZCA9XG4gICAgICBtYXRjaCBULnRyYWNlIHdpdGhcbiAgICAgIHwgU29tZSAoXywgcHJvZHVjdGlvbnMpIC0+XG4gICAgICAgICAgZnByaW50ZiBzdGRlcnIgXCIlc1xcbiUhXCIgcHJvZHVjdGlvbnMuKHByb2QpXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAoKVxuXG4gICAgbGV0IGxvb2thaGVhZF90b2tlbiB0b2tlbiBzdGFydHAgZW5kcCA9XG4gICAgICBtYXRjaCBULnRyYWNlIHdpdGhcbiAgICAgIHwgU29tZSAodGVybWluYWxzLCBfKSAtPlxuICAgICAgICAgIGZwcmludGYgc3RkZXJyIFwiTG9va2FoZWFkIHRva2VuIGlzIG5vdyAlcyAoJWQtJWQpXFxuJSFcIlxuICAgICAgICAgICAgdGVybWluYWxzLih0b2tlbilcbiAgICAgICAgICAgIHN0YXJ0cC5MZXhpbmcucG9zX2NudW1cbiAgICAgICAgICAgIGVuZHAuTGV4aW5nLnBvc19jbnVtXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAoKVxuXG4gICAgbGV0IGluaXRpYXRpbmdfZXJyb3JfaGFuZGxpbmcgKCkgPVxuICAgICAgbWF0Y2ggVC50cmFjZSB3aXRoXG4gICAgICB8IFNvbWUgXyAtPlxuICAgICAgICAgIGZwcmludGYgc3RkZXJyIFwiSW5pdGlhdGluZyBlcnJvciBoYW5kbGluZ1xcbiUhXCJcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICgpXG5cbiAgICBsZXQgcmVzdW1pbmdfZXJyb3JfaGFuZGxpbmcgKCkgPVxuICAgICAgbWF0Y2ggVC50cmFjZSB3aXRoXG4gICAgICB8IFNvbWUgXyAtPlxuICAgICAgICAgIGZwcmludGYgc3RkZXJyIFwiUmVzdW1pbmcgZXJyb3IgaGFuZGxpbmdcXG4lIVwiXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAoKVxuXG4gICAgbGV0IGhhbmRsaW5nX2Vycm9yIHN0YXRlID1cbiAgICAgIG1hdGNoIFQudHJhY2Ugd2l0aFxuICAgICAgfCBTb21lIF8gLT5cbiAgICAgICAgICBmcHJpbnRmIHN0ZGVyciBcIkhhbmRsaW5nIGVycm9yIGluIHN0YXRlICVkXFxuJSFcIiBzdGF0ZVxuICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgKClcblxuICBlbmRcblxuZW5kXG5lbmRcbm1vZHVsZSBTdGF0aWNWZXJzaW9uID0gc3RydWN0XG5sZXQgcmVxdWlyZV8yMDIyMDIxMCA9ICgpXG5lbmRcbiIsIlxudHlwZSB0ID0gaW50XG5sZXQgZXF1YWwgKHggOiBpbnQpICh5IDogaW50KSA9IHggPSB5XG5sZXQgY29tcGFyZSAoeCA6IGludCkgKHkgOiBpbnQpID0gY29tcGFyZSB4IHlcbmxldCB0b19pbnQgeCA9IHhcbmxldCBwcCA9IEZvcm1hdC5wcF9wcmludF9pbnRcblxubGV0IGludGVyc2VjdCB4IHkgPSB4IGxhbmQgeSA8PiAwXG5sZXQgKCsrKSB4IHkgPSB4IGxvciB5XG5cbmxldCBkdW1teSA9IC0xXG5sZXQgaW5leGlzdGFudCA9IDFcbmxldCBsZXR0ZXIgPSAyXG5sZXQgbm90X2xldHRlciA9IDRcbmxldCBuZXdsaW5lID0gOFxubGV0IGxhc3RuZXdsaW5lID0gMTZcbmxldCBzZWFyY2hfYm91bmRhcnkgPSAzMlxuXG5sZXQgZnJvbV9jaGFyID0gZnVuY3Rpb25cbiAgKCogU2hvdWxkIG1hdGNoIFtjd29yZF0gZGVmaW5pdGlvbiAqKVxuICB8ICdhJy4uJ3onIHwgJ0EnLi4nWicgfCAnMCcuLic5JyB8ICdfJyB8ICdcXDE3MCcgfCAnXFwxODEnIHwgJ1xcMTg2J1xuICB8ICdcXDE5MicuLidcXDIxNCcgfCAnXFwyMTYnLi4nXFwyNDYnIHwgJ1xcMjQ4Jy4uJ1xcMjU1JyAtPlxuICAgIGxldHRlclxuICB8ICdcXG4nIC0+XG4gICAgbm90X2xldHRlciArKyBuZXdsaW5lXG4gIHwgXyAtPlxuICAgIG5vdF9sZXR0ZXJcbiIsIigqXG4gICBSRSAtIEEgcmVndWxhciBleHByZXNzaW9uIGxpYnJhcnlcblxuICAgQ29weXJpZ2h0IChDKSAyMDAxIEplcm9tZSBWb3VpbGxvblxuICAgZW1haWw6IEplcm9tZS5Wb3VpbGxvbkBwcHMuanVzc2lldS5mclxuXG4gICBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gICBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoXG4gICBsaW5raW5nIGV4Y2VwdGlvbjsgZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXRcbiAgIHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlVcbiAgIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAgIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnk7IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbiAgIEZvdW5kYXRpb24sIEluYy4sIDUxIEZyYW5rbGluIFN0cmVldCwgRmlmdGggRmxvb3IsIEJvc3RvbiwgTUEgMDIxMTAtMTMwMSBVU0FcbiopXG5cbmxldCByZWMgaXRlciBuIGYgdiA9IGlmIG4gPSAwIHRoZW4gdiBlbHNlIGl0ZXIgKG4gLSAxKSBmIChmIHYpXG5cbigqKioqKVxuXG5sZXQgdW5rbm93biA9IC0yXG5sZXQgYnJlYWsgPSAtM1xuXG50eXBlIG1hdGNoX2luZm8gPVxuICB8IE1hdGNoIG9mIEdyb3VwLnRcbiAgfCBGYWlsZWRcbiAgfCBSdW5uaW5nXG5cbnR5cGUgc3RhdGUgPVxuICB7IGlkeCA6IGludDtcbiAgICAoKiBJbmRleCBvZiB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgcG9zaXRpb24gdGFibGUuXG4gICAgICAgTm90IHlldCBjb21wdXRlZCB0cmFuc2l0aW9ucyBwb2ludCB0byBhIGR1bW15IHN0YXRlIHdoZXJlXG4gICAgICAgW2lkeF0gaXMgc2V0IHRvIFt1bmtub3duXTtcbiAgICAgICBJZiBbaWR4XSBpcyBzZXQgdG8gW2JyZWFrXSBmb3Igc3RhdGVzIHRoYXQgZWl0aGVyIGFsd2F5c1xuICAgICAgIHN1Y2NlZWQgb3IgYWx3YXlzIGZhaWwuICopXG4gICAgcmVhbF9pZHggOiBpbnQ7XG4gICAgKCogVGhlIHJlYWwgaW5kZXgsIGluIGNhc2UgW2lkeF0gaXMgc2V0IHRvIFticmVha10gKilcbiAgICBuZXh0IDogc3RhdGUgYXJyYXk7XG4gICAgKCogVHJhbnNpdGlvbiB0YWJsZSwgaW5kZXhlZCBieSBjb2xvciAqKVxuICAgIG11dGFibGUgZmluYWwgOlxuICAgICAgKENhdGVnb3J5LnQgKlxuICAgICAgIChBdXRvbWF0YS5pZHggKiBBdXRvbWF0YS5zdGF0dXMpKSBsaXN0O1xuICAgICgqIE1hcHBpbmcgZnJvbSB0aGUgY2F0ZWdvcnkgb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvXG4gICAgICAgLSB0aGUgaW5kZXggd2hlcmUgdGhlIG5leHQgcG9zaXRpb24gc2hvdWxkIGJlIHNhdmVkXG4gICAgICAgLSBwb3NzaWJseSwgdGhlIGxpc3Qgb2YgbWFya3MgKGFuZCB0aGUgY29ycmVzcG9uZGluZyBpbmRpY2VzKVxuICAgICAgICAgY29ycmVzcG9uZGluZyB0byB0aGUgYmVzdCBtYXRjaCAqKVxuICAgIGRlc2MgOiBBdXRvbWF0YS5TdGF0ZS50XG4gICAgKCogRGVzY3JpcHRpb24gb2YgdGhpcyBzdGF0ZSBvZiB0aGUgYXV0b21hdGEgKikgfVxuXG4oKiBBdXRvbWF0YSAoY29tcGlsZWQgcmVndWxhciBleHByZXNzaW9uKSAqKVxudHlwZSByZSA9XG4gIHsgaW5pdGlhbCA6IEF1dG9tYXRhLmV4cHI7XG4gICAgKCogVGhlIHdob2xlIHJlZ3VsYXIgZXhwcmVzc2lvbiAqKVxuICAgIG11dGFibGUgaW5pdGlhbF9zdGF0ZXMgOiAoQ2F0ZWdvcnkudCAqIHN0YXRlKSBsaXN0O1xuICAgICgqIEluaXRpYWwgc3RhdGVzLCBpbmRleGVkIGJ5IGluaXRpYWwgY2F0ZWdvcnkgKilcbiAgICBjb2xvcnMgOiBCeXRlcy50O1xuICAgICgqIENvbG9yIHRhYmxlICopXG4gICAgY29sb3JfcmVwciA6IEJ5dGVzLnQ7XG4gICAgKCogVGFibGUgZnJvbSBjb2xvcnMgdG8gb25lIGNoYXJhY3RlciBvZiB0aGlzIGNvbG9yICopXG4gICAgbmNvbG9yIDogaW50O1xuICAgICgqIE51bWJlciBvZiBjb2xvcnMuICopXG4gICAgbG5sIDogaW50O1xuICAgICgqIENvbG9yIG9mIHRoZSBsYXN0IG5ld2xpbmUuIC0xIGlmIHVubmVjZXNzYXJ5ICopXG4gICAgdGJsIDogQXV0b21hdGEud29ya2luZ19hcmVhO1xuICAgICgqIFRlbXBvcmFyeSB0YWJsZSB1c2VkIHRvIGNvbXB1dGUgdGhlIGZpcnN0IGF2YWlsYWJsZSBpbmRleFxuICAgICAgIHdoZW4gY29tcHV0aW5nIGEgbmV3IHN0YXRlICopXG4gICAgc3RhdGVzIDogc3RhdGUgQXV0b21hdGEuU3RhdGUuVGFibGUudDtcbiAgICAoKiBTdGF0ZXMgb2YgdGhlIGRldGVybWluaXN0aWMgYXV0b21hdGEgKilcbiAgICBncm91cF9jb3VudCA6IGludFxuICAgICgqIE51bWJlciBvZiBncm91cHMgaW4gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiAqKSB9XG5cbmxldCBwcF9yZSBjaCByZSA9IEF1dG9tYXRhLnBwIGNoIHJlLmluaXRpYWxcblxubGV0IHByaW50X3JlID0gcHBfcmVcblxuKCogSW5mb3JtYXRpb24gdXNlZCBkdXJpbmcgbWF0Y2hpbmcgKilcbnR5cGUgaW5mbyA9XG4gIHsgcmUgOiByZTtcbiAgICAoKiBUaGUgYXV0b21hdGEgKilcbiAgICBjb2xvcnMgOiBCeXRlcy50O1xuICAgICgqIENvbG9yIHRhYmxlIChbeC5jb2xvcnMgPSB4LnJlLmNvbG9yc10pXG4gICAgICAgU2hvcnRjdXQgdXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyAqKVxuICAgIG11dGFibGUgcG9zaXRpb25zIDogaW50IGFycmF5O1xuICAgICgqIEFycmF5IG9mIG1hcmsgcG9zaXRpb25zXG4gICAgICAgVGhlIG1hcmsgYXJlIG9mZiBieSBvbmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgKilcbiAgICBwb3MgOiBpbnQ7XG4gICAgKCogUG9zaXRpb24gd2hlcmUgdGhlIG1hdGNoIGlzIHN0YXJ0ZWQgKilcbiAgICBsYXN0IDogaW50XG4gICAgKCogUG9zaXRpb24gd2hlcmUgdGhlIG1hdGNoIHNob3VsZCBzdG9wICopIH1cblxuXG4oKioqKilcblxubGV0IGNhdGVnb3J5IHJlIH5jb2xvciA9XG4gIGlmIGNvbG9yID0gLTEgdGhlblxuICAgIENhdGVnb3J5LmluZXhpc3RhbnRcbiAgICAoKiBTcGVjaWFsIGNhdGVnb3J5IGZvciB0aGUgbGFzdCBuZXdsaW5lICopXG4gIGVsc2UgaWYgY29sb3IgPSByZS5sbmwgdGhlblxuICAgIENhdGVnb3J5LihsYXN0bmV3bGluZSArKyBuZXdsaW5lICsrIG5vdF9sZXR0ZXIpXG4gIGVsc2VcbiAgICBDYXRlZ29yeS5mcm9tX2NoYXIgKEJ5dGVzLmdldCByZS5jb2xvcl9yZXByIGNvbG9yKVxuXG4oKioqKilcblxubGV0IGR1bW15X25leHQgPSBbfHxdXG5cbmxldCB1bmtub3duX3N0YXRlID1cbiAgeyBpZHggPSB1bmtub3duOyByZWFsX2lkeCA9IDA7XG4gICAgbmV4dCA9IGR1bW15X25leHQ7IGZpbmFsID0gW107XG4gICAgZGVzYyA9IEF1dG9tYXRhLlN0YXRlLmR1bW15IH1cblxubGV0IG1rX3N0YXRlIG5jb2wgZGVzYyA9XG4gIGxldCBicmVha19zdGF0ZSA9XG4gICAgbWF0Y2ggQXV0b21hdGEuc3RhdHVzIGRlc2Mgd2l0aFxuICAgIHwgQXV0b21hdGEuUnVubmluZyAtPiBmYWxzZVxuICAgIHwgQXV0b21hdGEuRmFpbGVkXG4gICAgfCBBdXRvbWF0YS5NYXRjaCBfIC0+IHRydWVcbiAgaW5cbiAgeyBpZHggPSBpZiBicmVha19zdGF0ZSB0aGVuIGJyZWFrIGVsc2UgZGVzYy5BdXRvbWF0YS5TdGF0ZS5pZHg7XG4gICAgcmVhbF9pZHggPSBkZXNjLkF1dG9tYXRhLlN0YXRlLmlkeDtcbiAgICBuZXh0ID0gaWYgYnJlYWtfc3RhdGUgdGhlbiBkdW1teV9uZXh0IGVsc2UgQXJyYXkubWFrZSBuY29sIHVua25vd25fc3RhdGU7XG4gICAgZmluYWwgPSBbXTtcbiAgICBkZXNjIH1cblxubGV0IGZpbmRfc3RhdGUgcmUgZGVzYyA9XG4gIHRyeVxuICAgIEF1dG9tYXRhLlN0YXRlLlRhYmxlLmZpbmQgcmUuc3RhdGVzIGRlc2NcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBsZXQgc3QgPSBta19zdGF0ZSByZS5uY29sb3IgZGVzYyBpblxuICAgIEF1dG9tYXRhLlN0YXRlLlRhYmxlLmFkZCByZS5zdGF0ZXMgZGVzYyBzdDtcbiAgICBzdFxuXG4oKioqKiBNYXRjaCB3aXRoIG1hcmtzICoqKiopXG5cbmxldCBkZWx0YSBpbmZvIGNhdCB+Y29sb3Igc3QgPVxuICBsZXQgZGVzYyA9IEF1dG9tYXRhLmRlbHRhIGluZm8ucmUudGJsIGNhdCBjb2xvciBzdC5kZXNjIGluXG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaW5mby5wb3NpdGlvbnMgaW5cbiAgaWYgZGVzYy5BdXRvbWF0YS5TdGF0ZS5pZHggPSBsZW4gJiYgbGVuID4gMCB0aGVuIGJlZ2luXG4gICAgbGV0IHBvcyA9IGluZm8ucG9zaXRpb25zIGluXG4gICAgaW5mby5wb3NpdGlvbnMgPC0gQXJyYXkubWFrZSAoMiAqIGxlbikgMDtcbiAgICBBcnJheS5ibGl0IHBvcyAwIGluZm8ucG9zaXRpb25zIDAgbGVuXG4gIGVuZDtcbiAgZGVzY1xuXG5sZXQgdmFsaWRhdGUgaW5mbyAoczpzdHJpbmcpIH5wb3Mgc3QgPVxuICBsZXQgY29sb3IgPSBDaGFyLmNvZGUgKEJ5dGVzLmdldCBpbmZvLmNvbG9ycyAoQ2hhci5jb2RlIHMuW3Bvc10pKSBpblxuICBsZXQgY2F0ID0gY2F0ZWdvcnkgaW5mby5yZSB+Y29sb3IgaW5cbiAgbGV0IGRlc2MnID0gZGVsdGEgaW5mbyBjYXQgfmNvbG9yIHN0IGluXG4gIGxldCBzdCcgPSBmaW5kX3N0YXRlIGluZm8ucmUgZGVzYycgaW5cbiAgc3QubmV4dC4oY29sb3IpIDwtIHN0J1xuXG4oKlxubGV0IHJlYyBsb29wIGluZm8gcyBwb3Mgc3QgPVxuICBpZiBwb3MgPCBpbmZvLmxhc3QgdGhlblxuICAgIGxldCBzdCcgPSBzdC5uZXh0LihDaGFyLmNvZGUgaW5mby5jb2xzLltDaGFyLmNvZGUgcy5bcG9zXV0pIGluXG4gICAgbGV0IGlkeCA9IHN0Jy5pZHggaW5cbiAgICBpZiBpZHggPj0gMCB0aGVuIGJlZ2luXG4gICAgICBpbmZvLnBvc2l0aW9ucy4oaWR4KSA8LSBwb3M7XG4gICAgICBsb29wIGluZm8gcyAocG9zICsgMSkgc3QnXG4gICAgZW5kIGVsc2UgaWYgaWR4ID0gYnJlYWsgdGhlbiBiZWdpblxuICAgICAgaW5mby5wb3NpdGlvbnMuKHN0Jy5yZWFsX2lkeCkgPC0gcG9zO1xuICAgICAgc3QnXG4gICAgZW5kIGVsc2UgYmVnaW4gKCogVW5rbm93biAqKVxuICAgICAgdmFsaWRhdGUgaW5mbyBzIHBvcyBzdDtcbiAgICAgIGxvb3AgaW5mbyBzIHBvcyBzdFxuICAgIGVuZFxuICBlbHNlXG4gICAgc3RcbiopXG5cbmxldCByZWMgbG9vcCBpbmZvIChzOnN0cmluZykgfnBvcyBzdCA9XG4gIGlmIHBvcyA8IGluZm8ubGFzdCB0aGVuXG4gICAgbGV0IHN0JyA9IHN0Lm5leHQuKENoYXIuY29kZSAoQnl0ZXMuZ2V0IGluZm8uY29sb3JzIChDaGFyLmNvZGUgcy5bcG9zXSkpKSBpblxuICAgIGxvb3AyIGluZm8gcyB+cG9zIHN0IHN0J1xuICBlbHNlXG4gICAgc3RcblxuYW5kIGxvb3AyIGluZm8gcyB+cG9zIHN0IHN0JyA9XG4gIGlmIHN0Jy5pZHggPj0gMCB0aGVuIGJlZ2luXG4gICAgbGV0IHBvcyA9IHBvcyArIDEgaW5cbiAgICBpZiBwb3MgPCBpbmZvLmxhc3QgdGhlbiBiZWdpblxuICAgICAgKCogSXQgaXMgaW1wb3J0YW50IHRvIHBsYWNlIHRoZXNlIHJlYWRzIGJlZm9yZSB0aGUgd3JpdGUgKilcbiAgICAgICgqIEJ1dCB0aGVuLCB3ZSBkb24ndCBoYXZlIGVub3VnaCByZWdpc3RlcnMgbGVmdCB0byBzdG9yZSB0aGVcbiAgICAgICAgIHJpZ2h0IHBvc2l0aW9uLiAgU28sIHdlIHN0b3JlIHRoZSBwb3NpdGlvbiBwbHVzIG9uZS4gKilcbiAgICAgIGxldCBzdCcnID1cbiAgICAgICAgc3QnLm5leHQuKENoYXIuY29kZSAoQnl0ZXMuZ2V0IGluZm8uY29sb3JzIChDaGFyLmNvZGUgcy5bcG9zXSkpKSBpblxuICAgICAgaW5mby5wb3NpdGlvbnMuKHN0Jy5pZHgpIDwtIHBvcztcbiAgICAgIGxvb3AyIGluZm8gcyB+cG9zIHN0JyBzdCcnXG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIGluZm8ucG9zaXRpb25zLihzdCcuaWR4KSA8LSBwb3M7XG4gICAgICBzdCdcbiAgICBlbmRcbiAgZW5kIGVsc2UgaWYgc3QnLmlkeCA9IGJyZWFrIHRoZW4gYmVnaW5cbiAgICBpbmZvLnBvc2l0aW9ucy4oc3QnLnJlYWxfaWR4KSA8LSBwb3MgKyAxO1xuICAgIHN0J1xuICBlbmQgZWxzZSBiZWdpbiAoKiBVbmtub3duICopXG4gICAgdmFsaWRhdGUgaW5mbyBzIH5wb3Mgc3Q7XG4gICAgbG9vcCBpbmZvIHMgfnBvcyBzdFxuICBlbmRcblxubGV0IHJlYyBsb29wX25vX21hcmsgaW5mbyBzIH5wb3Mgfmxhc3Qgc3QgPVxuICBpZiBwb3MgPCBsYXN0IHRoZW5cbiAgICBsZXQgc3QnID0gc3QubmV4dC4oQ2hhci5jb2RlIChCeXRlcy5nZXQgaW5mby5jb2xvcnMgKENoYXIuY29kZSBzLltwb3NdKSkpIGluXG4gICAgaWYgc3QnLmlkeCA+PSAwIHRoZW5cbiAgICAgIGxvb3Bfbm9fbWFyayBpbmZvIHMgfnBvczoocG9zICsgMSkgfmxhc3Qgc3QnXG4gICAgZWxzZSBpZiBzdCcuaWR4ID0gYnJlYWsgdGhlblxuICAgICAgc3QnXG4gICAgZWxzZSBiZWdpbiAoKiBVbmtub3duICopXG4gICAgICB2YWxpZGF0ZSBpbmZvIHMgfnBvcyBzdDtcbiAgICAgIGxvb3Bfbm9fbWFyayBpbmZvIHMgfnBvcyB+bGFzdCBzdFxuICAgIGVuZFxuICBlbHNlXG4gICAgc3RcblxubGV0IGZpbmFsIGluZm8gc3QgY2F0ID1cbiAgdHJ5XG4gICAgTGlzdC5hc3NxIGNhdCBzdC5maW5hbFxuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGxldCBzdCcgPSBkZWx0YSBpbmZvIGNhdCB+Y29sb3I6KC0xKSBzdCBpblxuICAgIGxldCByZXMgPSAoc3QnLkF1dG9tYXRhLlN0YXRlLmlkeCwgQXV0b21hdGEuc3RhdHVzIHN0JykgaW5cbiAgICBzdC5maW5hbCA8LSAoY2F0LCByZXMpIDo6IHN0LmZpbmFsO1xuICAgIHJlc1xuXG5sZXQgZmluZF9pbml0aWFsX3N0YXRlIHJlIGNhdCA9XG4gIHRyeVxuICAgIExpc3QuYXNzcSBjYXQgcmUuaW5pdGlhbF9zdGF0ZXNcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBsZXQgc3QgPSBmaW5kX3N0YXRlIHJlIChBdXRvbWF0YS5TdGF0ZS5jcmVhdGUgY2F0IHJlLmluaXRpYWwpIGluXG4gICAgcmUuaW5pdGlhbF9zdGF0ZXMgPC0gKGNhdCwgc3QpIDo6IHJlLmluaXRpYWxfc3RhdGVzO1xuICAgIHN0XG5cbmxldCBnZXRfY29sb3IgcmUgKHM6c3RyaW5nKSBwb3MgPVxuICBpZiBwb3MgPCAwIHRoZW5cbiAgICAtMVxuICBlbHNlXG4gICAgbGV0IHNsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICBpZiBwb3MgPj0gc2xlbiB0aGVuXG4gICAgICAtMVxuICAgIGVsc2UgaWYgcG9zID0gc2xlbiAtIDEgJiYgcmUubG5sIDw+IC0xICYmIHMuW3Bvc10gPSAnXFxuJyB0aGVuXG4gICAgICAoKiBTcGVjaWFsIGNhc2UgZm9yIHRoZSBsYXN0IG5ld2xpbmUgKilcbiAgICAgIHJlLmxubFxuICAgIGVsc2VcbiAgICAgIENoYXIuY29kZSAoQnl0ZXMuZ2V0IHJlLmNvbG9ycyAoQ2hhci5jb2RlIHMuW3Bvc10pKVxuXG5sZXQgcmVjIGhhbmRsZV9sYXN0X25ld2xpbmUgaW5mbyB+cG9zIHN0IH5ncm91cHMgPVxuICBsZXQgc3QnID0gc3QubmV4dC4oaW5mby5yZS5sbmwpIGluXG4gIGlmIHN0Jy5pZHggPj0gMCB0aGVuIGJlZ2luXG4gICAgaWYgZ3JvdXBzIHRoZW4gaW5mby5wb3NpdGlvbnMuKHN0Jy5pZHgpIDwtIHBvcyArIDE7XG4gICAgc3QnXG4gIGVuZCBlbHNlIGlmIHN0Jy5pZHggPSBicmVhayB0aGVuIGJlZ2luXG4gICAgaWYgZ3JvdXBzIHRoZW4gaW5mby5wb3NpdGlvbnMuKHN0Jy5yZWFsX2lkeCkgPC0gcG9zICsgMTtcbiAgICBzdCdcbiAgZW5kIGVsc2UgYmVnaW4gKCogVW5rbm93biAqKVxuICAgIGxldCBjb2xvciA9IGluZm8ucmUubG5sIGluXG4gICAgbGV0IHJlYWxfYyA9IENoYXIuY29kZSAoQnl0ZXMuZ2V0IGluZm8uY29sb3JzIChDaGFyLmNvZGUgJ1xcbicpKSBpblxuICAgIGxldCBjYXQgPSBjYXRlZ29yeSBpbmZvLnJlIH5jb2xvciBpblxuICAgIGxldCBkZXNjJyA9IGRlbHRhIGluZm8gY2F0IH5jb2xvcjpyZWFsX2Mgc3QgaW5cbiAgICBsZXQgc3QnID0gZmluZF9zdGF0ZSBpbmZvLnJlIGRlc2MnIGluXG4gICAgc3QubmV4dC4oY29sb3IpIDwtIHN0JztcbiAgICBoYW5kbGVfbGFzdF9uZXdsaW5lIGluZm8gfnBvcyBzdCB+Z3JvdXBzXG4gIGVuZFxuXG5sZXQgcmVjIHNjYW5fc3RyIGluZm8gKHM6c3RyaW5nKSBpbml0aWFsX3N0YXRlIH5ncm91cHMgPVxuICBsZXQgcG9zID0gaW5mby5wb3MgaW5cbiAgbGV0IGxhc3QgPSBpbmZvLmxhc3QgaW5cbiAgaWYgKGxhc3QgPSBTdHJpbmcubGVuZ3RoIHNcbiAgICAgICYmIGluZm8ucmUubG5sIDw+IC0xXG4gICAgICAmJiBsYXN0ID4gcG9zXG4gICAgICAmJiBTdHJpbmcuZ2V0IHMgKGxhc3QgLSAxKSA9ICdcXG4nKVxuICB0aGVuIGJlZ2luXG4gICAgbGV0IGluZm8gPSB7IGluZm8gd2l0aCBsYXN0ID0gbGFzdCAtIDEgfSBpblxuICAgIGxldCBzdCA9IHNjYW5fc3RyIGluZm8gcyBpbml0aWFsX3N0YXRlIH5ncm91cHMgaW5cbiAgICBpZiBzdC5pZHggPSBicmVhayB0aGVuXG4gICAgICBzdFxuICAgIGVsc2VcbiAgICAgIGhhbmRsZV9sYXN0X25ld2xpbmUgaW5mbyB+cG9zOihsYXN0IC0gMSkgc3Qgfmdyb3Vwc1xuICBlbmQgZWxzZSBpZiBncm91cHMgdGhlblxuICAgIGxvb3AgaW5mbyBzIH5wb3MgaW5pdGlhbF9zdGF0ZVxuICBlbHNlXG4gICAgbG9vcF9ub19tYXJrIGluZm8gcyB+cG9zIH5sYXN0IGluaXRpYWxfc3RhdGVcblxubGV0IG1hdGNoX3N0ciB+Z3JvdXBzIH5wYXJ0aWFsIHJlIHMgfnBvcyB+bGVuID1cbiAgbGV0IHNsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGxhc3QgPSBpZiBsZW4gPSAtMSB0aGVuIHNsZW4gZWxzZSBwb3MgKyBsZW4gaW5cbiAgbGV0IGluZm8gPVxuICAgIHsgcmUgOyBjb2xvcnMgPSByZS5jb2xvcnM7IHBvcyA7IGxhc3RcbiAgICA7IHBvc2l0aW9ucyA9XG4gICAgICAgIGlmIGdyb3VwcyB0aGVuIGJlZ2luXG4gICAgICAgICAgbGV0IG4gPSBBdXRvbWF0YS5pbmRleF9jb3VudCByZS50YmwgKyAxIGluXG4gICAgICAgICAgaWYgbiA8PSAxMCB0aGVuXG4gICAgICAgICAgICBbfDA7MDswOzA7MDswOzA7MDswOzB8XVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIEFycmF5Lm1ha2UgbiAwXG4gICAgICAgIGVuZCBlbHNlXG4gICAgICAgICAgW3x8XSB9XG4gIGluXG4gIGxldCBpbml0aWFsX2NhdCA9XG4gICAgaWYgcG9zID0gMCB0aGVuXG4gICAgICBDYXRlZ29yeS4oc2VhcmNoX2JvdW5kYXJ5ICsrIGluZXhpc3RhbnQpXG4gICAgZWxzZVxuICAgICAgQ2F0ZWdvcnkuKHNlYXJjaF9ib3VuZGFyeVxuICAgICAgICAgICAgICAgICsrIGNhdGVnb3J5IHJlIH5jb2xvcjooZ2V0X2NvbG9yIHJlIHMgKHBvcyAtIDEpKSlcbiAgaW5cbiAgbGV0IGluaXRpYWxfc3RhdGUgPSBmaW5kX2luaXRpYWxfc3RhdGUgcmUgaW5pdGlhbF9jYXQgaW5cbiAgbGV0IHN0ID0gc2Nhbl9zdHIgaW5mbyBzIGluaXRpYWxfc3RhdGUgfmdyb3VwcyBpblxuICBsZXQgcmVzID1cbiAgICBpZiBzdC5pZHggPSBicmVhayB8fCBwYXJ0aWFsIHRoZW5cbiAgICAgIEF1dG9tYXRhLnN0YXR1cyBzdC5kZXNjXG4gICAgZWxzZVxuICAgICAgbGV0IGZpbmFsX2NhdCA9XG4gICAgICAgIGlmIGxhc3QgPSBzbGVuIHRoZW5cbiAgICAgICAgICBDYXRlZ29yeS4oc2VhcmNoX2JvdW5kYXJ5ICsrIGluZXhpc3RhbnQpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBDYXRlZ29yeS4oc2VhcmNoX2JvdW5kYXJ5ICsrIGNhdGVnb3J5IHJlIH5jb2xvcjooZ2V0X2NvbG9yIHJlIHMgbGFzdCkpXG4gICAgICBpblxuICAgICAgbGV0IChpZHgsIHJlcykgPSBmaW5hbCBpbmZvIHN0IGZpbmFsX2NhdCBpblxuICAgICAgaWYgZ3JvdXBzIHRoZW4gaW5mby5wb3NpdGlvbnMuKGlkeCkgPC0gbGFzdCArIDE7XG4gICAgICByZXNcbiAgaW5cbiAgbWF0Y2ggcmVzIHdpdGhcbiAgICBBdXRvbWF0YS5NYXRjaCAobWFya3MsIHBtYXJrcykgLT5cbiAgICBNYXRjaCB7IHMgOyBtYXJrczsgcG1hcmtzIDsgZ3BvcyA9IGluZm8ucG9zaXRpb25zOyBnY291bnQgPSByZS5ncm91cF9jb3VudH1cbiAgfCBBdXRvbWF0YS5GYWlsZWQgLT4gRmFpbGVkXG4gIHwgQXV0b21hdGEuUnVubmluZyAtPiBSdW5uaW5nXG5cbmxldCBta19yZSB+aW5pdGlhbCB+Y29sb3JzIH5jb2xvcl9yZXByIH5uY29sb3IgfmxubCB+Z3JvdXBfY291bnQgPVxuICB7IGluaXRpYWwgO1xuICAgIGluaXRpYWxfc3RhdGVzID0gW107XG4gICAgY29sb3JzO1xuICAgIGNvbG9yX3JlcHI7XG4gICAgbmNvbG9yO1xuICAgIGxubDtcbiAgICB0YmwgPSBBdXRvbWF0YS5jcmVhdGVfd29ya2luZ19hcmVhICgpO1xuICAgIHN0YXRlcyA9IEF1dG9tYXRhLlN0YXRlLlRhYmxlLmNyZWF0ZSA5NztcbiAgICBncm91cF9jb3VudCB9XG5cbigqKioqIENoYXJhY3RlciBzZXRzICoqKiopXG5cbmxldCBjc2VxIGMgYycgPSBDc2V0LnNlcSAoQ2hhci5jb2RlIGMpIChDaGFyLmNvZGUgYycpXG5sZXQgY2FkZCBjIHMgPSBDc2V0LmFkZCAoQ2hhci5jb2RlIGMpIHNcblxubGV0IHRyYW5zX3NldCBjYWNoZSBjbSBzID1cbiAgbWF0Y2ggQ3NldC5vbmVfY2hhciBzIHdpdGhcbiAgfCBTb21lIGkgLT4gQ3NldC5jc2luZ2xlIChCeXRlcy5nZXQgY20gaSlcbiAgfCBOb25lIC0+XG4gICAgbGV0IHYgPSAoQ3NldC5oYXNoX3JlYyBzLCBzKSBpblxuICAgIHRyeVxuICAgICAgQ3NldC5DU2V0TWFwLmZpbmQgdiAhY2FjaGVcbiAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgbGV0IGwgPVxuICAgICAgICBDc2V0LmZvbGRfcmlnaHRcbiAgICAgICAgICBzXG4gICAgICAgICAgfmY6KGZ1biAoaSwgaikgbCAtPiBDc2V0LnVuaW9uIChjc2VxIChCeXRlcy5nZXQgY20gaSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKEJ5dGVzLmdldCBjbSBqKSkgbClcbiAgICAgICAgICB+aW5pdDpDc2V0LmVtcHR5XG4gICAgICBpblxuICAgICAgY2FjaGUgOj0gQ3NldC5DU2V0TWFwLmFkZCB2IGwgIWNhY2hlO1xuICAgICAgbFxuXG4oKioqKilcblxudHlwZSByZWdleHAgPVxuICAgIFNldCBvZiBDc2V0LnRcbiAgfCBTZXF1ZW5jZSBvZiByZWdleHAgbGlzdFxuICB8IEFsdGVybmF0aXZlIG9mIHJlZ2V4cCBsaXN0XG4gIHwgUmVwZWF0IG9mIHJlZ2V4cCAqIGludCAqIGludCBvcHRpb25cbiAgfCBCZWdfb2ZfbGluZSB8IEVuZF9vZl9saW5lXG4gIHwgQmVnX29mX3dvcmQgfCBFbmRfb2Zfd29yZCB8IE5vdF9ib3VuZFxuICB8IEJlZ19vZl9zdHIgfCBFbmRfb2Zfc3RyXG4gIHwgTGFzdF9lbmRfb2ZfbGluZSB8IFN0YXJ0IHwgU3RvcFxuICB8IFNlbSBvZiBBdXRvbWF0YS5zZW0gKiByZWdleHBcbiAgfCBTZW1fZ3JlZWR5IG9mIEF1dG9tYXRhLnJlcF9raW5kICogcmVnZXhwXG4gIHwgR3JvdXAgb2YgcmVnZXhwIHwgTm9fZ3JvdXAgb2YgcmVnZXhwIHwgTmVzdCBvZiByZWdleHBcbiAgfCBDYXNlIG9mIHJlZ2V4cCB8IE5vX2Nhc2Ugb2YgcmVnZXhwXG4gIHwgSW50ZXJzZWN0aW9uIG9mIHJlZ2V4cCBsaXN0XG4gIHwgQ29tcGxlbWVudCBvZiByZWdleHAgbGlzdFxuICB8IERpZmZlcmVuY2Ugb2YgcmVnZXhwICogcmVnZXhwXG4gIHwgUG1hcmsgb2YgUG1hcmsudCAqIHJlZ2V4cFxuXG5tb2R1bGUgVmlldyA9IHN0cnVjdFxuICB0eXBlIHQgPSByZWdleHAgPVxuICAgICAgU2V0IG9mIENzZXQudFxuICAgIHwgU2VxdWVuY2Ugb2YgcmVnZXhwIGxpc3RcbiAgICB8IEFsdGVybmF0aXZlIG9mIHJlZ2V4cCBsaXN0XG4gICAgfCBSZXBlYXQgb2YgcmVnZXhwICogaW50ICogaW50IG9wdGlvblxuICAgIHwgQmVnX29mX2xpbmUgfCBFbmRfb2ZfbGluZVxuICAgIHwgQmVnX29mX3dvcmQgfCBFbmRfb2Zfd29yZCB8IE5vdF9ib3VuZFxuICAgIHwgQmVnX29mX3N0ciB8IEVuZF9vZl9zdHJcbiAgICB8IExhc3RfZW5kX29mX2xpbmUgfCBTdGFydCB8IFN0b3BcbiAgICB8IFNlbSBvZiBBdXRvbWF0YS5zZW0gKiByZWdleHBcbiAgICB8IFNlbV9ncmVlZHkgb2YgQXV0b21hdGEucmVwX2tpbmQgKiByZWdleHBcbiAgICB8IEdyb3VwIG9mIHJlZ2V4cCB8IE5vX2dyb3VwIG9mIHJlZ2V4cCB8IE5lc3Qgb2YgcmVnZXhwXG4gICAgfCBDYXNlIG9mIHJlZ2V4cCB8IE5vX2Nhc2Ugb2YgcmVnZXhwXG4gICAgfCBJbnRlcnNlY3Rpb24gb2YgcmVnZXhwIGxpc3RcbiAgICB8IENvbXBsZW1lbnQgb2YgcmVnZXhwIGxpc3RcbiAgICB8IERpZmZlcmVuY2Ugb2YgcmVnZXhwICogcmVnZXhwXG4gICAgfCBQbWFyayBvZiBQbWFyay50ICogcmVnZXhwXG5cbiAgbGV0IHZpZXcgdCA9IHRcbmVuZFxuXG5sZXQgcmVjIHBwIGZtdCB0ID1cbiAgbGV0IG9wZW4gRm10IGluXG4gIGxldCB2YXIgcyByZSA9IHNleHAgZm10IHMgcHAgcmUgaW5cbiAgbGV0IHNlcSBzIHJlbCA9IHNleHAgZm10IHMgKGxpc3QgcHApIHJlbCBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXQgcyAtPiAgc2V4cCBmbXQgXCJTZXRcIiBDc2V0LnBwIHNcbiAgfCBTZXF1ZW5jZSBzcSAtPiBzZXEgXCJTZXF1ZW5jZVwiIHNxXG4gIHwgQWx0ZXJuYXRpdmUgYWx0IC0+IHNlcSBcIkFsdGVybmF0aXZlXCIgYWx0XG4gIHwgUmVwZWF0IChyZSwgc3RhcnQsIHN0b3ApIC0+XG4gICAgbGV0IHBwJyBmbXQgKCkgPSBmcHJpbnRmIGZtdCBcIiVhQCAlZCVhXCIgcHAgcmUgICBzdGFydCAgIG9wdGludCBzdG9wIGluXG4gICAgc2V4cCBmbXQgXCJSZXBlYXRcIiBwcCcgKClcbiAgfCBCZWdfb2ZfbGluZSAgICAgIC0+IHN0ciBmbXQgXCJCZWdfb2ZfbGluZVwiXG4gIHwgRW5kX29mX2xpbmUgICAgICAtPiBzdHIgZm10IFwiRW5kX29mX2xpbmVcIlxuICB8IEJlZ19vZl93b3JkICAgICAgLT4gc3RyIGZtdCBcIkJlZ19vZl93b3JkXCJcbiAgfCBFbmRfb2Zfd29yZCAgICAgIC0+IHN0ciBmbXQgXCJFbmRfb2Zfd29yZFwiXG4gIHwgTm90X2JvdW5kICAgICAgICAtPiBzdHIgZm10IFwiTm90X2JvdW5kXCJcbiAgfCBCZWdfb2Zfc3RyICAgICAgIC0+IHN0ciBmbXQgXCJCZWdfb2Zfc3RyXCJcbiAgfCBFbmRfb2Zfc3RyICAgICAgIC0+IHN0ciBmbXQgXCJFbmRfb2Zfc3RyXCJcbiAgfCBMYXN0X2VuZF9vZl9saW5lIC0+IHN0ciBmbXQgXCJMYXN0X2VuZF9vZl9saW5lXCJcbiAgfCBTdGFydCAgICAgICAgICAgIC0+IHN0ciBmbXQgXCJTdGFydFwiXG4gIHwgU3RvcCAgICAgICAgICAgICAtPiBzdHIgZm10IFwiU3RvcFwiXG4gIHwgU2VtIChzZW0sIHJlKSAgICAtPlxuICAgIHNleHAgZm10IFwiU2VtXCIgKHBhaXIgQXV0b21hdGEucHBfc2VtIHBwKSAoc2VtLCByZSlcbiAgfCBTZW1fZ3JlZWR5IChrLCByZSkgLT5cbiAgICBzZXhwIGZtdCBcIlNlbV9ncmVlZHlcIiAocGFpciBBdXRvbWF0YS5wcF9yZXBfa2luZCBwcCkgKGssIHJlKVxuICB8IEdyb3VwIGMgICAgICAgIC0+IHZhciBcIkdyb3VwXCIgY1xuICB8IE5vX2dyb3VwIGMgICAgIC0+IHZhciBcIk5vX2dyb3VwXCIgY1xuICB8IE5lc3QgYyAgICAgICAgIC0+IHZhciBcIk5lc3RcIiBjXG4gIHwgQ2FzZSBjICAgICAgICAgLT4gdmFyIFwiQ2FzZVwiIGNcbiAgfCBOb19jYXNlIGMgICAgICAtPiB2YXIgXCJOb19jYXNlXCIgY1xuICB8IEludGVyc2VjdGlvbiBjIC0+IHNlcSBcIkludGVyc2VjdGlvblwiIGNcbiAgfCBDb21wbGVtZW50IGMgICAtPiBzZXEgXCJDb21wbGVtZW50XCIgY1xuICB8IERpZmZlcmVuY2UgKGEsIGIpIC0+IHNleHAgZm10IFwiRGlmZmVyZW5jZVwiIChwYWlyIHBwIHBwKSAoYSwgYilcbiAgfCBQbWFyayAobSwgcikgICAgICAtPiBzZXhwIGZtdCBcIlBtYXJrXCIgKHBhaXIgUG1hcmsucHAgcHApIChtLCByKVxuXG5sZXQgcmVjIGlzX2NoYXJzZXQgPSBmdW5jdGlvblxuICB8IFNldCBfIC0+XG4gICAgdHJ1ZVxuICB8IEFsdGVybmF0aXZlIGwgfCBJbnRlcnNlY3Rpb24gbCB8IENvbXBsZW1lbnQgbCAtPlxuICAgIExpc3QuZm9yX2FsbCBpc19jaGFyc2V0IGxcbiAgfCBEaWZmZXJlbmNlIChyLCByJykgLT5cbiAgICBpc19jaGFyc2V0IHIgJiYgaXNfY2hhcnNldCByJ1xuICB8IFNlbSAoXywgcikgfCBTZW1fZ3JlZWR5IChfLCByKVxuICB8IE5vX2dyb3VwIHIgfCBDYXNlIHIgfCBOb19jYXNlIHIgLT5cbiAgICBpc19jaGFyc2V0IHJcbiAgfCBTZXF1ZW5jZSBfIHwgUmVwZWF0IF8gfCBCZWdfb2ZfbGluZSB8IEVuZF9vZl9saW5lXG4gIHwgQmVnX29mX3dvcmQgfCBFbmRfb2Zfd29yZCB8IEJlZ19vZl9zdHIgfCBFbmRfb2Zfc3RyXG4gIHwgTm90X2JvdW5kIHwgTGFzdF9lbmRfb2ZfbGluZSB8IFN0YXJ0IHwgU3RvcFxuICB8IEdyb3VwIF8gfCBOZXN0IF8gfCBQbWFyayAoXyxfKS0+XG4gICAgZmFsc2VcblxuKCpYWFggVXNlIGEgYmV0dGVyIGFsZ29yaXRobSBhbGxvd2luZyBub24tY29udGlndW91cyByZWdpb25zPyAqKVxuXG5sZXQgY3VwcGVyID1cbiAgQ3NldC51bmlvbiAoY3NlcSAnQScgJ1onKVxuICAgIChDc2V0LnVuaW9uIChjc2VxICdcXDE5MicgJ1xcMjE0JykgKGNzZXEgJ1xcMjE2JyAnXFwyMjInKSlcbmxldCBjbG93ZXIgPSBDc2V0Lm9mZnNldCAzMiBjdXBwZXJcbmxldCBjYWxwaGEgPVxuICBMaXN0LmZvbGRfcmlnaHQgY2FkZCBbJ1xcMTcwJzsgJ1xcMTgxJzsgJ1xcMTg2JzsgJ1xcMjIzJzsgJ1xcMjU1J11cbiAgICAoQ3NldC51bmlvbiBjbG93ZXIgY3VwcGVyKVxubGV0IGNkaWdpdCA9IGNzZXEgJzAnICc5J1xubGV0IGNhbG51bSA9IENzZXQudW5pb24gY2FscGhhIGNkaWdpdFxubGV0IGN3b3JkID0gY2FkZCAnXycgY2FsbnVtXG5cbmxldCBjb2xvcml6ZSBjIHJlZ2V4cCA9XG4gIGxldCBsbmwgPSByZWYgZmFsc2UgaW5cbiAgbGV0IHJlYyBjb2xvcml6ZSByZWdleHAgPVxuICAgIG1hdGNoIHJlZ2V4cCB3aXRoXG4gICAgICBTZXQgcyAgICAgICAgICAgICAgICAgICAgIC0+IENvbG9yX21hcC5zcGxpdCBzIGNcbiAgICB8IFNlcXVlbmNlIGwgICAgICAgICAgICAgICAgLT4gTGlzdC5pdGVyIGNvbG9yaXplIGxcbiAgICB8IEFsdGVybmF0aXZlIGwgICAgICAgICAgICAgLT4gTGlzdC5pdGVyIGNvbG9yaXplIGxcbiAgICB8IFJlcGVhdCAociwgXywgXykgICAgICAgICAgLT4gY29sb3JpemUgclxuICAgIHwgQmVnX29mX2xpbmUgfCBFbmRfb2ZfbGluZSAtPiBDb2xvcl9tYXAuc3BsaXQgKENzZXQuY3NpbmdsZSAnXFxuJykgY1xuICAgIHwgQmVnX29mX3dvcmQgfCBFbmRfb2Zfd29yZFxuICAgIHwgTm90X2JvdW5kICAgICAgICAgICAgICAgICAtPiBDb2xvcl9tYXAuc3BsaXQgY3dvcmQgY1xuICAgIHwgQmVnX29mX3N0ciB8IEVuZF9vZl9zdHJcbiAgICB8IFN0YXJ0IHwgU3RvcCAgICAgICAgICAgICAgLT4gKClcbiAgICB8IExhc3RfZW5kX29mX2xpbmUgICAgICAgICAgLT4gbG5sIDo9IHRydWVcbiAgICB8IFNlbSAoXywgcilcbiAgICB8IFNlbV9ncmVlZHkgKF8sIHIpXG4gICAgfCBHcm91cCByIHwgTm9fZ3JvdXAgclxuICAgIHwgTmVzdCByIHwgUG1hcmsgKF8scikgICAgIC0+IGNvbG9yaXplIHJcbiAgICB8IENhc2UgXyB8IE5vX2Nhc2UgX1xuICAgIHwgSW50ZXJzZWN0aW9uIF9cbiAgICB8IENvbXBsZW1lbnQgX1xuICAgIHwgRGlmZmVyZW5jZSBfICAgICAgICAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgaW5cbiAgY29sb3JpemUgcmVnZXhwO1xuICAhbG5sXG5cbigqKioqIENvbXBpbGF0aW9uICoqKiopXG5cbmxldCByZWMgZXF1YWwgeDEgeDIgPVxuICBtYXRjaCB4MSwgeDIgd2l0aFxuICAgIFNldCBzMSwgU2V0IHMyIC0+XG4gICAgczEgPSBzMlxuICB8IFNlcXVlbmNlIGwxLCBTZXF1ZW5jZSBsMiAtPlxuICAgIGVxX2xpc3QgbDEgbDJcbiAgfCBBbHRlcm5hdGl2ZSBsMSwgQWx0ZXJuYXRpdmUgbDIgLT5cbiAgICBlcV9saXN0IGwxIGwyXG4gIHwgUmVwZWF0ICh4MScsIGkxLCBqMSksIFJlcGVhdCAoeDInLCBpMiwgajIpIC0+XG4gICAgaTEgPSBpMiAmJiBqMSA9IGoyICYmIGVxdWFsIHgxJyB4MidcbiAgfCBCZWdfb2ZfbGluZSwgQmVnX29mX2xpbmVcbiAgfCBFbmRfb2ZfbGluZSwgRW5kX29mX2xpbmVcbiAgfCBCZWdfb2Zfd29yZCwgQmVnX29mX3dvcmRcbiAgfCBFbmRfb2Zfd29yZCwgRW5kX29mX3dvcmRcbiAgfCBOb3RfYm91bmQsIE5vdF9ib3VuZFxuICB8IEJlZ19vZl9zdHIsIEJlZ19vZl9zdHJcbiAgfCBFbmRfb2Zfc3RyLCBFbmRfb2Zfc3RyXG4gIHwgTGFzdF9lbmRfb2ZfbGluZSwgTGFzdF9lbmRfb2ZfbGluZVxuICB8IFN0YXJ0LCBTdGFydFxuICB8IFN0b3AsIFN0b3AgLT5cbiAgICB0cnVlXG4gIHwgU2VtIChzZW0xLCB4MScpLCBTZW0gKHNlbTIsIHgyJykgLT5cbiAgICBzZW0xID0gc2VtMiAmJiBlcXVhbCB4MScgeDInXG4gIHwgU2VtX2dyZWVkeSAoazEsIHgxJyksIFNlbV9ncmVlZHkgKGsyLCB4MicpIC0+XG4gICAgazEgPSBrMiAmJiBlcXVhbCB4MScgeDInXG4gIHwgR3JvdXAgXywgR3JvdXAgXyAtPiAoKiBEbyBub3QgbWVyZ2UgZ3JvdXBzISAqKVxuICAgIGZhbHNlXG4gIHwgTm9fZ3JvdXAgeDEnLCBOb19ncm91cCB4MicgLT5cbiAgICBlcXVhbCB4MScgeDInXG4gIHwgTmVzdCB4MScsIE5lc3QgeDInIC0+XG4gICAgZXF1YWwgeDEnIHgyJ1xuICB8IENhc2UgeDEnLCBDYXNlIHgyJyAtPlxuICAgIGVxdWFsIHgxJyB4MidcbiAgfCBOb19jYXNlIHgxJywgTm9fY2FzZSB4MicgLT5cbiAgICBlcXVhbCB4MScgeDInXG4gIHwgSW50ZXJzZWN0aW9uIGwxLCBJbnRlcnNlY3Rpb24gbDIgLT5cbiAgICBlcV9saXN0IGwxIGwyXG4gIHwgQ29tcGxlbWVudCBsMSwgQ29tcGxlbWVudCBsMiAtPlxuICAgIGVxX2xpc3QgbDEgbDJcbiAgfCBEaWZmZXJlbmNlICh4MScsIHgxJycpLCBEaWZmZXJlbmNlICh4MicsIHgyJycpIC0+XG4gICAgZXF1YWwgeDEnIHgyJyAmJiBlcXVhbCB4MScnIHgyJydcbiAgfCBQbWFyayAobTEsIHIxKSwgUG1hcmsgKG0yLCByMikgLT5cbiAgICBQbWFyay5lcXVhbCBtMSBtMiAmJiBlcXVhbCByMSByMlxuICB8IF8gLT5cbiAgICBmYWxzZVxuXG5hbmQgZXFfbGlzdCBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgW10sIFtdIC0+XG4gICAgdHJ1ZVxuICB8IHgxIDo6IHIxLCB4MiA6OiByMiAtPlxuICAgIGVxdWFsIHgxIHgyICYmIGVxX2xpc3QgcjEgcjJcbiAgfCBfIC0+XG4gICAgZmFsc2VcblxubGV0IHNlcXVlbmNlID0gZnVuY3Rpb25cbiAgfCBbeF0gLT4geFxuICB8IGwgICAtPiBTZXF1ZW5jZSBsXG5cbmxldCByZWMgbWVyZ2Vfc2VxdWVuY2VzID0gZnVuY3Rpb25cbiAgfCBbXSAtPlxuICAgIFtdXG4gIHwgQWx0ZXJuYXRpdmUgbCcgOjogciAtPlxuICAgIG1lcmdlX3NlcXVlbmNlcyAobCcgQCByKVxuICB8IFNlcXVlbmNlICh4IDo6IHkpIDo6IHIgLT5cbiAgICBiZWdpbiBtYXRjaCBtZXJnZV9zZXF1ZW5jZXMgciB3aXRoXG4gICAgICAgIFNlcXVlbmNlICh4JyA6OiB5JykgOjogcicgd2hlbiBlcXVhbCB4IHgnIC0+XG4gICAgICAgIFNlcXVlbmNlIFt4OyBBbHRlcm5hdGl2ZSBbc2VxdWVuY2UgeTsgc2VxdWVuY2UgeSddXSA6OiByJ1xuICAgICAgfCByJyAtPlxuICAgICAgICBTZXF1ZW5jZSAoeCA6OiB5KSA6OiByJ1xuICAgIGVuZFxuICB8IHggOjogciAtPlxuICAgIHggOjogbWVyZ2Vfc2VxdWVuY2VzIHJcblxubW9kdWxlIEEgPSBBdXRvbWF0YVxuXG5sZXQgZW5mb3JjZV9raW5kIGlkcyBraW5kIGtpbmQnIGNyID1cbiAgbWF0Y2gga2luZCwga2luZCcgd2l0aFxuICAgIGBGaXJzdCwgYEZpcnN0IC0+IGNyXG4gIHwgYEZpcnN0LCBrICAgICAgIC0+IEEuc2VxIGlkcyBrIGNyIChBLmVwcyBpZHMpXG4gIHwgIF8gICAgICAgICAgICAgICAtPiBjclxuXG4oKiBYWFggc2hvdWxkIHByb2JhYmx5IGNvbXB1dGUgYSBjYXRlZ29yeSBtYXNrICopXG5sZXQgcmVjIHRyYW5zbGF0ZSBpZHMga2luZCBpZ25fZ3JvdXAgaWduX2Nhc2UgZ3JlZWR5IHBvcyBjYWNoZSBjID0gZnVuY3Rpb25cbiAgfCBTZXQgcyAtPlxuICAgIChBLmNzdCBpZHMgKHRyYW5zX3NldCBjYWNoZSBjIHMpLCBraW5kKVxuICB8IFNlcXVlbmNlIGwgLT5cbiAgICAodHJhbnNfc2VxIGlkcyBraW5kIGlnbl9ncm91cCBpZ25fY2FzZSBncmVlZHkgcG9zIGNhY2hlIGMgbCwga2luZClcbiAgfCBBbHRlcm5hdGl2ZSBsIC0+XG4gICAgYmVnaW4gbWF0Y2ggbWVyZ2Vfc2VxdWVuY2VzIGwgd2l0aFxuICAgICAgICBbciddIC0+XG4gICAgICAgIGxldCAoY3IsIGtpbmQnKSA9XG4gICAgICAgICAgdHJhbnNsYXRlIGlkcyBraW5kIGlnbl9ncm91cCBpZ25fY2FzZSBncmVlZHkgcG9zIGNhY2hlIGMgcicgaW5cbiAgICAgICAgKGVuZm9yY2Vfa2luZCBpZHMga2luZCBraW5kJyBjciwga2luZClcbiAgICAgIHwgbWVyZ2VkX3NlcXVlbmNlcyAtPlxuICAgICAgICAoQS5hbHQgaWRzXG4gICAgICAgICAgIChMaXN0Lm1hcFxuICAgICAgICAgICAgICAoZnVuIHInIC0+XG4gICAgICAgICAgICAgICAgIGxldCAoY3IsIGtpbmQnKSA9XG4gICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlIGlkcyBraW5kIGlnbl9ncm91cCBpZ25fY2FzZSBncmVlZHlcbiAgICAgICAgICAgICAgICAgICAgIHBvcyBjYWNoZSBjIHInIGluXG4gICAgICAgICAgICAgICAgIGVuZm9yY2Vfa2luZCBpZHMga2luZCBraW5kJyBjcilcbiAgICAgICAgICAgICAgbWVyZ2VkX3NlcXVlbmNlcyksXG4gICAgICAgICBraW5kKVxuICAgIGVuZFxuICB8IFJlcGVhdCAocicsIGksIGopIC0+XG4gICAgbGV0IChjciwga2luZCcpID1cbiAgICAgIHRyYW5zbGF0ZSBpZHMga2luZCBpZ25fZ3JvdXAgaWduX2Nhc2UgZ3JlZWR5IHBvcyBjYWNoZSBjIHInIGluXG4gICAgbGV0IHJlbSA9XG4gICAgICBtYXRjaCBqIHdpdGhcbiAgICAgICAgTm9uZSAtPlxuICAgICAgICBBLnJlcCBpZHMgZ3JlZWR5IGtpbmQnIGNyXG4gICAgICB8IFNvbWUgaiAtPlxuICAgICAgICBsZXQgZiA9XG4gICAgICAgICAgbWF0Y2ggZ3JlZWR5IHdpdGhcbiAgICAgICAgICAgIGBHcmVlZHkgLT5cbiAgICAgICAgICAgIGZ1biByZW0gLT5cbiAgICAgICAgICAgICAgQS5hbHQgaWRzXG4gICAgICAgICAgICAgICAgW0Euc2VxIGlkcyBraW5kJyAoQS5yZW5hbWUgaWRzIGNyKSByZW07IEEuZXBzIGlkc11cbiAgICAgICAgICB8IGBOb25fZ3JlZWR5IC0+XG4gICAgICAgICAgICBmdW4gcmVtIC0+XG4gICAgICAgICAgICAgIEEuYWx0IGlkc1xuICAgICAgICAgICAgICAgIFtBLmVwcyBpZHM7IEEuc2VxIGlkcyBraW5kJyAoQS5yZW5hbWUgaWRzIGNyKSByZW1dXG4gICAgICAgIGluXG4gICAgICAgIGl0ZXIgKGogLSBpKSBmIChBLmVwcyBpZHMpXG4gICAgaW5cbiAgICAoaXRlciBpIChmdW4gcmVtIC0+IEEuc2VxIGlkcyBraW5kJyAoQS5yZW5hbWUgaWRzIGNyKSByZW0pIHJlbSwga2luZClcbiAgfCBCZWdfb2ZfbGluZSAtPlxuICAgIChBLmFmdGVyIGlkcyBDYXRlZ29yeS4oaW5leGlzdGFudCArKyBuZXdsaW5lKSwga2luZClcbiAgfCBFbmRfb2ZfbGluZSAtPlxuICAgIChBLmJlZm9yZSBpZHMgQ2F0ZWdvcnkuKGluZXhpc3RhbnQgKysgbmV3bGluZSksIGtpbmQpXG4gIHwgQmVnX29mX3dvcmQgLT5cbiAgICAoQS5zZXEgaWRzIGBGaXJzdFxuICAgICAgIChBLmFmdGVyIGlkcyBDYXRlZ29yeS4oaW5leGlzdGFudCArKyBub3RfbGV0dGVyKSlcbiAgICAgICAoQS5iZWZvcmUgaWRzIENhdGVnb3J5LmxldHRlciksXG4gICAgIGtpbmQpXG4gIHwgRW5kX29mX3dvcmQgLT5cbiAgICAoQS5zZXEgaWRzIGBGaXJzdFxuICAgICAgIChBLmFmdGVyIGlkcyBDYXRlZ29yeS5sZXR0ZXIpXG4gICAgICAgKEEuYmVmb3JlIGlkcyBDYXRlZ29yeS4oaW5leGlzdGFudCArKyBub3RfbGV0dGVyKSksXG4gICAgIGtpbmQpXG4gIHwgTm90X2JvdW5kIC0+XG4gICAgKEEuYWx0IGlkcyBbQS5zZXEgaWRzIGBGaXJzdFxuICAgICAgICAgICAgICAgICAgKEEuYWZ0ZXIgaWRzIENhdGVnb3J5LmxldHRlcilcbiAgICAgICAgICAgICAgICAgIChBLmJlZm9yZSBpZHMgQ2F0ZWdvcnkubGV0dGVyKTtcbiAgICAgICAgICAgICAgICBBLnNlcSBpZHMgYEZpcnN0XG4gICAgICAgICAgICAgICAgICAoQS5hZnRlciBpZHMgQ2F0ZWdvcnkuKGluZXhpc3RhbnQgKysgbm90X2xldHRlcikpXG4gICAgICAgICAgICAgICAgICAoQS5iZWZvcmUgaWRzIENhdGVnb3J5LihpbmV4aXN0YW50ICsrIG5vdF9sZXR0ZXIpKV0sXG4gICAgIGtpbmQpXG4gIHwgQmVnX29mX3N0ciAtPlxuICAgIChBLmFmdGVyIGlkcyBDYXRlZ29yeS5pbmV4aXN0YW50LCBraW5kKVxuICB8IEVuZF9vZl9zdHIgLT5cbiAgICAoQS5iZWZvcmUgaWRzIENhdGVnb3J5LmluZXhpc3RhbnQsIGtpbmQpXG4gIHwgTGFzdF9lbmRfb2ZfbGluZSAtPlxuICAgIChBLmJlZm9yZSBpZHMgQ2F0ZWdvcnkuKGluZXhpc3RhbnQgKysgbGFzdG5ld2xpbmUpLCBraW5kKVxuICB8IFN0YXJ0IC0+XG4gICAgKEEuYWZ0ZXIgaWRzIENhdGVnb3J5LnNlYXJjaF9ib3VuZGFyeSwga2luZClcbiAgfCBTdG9wIC0+XG4gICAgKEEuYmVmb3JlIGlkcyBDYXRlZ29yeS5zZWFyY2hfYm91bmRhcnksIGtpbmQpXG4gIHwgU2VtIChraW5kJywgcicpIC0+XG4gICAgbGV0IChjciwga2luZCcnKSA9XG4gICAgICB0cmFuc2xhdGUgaWRzIGtpbmQnIGlnbl9ncm91cCBpZ25fY2FzZSBncmVlZHkgcG9zIGNhY2hlIGMgcicgaW5cbiAgICAoZW5mb3JjZV9raW5kIGlkcyBraW5kJyBraW5kJycgY3IsXG4gICAgIGtpbmQnKVxuICB8IFNlbV9ncmVlZHkgKGdyZWVkeScsIHInKSAtPlxuICAgIHRyYW5zbGF0ZSBpZHMga2luZCBpZ25fZ3JvdXAgaWduX2Nhc2UgZ3JlZWR5JyBwb3MgY2FjaGUgYyByJ1xuICB8IEdyb3VwIHInIC0+XG4gICAgaWYgaWduX2dyb3VwIHRoZW5cbiAgICAgIHRyYW5zbGF0ZSBpZHMga2luZCBpZ25fZ3JvdXAgaWduX2Nhc2UgZ3JlZWR5IHBvcyBjYWNoZSBjIHInXG4gICAgZWxzZVxuICAgICAgbGV0IHAgPSAhcG9zIGluXG4gICAgICBwb3MgOj0gIXBvcyArIDI7XG4gICAgICBsZXQgKGNyLCBraW5kJykgPVxuICAgICAgICB0cmFuc2xhdGUgaWRzIGtpbmQgaWduX2dyb3VwIGlnbl9jYXNlIGdyZWVkeSBwb3MgY2FjaGUgYyByJyBpblxuICAgICAgKEEuc2VxIGlkcyBgRmlyc3QgKEEubWFyayBpZHMgcCkgKFxuICAgICAgICAgIEEuc2VxIGlkcyBgRmlyc3QgY3IgKEEubWFyayBpZHMgKHAgKyAxKSkpLFxuICAgICAgIGtpbmQnKVxuICB8IE5vX2dyb3VwIHInIC0+XG4gICAgdHJhbnNsYXRlIGlkcyBraW5kIHRydWUgaWduX2Nhc2UgZ3JlZWR5IHBvcyBjYWNoZSBjIHInXG4gIHwgTmVzdCByJyAtPlxuICAgIGxldCBiID0gIXBvcyBpblxuICAgIGxldCAoY3IsIGtpbmQnKSA9XG4gICAgICB0cmFuc2xhdGUgaWRzIGtpbmQgaWduX2dyb3VwIGlnbl9jYXNlIGdyZWVkeSBwb3MgY2FjaGUgYyByJ1xuICAgIGluXG4gICAgbGV0IGUgPSAhcG9zIC0gMSBpblxuICAgIGlmIGUgPCBiIHRoZW5cbiAgICAgIChjciwga2luZCcpXG4gICAgZWxzZVxuICAgICAgKEEuc2VxIGlkcyBgRmlyc3QgKEEuZXJhc2UgaWRzIGIgZSkgY3IsIGtpbmQnKVxuICB8IERpZmZlcmVuY2UgXyB8IENvbXBsZW1lbnQgXyB8IEludGVyc2VjdGlvbiBfIHwgTm9fY2FzZSBfIHwgQ2FzZSBfIC0+XG4gICAgYXNzZXJ0IGZhbHNlXG4gIHwgUG1hcmsgKGksIHInKSAtPlxuICAgIGxldCAoY3IsIGtpbmQnKSA9XG4gICAgICB0cmFuc2xhdGUgaWRzIGtpbmQgaWduX2dyb3VwIGlnbl9jYXNlIGdyZWVkeSBwb3MgY2FjaGUgYyByJyBpblxuICAgIChBLnNlcSBpZHMgYEZpcnN0IChBLnBtYXJrIGlkcyBpKSBjciwga2luZCcpXG5cbmFuZCB0cmFuc19zZXEgaWRzIGtpbmQgaWduX2dyb3VwIGlnbl9jYXNlIGdyZWVkeSBwb3MgY2FjaGUgYyA9IGZ1bmN0aW9uXG4gIHwgW10gLT5cbiAgICBBLmVwcyBpZHNcbiAgfCBbcl0gLT5cbiAgICBsZXQgKGNyJywga2luZCcpID1cbiAgICAgIHRyYW5zbGF0ZSBpZHMga2luZCBpZ25fZ3JvdXAgaWduX2Nhc2UgZ3JlZWR5IHBvcyBjYWNoZSBjIHIgaW5cbiAgICBlbmZvcmNlX2tpbmQgaWRzIGtpbmQga2luZCcgY3InXG4gIHwgciA6OiByZW0gLT5cbiAgICBsZXQgKGNyJywga2luZCcpID1cbiAgICAgIHRyYW5zbGF0ZSBpZHMga2luZCBpZ25fZ3JvdXAgaWduX2Nhc2UgZ3JlZWR5IHBvcyBjYWNoZSBjIHIgaW5cbiAgICBsZXQgY3InJyA9XG4gICAgICB0cmFuc19zZXEgaWRzIGtpbmQgaWduX2dyb3VwIGlnbl9jYXNlIGdyZWVkeSBwb3MgY2FjaGUgYyByZW0gaW5cbiAgICBpZiBBLmlzX2VwcyBjcicnIHRoZW5cbiAgICAgIGNyJ1xuICAgIGVsc2UgaWYgQS5pc19lcHMgY3InIHRoZW5cbiAgICAgIGNyJydcbiAgICBlbHNlXG4gICAgICBBLnNlcSBpZHMga2luZCcgY3InIGNyJydcblxuKCoqKiogQ2FzZSAqKioqKVxuXG5sZXQgY2FzZV9pbnNlbnMgcyA9XG4gIENzZXQudW5pb24gcyAoQ3NldC51bmlvbiAoQ3NldC5vZmZzZXQgMzIgKENzZXQuaW50ZXIgcyBjdXBwZXIpKVxuICAgICAgICAgICAgICAgICAgKENzZXQub2Zmc2V0ICgtMzIpIChDc2V0LmludGVyIHMgY2xvd2VyKSkpXG5cbmxldCBhc19zZXQgPSBmdW5jdGlvblxuICB8IFNldCBzIC0+IHNcbiAgfCBfICAgICAtPiBhc3NlcnQgZmFsc2VcblxuKCogWFhYIFNob3VsZCBzcGxpdCBhbHRlcm5hdGl2ZXMgaW50byAoMSkgY2hhcnNldHMgYW5kICgyKSBtb3JlXG4gICBjb21wbGV4IHJlZ3VsYXIgZXhwcmVzc2lvbnM7IGFsdGVybmF0aXZlIHNob3VsZCB0aGVyZWZvcmUgcHJvYmFibHlcbiAgIGJlIGZsYXR0ZW4gaGVyZSAqKVxubGV0IHJlYyBoYW5kbGVfY2FzZSBpZ25fY2FzZSA9IGZ1bmN0aW9uXG4gIHwgU2V0IHMgLT5cbiAgICBTZXQgKGlmIGlnbl9jYXNlIHRoZW4gY2FzZV9pbnNlbnMgcyBlbHNlIHMpXG4gIHwgU2VxdWVuY2UgbCAtPlxuICAgIFNlcXVlbmNlIChMaXN0Lm1hcCAoaGFuZGxlX2Nhc2UgaWduX2Nhc2UpIGwpXG4gIHwgQWx0ZXJuYXRpdmUgbCAtPlxuICAgIGxldCBsJyA9IExpc3QubWFwIChoYW5kbGVfY2FzZSBpZ25fY2FzZSkgbCBpblxuICAgIGlmIGlzX2NoYXJzZXQgKEFsdGVybmF0aXZlIGwnKSB0aGVuXG4gICAgICBTZXQgKExpc3QuZm9sZF9sZWZ0IChmdW4gcyByIC0+IENzZXQudW5pb24gcyAoYXNfc2V0IHIpKSBDc2V0LmVtcHR5IGwnKVxuICAgIGVsc2VcbiAgICAgIEFsdGVybmF0aXZlIGwnXG4gIHwgUmVwZWF0IChyLCBpLCBqKSAtPlxuICAgIFJlcGVhdCAoaGFuZGxlX2Nhc2UgaWduX2Nhc2UgciwgaSwgailcbiAgfCBCZWdfb2ZfbGluZSB8IEVuZF9vZl9saW5lIHwgQmVnX29mX3dvcmQgfCBFbmRfb2Zfd29yZCB8IE5vdF9ib3VuZFxuICB8IEJlZ19vZl9zdHIgfCBFbmRfb2Zfc3RyIHwgTGFzdF9lbmRfb2ZfbGluZSB8IFN0YXJ0IHwgU3RvcCBhcyByIC0+XG4gICAgclxuICB8IFNlbSAoaywgcikgLT5cbiAgICBsZXQgcicgPSBoYW5kbGVfY2FzZSBpZ25fY2FzZSByIGluXG4gICAgaWYgaXNfY2hhcnNldCByJyB0aGVuIHInIGVsc2UgU2VtIChrLCByJylcbiAgfCBTZW1fZ3JlZWR5IChrLCByKSAtPlxuICAgIGxldCByJyA9IGhhbmRsZV9jYXNlIGlnbl9jYXNlIHIgaW5cbiAgICBpZiBpc19jaGFyc2V0IHInIHRoZW4gcicgZWxzZSBTZW1fZ3JlZWR5IChrLCByJylcbiAgfCBHcm91cCByIC0+XG4gICAgR3JvdXAgKGhhbmRsZV9jYXNlIGlnbl9jYXNlIHIpXG4gIHwgTm9fZ3JvdXAgciAtPlxuICAgIGxldCByJyA9IGhhbmRsZV9jYXNlIGlnbl9jYXNlIHIgaW5cbiAgICBpZiBpc19jaGFyc2V0IHInIHRoZW4gcicgZWxzZSBOb19ncm91cCByJ1xuICB8IE5lc3QgciAtPlxuICAgIGxldCByJyA9IGhhbmRsZV9jYXNlIGlnbl9jYXNlIHIgaW5cbiAgICBpZiBpc19jaGFyc2V0IHInIHRoZW4gcicgZWxzZSBOZXN0IHInXG4gIHwgQ2FzZSByIC0+XG4gICAgaGFuZGxlX2Nhc2UgZmFsc2UgclxuICB8IE5vX2Nhc2UgciAtPlxuICAgIGhhbmRsZV9jYXNlIHRydWUgclxuICB8IEludGVyc2VjdGlvbiBsIC0+XG4gICAgbGV0IGwnID0gTGlzdC5tYXAgKGZ1biByIC0+IGhhbmRsZV9jYXNlIGlnbl9jYXNlIHIpIGwgaW5cbiAgICBTZXQgKExpc3QuZm9sZF9sZWZ0IChmdW4gcyByIC0+IENzZXQuaW50ZXIgcyAoYXNfc2V0IHIpKSBDc2V0LmNhbnkgbCcpXG4gIHwgQ29tcGxlbWVudCBsIC0+XG4gICAgbGV0IGwnID0gTGlzdC5tYXAgKGZ1biByIC0+IGhhbmRsZV9jYXNlIGlnbl9jYXNlIHIpIGwgaW5cbiAgICBTZXQgKENzZXQuZGlmZiBDc2V0LmNhbnlcbiAgICAgICAgICAgKExpc3QuZm9sZF9sZWZ0IChmdW4gcyByIC0+IENzZXQudW5pb24gcyAoYXNfc2V0IHIpKVxuICAgICAgICAgICAgICBDc2V0LmVtcHR5IGwnKSlcbiAgfCBEaWZmZXJlbmNlIChyLCByJykgLT5cbiAgICBTZXQgKENzZXQuaW50ZXIgKGFzX3NldCAoaGFuZGxlX2Nhc2UgaWduX2Nhc2UgcikpXG4gICAgICAgICAgIChDc2V0LmRpZmYgQ3NldC5jYW55IChhc19zZXQgKGhhbmRsZV9jYXNlIGlnbl9jYXNlIHInKSkpKVxuICB8IFBtYXJrIChpLHIpIC0+IFBtYXJrIChpLGhhbmRsZV9jYXNlIGlnbl9jYXNlIHIpXG5cbigqKioqKVxuXG5sZXQgY29tcGlsZV8xIHJlZ2V4cCA9XG4gIGxldCByZWdleHAgPSBoYW5kbGVfY2FzZSBmYWxzZSByZWdleHAgaW5cbiAgbGV0IGMgPSBDb2xvcl9tYXAubWFrZSAoKSBpblxuICBsZXQgbmVlZF9sbmwgPSBjb2xvcml6ZSBjIHJlZ2V4cCBpblxuICBsZXQgKGNvbG9ycywgY29sb3JfcmVwciwgbmNvbG9yKSA9IENvbG9yX21hcC5mbGF0dGVuIGMgaW5cbiAgbGV0IGxubCA9IGlmIG5lZWRfbG5sIHRoZW4gbmNvbG9yIGVsc2UgLTEgaW5cbiAgbGV0IG5jb2xvciA9IGlmIG5lZWRfbG5sIHRoZW4gbmNvbG9yICsgMSBlbHNlIG5jb2xvciBpblxuICBsZXQgaWRzID0gQS5jcmVhdGVfaWRzICgpIGluXG4gIGxldCBwb3MgPSByZWYgMCBpblxuICBsZXQgKHIsIGtpbmQpID1cbiAgICB0cmFuc2xhdGUgaWRzXG4gICAgICBgRmlyc3QgZmFsc2UgZmFsc2UgYEdyZWVkeSBwb3MgKHJlZiBDc2V0LkNTZXRNYXAuZW1wdHkpIGNvbG9ycyByZWdleHAgaW5cbiAgbGV0IHIgPSBlbmZvcmNlX2tpbmQgaWRzIGBGaXJzdCBraW5kIHIgaW5cbiAgKCpGb3JtYXQuZXByaW50ZiBcIjwlZCAlZD5ALlwiICFpZHMgbmNvbDsqKVxuICBta19yZSB+aW5pdGlhbDpyIH5jb2xvcnMgfmNvbG9yX3JlcHIgfm5jb2xvciB+bG5sIH5ncm91cF9jb3VudDooIXBvcyAvIDIpXG5cbigqKioqKVxuXG5sZXQgcmVjIGFuY2hvcmVkID0gZnVuY3Rpb25cbiAgfCBTZXF1ZW5jZSBsIC0+XG4gICAgTGlzdC5leGlzdHMgYW5jaG9yZWQgbFxuICB8IEFsdGVybmF0aXZlIGwgLT5cbiAgICBMaXN0LmZvcl9hbGwgYW5jaG9yZWQgbFxuICB8IFJlcGVhdCAociwgaSwgXykgLT5cbiAgICBpID4gMCAmJiBhbmNob3JlZCByXG4gIHwgU2V0IF8gfCBCZWdfb2ZfbGluZSB8IEVuZF9vZl9saW5lIHwgQmVnX29mX3dvcmQgfCBFbmRfb2Zfd29yZFxuICB8IE5vdF9ib3VuZCB8IEVuZF9vZl9zdHIgfCBMYXN0X2VuZF9vZl9saW5lIHwgU3RvcFxuICB8IEludGVyc2VjdGlvbiBfIHwgQ29tcGxlbWVudCBfIHwgRGlmZmVyZW5jZSBfIC0+XG4gICAgZmFsc2VcbiAgfCBCZWdfb2Zfc3RyIHwgU3RhcnQgLT5cbiAgICB0cnVlXG4gIHwgU2VtIChfLCByKSB8IFNlbV9ncmVlZHkgKF8sIHIpIHwgR3JvdXAgciB8IE5vX2dyb3VwIHIgfCBOZXN0IHJcbiAgfCBDYXNlIHIgfCBOb19jYXNlIHIgfCBQbWFyayAoXywgcikgLT5cbiAgICBhbmNob3JlZCByXG5cbigqKioqKVxuXG50eXBlIHQgPSByZWdleHBcblxubGV0IHN0ciBzID1cbiAgbGV0IGwgPSByZWYgW10gaW5cbiAgZm9yIGkgPSBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvd250byAwIGRvXG4gICAgbCA6PSBTZXQgKENzZXQuY3NpbmdsZSBzLltpXSkgOjogIWxcbiAgZG9uZTtcbiAgU2VxdWVuY2UgIWxcbmxldCBjaGFyIGMgPSBTZXQgKENzZXQuY3NpbmdsZSBjKVxuXG5sZXQgYWx0ID0gZnVuY3Rpb25cbiAgfCBbcl0gLT4gclxuICB8IGwgICAtPiBBbHRlcm5hdGl2ZSBsXG5sZXQgc2VxID0gZnVuY3Rpb25cbiAgfCBbcl0gLT4gclxuICB8IGwgICAtPiBTZXF1ZW5jZSBsXG5cbmxldCBlbXB0eSA9IGFsdCBbXVxubGV0IGVwc2lsb24gPSBzZXEgW11cbmxldCByZXBuIHIgaSBqID1cbiAgaWYgaSA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlJlLnJlcG5cIjtcbiAgYmVnaW4gbWF0Y2ggaiB3aXRoXG4gICAgfCBTb21lIGogd2hlbiBqIDwgaSAtPiBpbnZhbGlkX2FyZyBcIlJlLnJlcG5cIlxuICAgIHwgXyAtPiAoKVxuICBlbmQ7XG4gIFJlcGVhdCAociwgaSwgailcbmxldCByZXAgciA9IHJlcG4gciAwIE5vbmVcbmxldCByZXAxIHIgPSByZXBuIHIgMSBOb25lXG5sZXQgb3B0IHIgPSByZXBuIHIgMCAoU29tZSAxKVxubGV0IGJvbCA9IEJlZ19vZl9saW5lXG5sZXQgZW9sID0gRW5kX29mX2xpbmVcbmxldCBib3cgPSBCZWdfb2Zfd29yZFxubGV0IGVvdyA9IEVuZF9vZl93b3JkXG5sZXQgd29yZCByID0gc2VxIFtib3c7IHI7IGVvd11cbmxldCBub3RfYm91bmRhcnkgPSBOb3RfYm91bmRcbmxldCBib3MgPSBCZWdfb2Zfc3RyXG5sZXQgZW9zID0gRW5kX29mX3N0clxubGV0IHdob2xlX3N0cmluZyByID0gc2VxIFtib3M7IHI7IGVvc11cbmxldCBsZW9sID0gTGFzdF9lbmRfb2ZfbGluZVxubGV0IHN0YXJ0ID0gU3RhcnRcbmxldCBzdG9wID0gU3RvcFxubGV0IGxvbmdlc3QgciA9IFNlbSAoYExvbmdlc3QsIHIpXG5sZXQgc2hvcnRlc3QgciA9IFNlbSAoYFNob3J0ZXN0LCByKVxubGV0IGZpcnN0IHIgPSBTZW0gKGBGaXJzdCwgcilcbmxldCBncmVlZHkgciA9IFNlbV9ncmVlZHkgKGBHcmVlZHksIHIpXG5sZXQgbm9uX2dyZWVkeSByID0gU2VtX2dyZWVkeSAoYE5vbl9ncmVlZHksIHIpXG5sZXQgZ3JvdXAgciA9IEdyb3VwIHJcbmxldCBub19ncm91cCByID0gTm9fZ3JvdXAgclxubGV0IG5lc3QgciA9IE5lc3QgclxubGV0IG1hcmsgciA9IGxldCBpID0gUG1hcmsuZ2VuICgpIGluIChpLFBtYXJrIChpLHIpKVxuXG5sZXQgc2V0IHN0ciA9XG4gIGxldCBzID0gcmVmIENzZXQuZW1wdHkgaW5cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggc3RyIC0gMSBkb1xuICAgIHMgOj0gQ3NldC51bmlvbiAoQ3NldC5jc2luZ2xlIHN0ci5baV0pICFzXG4gIGRvbmU7XG4gIFNldCAhc1xuXG5sZXQgcmcgYyBjJyA9IFNldCAoY3NlcSBjIGMnKVxuXG5sZXQgaW50ZXIgbCA9XG4gIGxldCByID0gSW50ZXJzZWN0aW9uIGwgaW5cbiAgaWYgaXNfY2hhcnNldCByIHRoZW5cbiAgICByXG4gIGVsc2VcbiAgICBpbnZhbGlkX2FyZyBcIlJlLmludGVyXCJcblxubGV0IGNvbXBsIGwgPVxuICBsZXQgciA9IENvbXBsZW1lbnQgbCBpblxuICBpZiBpc19jaGFyc2V0IHIgdGhlblxuICAgIHJcbiAgZWxzZVxuICAgIGludmFsaWRfYXJnIFwiUmUuY29tcGxcIlxuXG5sZXQgZGlmZiByIHInID1cbiAgbGV0IHInJyA9IERpZmZlcmVuY2UgKHIsIHInKSBpblxuICBpZiBpc19jaGFyc2V0IHInJyB0aGVuXG4gICAgcicnXG4gIGVsc2VcbiAgICBpbnZhbGlkX2FyZyBcIlJlLmRpZmZcIlxuXG5sZXQgYW55ID0gU2V0IENzZXQuY2FueVxubGV0IG5vdG5sID0gU2V0IChDc2V0LmRpZmYgQ3NldC5jYW55IChDc2V0LmNzaW5nbGUgJ1xcbicpKVxuXG5sZXQgbG93ZXIgPSBhbHQgW3JnICdhJyAneic7IGNoYXIgJ1xcMTgxJzsgcmcgJ1xcMjIzJyAnXFwyNDYnOyByZyAnXFwyNDgnICdcXDI1NSddXG5sZXQgdXBwZXIgPSBhbHQgW3JnICdBJyAnWic7IHJnICdcXDE5MicgJ1xcMjE0JzsgcmcgJ1xcMjE2JyAnXFwyMjInXVxubGV0IGFscGhhID0gYWx0IFtsb3dlcjsgdXBwZXI7IGNoYXIgJ1xcMTcwJzsgY2hhciAnXFwxODYnXVxubGV0IGRpZ2l0ID0gcmcgJzAnICc5J1xubGV0IGFsbnVtID0gYWx0IFthbHBoYTsgZGlnaXRdXG5sZXQgd29yZGMgPSBhbHQgW2FsbnVtOyBjaGFyICdfJ11cbmxldCBhc2NpaSA9IHJnICdcXDAwMCcgJ1xcMTI3J1xubGV0IGJsYW5rID0gc2V0IFwiXFx0IFwiXG5sZXQgY250cmwgPSBhbHQgW3JnICdcXDAwMCcgJ1xcMDMxJzsgcmcgJ1xcMTI3JyAnXFwxNTknXVxubGV0IGdyYXBoID0gYWx0IFtyZyAnXFwwMzMnICdcXDEyNic7IHJnICdcXDE2MCcgJ1xcMjU1J11cbmxldCBwcmludCA9IGFsdCBbcmcgJ1xcMDMyJyAnXFwxMjYnOyByZyAnXFwxNjAnICdcXDI1NSddXG5sZXQgcHVuY3QgPVxuICBhbHQgW3JnICdcXDAzMycgJ1xcMDQ3JzsgcmcgJ1xcMDU4JyAnXFwwNjQnOyByZyAnXFwwOTEnICdcXDA5Nic7XG4gICAgICAgcmcgJ1xcMTIzJyAnXFwxMjYnOyByZyAnXFwxNjAnICdcXDE2OSc7IHJnICdcXDE3MScgJ1xcMTgwJztcbiAgICAgICByZyAnXFwxODInICdcXDE4NSc7IHJnICdcXDE4NycgJ1xcMTkxJzsgY2hhciAnXFwyMTUnOyBjaGFyICdcXDI0NyddXG5sZXQgc3BhY2UgPSBhbHQgW2NoYXIgJyAnOyByZyAnXFwwMDknICdcXDAxMyddXG5sZXQgeGRpZ2l0ID0gYWx0IFtkaWdpdDsgcmcgJ2EnICdmJzsgcmcgJ0EnICdGJ11cblxubGV0IGNhc2UgciA9IENhc2UgclxubGV0IG5vX2Nhc2UgciA9IE5vX2Nhc2UgclxuXG4oKioqKilcblxubGV0IGNvbXBpbGUgciA9XG4gIGNvbXBpbGVfMSAoXG4gICAgaWYgYW5jaG9yZWQgciB0aGVuXG4gICAgICBncm91cCByXG4gICAgZWxzZVxuICAgICAgc2VxIFtzaG9ydGVzdCAocmVwIGFueSk7IGdyb3VwIHJdXG4gIClcblxubGV0IGV4ZWNfaW50ZXJuYWwgbmFtZSA/KHBvcz0wKSA/KGxlbiA9IC0xKSB+cGFydGlhbCB+Z3JvdXBzIHJlIHMgPVxuICBpZiBwb3MgPCAwIHx8IGxlbiA8IC0xIHx8IHBvcyArIGxlbiA+IFN0cmluZy5sZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgbmFtZTtcbiAgbWF0Y2hfc3RyIH5ncm91cHMgfnBhcnRpYWwgcmUgcyB+cG9zIH5sZW5cblxubGV0IGV4ZWMgP3BvcyA/bGVuIHJlIHMgPVxuICBtYXRjaCBleGVjX2ludGVybmFsIFwiUmUuZXhlY1wiID9wb3MgP2xlbiB+Z3JvdXBzOnRydWUgfnBhcnRpYWw6ZmFsc2UgcmUgcyB3aXRoXG4gICAgTWF0Y2ggc3Vic3RyIC0+IHN1YnN0clxuICB8IF8gICAgICAgICAgICAtPiByYWlzZSBOb3RfZm91bmRcblxubGV0IGV4ZWNfb3B0ID9wb3MgP2xlbiByZSBzID1cbiAgbWF0Y2ggZXhlY19pbnRlcm5hbCBcIlJlLmV4ZWNfb3B0XCIgP3BvcyA/bGVuIH5ncm91cHM6dHJ1ZSB+cGFydGlhbDpmYWxzZVxuICAgICAgICAgIHJlIHMgd2l0aFxuICAgIE1hdGNoIHN1YnN0ciAtPiBTb21lIHN1YnN0clxuICB8IF8gICAgICAgICAgICAtPiBOb25lXG5cbmxldCBleGVjcCA/cG9zID9sZW4gcmUgcyA9XG4gIG1hdGNoIGV4ZWNfaW50ZXJuYWwgfmdyb3VwczpmYWxzZSB+cGFydGlhbDpmYWxzZSBcIlJlLmV4ZWNwXCIgP3BvcyA/bGVuIHJlIHMgd2l0aFxuICAgIE1hdGNoIF9zdWJzdHIgLT4gdHJ1ZVxuICB8IF8gICAgICAgICAgICAgLT4gZmFsc2VcblxubGV0IGV4ZWNfcGFydGlhbCA/cG9zID9sZW4gcmUgcyA9XG4gIG1hdGNoIGV4ZWNfaW50ZXJuYWwgfmdyb3VwczpmYWxzZSB+cGFydGlhbDp0cnVlIFwiUmUuZXhlY19wYXJ0aWFsXCJcbiAgICAgICAgICA/cG9zID9sZW4gcmUgcyB3aXRoXG4gICAgTWF0Y2ggXyAtPiBgRnVsbFxuICB8IFJ1bm5pbmcgLT4gYFBhcnRpYWxcbiAgfCBGYWlsZWQgIC0+IGBNaXNtYXRjaFxuXG5tb2R1bGUgTWFyayA9IHN0cnVjdFxuXG4gIHR5cGUgdCA9IFBtYXJrLnRcblxuICBsZXQgdGVzdCAoZyA6IEdyb3VwLnQpIHAgPVxuICAgIFBtYXJrLlNldC5tZW0gcCBnLnBtYXJrc1xuXG4gIGxldCBhbGwgKGcgOiBHcm91cC50KSA9IGcucG1hcmtzXG5cbiAgbW9kdWxlIFNldCA9IFBtYXJrLlNldFxuXG4gIGxldCBlcXVhbCA9IFBtYXJrLmVxdWFsXG5cbiAgbGV0IGNvbXBhcmUgPSBQbWFyay5jb21wYXJlXG5cbmVuZFxuXG50eXBlIHNwbGl0X3Rva2VuID1cbiAgWyBgVGV4dCBvZiBzdHJpbmdcbiAgfCBgRGVsaW0gb2YgR3JvdXAudFxuICBdXG5cbm1vZHVsZSBSc2VxID0gc3RydWN0XG4gIGxldCBhbGwgPyhwb3M9MCkgP2xlbiByZSBzIDogXyBTZXEudCA9XG4gICAgaWYgcG9zIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiUmUuYWxsXCI7XG4gICAgKCogaW5kZXggb2YgdGhlIGZpcnN0IHBvc2l0aW9uIHdlIGRvIG5vdCBjb25zaWRlci5cbiAgICAgICAhcG9zIDwgbGltaXQgaXMgYW4gaW52YXJpYW50ICopXG4gICAgbGV0IGxpbWl0ID0gbWF0Y2ggbGVuIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBTdHJpbmcubGVuZ3RoIHNcbiAgICAgIHwgU29tZSBsIC0+XG4gICAgICAgIGlmIGw8MCB8fCBwb3MrbCA+IFN0cmluZy5sZW5ndGggcyB0aGVuIGludmFsaWRfYXJnIFwiUmUuYWxsXCI7XG4gICAgICAgIHBvcytsXG4gICAgaW5cbiAgICAoKiBpdGVyYXRlIG9uIG1hdGNoZXMuIFdoZW4gYSBtYXRjaCBpcyBmb3VuZCwgc2VhcmNoIGZvciB0aGUgbmV4dFxuICAgICAgIG9uZSBqdXN0IGFmdGVyIGl0cyBlbmQgKilcbiAgICBsZXQgcmVjIGF1eCBwb3MgKCkgPVxuICAgICAgaWYgcG9zID49IGxpbWl0XG4gICAgICB0aGVuIFNlcS5OaWwgKCogbm8gbW9yZSBtYXRjaGVzICopXG4gICAgICBlbHNlXG4gICAgICAgIG1hdGNoIG1hdGNoX3N0ciB+Z3JvdXBzOnRydWUgfnBhcnRpYWw6ZmFsc2UgcmUgc1xuICAgICAgICAgICAgICAgIH5wb3MgfmxlbjoobGltaXQgLSBwb3MpIHdpdGhcbiAgICAgICAgfCBNYXRjaCBzdWJzdHIgLT5cbiAgICAgICAgICBsZXQgcDEsIHAyID0gR3JvdXAub2Zmc2V0IHN1YnN0ciAwIGluXG4gICAgICAgICAgbGV0IHBvcyA9IGlmIHAxPXAyIHRoZW4gcDIrMSBlbHNlIHAyIGluXG4gICAgICAgICAgU2VxLkNvbnMgKHN1YnN0ciwgYXV4IHBvcylcbiAgICAgICAgfCBSdW5uaW5nXG4gICAgICAgIHwgRmFpbGVkIC0+IFNlcS5OaWxcbiAgICBpblxuICAgIGF1eCBwb3NcblxuICBsZXQgbWF0Y2hlcyA/cG9zID9sZW4gcmUgcyA6IF8gU2VxLnQgPVxuICAgIGFsbCA/cG9zID9sZW4gcmUgc1xuICAgIHw+IFNlcS5tYXAgKGZ1biBzdWIgLT4gR3JvdXAuZ2V0IHN1YiAwKVxuXG4gIGxldCBzcGxpdF9mdWxsID8ocG9zPTApID9sZW4gcmUgcyA6IF8gU2VxLnQgPVxuICAgIGlmIHBvcyA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlJlLnNwbGl0XCI7XG4gICAgbGV0IGxpbWl0ID0gbWF0Y2ggbGVuIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBTdHJpbmcubGVuZ3RoIHNcbiAgICAgIHwgU29tZSBsIC0+XG4gICAgICAgIGlmIGw8MCB8fCBwb3MrbCA+IFN0cmluZy5sZW5ndGggcyB0aGVuIGludmFsaWRfYXJnIFwiUmUuc3BsaXRcIjtcbiAgICAgICAgcG9zK2xcbiAgICBpblxuICAgICgqIGk6IHN0YXJ0IG9mIGRlbGltaXRlZCBzdHJpbmdcbiAgICAgICBwb3M6IGZpcnN0IHBvc2l0aW9uIGFmdGVyIGxhc3QgbWF0Y2ggb2YgW3JlXVxuICAgICAgIGxpbWl0OiBmaXJzdCBpbmRleCB3ZSBpZ25vcmUgKCFwb3MgPCBsaW1pdCBpcyBhbiBpbnZhcmlhbnQpICopXG4gICAgbGV0IHBvczAgPSBwb3MgaW5cbiAgICBsZXQgcmVjIGF1eCBzdGF0ZSBpIHBvcyAoKSA9IG1hdGNoIHN0YXRlIHdpdGhcbiAgICAgIHwgYElkbGUgd2hlbiBwb3MgPj0gbGltaXQgLT5cbiAgICAgICAgaWYgaSA8IGxpbWl0IHRoZW4gKFxuICAgICAgICAgIGxldCBzdWIgPSBTdHJpbmcuc3ViIHMgaSAobGltaXQgLSBpKSBpblxuICAgICAgICAgIFNlcS5Db25zIChgVGV4dCBzdWIsIGF1eCBzdGF0ZSAoaSsxKSBwb3MpXG4gICAgICAgICkgZWxzZSBTZXEuTmlsXG4gICAgICB8IGBJZGxlIC0+XG4gICAgICAgIGJlZ2luIG1hdGNoIG1hdGNoX3N0ciB+Z3JvdXBzOnRydWUgfnBhcnRpYWw6ZmFsc2UgcmUgcyB+cG9zXG4gICAgICAgICAgICAgICAgICAgICAgfmxlbjoobGltaXQgLSBwb3MpIHdpdGhcbiAgICAgICAgfCBNYXRjaCBzdWJzdHIgLT5cbiAgICAgICAgICBsZXQgcDEsIHAyID0gR3JvdXAub2Zmc2V0IHN1YnN0ciAwIGluXG4gICAgICAgICAgbGV0IHBvcyA9IGlmIHAxPXAyIHRoZW4gcDIrMSBlbHNlIHAyIGluXG4gICAgICAgICAgbGV0IG9sZF9pID0gaSBpblxuICAgICAgICAgIGxldCBpID0gcDIgaW5cbiAgICAgICAgICBpZiBwMSA+IHBvczAgdGhlbiAoXG4gICAgICAgICAgICAoKiBzdHJpbmcgZG9lcyBub3Qgc3RhcnQgYnkgYSBkZWxpbWl0ZXIgKilcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gU3RyaW5nLnN1YiBzIG9sZF9pIChwMSAtIG9sZF9pKSBpblxuICAgICAgICAgICAgbGV0IHN0YXRlID0gYFlpZWxkIChgRGVsaW0gc3Vic3RyKSBpblxuICAgICAgICAgICAgU2VxLkNvbnMgKGBUZXh0IHRleHQsIGF1eCBzdGF0ZSBpIHBvcylcbiAgICAgICAgICApIGVsc2UgU2VxLkNvbnMgKGBEZWxpbSBzdWJzdHIsIGF1eCBzdGF0ZSBpIHBvcylcbiAgICAgICAgfCBSdW5uaW5nIC0+IFNlcS5OaWxcbiAgICAgICAgfCBGYWlsZWQgLT5cbiAgICAgICAgICBpZiBpIDwgbGltaXRcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gU3RyaW5nLnN1YiBzIGkgKGxpbWl0IC0gaSkgaW5cbiAgICAgICAgICAgICgqIHlpZWxkIGxhc3Qgc3RyaW5nICopXG4gICAgICAgICAgICBTZXEuQ29ucyAoYFRleHQgdGV4dCwgYXV4IHN0YXRlIGxpbWl0IHBvcylcbiAgICAgICAgICApIGVsc2VcbiAgICAgICAgICAgIFNlcS5OaWxcbiAgICAgICAgZW5kXG4gICAgICB8IGBZaWVsZCB4IC0+XG4gICAgICAgIFNlcS5Db25zICh4LCBhdXggYElkbGUgaSBwb3MpXG4gICAgaW5cbiAgICBhdXggYElkbGUgcG9zIHBvc1xuXG4gIGxldCBzcGxpdCA/cG9zID9sZW4gcmUgcyA6IF8gU2VxLnQgPVxuICAgIGxldCBzZXEgPSBzcGxpdF9mdWxsID9wb3MgP2xlbiByZSBzIGluXG4gICAgbGV0IHJlYyBmaWx0ZXIgc2VxICgpID0gbWF0Y2ggc2VxICgpICB3aXRoXG4gICAgICB8IFNlcS5OaWwgLT4gU2VxLk5pbFxuICAgICAgfCBTZXEuQ29ucyAoYERlbGltIF8sIHRsKSAtPiBmaWx0ZXIgdGwgKClcbiAgICAgIHwgU2VxLkNvbnMgKGBUZXh0IHMsdGwpIC0+IFNlcS5Db25zIChzLCBmaWx0ZXIgdGwpXG4gICAgaW4gZmlsdGVyIHNlcVxuZW5kXG5cbm1vZHVsZSBSbGlzdCA9IHN0cnVjdFxuICBsZXQgbGlzdF9vZl9zZXEgKHM6J2EgU2VxLnQpIDogJ2EgbGlzdCA9XG4gICAgU2VxLmZvbGRfbGVmdCAoZnVuIGwgeCAtPiB4IDo6IGwpIFtdIHMgfD4gTGlzdC5yZXZcblxuICBsZXQgYWxsID9wb3MgP2xlbiByZSBzID0gUnNlcS5hbGwgP3BvcyA/bGVuIHJlIHMgfD4gbGlzdF9vZl9zZXFcblxuICBsZXQgbWF0Y2hlcyA/cG9zID9sZW4gcmUgcyA9IFJzZXEubWF0Y2hlcyA/cG9zID9sZW4gcmUgcyB8PiBsaXN0X29mX3NlcVxuXG4gIGxldCBzcGxpdF9mdWxsID9wb3MgP2xlbiByZSBzID0gUnNlcS5zcGxpdF9mdWxsID9wb3MgP2xlbiByZSBzIHw+IGxpc3Rfb2Zfc2VxXG5cbiAgbGV0IHNwbGl0ID9wb3MgP2xlbiByZSBzID0gUnNlcS5zcGxpdCA/cG9zID9sZW4gcmUgcyB8PiBsaXN0X29mX3NlcVxuZW5kXG5cbm1vZHVsZSBHZW4gPSBzdHJ1Y3RcbiAgdHlwZSAnYSBnZW4gPSB1bml0IC0+ICdhIG9wdGlvblxuICBsZXQgZ2VuX29mX3NlcSAoczonYSBTZXEudCkgOiAnYSBnZW4gPVxuICAgIGxldCByID0gcmVmIHMgaW5cbiAgICBmdW4gKCkgLT4gbWF0Y2ggIXIgKCkgd2l0aFxuICAgICAgfCBTZXEuTmlsIC0+IE5vbmVcbiAgICAgIHwgU2VxLkNvbnMgKHgsIHRsKSAtPlxuICAgICAgICByIDo9IHRsO1xuICAgICAgICBTb21lIHhcblxuICBsZXQgc3BsaXQgP3BvcyA/bGVuIHJlIHMgOiBfIGdlbiA9XG4gICAgUnNlcS5zcGxpdCA/cG9zID9sZW4gcmUgcyB8PiBnZW5fb2Zfc2VxXG5cbiAgbGV0IHNwbGl0X2Z1bGwgP3BvcyA/bGVuIHJlIHMgOiBfIGdlbiA9XG4gICAgUnNlcS5zcGxpdF9mdWxsID9wb3MgP2xlbiByZSBzIHw+IGdlbl9vZl9zZXFcblxuICBsZXQgYWxsID9wb3MgP2xlbiByZSBzID0gUnNlcS5hbGwgP3BvcyA/bGVuIHJlIHMgfD4gZ2VuX29mX3NlcVxuXG4gIGxldCBtYXRjaGVzID9wb3MgP2xlbiByZSBzID0gUnNlcS5tYXRjaGVzID9wb3MgP2xlbiByZSBzIHw+IGdlbl9vZl9zZXFcbmVuZFxuXG5sZXQgcmVwbGFjZSA/KHBvcz0wKSA/bGVuID8oYWxsPXRydWUpIHJlIH5mIHMgPVxuICBpZiBwb3MgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJSZS5yZXBsYWNlXCI7XG4gIGxldCBsaW1pdCA9IG1hdGNoIGxlbiB3aXRoXG4gICAgfCBOb25lIC0+IFN0cmluZy5sZW5ndGggc1xuICAgIHwgU29tZSBsIC0+XG4gICAgICBpZiBsPDAgfHwgcG9zK2wgPiBTdHJpbmcubGVuZ3RoIHMgdGhlbiBpbnZhbGlkX2FyZyBcIlJlLnJlcGxhY2VcIjtcbiAgICAgIHBvcytsXG4gIGluXG4gICgqIGJ1ZmZlciBpbnRvIHdoaWNoIHdlIHdyaXRlIHRoZSByZXN1bHQgKilcbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgKFN0cmluZy5sZW5ndGggcykgaW5cbiAgKCogaXRlcmF0ZSBvbiBtYXRjaGVkIHN1YnN0cmluZ3MuICopXG4gIGxldCByZWMgaXRlciBwb3MgPVxuICAgIGlmIHBvcyA8IGxpbWl0XG4gICAgdGhlblxuICAgICAgbWF0Y2ggbWF0Y2hfc3RyIH5ncm91cHM6dHJ1ZSB+cGFydGlhbDpmYWxzZSByZSBzIH5wb3MgfmxlbjoobGltaXQtcG9zKSB3aXRoXG4gICAgICB8IE1hdGNoIHN1YnN0ciAtPlxuICAgICAgICBsZXQgcDEsIHAyID0gR3JvdXAub2Zmc2V0IHN1YnN0ciAwIGluXG4gICAgICAgICgqIGFkZCBzdHJpbmcgYmV0d2VlbiBwcmV2aW91cyBtYXRjaCBhbmQgY3VycmVudCBtYXRjaCAqKVxuICAgICAgICBCdWZmZXIuYWRkX3N1YnN0cmluZyBidWYgcyBwb3MgKHAxLXBvcyk7XG4gICAgICAgICgqIHdoYXQgc2hvdWxkIHdlIHJlcGxhY2UgdGhlIG1hdGNoZWQgZ3JvdXAgd2l0aD8gKilcbiAgICAgICAgbGV0IHJlcGxhY2luZyA9IGYgc3Vic3RyIGluXG4gICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiByZXBsYWNpbmc7XG4gICAgICAgIGlmIGFsbCB0aGVuXG4gICAgICAgICAgKCogaWYgd2UgbWF0Y2hlZCBhIG5vbi1jaGFyIGUuZy4gXiB3ZSBtdXN0IG1hbnVhbGx5IGFkdmFuY2UgYnkgMSAqKVxuICAgICAgICAgIGl0ZXIgKFxuICAgICAgICAgICAgaWYgcDE9cDIgdGhlbiAoXG4gICAgICAgICAgICAgICgqIGEgbm9uIGNoYXIgY291bGQgYmUgcGFzdCB0aGUgZW5kIG9mIHN0cmluZy4gZS5nLiAkICopXG4gICAgICAgICAgICAgIGlmIHAyIDwgbGltaXQgdGhlbiBCdWZmZXIuYWRkX2NoYXIgYnVmIHMuW3AyXTtcbiAgICAgICAgICAgICAgcDIrMVxuICAgICAgICAgICAgKSBlbHNlXG4gICAgICAgICAgICAgIHAyKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgQnVmZmVyLmFkZF9zdWJzdHJpbmcgYnVmIHMgcDIgKGxpbWl0LXAyKVxuICAgICAgfCBSdW5uaW5nIC0+ICgpXG4gICAgICB8IEZhaWxlZCAtPlxuICAgICAgICBCdWZmZXIuYWRkX3N1YnN0cmluZyBidWYgcyBwb3MgKGxpbWl0LXBvcylcbiAgaW5cbiAgaXRlciBwb3M7XG4gIEJ1ZmZlci5jb250ZW50cyBidWZcblxubGV0IHJlcGxhY2Vfc3RyaW5nID9wb3MgP2xlbiA/YWxsIHJlIH5ieSBzID1cbiAgcmVwbGFjZSA/cG9zID9sZW4gP2FsbCByZSBzIH5mOihmdW4gXyAtPiBieSlcblxubGV0IHdpdG5lc3MgdCA9XG4gIGxldCByZWMgd2l0bmVzcyA9IGZ1bmN0aW9uXG4gICAgfCBTZXQgYyAtPiBTdHJpbmcubWFrZSAxIChDaGFyLmNociAoQ3NldC5waWNrIGMpKVxuICAgIHwgU2VxdWVuY2UgeHMgLT4gU3RyaW5nLmNvbmNhdCBcIlwiIChMaXN0Lm1hcCB3aXRuZXNzIHhzKVxuICAgIHwgQWx0ZXJuYXRpdmUgKHggOjogXykgLT4gd2l0bmVzcyB4XG4gICAgfCBBbHRlcm5hdGl2ZSBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IFJlcGVhdCAociwgZnJvbSwgX3RvKSAtPlxuICAgICAgbGV0IHcgPSB3aXRuZXNzIHIgaW5cbiAgICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAoU3RyaW5nLmxlbmd0aCB3ICogZnJvbSkgaW5cbiAgICAgIGZvciBfaT0xIHRvIGZyb20gZG9cbiAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYiB3XG4gICAgICBkb25lO1xuICAgICAgQnVmZmVyLmNvbnRlbnRzIGJcbiAgICB8IE5vX2Nhc2UgciAtPiB3aXRuZXNzIHJcbiAgICB8IEludGVyc2VjdGlvbiBfXG4gICAgfCBDb21wbGVtZW50IF9cbiAgICB8IERpZmZlcmVuY2UgKF8sIF8pIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgR3JvdXAgclxuICAgIHwgTm9fZ3JvdXAgclxuICAgIHwgTmVzdCByXG4gICAgfCBTZW0gKF8sIHIpXG4gICAgfCBQbWFyayAoXywgcilcbiAgICB8IENhc2UgclxuICAgIHwgU2VtX2dyZWVkeSAoXywgcikgLT4gd2l0bmVzcyByXG4gICAgfCBCZWdfb2ZfbGluZVxuICAgIHwgRW5kX29mX2xpbmVcbiAgICB8IEJlZ19vZl93b3JkXG4gICAgfCBFbmRfb2Zfd29yZFxuICAgIHwgTm90X2JvdW5kXG4gICAgfCBCZWdfb2Zfc3RyXG4gICAgfCBMYXN0X2VuZF9vZl9saW5lXG4gICAgfCBTdGFydFxuICAgIHwgU3RvcFxuICAgIHwgRW5kX29mX3N0ciAtPiBcIlwiIGluXG4gIHdpdG5lc3MgKGhhbmRsZV9jYXNlIGZhbHNlIHQpXG5cbm1vZHVsZSBTZXEgPSBSc2VxXG5tb2R1bGUgTGlzdCA9IFJsaXN0XG5tb2R1bGUgR3JvdXAgPSBHcm91cFxuXG4oKiogezIgRGVwcmVjYXRlZCBmdW5jdGlvbnN9ICopXG5cbmxldCBzcGxpdF9mdWxsX3NlcSA9IFNlcS5zcGxpdF9mdWxsXG5sZXQgc3BsaXRfc2VxID0gU2VxLnNwbGl0XG5sZXQgbWF0Y2hlc19zZXEgPSBTZXEubWF0Y2hlc1xubGV0IGFsbF9zZXEgPSBTZXEuYWxsXG5cbnR5cGUgJ2EgZ2VuICAgICAgICA9ICdhIEdlbi5nZW5cbmxldCBhbGxfZ2VuICAgICAgICA9IEdlbi5hbGxcbmxldCBtYXRjaGVzX2dlbiAgICA9IEdlbi5tYXRjaGVzXG5sZXQgc3BsaXRfZ2VuICAgICAgPSBHZW4uc3BsaXRcbmxldCBzcGxpdF9mdWxsX2dlbiA9IEdlbi5zcGxpdF9mdWxsXG5cblxudHlwZSBzdWJzdHJpbmdzID0gR3JvdXAudFxuXG5sZXQgZ2V0ID0gR3JvdXAuZ2V0XG5sZXQgZ2V0X29mcyA9IEdyb3VwLm9mZnNldFxubGV0IGdldF9hbGwgPSBHcm91cC5hbGxcbmxldCBnZXRfYWxsX29mcyA9IEdyb3VwLmFsbF9vZmZzZXRcbmxldCB0ZXN0ID0gR3JvdXAudGVzdFxuXG50eXBlIG1hcmtpZCA9IE1hcmsudFxuXG5sZXQgbWFya2VkID0gTWFyay50ZXN0XG5sZXQgbWFya19zZXQgPSBNYXJrLmFsbFxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCpcbkluZm9ybWF0aW9uIGFib3V0IHRoZSBwcmV2aW91cyBjaGFyYWN0ZXI6XG4tIGRvZXMgbm90IGV4aXN0c1xuLSBpcyBhIGxldHRlclxuLSBpcyBub3QgYSBsZXR0ZXJcbi0gaXMgYSBuZXdsaW5lXG4tIGlzIGxhc3QgbmV3bGluZVxuXG5CZWdpbm5pbmcgb2Ygd29yZDpcbi0gcHJldmlvdXMgaXMgbm90IGEgbGV0dGVyIG9yIGRvZXMgbm90IGV4aXN0XG4tIGN1cnJlbnQgaXMgYSBsZXR0ZXIgb3IgZG9lcyBub3QgZXhpc3RcblxuRW5kIG9mIHdvcmQ6XG4tIHByZXZpb3VzIGlzIGEgbGV0dGVyIG9yIGRvZXMgbm90IGV4aXN0XG4tIGN1cnJlbnQgaXMgbm90IGEgbGV0dGVyIG9yIGRvZXMgbm90IGV4aXN0XG5cbkJlZ2lubmluZyBvZiBsaW5lOlxuLSBwcmV2aW91cyBpcyBhIG5ld2xpbmUgb3IgZG9lcyBub3QgZXhpc3RcblxuQmVnaW5uaW5nIG9mIGJ1ZmZlcjpcbi0gcHJldmlvdXMgZG9lcyBub3QgZXhpc3RcblxuRW5kIG9mIGJ1ZmZlclxuLSBjdXJyZW50IGRvZXMgbm90IGV4aXN0XG5cbkVuZCBvZiBsaW5lXG4tIGN1cnJlbnQgaXMgYSBuZXdsaW5lIG9yIGRvZXMgbm90IGV4aXN0XG4qKVxuXG4oKlxuUmVwOiBlID0gVCxlIHwgKClcbiAgLSBzZW1hbnRpY3Mgb2YgdGhlIGNvbW1hIChzaG9ydGVzdC9sb25nZXN0L2ZpcnN0KVxuICAtIHNlbWFudGljcyBvZiB0aGUgdW5pb24gKGdyZWVkeS9ub24tZ3JlZWR5KVxuXG5Cb3VuZGVkIHJlcGV0aXRpb25cbiAgYXswLDN9ID0gKGEsKGEsYT8pPyk/XG4qKVxuXG50eXBlIGdyb3VwcyA9IEdyb3VwLnRcblxuaW5jbHVkZSBSbGlzdFxuIiwiKCogSW4gcmVhbGl0eSwgdGhpcyBjYW4gcmVhbGx5IGJlIHJlcHJlc2VudGVkIGFzIGEgYm9vbCBhcnJheS5cblxuICAgVGhlIHJlcHJlc2VudGF0aW9uIGlzIGJlc3QgdGhvdWdodCBvZiBhcyBhIGxpc3Qgb2YgYWxsIGNoYXJzIGFsb25nIHdpdGggYVxuICAgZmxhZzpcblxuICAgKGEsIDApLCAoYiwgMSksIChjLCAwKSwgKGQsIDApLCAuLi5cblxuICAgY2hhcmFjdGVycyBiZWxvbmdpbmcgdG8gdGhlIHNhbWUgY29sb3IgYXJlIHJlcHJlc2VudGVkIGJ5IHNlcXVuY2VzIG9mXG4gICBjaGFyYWN0ZXJzIHdpdGggdGhlIGZsYWcgc2V0IHRvIDAuXG4qKVxuXG50eXBlIHQgPSBCeXRlcy50XG5cbmxldCBtYWtlICgpID0gQnl0ZXMubWFrZSAyNTcgJ1xcMDAwJ1xuXG5sZXQgZmxhdHRlbiBjbSA9XG4gIGxldCBjID0gQnl0ZXMuY3JlYXRlIDI1NiBpblxuICBsZXQgY29sb3JfcmVwciA9IEJ5dGVzLmNyZWF0ZSAyNTYgaW5cbiAgbGV0IHYgPSByZWYgMCBpblxuICBCeXRlcy5zZXQgYyAwICdcXDAwMCc7XG4gIEJ5dGVzLnNldCBjb2xvcl9yZXByIDAgJ1xcMDAwJztcbiAgZm9yIGkgPSAxIHRvIDI1NSBkb1xuICAgIGlmIEJ5dGVzLmdldCBjbSBpIDw+ICdcXDAwMCcgdGhlbiBpbmNyIHY7XG4gICAgQnl0ZXMuc2V0IGMgaSAoQ2hhci5jaHIgIXYpO1xuICAgIEJ5dGVzLnNldCBjb2xvcl9yZXByICF2IChDaGFyLmNociBpKVxuICBkb25lO1xuICAoYywgQnl0ZXMuc3ViIGNvbG9yX3JlcHIgMCAoIXYgKyAxKSwgIXYgKyAxKVxuXG4oKiBtYXJrIGFsbCB0aGUgZW5kcG9pbnRzIG9mIHRoZSBpbnRlcnZhbHMgb2YgdGhlIGNoYXIgc2V0IHdpdGggdGhlIDEgYnl0ZSAqKVxubGV0IHNwbGl0IHMgY20gPVxuICBDc2V0Lml0ZXIgcyB+ZjooZnVuIGkgaiAtPlxuICAgICAgQnl0ZXMuc2V0IGNtIGkgJ1xcMDAxJztcbiAgICAgIEJ5dGVzLnNldCBjbSAoaiArIDEpICdcXDAwMSc7XG4gICAgKVxuIiwiKCogUmVzdWx0IG9mIGEgc3VjY2Vzc2Z1bCBtYXRjaC4gKilcbnR5cGUgdCA9XG4gIHsgcyA6IHN0cmluZ1xuICA7IG1hcmtzIDogQXV0b21hdGEubWFya19pbmZvc1xuICA7IHBtYXJrcyA6IFBtYXJrLlNldC50XG4gIDsgZ3BvcyA6IGludCBhcnJheVxuICA7IGdjb3VudCA6IGludFxuICB9XG5cbmxldCBvZmZzZXQgdCBpID1cbiAgaWYgMiAqIGkgKyAxID49IEFycmF5Lmxlbmd0aCB0Lm1hcmtzIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICBsZXQgbTEgPSB0Lm1hcmtzLigyICogaSkgaW5cbiAgaWYgbTEgPSAtMSB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgbGV0IHAxID0gdC5ncG9zLihtMSkgLSAxIGluXG4gIGxldCBwMiA9IHQuZ3Bvcy4odC5tYXJrcy4oMiAqIGkgKyAxKSkgLSAxIGluXG4gIChwMSwgcDIpXG5cbmxldCBnZXQgdCBpID1cbiAgbGV0IChwMSwgcDIpID0gb2Zmc2V0IHQgaSBpblxuICBTdHJpbmcuc3ViIHQucyBwMSAocDIgLSBwMSlcblxubGV0IHN0YXJ0IHN1YnMgaSA9IGZzdCAob2Zmc2V0IHN1YnMgaSlcblxubGV0IHN0b3Agc3VicyBpID0gc25kIChvZmZzZXQgc3VicyBpKVxuXG5sZXQgdGVzdCB0IGkgPVxuICBpZiAyICogaSA+PSBBcnJheS5sZW5ndGggdC5tYXJrcyB0aGVuXG4gICAgZmFsc2VcbiAgZWxzZVxuICAgIGxldCBpZHggPSB0Lm1hcmtzLigyICogaSkgaW5cbiAgICBpZHggPD4gLTFcblxubGV0IGdldF9vcHQgdCBpID1cbiAgaWYgdGVzdCB0IGlcbiAgdGhlbiBTb21lIChnZXQgdCBpKVxuICBlbHNlIE5vbmVcblxubGV0IGR1bW15X29mZnNldCA9ICgtMSwgLTEpXG5cbmxldCBhbGxfb2Zmc2V0IHQgPVxuICBsZXQgcmVzID0gQXJyYXkubWFrZSB0Lmdjb3VudCBkdW1teV9vZmZzZXQgaW5cbiAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0Lm1hcmtzIC8gMiAtIDEgZG9cbiAgICBsZXQgbTEgPSB0Lm1hcmtzLigyICogaSkgaW5cbiAgICBpZiBtMSA8PiAtMSB0aGVuIGJlZ2luXG4gICAgICBsZXQgcDEgPSB0Lmdwb3MuKG0xKSBpblxuICAgICAgbGV0IHAyID0gdC5ncG9zLih0Lm1hcmtzLigyICogaSArIDEpKSBpblxuICAgICAgcmVzLihpKSA8LSAocDEgLSAxLCBwMiAtIDEpXG4gICAgZW5kXG4gIGRvbmU7XG4gIHJlc1xuXG5sZXQgZHVtbXlfc3RyaW5nID0gXCJcIlxuXG5sZXQgYWxsIHQgPVxuICBsZXQgcmVzID0gQXJyYXkubWFrZSB0Lmdjb3VudCBkdW1teV9zdHJpbmcgaW5cbiAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0Lm1hcmtzIC8gMiAtIDEgZG9cbiAgICBsZXQgbTEgPSB0Lm1hcmtzLigyICogaSkgaW5cbiAgICBpZiBtMSA8PiAtMSB0aGVuIGJlZ2luXG4gICAgICBsZXQgcDEgPSB0Lmdwb3MuKG0xKSBpblxuICAgICAgbGV0IHAyID0gdC5ncG9zLih0Lm1hcmtzLigyICogaSArIDEpKSBpblxuICAgICAgcmVzLihpKSA8LSBTdHJpbmcuc3ViIHQucyAocDEgLSAxKSAocDIgLSBwMSlcbiAgICBlbmRcbiAgZG9uZTtcbiAgcmVzXG5cbmxldCBwcCBmbXQgdCA9XG4gIGxldCBtYXRjaGVzID1cbiAgICBsZXQgb2Zmc2V0cyA9IGFsbF9vZmZzZXQgdCBpblxuICAgIGxldCBzdHJzID0gYWxsIHQgaW5cbiAgICBBcnJheS50b19saXN0IChcbiAgICAgIEFycmF5LmluaXQgKEFycmF5Lmxlbmd0aCBzdHJzKSAoZnVuIGkgLT4gc3Rycy4oaSksIG9mZnNldHMuKGkpKVxuICAgICkgaW5cbiAgbGV0IG9wZW4gRm10IGluXG4gIGxldCBwcF9tYXRjaCBmbXQgKHN0ciwgKHN0YXJ0LCBzdG9wKSkgPVxuICAgIGZwcmludGYgZm10IFwiQFsoJXMgKCVkICVkKSlAXVwiIHN0ciBzdGFydCBzdG9wIGluXG4gIHNleHAgZm10IFwiR3JvdXBcIiAobGlzdCBwcF9tYXRjaCkgbWF0Y2hlc1xuXG5sZXQgbmJfZ3JvdXBzIHQgPSB0Lmdjb3VudFxuIiwiKCogVHlYTUxcbiAqIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvdHl4bWxcbiAqIENvcHlyaWdodCAoQykgMjAwOCBWaW5jZW50IEJhbGF0LCBNYXVyaWNpbyBGZXJuYW5kZXpcbiAqIENvcHlyaWdodCAoQykgMjAxMSBQaWVycmUgQ2hhbWJhcnQsIEdyw6lnb2lyZSBIZW5yeVxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4gKiBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICogR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICogRm91bmRhdGlvbiwgSW5jLiwgNTEgRnJhbmtsaW4gU3RyZWV0LCBTdWl0ZSA1MDAsIEJvc3RvbiwgTUEgMDIxMTAtMTMwMSwgVVNBLlxuKilcblxubGV0IGlzX2NvbnRyb2wgYyA9XG4gIGxldCBjYyA9IENoYXIuY29kZSBjIGluXG4gIChjYyA8PSA4IHx8IGNjID0gMTEgfHwgY2MgPSAxMiB8fCAoMTQgPD0gY2MgJiYgY2MgPD0gMzEpIHx8IGNjID0gMTI3KVxuXG5sZXQgYWRkX3Vuc2FmZV9jaGFyIGIgPSBmdW5jdGlvblxuICB8ICc8JyAtPiBCdWZmZXIuYWRkX3N0cmluZyBiIFwiJmx0O1wiXG4gIHwgJz4nIC0+IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCImZ3Q7XCJcbiAgfCAnXCInIC0+IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCImcXVvdDtcIlxuICB8ICcmJyAtPiBCdWZmZXIuYWRkX3N0cmluZyBiIFwiJmFtcDtcIlxuICB8IGMgd2hlbiBpc19jb250cm9sIGMgLT5cbiAgICBCdWZmZXIuYWRkX3N0cmluZyBiIFwiJiNcIiA7XG4gICAgQnVmZmVyLmFkZF9zdHJpbmcgYiAoc3RyaW5nX29mX2ludCAoQ2hhci5jb2RlIGMpKSA7XG4gICAgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIjtcIlxuICB8IGMgLT4gQnVmZmVyLmFkZF9jaGFyIGIgY1xuXG5sZXQgZW5jb2RlX3Vuc2FmZV9jaGFyIHMgPVxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgKFN0cmluZy5sZW5ndGggcykgaW5cbiAgU3RyaW5nLml0ZXIgKGFkZF91bnNhZmVfY2hhciBiKSBzO1xuICBCdWZmZXIuY29udGVudHMgYlxuXG5sZXQgZW5jb2RlX3Vuc2FmZV9jaGFyX2FuZF9hdCBzID1cbiAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChTdHJpbmcubGVuZ3RoIHMpIGluXG4gIGxldCBmID0gZnVuY3Rpb25cbiAgICB8ICdAJyAtPiBCdWZmZXIuYWRkX3N0cmluZyBiIFwiJiM2NDtcIlxuICAgIHwgYyAtPiBhZGRfdW5zYWZlX2NoYXIgYiBjXG4gIGluXG4gIFN0cmluZy5pdGVyIGYgcztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxubGV0IGNvbXBvc2VfZGVjbCA/KHZlcnNpb24gPSBcIjEuMFwiKSA/KGVuY29kaW5nID0gXCJVVEYtOFwiKSAoKSA9XG4gIEZvcm1hdC5zcHJpbnRmXG4gICAge3w8P3htbCB2ZXJzaW9uPVwiJXNcIiBlbmNvZGluZz1cIiVzXCI/Plxcbnx9XG4gICAgdmVyc2lvbiBlbmNvZGluZ1xuXG5sZXQgY29tcG9zZV9kb2N0eXBlIGR0IGFyZ3MgPVxuICBsZXQgcHBfYXJncyBmbXQgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gKClcbiAgICB8IGwgLT5cbiAgICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIiBQVUJMSUMgJWFcIlxuICAgICAgICAoRm9ybWF0LnBwX3ByaW50X2xpc3QgfnBwX3NlcDpGb3JtYXQucHBfcHJpbnRfc3BhY2VcbiAgICAgICAgICAgKGZ1biBmbXQgLT4gRm9ybWF0LmZwcmludGYgZm10IFwiXFxcIiVzXFxcIlwiKSlcbiAgICAgICAgbFxuICBpblxuICBGb3JtYXQuYXNwcmludGZcbiAgICBcIjwhRE9DVFlQRSAlcyVhPlwiXG4gICAgZHRcbiAgICBwcF9hcmdzIGFyZ3NcblxubGV0IHJlX2VuZF9jb21tZW50ID0gUmUuKGNvbXBpbGUgQEAgYWx0IFtcbiAgc2VxIFsgYm9zIDsgc3RyIFwiPlwiIF0gO1xuICBzZXEgWyBib3MgOyBzdHIgXCItPlwiIF0gO1xuICBzdHIgXCItLT5cIiA7XG4gIHN0ciBcIi0tIT5cIiA7XG5dKVxubGV0IGVzY2FwZV9jb21tZW50IHMgPVxuICBsZXQgZiBnID0gbWF0Y2ggUmUuR3JvdXAuZ2V0IGcgMCB3aXRoXG4gICAgfCBcIj5cIiAtPiBcIiZndDtcIlxuICAgIHwgXCItPlwiIC0+IFwiLSZndDtcIlxuICAgIHwgXCItLT5cIiAtPiBcIi0tJmd0O1wiXG4gICAgfCBcIi0tIT5cIiAtPiBcIi0tISZndDtcIlxuICAgIHwgcyAtPiBzXG4gIGluXG4gIFJlLnJlcGxhY2UgfmFsbDp0cnVlIHJlX2VuZF9jb21tZW50IH5mIHNcblxuKCogY29waWVkIGZvcm0ganNfb2Zfb2NhbWw6IGNvbXBpbGVyL2phdmFzY3JpcHQubWwgKilcbmxldCBwcF9udW1iZXIgZm10IHYgPVxuICBpZiB2ID0gaW5maW5pdHlcbiAgdGhlbiBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIGZtdCBcIkluZmluaXR5XCJcbiAgZWxzZSBpZiB2ID0gbmVnX2luZmluaXR5XG4gIHRoZW4gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBmbXQgXCItSW5maW5pdHlcIlxuICBlbHNlIGlmIHYgPD4gdlxuICB0aGVuIEZvcm1hdC5wcF9wcmludF9zdHJpbmcgZm10IFwiTmFOXCJcbiAgZWxzZVxuICAgIGxldCB2aW50ID0gaW50X29mX2Zsb2F0IHYgaW5cbiAgICAoKiBjb21waWxlciAxMDAwIGludG8gMWUzICopXG4gICAgaWYgZmxvYXRfb2ZfaW50IHZpbnQgPSB2XG4gICAgdGhlblxuICAgICAgbGV0IHJlYyBkaXYgbiBpID1cbiAgICAgICAgaWYgbiA8PiAwICYmIG4gbW9kIDEwID0gMFxuICAgICAgICB0aGVuIGRpdiAobi8xMCkgKHN1Y2MgaSlcbiAgICAgICAgZWxzZVxuICAgICAgICBpZiBpID4gMlxuICAgICAgICB0aGVuIEZvcm1hdC5mcHJpbnRmIGZtdCBcIiVkZSVkXCIgbiBpXG4gICAgICAgIGVsc2UgRm9ybWF0LnBwX3ByaW50X2ludCBmbXQgdmludCBpblxuICAgICAgZGl2IHZpbnQgMFxuICAgIGVsc2VcbiAgICAgIGxldCBzMSA9IFByaW50Zi5zcHJpbnRmIFwiJS4xMmdcIiB2IGluXG4gICAgICBpZiB2ID0gZmxvYXRfb2Zfc3RyaW5nIHMxXG4gICAgICB0aGVuIEZvcm1hdC5wcF9wcmludF9zdHJpbmcgZm10IHMxXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBzMiA9IFByaW50Zi5zcHJpbnRmIFwiJS4xNWdcIiB2IGluXG4gICAgICAgIGlmIHYgPSBmbG9hdF9vZl9zdHJpbmcgczJcbiAgICAgICAgdGhlbiBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIGZtdCBzMlxuICAgICAgICBlbHNlICBGb3JtYXQuZnByaW50ZiBmbXQgXCIlLjE4Z1wiIHZcblxubGV0IHN0cmluZ19vZl9udW1iZXIgdiA9XG4gIEZvcm1hdC5hc3ByaW50ZiBcIiVhXCIgcHBfbnVtYmVyIHZcblxubW9kdWxlIFV0ZjggPSBzdHJ1Y3RcbiAgdHlwZSB1dGY4ID0gc3RyaW5nXG5cbiAgbGV0IG5vcm1hbGl6ZSBzcmMgPVxuICAgIGxldCB3YXJuID0gcmVmIGZhbHNlIGluXG4gICAgbGV0IGJ1ZmZlciA9IEJ1ZmZlci5jcmVhdGUgKFN0cmluZy5sZW5ndGggc3JjKSBpblxuICAgIFV1dGYuU3RyaW5nLmZvbGRfdXRmXzhcbiAgICAgIChmdW4gXyBfIGQgLT5cbiAgICAgICAgIG1hdGNoIGQgd2l0aFxuICAgICAgICAgfCBgVWNoYXIgY29kZSAtPiBVdXRmLkJ1ZmZlci5hZGRfdXRmXzggYnVmZmVyIGNvZGVcbiAgICAgICAgIHwgYE1hbGZvcm1lZCBfIC0+XG4gICAgICAgICAgICAgICBVdXRmLkJ1ZmZlci5hZGRfdXRmXzggYnVmZmVyIFV1dGYudV9yZXA7XG4gICAgICAgICAgICAgICB3YXJuOj10cnVlKVxuICAgICAgKCkgc3JjO1xuICAgIChCdWZmZXIuY29udGVudHMgYnVmZmVyLCAhd2FybilcblxuICBsZXQgbm9ybWFsaXphdGlvbl9uZWVkZWQgc3JjID1cbiAgICBsZXQgcmVjIGxvb3Agc3JjIGkgbCA9XG4gICAgICBpIDwgbCAmJlxuICAgICAgbWF0Y2ggc3JjLltpXSB3aXRoXG4gICAgICAoKiBDaGFyYWN0ZXJzIHRoYXQgbmVlZCB0byBiZSBlbmNvZGVkIGluIEhUTUwgKilcbiAgICAgIHwgJ1xcMDM0JyB8ICdcXDAzOCcgfCAnXFwwNjAnIHwnXFwwNjInIC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgKCogQVNDSUkgY2hhcmFjdGVycyAqKVxuICAgICAgfCAnXFwwMDknIHwgJ1xcMDEwJyB8ICdcXDAxMycgfCAnXFwwMzInLi4nXFwxMjYnIC0+XG4gICAgICAgICAgbG9vcCBzcmMgKGkgKyAxKSBsXG4gICAgICB8IF8gLT5cbiAgICAgICAgICB0cnVlXG4gICAgaW5cbiAgICBsb29wIHNyYyAwIChTdHJpbmcubGVuZ3RoIHNyYylcblxuICBsZXQgbm9ybWFsaXplX2h0bWwgc3JjID1cbiAgICBpZiBub3JtYWxpemF0aW9uX25lZWRlZCBzcmMgdGhlbiBiZWdpblxuICAgICAgbGV0IHdhcm4gPSByZWYgZmFsc2UgaW5cbiAgICAgIGxldCBidWZmZXIgPSBCdWZmZXIuY3JlYXRlIChTdHJpbmcubGVuZ3RoIHNyYykgaW5cbiAgICAgIFV1dGYuU3RyaW5nLmZvbGRfdXRmXzhcbiAgICAgICAgKGZ1biBfIF8gZCAtPlxuICAgICAgICAgICBtYXRjaCBkIHdpdGhcbiAgICAgICAgICAgfCBgVWNoYXIgdSAtPlxuICAgICAgICAgICAgICAgYmVnaW4gbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuICAgICAgICAgICAgICAgfCAzNCAtPlxuICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZmZlciBcIiZxdW90O1wiXG4gICAgICAgICAgICAgICB8IDM4IC0+XG4gICAgICAgICAgICAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmZmVyIFwiJmFtcDtcIlxuICAgICAgICAgICAgICAgfCA2MCAtPlxuICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZmZlciBcIiZsdDtcIlxuICAgICAgICAgICAgICAgfCA2MiAtPlxuICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZmZlciBcIiZndDtcIlxuICAgICAgICAgICAgICAgfCBjb2RlIC0+XG4gICAgICAgICAgICAgICAgICAgbGV0IHUgPVxuICAgICAgICAgICAgICAgICAgICAgKCogSWxsZWdhbCBjaGFyYWN0ZXJzIGluIGh0bWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2hhcmFjdGVyX2VuY29kaW5nc19pbl9IVE1MXG4gICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCAqKVxuICAgICAgICAgICAgICAgICAgICAgaWYgKCogQS4gY29udHJvbCBDMCAqKVxuICAgICAgICAgICAgICAgICAgICAgICAoY29kZSA8PSAzMSAmJiBjb2RlIDw+IDkgJiYgY29kZSA8PiAxMCAmJiBjb2RlIDw+IDEzKVxuICAgICAgICAgICAgICAgICAgICAgICAoKiBCLiBERUwgKyBjb250cm9sIEMxXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC0gaW52YWxpZCBpbiBodG1sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC0gZGlzY291cmFnZWQgaW4geG1sO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQgMHg4NSBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvbmV3bGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICBidXQgbGV0J3MgZGlzY2FyZCBpdCBhbnl3YXkgKilcbiAgICAgICAgICAgICAgICAgICAgICAgfHwgKGNvZGUgPj0gMTI3ICYmIGNvZGUgPD0gMTU5KVxuICAgICAgICAgICAgICAgICAgICAgICAoKiBDLiBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlcyA6IGFscmVhZHkgZGlzY2FyZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJ5IHV1dGYgfHwgKGNvZGUgPj0gMHhEODAwICYmIGNvZGUgPD0gMHhERkZGKSAqKVxuICAgICAgICAgICAgICAgICAgICAgICAoKiBELiBCT00gcmVsYXRlZCAqKVxuICAgICAgICAgICAgICAgICAgICAgICB8fCBjb2RlIGxhbmQgMHhGRkZGID0gMHhGRkZFXG4gICAgICAgICAgICAgICAgICAgICAgIHx8IGNvZGUgbGFuZCAweEZGRkYgPSAweEZGRkZcbiAgICAgICAgICAgICAgICAgICAgIHRoZW4gKHdhcm46PXRydWU7IFV1dGYudV9yZXApXG4gICAgICAgICAgICAgICAgICAgICBlbHNlIHVcbiAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgIFV1dGYuQnVmZmVyLmFkZF91dGZfOCBidWZmZXIgdVxuICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgIHwgYE1hbGZvcm1lZCBfIC0+XG4gICAgICAgICAgICAgICBVdXRmLkJ1ZmZlci5hZGRfdXRmXzggYnVmZmVyIFV1dGYudV9yZXA7XG4gICAgICAgICAgICAgICB3YXJuOj10cnVlKVxuICAgICAgICAoKSBzcmM7XG4gICAgICAoQnVmZmVyLmNvbnRlbnRzIGJ1ZmZlciwgIXdhcm4pXG4gICAgZW5kIGVsc2VcbiAgICAgIChzcmMsIGZhbHNlKVxuXG5lbmRcblxubW9kdWxlIHR5cGUgVGFnTGlzdCA9IHNpZyB2YWwgZW1wdHl0YWdzIDogc3RyaW5nIGxpc3QgZW5kXG5cbigqKiBGb3JtYXQgYmFzZWQgcHJpbnRlcnMgKilcblxubGV0IHBwX25vb3AgX2ZtdCBfID0gKClcblxubW9kdWxlIE1ha2VfZm10XG4gICAgKFhtbCA6IFhtbF9zaWdzLkl0ZXJhYmxlKVxuICAgIChJIDogVGFnTGlzdCkgPVxuc3RydWN0XG4gIG9wZW4gWG1sXG5cbiAgbGV0IG9wZW5fYm94IGluZGVudCBmbXQgPSBpZiBpbmRlbnQgdGhlbiBGb3JtYXQucHBfb3Blbl9ib3ggZm10IDAgZWxzZSAoKVxuICBsZXQgY2xvc2VfYm94IGluZGVudCBmbXQgPSBpZiBpbmRlbnQgdGhlbiBGb3JtYXQucHBfY2xvc2VfYm94IGZtdCAoKSBlbHNlICgpXG4gIGxldCBzcCBpbmRlbnQgZm10ID1cbiAgICBpZiBpbmRlbnQgdGhlbiBGb3JtYXQucHBfcHJpbnRfc3BhY2UgZm10ICgpIGVsc2UgRm9ybWF0LnBwX3ByaW50X3N0cmluZyBmbXQgXCIgXCJcbiAgbGV0IGN1dCBpbmRlbnQgZm10ID1cbiAgICBpZiBpbmRlbnQgdGhlbiBGb3JtYXQucHBfcHJpbnRfY3V0IGZtdCAoKSBlbHNlICgpXG5cbiAgbW9kdWxlIFMgPSBTZXQuTWFrZShTdHJpbmcpXG4gIGxldCBpc19lbXB0eXRhZyA9IG1hdGNoIEkuZW1wdHl0YWdzIHdpdGhcbiAgICB8IFtdIC0+IGZ1biBfIC0+IGZhbHNlXG4gICAgfCBsIC0+XG4gICAgICBsZXQgc2V0ID0gTGlzdC5mb2xkX2xlZnQgKGZ1biBzIHggLT4gUy5hZGQgeCBzKSBTLmVtcHR5IGwgaW5cbiAgICAgIGZ1biB4IC0+IFMubWVtIHggc2V0XG5cbiAgbGV0IHBwX2VuY29kZSBlbmNvZGUgaW5kZW50IGZtdCBzID1cbiAgICBsZXQgcyA9IGVuY29kZSBzIGluXG4gICAgaWYgaW5kZW50IHRoZW5cbiAgICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIkBbJWFAXVwiIEZvcm1hdC5wcF9wcmludF90ZXh0IHNcbiAgICBlbHNlXG4gICAgICBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIGZtdCBzXG5cbiAgbGV0IHBwX3NlcCBpbmRlbnQgPSBmdW5jdGlvblxuICAgIHwgU3BhY2UgLT4gZnVuIGZtdCAoKSAtPiBzcCBpbmRlbnQgZm10XG4gICAgfCBDb21tYSAtPiBmdW4gZm10ICgpIC0+IEZvcm1hdC5mcHJpbnRmIGZtdCBcIiwldFwiIChzcCBpbmRlbnQpXG5cbiAgbGV0IHBwX2F0dHJpYl92YWx1ZSBlbmNvZGUgaW5kZW50IGZtdCBhID0gbWF0Y2ggYWNvbnRlbnQgYSB3aXRoXG4gICAgfCBBRmxvYXQgZiAtPiBGb3JtYXQuZnByaW50ZiBmbXQgXCJcXFwiJWFcXFwiXCIgcHBfbnVtYmVyIGZcbiAgICB8IEFJbnQgaSAtPiBGb3JtYXQuZnByaW50ZiBmbXQgXCJcXFwiJWRcXFwiXCIgaVxuICAgIHwgQVN0ciBzIC0+IEZvcm1hdC5mcHJpbnRmIGZtdCBcIlxcXCIlc1xcXCJcIiAoZW5jb2RlIHMpXG4gICAgfCBBU3RyTCAoc2VwLCBzbGlzdCkgLT5cbiAgICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIlxcXCIlYVxcXCJcIlxuICAgICAgICAoRm9ybWF0LnBwX3ByaW50X2xpc3QgfnBwX3NlcDoocHBfc2VwIGluZGVudCBzZXApXG4gICAgICAgICAgIChwcF9lbmNvZGUgZW5jb2RlIGluZGVudCkpIHNsaXN0XG5cbiAgbGV0IHBwX2F0dHJpYiBlbmNvZGUgaW5kZW50IGZtdCBhID1cbiAgICBGb3JtYXQuZnByaW50ZiBmbXRcbiAgICAgIFwiJXQlcz0lYVwiIChzcCBpbmRlbnQpIChhbmFtZSBhKSAocHBfYXR0cmliX3ZhbHVlIGVuY29kZSBpbmRlbnQpIGFcblxuICBsZXQgcHBfYXR0cmlicyBlbmNvZGUgaW5kZW50ID1cbiAgICBGb3JtYXQucHBfcHJpbnRfbGlzdCB+cHBfc2VwOnBwX25vb3AgKHBwX2F0dHJpYiBlbmNvZGUgaW5kZW50KVxuXG4gIGxldCBwcF90YWdfYW5kX2F0dHJpYnMgZW5jb2RlIGluZGVudCBmbXQgKHRhZywgYXR0cnMpID1cbiAgICBvcGVuX2JveCBpbmRlbnQgZm10IDtcbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCIlcyVhJXRcIiB0YWcgKHBwX2F0dHJpYnMgZW5jb2RlIGluZGVudCkgYXR0cnMgKGN1dCBpbmRlbnQpO1xuICAgIGNsb3NlX2JveCBpbmRlbnQgZm10XG5cbiAgbGV0IHBwX2Nsb3NlZHRhZyBlbmNvZGUgaW5kZW50IGZtdCB0YWcgYXR0cnMgPVxuICAgIGlmIGlzX2VtcHR5dGFnIHRhZyB0aGVuXG4gICAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCI8JWEvPlwiIChwcF90YWdfYW5kX2F0dHJpYnMgZW5jb2RlIGluZGVudCkgKHRhZywgYXR0cnMpXG4gICAgZWxzZSBiZWdpblxuICAgICAgb3Blbl9ib3ggaW5kZW50IGZtdCA7XG4gICAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCI8JWE+JXQ8LyVzPlwiXG4gICAgICAgIChwcF90YWdfYW5kX2F0dHJpYnMgZW5jb2RlIGluZGVudCkgKHRhZywgYXR0cnMpXG4gICAgICAgIChjdXQgaW5kZW50KVxuICAgICAgICB0YWcgO1xuICAgICAgY2xvc2VfYm94IGluZGVudCBmbXRcbiAgICBlbmRcblxuICBsZXQgcmVjIHBwX3RhZyBlbmNvZGUgaW5kZW50IGZtdCB0YWcgYXR0cnMgY2hpbGRyZW4gPVxuICAgIG1hdGNoIGNoaWxkcmVuIHdpdGhcbiAgICB8IFtdIC0+IHBwX2Nsb3NlZHRhZyBlbmNvZGUgaW5kZW50IGZtdCB0YWcgYXR0cnNcbiAgICB8IF8gLT5cbiAgICAgIG9wZW5fYm94IGluZGVudCBmbXQgO1xuICAgICAgRm9ybWF0LmZwcmludGYgZm10IFwiPCV0JWE+JXQlYSV0JXQ8LyVzPlwiXG4gICAgICAgIChvcGVuX2JveCBpbmRlbnQpXG4gICAgICAgIChwcF90YWdfYW5kX2F0dHJpYnMgZW5jb2RlIGluZGVudCkgKHRhZywgYXR0cnMpXG4gICAgICAgIChjdXQgaW5kZW50KVxuICAgICAgICAocHBfZWx0cyBlbmNvZGUgaW5kZW50KSBjaGlsZHJlblxuICAgICAgICAoY2xvc2VfYm94IGluZGVudClcbiAgICAgICAgKGN1dCBpbmRlbnQpXG4gICAgICAgIHRhZyA7XG4gICAgICBjbG9zZV9ib3ggaW5kZW50IGZtdFxuXG4gIGFuZCBwcF9lbHQgZW5jb2RlIGluZGVudCBmbXQgZWx0ID0gbWF0Y2ggY29udGVudCBlbHQgd2l0aFxuICAgIHwgQ29tbWVudCB0ZXh0ZSAtPlxuICAgICAgRm9ybWF0LmZwcmludGYgZm10IFwiPCEtLSVzLS0+XCIgKGVzY2FwZV9jb21tZW50IHRleHRlKVxuXG4gICAgfCBFbnRpdHkgZSAtPlxuICAgICAgRm9ybWF0LmZwcmludGYgZm10IFwiJiVzO1wiIGVcblxuICAgIHwgUENEQVRBIHRleHRlIC0+XG4gICAgICBwcF9lbmNvZGUgZW5jb2RlIGluZGVudCBmbXQgdGV4dGVcblxuICAgIHwgRW5jb2RlZFBDREFUQSB0ZXh0ZSAtPlxuICAgICAgRm9ybWF0LnBwX3ByaW50X3N0cmluZyBmbXQgdGV4dGVcblxuICAgIHwgTm9kZSAobmFtZSwgeGhfYXR0cnMsIHhoX3RhZ2xpc3QpIC0+XG4gICAgICBwcF90YWcgZW5jb2RlIGluZGVudCBmbXQgbmFtZSB4aF9hdHRycyB4aF90YWdsaXN0XG5cbiAgICB8IExlYWYgKG5hbWUsIHhoX2F0dHJzKSAtPlxuICAgICAgcHBfY2xvc2VkdGFnIGVuY29kZSBpbmRlbnQgZm10IG5hbWUgeGhfYXR0cnNcblxuICAgIHwgRW1wdHkgLT4gKClcblxuICBhbmQgcHBfZWx0cyBlbmNvZGUgaW5kZW50ID1cbiAgICBGb3JtYXQucHBfcHJpbnRfbGlzdFxuICAgICAgfnBwX3NlcDooZnVuIGZtdCAoKSAtPiBjdXQgaW5kZW50IGZtdClcbiAgICAgIChwcF9lbHQgZW5jb2RlIGluZGVudClcblxuICBsZXQgcHAgPyhlbmNvZGU9ZW5jb2RlX3Vuc2FmZV9jaGFyKSA/KGluZGVudD1mYWxzZSkgKCkgPVxuICAgIHBwX2VsdCBlbmNvZGUgaW5kZW50XG5cbmVuZFxuXG5tb2R1bGUgTWFrZV90eXBlZF9mbXRcbiAgICAoWG1sIDogWG1sX3NpZ3MuSXRlcmFibGUpXG4gICAgKFR5cGVkX3htbCA6IFhtbF9zaWdzLlR5cGVkX3htbCB3aXRoIG1vZHVsZSBYbWwgOj0gWG1sKSA9XG5zdHJ1Y3RcblxuICBtb2R1bGUgUCA9IE1ha2VfZm10KFhtbCkoVHlwZWRfeG1sLkluZm8pXG5cbiAgKCogQWRkIGFuIHhtbG5zIHRhZyBvbiB0aGUgaHRtbCBlbGVtZW50IGlmIGl0J3Mgbm90IGFscmVhZHkgcHJlc2VudCAqKVxuICBsZXQgcHJlcGFyZV9kb2N1bWVudCBkb2MgPVxuICAgIGxldCBkb2MgPSBUeXBlZF94bWwuZG9jX3RvZWx0IGRvYyBpblxuICAgIG1hdGNoIFhtbC5jb250ZW50IGRvYyB3aXRoXG4gICAgfCBYbWwuTm9kZSAobiwgYSwgYykgLT5cbiAgICAgIGxldCBhID1cbiAgICAgICAgaWYgTGlzdC5leGlzdHMgKGZ1biBhIC0+IFhtbC5hbmFtZSBhID0gXCJ4bWxuc1wiKSBhXG4gICAgICAgIHRoZW4gYVxuICAgICAgICBlbHNlIFhtbC5zdHJpbmdfYXR0cmliIFwieG1sbnNcIiBUeXBlZF94bWwuSW5mby5uYW1lc3BhY2UgOjogYVxuICAgICAgaW5cbiAgICAgIFhtbC5ub2RlIH5hIG4gY1xuICAgIHwgXyAtPiBkb2NcblxuICBsZXQgcHBfZWx0ID8oZW5jb2RlPWVuY29kZV91bnNhZmVfY2hhcikgPyhpbmRlbnQ9ZmFsc2UpICgpIGZtdCBmb3JldCA9XG4gICAgUC5wcF9lbHQgZW5jb2RlIGluZGVudCBmbXQgKFR5cGVkX3htbC50b2VsdCBmb3JldClcblxuICBsZXQgcHAgPyhlbmNvZGUgPSBlbmNvZGVfdW5zYWZlX2NoYXIpID8oaW5kZW50PWZhbHNlKSA/YWR2ZXJ0ICgpIGZtdCBkb2MgPVxuICAgIEZvcm1hdC5wcF9vcGVuX3Zib3ggZm10IDAgO1xuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIiVzQCxcIiBUeXBlZF94bWwuSW5mby5kb2N0eXBlIDtcblxuICAgIGJlZ2luIG1hdGNoIGFkdmVydCB3aXRoXG4gICAgICB8IFNvbWUgcyAtPiBGb3JtYXQuZnByaW50ZiBmbXQgXCI8IS0tICVzIC0tPkAsXCIgc1xuICAgICAgfCBOb25lIC0+ICgpXG4gICAgZW5kIDtcblxuICAgIFAucHBfZWx0IGVuY29kZSBpbmRlbnQgZm10IChwcmVwYXJlX2RvY3VtZW50IGRvYykgO1xuICAgIEZvcm1hdC5wcF9jbG9zZV9ib3ggZm10ICgpO1xuXG5lbmRcblxubW9kdWxlIE1ha2VcbiAgICAoWG1sIDogWG1sX3NpZ3MuSXRlcmFibGUpXG4gICAgKEkgOiBUYWdMaXN0KVxuICAgIChPIDogWG1sX3NpZ3MuT3V0cHV0KSA9XG5zdHJ1Y3RcblxuICBsZXQgKCsrKSA9IE8uY29uY2F0XG5cbiAgb3BlbiBYbWxcblxuICBsZXQgc2VwYXJhdG9yX3RvX3N0cmluZyA9IGZ1bmN0aW9uXG4gICAgfCBTcGFjZSAtPiBcIiBcIlxuICAgIHwgQ29tbWEgLT4gXCIsIFwiXG5cbiAgbGV0IGF0dHJpYl92YWx1ZV90b19zdHJpbmcgZW5jb2RlIGEgPSBtYXRjaCBhY29udGVudCBhIHdpdGhcbiAgICB8IEFGbG9hdCBmIC0+IFByaW50Zi5zcHJpbnRmIFwiXFxcIiVzXFxcIlwiIChzdHJpbmdfb2ZfbnVtYmVyIGYpXG4gICAgfCBBSW50IGkgLT4gUHJpbnRmLnNwcmludGYgXCJcXFwiJWRcXFwiXCIgaVxuICAgIHwgQVN0ciBzIC0+IFByaW50Zi5zcHJpbnRmIFwiXFxcIiVzXFxcIlwiIChlbmNvZGUgcylcbiAgICB8IEFTdHJMIChzZXAsIHNsaXN0KSAtPlxuICAgICAgUHJpbnRmLnNwcmludGYgXCJcXFwiJXNcXFwiXCJcbiAgICAgICAgKGVuY29kZSAoU3RyaW5nLmNvbmNhdCAoc2VwYXJhdG9yX3RvX3N0cmluZyBzZXApIHNsaXN0KSlcblxuICBsZXQgYXR0cmliX3RvX3N0cmluZyBlbmNvZGUgYSA9XG4gICAgUHJpbnRmLnNwcmludGYgXCIlcz0lc1wiIChhbmFtZSBhKSAoYXR0cmliX3ZhbHVlX3RvX3N0cmluZyBlbmNvZGUgYSlcblxuICBsZXQgcmVjIHhoX3ByaW50X2F0dHJzIGVuY29kZSBhdHRycyA9IG1hdGNoIGF0dHJzIHdpdGhcbiAgICB8IFtdIC0+IE8uZW1wdHlcbiAgICB8IGF0dHI6OnF1ZXVlIC0+XG4gICAgICBPLnB1dCAoXCIgXCJeIGF0dHJpYl90b19zdHJpbmcgZW5jb2RlIGF0dHIpXG4gICAgICArKyB4aF9wcmludF9hdHRycyBlbmNvZGUgcXVldWVcblxuICBhbmQgeGhfcHJpbnRfY2xvc2VkdGFnIGVuY29kZSB0YWcgYXR0cnMgPVxuICAgIGlmIEkuZW1wdHl0YWdzID0gW10gfHwgTGlzdC5tZW0gdGFnIEkuZW1wdHl0YWdzXG4gICAgdGhlblxuICAgICAgKE8ucHV0IChcIjxcIl50YWcpXG4gICAgICAgKysgeGhfcHJpbnRfYXR0cnMgZW5jb2RlIGF0dHJzXG4gICAgICAgKysgTy5wdXQgXCIgLz5cIilcbiAgICBlbHNlXG4gICAgICAoTy5wdXQgKFwiPFwiXnRhZylcbiAgICAgICArKyB4aF9wcmludF9hdHRycyBlbmNvZGUgYXR0cnNcbiAgICAgICArKyBPLnB1dCAoXCI+PC9cIl50YWdeXCI+XCIpKVxuXG4gIGFuZCB4aF9wcmludF90YWcgZW5jb2RlIHRhZyBhdHRycyB0YWdsaXN0ID1cbiAgICBpZiB0YWdsaXN0ID0gW11cbiAgICB0aGVuIHhoX3ByaW50X2Nsb3NlZHRhZyBlbmNvZGUgdGFnIGF0dHJzXG4gICAgZWxzZVxuICAgICAgKE8ucHV0IChcIjxcIl50YWcpXG4gICAgICAgKysgeGhfcHJpbnRfYXR0cnMgZW5jb2RlIGF0dHJzXG4gICAgICAgKysgTy5wdXQgXCI+XCJcbiAgICAgICArKyB4aF9wcmludF90YWdsaXN0IGVuY29kZSB0YWdsaXN0XG4gICAgICAgKysgTy5wdXQgKFwiPC9cIl50YWdeXCI+XCIpKVxuXG4gIGFuZCBwcmludF9ub2RlcyBlbmNvZGUgbmFtZSB4aF9hdHRycyB4aF90YWdsaXN0IHF1ZXVlID1cbiAgICB4aF9wcmludF90YWcgZW5jb2RlIG5hbWUgeGhfYXR0cnMgeGhfdGFnbGlzdFxuICAgICsrIHhoX3ByaW50X3RhZ2xpc3QgZW5jb2RlIHF1ZXVlXG5cbiAgYW5kIHhoX3ByaW50X3RhZ2xpc3QgZW5jb2RlIHRhZ2xpc3QgPVxuICAgIG1hdGNoIHRhZ2xpc3Qgd2l0aFxuXG4gICAgfCBbXSAtPiBPLmVtcHR5XG5cbiAgICB8IGVsdCA6OiBxdWV1ZSAtPiBtYXRjaCBjb250ZW50IGVsdCB3aXRoXG5cbiAgICAgIHwgQ29tbWVudCB0ZXh0ZSAtPlxuICAgICAgICBPLnB1dCAoXCI8IS0tXCJeKGVuY29kZSB0ZXh0ZSleXCItLT5cIilcbiAgICAgICAgKysgeGhfcHJpbnRfdGFnbGlzdCBlbmNvZGUgcXVldWVcblxuICAgICAgfCBFbnRpdHkgZSAtPlxuICAgICAgICBPLnB1dCAoXCImXCJeZV5cIjtcIikgKCogbm8gZW5jb2RpbmcgKilcbiAgICAgICAgKysgeGhfcHJpbnRfdGFnbGlzdCBlbmNvZGUgcXVldWVcblxuICAgICAgfCBQQ0RBVEEgdGV4dGUgLT5cbiAgICAgICAgTy5wdXQgKGVuY29kZSB0ZXh0ZSlcbiAgICAgICAgKysgeGhfcHJpbnRfdGFnbGlzdCBlbmNvZGUgcXVldWVcblxuICAgICAgfCBFbmNvZGVkUENEQVRBIHRleHRlIC0+XG4gICAgICAgIE8ucHV0IHRleHRlXG4gICAgICAgICsrIHhoX3ByaW50X3RhZ2xpc3QgZW5jb2RlIHF1ZXVlXG5cbiAgICAgIHwgTm9kZSAobmFtZSwgeGhfYXR0cnMsIHhoX3RhZ2xpc3QpIC0+XG4gICAgICAgIHByaW50X25vZGVzIGVuY29kZSBuYW1lIHhoX2F0dHJzIHhoX3RhZ2xpc3QgcXVldWVcblxuICAgICAgfCBMZWFmIChuYW1lLCB4aF9hdHRycykgLT5cbiAgICAgICAgcHJpbnRfbm9kZXMgZW5jb2RlIG5hbWUgeGhfYXR0cnMgW10gcXVldWVcblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICB4aF9wcmludF90YWdsaXN0IGVuY29kZSBxdWV1ZVxuXG4gIGxldCBwcmludF9saXN0ID8oZW5jb2RlID0gZW5jb2RlX3Vuc2FmZV9jaGFyKSBmb3JldCA9XG4gICAgTy5tYWtlICh4aF9wcmludF90YWdsaXN0IGVuY29kZSBmb3JldClcblxuZW5kXG5cbm1vZHVsZSBNYWtlX3R5cGVkXG4gICAgKFhtbCA6IFhtbF9zaWdzLkl0ZXJhYmxlKVxuICAgIChUeXBlZF94bWwgOiBYbWxfc2lncy5UeXBlZF94bWwgd2l0aCBtb2R1bGUgWG1sIDo9IFhtbClcbiAgICAoTyA6IFhtbF9zaWdzLk91dHB1dCkgPVxuc3RydWN0XG5cbiAgbW9kdWxlIFAgPSBNYWtlKFhtbCkoVHlwZWRfeG1sLkluZm8pKE8pXG4gIGxldCAoKyspID0gTy5jb25jYXRcblxuICBsZXQgcHJpbnRfbGlzdCA/KGVuY29kZSA9IGVuY29kZV91bnNhZmVfY2hhcikgZm9yZXQgPVxuICAgIE8ubWFrZSAoUC54aF9wcmludF90YWdsaXN0IGVuY29kZSAoTGlzdC5tYXAgVHlwZWRfeG1sLnRvZWx0IGZvcmV0KSlcblxuICBsZXQgcHJpbnQgPyhlbmNvZGUgPSBlbmNvZGVfdW5zYWZlX2NoYXIpID8oYWR2ZXJ0ID0gXCJcIikgZG9jID1cbiAgICBsZXQgZG9jID0gVHlwZWRfeG1sLmRvY190b2VsdCBkb2MgaW5cbiAgICBsZXQgZG9jID0gbWF0Y2ggWG1sLmNvbnRlbnQgZG9jIHdpdGhcbiAgICAgIHwgWG1sLk5vZGUgKG4sIGEsIGMpIC0+XG4gICAgICAgIGxldCBhID1cbiAgICAgICAgICBpZiBMaXN0LmV4aXN0cyAoZnVuIGEgLT4gWG1sLmFuYW1lIGEgPSBcInhtbG5zXCIpIGFcbiAgICAgICAgICB0aGVuIGFcbiAgICAgICAgICBlbHNlIFhtbC5zdHJpbmdfYXR0cmliIFwieG1sbnNcIiBUeXBlZF94bWwuSW5mby5uYW1lc3BhY2UgOjogYVxuICAgICAgICBpblxuICAgICAgICBYbWwubm9kZSB+YSBuIGNcbiAgICAgIHwgXyAtPiBkb2MgaW5cbiAgICBPLm1ha2VcbiAgICAgIChPLnB1dCBUeXBlZF94bWwuSW5mby5kb2N0eXBlXG4gICAgICAgKysgTy5wdXQgKGlmIGFkdmVydCA8PiBcIlwiIHRoZW4gKFwiPCEtLSBcIiBeIGFkdmVydCBeIFwiIC0tPlxcblwiKSBlbHNlIFwiXFxuXCIpXG4gICAgICAgKysgUC54aF9wcmludF90YWdsaXN0IGVuY29kZSBbZG9jXSlcblxuZW5kXG5cbm1vZHVsZSBTaW1wbGVfb3V0cHV0KE0gOiBzaWcgdmFsIHB1dDogc3RyaW5nIC0+IHVuaXQgZW5kKSA9IHN0cnVjdFxuICB0eXBlIG91dCA9IHVuaXRcbiAgdHlwZSBtID0gdW5pdCAtPiB1bml0XG4gIGxldCBlbXB0eSAoKSA9ICgpXG4gIGxldCBjb25jYXQgZjEgZjIgKCkgPSBmMSAoKTsgZjIgKClcbiAgbGV0IHB1dCBzICgpID0gTS5wdXQgc1xuICBsZXQgbWFrZSBmID0gZiAoKVxuZW5kXG5cbm1vZHVsZSBNYWtlX3NpbXBsZVxuICAgIChYbWwgOiBYbWxfc2lncy5JdGVyYWJsZSlcbiAgICAoSSA6IFRhZ0xpc3QpID1cbnN0cnVjdFxuXG4gIGxldCBwcmludF9saXN0IH5vdXRwdXQgPVxuICAgIGxldCBtb2R1bGUgTSA9IE1ha2UoWG1sKShJKShTaW1wbGVfb3V0cHV0KHN0cnVjdCBsZXQgcHV0ID0gb3V0cHV0IGVuZCkpIGluXG4gICAgTS5wcmludF9saXN0XG5cbmVuZFxuXG5tb2R1bGUgTWFrZV90eXBlZF9zaW1wbGVcbiAgICAoWG1sIDogWG1sX3NpZ3MuSXRlcmFibGUpXG4gICAgKFR5cGVkX3htbCA6IFhtbF9zaWdzLlR5cGVkX3htbCB3aXRoICBtb2R1bGUgWG1sIDo9IFhtbCkgPVxuc3RydWN0XG5cbiAgbGV0IHByaW50X2xpc3Qgfm91dHB1dCA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIE1ha2VfdHlwZWQoWG1sKShUeXBlZF94bWwpKFNpbXBsZV9vdXRwdXQoc3RydWN0IGxldCBwdXQgPSBvdXRwdXQgZW5kKSkgaW5cbiAgICBNLnByaW50X2xpc3RcblxuICBsZXQgcHJpbnQgfm91dHB1dCA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIE1ha2VfdHlwZWQoWG1sKShUeXBlZF94bWwpKFNpbXBsZV9vdXRwdXQoc3RydWN0IGxldCBwdXQgPSBvdXRwdXQgZW5kKSkgaW5cbiAgICBNLnByaW50XG5cbmVuZFxuIiwiKCogVHlYTUxcbiAqIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvdHl4bWxcbiAqIENvcHlyaWdodCAoQykgMjAwNCBUaG9yc3RlbiBPaGwgPG9obEBwaHlzaWsudW5pLXd1ZXJ6YnVyZy5kZT5cbiAqIENvcHlyaWdodCAoQykgMjAwNyBHYWJyaWVsIEtlcm5laXNcbiAqIENvcHlyaWdodCAoQykgMjAxMCBDZWNpbGUgSGVyYmVsaW5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuICogZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAqIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbiAqIEZvdW5kYXRpb24sIEluYy4sIDUxIEZyYW5rbGluIFN0cmVldCwgU3VpdGUgNTAwLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEsIFVTQS5cbiopXG5cblxubW9kdWxlIE0gPSBzdHJ1Y3RcblxuICBtb2R1bGUgVyA9IFhtbF93cmFwLk5vV3JhcFxuXG4gIHR5cGUgJ2Egd3JhcCA9ICdhXG4gIHR5cGUgJ2EgbGlzdF93cmFwID0gJ2EgbGlzdFxuXG4gIHR5cGUgdXJpID0gc3RyaW5nXG4gIGxldCB1cmlfb2Zfc3RyaW5nIHMgPSBzXG4gIGxldCBzdHJpbmdfb2ZfdXJpIHMgPSBzXG5cbiAgdHlwZSBzZXBhcmF0b3IgPSBTcGFjZSB8IENvbW1hXG5cbiAgKCoqIEF0dHJpYnV0ZXMgKilcblxuICB0eXBlIGFuYW1lID0gc3RyaW5nXG4gIHR5cGUgYWNvbnRlbnQgPVxuICAgIHwgQUZsb2F0IG9mIGZsb2F0XG4gICAgfCBBSW50IG9mIGludFxuICAgIHwgQVN0ciBvZiBzdHJpbmdcbiAgICB8IEFTdHJMIG9mIHNlcGFyYXRvciAqIHN0cmluZyBsaXN0XG4gIHR5cGUgYXR0cmliID0gYW5hbWUgKiBhY29udGVudFxuXG4gIHR5cGUgZXZlbnRfaGFuZGxlciA9IHN0cmluZ1xuICB0eXBlIG1vdXNlX2V2ZW50X2hhbmRsZXIgPSBzdHJpbmdcbiAgdHlwZSBrZXlib2FyZF9ldmVudF9oYW5kbGVyID0gc3RyaW5nXG4gIHR5cGUgdG91Y2hfZXZlbnRfaGFuZGxlciA9IHN0cmluZ1xuXG4gIGxldCBhY29udGVudCAoXywgYSkgPSBhXG4gIGxldCBhbmFtZSAobmFtZSwgXykgPSBuYW1lXG5cbiAgbGV0IGZsb2F0X2F0dHJpYiBuYW1lIHZhbHVlID0gbmFtZSwgQUZsb2F0IHZhbHVlXG4gIGxldCBpbnRfYXR0cmliIG5hbWUgdmFsdWUgPSBuYW1lLCBBSW50IHZhbHVlXG4gIGxldCBzdHJpbmdfYXR0cmliIG5hbWUgdmFsdWUgPSBuYW1lLCBBU3RyIHZhbHVlXG4gIGxldCBzcGFjZV9zZXBfYXR0cmliIG5hbWUgdmFsdWVzID0gbmFtZSwgQVN0ckwgKFNwYWNlLCB2YWx1ZXMpXG4gIGxldCBjb21tYV9zZXBfYXR0cmliIG5hbWUgdmFsdWVzID0gbmFtZSwgQVN0ckwgKENvbW1hLCB2YWx1ZXMpXG4gIGxldCBldmVudF9oYW5kbGVyX2F0dHJpYiBuYW1lIHZhbHVlID0gbmFtZSwgQVN0ciB2YWx1ZVxuICBsZXQgbW91c2VfZXZlbnRfaGFuZGxlcl9hdHRyaWIgbmFtZSB2YWx1ZSA9IG5hbWUsIEFTdHIgdmFsdWVcbiAgbGV0IGtleWJvYXJkX2V2ZW50X2hhbmRsZXJfYXR0cmliIG5hbWUgdmFsdWUgPSBuYW1lLCBBU3RyIHZhbHVlXG4gIGxldCB0b3VjaF9ldmVudF9oYW5kbGVyX2F0dHJpYiBuYW1lIHZhbHVlID0gbmFtZSwgQVN0ciB2YWx1ZVxuICBsZXQgdXJpX2F0dHJpYiBuYW1lIHZhbHVlID0gbmFtZSwgQVN0ciB2YWx1ZVxuICBsZXQgdXJpc19hdHRyaWIgbmFtZSB2YWx1ZXMgPSBuYW1lLCBBU3RyTCAoU3BhY2UsIHZhbHVlcylcblxuXG4gICgqKiBFbGVtZW50ICopXG5cbiAgdHlwZSBlbmFtZSA9IHN0cmluZ1xuICB0eXBlIGVjb250ZW50ID1cbiAgICB8IEVtcHR5XG4gICAgfCBDb21tZW50IG9mIHN0cmluZ1xuICAgIHwgRW5jb2RlZFBDREFUQSBvZiBzdHJpbmdcbiAgICB8IFBDREFUQSBvZiBzdHJpbmdcbiAgICB8IEVudGl0eSBvZiBzdHJpbmdcbiAgICB8IExlYWYgb2YgZW5hbWUgKiBhdHRyaWIgbGlzdFxuICAgIHwgTm9kZSBvZiBlbmFtZSAqIGF0dHJpYiBsaXN0ICogZWNvbnRlbnQgbGlzdFxuXG4gIHR5cGUgZWx0ID0gIGVjb250ZW50XG5cbiAgbGV0IGNvbnRlbnQgZWx0ID0gZWx0XG5cbiAgbGV0IGVtcHR5ICgpID0gRW1wdHlcblxuICBsZXQgY29tbWVudCBjID0gQ29tbWVudCBjXG5cbiAgbGV0IHBjZGF0YSBkID0gUENEQVRBIGRcbiAgbGV0IGVuY29kZWRwY2RhdGEgZCA9IEVuY29kZWRQQ0RBVEEgZFxuICBsZXQgZW50aXR5IGUgPSBFbnRpdHkgZVxuXG4gICgqIEZvciBzZWN1cml0eSByZWFzb25zLCB3ZSBkbyBub3QgYWxsb3cgXCJdXT5cIiBpbnNpZGUgQ0RBVEFcbiAgICAgKGFzIHRoaXMgc3RyaW5nIGlzIHRvIGJlIGNvbnNpZGVyZWQgYXMgdGhlIGVuZCBvZiB0aGUgY2RhdGEpXG4gICopXG4gIGxldCByZV9lbmRfY2RhdGEgPSBSZS4oY29tcGlsZSBAQCBzdHIgXCJdXT5cIilcbiAgbGV0IGVuY29kZWRfY2RhdGEgczEgczIgcyA9XG4gICAgZW5jb2RlZHBjZGF0YVxuICAgICAgKFByaW50Zi5zcHJpbnRmIFwiXFxuJXNcXG4lc1xcbiVzXFxuXCJcbiAgICAgICAgIHMxXG4gICAgICAgICAoUmUucmVwbGFjZV9zdHJpbmcgfmFsbDp0cnVlIHJlX2VuZF9jZGF0YSB+Ynk6XCJcIiBzKVxuICAgICAgICAgczIgKVxuXG4gIGxldCBjZGF0YSA9IGVuY29kZWRfY2RhdGEgXCI8IVtDREFUQVtcIiBcIl1dPlwiXG4gIGxldCBjZGF0YV9zY3JpcHQgPSBlbmNvZGVkX2NkYXRhIFwiLy88IVtDREFUQVtcIiBcIi8vXV0+XCJcbiAgbGV0IGNkYXRhX3N0eWxlID0gZW5jb2RlZF9jZGF0YSBcIi8qIDwhW0NEQVRBWyAqL1wiIFwiLyogXV0+ICovXCJcblxuICBsZXQgbGVhZiA/KGE9W10pIG5hbWUgPSBMZWFmIChuYW1lLCBhKVxuICBsZXQgbm9kZSA/KGE9W10pIG5hbWUgY2hpbGRyZW4gPSBOb2RlIChuYW1lLCBhLCBjaGlsZHJlbilcblxuZW5kXG5cbmluY2x1ZGUgTVxuaW5jbHVkZSBYbWxfcHJpbnQuTWFrZV9zaW1wbGUoTSkoc3RydWN0IGxldCBlbXB0eXRhZ3MgPSBbXSBlbmQpXG5bQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cblxuaW5jbHVkZSBYbWxfaXRlci5NYWtlKE0pXG5pbmNsdWRlIFhtbF9wcmludC5NYWtlX2ZtdChNKShzdHJ1Y3QgbGV0IGVtcHR5dGFncyA9IFtdIGVuZClcblxuaW5jbHVkZSBYbWxfc3RyZWFtLkltcG9ydChNKVxubGV0IHByaW50IGZtdCB4ID0gcHJpbnRfbGlzdCB+b3V0cHV0OihGb3JtYXQucHBfcHJpbnRfc3RyaW5nIGZtdCkgW3hdXG4iLCIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxuXG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG50eXBlICdhIHQgPSB7XG4gIG11dGFibGUgcHJldiA6ICdhIHQ7XG4gIG11dGFibGUgbmV4dCA6ICdhIHQ7XG59XG5cbnR5cGUgJ2Egbm9kZSA9IHtcbiAgbm9kZV9wcmV2IDogJ2EgdDtcbiAgbm9kZV9uZXh0IDogJ2EgdDtcbiAgbXV0YWJsZSBub2RlX2RhdGEgOiAnYTtcbiAgbXV0YWJsZSBub2RlX2FjdGl2ZSA6IGJvb2w7XG59XG5cbmV4dGVybmFsIHNlcV9vZl9ub2RlIDogJ2Egbm9kZSAtPiAnYSB0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgbm9kZV9vZl9zZXEgOiAnYSB0IC0+ICdhIG5vZGUgPSBcIiVpZGVudGl0eVwiXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgT3BlcmF0aW9ucyBvbiBub2RlcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxubGV0IGdldCBub2RlID1cbiAgbm9kZS5ub2RlX2RhdGFcblxubGV0IHNldCBub2RlIGRhdGEgPVxuICBub2RlLm5vZGVfZGF0YSA8LSBkYXRhXG5cbmxldCByZW1vdmUgbm9kZSA9XG4gIGlmIG5vZGUubm9kZV9hY3RpdmUgdGhlbiBiZWdpblxuICAgIG5vZGUubm9kZV9hY3RpdmUgPC0gZmFsc2U7XG4gICAgbGV0IHNlcSA9IHNlcV9vZl9ub2RlIG5vZGUgaW5cbiAgICBzZXEucHJldi5uZXh0IDwtIHNlcS5uZXh0O1xuICAgIHNlcS5uZXh0LnByZXYgPC0gc2VxLnByZXZcbiAgZW5kXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgT3BlcmF0aW9ucyBvbiBzZXF1ZW5jZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxubGV0IGNyZWF0ZSAoKSA9XG4gIGxldCByZWMgc2VxID0geyBwcmV2ID0gc2VxOyBuZXh0ID0gc2VxIH0gaW5cbiAgc2VxXG5cbmxldCBjbGVhciBzZXEgPVxuICBzZXEucHJldiA8LSBzZXE7XG4gIHNlcS5uZXh0IDwtIHNlcVxuXG5sZXQgaXNfZW1wdHkgc2VxID0gc2VxLm5leHQgPT0gc2VxXG5cbmxldCBsZW5ndGggc2VxID1cbiAgbGV0IHJlYyBsb29wIGN1cnIgbGVuID1cbiAgICBpZiBjdXJyID09IHNlcSB0aGVuXG4gICAgICBsZW5cbiAgICBlbHNlXG4gICAgICBsZXQgbm9kZSA9IG5vZGVfb2Zfc2VxIGN1cnIgaW4gbG9vcCBub2RlLm5vZGVfbmV4dCAobGVuICsgMSlcbiAgaW5cbiAgbG9vcCBzZXEubmV4dCAwXG5cbmxldCBhZGRfbCBkYXRhIHNlcSA9XG4gIGxldCBub2RlID0geyBub2RlX3ByZXYgPSBzZXE7IG5vZGVfbmV4dCA9IHNlcS5uZXh0OyBub2RlX2RhdGEgPSBkYXRhOyBub2RlX2FjdGl2ZSA9IHRydWUgfSBpblxuICBzZXEubmV4dC5wcmV2IDwtIHNlcV9vZl9ub2RlIG5vZGU7XG4gIHNlcS5uZXh0IDwtIHNlcV9vZl9ub2RlIG5vZGU7XG4gIG5vZGVcblxubGV0IGFkZF9yIGRhdGEgc2VxID1cbiAgbGV0IG5vZGUgPSB7IG5vZGVfcHJldiA9IHNlcS5wcmV2OyBub2RlX25leHQgPSBzZXE7IG5vZGVfZGF0YSA9IGRhdGE7IG5vZGVfYWN0aXZlID0gdHJ1ZSB9IGluXG4gIHNlcS5wcmV2Lm5leHQgPC0gc2VxX29mX25vZGUgbm9kZTtcbiAgc2VxLnByZXYgPC0gc2VxX29mX25vZGUgbm9kZTtcbiAgbm9kZVxuXG5sZXQgdGFrZV9sIHNlcSA9XG4gIGlmIGlzX2VtcHR5IHNlcSB0aGVuXG4gICAgcmFpc2UgRW1wdHlcbiAgZWxzZSBiZWdpblxuICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgc2VxLm5leHQgaW5cbiAgICByZW1vdmUgbm9kZTtcbiAgICBub2RlLm5vZGVfZGF0YVxuICBlbmRcblxubGV0IHRha2VfciBzZXEgPVxuICBpZiBpc19lbXB0eSBzZXEgdGhlblxuICAgIHJhaXNlIEVtcHR5XG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgbm9kZSA9IG5vZGVfb2Zfc2VxIHNlcS5wcmV2IGluXG4gICAgcmVtb3ZlIG5vZGU7XG4gICAgbm9kZS5ub2RlX2RhdGFcbiAgZW5kXG5cbmxldCB0YWtlX29wdF9sIHNlcSA9XG4gIGlmIGlzX2VtcHR5IHNlcSB0aGVuXG4gICAgTm9uZVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBzZXEubmV4dCBpblxuICAgIHJlbW92ZSBub2RlO1xuICAgIFNvbWUgbm9kZS5ub2RlX2RhdGFcbiAgZW5kXG5cbmxldCB0YWtlX29wdF9yIHNlcSA9XG4gIGlmIGlzX2VtcHR5IHNlcSB0aGVuXG4gICAgTm9uZVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBzZXEucHJldiBpblxuICAgIHJlbW92ZSBub2RlO1xuICAgIFNvbWUgbm9kZS5ub2RlX2RhdGFcbiAgZW5kXG5cbmxldCB0cmFuc2Zlcl9sIHMxIHMyID1cbiAgczIubmV4dC5wcmV2IDwtIHMxLnByZXY7XG4gIHMxLnByZXYubmV4dCA8LSBzMi5uZXh0O1xuICBzMi5uZXh0IDwtIHMxLm5leHQ7XG4gIHMxLm5leHQucHJldiA8LSBzMjtcbiAgczEucHJldiA8LSBzMTtcbiAgczEubmV4dCA8LSBzMVxuXG5sZXQgdHJhbnNmZXJfciBzMSBzMiA9XG4gIHMyLnByZXYubmV4dCA8LSBzMS5uZXh0O1xuICBzMS5uZXh0LnByZXYgPC0gczIucHJldjtcbiAgczIucHJldiA8LSBzMS5wcmV2O1xuICBzMS5wcmV2Lm5leHQgPC0gczI7XG4gIHMxLnByZXYgPC0gczE7XG4gIHMxLm5leHQgPC0gczFcblxubGV0IGl0ZXJfbCBmIHNlcSA9XG4gIGxldCByZWMgbG9vcCBjdXJyID1cbiAgICBpZiBjdXJyICE9IHNlcSB0aGVuIGJlZ2luXG4gICAgICBsZXQgbm9kZSA9IG5vZGVfb2Zfc2VxIGN1cnIgaW5cbiAgICAgIGlmIG5vZGUubm9kZV9hY3RpdmUgdGhlbiBmIG5vZGUubm9kZV9kYXRhO1xuICAgICAgbG9vcCBub2RlLm5vZGVfbmV4dFxuICAgIGVuZFxuICBpblxuICBsb29wIHNlcS5uZXh0XG5cbmxldCBpdGVyX3IgZiBzZXEgPVxuICBsZXQgcmVjIGxvb3AgY3VyciA9XG4gICAgaWYgY3VyciAhPSBzZXEgdGhlbiBiZWdpblxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluXG4gICAgICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW4gZiBub2RlLm5vZGVfZGF0YTtcbiAgICAgIGxvb3Agbm9kZS5ub2RlX3ByZXZcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBzZXEucHJldlxuXG5sZXQgaXRlcl9ub2RlX2wgZiBzZXEgPVxuICBsZXQgcmVjIGxvb3AgY3VyciA9XG4gICAgaWYgY3VyciAhPSBzZXEgdGhlbiBiZWdpblxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluXG4gICAgICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW4gZiBub2RlO1xuICAgICAgbG9vcCBub2RlLm5vZGVfbmV4dFxuICAgIGVuZFxuICBpblxuICBsb29wIHNlcS5uZXh0XG5cbmxldCBpdGVyX25vZGVfciBmIHNlcSA9XG4gIGxldCByZWMgbG9vcCBjdXJyID1cbiAgICBpZiBjdXJyICE9IHNlcSB0aGVuIGJlZ2luXG4gICAgICBsZXQgbm9kZSA9IG5vZGVfb2Zfc2VxIGN1cnIgaW5cbiAgICAgIGlmIG5vZGUubm9kZV9hY3RpdmUgdGhlbiBmIG5vZGU7XG4gICAgICBsb29wIG5vZGUubm9kZV9wcmV2XG4gICAgZW5kXG4gIGluXG4gIGxvb3Agc2VxLnByZXZcblxubGV0IGZvbGRfbCBmIHNlcSBhY2MgPVxuICBsZXQgcmVjIGxvb3AgY3VyciBhY2MgPVxuICAgIGlmIGN1cnIgPT0gc2VxIHRoZW5cbiAgICAgIGFjY1xuICAgIGVsc2VcbiAgICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgY3VyciBpblxuICAgICAgaWYgbm9kZS5ub2RlX2FjdGl2ZSB0aGVuXG4gICAgICAgIGxvb3Agbm9kZS5ub2RlX25leHQgKGYgbm9kZS5ub2RlX2RhdGEgYWNjKVxuICAgICAgZWxzZVxuICAgICAgICBsb29wIG5vZGUubm9kZV9uZXh0IGFjY1xuICBpblxuICBsb29wIHNlcS5uZXh0IGFjY1xuXG5sZXQgZm9sZF9yIGYgc2VxIGFjYyA9XG4gIGxldCByZWMgbG9vcCBjdXJyIGFjYyA9XG4gICAgaWYgY3VyciA9PSBzZXEgdGhlblxuICAgICAgYWNjXG4gICAgZWxzZVxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluXG4gICAgICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW5cbiAgICAgICAgbG9vcCBub2RlLm5vZGVfcHJldiAoZiBub2RlLm5vZGVfZGF0YSBhY2MpXG4gICAgICBlbHNlXG4gICAgICAgIGxvb3Agbm9kZS5ub2RlX3ByZXYgYWNjXG4gIGluXG4gIGxvb3Agc2VxLnByZXYgYWNjXG5cbmxldCBmaW5kX25vZGVfbCBmIHNlcSA9XG4gIGxldCByZWMgbG9vcCBjdXJyID1cbiAgICBpZiBjdXJyICE9IHNlcSB0aGVuXG4gICAgICBsZXQgbm9kZSA9IG5vZGVfb2Zfc2VxIGN1cnIgaW5cbiAgICAgIGlmIG5vZGUubm9kZV9hY3RpdmUgdGhlblxuICAgICAgICBpZiBmIG5vZGUubm9kZV9kYXRhIHRoZW5cbiAgICAgICAgICBub2RlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsb29wIG5vZGUubm9kZV9uZXh0XG4gICAgICBlbHNlXG4gICAgICAgIGxvb3Agbm9kZS5ub2RlX25leHRcbiAgICBlbHNlXG4gICAgICByYWlzZSBOb3RfZm91bmRcbiAgaW5cbiAgbG9vcCBzZXEubmV4dFxuXG5sZXQgZmluZF9ub2RlX3IgZiBzZXEgPVxuICBsZXQgcmVjIGxvb3AgY3VyciA9XG4gICAgaWYgY3VyciAhPSBzZXEgdGhlblxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluXG4gICAgICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW5cbiAgICAgICAgaWYgZiBub2RlLm5vZGVfZGF0YSB0aGVuXG4gICAgICAgICAgbm9kZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbG9vcCBub2RlLm5vZGVfcHJldlxuICAgICAgZWxzZVxuICAgICAgICBsb29wIG5vZGUubm9kZV9wcmV2XG4gICAgZWxzZVxuICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gIGluXG4gIGxvb3Agc2VxLnByZXZcblxubGV0IGZpbmRfbm9kZV9vcHRfbCBmIHNlcSA9XG4gIHRyeSBTb21lIChmaW5kX25vZGVfbCBmIHNlcSkgd2l0aCBOb3RfZm91bmQgLT4gTm9uZVxuXG5sZXQgZmluZF9ub2RlX29wdF9yIGYgc2VxID1cbiAgdHJ5IFNvbWUgKGZpbmRfbm9kZV9yIGYgc2VxKSB3aXRoIE5vdF9mb3VuZCAtPiBOb25lXG4iLCIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxuXG5cbigqIFJlYWRpbmcgZ3VpZGVcblxuICAgV2VsY29tZSB0byB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIEx3dCBjb3JlISBUaGlzIGlzIGEgYmlnIGZpbGUsIGJ1dCB3ZVxuICAgaG9wZSB0aGF0IHJlYWRpbmcgaXQgKHBhcnRzIGF0IGEgdGltZSEpIHdpbGwgbm90IGJlIHNjYXJ5IDopIEhlcmUgaXMgd2h5OlxuXG5cbiAgICogU2VjdGlvbmluZ1xuXG4gICBUaGUgY29kZSBpcyBicm9rZW4gdXAgaW50byBzZWN0aW9ucywgZWFjaCBvbmUgb2Ygd2hpY2ggaXMgYW4gaW50ZXJuYWwgbW9kdWxlLlxuICAgTW9zdCBvZiB0aGUgbW9kdWxlcyBoYXZlIGEgc2lnbmF0dXJlLCB3aGljaCBzZXJ2ZXMgYXMgYSBuZWF0IHRhYmxlIG9mXG4gICBjb250ZW50cy5cblxuICAgSXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3UgcmVhZCB0aGlzIGZpbGUgd2l0aCBjb2RlIGZvbGRpbmcgZW5hYmxlZC4gSWYgeW91XG4gICBmb2xkIGFsbCB0aGUgbW9kdWxlcywgeW91IGNhbiB2aXN1YWxpemUgdGhlIGxvZ2ljYWwgc3RydWN0dXJlIG9mIEx3dCBxdWl0ZVxuICAgZWFzaWx5LiBZb3UgY2FuIHRoZW4gZXhwYW5kIG1vZHVsZXMgYXMgbmVlZGVkLCBkZXBlbmRpbmcgb24gd2hhdCBwYXJ0IG9mIHRoZVxuICAgaW1wbGVtZW50YXRpb24geW91IGFyZSBpbnRlcmVzdGVkIGluLiBXaXRob3V0IGNvZGUgZm9sZGluZywgeW91IGZhY2UgYW5cbiAgIGludGltaWRhdGluZyB3YWxsIG9mIGNvZGUgOiggWW91IGNhbiBzdGlsbCB2aXN1YWxseSBwYXJzZSB0aGUgZmlsZSwgaG93ZXZlcixcbiAgIGJlY2F1c2UgdGhlcmUgYXJlIHBsZW50eSBvZiBibGFuayBsaW5lcyB0byBoZWxwIHNlY3Rpb24gdGhpbmdzIG9mZi4gWW91IGNhblxuICAgYWxzbyB2aWV3IHRoaXMgZmlsZSBmb2xkZWQgb25saW5lOlxuXG4gICAgIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2FhbnRyb24vOWZhYjBiZGVhZDk4YTYwZmNjZjA2ZTAxODkxODY4NjNcbiAgICAgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYWFudHJvbi85N2I1ODUyMGQ1YmI0ODU4Y2NhYzZmNTQ3MDBhMjRkN1xuXG4gICBUaGUgc2lnbmF0dXJlcyBhcmUgdW51c3VhbDogYmlnIGNvbW1lbnRzIGFyZSBhYnNlbnQuIFRoZXkgYXJlIG1vdmVkIGludG8gdGhlXG4gICBtb2R1bGVzLCBzbyB0aGF0IHRoZXkgYXJlIGhpZGRlbiBieSBjb2RlIGZvbGRpbmcgd2hlbiB5b3UgKHRoZSByZWFkZXIhKSBhcmVcbiAgIG5vdCBpbnRlcmVzdGVkIGluIHRob3NlIG1vZHVsZXMuXG5cblxuICAgKiBEb2N1bWVudGF0aW9uXG5cbiAgIFRoZSBkb2N1bWVudGF0aW9uIGJlZ2lucyB3aXRoIGFuIG92ZXJ2aWV3IG9mIG1ham9yIGNvbmNlcHRzIGFuZCBjb21wb25lbnRzLlxuICAgVGhpcyBvdmVydmlldyBwdXRzIGV2ZXJ5dGhpbmcgaW50byBjb250ZXh0LiBZb3UgZG9uJ3QgaGF2ZSB0byByZWFkIHRoZSB3aG9sZVxuICAgdGhpbmcuIFRoZSBvdmVydmlldyBiZWdpbnMgd2l0aCBiYXNpYyBjb25jZXB0cywgbW92ZXMgb24gdG8gYWR2YW5jZWQgb25lcyxcbiAgIGFuZCB0aGVuIGdldHMgaW50byB0aGUgdHJ1bHkgZXNvdGVyaWMuIFlvdSBjYW4gcmVhZCBhYm91dCBlYWNoIGNvbmNlcHQgb24gYW5cbiAgIGFzLW5lZWRlZCBiYXNpcy4gSG93ZXZlciwgb25jZSB5b3UgaGF2ZSByZWFkIHRoZSB3aG9sZSBvdmVydmlldywgeW91IHdpbGwgYmVcbiAgIGF3YXJlIG9mICpldmVyeXRoaW5nKiB0aGF0IGlzIG5lZWRlZCB0byB1bmRlcnN0YW5kLCBhbmQgd29yayB3aXRoLCB0aGUgY29yZVxuICAgb2YgTHd0LlxuXG4gICBMaXR0ZXJlZCBpbiB0aGUgY29kZSBhcmUgYWRkaXRpb25hbCBjb21tZW50cywgdGhhdCBnbyBpbi1kZXB0aCBvbiB2YXJpb3VzXG4gICBsb2NhbCBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLCBvcHBvcnR1bml0aWVzLCByZWdyZXRzLCBhbmQgdGhlIGxpa2UuXG5cbiAgIFRoZSBzZWN0aW9ucyAobW9kdWxlcykgb2YgdGhlIGNvZGUgY29ycmVzcG9uZCBjbG9zZWx5IHRvIHNlY3Rpb25zIG9mIHRoZVxuICAgb3ZlcnZpZXcuXG5cblxuICAgKiBXaGl0ZXNwYWNlXG5cbiAgIFRoZSB0b3RhbCBsaW5lIGNvdW50IG9mIHRoaXMgZmlsZSBtYXkgc2VlbSBmcmlnaHRlbmluZywgYnV0IG9uZSB0aGlyZCBvZiBpdFxuICAgaXMgd2hpdGVzcGFjZSBhbmQgY29tbWVudHMsIGJvdGggdGhlcmUgdG8gaGVscCB5b3UgcmVhZCB0aGUgcmVtYWluaW5nIHR3b1xuICAgdGhpcmRzIVxuXG4gICBBbHNvLCB3aXRoaW4gdGhvc2UgdHdvIHRoaXJkcywgdGhlcmUgYXJlIGxhcmdlIGdyb3VwcyBvZiBmdW5jdGlvbnMgdGhhdCBhcmVcbiAgIHJlcGV0aXRpdmUgYW5kIGZvcm11bGFpYywgc28gdGhlcmUgaXMgbXVjaCBsZXNzIGNvbmNlcHR1YWxseS11bmlxdWUgY29kZSBpblxuICAgTHd0IHRoYW4geW91IG1pZ2h0IHRoaW5rIGF0IGZpcnN0LlxuXG5cbiAgICogUGxlYXNlIGVkaXQgdGhlIGNvZGUgYW5kIHRoZSBkb2NzIVxuXG4gICBUaGlzIGNvZGUgaXMgbWVhbnQgdG8gYmUgcmVhZGFibGUsIGFuZCB0byBiZSBlZGl0ZWQuIElmIHlvdSBhcmUgcmVhZGluZ1xuICAgc29tZXRoaW5nLCBhbmQgdGhpbmsgdGhlcmUgaXMgYSBiZXR0ZXIgd2F5IHRvIGV4cHJlc3MgaXQsIHBsZWFzZSBnbyBhaGVhZCBhbmRcbiAgIG9wZW4gYSBwdWxsIHJlcXVlc3QgdG8gdGhlIEx3dCByZXBvc2l0b3J5IGF0XG5cbiAgICAgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0XG5cbiAgIEV2ZW4gaWYgeW91ciBwdWxsIHJlcXVlc3Qgc29tZWhvdyBkb2Vzbid0IGdldCBtZXJnZWQsIHlvdSB3aWxsIGhhdmUgZWR1Y2F0ZWRcbiAgIHRoZSBtYWludGFpbmVycywgbm90IHRvIG1lbnRpb24gb3RoZXIgY29udHJpYnV0b3JzLCBhbmQgdXNlcnMuIFRoaXMgaXMgdHJ1ZVxuICAgZXZlbiBpZiB0aGUgY2hhbmdlIGlzIHRyaXZpYWwgLS0gc29tZXRpbWVzLCBtYWludGFpbmVycyBqdXN0IG5lZWQgdG8gYmVcbiAgIGVkdWNhdGVkIG11bHRpcGxlIHRpbWVzIGJlZm9yZSB0aGV5IHNlZSB0aGUgd2lzZG9tIG9mIGl0IDovXG5cbiAgIExpa2V3aXNlLCBpZiB5b3Ugd291bGQgbGlrZSB0byBtYWtlIGEgY29kZSBjb250cmlidXRpb24gdG8gdGhlIEx3dCBjb3JlLCBpdFxuICAgaXMgcXVpdGUgd2VsY29tZSwgYW5kIHdlIGhvcGUgdGhhdCB0aGlzIGNvZGUgaXMgcmVhZGFibGUgZW5vdWdoIGZvciB5b3UgdG8gYmVcbiAgIGFibGUgdG8gbWFrZSBpdCFcblxuXG4gICBFbmpveSEgKilcblxuXG5cbigqIE92ZXJ2aWV3XG5cbiAgIEluIHRoaXMgZmlsZSwgdGhlcmUgaXMgYSBcIm1vZGVsXCIgZnVuY3Rpb24gLS0gW0x3dC5iaW5kXSAtLSB3aGljaCBwdWxsc1xuICAgdG9nZXRoZXIgbWFueSAodGhvdWdoIG5vdCBhbGwpIG9mIHRoZSBjb25jZXB0cyBhbmQgaGVscGVycyBkaXNjdXNzZWQgaW4gdGhpc1xuICAgb3ZlcnZpZXcuIFRvIGZpbmQgaXQsIHNlYXJjaCBmb3IgXCJsZXQgYmluZCxcIiBhbmQgeW91IGNhbiBleGFtaW5lIGl0IHdoaWxlXG4gICByZWFkaW5nIHRoZSBvdmVydmlldy4gVGhlIGF1dGhvcnMgb2YgdGhpcyBmaWxlIGludGVuZCB0byBwdXQgZXh0cmEgZWZmb3J0XG4gICBpbnRvIHdyaXRpbmcgbmljZSBjb21tZW50cyBpbnNpZGUgW0x3dC5iaW5kXSA6KVxuXG5cbiAgIDAuIE1haW4gbWVjaGFuaXNtIGFuZCB0d28gYXNwZWN0c1xuXG4gICBUaGUgTHd0IGludGVyZmFjZSAoW2x3dC5tbGldKSBwcm92aWRlcyBvbmUgbWFpbiBtZWNoYW5pc20sIHByb21pc2VzLCBhbmQgdHdvXG4gICBcImFzcGVjdHMsXCIgd2hpY2ggYXJlICpub3QqIG5lY2Vzc2FyeSB0byB1bmRlcnN0YW5kIHRoZSBtYWluIG1lY2hhbmlzbVxuICAgcHJvbWlzZXMsIGJ1dCB0aGV5IGFyZSBzdGlsbCB0aGVyZTpcblxuICAgLSBwcm9taXNlIGNhbmNlbGxhdGlvblxuICAgLSBzZXF1ZW5jZS1hc3NvY2lhdGVkIHN0b3JhZ2VcblxuICAgSWYgeW91IGFyZSBub3QgaW50ZXJlc3RlZCBpbiBjYW5jZWxsYXRpb24gb3Igc3RvcmFnZSwgeW91IGNhbiBpZ25vcmUgdGhlc2VcbiAgIHR3byBjb21wbGljYXRpb25zLCBhbmQgc3RpbGwgZ2V0IGEgcHJldHR5IGdvb2QgdW5kZXJzdGFuZGluZyBvZiB0aGUgY29kZS4gVG9cbiAgIGhlbHAsIGFsbCBpZGVudGlmaWVycyByZWxhdGVkIHRvIGNhbmNlbGxhdGlvbiBjb250YWluIHRoZSBzdHJpbmcgXCJjYW5jZWwsXCJcbiAgIGFuZCBhbGwgaWRlbnRpZmllcnMgcmVsYXRlZCB0byBzdG9yYWdlIGNvbnRhaW4gXCJzdG9yYWdlLlwiXG5cblxuICAgMS4gUHJvbWlzZXNcblxuICAgQSBwcm9taXNlIGlzIGEgY2VsbCB0aGF0IGNhbiBiZSBpbiBvbmUgb2YgdHdvIHN0YXRlczogXCJyZXNvbHZlZFwiIG9yXG4gICBcInBlbmRpbmcuXCJcblxuICAgLSBSZXNvbHZlZCBwcm9taXNlc1xuXG4gICAgIEEgcmVzb2x2ZWQgcHJvbWlzZSBpcyBlaXRoZXIgXCJmdWxmaWxsZWRcIiB3aXRoIGEgdmFsdWUsIG9yIFwicmVqZWN0ZWRcIiB3aXRoXG4gICAgIGFuIGV4Y2VwdGlvbi4gVGhlIHN0YXRlIG9mIGEgcmVzb2x2ZWQgcHJvbWlzZSB3aWxsIG5ldmVyIGNoYW5nZSBhZ2FpbjogYVxuICAgICByZXNvbHZlZCBwcm9taXNlIGlzIGltbXV0YWJsZS4gQSByZXNvbHZlZCBwcm9taXNlIGlzIGJhc2ljYWxseSBlcXVpdmFsZW50XG4gICAgIHRvIGFuIFsoJ2EsIGV4bikgU3RkbGliLnJlc3VsdF0uIFJlc29sdmVkIHByb21pc2VzIGFyZSBwcm9kdWNlZCBpbiB0d29cbiAgICAgd2F5czpcblxuICAgICAtIFtMd3QucmV0dXJuXSwgW0x3dC5mYWlsXSwgYW5kIHJlbGF0ZWQgZnVuY3Rpb25zLCBwcm9kdWNlIFwidHJpdmlhbFwiXG4gICAgICAgcHJvbWlzZXMgdGhhdCBhcmUgcmVzb2x2ZWQgZnJvbSB0aGUgc3RhcnQuXG4gICAgIC0gVGhlIG90aGVyIHdheSBpcyB0byByZXNvbHZlIGEgcHJvbWlzZSB0aGF0IHN0YXJ0ZWQgb3V0IHBlbmRpbmcuXG5cbiAgICAgTm90ZSB0aGF0IHJlamVjdGVkIHByb21pc2VzIGhhdmUgbm90aGluZyB0byBkbyB3aXRoIHVuaGFuZGxlZCBleGNlcHRpb25zLlxuXG4gICAtIFBlbmRpbmcgcHJvbWlzZXNcblxuICAgICAuLi5hcmUgdGhvc2UgdGhhdCBtYXkgYmVjb21lIHJlc29sdmVkIGluIHRoZSBmdXR1cmUuIEVhY2ggcGVuZGluZyBwcm9taXNlXG4gICAgIGNhcnJpZXMgYSBsaXN0IG9mIGNhbGxiYWNrcy4gVGhlc2UgY2FsbGJhY2tzIGFyZSBhZGRlZCBieSBmdW5jdGlvbnMgbGlrZVxuICAgICBbTHd0LmJpbmRdLCBhbmQgY2FsbGVkIGJ5IEx3dCBpZi93aGVuIHRoZSBwcm9taXNlIGlzIHJlc29sdmVkLiBUaGVzZVxuICAgICBjYWxsYmFja3MgdHlwaWNhbGx5IGVuZCB1cCByZXNvbHZpbmcgYWRkaXRpb25hbCBwcm9taXNlczsgc2VlIHNlY3Rpb25cbiAgICAgXCJSZXNvbHV0aW9uIGxvb3BcIiBiZWxvdy5cblxuICAgICBQZW5kaW5nIHByb21pc2VzIGFyZSBwcm9kdWNlZCBpbiB0aHJlZSB3YXlzLCBhY2NvcmRpbmcgdG8gaG93IHRoZXkgY2FuIGJlXG4gICAgIHJlc29sdmVkOlxuXG4gICAgIC0gSW5pdGlhbCBwcm9taXNlc1xuXG4gICAgICAgLi4uYXJlIGNyZWF0ZWQgYnkgW0x3dC53YWl0XSBhbmQgW0x3dC50YXNrXS4gVGhlIHVzZXIgb2YgTHd0IHJlc29sdmVzXG4gICAgICAgdGhlc2UgcHJvbWlzZXMgbWFudWFsbHksIHRocm91Z2ggdGhlIHJlc29sdmVycyByZXR1cm5lZCBieSB0aG9zZVxuICAgICAgIGZ1bmN0aW9ucy5cblxuICAgICAtIFNlcXVlbnRpYWwgY29tcG9zaXRpb25cblxuICAgICAgIEZvciBleGFtcGxlLCBbTHd0LmJpbmRdLiBUaGVzZSBwcm9taXNlcyBvbmx5IGFyZSBvbmx5IHJlc29sdmVkIHdoZW4gdGhlXG4gICAgICAgcHJlY2VkaW5nIHNlcXVlbmNlIG9mIHByb21pc2VzIHJlc29sdmVzLiBUaGUgdXNlciBjYW5ub3QgcmVzb2x2ZSB0aGVzZVxuICAgICAgIHByb21pc2VzIGRpcmVjdGx5IChidXQgc2VlIHRoZSBzZWN0aW9uIG9uIGNhbmNlbGxhdGlvbiBiZWxvdykuXG5cbiAgICAgLSBDb25jdXJyZW50IGNvbXBvc2l0aW9uXG5cbiAgICAgICBGb3IgZXhhbXBsZSwgW0x3dC5qb2luXSBvciBbTHd0LmNob29zZV0uIFRoZXNlIHByb21pc2VzIGFyZSBvbmx5IHJlc29sdmVkXG4gICAgICAgd2hlbiBhbGwgb3Igb25lIG9mIGEgc2V0IG9mIFwicHJlY2VkaW5nXCIgcHJvbWlzZXMgcmVzb2x2ZS4gVGhlIHVzZXIgY2Fubm90XG4gICAgICAgcmVzb2x2ZSB0aGVzZSBwcm9taXNlcyBkaXJlY3RseSAoYnV0IHNlZSB0aGUgc2VjdGlvbiBvbiBjYW5jZWxsYXRpb25cbiAgICAgICBiZWxvdykuXG5cblxuICAgMi4gUmVzb2x2ZXJzXG5cbiAgIFJlc29sdmVycyBhcmUgZ2l2ZW4gdG8gdGhlIHVzZXIgYnkgW0x3dC53YWl0XSBhbmQgW0x3dC50YXNrXSwgYW5kIGNhbiBiZSB1c2VkXG4gICBieSB0aGUgdXNlciB0byByZXNvbHZlIHRoZSBjb3JyZXNwb25kaW5nIHByb21pc2VzLiBOb3RlIHRoYXQgdGhpcyBtZWFucyB0aGVcbiAgIHVzZXIgb25seSBldmVyIGdldHMgcmVzb2x2ZXJzIGZvciBpbml0aWFsIHByb21pc2VzLlxuXG4gICBJbnRlcm5hbGx5LCByZXNvbHZlcnMgYXJlIHRoZSBleGFjdCBzYW1lIG9iamVjdHMgYXMgdGhlIHByb21pc2VzIHRoZXlcbiAgIHJlc29sdmUsIGV2ZW4gdGhvdWdoIHRoZSByZXNvbHZlciBpcyBleHBvc2VkIGFzIGEgcmVmZXJlbmNlIG9mIGEgZGlmZmVyZW50XG4gICB0eXBlIGJ5IFtsd3QubWxpXS4gRm9yIGRldGFpbHMgb24gd2h5LCBzZWUgc2VjdGlvbiBcIlR5cGUgc3lzdGVtIGFidXNlXCIgYmVsb3cuXG5cblxuICAgMy4gQ2FsbGJhY2tzXG5cbiAgIC4uLmFyZSBhdHRhY2hlZCBieSBMd3QgdG8gcGVuZGluZyBwcm9taXNlcywgYW5kIGFyZSBydW4gYnkgTHd0IGlmL3doZW4gdGhvc2VcbiAgIHByb21pc2VzIGFyZSByZXNvbHZlZC4gVGhlc2UgY2FsbGJhY2tzIGFyZSBub3QgZGlyZWN0bHkgZXhwb3NlZCB0aHJvdWdoXG4gICBbbHd0Lm1saV0gLS0gdGhleSBhcmUgYSBsb3ctbGV2ZWwgbWVjaGFuaXNtLiBGb3IgZXhhbXBsZSwgdG8gaW1wbGVtZW50XG4gICBbTHd0LmJpbmQgcCBmXSwgTHd0IGF0dGFjaGVzIGEgY2FsbGJhY2sgdG8gW3BdIHRoYXQgZG9lcyBzb21lIGludGVybmFsIEx3dFxuICAgYm9vay1rZWVwaW5nLCBhbmQgdGhlbiBjYWxscyBbZl0gaWYgW3BdIGlzIGZ1bGZpbGxlZCwgYW5kIGRvZXMgc29tZXRoaW5nIGVsc2VcbiAgIGlmIFtwXSBpcyByZWplY3RlZC5cblxuICAgQ2FsbGJhY2tzIGNvbWUgaW4gdHdvIGZsYXZvcnM6IHJlZ3VsYXIgY2FsbGJhY2tzIGFuZCBjYW5jZWwgY2FsbGJhY2tzLiBUaGVcbiAgIG9ubHkgbWF0ZXJpYWwgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGVtIGFyZSB0aGF0OlxuXG4gICAtIHJlZ3VsYXIgY2FsbGJhY2tzIGFyZSBhbHdheXMgY2FsbGVkIHdoZW4gYSBwcm9taXNlIGlzIHJlc29sdmVkLCBidXQgY2FuY2VsXG4gICAgIGNhbGxiYWNrcyBhcmUgY2FsbGVkLCBpbiBhZGRpdGlvbiwgb25seSBpZiB0aGUgcHJvbWlzZSBpcyBjYW5jZWxlZCwgYW5kXG4gICAtIGFsbCBjYW5jZWwgY2FsbGJhY2tzIG9mIGEgcHJvbWlzZSBhcmUgY2FsbGVkIGJlZm9yZSBhbnkgcmVndWxhciBjYWxsYmFja1xuICAgICBpcyBjYWxsZWQuXG5cbiAgIENhbmNlbGxhdGlvbiBpcyBhIHNwZWNpYWwgY2FzZSBvZiByZXNvbHV0aW9uLCBpbiBwYXJ0aWN1bGFyLCBhIHNwZWNpYWwgY2FzZVxuICAgb2YgcmVqZWN0aW9uLCBidXQgc2VlIHRoZSBzZWN0aW9uIG9uIGNhbmNlbGxhdGlvbiBsYXRlciBiZWxvdy5cblxuXG4gICA0LiBSZXNvbHV0aW9uIGxvb3BcblxuICAgUmVzb2x2aW5nIGEgcGVuZGluZyBwcm9taXNlIHRyaWdnZXJzIGl0cyBjYWxsYmFja3MsIGFuZCB0aG9zZSBtaWdodCByZXNvbHZlXG4gICBtb3JlIHBlbmRpbmcgcHJvbWlzZXMsIHRyaWdnZXJpbmcgbW9yZSBjYWxsYmFja3MsIGV0Yy4gVGhpcyBiZWhhdmlvciBpcyB0aGVcbiAgICpyZXNvbHV0aW9uIGxvb3AqLiBMd3QgaGFzIHNvbWUgbWFjaGluZXJ5IHRvIGF2b2lkIHN0YWNrIG92ZXJmbG93IGFuZCBvdGhlclxuICAgdW5mb3J0dW5hdGUgc2l0dWF0aW9ucyBkdXJpbmcgdGhpcyBsb29wLlxuXG4gICBUaGlzIGNoYWluaW5nIG9mIHByb21pc2UgcmVzb2x1dGlvbnMgdGhyb3VnaCBjYWxsYmFja3MgY2FuIGJlIHNlZW4gYXMgYSBraW5kXG4gICBvZiBwcm9taXNlIGRlcGVuZGVuY3kgZ3JhcGgsIGluIHdoaWNoIHRoZSBub2RlcyBhcmUgcGVuZGluZyBwcm9taXNlcywgYW5kIHRoZVxuICAgZWRnZXMgYXJlIGNhbGxiYWNrcy4gRHVyaW5nIHRoZSByZXNvbHV0aW9uIGxvb3AsIEx3dCBzdGFydHMgYXQgc29tZSBpbml0aWFsXG4gICBwcm9taXNlIHRoYXQgaXMgZ2V0dGluZyByZXNvbHZlZCBieSB0aGUgdXNlciwgYW5kIHJlY3Vyc2l2ZWx5IHJlc29sdmVzIGFsbFxuICAgZGVwZW5kZW50IHByb21pc2VzLiBUaGUgZ3JhcGggaXMgbW9kaWZpZWQ6IHJlc29sdmVkIHByb21pc2VzIGFyZSBubyBsb25nZXJcbiAgIHBlbmRpbmcsIHNvIHRoZXkgYXJlIG5vIGxvbmdlciBwYXJ0IG9mIHRoZSBncmFwaC5cblxuICAgU29tZSBvZiB0aGVzZSBkZXBlbmRlbmNpZXMgYXJlIGV4cGxpY2l0IHRvIEx3dCwgZS5nLiB0aGUgY2FsbGJhY2tzIHJlZ2lzdGVyZWRcbiAgIGJ5IFtMd3QuYmluZF0uIE90aGVycyBhcmUgbm90IHZpc2libGUgdG8gTHd0LCBiZWNhdXNlIHRoZSB1c2VyIGNhbiBhbHdheXNcbiAgIHJlZ2lzdGVyIGEgY2FsbGJhY2sgdXNpbmcgYSBmdW5jdGlvbiBsaWtlIFtMd3Qub25fc3VjY2Vzc10sIGFuZCB1c2UgdGhhdFxuICAgY2FsbGJhY2sgdG8gcmVzb2x2ZSBhbm90aGVyIGluaXRpYWwgcHJvbWlzZS4gQWxsIHRoZSBleHBsaWNpdCBkZXBlbmRlbmNpZXNcbiAgIGFyZSBjcmVhdGVkIGJ5IEx3dCdzIG93biBzZXF1ZW50aWFsIGFuZCBjb25jdXJyZW50IGNvbXBvc2l0aW9uIGZ1bmN0aW9uc1xuICAgKHNvLCBbTHd0LmJpbmRdLCBbTHd0LmpvaW5dLCBldGMpLiBXaGV0aGVyIGRlcGVuZGVuY2llcyBhcmUgZXhwbGljaXQgb3Igbm90XG4gICBpcyByZWxldmFudCBvbmx5IHRvIGNhbmNlbGxhdGlvbi5cblxuXG4gICA1LiBDYW5jZWxsYXRpb25cblxuICAgQXMgZGVzY3JpYmVkIGFib3ZlLCBvcmRpbmFyeSBwcm9taXNlIHJlc29sdXRpb24gcHJvY2VlZHMgZnJvbSBhbiBpbml0aWFsXG4gICBwcm9taXNlLCBmb3J3YXJkIGFsb25nIGNhbGxiYWNrcyB0aHJvdWdoIHRoZSBkZXBlbmRlbmN5IGdyYXBoLiBTaW5jZSBpdFxuICAgc3RhcnRzIGZyb20gYW4gaW5pdGlhbCBwcm9taXNlLCBpdCBjYW4gb25seSBiZSB0cmlnZ2VyZWQgdXNpbmcgYSByZXNvbHZlci5cblxuICAgQ2FuY2VsbGF0aW9uIGlzIGEgc29ydCBvZiBkdWFsIHRvIG9yZGluYXJ5IHJlc29sdXRpb24uIEluc3RlYWQgb2Ygc3RhcnRpbmcgYXRcbiAgIGFuIGluaXRpYWwgcHJvbWlzZS9yZXNvbHZlciwgY2FuY2VsbGF0aW9uIHN0YXJ0cyBhdCAqYW55KiBwcm9taXNlLiBJdCB0aGVuXG4gICBnb2VzICpiYWNrd2FyZHMqIHRocm91Z2ggdGhlIGV4cGxpY2l0IGRlcGVuZGVuY3kgZ3JhcGgsIGxvb2tpbmcgZm9yXG4gICBjYW5jZWxhYmxlIGluaXRpYWwgcHJvbWlzZXMgdG8gY2FuY2VsIC0tIHRob3NlIHRoYXQgd2VyZSBjcmVhdGVkIGJ5XG4gICBbTHd0LnRhc2tdLiBBZnRlciBmaW5kaW5nIHRoZW0sIGNhbmNlbGxhdGlvbiByZXNvbHZlcyB0aGVtIG5vcm1hbGx5IHdpdGhcbiAgIFtSZWplY3RlZCBMd3QuQ2FuY2VsZWRdLCBjYXVzaW5nIGFuIG9yZGluYXJ5IHByb21pc2UgcmVzb2x1dGlvbiBwcm9jZXNzLlxuXG4gICBUbyBzdW1tYXJpemUsIGNhbmNlbGxhdGlvbiBpcyBhIHdheSB0byB0cmlnZ2VyIGFuICpvcmRpbmFyeSogcmVzb2x1dGlvbiBvZlxuICAgcHJvbWlzZXMgY3JlYXRlZCB3aXRoIFtMd3QudGFza10sIGJ5IGZpcnN0IHNlYXJjaGluZyBmb3IgdGhlbSBpbiB0aGUgcHJvbWlzZVxuICAgZGVwZW5kZW5jeSBncmFwaCAod2hpY2ggaXMgYXNzZW1ibGVkIGJ5IFtMd3QuYmluZF0sIFtMd3Quam9pbl0sIGV0YykuXG5cbiAgIFRoaXMgYmFja3dhcmRzIHNlYXJjaCBpcyB0cmlnZ2VyZWQgb25seSBieSBbTHd0LmNhbmNlbF0uIEl0IGlzIGFsc28gcG9zc2libGVcbiAgIGZvciB0aGUgdXNlciB0byBjYW5jZWwgYSBwcm9taXNlIGRpcmVjdGx5IGJ5IHJlamVjdGluZyBpdCB3aXRoXG4gICBbTHd0LkNhbmNlbGVkXSwgYnV0IGluIGFsbCBjYXNlcyB3aGVyZSB0aGUgdXNlciBjYW4gZG8gc28sIHRoZSBzZWFyY2ggd291bGRcbiAgIGJlIHJlZHVuZGFudCBhbnl3YXkgLS0gdGhlIHVzZXIgaGFzIG9ubHkgdHdvIHdheXMgb2YgZGlyZWN0bHkgcmVqZWN0aW5nIGFcbiAgIHByb21pc2Ugd2l0aCBbTHd0LkNhbmNlbGVkXSAob3IgYW55IGV4Y2VwdGlvbiwgZm9yIHRoYXQgbWF0dGVyKTpcblxuICAgLSBUaGUgdXNlciBjYW4gY3JlYXRlIGFuIGluaXRpYWwgcHJvbWlzZSwgdGhlbiByZWplY3QgaXQgdGhyb3VnaCBpdHNcbiAgICAgcmVzb2x2ZXIuIFRoZSBzZWFyY2ggaXMgcmVkdW5kYW50IGJlY2F1c2UgaXQgd291bGQgZmluZCBvbmx5IHRoZSBzYW1lXG4gICAgIGluaXRpYWwgcHJvbWlzZSB0byBjYW5jZWwuXG4gICAtIFRoZSB1c2VyIGNhbiBjcmVhdGUgYSB0cml2aWFsIHByb21pc2UgYnkgY2FsbGluZyBbTHd0LmZhaWwgTHd0LkNhbmNlbGVkXS5cbiAgICAgVGhlIHNlYXJjaCBpcyBhZ2FpbiByZWR1bmRhbnQ7IGluIHRoaXMgY2FzZSBpdCB3b3VsZCBmaW5kIG5vdGhpbmcgdG9cbiAgICAgY2FuY2VsLlxuXG4gICBOb3RlIHRoYXQgdGhlcmUgaXMgYSBxdWlyazogb25seSBwcm9taXNlcyBjcmVhdGVkIGJ5IFtMd3QudGFza10gYXJlXG4gICBzdXNjZXB0aWJsZSB0byBiZWluZyBjYW5jZWxlZCBieSBbTHd0LmNhbmNlbF0sIGJ1dCB0aGUgdXNlciBjYW4gbWFudWFsbHlcbiAgIGNhbmNlbCBpbml0aWFsIHByb21pc2VzIGNyZWF0ZWQgYnkgYm90aCBbTHd0LnRhc2tdIGFuZCBbTHd0LndhaXRdLlxuXG4gICBEdWUgdG8gW0x3dC5jYW5jZWxdLCBwcm9taXNlIGNhbmNlbGxhdGlvbiwgYW5kIHRoZXJlZm9yZSByZXNvbHV0aW9uLCBjYW4gYmVcbiAgIGluaXRpYXRlZCBieSB0aGUgdXNlciB3aXRob3V0IGFjY2VzcyB0byBhIHJlc29sdmVyLiBUaGlzIGlzIGltcG9ydGFudCBmb3JcbiAgIHJlYXNvbmluZyBhYm91dCBzdGF0ZSBjaGFuZ2VzIGluIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBMd3QsIGFuZCBpcyByZWZlcmVuY2VkXG4gICBpbiBzb21lIGltcGxlbWVudGF0aW9uIGRldGFpbCBjb21tZW50cy5cblxuXG4gICA2LiBObyBJL09cblxuICAgVGhlIEx3dCBjb3JlIGRlbGliZXJhdGVseSBkb2Vzbid0IGRvIEkvTy4gVGhlIHJlc29sdXRpb24gbG9vcCBzdG9wcyBydW5uaW5nXG4gICBvbmNlIG5vIHByb21pc2VzIGNhbiBiZSByZXNvbHZlZCBpbW1lZGlhdGVseS4gSXQgaGFzIHRvIGJlIHJlc3RhcnRlZCBsYXRlclxuICAgYnkgc29tZSBzdXJyb3VuZGluZyBJL08gbG9vcC4gVGhpcyBJL08gbG9vcCB0eXBpY2FsbHkga2VlcHMgdHJhY2sgb2YgcGVuZGluZ1xuICAgcHJvbWlzZXMgdGhhdCByZXByZXNlbnQgYmxvY2tlZCBvciBpbi1wcm9ncmVzcyBJL087IG90aGVyIHBlbmRpbmcgcHJvbWlzZXNcbiAgIHRoYXQgaW5kaXJlY3RseSBkZXBlbmQgb24gSS9PIGFyZSBub3QgZXhwbGljaXRseSB0cmFja2VkLiBUaGV5IGFyZSByZXRhaW5lZFxuICAgaW4gbWVtb3J5IGJ5IHJlZmVyZW5jZXMgY2FwdHVyZWQgaW5zaWRlIGNhbGxiYWNrcy5cblxuICAgT24gVW5peCBhbmQgV2luZG93cywgYSBzZXBhcmF0ZSB0b3AtbGV2ZWwgbG9vcCwgdHlwaWNhbGx5IFtMd3RfbWFpbi5ydW5dLCBpc1xuICAgbmVjZXNzYXJ5IHRvIHJlcGVhdGVkbHkgY2FsbCBbc2VsZWN0XSwgW2Vwb2xsXSwgb3IgW2tldmVudF0sIGFuZCByZXNvbHZlXG4gICBibG9ja2VkIEkvTyBwcm9taXNlcy5cblxuICAgSW4gSmF2YVNjcmlwdCwgcmVmZXJlbmNlcyB0byBwcm9taXNlcyBhcmUgcmV0YWluZWQgYnkgSmF2YVNjcmlwdCBjb2RlLCB3aGljaFxuICAgaXMsIGluIHR1cm4sIHRyaWdnZXJlZCBieSB0aGUgSlMgZW5naW5lLiBJbiBvdGhlciB3b3JkcywgdGhlIHRvcC1sZXZlbCBsb29wXG4gICBpcyBidXJpZWQgaW5zaWRlIHRoZSBKUyBlbmdpbmUuXG5cbiAgIFRoaXMgc2VwYXJhdGlvbiBvZiB0aGUgTHd0IGNvcmUgZnJvbSB0aGUgdG9wLWxldmVsIEkvTyBsb29wIGtlZXBzIHRoZSBjb3JlXG4gICBwb3J0YWJsZS5cblxuXG4gICA3LiBQcm9taXNlIFwicHJveHlpbmdcIlxuXG4gICBJbiBbTHd0LmJpbmQgOiAnYSB0IC0+ICgnYSAtPiAnYiB0KSAtPiAnYiB0XSwgdGhlIG91dGVyIFsnYiB0XSBpcyBjcmVhdGVkIGJ5XG4gICBbYmluZF0gZmlyc3QsIGFuZCByZXR1cm5lZCB0byB0aGUgdXNlci4gVGhlIGlubmVyIFsnYiB0XSBpcyBjcmVhdGVkIGJ5IHRoZVxuICAgdXNlciBsYXRlciwgYW5kIHRoZW4gcmV0dXJuZWQgdG8gW2JpbmRdLiBBdCB0aGF0IHBvaW50LCBbYmluZF0gbmVlZHMgdG8gbWFrZVxuICAgdGhlIGlubmVyIGFuZCBvdXRlciBbJ2IgdF1zIGJlaGF2ZSBpZGVudGljYWxseS5cblxuICAgVGhpcyBpcyBhY2NvbXBsaXNoZWQgYnkgbWFraW5nIG9uZSBvZiB0aGUgcHJvbWlzZXMgcG9pbnQgdG8gdGhlIG90aGVyLiBUaGVcbiAgIGZpcnN0IG9mIHRoZSBwcm9taXNlcyB0aHVzIGJlY29tZXMgYSBcInByb3h5LFwiIGFuZCB0aGUgb3RoZXIgaXMgaXRzXG4gICBcInVuZGVybHlpbmdcIiBwcm9taXNlLlxuXG4gICBBZnRlciB0aGF0LCBhbGwgb3BlcmF0aW9ucyB0aGF0IHdvdWxkIGJlIHBlcmZvcm1lZCBieSBMd3Qgb24gdGhlIHByb3h5IGFyZVxuICAgaW5zdGVhZCBwZXJmb3JtZWQgb24gdGhlIHVuZGVybHlpbmcgcHJvbWlzZS4gVGhpcyBpcyBlbnN1cmVkIGJ5IHRoZSBudW1lcm91c1xuICAgY2FsbHMgdG8gdGhlIGludGVybmFsIGZ1bmN0aW9uIFt1bmRlcmx5aW5nXSBpbiB0aGlzIGZpbGUuXG5cbiAgIEJlY2F1c2Ugb2YgdGhlIHBlcnZhc2l2ZSB1c2Ugb2YgW3VuZGVybHlpbmddLCBwcm94aWVzIGNhbiBiZSBtb3JlIG9yIGxlc3NcbiAgIGlnbm9yZWQgb24gYSBmaXJzdCByZWFkaW5nIHRoZSBjb2RlLiBIb3dldmVyLCBiZWNvbWluZyBhIHByb3h5IGlzIGEga2luZCBvZlxuICAgc3RhdGUgY2hhbmdlLCBhbmQgYW55IHByb21pc2UgdGhhdCBpcyByZXR1cm5lZCBieSBhIGNhbGxiYWNrIHRvIFtiaW5kXSwgb3IgdG9cbiAgIGEgc2ltaWxhciBMd3QgZnVuY3Rpb24sIG1pZ2h0IGJlY29tZSBhIHByb3h5LiBUaGF0IG1lYW5zOiBqdXN0IGFib3V0IGFueVxuICAgcHJvbWlzZSB0aGF0IGlzIGhhbmRlZCB0byB0aGUgdXNlciwgbWlnaHQgYmVjb21lIGEgcHJveHkgcHJvbWlzZSBieSB0aGUgbmV4dFxuICAgdGltZSBMd3Qgc2VlcyBpdC4gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIHJlYXNvbmluZyBhYm91dCBwb3NzaWJsZSBzdGF0ZVxuICAgY2hhbmdlcyBpbiBpbXBsZW1lbnRhdGlvbiBvZiBMd3QsIGFuZCBpcyByZWZlcmVuY2VkIGluIHNvbWUgaW1wbGVtZW50YXRpb25cbiAgIGRldGFpbCBjb21tZW50cy5cblxuXG4gICA4LiBTZXF1ZW5jZS1hc3NvY2lhdGVkIHN0b3JhZ2VcblxuICAgTHd0IGhhcyBhIGdsb2JhbCBrZXktdmFsdWUgbWFwLiBUaGUgbWFwIGNhbiBiZSBwcmVzZXJ2ZWQgYWNyb3NzIHNlcXVlbnRpYWxcbiAgIGNvbXBvc2l0aW9uIGZ1bmN0aW9ucywgc28gdGhhdCBpdCBoYXMgdGhlIHNhbWUgc3RhdGUgaW4gdGhlIHVzZXIncyBjYWxsYmFja1xuICAgW2ZdIGFzIGl0IGRpZCBhdCB0aGUgdGltZSB0aGUgdXNlciBjYWxsZWQgW0x3dC5iaW5kIHAgZl0uXG5cbiAgIFRoZSBkZXRhaWxzIGFyZSBwcmV0dHkgc3RyYWlnaHRmb3J3YXJkLCBhbmQgZGlzY3Vzc2VkIGluIG1vZHVsZVxuICAgW1NlcXVlbmNlX2Fzc29jaWF0ZWRfc3RvcmFnZV0uIFRoZSBtYWluIHRoaW5nIHRvIGJlIGF3YXJlIG9mIGlzIHRoZSBtYW55XG4gICByZWZlcmVuY2VzIHRvIFtjdXJyZW50X3N0b3JhZ2VdIHRocm91Z2hvdXQgTHd0LCB3aGljaCBhcmUgbmVlZGVkIHRvIHByb3Blcmx5XG4gICBzYXZlIGFuZCByZXN0b3JlIHRoZSBtYXBwaW5nLlxuXG5cbiAgIDkuIFR5cGUgc3lzdGVtIGFidXNlXG5cbiAgIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIHRoZSB0eXBlIHN5c3RlbSBzb21ld2hhdCBleHRlbnNpdmVseS4gR2VudGxlXG4gICBpbnRyb2R1Y3Rpb25zIGNhbiBiZSBmb3VuZCBoZXJlOlxuXG4gICAgIGh0dHBzOi8vZGlzY3Vzcy5vY2FtbC5vcmcvdC8xNjEvN1xuICAgICBodHRwczovL2Rpc2N1c3Mub2NhbWwub3JnL3QvMTYxLzE2XG5cbiAgIEEgc2hvcnQgc3VtbWFyeSBmb2xsb3dzLlxuXG4gICBUaGUgcHJvbWlzZSBzdGF0ZSBpcywgaW50ZXJuYWxseSwgYSBHQURUIHdoaWNoIGVuY29kZXMgdGhlIHN0YXRlIGluIGl0cyB0eXBlXG4gICBwYXJhbWV0ZXJzLiBUaHVzLCBpZiB5b3UgZG8gW2xldCBwID0gdW5kZXJseWluZyBwXSwgdGhlIHNoYWRvd2luZyByZWZlcmVuY2VcbiAgIFtwXSBpcyBzdGF0aWNhbGx5IGtub3duICpub3QqIHRvIGJlIGEgcHJveHksIGFuZCB0aGUgY29tcGlsZXIga25vd3MgdGhhdCB0aGVcbiAgIGNvcnJlc3BvbmRpbmcgbWF0Y2ggY2FzZSBbUHJveHkgX10gaXMgaW1wb3NzaWJsZS5cblxuICAgVGhlIGV4dGVybmFsIHByb21pc2UgdHlwZSwgWydhIHRdLCBhbmQgdGhlIGV4dGVybmFsIHJlc29sdmVyIHR5cGUsIFsnYSB1XSxcbiAgIGFyZSBub3QgR0FEVHMuIEZ1cnRoZXJtb3JlLCB0aGV5IGFyZSwgcmVzcGVjdGl2ZWx5LCBjb3ZhcmlhbnQgYW5kXG4gICBjb250cmF2YXJpYW50IGluIFsnYV0sIHdoaWxlIHRoZSBpbnRlcm5hbCBwcm9taXNlIHR5cGUgaXMgaW52YXJpYW50IGluIFsnYV0uXG4gICBGb3IgdGhlc2UgcmVhc29ucywgdGhlcmUgYXJlIG5hc3R5IGNhc3RzIGJldHdlZW4gWydhIHRdLCBbJ2EgdV0sIGFuZCB0aGVcbiAgIGludGVybmFsIHByb21pc2UgdHlwZS4gVGhlIGltcGxlbWVudGF0aW9uIGlzLCBvZiBjb3Vyc2UsIHdyaXR0ZW4gaW4gdGVybXMgb2ZcbiAgIHRoZSBpbnRlcm5hbCB0eXBlLlxuXG4gICBDYXN0aW5nIGZyb20gYW4gWydhIHRdIHRvIGFuIGludGVybmFsIHByb21pc2UgcHJvZHVjZXMgYSByZWZlcmVuY2UgZm9yXG4gICB3aGljaCB0aGUgc3RhdGUgaXMgXCJ1bmtub3duXCI6IHRoaXMgaXMgc2ltdWxhdGVkIHdpdGggYSBoZWxwZXIgR0FEVCwgd2hpY2hcbiAgIGVuY29kZXMgZXhpc3RlbnRpYWwgdHlwZXMuIFRoZXJlIGFyZSBzZXZlcmFsIHNpbWlsYXIgY2FzdHMsIHdoaWNoIGFyZSB1c2VkXG4gICB0byBkb2N1bWVudCBwb3NzaWJsZSBzdGF0ZSBjaGFuZ2VzIGJldHdlZW4gdGhlIHRpbWUgYSBwcm9taXNlIGlzIGNyZWF0ZWQsXG4gICBhbmQgdGhlIGxhdGVyIHRpbWUgaXQgaXMgdXNlZCBpbiBhIGNhbGxiYWNrLiBZb3UgY2FuIHNlZSB0aGVzZSBjYXN0cyBpblxuICAgYWN0aW9uIGluIFtMd3QuYmluZF0uIFRoZSBjYXN0IHN5bnRheCBpcyBwcmV0dHkgbGlnaHQsIGFuZCwgYmVzaWRlcyBiZWluZ1xuICAgY29tbWVudGVkIGluIFtiaW5kXSwgYWxsIHN1Y2ggY2FzdHMgYXJlIGRvY3VtZW50ZWQgaW4gbW9kdWxlcyBbUHVibGljX3R5cGVzXVxuICAgYW5kIFtCYXNpY19oZWxwZXJzXS5cblxuXG4gICBJZiB5b3UndmUgbWFkZSBpdCB0aGlzIGZhciwgeW91IGFyZSBhbiBMd3QgZXhwZXJ0ISBSZWpvaWNlISAqKVxuXG5cblxuKCogW0x3dF9zZXF1ZW5jZV0gaXMgZGVwcmVjYXRlZCDigJMgd2UgZG9uJ3Qgd2FudCB1c2VycyBvdXRzaWRlIEx3dCB1c2luZyBpdC5cbiAgIEhvd2V2ZXIsIGl0IGlzIHN0aWxsIHVzZWQgaW50ZXJuYWxseSBieSBMd3QuIFNvLCBicmllZmx5IGRpc2FibGUgd2FybmluZyAzXG4gICAoXCJkZXByZWNhdGVkXCIpLCBhbmQgY3JlYXRlIGEgbG9jYWwsIG5vbi1kZXByZWNhdGVkIGFsaWFzIGZvclxuICAgW0x3dF9zZXF1ZW5jZV0gdGhhdCBjYW4gYmUgcmVmZXJyZWQgdG8gYnkgdGhlIHJlc3Qgb2YgdGhlIGNvZGUgaW4gdGhpc1xuICAgbW9kdWxlIHdpdGhvdXQgdHJpZ2dlcmluZyBhbnkgbW9yZSB3YXJuaW5ncy4gKilcbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbm1vZHVsZSBMd3Rfc2VxdWVuY2UgPSBMd3Rfc2VxdWVuY2VcbltAQEBvY2FtbC53YXJuaW5nIFwiKzNcIl1cblxuKCogU29tZSBzZXF1ZW5jZS1hc3NvY2lhdGVkIHN0b3JhZ2UgdHlwZXNcblxuICAgU2VxdWVuY2UtYXNzb2NpYXRlZCBzdG9yYWdlIGlzIGRlZmluZWQgYW5kIGRvY3VtZW50ZWQgbGF0ZXIsIGluIG1vZHVsZVxuICAgW1NlcXVlbmNlX2Fzc29jaWF0ZWRfc3RvcmFnZV0uIEhvd2V2ZXIsIHRoZSBmb2xsb3dpbmcgdHlwZXMgYXJlIG1lbnRpb25lZCBpblxuICAgdGhlIGRlZmluaXRpb24gb2YgW3Byb21pc2VdLCBzbyB0aGV5IG11c3QgYmUgZGVmaW5lZCBoZXJlIGZpcnN0LiAqKVxubW9kdWxlIFN0b3JhZ2VfbWFwID1cbiAgTWFwLk1ha2VcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIHQgPSBpbnRcbiAgICAgIGxldCBjb21wYXJlID0gY29tcGFyZVxuICAgIGVuZClcbnR5cGUgc3RvcmFnZSA9ICh1bml0IC0+IHVuaXQpIFN0b3JhZ2VfbWFwLnRcblxuXG5cbm1vZHVsZSBNYWluX2ludGVybmFsX3R5cGVzID1cbnN0cnVjdFxuICAoKiBQaGFudG9tIHR5cGVzIGZvciB1c2Ugd2l0aCB0eXBlcyBbcHJvbWlzZV0gYW5kIFtzdGF0ZV0uIFRoZXNlIGFyZSBuZXZlclxuICAgICBjb25zdHJ1Y3RlZDsgdGhlIHB1cnBvc2Ugb2YgdGhlIGNvbnN0cnVjdG9ycyBpcyB0byBwcm92ZSB0byB0aGUgdHlwZVxuICAgICBjaGVja2VyIHRoYXQgdGhlc2UgdHlwZXMgYXJlIGRpc3RpbmN0IGZyb20gZWFjaCBvdGhlci4gV2FybmluZyAzNywgXCJ1bnVzZWRcbiAgICAgY29uc3RydWN0b3IsXCIgdGhlcmVmb3JlIGhhcyB0byBiZSB0ZW1wb3JhcmlseSBzdXBwcmVzc2VkLiAqKVxuXG4gIFtAQEBvY2FtbC53YXJuaW5nIFwiLTM3XCJdXG5cbiAgdHlwZSB1bmRlcmx5aW5nID0gcHJpdmF0ZSBVbmRlcmx5aW5nX2FuZF90aGlzX2NvbnN0cnVjdG9yX2lzX25vdF91c2VkXG4gIHR5cGUgcHJveHkgPSBwcml2YXRlIFByb3h5X2FuZF90aGlzX2NvbnN0cnVjdG9yX2lzX25vdF91c2VkXG5cbiAgdHlwZSByZXNvbHZlZCA9IHByaXZhdGUgUmVzb2x2ZWRfYW5kX3RoaXNfY29uc3RydWN0b3JfaXNfbm90X3VzZWRcbiAgdHlwZSBwZW5kaW5nID0gcHJpdmF0ZSBQZW5kaW5nX2FuZF90aGlzX2NvbnN0cnVjdG9yX2lzX25vdF91c2VkXG5cbiAgW0BAQG9jYW1sLndhcm5pbmcgXCIrMzdcIl1cblxuXG5cbiAgKCogUHJvbWlzZXMgcHJvcGVyLiAqKVxuXG4gIHR5cGUgKCdhLCAndSwgJ2MpIHByb21pc2UgPSB7XG4gICAgbXV0YWJsZSBzdGF0ZSA6ICgnYSwgJ3UsICdjKSBzdGF0ZTtcbiAgfVxuXG4gIGFuZCAoXywgXywgXykgc3RhdGUgPVxuICAgIHwgRnVsZmlsbGVkIDogJ2EgICAgICAgICAgICAgICAgICAtPiAoJ2EsIHVuZGVybHlpbmcsIHJlc29sdmVkKSBzdGF0ZVxuICAgIHwgUmVqZWN0ZWQgIDogZXhuICAgICAgICAgICAgICAgICAtPiAoIF8sIHVuZGVybHlpbmcsIHJlc29sdmVkKSBzdGF0ZVxuICAgIHwgUGVuZGluZyAgIDogJ2EgY2FsbGJhY2tzICAgICAgICAtPiAoJ2EsIHVuZGVybHlpbmcsIHBlbmRpbmcpICBzdGF0ZVxuICAgIHwgUHJveHkgICAgIDogKCdhLCBfLCAnYykgcHJvbWlzZSAtPiAoJ2EsIHByb3h5LCAgICAgICdjKSAgICAgICBzdGF0ZVxuXG4gICgqIE5vdGU6XG5cbiAgICAgQSBwcm9taXNlIHdob3NlIHN0YXRlIGlzIFtQcm94eSBfXSBpcyBhIFwicHJveHlcIiBwcm9taXNlLiBBIHByb21pc2Ugd2hvc2VcbiAgICAgc3RhdGUgaXMgKm5vdCogW1Byb3h5IF9dIGlzIGFuIFwidW5kZXJseWluZ1wiIHByb21pc2UuXG5cbiAgICAgVGhlIFwidW5kZXJseWluZyBwcm9taXNlIG9mIFtwXVwiIGlzOlxuXG4gICAgIC0gW3BdLCBpZiBbcF0gaXMgaXRzZWxmIHVuZGVybHlpbmcuXG4gICAgIC0gT3RoZXJ3aXNlLCBbcF0gaXMgYSBwcm94eSBhbmQgaGFzIHN0YXRlIFtQcm94eSBwJ10uIFRoZSB1bmRlcmx5aW5nXG4gICAgICAgcHJvbWlzZSBvZiBbcF0gaXMgdGhlIHVuZGVybHlpbmcgcHJvbWlzZSBvZiBbcCddLlxuXG4gICAgIEluIG90aGVyIHdvcmRzLCB0byBmaW5kIHRoZSB1bmRlcmx5aW5nIHByb21pc2Ugb2YgYSBwcm94eSwgTHd0IGZvbGxvd3MgdGhlXG4gICAgIFtQcm94eSBfXSBsaW5rcyB0byB0aGUgZW5kLiAqKVxuXG4gICgqIE5vdGU6XG5cbiAgICAgV2hlbiBhIHByb21pc2UgaXMgcmVzb2x2ZWQsIG9yIGJlY29tZXMgYSBwcm94eSwgaXRzIHN0YXRlIGZpZWxkIGlzXG4gICAgIG11dGF0ZWQuIFRoaXMgaW52YWxpZGF0ZXMgdGhlIHR5cGUgaW52YXJpYW50cyBvbiB0aGUgcHJvbWlzZS4gU2VlIGludGVybmFsXG4gICAgIGZ1bmN0aW9uIFtzZXRfcHJvbWlzZV9zdGF0ZV0gZm9yIGRldGFpbHMgYWJvdXQgdGhhdC5cblxuICAgICBXaGVuIGFuIEx3dCBmdW5jdGlvbiBoYXMgYSByZWZlcmVuY2UgdG8gYSBwcm9taXNlLCBhbmQgYWxzbyByZWdpc3RlcnMgYVxuICAgICBjYWxsYmFjayB0aGF0IGhhcyBhIHJlZmVyZW5jZSB0byB0aGUgc2FtZSBwcm9taXNlLCB0aGUgaW52YXJpYW50cyBvbiB0aGVcbiAgICAgcmVmZXJlbmNlIG1heSBiZWNvbWUgaW52YWxpZCBieSB0aGUgdGltZSB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkLiBBbGwgc3VjaFxuICAgICBjYWxsYmFja3MgaGF2ZSBjb21tZW50cyBleHBsYWluaW5nIHdoYXQgdGhlIHZhbGlkIGludmFyaWFudHMgYXJlIGF0IHRoYXRcbiAgICAgcG9pbnQsIGFuZC9vciBjYXN0cyB0byAoMSkgZ2V0IHRoZSBjb3JyZWN0IHR5cGluZyBhbmQgKDIpIGRvY3VtZW50IHRoZVxuICAgICBwb3RlbnRpYWwgc3RhdGUgY2hhbmdlIGZvciByZWFkZXJzIG9mIHRoZSBjb2RlLiAqKVxuXG5cblxuICAoKiBDYWxsYmFjayBpbmZvcm1hdGlvbiBmb3IgcGVuZGluZyBwcm9taXNlcy4gKilcblxuICBhbmQgJ2EgY2FsbGJhY2tzID0ge1xuICAgIG11dGFibGUgcmVndWxhcl9jYWxsYmFja3MgOiAnYSByZWd1bGFyX2NhbGxiYWNrX2xpc3Q7XG4gICAgbXV0YWJsZSBjYW5jZWxfY2FsbGJhY2tzICA6ICdhIGNhbmNlbF9jYWxsYmFja19saXN0O1xuICAgIG11dGFibGUgaG93X3RvX2NhbmNlbCAgICAgOiBob3dfdG9fY2FuY2VsO1xuICAgIG11dGFibGUgY2xlYW51cHNfZGVmZXJyZWQgOiBpbnQ7XG4gIH1cblxuICBhbmQgJ2EgcmVndWxhcl9jYWxsYmFjayA9ICdhIHJlc29sdmVkX3N0YXRlIC0+IHVuaXRcblxuICBhbmQgY2FuY2VsX2NhbGxiYWNrID0gdW5pdCAtPiB1bml0XG5cbiAgYW5kICdhIHJlc29sdmVkX3N0YXRlID0gKCdhLCB1bmRlcmx5aW5nLCByZXNvbHZlZCkgc3RhdGVcblxuICBhbmQgaG93X3RvX2NhbmNlbCA9XG4gICAgfCBOb3RfY2FuY2VsYWJsZSAgICAgICAgICAgICAgOiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvd190b19jYW5jZWxcbiAgICB8IENhbmNlbF90aGlzX3Byb21pc2UgICAgICAgICA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgaG93X3RvX2NhbmNlbFxuICAgIHwgUHJvcGFnYXRlX2NhbmNlbF90b19vbmUgICAgIDogKF8sIF8sIF8pIHByb21pc2UgICAgICAtPiBob3dfdG9fY2FuY2VsXG4gICAgfCBQcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgOiAoXywgXywgXykgcHJvbWlzZSBsaXN0IC0+IGhvd190b19jYW5jZWxcblxuICBhbmQgJ2EgcmVndWxhcl9jYWxsYmFja19saXN0ID1cbiAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9lbXB0eVxuICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2NvbmNhdCBvZlxuICAgICAgJ2EgcmVndWxhcl9jYWxsYmFja19saXN0ICogJ2EgcmVndWxhcl9jYWxsYmFja19saXN0XG4gICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIG9mXG4gICAgICAnYSByZWd1bGFyX2NhbGxiYWNrXG4gICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2sgb2ZcbiAgICAgICdhIHJlZ3VsYXJfY2FsbGJhY2sgb3B0aW9uIHJlZlxuXG4gIGFuZCBfIGNhbmNlbF9jYWxsYmFja19saXN0ID1cbiAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X2VtcHR5IDpcbiAgICAgIF8gY2FuY2VsX2NhbGxiYWNrX2xpc3RcbiAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X2NvbmNhdCA6XG4gICAgICAnYSBjYW5jZWxfY2FsbGJhY2tfbGlzdCAqICdhIGNhbmNlbF9jYWxsYmFja19saXN0IC0+XG4gICAgICAgICdhIGNhbmNlbF9jYWxsYmFja19saXN0XG4gICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9jYWxsYmFjayA6XG4gICAgICBzdG9yYWdlICogY2FuY2VsX2NhbGxiYWNrIC0+XG4gICAgICAgIF8gY2FuY2VsX2NhbGxiYWNrX2xpc3RcbiAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X3JlbW92ZV9zZXF1ZW5jZV9ub2RlIDpcbiAgICAgICgnYSwgXywgXykgcHJvbWlzZSBMd3Rfc2VxdWVuY2Uubm9kZSAtPlxuICAgICAgICAnYSBjYW5jZWxfY2FsbGJhY2tfbGlzdFxuXG4gICgqIE5vdGVzOlxuXG4gICAgIFRoZXNlIHR5cGUgZGVmaW5pdGlvbnMgYXJlIGd1aWx0eSBvZiBwZXJmb3JtaW5nIHNldmVyYWwgb3B0aW1pemF0aW9ucyxcbiAgICAgd2l0aG91dCB3aGljaCB0aGV5IHdvdWxkIGJlIG11Y2ggZWFzaWVyIHRvIHVuZGVyc3RhbmQuXG5cbiAgICAgLSBUaGUgdHlwZSBwYXJhbWV0ZXJzIG9mIFsnYSByZXNvbHZlZF9zdGF0ZV0gZ3VhcmFudGVlIHRoYXQgaXQgaXMgZWl0aGVyXG4gICAgICAgW0Z1bGZpbGxlZCBfXSBvciBbUmVqZWN0ZWQgX10uIFNvLCBpdCBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgWygnYSwgZXhuKSBTdGRsaWIucmVzdWx0XSwgYW5kLCBpbmRlZWQsIHNob3VsZCBoYXZlIGFuIGlkZW50aWNhbFxuICAgICAgIG1lbW9yeSByZXByZXNlbnRhdGlvbi5cblxuICAgICAtIEFzIHBlciB0aGUgT3ZlcnZpZXcsIHRoZXJlIGFyZSByZWd1bGFyIGNhbGxiYWNrcyBhbmQgY2FuY2VsIGNhbGxiYWNrcy5cbiAgICAgICBDYW5jZWwgY2FsbGJhY2tzIGFyZSBjYWxsZWQgb25seSBvbiBjYW5jZWxsYXRpb24sIGFuZCwgdGhlbiwgYmVmb3JlIGFueVxuICAgICAgIHJlZ3VsYXIgY2FsbGJhY2tzIGFyZSBjYWxsZWQuXG5cbiAgICAgICBEZXNwaXRlIHRoZSBkaWZmZXJlbnQgdHlwZXMgZm9yIHRoZSB0d28ga2luZHMgb2YgY2FsbGJhY2tzLCB0aGV5IGFyZVxuICAgICAgIG90aGVyd2lzZSB0aGUgc2FtZS4gQ2FuY2VsIGNhbGxiYWNrcyBqdXN0IGRvbid0IG5lZWQgYSByZXN1bHQgc3RhdGVcbiAgICAgICBhcmd1bWVudCwgYmVjYXVzZSBpdCBpcyBrbm93biB0byBiZSBbUmVqZWN0ZWQgQ2FuY2VsZWRdLlxuXG4gICAgIC0gUmVndWxhciBjYWxsYmFja3MgYXJlIG5vdCBhbGxvd2VkIHRvIHJhaXNlIGV4Y2VwdGlvbnMuIEFsbCByZWd1bGFyXG4gICAgICAgY2FsbGJhY2tzIGFyZSBjcmVhdGVkIGluIHRoaXMgZmlsZSwgc28gdGhpcyBjYW4gYmUgY2hlY2tlZC5cblxuICAgICAgIENhbmNlbCBjYWxsYmFja3MgY2FuIHJhaXNlIGV4Y2VwdGlvbnMsIGJ1dCBpZiB0aGV5IGRvIHNvLCB0aGUgZXhjZXB0aW9uc1xuICAgICAgIGFyZSBwYXNzZWQgdG8gW2FzeW5jX2V4Y2VwdGlvbl9ob29rXS5cblxuICAgICAtIFtob3dfdG9fY2FuY2VsXSBpbXBsZW1lbnRzIHRoZSBkZXBlbmRlbmN5IGdyYXBoIG1lbnRpb25lZCBpbiB0aGVcbiAgICAgICBPdmVydmlldy4gSXQgaXMgdHJhdmVyc2VkIGJhY2t3YXJkcyBkdXJpbmcgW0x3dC5jYW5jZWxdLiBJdCBpcyBhIEdBRFRcbiAgICAgICBiZWNhdXNlIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhlIGFjdHVhbCB0eXBlcyBvZiB0aGUgcHJvbWlzZSByZWZlcmVuY2VzXG4gICAgICAgc3RvcmVkLCBvciB0aGVpciBpbnZhcmlhbnRzLiBUaGUgY29uc3RydWN0b3JzIGNvcnJlc3BvbmQgdG8gcGVuZGluZ1xuICAgICAgIHByb21pc2Uga2luZHMgYXMgZm9sbG93czpcbiAgICAgICAgIC0gW05vdF9jYW5jZWxhYmxlXTogaW5pdGlhbCwgW0x3dC53YWl0XS5cbiAgICAgICAgIC0gW0NhbmNlbF90aGlzX3Byb21pc2VdOiBpbml0aWFsLCBbTHd0LnRhc2tdLlxuICAgICAgICAgLSBbUHJvcGFnYXRlX2NhbmNlbF90b19vbmVdOiBzZXF1ZW50aWFsIGNvbXBvc2l0aW9uLCBlLmcuIFtMd3QuYmluZF0uXG4gICAgICAgICAtIFtQcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWxdOiBjb25jdXJyZW50IGNvbXBvc2l0aW9uLCBlLmcuXG4gICAgICAgICAgIFtMd3Quam9pbl0uXG5cbiAgICAgLSBUaGUgdHdvIGNhbGxiYWNrIGxpc3QgdHlwZXMgYXJlIG9yZGluYXJ5IGFwcGVuZC1mcmllbmRseSBsaXN0cywgd2l0aCB0d29cbiAgICAgICBvcHRpbWl6YXRpb25zIGlubGluZWQ6XG5cbiAgICAgICAtIFsnYSByZWd1bGFyX2NhbGxiYWNrX2xpc3RdIGFwcGFyZW50bHkgaGFzIHR3byBcImtpbmRzXCIgb2YgcmVndWxhclxuICAgICAgICAgY2FsbGJhY2tzLCBpbXBsaWNpdGx5IHJlbW92ZWQgYW5kIGV4cGxpY2l0bHkgcmVtb3ZhYmxlLiBBbGwgY2FsbGJhY2tzXG4gICAgICAgICBhcmUgcmVtb3ZhYmxlLiBJdCdzIGp1c3QgdGhhdCwgZm9yIHNvbWUgY2FsbGJhY2tzLCB0aGV5IHdpbGwgb25seSBiZVxuICAgICAgICAgcmVtb3ZlZCBhdCB0aGUgc2FtZSB0aW1lIHRoYXQgdGhlIHByb21pc2UgdGhleSBhcmUgYXR0YWNoZWQgdG8gYmVjb21lc1xuICAgICAgICAgcmVzb2x2ZWQuIFdoZW4gdGhhdCBoYXBwZW5zLCB0aGUgZW50aXJlIHN0YXRlIG9mIHRoYXQgcHJvbWlzZSBjaGFuZ2VzXG4gICAgICAgICB0byBbRnVsZmlsbGVkIF9dIG9yIFtSZWplY3RlZCBfXSwgYW5kIHRoZSByZWZlcmVuY2UgdG8gdGhlIHdob2xlXG4gICAgICAgICBjYWxsYmFjayBsaXN0IGlzIHNpbXBseSBsb3N0LiBUaGlzIFwicmVtb3Zlc1wiIHRoZSBjYWxsYmFjay4gRm9yIHRoZXNlXG4gICAgICAgICBjYWxsYmFja3MsIFsnYSByZWd1bGFyX2NhbGxiYWNrX2xpc3RdIGF0dGVtcHRzIHRvIHRyaW0gYW4gb3B0aW9uIGFuZCBhXG4gICAgICAgICByZWZlcmVuY2UgY2VsbCB3aXRoIHRoZVxuICAgICAgICAgW1JlZ3VsYXJfY2FsbGJhY2tfbGlzdF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2tdIGNvbnN0cnVjdG9yLlxuXG4gICAgICAgLSBbJ2EgY2FuY2VsX2NhbGxiYWNrX2xpc3RdIGhhc1xuICAgICAgICAgW0NhbmNlbF9jYWxsYmFja19saXN0X3JlbW92ZV9zZXF1ZW5jZV9ub2RlIG5vZGVdLCB3aGljaCBpcyB0aGUgc2FtZSBhc1xuICAgICAgICAgW0NhbmNlbF9jYWxsYmFja19saXN0X2NhbGxiYWNrIChfLCAoZnVuIF8gLT5cbiAgICAgICAgICAgTHd0X3NlcXVlbmNlLnJlbW92ZSBub2RlKSldLlxuICAgICAgICAgVGhpcyB3YXMgcHJvYmFibHkgZG9uZSB0byBhdm9pZCBhIGNsb3N1cmUgYWxsb2NhdGlvbi5cblxuICAgICAtIFRoZSBbY2xlYW51cHNfZGVmZXJyZWRdIGZpZWxkIGlzIGV4cGxhaW5lZCBpbiBtb2R1bGVcbiAgICAgICBbUGVuZGluZ19jYWxsYmFja3NdLiAqKVxuZW5kXG5vcGVuIE1haW5faW50ZXJuYWxfdHlwZXNcblxuXG5cbm1vZHVsZSBQdWJsaWNfdHlwZXMgPVxuc3RydWN0XG4gIHR5cGUgKydhIHRcbiAgdHlwZSAtJ2EgdVxuICAoKiBUaGUgY29udHJhdmFyaWFuY2Ugb2YgcmVzb2x2ZXJzIGlzLCB0ZWNobmljYWxseSwgdW5zb3VuZCBkdWUgdG8gdGhlXG4gICAgIGV4aXN0ZW5jZSBvZiBbTHd0LndhaXRlcl9vZl93YWtlbmVyXS4gVGhhdCBpcyB3aHkgdGhhdCBmdW5jdGlvbiBpc1xuICAgICBkZXByZWNhdGVkLiBTZWVcblxuICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9pc3N1ZXMvNDU4ICopXG5cbiAgbGV0IHRvX3B1YmxpY19wcm9taXNlIDogKCdhLCBfLCBfKSBwcm9taXNlIC0+ICdhIHQgPSBPYmoubWFnaWNcbiAgbGV0IHRvX3B1YmxpY19yZXNvbHZlciA6ICgnYSwgXywgXykgcHJvbWlzZSAtPiAnYSB1ID0gT2JqLm1hZ2ljXG5cbiAgdHlwZSBfIHBhY2tlZF9wcm9taXNlID1cbiAgICB8IEludGVybmFsIDogKCdhLCBfLCBfKSBwcm9taXNlIC0+ICdhIHBhY2tlZF9wcm9taXNlXG4gICAgW0BAb2NhbWwudW5ib3hlZF1cblxuICBsZXQgdG9faW50ZXJuYWxfcHJvbWlzZSAocCA6ICdhIHQpIDogJ2EgcGFja2VkX3Byb21pc2UgPVxuICAgIEludGVybmFsIChPYmoubWFnaWMgcClcbiAgbGV0IHRvX2ludGVybmFsX3Jlc29sdmVyIChyIDogJ2EgdSkgOiAnYSBwYWNrZWRfcHJvbWlzZSA9XG4gICAgSW50ZXJuYWwgKE9iai5tYWdpYyByKVxuXG4gICgqIE1vc3QgZnVuY3Rpb25zIHRoYXQgdGFrZSBhIHB1YmxpYyBwcm9taXNlIChbJ2EgdF0pIGNvbnZlcnQgaXQgdG8gYW5cbiAgICAgaW50ZXJuYWwgcHJvbWlzZSBhcyBmb2xsb3dzOlxuXG4gICAgICAgKCogcCA6ICdhIHQgKilcblxuICAgICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG5cbiAgICAgICAoKiBwIDogKCdhLCB1LCBjKSBwcm9taXNlLCB3aGVyZSB1IGFuZCBjIGFyZSBmcmVzaCB0eXBlcywgaS5lLiB0aGVcbiAgICAgICAgICBpbnZhcmlhbnRzIG9uIHAgYXJlIHVua25vd24uICopXG5cbiAgICAgVGhpcyBjYXN0IGlzIGEgbm8tb3AgY2FzdC4gSXQgb25seSBwcm9kdWNlcyBhIHJlZmVyZW5jZSB3aXRoIGEgZGlmZmVyZW50XG4gICAgIHR5cGUuIFRoZSBpbnRyb2R1Y3Rpb24gYW5kIGltbWVkaWF0ZSBlbGltaW5hdGlvbiBvZiBbSW50ZXJuYWwgX10gc2VlbXMgdG9cbiAgICAgYmUgb3B0aW1pemVkIGF3YXkgZXZlbiBvbiBvbGRlciB2ZXJzaW9ucyBvZiBPQ2FtbCB0aGF0IGRvbid0IGhhdmUgRmxhbWJkYVxuICAgICBhbmQgZG9uJ3Qgc3VwcG9ydCBbW0BAb2NhbWwudW5ib3hlZF1dLiAqKVxuXG5cblxuICAoKiBJbnRlcm5hbCBuYW1lIG9mIHRoZSBwdWJsaWMgWysnYSBMd3QucmVzdWx0XS4gVGhlIHB1YmxpYyBuYW1lIGlzIGRlZmluZWRcbiAgICAgbGF0ZXIgaW4gdGhlIG1vZHVsZS4gVGhpcyBpcyB0byBhdm9pZCBwb3RlbnRpYWwgY29uZnVzaW9uIHdpdGhcbiAgICAgW1N0ZGxpYi5yZXN1bHRdL1tSZXN1bHQucmVzdWx0XSwgYXMgdGhlIHB1YmxpYyBuYW1lIHdvdWxkIG5vdCBiZVxuICAgICBwcmVmaXhlZCB3aXRoIFtMd3QuXSBpbnNpZGUgdGhpcyBmaWxlLiAqKVxuICB0eXBlICsnYSBsd3RfcmVzdWx0ID0gKCdhLCBleG4pIFJlc3VsdC50XG5cbiAgKCogVGhpcyBjb3VsZCBwcm9iYWJseSBzYXZlIGFuIGFsbG9jYXRpb24gYnkgdXNpbmcgW09iai5tYWdpY10uICopXG4gIGxldCBzdGF0ZV9vZl9yZXN1bHQgPSBmdW5jdGlvblxuICAgIHwgUmVzdWx0Lk9rIHggLT4gRnVsZmlsbGVkIHhcbiAgICB8IFJlc3VsdC5FcnJvciBleG4gLT4gUmVqZWN0ZWQgZXhuXG5lbmRcbmluY2x1ZGUgUHVibGljX3R5cGVzXG5cblxuXG5tb2R1bGUgQmFzaWNfaGVscGVycyA6XG5zaWdcbiAgdmFsIGlkZW50aWNhbCA6ICgnYSwgXywgXykgcHJvbWlzZSAtPiAoJ2EsIF8sIF8pIHByb21pc2UgLT4gYm9vbFxuICB2YWwgdW5kZXJseWluZyA6ICgnYSwgJ3UsICdjKSBwcm9taXNlIC0+ICgnYSwgdW5kZXJseWluZywgJ2MpIHByb21pc2VcblxuICB0eXBlICgnYSwgJ3UsICdjKSBzdGF0ZV9jaGFuZ2VkID1cbiAgICB8IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgb2YgKCdhLCAndSwgJ2MpIHByb21pc2VcbiAgICBbQEBvY2FtbC51bmJveGVkXVxuICB2YWwgc2V0X3Byb21pc2Vfc3RhdGUgOlxuICAgICgnYSwgXywgXykgcHJvbWlzZSAtPiAoJ2EsICd1LCAnYykgc3RhdGUgLT4gKCdhLCAndSwgJ2MpIHN0YXRlX2NoYW5nZWRcblxuICB0eXBlICdhIG1heV9ub3dfYmVfcHJveHkgPVxuICAgIHwgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IDpcbiAgICAgICgnYSwgXywgcGVuZGluZykgcHJvbWlzZSAtPiAnYSBtYXlfbm93X2JlX3Byb3h5XG4gICAgW0BAb2NhbWwudW5ib3hlZF1cbiAgdmFsIG1heV9ub3dfYmVfcHJveHkgOlxuICAgICgnYSwgdW5kZXJseWluZywgcGVuZGluZykgcHJvbWlzZSAtPiAnYSBtYXlfbm93X2JlX3Byb3h5XG5lbmQgPVxuc3RydWN0XG4gICgqIENoZWNrcyBwaHlzaWNhbCBlcXVhbGl0eSAoWz09XSkgb2YgdHdvIGludGVybmFsIHByb21pc2VzLiBVbmxpa2UgWz09XSwgZG9lc1xuICAgICBub3QgZm9yY2UgdW5pZmljYXRpb24gb2YgdGhlaXIgaW52YXJpYW50cy4gKilcbiAgbGV0IGlkZW50aWNhbCBwMSBwMiA9XG4gICAgKHRvX3B1YmxpY19wcm9taXNlIHAxKSA9PSAodG9fcHVibGljX3Byb21pc2UgcDIpXG5cbiAgKCogW3VuZGVybHlpbmcgcF0gZXZhbHVhdGVzIHRvIHRoZSB1bmRlcmx5aW5nIHByb21pc2Ugb2YgW3BdLlxuXG4gICAgIElmIG11bHRpcGxlIFtQcm94eSBfXSBsaW5rcyBhcmUgdHJhdmVyc2VkLCBbdW5kZXJseWluZ10gdXBkYXRlcyBhbGwgdGhlXG4gICAgIHByb3hpZXMgdG8gcG9pbnQgaW1tZWRpYXRlbHkgdG8gdGhlaXIgZmluYWwgdW5kZXJseWluZyBwcm9taXNlLiAqKVxuICBsZXQgcmVjIHVuZGVybHlpbmdcbiAgICAgIDogdHlwZSB1IGMuICgnYSwgdSwgYykgcHJvbWlzZSAtPiAoJ2EsIHVuZGVybHlpbmcsIGMpIHByb21pc2UgPVxuICAgIGZ1biBwIC0+XG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCBfIC0+IChwIDogKF8sIHVuZGVybHlpbmcsIF8pIHByb21pc2UpXG4gICAgfCBSZWplY3RlZCBfIC0+IHBcbiAgICB8IFBlbmRpbmcgXyAtPiBwXG4gICAgfCBQcm94eSBwJyAtPlxuICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcgaW5cbiAgICAgIGlmIG5vdCAoaWRlbnRpY2FsIHAnJyBwJykgdGhlblxuICAgICAgICBwLnN0YXRlIDwtIFByb3h5IHAnJztcbiAgICAgIHAnJ1xuXG5cblxuICB0eXBlICgnYSwgJ3UsICdjKSBzdGF0ZV9jaGFuZ2VkID1cbiAgICB8IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgb2YgKCdhLCAndSwgJ2MpIHByb21pc2VcbiAgICBbQEBvY2FtbC51bmJveGVkXVxuXG4gIGxldCBzZXRfcHJvbWlzZV9zdGF0ZSBwIHN0YXRlID1cbiAgICBsZXQgcCA6IChfLCBfLCBfKSBwcm9taXNlID0gT2JqLm1hZ2ljIHAgaW5cbiAgICBwLnN0YXRlIDwtIHN0YXRlO1xuICAgIFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcFxuXG4gICgqIFtzZXRfcHJvbWlzZV9zdGF0ZSBwIHN0YXRlXSBtdXRhdGVzIHRoZSBzdGF0ZSBvZiBbcF0sIGFuZCBldmFsdWF0ZXMgdG8gYVxuICAgICAod3JhcHBlZCkgcmVmZXJlbmNlIHRvIFtwXSB3aXRoIHRoZSBzYW1lIGludmFyaWFudHMgYXMgb24gW3N0YXRlXS4gVGhlXG4gICAgIG9yaWdpbmFsIHJlZmVyZW5jZSBbcF0gc2hvdWxkIGJlIHNoYWRvd2VkIHdoZW4gY2FsbGluZyB0aGlzIGZ1bmN0aW9uOlxuXG4gICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCA9IHNldF9wcm9taXNlX3N0YXRlIHAgKEZ1bGZpbGxlZCA0MikgaW4gLi4uXG5cbiAgICAgVGhpcyBpcyBhIGtpbmQgb2YgY2hlYXAgaW1pdGF0aW9uIG9mIGxpbmVhciB0eXBpbmcsIHdoaWNoIGlzIGdvb2QgZW5vdWdoXG4gICAgIGZvciB0aGUgbmVlZHMgb2YgW2x3dC5tbF0uXG5cbiAgICAgSW50ZXJuYWwgZnVuY3Rpb25zIHRoYXQgdHJhbnNpdGl2ZWx5IGNhbGwgW3NldF9wcm9taXNlX3N0YXRlXSBsaWtld2lzZVxuICAgICByZXR1cm4gdGhlIG5ldyByZWZlcmVuY2UuIFRoaXMgZW5kcyBhdCBzb21lIHRvcC1sZXZlbCBmdW5jdGlvbiwgdHlwaWNhbGx5XG4gICAgIGVpdGhlciBhIGNhbGxiYWNrIG9yIGEgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuIFRoZXJlLCB0aGUgbmV3IHJlZmVyZW5jZVxuICAgICBpcyBzdGlsbCBib3VuZCwgYnV0IGlzIHRoZW4gZXhwbGljaXRseSBpZ25vcmVkLlxuXG4gICAgIFRoZSBzdGF0ZSBvZiBhIHByb21pc2UgaXMgbmV2ZXIgdXBkYXRlZCBkaXJlY3RseSBvdXRzaWRlIHRoaXMgbW9kdWxlXG4gICAgIFtCYXNpY19oZWxwZXJzXS4gQWxsIHVwZGF0ZXMgZWxzZXdoZXJlIGFyZSBkb25lIHRocm91Z2hcbiAgICAgW3NldF9wcm9taXNlX3N0YXRlXS5cblxuICAgICBUbyBhdm9pZCBwcm9ibGVtcyB3aXRoIHR5cGUtbGV2ZWwgaW52YXJpYW50cyBub3QgbWF0Y2hpbmcgcmVhbGl0eSwgZGF0YVxuICAgICBzdHJ1Y3R1cmVzIGRvIG5vdCBzdG9yZSBwcm9taXNlcyB3aXRoIGNvbmNyZXRlIGludmFyaWFudHMgLS0gZXhjZXB0XG4gICAgIHJlc29sdmVkIHByb21pc2VzLCB3aGljaCBhcmUgaW1tdXRhYmxlLiBJbmRlZWQsIGlmIG9uZSBsb29rcyBhdFxuICAgICBkZWZpbml0aW9ucyBvZiBkYXRhIHN0cnVjdHVyZXMgdGhhdCBjYW4gc3RvcmUgcGVuZGluZyBwcm9taXNlcywgZS5nLiB0aGVcbiAgICAgW2hvd190b19jYW5jZWxdIGdyYXBoLCB0aGUgaW52YXJpYW50cyBhcmUgZXhpc3RlbnRpYWxseSBxdWFudGlmaWVkLlxuXG4gICAgIE5vdGU6IGl0J3MgcG9zc2libGUgdG8gc3RhdGljYWxseSBkaXNhbGxvdyB0aGUgc2V0dGluZyBvZiB0aGUgW3N0YXRlXSBmaWVsZFxuICAgICBieSBtYWtpbmcgdHlwZSBbcHJvbWlzZV0gcHJpdmF0ZS4gSG93ZXZlciwgdGhhdCBzZWVtcyB0byByZXF1aXJlIHdyaXRpbmcgYVxuICAgICBzaWduYXR1cmUgdGhhdCBpcyBhIG5lYXItZHVwbGljYXRlIG9mIFtNYWluX2ludGVybmFsX3R5cGVzXSwgb3Igc29tZSBhYnVzZVxuICAgICBvZiBmdW5jdG9ycy4gKilcblxuXG5cbiAgdHlwZSAnYSBtYXlfbm93X2JlX3Byb3h5ID1cbiAgICB8IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSA6XG4gICAgICAoJ2EsIF8sIHBlbmRpbmcpIHByb21pc2UgLT4gJ2EgbWF5X25vd19iZV9wcm94eVxuICAgIFtAQG9jYW1sLnVuYm94ZWRdXG5cbiAgbGV0IG1heV9ub3dfYmVfcHJveHkgcCA9IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwXG5cbiAgKCogTWFueSBmdW5jdGlvbnMsIGZvciBleGFtcGxlIFtMd3QuYmluZF0gYW5kIFtMd3Quam9pbl0sIGNyZWF0ZSBhIGZyZXNoXG4gICAgIHBlbmRpbmcgcHJvbWlzZSBbcF0gYW5kIHJldHVybiBpdCB0byB0aGUgdXNlci5cblxuICAgICBUaGV5IGRvIG5vdCByZXR1cm4gYSBjb3JyZXNwb25kaW5nIHJlc29sdmVyLiBUaGF0IG1lYW5zIHRoYXQgb25seSB0aGVcbiAgICAgZnVuY3Rpb24gaXRzZWxmICh0eXBpY2FsbHksIGEgY2FsbGJhY2sgcmVnaXN0ZXJlZCBieSBpdCkgY2FuIHJlc29sdmUgW3BdLlxuICAgICBUaGUgb25seSB0aGluZyB0aGUgdXNlciBjYW4gZG8gZGlyZWN0bHkgaXMgdHJ5IHRvIGNhbmNlbCBbcF0sIGJ1dCwgc2luY2VcbiAgICAgW3BdIGlzIG5vdCBhbiBpbml0aWFsIHByb21pc2UsIHRoZSBjYW5jZWxsYXRpb24gYXR0ZW1wdCBzaW1wbHkgcHJvcGFnYXRlc1xuICAgICBwYXN0IFtwXSB0byBbcF0ncyBwcmVkZWNlc3NvcnMuIElmIHRoYXQgZXZlbnR1YWxseSByZXN1bHRzIGluIGNhbmNlbGluZ1xuICAgICBbcF0sIGl0IHdpbGwgYmUgdGhyb3VnaCB0aGUgbm9ybWFsIG1lY2hhbmlzbXMgb2YgdGhlIGZ1bmN0aW9uIChlLmcuXG4gICAgIFtMd3QuYmluZF0ncyBjYWxsYmFjaykuXG5cbiAgICAgQXMgYSByZXN1bHQsIHRoZSBvbmx5IHBvc3NpYmxlIHN0YXRlIGNoYW5nZSwgYmVmb3JlIHRoZSBjYWxsYmFjaywgaXMgdGhhdFxuICAgICBbcF0gbWF5IGhhdmUgYmVjb21lIGEgcHJveHkuIE5vdyxcblxuICAgICAtIElmIFtwXSBkb2VzIG5vdCB1bmRlcmdvIHRoaXMgc3RhdGUgY2hhbmdlIGFuZCBiZWNvbWUgYSBwcm94eSwgaXQgcmVtYWluc1xuICAgICAgIGFuIHVuZGVybHlpbmcsIHBlbmRpbmcgcHJvbWlzZS5cbiAgICAgLSBJZiBbcF0gZG9lcyBiZWNvbWUgYSBwcm94eSwgaXQgd2lsbCBiZSBhIHByb3h5IGZvciBhbm90aGVyIHByb21pc2UgW3AnXVxuICAgICAgIGNyZWF0ZWQgZnJlc2ggYnkgW0x3dC5iaW5kXSwgdG8gd2hpY2ggdGhpcyBzYW1lIGFyZ3VtZW50IGFwcGxpZXMuIFNlZVxuICAgICAgIFttYWtlX2ludG9fcHJveHldLlxuXG4gICAgIFNvLCBieSBpbmR1Y3Rpb24gb24gdGhlIGxlbmd0aCBvZiB0aGUgcHJveHkgKFtQcm94eSBfXSkgY2hhaW4sIGF0IHRoZSB0aW1lXG4gICAgIHRoZSBjYWxsYmFjayBpcyBjYWxsZWQsIFtwXSBpcyBlaXRoZXIgYW4gdW5kZXJseWluZywgcGVuZGluZyBwcm9taXNlLCBvciBhXG4gICAgIHByb3h5IGZvciBhIHBlbmRpbmcgcHJvbWlzZS5cblxuICAgICBUaGUgY2FzdFxuXG4gICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwID0gbWF5X25vd19iZV9wcm94eSBwIGluIC4uLlxuXG4gICAgIGVuY29kZXMgdGhlIHBvc3NpYmlsaXR5IG9mIHRoaXMgc3RhdGUgY2hhbmdlLiBJdCByZXBsYWNlcyBhIHJlZmVyZW5jZVxuXG4gICAgICAgcCA6ICgnYSwgdW5kZXJseWluZywgcGVuZGluZylcblxuICAgICB3aXRoXG5cbiAgICAgICBwIDogKCdhLCAkVW5rbm93biwgcGVuZGluZylcblxuICAgICBhbmQgaXMgdHlwaWNhbGx5IHNlZW4gYXQgdGhlIGJlZ2lubmluZyBvZiBjYWxsYmFja3MgcmVnaXN0ZXJlZCBieVxuICAgICBbTHd0LmJpbmRdIGFuZCBzaW1pbGFyIGZ1bmN0aW9ucy5cblxuICAgICBUaGUgY2FzdCBpcyBhIG5vLW9wIGNhc3QuIFRoZSBpbnRyb2R1Y3Rpb24gYW5kIGltbWVkaWF0ZSBlbGltaW5hdGlvbiBvZlxuICAgICBbU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBfXSBzZWVtcyB0byBiZSBvcHRpbWl6ZWQgYXdheSBldmVuIG9uIG9sZCB2ZXJzaW9uc1xuICAgICBvZiBPQ2FtbC4gKilcbmVuZFxub3BlbiBCYXNpY19oZWxwZXJzXG5cblxuXG5tb2R1bGUgU2VxdWVuY2VfYXNzb2NpYXRlZF9zdG9yYWdlIDpcbnNpZ1xuICAoKiBQdWJsaWMgaW50ZXJmYWNlICopXG4gIHR5cGUgJ3Yga2V5XG4gIHZhbCBuZXdfa2V5IDogdW5pdCAtPiBfIGtleVxuICB2YWwgZ2V0IDogJ3Yga2V5IC0+ICd2IG9wdGlvblxuICB2YWwgd2l0aF92YWx1ZSA6ICd2IGtleSAtPiAndiBvcHRpb24gLT4gKHVuaXQgLT4gJ2IpIC0+ICdiXG5cbiAgKCogSW50ZXJuYWwgaW50ZXJmYWNlICopXG4gIHZhbCBjdXJyZW50X3N0b3JhZ2UgOiBzdG9yYWdlIHJlZlxuZW5kID1cbnN0cnVjdFxuICAoKiBUaGUgaWRlYSBiZWhpbmQgc2VxdWVuY2UtYXNzb2NpYXRlZCBzdG9yYWdlIGlzIHRvIHByZXNlcnZlIHNvbWUgdmFsdWVzXG4gICAgIGR1cmluZyBhIGNhbGwgdG8gW2JpbmRdIG9yIG90aGVyIHNlcXVlbnRpYWwgY29tcG9zaXRpb24gb3BlcmF0aW9uLCBhbmRcbiAgICAgcmVzdG9yZSB0aG9zZSB2YWx1ZXMgaW4gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uOlxuXG4gICAgICAgTHd0LndpdGhfdmFsdWUgbXlfa2V5IChTb21lIFwiZm9vXCIpIChmdW4gKCkgLT5cbiAgICAgICBwID58PSBmdW4gKCkgLT5cbiAgICAgICBhc3NlcnQgKEx3dC5nZXQgbXlfa2V5ID0gU29tZSBcImZvb1wiKSlcbiAgICAgICAgICgqIFdpbGwgc3VjY2VlZCBldmVuIGlmIHRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIGxhdGVyLiAqKVxuXG4gICAgIE5vdGUgdGhhdCBpdCBkb2VzIG5vdCBtYXR0ZXIgdGhhdCB0aGUgY2FsbGJhY2sgaXMgZGVmaW5lZCB3aXRoaW4gYW5cbiAgICAgYXJndW1lbnQgb2YgW3dpdGhfdmFsdWVdLCBpLmUuLCB0aGlzIGRvZXMgdGhlIHNhbWU6XG5cbiAgICAgICBsZXQgZiA9IGZ1biAoKSAtPiBhc3NlcnQgKEx3dC5nZXQgbXlfa2V5ID0gU29tZSBcImZvb1wiKSBpblxuICAgICAgIEx3dC53aXRoX3ZhbHVlIG15X2tleSAoU29tZSBcImZvb1wiKSAoZnVuICgpIC0+IHAgPnw9IGYpXG5cbiAgICAgQWxsIHRoYXQgbWF0dGVycyBpcyB0aGF0IHRoZSB0b3AtbW9zdCBzZXF1ZW5jaW5nIG9wZXJhdGlvbiAoaW4gdGhpcyBjYXNlLFxuICAgICBtYXApIGlzIGV4ZWN1dGVkIGJ5IHRoYXQgYXJndW1lbnQuXG5cbiAgICAgVGhpcyBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHNpbmdsZSBnbG9iYWwgaGV0ZXJvZ2VuZW91cyBrZXktdmFsdWUgbWFwLlxuICAgICBTZXF1ZW50aWFsIGNvbXBvc2l0aW9uIGZ1bmN0aW9ucyBzbmFwc2hvdCB0aGlzIG1hcCB3aGVuIHRoZXkgYXJlIGNhbGxlZCxcbiAgICAgYW5kIHJlc3RvcmUgdGhlIHNuYXBzaG90IHJpZ2h0IGJlZm9yZSBjYWxsaW5nIHRoZSB1c2VyJ3MgY2FsbGJhY2suIFRoZSBzYW1lXG4gICAgIGhhcHBlbnMgZm9yIGNhbmNlbCB0cmlnZ2VycyBhZGRlZCBieSBbb25fY2FuY2VsXS5cblxuICAgICBNYWludGFpbmVyJ3Mgbm90ZTogSSB0aGluayB1c2luZyB0aGlzIG1lY2hhbmlzbSBzaG91bGQgYmUgZGlzY291cmFnZWQgaW5cbiAgICAgbmV3IGNvZGUuICopXG5cbiAgdHlwZSAndiBrZXkgPSB7XG4gICAgaWQgOiBpbnQ7XG4gICAgbXV0YWJsZSB2YWx1ZSA6ICd2IG9wdGlvbjtcbiAgfVxuXG4gIGxldCBuZXh0X2tleV9pZCA9IHJlZiAwXG5cbiAgbGV0IG5ld19rZXkgKCkgPVxuICAgIGxldCBpZCA9ICFuZXh0X2tleV9pZCBpblxuICAgIG5leHRfa2V5X2lkIDo9IGlkICsgMTtcbiAgICB7aWQgPSBpZDsgdmFsdWUgPSBOb25lfVxuXG4gIGxldCBjdXJyZW50X3N0b3JhZ2UgPSByZWYgU3RvcmFnZV9tYXAuZW1wdHlcblxuICBsZXQgZ2V0IGtleSA9XG4gICAgaWYgU3RvcmFnZV9tYXAubWVtIGtleS5pZCAhY3VycmVudF9zdG9yYWdlIHRoZW4gYmVnaW5cbiAgICAgIGxldCByZWZyZXNoID0gU3RvcmFnZV9tYXAuZmluZCBrZXkuaWQgIWN1cnJlbnRfc3RvcmFnZSBpblxuICAgICAgcmVmcmVzaCAoKTtcbiAgICAgIGxldCB2YWx1ZSA9IGtleS52YWx1ZSBpblxuICAgICAga2V5LnZhbHVlIDwtIE5vbmU7XG4gICAgICB2YWx1ZVxuICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIE5vbmVcblxuICBsZXQgd2l0aF92YWx1ZSBrZXkgdmFsdWUgZiA9XG4gICAgbGV0IG5ld19zdG9yYWdlID1cbiAgICAgIG1hdGNoIHZhbHVlIHdpdGhcbiAgICAgIHwgU29tZSBfIC0+XG4gICAgICAgIGxldCByZWZyZXNoID0gZnVuICgpIC0+IGtleS52YWx1ZSA8LSB2YWx1ZSBpblxuICAgICAgICBTdG9yYWdlX21hcC5hZGQga2V5LmlkIHJlZnJlc2ggIWN1cnJlbnRfc3RvcmFnZVxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIFN0b3JhZ2VfbWFwLnJlbW92ZSBrZXkuaWQgIWN1cnJlbnRfc3RvcmFnZVxuICAgIGluXG5cbiAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cbiAgICBjdXJyZW50X3N0b3JhZ2UgOj0gbmV3X3N0b3JhZ2U7XG4gICAgdHJ5XG4gICAgICBsZXQgcmVzdWx0ID0gZiAoKSBpblxuICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG4gICAgICByZXN1bHRcbiAgICB3aXRoIGV4biAtPlxuICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG4gICAgICByYWlzZSBleG5cbmVuZFxuaW5jbHVkZSBTZXF1ZW5jZV9hc3NvY2lhdGVkX3N0b3JhZ2VcblxuXG5cbm1vZHVsZSBQZW5kaW5nX2NhbGxiYWNrcyA6XG5zaWdcbiAgKCogTXV0YXRpbmcgY2FsbGJhY2sgbGlzdHMgYXR0YWNoZWQgdG8gcGVuZGluZyBwcm9taXNlcyAqKVxuICB2YWwgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayA6XG4gICAgJ2EgY2FsbGJhY2tzIC0+ICdhIHJlZ3VsYXJfY2FsbGJhY2sgLT4gdW5pdFxuICB2YWwgYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX3RvX2VhY2hfb2YgOlxuICAgICdhIHQgbGlzdCAtPiAnYSByZWd1bGFyX2NhbGxiYWNrIC0+IHVuaXRcbiAgdmFsIGFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja19hbmRfZ2l2ZV9yZW1vdmVfZnVuY3Rpb24gOlxuICAgICdhIHQgbGlzdCAtPiAnYSByZWd1bGFyX2NhbGxiYWNrIC0+IGNhbmNlbF9jYWxsYmFja1xuICB2YWwgYWRkX2NhbmNlbF9jYWxsYmFjayA6ICdhIGNhbGxiYWNrcyAtPiBjYW5jZWxfY2FsbGJhY2sgLT4gdW5pdFxuICB2YWwgbWVyZ2VfY2FsbGJhY2tzIDogZnJvbTonYSBjYWxsYmFja3MgLT4gaW50bzonYSBjYWxsYmFja3MgLT4gdW5pdFxuZW5kID1cbnN0cnVjdFxuICBsZXQgY29uY2F0X3JlZ3VsYXJfY2FsbGJhY2tzIGwxIGwyID1cbiAgICBiZWdpbiBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2VtcHR5LCBfIC0+IGwyXG4gICAgfCBfLCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHkgLT4gbDFcbiAgICB8IF8sIF8gLT4gUmVndWxhcl9jYWxsYmFja19saXN0X2NvbmNhdCAobDEsIGwyKVxuICAgIGVuZCBbQG9jYW1sLndhcm5pbmcgXCItNFwiXVxuXG4gIGxldCBjb25jYXRfY2FuY2VsX2NhbGxiYWNrcyBsMSBsMiA9XG4gICAgYmVnaW4gbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X2VtcHR5LCBfIC0+IGwyXG4gICAgfCBfLCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9lbXB0eSAtPiBsMVxuICAgIHwgXywgXyAtPiBDYW5jZWxfY2FsbGJhY2tfbGlzdF9jb25jYXQgKGwxLCBsMilcbiAgICBlbmQgW0BvY2FtbC53YXJuaW5nIFwiLTRcIl1cblxuICAoKiBJbiBhIGNhbGxiYWNrIGxpc3QsIGZpbHRlcnMgb3V0IGNlbGxzIG9mIGV4cGxpY2l0bHkgcmVtb3ZhYmxlIGNhbGxiYWNrc1xuICAgICB0aGF0IGhhdmUgYmVlbiByZW1vdmVkLiAqKVxuICBsZXQgcmVjIGNsZWFuX3VwX2NhbGxiYWNrX2NlbGxzID0gZnVuY3Rpb25cbiAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFjayB7Y29udGVudHMgPSBOb25lfSAtPlxuICAgICAgUmVndWxhcl9jYWxsYmFja19saXN0X2VtcHR5XG5cbiAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFjayB7Y29udGVudHMgPSBTb21lIF99XG4gICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIF9cbiAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9lbXB0eSBhcyBjYWxsYmFja3MgLT5cbiAgICAgIGNhbGxiYWNrc1xuXG4gICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfY29uY2F0IChsMSwgbDIpIC0+XG4gICAgICBsZXQgbDEgPSBjbGVhbl91cF9jYWxsYmFja19jZWxscyBsMSBpblxuICAgICAgbGV0IGwyID0gY2xlYW5fdXBfY2FsbGJhY2tfY2VsbHMgbDIgaW5cbiAgICAgIGNvbmNhdF9yZWd1bGFyX2NhbGxiYWNrcyBsMSBsMlxuXG4gICgqIFNlZSBbY2xlYXJfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfY2VsbF0gYW5kIFttZXJnZV9jYWxsYmFja3NdLiAqKVxuICBsZXQgY2xlYW51cF90aHJvdHRsZSA9IDQyXG5cbiAgKCogRXhwbGljaXRseSByZW1vdmFibGUgY2FsbGJhY2tzIGFyZSBhZGRlZCAobWFpbmx5KSBieSBbTHd0LmNob29zZV0gYW5kIGl0c1xuICAgICBzaW1pbGFyIGZ1bmN0aW9ucy4gSW4gW0x3dC5jaG9vc2UgW3A7IHAnXV0sIGlmIFtwJ10gcmVzb2x2ZXMgZmlyc3QsIHRoZVxuICAgICBjYWxsYmFjayBhZGRlZCBieSBbTHd0LmNob29zZV0gdG8gW3BdIGlzIHJlbW92ZWQuXG5cbiAgICAgVGhlIHJlbW92YWwgaXRzZWxmIGlzIGFjY29tcGxpc2hlZCB3aGVuIHRoaXMgZnVuY3Rpb24gY2xlYXJzIHRoZSByZWZlcmVuY2VcbiAgICAgY2VsbCBbY2VsbF0sIHdoaWNoIGNvbnRhaW5zIHRoZSByZWZlcmVuY2UgdG8gdGhhdCBjYWxsYmFjay5cblxuICAgICBJZiBbcF0gaXMgYSBsb25nLXBlbmRpbmcgcHJvbWlzZSB0aGF0IHJlcGVhdGVkbHkgcGFydGljaXBhdGVzIGluXG4gICAgIFtMd3QuY2hvb3NlXSwgcGVyaGFwcyBpbiBhIGxvb3AsIGl0IHdpbGwgYWNjdW11bGF0ZSBhIGxhcmdlIG51bWJlciBvZlxuICAgICBjbGVhcmVkIHJlZmVyZW5jZSBjZWxscyBpbiB0aGlzIGZhc2hpb24uIFRvIGF2b2lkIGEgbWVtb3J5IGxlYWssIHRoZXkgbXVzdFxuICAgICBiZSBjbGVhbmVkIHVwLiBIb3dldmVyLCB0aGUgY2VsbHMgYXJlIG5vdCBjbGVhbmVkIHVwIG9uICpldmVyeSogcmVtb3ZhbCxcbiAgICAgcHJlc3VtYWJseSBiZWNhdXNlIHNjYW5uaW5nIHRoZSBjYWxsYmFjayBsaXN0IHRoYXQgb2Z0ZW4sIGFuZCByZWJ1aWxkaW5nXG4gICAgIGl0LCBjYW4gZ2V0IGV4cGVuc2l2ZS5cblxuICAgICBDbGVhbnVwIGlzIHRocm90dGxlZCBieSBtYWludGFpbmluZyBhIGNvdW50ZXIsIFtjbGVhbnVwc19kZWZlcnJlZF0sIG9uIGVhY2hcbiAgICAgcGVuZGluZyBwcm9taXNlLiBUaGUgY291bnRlciBpcyBpbmNyZW1lbnRlZCBlYWNoIHRpbWUgdGhpcyBmdW5jdGlvbiB3YW50c1xuICAgICB0byBjbGVhbiB0aGUgY2FsbGJhY2sgbGlzdCAocmlnaHQgYWZ0ZXIgY2xlYXJpbmcgYSBjZWxsKS4gV2hlbiB0aGUgY291bnRlclxuICAgICByZWFjaGVzIFtjbGVhbnVwX3Rocm90dGxlXSwgdGhlIGNhbGxiYWNrIGxpc3QgaXMgYWN0dWFsbHkgc2Nhbm5lZCBhbmRcbiAgICAgY2xlYXJlZCBjYWxsYmFjayBjZWxscyBhcmUgcmVtb3ZlZC4gKilcbiAgbGV0IGNsZWFyX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2NlbGwgY2VsbCB+b3JpZ2luYWxseV9hZGRlZF90bzpwcyA9XG4gICAgY2VsbCA6PSBOb25lO1xuXG4gICAgKCogR28gdGhyb3VnaCB0aGUgcHJvbWlzZXMgdGhlIGNlbGwgaGFkIG9yaWdpbmFsbHkgYmVlbiBhZGRlZCB0bywgYW5kIGVpdGhlclxuICAgICAgIGRlZmVyIGEgY2xlYW51cCwgb3IgYWN0dWFsbHkgY2xlYW4gdXAgdGhlaXIgY2FsbGJhY2sgbGlzdHMuICopXG4gICAgcHMgfD4gTGlzdC5pdGVyIChmdW4gcCAtPlxuICAgICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICAgICgqIFNvbWUgb2YgdGhlIHByb21pc2VzIG1heSBhbHJlYWR5IGhhdmUgYmVlbiByZXNvbHZlZCBhdCB0aGUgdGltZSB0aGlzXG4gICAgICAgICBmdW5jdGlvbiBpcyBjYWxsZWQuICopXG4gICAgICB8IEZ1bGZpbGxlZCBfIC0+ICgpXG4gICAgICB8IFJlamVjdGVkIF8gLT4gKClcblxuICAgICAgfCBQZW5kaW5nIGNhbGxiYWNrcyAtPlxuICAgICAgICBtYXRjaCBjYWxsYmFja3MucmVndWxhcl9jYWxsYmFja3Mgd2l0aFxuICAgICAgICAoKiBJZiB0aGUgcHJvbWlzZSBoYXMgb25seSBvbmUgcmVndWxhciBjYWxsYmFjaywgYW5kIGl0IGlzIHJlbW92YWJsZSwgaXRcbiAgICAgICAgICAgbXVzdCBoYXZlIGJlZW4gdGhlIGNlbGwgY2xlYXJlZCBpbiB0aGlzIGZ1bmN0aW9uLCBhYm92ZS4gSW4gdGhhdFxuICAgICAgICAgICBjYXNlLCBqdXN0IHNldCBpdHMgY2FsbGJhY2sgbGlzdCB0byBlbXB0eS4gKilcbiAgICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2sgXyAtPlxuICAgICAgICAgIGNhbGxiYWNrcy5yZWd1bGFyX2NhbGxiYWNrcyA8LSBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHlcblxuICAgICAgICAoKiBNYWludGFpbmVyJ3Mgbm90ZTogSSB0aGluayB0aGlzIGZ1bmN0aW9uIHNob3VsZG4ndCB0cnkgdG8gdHJpZ2dlciBhXG4gICAgICAgICAgIGNsZWFudXAgaW4gdGhlIGZpcnN0IHR3byBjYXNlcywgYnV0IEkgYW0gcHJlc2VydmluZyB0aGVtIGZvciBub3csIGFzXG4gICAgICAgICAgIHRoaXMgaXMgaG93IHRoZSBjb2RlIHdhcyB3cml0dGVuIGluIHRoZSBwYXN0LiAqKVxuICAgICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9lbXB0eVxuICAgICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgX1xuICAgICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9jb25jYXQgXyAtPlxuICAgICAgICAgIGxldCBjbGVhbnVwc19kZWZlcnJlZCA9IGNhbGxiYWNrcy5jbGVhbnVwc19kZWZlcnJlZCArIDEgaW5cbiAgICAgICAgICBpZiBjbGVhbnVwc19kZWZlcnJlZCA+IGNsZWFudXBfdGhyb3R0bGUgdGhlbiBiZWdpblxuICAgICAgICAgICAgY2FsbGJhY2tzLmNsZWFudXBzX2RlZmVycmVkIDwtIDA7XG4gICAgICAgICAgICBjYWxsYmFja3MucmVndWxhcl9jYWxsYmFja3MgPC1cbiAgICAgICAgICAgICAgY2xlYW5fdXBfY2FsbGJhY2tfY2VsbHMgY2FsbGJhY2tzLnJlZ3VsYXJfY2FsbGJhY2tzXG4gICAgICAgICAgZW5kIGVsc2VcbiAgICAgICAgICAgIGNhbGxiYWNrcy5jbGVhbnVwc19kZWZlcnJlZCA8LSBjbGVhbnVwc19kZWZlcnJlZClcblxuICAoKiBDb25jYXRlbmF0ZXMgYm90aCBraW5kcyBvZiBjYWxsYmFja3Mgb24gW35mcm9tXSB0byB0aGUgY29ycmVzcG9uZGluZyBsaXN0c1xuICAgICBvZiBbfmludG9dLiBUaGUgY2FsbGJhY2sgbGlzdHMgb24gW35mcm9tXSBhcmUgKm5vdCogdGhlbiBjbGVhcmVkLCBiZWNhdXNlXG4gICAgIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgYnkgW1NlcXVlbnRpYWxfY29tcG9zaXRpb24ubWFrZV9pbnRvX3Byb3h5XSxcbiAgICAgd2hpY2ggaW1tZWRpYXRlbHkgY2hhbmdlcyB0aGUgc3RhdGUgb2YgW35mcm9tXSBhbmQgbG9zZXMgcmVmZXJlbmNlcyB0byB0aGVcbiAgICAgb3JpZ2luYWwgY2FsbGJhY2sgbGlzdHMuXG5cbiAgICAgVGhlIFtjbGVhbnVwc19kZWZlcnJlZF0gZmllbGRzIG9mIGJvdGggcHJvbWlzZXMgYXJlIHN1bW1lZCwgYW5kIGlmIHRoZSBzdW1cbiAgICAgZXhjZWVkcyBbY2xlYW51cF90aHJvdHRsZV0sIGEgY2xlYW51cCBvZiByZWd1bGFyIGNhbGxiYWNrcyBpcyB0cmlnZ2VyZWQuXG4gICAgIFRoaXMgaXMgdG8gcHJldmVudCBtZW1vcnkgbGVha3M7IHNlZVxuICAgICBbY2xlYXJfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfY2VsbF0uICopXG4gIGxldCBtZXJnZV9jYWxsYmFja3MgfmZyb20gfmludG8gPVxuICAgIGxldCByZWd1bGFyX2NhbGxiYWNrcyA9XG4gICAgICBjb25jYXRfcmVndWxhcl9jYWxsYmFja3MgaW50by5yZWd1bGFyX2NhbGxiYWNrcyBmcm9tLnJlZ3VsYXJfY2FsbGJhY2tzIGluXG4gICAgbGV0IGNsZWFudXBzX2RlZmVycmVkID0gaW50by5jbGVhbnVwc19kZWZlcnJlZCArIGZyb20uY2xlYW51cHNfZGVmZXJyZWQgaW5cblxuICAgIGxldCByZWd1bGFyX2NhbGxiYWNrcywgY2xlYW51cHNfZGVmZXJyZWQgPVxuICAgICAgaWYgY2xlYW51cHNfZGVmZXJyZWQgPiBjbGVhbnVwX3Rocm90dGxlIHRoZW5cbiAgICAgICAgY2xlYW5fdXBfY2FsbGJhY2tfY2VsbHMgcmVndWxhcl9jYWxsYmFja3MsIDBcbiAgICAgIGVsc2VcbiAgICAgICAgcmVndWxhcl9jYWxsYmFja3MsIGNsZWFudXBzX2RlZmVycmVkXG4gICAgaW5cblxuICAgIGxldCBjYW5jZWxfY2FsbGJhY2tzID1cbiAgICAgIGNvbmNhdF9jYW5jZWxfY2FsbGJhY2tzIGludG8uY2FuY2VsX2NhbGxiYWNrcyBmcm9tLmNhbmNlbF9jYWxsYmFja3MgaW5cblxuICAgIGludG8ucmVndWxhcl9jYWxsYmFja3MgPC0gcmVndWxhcl9jYWxsYmFja3M7XG4gICAgaW50by5jYW5jZWxfY2FsbGJhY2tzIDwtIGNhbmNlbF9jYWxsYmFja3M7XG4gICAgaW50by5jbGVhbnVwc19kZWZlcnJlZCA8LSBjbGVhbnVwc19kZWZlcnJlZFxuXG5cblxuICAoKiBHZW5lcmFsLCBpbnRlcm5hbCwgZnVuY3Rpb24gZm9yIGFkZGluZyBhIHJlZ3VsYXIgY2FsbGJhY2suICopXG4gIGxldCBhZGRfcmVndWxhcl9jYWxsYmFja19saXN0X25vZGUgY2FsbGJhY2tzIG5vZGUgPVxuICAgIGNhbGxiYWNrcy5yZWd1bGFyX2NhbGxiYWNrcyA8LVxuICAgICAgbWF0Y2ggY2FsbGJhY2tzLnJlZ3VsYXJfY2FsbGJhY2tzIHdpdGhcbiAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2VtcHR5IC0+XG4gICAgICAgIG5vZGVcbiAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBfXG4gICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFjayBfXG4gICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9jb25jYXQgXyBhcyBleGlzdGluZyAtPlxuICAgICAgICBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfY29uY2F0IChub2RlLCBleGlzdGluZylcblxuICBsZXQgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBjYWxsYmFja3MgZiA9XG4gICAgYWRkX3JlZ3VsYXJfY2FsbGJhY2tfbGlzdF9ub2RlXG4gICAgICBjYWxsYmFja3MgKFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgZilcblxuICAoKiBBZGRzIFtjYWxsYmFja10gYXMgcmVtb3ZhYmxlIHRvIGVhY2ggcHJvbWlzZSBpbiBbcHNdLiBUaGUgZmlyc3QgcHJvbWlzZSBpblxuICAgICBbcHNdIHRvIHRyaWdnZXIgW2NhbGxiYWNrXSByZW1vdmVzIFtjYWxsYmFja10gZnJvbSB0aGUgb3RoZXIgcHJvbWlzZXM7IHRoaXNcbiAgICAgZ3VhcmFudGVlcyB0aGF0IFtjYWxsYmFja10gaXMgY2FsbGVkIGF0IG1vc3Qgb25jZS4gQWxsIHRoZSBwcm9taXNlcyBpbiBbcHNdXG4gICAgIG11c3QgYmUgcGVuZGluZy5cblxuICAgICBUaGlzIGlzIGFuIGludGVybmFsIGZ1bmN0aW9uLCBpbmRpcmVjdGx5IHVzZWQgYnkgdGhlIGltcGxlbWVudGF0aW9ucyBvZlxuICAgICBbTHd0LmNob29zZV0gYW5kIHJlbGF0ZWQgZnVuY3Rpb25zLiAqKVxuICBsZXQgYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2FuZF9naXZlX2NlbGwgcHMgZiA9XG4gICAgbGV0IHJlYyBjZWxsID0gcmVmIChTb21lIHNlbGZfcmVtb3ZpbmdfY2FsbGJhY2tfd3JhcHBlcilcbiAgICBhbmQgc2VsZl9yZW1vdmluZ19jYWxsYmFja193cmFwcGVyIHJlc3VsdCA9XG4gICAgICBjbGVhcl9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja19jZWxsIGNlbGwgfm9yaWdpbmFsbHlfYWRkZWRfdG86cHM7XG4gICAgICBmIHJlc3VsdFxuICAgIGluXG5cbiAgICBsZXQgbm9kZSA9IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFjayBjZWxsIGluXG4gICAgcHMgfD4gTGlzdC5pdGVyIChmdW4gcCAtPlxuICAgICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICAgIHwgUGVuZGluZyBjYWxsYmFja3MgLT4gYWRkX3JlZ3VsYXJfY2FsbGJhY2tfbGlzdF9ub2RlIGNhbGxiYWNrcyBub2RlXG4gICAgICB8IEZ1bGZpbGxlZCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBSZWplY3RlZCBfIC0+IGFzc2VydCBmYWxzZSk7XG5cbiAgICBjZWxsXG5cbiAgbGV0IGFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja190b19lYWNoX29mIHBzIGYgPVxuICAgIGlnbm9yZSAoYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2FuZF9naXZlX2NlbGwgcHMgZilcblxuICAoKiBUaGlzIGlzIGJhc2ljYWxseSBqdXN0IHRvIHN1cHBvcnQgW0x3dC5wcm90ZWN0ZWRdLCB3aGljaCBuZWVkcyB0byByZW1vdmVcbiAgICAgdGhlIGNhbGxiYWNrIGluIGNpcmN1bXN0YW5jZXMgb3RoZXIgdGhhbiB0aGUgY2FsbGJhY2sgYmVpbmcgY2FsbGVkLiAqKVxuICBsZXQgYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2FuZF9naXZlX3JlbW92ZV9mdW5jdGlvbiBwcyBmID1cbiAgICBsZXQgY2VsbCA9IGFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja19hbmRfZ2l2ZV9jZWxsIHBzIGYgaW5cbiAgICBmdW4gKCkgLT5cbiAgICAgIGNsZWFyX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2NlbGwgY2VsbCB+b3JpZ2luYWxseV9hZGRlZF90bzpwc1xuXG4gIGxldCBhZGRfY2FuY2VsX2NhbGxiYWNrIGNhbGxiYWNrcyBmID1cbiAgICBsZXQgbm9kZSA9IENhbmNlbF9jYWxsYmFja19saXN0X2NhbGxiYWNrICghY3VycmVudF9zdG9yYWdlLCBmKSBpblxuXG4gICAgY2FsbGJhY2tzLmNhbmNlbF9jYWxsYmFja3MgPC1cbiAgICAgIG1hdGNoIGNhbGxiYWNrcy5jYW5jZWxfY2FsbGJhY2tzIHdpdGhcbiAgICAgIHwgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfZW1wdHkgLT5cbiAgICAgICAgbm9kZVxuXG4gICAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X2NhbGxiYWNrIF9cbiAgICAgIHwgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfcmVtb3ZlX3NlcXVlbmNlX25vZGUgX1xuICAgICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9jb25jYXQgXyAtPlxuICAgICAgICBDYW5jZWxfY2FsbGJhY2tfbGlzdF9jb25jYXQgKG5vZGUsIGNhbGxiYWNrcy5jYW5jZWxfY2FsbGJhY2tzKVxuZW5kXG5vcGVuIFBlbmRpbmdfY2FsbGJhY2tzXG5cblxuXG5tb2R1bGUgUmVzb2x1dGlvbl9sb29wIDpcbnNpZ1xuICAoKiBBbGwgdXNlci1wcm92aWRlZCBjYWxsYmFja3MgYXJlIGNhbGxlZCBieSBMd3Qgb25seSB0aHJvdWdoIHRoaXMgbW9kdWxlLiBJdFxuICAgICB0cmFja3MgdGhlIGN1cnJlbnQgY2FsbGJhY2sgc3RhY2sgZGVwdGgsIGFuZCBkZWNpZGVzIHdoZXRoZXIgZWFjaCBjYWxsYmFja1xuICAgICBjYWxsIHNob3VsZCBiZSBkZWZlcnJlZCBvciBub3QuICopXG5cbiAgKCogSW50ZXJuYWwgaW50ZXJmYWNlIHVzZWQgb25seSBpbiB0aGlzIG1vZHVsZSBMd3QgKilcbiAgdmFsIHJlc29sdmUgOlxuICAgID9hbGxvd19kZWZlcnJpbmc6Ym9vbCAtPlxuICAgID9tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGg6aW50IC0+XG4gICAgKCdhLCB1bmRlcmx5aW5nLCBwZW5kaW5nKSBwcm9taXNlIC0+XG4gICAgJ2EgcmVzb2x2ZWRfc3RhdGUgLT5cbiAgICAgICgnYSwgdW5kZXJseWluZywgcmVzb2x2ZWQpIHN0YXRlX2NoYW5nZWRcblxuICB2YWwgcnVuX2NhbGxiYWNrc19vcl9kZWZlcl90aGVtIDpcbiAgICA/YWxsb3dfZGVmZXJyaW5nOmJvb2wgLT5cbiAgICA/bWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoOmludCAtPlxuICAgICgnYSBjYWxsYmFja3MpIC0+XG4gICAgJ2EgcmVzb2x2ZWRfc3RhdGUgLT5cbiAgICAgIHVuaXRcblxuICB2YWwgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0IDpcbiAgICA/cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOmJvb2wgLT5cbiAgICBjYWxsYmFjazoodW5pdCAtPiAnYSkgLT5cbiAgICBpZl9kZWZlcnJlZDoodW5pdCAtPiAnYSAqICdiIHJlZ3VsYXJfY2FsbGJhY2sgKiAnYiByZXNvbHZlZF9zdGF0ZSkgLT5cbiAgICAgICdhXG5cbiAgdmFsIGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIDogKCdhIC0+IHVuaXQpIC0+ICdhIC0+IHVuaXRcblxuICAoKiBJbnRlcm5hbCBpbnRlcmZhY2UgZXhwb3NlZCB0byBvdGhlciBtb2R1bGVzIGluIEx3dCAqKVxuICB2YWwgYWJhbmRvbl93YWtldXBzIDogdW5pdCAtPiB1bml0XG5cbiAgKCogUHVibGljIGludGVyZmFjZSAqKVxuICBleGNlcHRpb24gQ2FuY2VsZWRcblxuICB2YWwgYXN5bmNfZXhjZXB0aW9uX2hvb2sgOiAoZXhuIC0+IHVuaXQpIHJlZlxuZW5kID1cbnN0cnVjdFxuICAoKiBXaGVuIEx3dCBuZWVkcyB0byBjYWxsIGEgY2FsbGJhY2ssIGl0IGVudGVycyB0aGUgcmVzb2x1dGlvbiBsb29wLiBUaGlzXG4gICAgIHR5cGljYWxseSBoYXBwZW5zIHdoZW4gTHd0IHNldHMgdGhlIHN0YXRlIG9mIG9uZSBwcm9taXNlIHRvIFtGdWxmaWxsZWQgX11cbiAgICAgb3IgW1JlamVjdGVkIF9dLiBUaGUgY2FsbGJhY2tzIHRoYXQgd2VyZSBhdHRhY2hlZCB0byB0aGUgcHJvbWlzZSB3aGVuIGl0XG4gICAgIHdhcyBwZW5kaW5nIG11c3QgdGhlbiBiZSBjYWxsZWQuXG5cbiAgICAgVGhpcyBhbHNvIGhhcHBlbnMgaW4gYSBmZXcgb3RoZXIgc2l0dWF0aW9ucy4gRm9yIGV4YW1wbGUsIHdoZW4gW0x3dC5iaW5kXVxuICAgICBpcyBjYWxsZWQgb24gYSBwcm9taXNlLCBidXQgdGhhdCBwcm9taXNlIGlzIGFscmVhZHkgcmVzb2x2ZWQsIHRoZSBjYWxsYmFja1xuICAgICBwYXNzZWQgdG8gW2JpbmRdIG11c3QgYmUgY2FsbGVkLlxuXG4gICAgIFRoZSBjYWxsYmFja3MgdHJpZ2dlcmVkIGR1cmluZyB0aGUgcmVzb2x1dGlvbiBsb29wIG1pZ2h0IHJlc29sdmUgbW9yZVxuICAgICBwcm9taXNlcywgdHJpZ2dlcmluZyBtb3JlIGNhbGxiYWNrcywgYW5kIHNvIG9uLiBUaGlzIGlzIHdoYXQgbWFrZXMgdGhlXG4gICAgIHJlc29sdXRpb24gbG9vcCBhIHtlIGxvb3B9LlxuXG4gICAgIEx3dCBnZW5lcmFsbHkgdHJpZXMgdG8gY2FsbCBlYWNoIGNhbGxiYWNrIGltbWVkaWF0ZWx5LiBIb3dldmVyLCB0aGlzIGNhblxuICAgICBsZWFkIHRvIGEgcHJvZ3Jlc3NpdmUgZGVlcGVuaW5nIG9mIHRoZSBjYWxsIHN0YWNrLCB1bnRpbCB0aGVyZSBpcyBhIHN0YWNrXG4gICAgIG92ZXJmbG93LiBUaGlzIGNhbid0IGJlIGF2b2lkZWQgYnkgZG9pbmcgdGFpbCBjYWxscywgYmVjYXVzZSBMd3QgYWx3YXlzXG4gICAgIG5lZWRzIHRvIGRvIGV4Y2VwdGlvbiBoYW5kbGluZyBhcm91bmQgY2FsbGJhY2tzIGNhbGxzOiBlYWNoIGNhbGxiYWNrIGNhbGxcbiAgICAgaXMgZm9sbG93ZWQgYnkgYW4gZXhjZXB0aW9uIGhhbmRsZXIuIEluc3RlYWQsIHdoYXQgTHd0IGRvZXMgaXMgdHJhY2sgdGhlXG4gICAgIGN1cnJlbnQgY2FsbGJhY2sgY2FsbCBkZXB0aC4gT25jZSB0aGF0IGRlcHRoIHJlYWNoZXMgYSBjZXJ0YWluIG51bWJlcixcbiAgICAgW2RlZmF1bHRfbWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoXSwgZGVmaW5lZCBiZWxvdywgZnVydGhlciBjYWxsYmFja3NcbiAgICAgYXJlIGRlZmVycmVkIGludG8gYSBxdWV1ZSBpbnN0ZWFkLiBUaGF0IHF1ZXVlIGlzIGRyYWluZWQgd2hlbiBMd3QgZXhpdHNcbiAgICAgZnJvbSB0aGUgdG9wLW1vc3QgY2FsbGJhY2sgY2FsbCB0aGF0IHRyaWdnZXJlZCB0aGUgcmVzb2x1dGlvbiBsb29wIGluIHRoZVxuICAgICBmaXJzdCBwbGFjZS5cblxuICAgICBUbyBlbnN1cmUgdGhhdCB0aGlzIGRlZmVycmFsIG1lY2hhbmlzbSBpcyBhbHdheXMgcHJvcGVybHkgaW52b2tlZCwgYWxsXG4gICAgIGNhbGxiYWNrcyBjYWxsZWQgYnkgTHd0IGFyZSBjYWxsZWQgdGhyb3VnaCBvbmUgb2YgdGhyZWUgZnVuY3Rpb25zIHByb3ZpZGVkXG4gICAgIGJ5IHRoaXMgbW9kdWxlOlxuXG4gICAgIC0gW3Jlc29sdmVdLCB3aGljaCBjYWxscyBhbGwgdGhlIGNhbGxiYWNrcyBhc3NvY2lhdGVkIHRvIGEgcGVuZGluZyBwcm9taXNlXG4gICAgICAgKGFuZCByZXNvbHZlcyBpdCwgY2hhbmdpbmcgaXRzIHN0YXRlKS5cbiAgICAgLSBbcnVuX2NhbGxiYWNrc19vcl9kZWZlcl90aGVtXSwgd2hpY2ggaXMgaW50ZXJuYWxseSB1c2VkIGJ5IFtyZXNvbHZlXSB0b1xuICAgICAgIGNhbGwgY2FsbGJhY2tzIHRoYXQgYXJlIGluIGEgcmVjb3JkIG9mIHR5cGUgWydhIGNhbGxiYWNrc10sIHdoaWNoIHJlY29yZHNcbiAgICAgICBhcmUgYXNzb2NpYXRlZCB3aXRoIHBlbmRpbmcgcHJvbWlzZXMuIFRoaXMgZnVuY3Rpb24gaXMgZXhwb3NlZCBiZWNhdXNlXG4gICAgICAgdGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgW0x3dC5jYW5jZWxdIG5lZWRzIHRvIGNhbGwgaXQgZGlyZWN0bHkuXG4gICAgICAgUHJvbWlzZSByZXNvbHV0aW9uIGFuZCBjYWxsYmFjayBjYWxsaW5nIGFyZSBzZXBhcmF0ZWQgaW4gYSB1bmlxdWUgd2F5IGluXG4gICAgICAgW2NhbmNlbF0uXG4gICAgIC0gW3J1bl9jYWxsYmFja19vcl9kZWZlcl9pdF0sIHdoaWNoIGlzIHVzZWQgYnkgW0x3dC5iaW5kXSBhbmQgc2ltaWxhclxuICAgICAgIGZ1bmN0aW9ucyB0byBjYWxsIHNpbmdsZSBjYWxsYmFja3Mgd2hlbiB0aGUgcHJvbWlzZXMgcGFzc2VkIHRvXG4gICAgICAgW0x3dC5iaW5kXSwgZXRjLiwgYXJlIGFscmVhZHkgcmVzb2x2ZWQuXG5cbiAgICAgQ3VycmVudCBMd3QgYWN0dWFsbHkgaGFzIGEgbWVzc3kgbWl4IG9mIGNhbGxiYWNrLWNhbGxpbmcgYmVoYXZpb3JzLiBGb3JcbiAgICAgZXhhbXBsZSwgW0x3dC5iaW5kXSBpcyBleHBlY3RlZCB0byBhbHdheXMgY2FsbCBpdHMgY2FsbGJhY2sgaW1tZWRpYXRlbHksXG4gICAgIHdoaWxlIFtMd3Qud2FrZXVwX2xhdGVyXSBpcyBleHBlY3RlZCB0byBkZWZlciBhbGwgY2FsbGJhY2tzIG9mIHRoZSBwcm9taXNlXG4gICAgIHJlc29sdmVkLCB7ZSB1bmxlc3N9IEx3dCBpcyBub3QgYWxyZWFkeSBpbnNpZGUgdGhlIHJlc29sdXRpb24gbG9vcC5cblxuICAgICBXZSBwbGFubmVkIHRvIG1ha2UgdGhlc2UgYmVoYXZpb3JzIHVuaWZvcm0gaW4gTHd0IDQuMC4wLCBidXQgZGVjaWRlZFxuICAgICBhZ2FpbnN0IGl0IGR1ZSB0byB0aGUgcmlzayBvZiBicmVha2luZyB1c2Vycy4gU2VlXG5cbiAgICAgLSBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvcHVsbC81MDBcbiAgICAgLSBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvcHVsbC81MTlcblxuICAgICBBcyBwYXJ0IG9mIHRoZSBwcmVwYXJhdGlvbiBmb3IgdGhlIGNoYW5nZSwgdGhlIGFib3ZlIGNhbGxiYWNrLWludm9raW5nXG4gICAgIGZ1bmN0aW9ucyBzdXBwb3J0IHNldmVyYWwgb3B0aW9uYWwgYXJndW1lbnRzIHRvIGVtdWxhdGUgdGhlIHZhcmlvdXNcbiAgICAgYmVoYXZpb3JzLiBXZSBkZWNpZGVkIG5vdCB0byByZW1vdmUgdGhpcyBtYWNoaW5lcnksIGJlY2F1c2Ugd2UgbWlnaHQgd2FudFxuICAgICB0byBleHBvc2UgZGlmZmVyZW50IEFQSXMgdG8gTHd0IGluIHRoZSBmdXR1cmUuXG5cbiAgICAgLSBbfmFsbG93X2RlZmVycmluZzpmYWxzZV0gYWxsb3dzIGlnbm9yaW5nIHRoZSBjYWxsYmFjayBzdGFjayBkZXB0aCwgYW5kXG4gICAgICAgY2FsbGluZyB0aGUgY2FsbGJhY2tzIGltbWVkaWF0ZWx5LiBUaGlzIGVtdWxhdGVzIHRoZSBvbGQgcmVzb2x1dGlvblxuICAgICAgIGJlaGF2aW9yLlxuICAgICAtIFt+bWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoOjFdIGFsbG93cyBsaW1pdGluZyB0aGUgZGVwdGggd2hpY2hcbiAgICAgICB0cmlnZ2VycyBkZWZlcnJhbCBvbiBhIHBlci1jYWxsLXNpdGUgYmFzaXMuIFRoaXMgaXMgdXNlZCBieVxuICAgICAgIFtMd3Qud2FrZXVwX2xhdGVyXS5cbiAgICAgLSBbfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXSBpcyBsaWtlXG4gICAgICAgW35hbGxvd19kZWZlcnJpbmc6ZmFsc2VdLCB3aGljaCBpZ25vcmVzIHRoZSBjYWxsYmFjayBzdGFjayBkZXB0aC5cbiAgICAgICBIb3dldmVyLCB0byBlbnN1cmUgdGhhdCB0aGUgY2FsbGJhY2sgaXMgdGFpbC1jYWxsZWQsIEx3dCBkb2Vzbid0IGV2ZW5cbiAgICAgICB1cGRhdGUgdGhlIGNhbGxiYWNrIHN0YWNrIGRlcHRoIGZvciB0aGUgYmVuZWZpdCBvZiAqb3RoZXIqIGNhbGxiYWNrXG4gICAgICAgY2FsbHMuIEl0IGp1c3QgYmxpbmRseSBjYWxscyB0aGUgY2FsbGJhY2suXG5cbiAgICAgU2VlIGRpc2N1c3Npb24gb2YgY2FsbGJhY2stY2FsbGluZyBzZW1hbnRpY3MgaW46XG5cbiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvaXNzdWVzLzMyOVxuXG4gICAgICogQ29udGV4dFxuXG4gICAgIFRoZSByZXNvbHV0aW9uIGxvb3AgZWZmZWN0aXZlbHkgaGFuZGxlcyBhbGwgcHJvbWlzZXMgdGhhdCBjYW4gYmUgcmVzb2x2ZWRcbiAgICAgaW1tZWRpYXRlbHksIHdpdGhvdXQgYmxvY2tpbmcgb24gSS9PLiBBIGNvbXBsZXRlIHByb2dyYW0gdGhhdCBkb2VzIEkvT1xuICAgICBjYWxscyBbTHd0X21haW4ucnVuXS4gU2VlIFwiTm8gSS9PXCIgaW4gdGhlIE92ZXJ2aWV3LiAqKVxuXG5cblxuICBsZXQgYXN5bmNfZXhjZXB0aW9uX2hvb2sgPVxuICAgIHJlZiAoZnVuIGV4biAtPlxuICAgICAgcHJlcnJfc3RyaW5nIFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiBcIjtcbiAgICAgIHByZXJyX3N0cmluZyAoUHJpbnRleGMudG9fc3RyaW5nIGV4bik7XG4gICAgICBwcmVycl9jaGFyICdcXG4nO1xuICAgICAgUHJpbnRleGMucHJpbnRfYmFja3RyYWNlIHN0ZGVycjtcbiAgICAgIGZsdXNoIHN0ZGVycjtcbiAgICAgIGV4aXQgMilcblxuICBsZXQgaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiB2ID1cbiAgICAoKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBjYXJlIGlmIFtmXSBldmFsdWF0ZXMgdG8gYSBwcm9taXNlLiBJblxuICAgICAgIHBhcnRpY3VsYXIsIGlmIFtmIHZdIGV2YWx1YXRlcyB0byBbcF0gYW5kIFtwXSBpcyBhbHJlYWR5IHJlamVjdGVkIG9yIHdpbGxcbiAgICAgICBiZSByZWplY3QgbGF0ZXIsIGl0IGlzIG5vdCB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhpcyBmdW5jdGlvbiB0byBwYXNzXG4gICAgICAgdGhlIGV4Y2VwdGlvbiB0byBbIWFzeW5jX2V4Y2VwdGlvbl9ob29rXS4gKilcbiAgICB0cnkgZiB2XG4gICAgd2l0aCBleG4gLT4gIWFzeW5jX2V4Y2VwdGlvbl9ob29rIGV4blxuXG5cblxuICBleGNlcHRpb24gQ2FuY2VsZWRcblxuXG5cbiAgKCogUnVucyB0aGUgY2FsbGJhY2tzIChmb3JtZXJseSkgYXNzb2NpYXRlZCB0byBhIHByb21pc2UuIENhbmNlbCBjYWxsYmFja3MgYXJlXG4gICAgIHJ1biBmaXJzdCwgaWYgdGhlIHByb21pc2Ugd2FzIGNhbmNlbGVkLiBUaGVzZSBhcmUgZm9sbG93ZWQgYnkgcmVndWxhclxuICAgICBjYWxsYmFja3MuXG5cbiAgICAgVGhlIHJlYXNvbiBmb3IgdGhlIFwiZm9ybWVybHlcIiBpcyB0aGF0IHRoZSBwcm9taXNlJ3Mgc3RhdGUgaGFzIGFscmVhZHkgYmVlblxuICAgICBzZXQgdG8gW0Z1bGZpbGxlZCBfXSBvciBbUmVqZWN0ZWQgX10sIHNvIHRoZSBjYWxsYmFja3MgYXJlIG5vIGxvbmdlclxuICAgICByZWFjaGFibGUgdGhyb3VnaCB0aGUgcHJvbWlzZSByZWZlcmVuY2UuIFRoaXMgaXMgd2h5IHRoZSBkaXJlY3QgW2NhbGxiYWNrc11cbiAgICAgcmVjb3JkIG11c3QgYmUgZ2l2ZW4gdG8gdGhpcyBmdW5jdGlvbi4gKilcbiAgbGV0IHJ1bl9jYWxsYmFja3NcbiAgICAgIChjYWxsYmFja3MgOiAnYSBjYWxsYmFja3MpXG4gICAgICAocmVzdWx0IDogJ2EgcmVzb2x2ZWRfc3RhdGUpIDogdW5pdCA9XG5cbiAgICBsZXQgcnVuX2NhbmNlbF9jYWxsYmFja3MgZnMgPVxuICAgICAgbGV0IHJlYyBpdGVyX2NhbGxiYWNrX2xpc3QgZnMgcmVzdCA9XG4gICAgICAgIG1hdGNoIGZzIHdpdGhcbiAgICAgICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9lbXB0eSAtPlxuICAgICAgICAgIGl0ZXJfbGlzdCByZXN0XG4gICAgICAgIHwgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfY2FsbGJhY2sgKHN0b3JhZ2UsIGYpIC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHN0b3JhZ2U7XG4gICAgICAgICAgaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiAoKTtcbiAgICAgICAgICBpdGVyX2xpc3QgcmVzdFxuICAgICAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X3JlbW92ZV9zZXF1ZW5jZV9ub2RlIG5vZGUgLT5cbiAgICAgICAgICBMd3Rfc2VxdWVuY2UucmVtb3ZlIG5vZGU7XG4gICAgICAgICAgaXRlcl9saXN0IHJlc3RcbiAgICAgICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9jb25jYXQgKGZzLCBmcycpIC0+XG4gICAgICAgICAgaXRlcl9jYWxsYmFja19saXN0IGZzIChmcyc6OnJlc3QpXG5cbiAgICAgIGFuZCBpdGVyX2xpc3QgcmVzdCA9XG4gICAgICAgIG1hdGNoIHJlc3Qgd2l0aFxuICAgICAgICB8IFtdIC0+ICgpXG4gICAgICAgIHwgZnM6OnJlc3QgLT4gaXRlcl9jYWxsYmFja19saXN0IGZzIHJlc3RcblxuICAgICAgaW5cblxuICAgICAgaXRlcl9jYWxsYmFja19saXN0IGZzIFtdXG4gICAgaW5cblxuICAgIGxldCBydW5fcmVndWxhcl9jYWxsYmFja3MgZnMgPVxuICAgICAgbGV0IHJlYyBpdGVyX2NhbGxiYWNrX2xpc3QgZnMgcmVzdCA9XG4gICAgICAgIG1hdGNoIGZzIHdpdGhcbiAgICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHkgLT5cbiAgICAgICAgICBpdGVyX2xpc3QgcmVzdFxuICAgICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgZiAtPlxuICAgICAgICAgIGYgcmVzdWx0O1xuICAgICAgICAgIGl0ZXJfbGlzdCByZXN0XG4gICAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrXG4gICAgICAgICAgICB7Y29udGVudHMgPSBOb25lfSAtPlxuICAgICAgICAgIGl0ZXJfbGlzdCByZXN0XG4gICAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrXG4gICAgICAgICAgICB7Y29udGVudHMgPSBTb21lIGZ9IC0+XG4gICAgICAgICAgZiByZXN1bHQ7XG4gICAgICAgICAgaXRlcl9saXN0IHJlc3RcbiAgICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfY29uY2F0IChmcywgZnMnKSAtPlxuICAgICAgICAgIGl0ZXJfY2FsbGJhY2tfbGlzdCBmcyAoZnMnOjpyZXN0KVxuXG4gICAgICBhbmQgaXRlcl9saXN0IHJlc3QgPVxuICAgICAgICBtYXRjaCByZXN0IHdpdGhcbiAgICAgICAgfCBbXSAtPiAoKVxuICAgICAgICB8IGZzOjpyZXN0IC0+IGl0ZXJfY2FsbGJhY2tfbGlzdCBmcyByZXN0XG5cbiAgICAgIGluXG5cbiAgICAgIGl0ZXJfY2FsbGJhY2tfbGlzdCBmcyBbXVxuICAgIGluXG5cbiAgICAoKiBQYXR0ZXJuIG1hdGNoaW5nIGlzIG11Y2ggZmFzdGVyIHRoYW4gcG9seW1vcnBoaWMgY29tcGFyaXNvbi4gKilcbiAgICBsZXQgaXNfY2FuY2VsZWQgPVxuICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgIHwgUmVqZWN0ZWQgQ2FuY2VsZWQgLT4gdHJ1ZVxuICAgICAgfCBSZWplY3RlZCBfIC0+IGZhbHNlXG4gICAgICB8IEZ1bGZpbGxlZCBfIC0+IGZhbHNlXG4gICAgaW5cbiAgICBpZiBpc19jYW5jZWxlZCB0aGVuXG4gICAgICBydW5fY2FuY2VsX2NhbGxiYWNrcyBjYWxsYmFja3MuY2FuY2VsX2NhbGxiYWNrcztcbiAgICBydW5fcmVndWxhcl9jYWxsYmFja3MgY2FsbGJhY2tzLnJlZ3VsYXJfY2FsbGJhY2tzXG5cblxuXG4gIGxldCBkZWZhdWx0X21heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aCA9IDQyXG5cbiAgbGV0IGN1cnJlbnRfY2FsbGJhY2tfbmVzdGluZ19kZXB0aCA9IHJlZiAwXG5cbiAgdHlwZSBkZWZlcnJlZF9jYWxsYmFja3MgPVxuICAgIERlZmVycmVkIDogKCdhIGNhbGxiYWNrcyAqICdhIHJlc29sdmVkX3N0YXRlKSAtPiBkZWZlcnJlZF9jYWxsYmFja3NcbiAgICBbQEBvY2FtbC51bmJveGVkXVxuXG4gIGxldCBkZWZlcnJlZF9jYWxsYmFja3MgOiBkZWZlcnJlZF9jYWxsYmFja3MgUXVldWUudCA9IFF1ZXVlLmNyZWF0ZSAoKVxuXG4gICgqIEJlZm9yZSBlbnRlcmluZyBhIHJlc29sdXRpb24gbG9vcCwgaXQgaXMgbmVjZXNzYXJ5IHRvIHRha2UgYSBzbmFwc2hvdCBvZlxuICAgICB0aGUgY3VycmVudCBzdGF0ZSBvZiBzZXF1ZW5jZS1hc3NvY2lhdGVkIHN0b3JhZ2UuIFRoaXMgaXMgYmVjYXVzZSBtYW55IG9mXG4gICAgIHRoZSBjYWxsYmFja3MgdGhhdCB3aWxsIGJlIHJ1biB3aWxsIG1vZGlmeSB0aGUgc3RvcmFnZS4gVGhlIHN0b3JhZ2UgaXNcbiAgICAgcmVzdG9yZWQgdG8gdGhlIHNuYXBzaG90IHdoZW4gdGhlIHJlc29sdXRpb24gbG9vcCBpcyBleGl0ZWQuICopXG4gIGxldCBlbnRlcl9yZXNvbHV0aW9uX2xvb3AgKCkgPVxuICAgIGN1cnJlbnRfY2FsbGJhY2tfbmVzdGluZ19kZXB0aCA6PSAhY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoICsgMTtcbiAgICBsZXQgc3RvcmFnZV9zbmFwc2hvdCA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cbiAgICBzdG9yYWdlX3NuYXBzaG90XG5cbiAgbGV0IGxlYXZlX3Jlc29sdXRpb25fbG9vcCAoc3RvcmFnZV9zbmFwc2hvdCA6IHN0b3JhZ2UpIDogdW5pdCA9XG4gICAgaWYgIWN1cnJlbnRfY2FsbGJhY2tfbmVzdGluZ19kZXB0aCA9IDEgdGhlbiBiZWdpblxuICAgICAgd2hpbGUgbm90IChRdWV1ZS5pc19lbXB0eSBkZWZlcnJlZF9jYWxsYmFja3MpIGRvXG4gICAgICAgIGxldCBEZWZlcnJlZCAoY2FsbGJhY2tzLCByZXN1bHQpID0gUXVldWUucG9wIGRlZmVycmVkX2NhbGxiYWNrcyBpblxuICAgICAgICBydW5fY2FsbGJhY2tzIGNhbGxiYWNrcyByZXN1bHRcbiAgICAgIGRvbmVcbiAgICBlbmQ7XG4gICAgY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoIDo9ICFjdXJyZW50X2NhbGxiYWNrX25lc3RpbmdfZGVwdGggLSAxO1xuICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzdG9yYWdlX3NuYXBzaG90XG5cbiAgbGV0IHJ1bl9pbl9yZXNvbHV0aW9uX2xvb3AgZiA9XG4gICAgbGV0IHN0b3JhZ2Vfc25hcHNob3QgPSBlbnRlcl9yZXNvbHV0aW9uX2xvb3AgKCkgaW5cbiAgICBsZXQgcmVzdWx0ID0gZiAoKSBpblxuICAgIGxlYXZlX3Jlc29sdXRpb25fbG9vcCBzdG9yYWdlX3NuYXBzaG90O1xuICAgIHJlc3VsdFxuXG4gICgqIFRoaXMgaXMgYmFzaWNhbGx5IGEgaGFjayB0byBmaXggaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2lzc3Vlcy80OC5cbiAgICAgSWYgY3VycmVudGx5IHJlc29sdmluZyBwcm9taXNlcywgaXQgaW1tZWRpYXRlbHkgZXhpdHMgYWxsIHJlY3Vyc2l2ZVxuICAgICBlbnRyaWVzIG9mIHRoZSByZXNvbHV0aW9uIGxvb3AsIGdvZXMgdG8gdGhlIHRvcCBsZXZlbCwgcnVucyBhbnkgZGVmZXJyZWRcbiAgICAgY2FsbGJhY2tzLCBhbmQgZXhpdHMgdGhlIHRvcC1sZXZlbCByZXNvbHV0aW9uIGxvb3AuXG5cbiAgICAgVGhlIG5hbWUgc2hvdWxkIHByb2JhYmx5IGJlIFthYmFvbmRvbl9yZXNvbHV0aW9uX2xvb3BdLiAqKVxuICBsZXQgYWJhbmRvbl93YWtldXBzICgpID1cbiAgICBpZiAhY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoIDw+IDAgdGhlblxuICAgICAgbGVhdmVfcmVzb2x1dGlvbl9sb29wIFN0b3JhZ2VfbWFwLmVtcHR5XG5cblxuXG4gIGxldCBydW5fY2FsbGJhY2tzX29yX2RlZmVyX3RoZW1cbiAgICAgID8oYWxsb3dfZGVmZXJyaW5nID0gdHJ1ZSlcbiAgICAgID8obWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoID0gZGVmYXVsdF9tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGgpXG4gICAgICBjYWxsYmFja3MgcmVzdWx0ID1cblxuICAgIGxldCBzaG91bGRfZGVmZXIgPVxuICAgICAgYWxsb3dfZGVmZXJyaW5nXG4gICAgICAmJiAhY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoID49IG1heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aFxuICAgIGluXG5cbiAgICBpZiBzaG91bGRfZGVmZXIgdGhlblxuICAgICAgUXVldWUucHVzaCAoRGVmZXJyZWQgKGNhbGxiYWNrcywgcmVzdWx0KSkgZGVmZXJyZWRfY2FsbGJhY2tzXG4gICAgZWxzZVxuICAgICAgcnVuX2luX3Jlc29sdXRpb25fbG9vcCAoZnVuICgpIC0+XG4gICAgICAgIHJ1bl9jYWxsYmFja3MgY2FsbGJhY2tzIHJlc3VsdClcblxuICBsZXQgcmVzb2x2ZSA/YWxsb3dfZGVmZXJyaW5nID9tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGggcCByZXN1bHQgPVxuICAgIGxldCBQZW5kaW5nIGNhbGxiYWNrcyA9IHAuc3RhdGUgaW5cbiAgICBsZXQgcCA9IHNldF9wcm9taXNlX3N0YXRlIHAgcmVzdWx0IGluXG5cbiAgICBydW5fY2FsbGJhY2tzX29yX2RlZmVyX3RoZW1cbiAgICAgID9hbGxvd19kZWZlcnJpbmcgP21heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aCBjYWxsYmFja3MgcmVzdWx0O1xuXG4gICAgcFxuXG4gIGxldCBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgID8ocnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsID0gZmFsc2UpXG4gICAgICB+Y2FsbGJhY2s6ZlxuICAgICAgfmlmX2RlZmVycmVkID1cblxuICAgIGlmIHJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbCB0aGVuXG4gICAgICBmICgpXG5cbiAgICBlbHNlXG4gICAgICBsZXQgc2hvdWxkX2RlZmVyID1cbiAgICAgICAgIWN1cnJlbnRfY2FsbGJhY2tfbmVzdGluZ19kZXB0aFxuICAgICAgICAgID49IGRlZmF1bHRfbWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoXG4gICAgICBpblxuXG4gICAgICBpZiBzaG91bGRfZGVmZXIgdGhlbiBiZWdpblxuICAgICAgICBsZXQgaW1tZWRpYXRlX3Jlc3VsdCwgZGVmZXJyZWRfY2FsbGJhY2ssIGRlZmVycmVkX3Jlc3VsdCA9XG4gICAgICAgICAgaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgbGV0IGRlZmVycmVkX3JlY29yZCA9XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVndWxhcl9jYWxsYmFja3MgPVxuICAgICAgICAgICAgICBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrXG4gICAgICAgICAgICAgICAgZGVmZXJyZWRfY2FsbGJhY2s7XG4gICAgICAgICAgICBjYW5jZWxfY2FsbGJhY2tzID0gQ2FuY2VsX2NhbGxiYWNrX2xpc3RfZW1wdHk7XG4gICAgICAgICAgICBob3dfdG9fY2FuY2VsID0gTm90X2NhbmNlbGFibGU7XG4gICAgICAgICAgICBjbGVhbnVwc19kZWZlcnJlZCA9IDBcbiAgICAgICAgICB9XG4gICAgICAgIGluXG4gICAgICAgIFF1ZXVlLnB1c2hcbiAgICAgICAgICAoRGVmZXJyZWQgKGRlZmVycmVkX3JlY29yZCwgZGVmZXJyZWRfcmVzdWx0KSkgZGVmZXJyZWRfY2FsbGJhY2tzO1xuICAgICAgICBpbW1lZGlhdGVfcmVzdWx0XG4gICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgcnVuX2luX3Jlc29sdXRpb25fbG9vcCAoZnVuICgpIC0+XG4gICAgICAgICAgZiAoKSlcbmVuZFxuaW5jbHVkZSBSZXNvbHV0aW9uX2xvb3BcblxuXG5cbm1vZHVsZSBSZXNvbHZpbmcgOlxuc2lnXG4gIHZhbCB3YWtldXBfbGF0ZXJfcmVzdWx0IDogJ2EgdSAtPiAnYSBsd3RfcmVzdWx0IC0+IHVuaXRcbiAgdmFsIHdha2V1cF9sYXRlciA6ICdhIHUgLT4gJ2EgLT4gdW5pdFxuICB2YWwgd2FrZXVwX2xhdGVyX2V4biA6IF8gdSAtPiBleG4gLT4gdW5pdFxuXG4gIHZhbCB3YWtldXBfcmVzdWx0IDogJ2EgdSAtPiAnYSBsd3RfcmVzdWx0IC0+IHVuaXRcbiAgdmFsIHdha2V1cCA6ICdhIHUgLT4gJ2EgLT4gdW5pdFxuICB2YWwgd2FrZXVwX2V4biA6IF8gdSAtPiBleG4gLT4gdW5pdFxuXG4gIHZhbCBjYW5jZWwgOiAnYSB0IC0+IHVuaXRcbmVuZCA9XG5zdHJ1Y3RcbiAgKCogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gZGV2aWF0ZXMgZnJvbSB0aGUgXCJpZGVhbFwiIGNhbGxiYWNrIGRlZmVycmFsXG4gICAgIGJlaGF2aW9yOiBpdCBydW5zIGNhbGxiYWNrcyBkaXJlY3RseSBvbiB0aGUgY3VycmVudCBzdGFjay4gSXQgc2hvdWxkXG4gICAgIHRoZXJlZm9yZSBiZSBwb3NzaWJsZSB0byBjYXVzZSBhIHN0YWNrIG92ZXJmbG93IHVzaW5nIHRoaXMgZnVuY3Rpb24uICopXG4gIGxldCB3YWtldXBfZ2VuZXJhbCBhcGlfZnVuY3Rpb25fbmFtZSByIHJlc3VsdCA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9yZXNvbHZlciByIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgUmVqZWN0ZWQgQ2FuY2VsZWQgLT5cbiAgICAgICgpXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgUHJpbnRmLmtzcHJpbnRmIGludmFsaWRfYXJnIFwiTHd0LiVzXCIgYXBpX2Z1bmN0aW9uX25hbWVcbiAgICB8IFJlamVjdGVkIF8gLT5cbiAgICAgIFByaW50Zi5rc3ByaW50ZiBpbnZhbGlkX2FyZyBcIkx3dC4lc1wiIGFwaV9mdW5jdGlvbl9uYW1lXG5cbiAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgbGV0IHJlc3VsdCA9IHN0YXRlX29mX3Jlc3VsdCByZXN1bHQgaW5cbiAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAgPSByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCByZXN1bHQgaW5cbiAgICAgIGlnbm9yZSBwXG5cbiAgbGV0IHdha2V1cF9yZXN1bHQgciByZXN1bHQgPSB3YWtldXBfZ2VuZXJhbCBcIndha2V1cF9yZXN1bHRcIiByIHJlc3VsdFxuICBsZXQgd2FrZXVwIHIgdiA9IHdha2V1cF9nZW5lcmFsIFwid2FrZXVwXCIgciAoUmVzdWx0Lk9rIHYpXG4gIGxldCB3YWtldXBfZXhuIHIgZXhuID0gd2FrZXVwX2dlbmVyYWwgXCJ3YWtldXBfZXhuXCIgciAoUmVzdWx0LkVycm9yIGV4bilcblxuICBsZXQgd2FrZXVwX2xhdGVyX2dlbmVyYWwgYXBpX2Z1bmN0aW9uX25hbWUgciByZXN1bHQgPVxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcmVzb2x2ZXIgciBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IFJlamVjdGVkIENhbmNlbGVkIC0+XG4gICAgICAoKVxuICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgIFByaW50Zi5rc3ByaW50ZiBpbnZhbGlkX2FyZyBcIkx3dC4lc1wiIGFwaV9mdW5jdGlvbl9uYW1lXG4gICAgfCBSZWplY3RlZCBfIC0+XG4gICAgICBQcmludGYua3NwcmludGYgaW52YWxpZF9hcmcgXCJMd3QuJXNcIiBhcGlfZnVuY3Rpb25fbmFtZVxuXG4gICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgIGxldCByZXN1bHQgPSBzdGF0ZV9vZl9yZXN1bHQgcmVzdWx0IGluXG4gICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwID1cbiAgICAgICAgcmVzb2x2ZSB+bWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoOjEgcCByZXN1bHQgaW5cbiAgICAgIGlnbm9yZSBwXG5cbiAgbGV0IHdha2V1cF9sYXRlcl9yZXN1bHQgciByZXN1bHQgPVxuICAgIHdha2V1cF9sYXRlcl9nZW5lcmFsIFwid2FrZXVwX2xhdGVyX3Jlc3VsdFwiIHIgcmVzdWx0XG4gIGxldCB3YWtldXBfbGF0ZXIgciB2ID1cbiAgICB3YWtldXBfbGF0ZXJfZ2VuZXJhbCBcIndha2V1cF9sYXRlclwiIHIgKFJlc3VsdC5PayB2KVxuICBsZXQgd2FrZXVwX2xhdGVyX2V4biByIGV4biA9XG4gICAgd2FrZXVwX2xhdGVyX2dlbmVyYWwgXCJ3YWtldXBfbGF0ZXJfZXhuXCIgciAoUmVzdWx0LkVycm9yIGV4bilcblxuXG5cbiAgdHlwZSBwYWNrZWRfY2FsbGJhY2tzID1cbiAgICB8IFBhY2tlZCA6IF8gY2FsbGJhY2tzIC0+IHBhY2tlZF9jYWxsYmFja3NcbiAgICBbQEBvY2FtbC51bmJveGVkXVxuXG4gICgqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGRldmlhdGVzIGZyb20gdGhlIFwiaWRlYWxcIiBjYWxsYmFjayBkZWZlcnJhbFxuICAgICBiZWhhdmlvcjogaXQgcnVucyBjYWxsYmFja3MgZGlyZWN0bHkgb24gdGhlIGN1cnJlbnQgc3RhY2suIEl0IHNob3VsZFxuICAgICB0aGVyZWZvcmUgYmUgcG9zc2libGUgdG8gY2F1c2UgYSBzdGFjayBvdmVyZmxvdyB1c2luZyB0aGlzIGZ1bmN0aW9uLiAqKVxuICBsZXQgY2FuY2VsIHAgPVxuICAgIGxldCBjYW5jZWxlZF9yZXN1bHQgPSBSZWplY3RlZCBDYW5jZWxlZCBpblxuXG4gICAgKCogV2Fsa3MgdGhlIHByb21pc2UgZGVwZW5kZW5jeSBncmFwaCBiYWNrd2FyZHMsIGxvb2tpbmcgZm9yIGNhbmNlbGFibGVcbiAgICAgICBpbml0aWFsIHByb21pc2VzLCBhbmQgY2FuY2VscyAob25seSkgdGhlbS5cblxuICAgICAgIEZvdW5kIGluaXRpYWwgcHJvbWlzZXMgYXJlIGNhbmNlbGVkIGltbWVkaWF0ZWx5LCBhcyB0aGV5IGFyZSBmb3VuZCwgYnlcbiAgICAgICBzZXR0aW5nIHRoZWlyIHN0YXRlIHRvIFtSZWplY3RlZCBDYW5jZWxlZF0uIFRoaXMgaXMgdG8gcHJldmVudCB0aGVtIGZyb21cbiAgICAgICBiZWluZyBcImZvdW5kIHR3aWNlXCIgaWYgdGhleSBhcmUgcmVhY2hhYmxlIGJ5IHR3byBvciBtb3JlIGRpc3RpbmN0IHBhdGhzXG4gICAgICAgdGhyb3VnaCB0aGUgcHJvbWlzZSBkZXBlbmRlbmN5IGdyYXBoLlxuXG4gICAgICAgVGhlIGNhbGxiYWNrcyBvZiB0aGVzZSBpbml0aWFsIHByb21pc2VzIGFyZSB0aGVuIHJ1biwgaW4gYSBzZXBhcmF0ZVxuICAgICAgIHBoYXNlLiBUaGVzZSBjYWxsYmFja3MgcHJvcGFnYXRlIGNhbmNlbGxhdGlvbiBmb3J3YXJkcyB0byBhbnkgZGVwZW5kZW50XG4gICAgICAgcHJvbWlzZXMuIFNlZSBcIkNhbmNlbGxhdGlvblwiIGluIHRoZSBPdmVydmlldy4gKilcbiAgICBsZXQgcHJvcGFnYXRlX2NhbmNlbCA6IChfLCBfLCBfKSBwcm9taXNlIC0+IHBhY2tlZF9jYWxsYmFja3MgbGlzdCA9XG4gICAgICAgIGZ1biBwIC0+XG4gICAgICBsZXQgcmVjIGNhbmNlbF9hbmRfY29sbGVjdF9jYWxsYmFja3MgOlxuICAgICAgICAgICdhICd1ICdjLiBwYWNrZWRfY2FsbGJhY2tzIGxpc3QgLT4gKCdhLCAndSwgJ2MpIHByb21pc2UgLT5cbiAgICAgICAgICAgIHBhY2tlZF9jYWxsYmFja3MgbGlzdCA9XG4gICAgICAgICAgZnVuICh0eXBlIGMpIGNhbGxiYWNrc19hY2N1bXVsYXRvciAocCA6IChfLCBfLCBjKSBwcm9taXNlKSAtPlxuXG4gICAgICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG4gICAgICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgICAgICAoKiBJZiB0aGUgcHJvbWlzZSBpcyBub3Qgc3RpbGwgcGVuZGluZywgaXQgY2FuJ3QgYmUgY2FuY2VsZWQuICopXG4gICAgICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICAgICBjYWxsYmFja3NfYWNjdW11bGF0b3JcbiAgICAgICAgfCBSZWplY3RlZCBfIC0+XG4gICAgICAgICAgY2FsbGJhY2tzX2FjY3VtdWxhdG9yXG5cbiAgICAgICAgfCBQZW5kaW5nIGNhbGxiYWNrcyAtPlxuICAgICAgICAgIG1hdGNoIGNhbGxiYWNrcy5ob3dfdG9fY2FuY2VsIHdpdGhcbiAgICAgICAgICB8IE5vdF9jYW5jZWxhYmxlIC0+XG4gICAgICAgICAgICBjYWxsYmFja3NfYWNjdW11bGF0b3JcbiAgICAgICAgICB8IENhbmNlbF90aGlzX3Byb21pc2UgLT5cbiAgICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAgPVxuICAgICAgICAgICAgICBzZXRfcHJvbWlzZV9zdGF0ZSBwIGNhbmNlbGVkX3Jlc3VsdCBpblxuICAgICAgICAgICAgaWdub3JlIHA7XG4gICAgICAgICAgICAoUGFja2VkIGNhbGxiYWNrcyk6OmNhbGxiYWNrc19hY2N1bXVsYXRvclxuICAgICAgICAgIHwgUHJvcGFnYXRlX2NhbmNlbF90b19vbmUgcCcgLT5cbiAgICAgICAgICAgIGNhbmNlbF9hbmRfY29sbGVjdF9jYWxsYmFja3MgY2FsbGJhY2tzX2FjY3VtdWxhdG9yIHAnXG4gICAgICAgICAgfCBQcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgcHMgLT5cbiAgICAgICAgICAgIExpc3QuZm9sZF9sZWZ0IGNhbmNlbF9hbmRfY29sbGVjdF9jYWxsYmFja3MgY2FsbGJhY2tzX2FjY3VtdWxhdG9yIHBzXG4gICAgICBpblxuICAgICAgY2FuY2VsX2FuZF9jb2xsZWN0X2NhbGxiYWNrcyBbXSBwXG4gICAgaW5cblxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IGNhbGxiYWNrcyA9IHByb3BhZ2F0ZV9jYW5jZWwgcCBpblxuXG4gICAgY2FsbGJhY2tzIHw+IExpc3QuaXRlciAoZnVuIChQYWNrZWQgY2FsbGJhY2tzKSAtPlxuICAgICAgcnVuX2NhbGxiYWNrc19vcl9kZWZlcl90aGVtXG4gICAgICAgIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgY2FsbGJhY2tzIGNhbmNlbGVkX3Jlc3VsdClcbmVuZFxuaW5jbHVkZSBSZXNvbHZpbmdcblxuXG5cbm1vZHVsZSBUcml2aWFsX3Byb21pc2VzIDpcbnNpZ1xuICB2YWwgcmV0dXJuIDogJ2EgLT4gJ2EgdFxuICB2YWwgZmFpbCA6IGV4biAtPiBfIHRcbiAgdmFsIG9mX3Jlc3VsdCA6ICdhIGx3dF9yZXN1bHQgLT4gJ2EgdFxuXG4gIHZhbCByZXR1cm5fdW5pdCA6IHVuaXQgdFxuICB2YWwgcmV0dXJuX3RydWUgOiBib29sIHRcbiAgdmFsIHJldHVybl9mYWxzZSA6IGJvb2wgdFxuICB2YWwgcmV0dXJuX25vbmUgOiBfIG9wdGlvbiB0XG4gIHZhbCByZXR1cm5fc29tZSA6ICdhIC0+ICdhIG9wdGlvbiB0XG4gIHZhbCByZXR1cm5fb2sgOiAnYSAtPiAoJ2EsIF8pIFJlc3VsdC50IHRcbiAgdmFsIHJldHVybl9lcnJvciA6ICdlIC0+IChfLCAnZSkgUmVzdWx0LnQgdFxuICB2YWwgcmV0dXJuX25pbCA6IF8gbGlzdCB0XG5cbiAgdmFsIGZhaWxfd2l0aCA6IHN0cmluZyAtPiBfIHRcbiAgdmFsIGZhaWxfaW52YWxpZF9hcmcgOiBzdHJpbmcgLT4gXyB0XG5lbmQgPVxuc3RydWN0XG4gIGxldCByZXR1cm4gdiA9XG4gICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gRnVsZmlsbGVkIHZ9XG5cbiAgbGV0IG9mX3Jlc3VsdCByZXN1bHQgPVxuICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IHN0YXRlX29mX3Jlc3VsdCByZXN1bHR9XG5cbiAgbGV0IGZhaWwgZXhuID1cbiAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSBSZWplY3RlZCBleG59XG5cbiAgbGV0IHJldHVybl91bml0ID0gcmV0dXJuICgpXG4gIGxldCByZXR1cm5fbm9uZSA9IHJldHVybiBOb25lXG4gIGxldCByZXR1cm5fc29tZSB4ID0gcmV0dXJuIChTb21lIHgpXG4gIGxldCByZXR1cm5fbmlsID0gcmV0dXJuIFtdXG4gIGxldCByZXR1cm5fdHJ1ZSA9IHJldHVybiB0cnVlXG4gIGxldCByZXR1cm5fZmFsc2UgPSByZXR1cm4gZmFsc2VcbiAgbGV0IHJldHVybl9vayB4ID0gcmV0dXJuIChSZXN1bHQuT2sgeClcbiAgbGV0IHJldHVybl9lcnJvciB4ID0gcmV0dXJuIChSZXN1bHQuRXJyb3IgeClcblxuICBsZXQgZmFpbF93aXRoIG1zZyA9XG4gICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gUmVqZWN0ZWQgKEZhaWx1cmUgbXNnKX1cblxuICBsZXQgZmFpbF9pbnZhbGlkX2FyZyBtc2cgPVxuICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IFJlamVjdGVkIChJbnZhbGlkX2FyZ3VtZW50IG1zZyl9XG5lbmRcbmluY2x1ZGUgVHJpdmlhbF9wcm9taXNlc1xuXG5cblxubW9kdWxlIFBlbmRpbmdfcHJvbWlzZXMgOlxuc2lnXG4gICgqIEludGVybmFsICopXG4gIHZhbCBuZXdfcGVuZGluZyA6XG4gICAgaG93X3RvX2NhbmNlbDpob3dfdG9fY2FuY2VsIC0+ICgnYSwgdW5kZXJseWluZywgcGVuZGluZykgcHJvbWlzZVxuICB2YWwgcHJvcGFnYXRlX2NhbmNlbF90b19zZXZlcmFsIDogXyB0IGxpc3QgLT4gaG93X3RvX2NhbmNlbFxuXG4gICgqIEluaXRpYWwgcGVuZGluZyBwcm9taXNlcyAocHVibGljKSAqKVxuICB2YWwgd2FpdCA6IHVuaXQgLT4gJ2EgdCAqICdhIHVcbiAgdmFsIHRhc2sgOiB1bml0IC0+ICdhIHQgKiAnYSB1XG5cbiAgdmFsIHdhaXRlcl9vZl93YWtlbmVyIDogJ2EgdSAtPiAnYSB0XG5cbiAgdmFsIGFkZF90YXNrX3IgOiAnYSB1IEx3dF9zZXF1ZW5jZS50IC0+ICdhIHRcbiAgdmFsIGFkZF90YXNrX2wgOiAnYSB1IEx3dF9zZXF1ZW5jZS50IC0+ICdhIHRcblxuICB2YWwgcHJvdGVjdGVkIDogJ2EgdCAtPiAnYSB0XG4gIHZhbCBub19jYW5jZWwgOiAnYSB0IC0+ICdhIHRcbmVuZCA9XG5zdHJ1Y3RcbiAgbGV0IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsID1cbiAgICBsZXQgc3RhdGUgPVxuICAgICAgUGVuZGluZyB7XG4gICAgICAgIHJlZ3VsYXJfY2FsbGJhY2tzID0gUmVndWxhcl9jYWxsYmFja19saXN0X2VtcHR5O1xuICAgICAgICBjYW5jZWxfY2FsbGJhY2tzID0gQ2FuY2VsX2NhbGxiYWNrX2xpc3RfZW1wdHk7XG4gICAgICAgIGhvd190b19jYW5jZWw7XG4gICAgICAgIGNsZWFudXBzX2RlZmVycmVkID0gMDtcbiAgICAgIH1cbiAgICBpblxuICAgIHtzdGF0ZX1cblxuICBsZXQgcHJvcGFnYXRlX2NhbmNlbF90b19zZXZlcmFsIHBzID1cbiAgICAoKiBVc2luZyBhIGRpcnR5IGNhc3QgaGVyZSB0byBhdm9pZCByZWJ1aWxkaW5nIHRoZSBsaXN0IDooIE5vdCBib3RoZXJpbmdcbiAgICAgICB3aXRoIHRoZSBpbnZhcmlhbnRzLCBiZWNhdXNlIFtQcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWxdIHBhY2tzIHRoZW0sXG4gICAgICAgYW5kIGNvZGUgdGhhdCBtYXRjaGVzIG9uIFtQcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWxdIGRvZXNuJ3QgY2FyZSBhYm91dFxuICAgICAgIHRoZW0gYW55d2F5LiAqKVxuICAgIGxldCBjYXN0X3Byb21pc2VfbGlzdCA6ICdhIHQgbGlzdCAtPiAoJ2EsIF8sIF8pIHByb21pc2UgbGlzdCA9IE9iai5tYWdpYyBpblxuICAgIFByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCAoY2FzdF9wcm9taXNlX2xpc3QgcHMpXG5cblxuXG4gIGxldCB3YWl0ICgpID1cbiAgICBsZXQgcCA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOk5vdF9jYW5jZWxhYmxlIGluXG4gICAgdG9fcHVibGljX3Byb21pc2UgcCwgdG9fcHVibGljX3Jlc29sdmVyIHBcblxuICBsZXQgdGFzayAoKSA9XG4gICAgbGV0IHAgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDpDYW5jZWxfdGhpc19wcm9taXNlIGluXG4gICAgdG9fcHVibGljX3Byb21pc2UgcCwgdG9fcHVibGljX3Jlc29sdmVyIHBcblxuXG5cbiAgbGV0IHdhaXRlcl9vZl93YWtlbmVyIHIgPVxuICAgIGxldCBJbnRlcm5hbCByID0gdG9faW50ZXJuYWxfcmVzb2x2ZXIgciBpblxuICAgIGxldCBwID0gciBpblxuICAgIHRvX3B1YmxpY19wcm9taXNlIHBcblxuXG5cbiAgbGV0IGNhc3Rfc2VxdWVuY2Vfbm9kZVxuICAgICAgKG5vZGUgOiAnYSB1IEx3dF9zZXF1ZW5jZS5ub2RlKVxuICAgICAgKF9hY3R1YWxfY29udGVudDooJ2EsICd1LCAnYykgcHJvbWlzZSlcbiAgICAgICAgOiAoJ2EsICd1LCAnYykgcHJvbWlzZSBMd3Rfc2VxdWVuY2Uubm9kZSA9XG4gICAgT2JqLm1hZ2ljIG5vZGVcblxuICBsZXQgYWRkX3Rhc2tfciBzZXF1ZW5jZSA9XG4gICAgbGV0IHAgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDpDYW5jZWxfdGhpc19wcm9taXNlIGluXG4gICAgbGV0IG5vZGUgPSBMd3Rfc2VxdWVuY2UuYWRkX3IgKHRvX3B1YmxpY19yZXNvbHZlciBwKSBzZXF1ZW5jZSBpblxuICAgIGxldCBub2RlID0gY2FzdF9zZXF1ZW5jZV9ub2RlIG5vZGUgcCBpblxuXG4gICAgbGV0IFBlbmRpbmcgY2FsbGJhY2tzID0gcC5zdGF0ZSBpblxuICAgIGNhbGxiYWNrcy5jYW5jZWxfY2FsbGJhY2tzIDwtXG4gICAgICBDYW5jZWxfY2FsbGJhY2tfbGlzdF9yZW1vdmVfc2VxdWVuY2Vfbm9kZSBub2RlO1xuXG4gICAgdG9fcHVibGljX3Byb21pc2UgcFxuXG4gIGxldCBhZGRfdGFza19sIHNlcXVlbmNlID1cbiAgICBsZXQgcCA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOkNhbmNlbF90aGlzX3Byb21pc2UgaW5cbiAgICBsZXQgbm9kZSA9IEx3dF9zZXF1ZW5jZS5hZGRfbCAodG9fcHVibGljX3Jlc29sdmVyIHApIHNlcXVlbmNlIGluXG4gICAgbGV0IG5vZGUgPSBjYXN0X3NlcXVlbmNlX25vZGUgbm9kZSBwIGluXG5cbiAgICBsZXQgUGVuZGluZyBjYWxsYmFja3MgPSBwLnN0YXRlIGluXG4gICAgY2FsbGJhY2tzLmNhbmNlbF9jYWxsYmFja3MgPC1cbiAgICAgIENhbmNlbF9jYWxsYmFja19saXN0X3JlbW92ZV9zZXF1ZW5jZV9ub2RlIG5vZGU7XG5cbiAgICB0b19wdWJsaWNfcHJvbWlzZSBwXG5cblxuXG4gIGxldCBwcm90ZWN0ZWQgcCA9XG4gICAgbGV0IEludGVybmFsIHBfaW50ZXJuYWwgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBtYXRjaCAodW5kZXJseWluZyBwX2ludGVybmFsKS5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPiBwXG4gICAgfCBSZWplY3RlZCBfIC0+IHBcblxuICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICBsZXQgcCcgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDpDYW5jZWxfdGhpc19wcm9taXNlIGluXG5cbiAgICAgIGxldCBjYWxsYmFjayBwX3Jlc3VsdCA9XG4gICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcgPSBtYXlfbm93X2JlX3Byb3h5IHAnIGluXG4gICAgICAgIGxldCBwJyA9IHVuZGVybHlpbmcgcCcgaW5cbiAgICAgICAgKCogSW4gdGhpcyBjYWxsYmFjaywgW3AnXSB3aWxsIGVpdGhlciBzdGlsbCBpdHNlbGYgYmUgcGVuZGluZywgb3IgaXRcbiAgICAgICAgICAgd2lsbCBoYXZlIGJlY29tZSBhIHByb3h5IGZvciBhIHBlbmRpbmcgcHJvbWlzZS4gVGhlIHJlYXNvbmluZyBmb3JcbiAgICAgICAgICAgdGhpcyBpcyBhbG1vc3QgdGhlIHNhbWUgYXMgaW4gdGhlIGNvbW1lbnQgYXQgW21heV9ub3dfYmVfcHJveHldLiBUaGVcbiAgICAgICAgICAgZGlmZmVyZW5jZXMgYXJlOlxuXG4gICAgICAgICAgIC0gW3AnXSAqaXMqIGFuIGluaXRpYWwgcHJvbWlzZSwgc28gaXQgKmNhbiogZ2V0IGNhbmNlbGVkLiBIb3dldmVyLCBpZlxuICAgICAgICAgICAgIGl0IGRvZXMsIHRoZSBbb25fY2FuY2VsXSBoYW5kbGVyIGluc3RhbGxlZCBiZWxvdyB3aWxsIHJlbW92ZSB0aGlzXG4gICAgICAgICAgICAgY2FsbGJhY2suXG4gICAgICAgICAgIC0gW3AnXSBuZXZlciBnZXRzIHBhc3NlZCB0byBbbWFrZV9pbnRvX3Byb3h5XSwgdGhlIG9ubHkgZWZmZWN0IG9mXG4gICAgICAgICAgICAgd2hpY2ggaXMgdGhhdCBpdCBjYW5ub3QgYmUgdGhlIHVuZGVybHlpbmcgcHJvbWlzZSBvZiBhbm90aGVyXG4gICAgICAgICAgICAgKHByb3h5KSBwcm9taXNlLiBTbywgW3AnXSBjYW4gb25seSBhcHBlYXIgYXQgdGhlIGhlYWQgb2YgYSBjaGFpbiBvZlxuICAgICAgICAgICAgIFtQcm94eSBfXSBsaW5rcywgYW5kIGl0J3Mgbm90IG5lY2Vzc2FyeSB0byB3b3JyeSBhYm91dCB3aGV0aGVyIHRoZVxuICAgICAgICAgICAgIGluZHVjdGl2ZSByZWFzb25pbmcgYXQgW21heV9ub3dfYmVfcHJveHldIGFwcGxpZXMuICopXG5cbiAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcgPVxuICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwJyBwX3Jlc3VsdCBpblxuICAgICAgICBpZ25vcmUgcCdcbiAgICAgIGluXG5cbiAgICAgIGxldCByZW1vdmVfdGhlX2NhbGxiYWNrID1cbiAgICAgICAgYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2FuZF9naXZlX3JlbW92ZV9mdW5jdGlvblxuICAgICAgICAgIFtwXSBjYWxsYmFja1xuICAgICAgaW5cblxuICAgICAgbGV0IFBlbmRpbmcgcCdfY2FsbGJhY2tzID0gcCcuc3RhdGUgaW5cbiAgICAgIGFkZF9jYW5jZWxfY2FsbGJhY2sgcCdfY2FsbGJhY2tzIHJlbW92ZV90aGVfY2FsbGJhY2s7XG5cbiAgICAgIHRvX3B1YmxpY19wcm9taXNlIHAnXG5cbiAgbGV0IG5vX2NhbmNlbCBwID1cbiAgICBsZXQgSW50ZXJuYWwgcF9pbnRlcm5hbCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIG1hdGNoICh1bmRlcmx5aW5nIHBfaW50ZXJuYWwpLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCBfIC0+IHBcbiAgICB8IFJlamVjdGVkIF8gLT4gcFxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgcCcgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDpOb3RfY2FuY2VsYWJsZSBpblxuXG4gICAgICBsZXQgY2FsbGJhY2sgcF9yZXN1bHQgPVxuICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnID0gbWF5X25vd19iZV9wcm94eSBwJyBpblxuICAgICAgICBsZXQgcCcgPSB1bmRlcmx5aW5nIHAnIGluXG4gICAgICAgICgqIEluIHRoaXMgY2FsbGJhY2ssIFtwJ10gd2lsbCBlaXRoZXIgc3RpbGwgaXRzZWxmIGJlIHBlbmRpbmcsIG9yIGl0XG4gICAgICAgICAgIHdpbGwgaGF2ZSBiZWNvbWUgYSBwcm94eSBmb3IgYSBwZW5kaW5nIHByb21pc2UuIFRoZSByZWFzb25pbmcgZm9yXG4gICAgICAgICAgIHRoaXMgaXMgYXMgaW4gW3Byb3RlY3RlZF0gYW5kIFttYXlfbm93X2JlX3Byb3h5XSwgYnV0IGV2ZW4gc2ltcGxlcixcbiAgICAgICAgICAgYmVjYXVzZSBbcCddIGlzIG5vdCBjYW5jZWxhYmxlLiAqKVxuXG4gICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnID1cbiAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCcgcF9yZXN1bHQgaW5cbiAgICAgICAgaWdub3JlIHAnXG4gICAgICBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFjaztcblxuICAgICAgdG9fcHVibGljX3Byb21pc2UgcCdcbmVuZFxuaW5jbHVkZSBQZW5kaW5nX3Byb21pc2VzXG5cblxuXG5tb2R1bGUgU2VxdWVudGlhbF9jb21wb3NpdGlvbiA6XG5zaWdcbiAgKCogTWFpbiBpbnRlcmZhY2UgKHB1YmxpYykgKilcbiAgdmFsIGJpbmQgOiAnYSB0IC0+ICgnYSAtPiAnYiB0KSAtPiAnYiB0XG4gIHZhbCBtYXAgOiAoJ2EgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgdFxuICB2YWwgY2F0Y2ggOiAodW5pdCAtPiAnYSB0KSAtPiAoZXhuIC0+ICdhIHQpIC0+ICdhIHRcbiAgdmFsIGZpbmFsaXplIDogKHVuaXQgLT4gJ2EgdCkgLT4gKHVuaXQgLT4gdW5pdCB0KSAtPiAnYSB0XG4gIHZhbCB0cnlfYmluZCA6ICh1bml0IC0+ICdhIHQpIC0+ICgnYSAtPiAnYiB0KSAtPiAoZXhuIC0+ICdiIHQpIC0+ICdiIHRcblxuICAoKiBDYW5jZWwgY2FsbGJhY2tzIChwdWJsaWMpLiAqKVxuICB2YWwgb25fY2FuY2VsIDogJ2EgdCAtPiAodW5pdCAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCogTm9uLXByb21pc2UgY2FsbGJhY2tzIChwdWJsaWMpICopXG4gIHZhbCBvbl9zdWNjZXNzIDogJ2EgdCAtPiAoJ2EgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgb25fZmFpbHVyZSA6IF8gdCAtPiAoZXhuIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIG9uX3Rlcm1pbmF0aW9uIDogXyB0IC0+ICh1bml0IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIG9uX2FueSA6ICdhIHQgLT4gKCdhIC0+IHVuaXQpIC0+IChleG4gLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqIEJhY2t0cmFjZSBzdXBwb3J0IChpbnRlcm5hbDsgZm9yIHVzZSBieSB0aGUgUFBYKSAqKVxuICB2YWwgYmFja3RyYWNlX2JpbmQgOlxuICAgIChleG4gLT4gZXhuKSAtPiAnYSB0IC0+ICgnYSAtPiAnYiB0KSAtPiAnYiB0XG4gIHZhbCBiYWNrdHJhY2VfY2F0Y2ggOlxuICAgIChleG4gLT4gZXhuKSAtPiAodW5pdCAtPiAnYSB0KSAtPiAoZXhuIC0+ICdhIHQpIC0+ICdhIHRcbiAgdmFsIGJhY2t0cmFjZV9maW5hbGl6ZSA6XG4gICAgKGV4biAtPiBleG4pIC0+ICh1bml0IC0+ICdhIHQpIC0+ICh1bml0IC0+IHVuaXQgdCkgLT4gJ2EgdFxuICB2YWwgYmFja3RyYWNlX3RyeV9iaW5kIDpcbiAgICAoZXhuIC0+IGV4bikgLT4gKHVuaXQgLT4gJ2EgdCkgLT4gKCdhIC0+ICdiIHQpIC0+IChleG4gLT4gJ2IgdCkgLT4gJ2IgdFxuZW5kID1cbnN0cnVjdFxuICAoKiBUaGVyZSBhcmUgZml2ZSBwcmltYXJ5IHNlcXVlbnRpYWwgY29tcG9zaXRpb24gZnVuY3Rpb25zOiBbYmluZF0sIFttYXBdLFxuICAgICBbY2F0Y2hdLCBbZmluYWxpemVdLCBhbmQgW3RyeV9iaW5kXS4gT2YgdGhlc2UsIFt0cnlfYmluZF0gaXMgdGhlIG1vc3RcbiAgICAgZ2VuZXJhbCAtLSBhbGwgdGhlIG90aGVycyBjYW4gYmUgaW1wbGVtZW50ZWQgaW4gdGVybXMgb2YgaXQuXG5cbiAgICAgTHd0IGNvbmZsYXRlcyBjb25jdXJyZW5jeSB3aXRoIGVycm9yIHByb3BhZ2F0aW9uLiBJZiBMd3QgZGlkIG5vdCBkbyB0aGlzLFxuICAgICB0aGVyZSB3b3VsZCBiZSBvbmx5IHR3byBwcmltYXJ5IGZ1bmN0aW9uczogW2JpbmRdIGFuZCBbbWFwXSwgYW5kLCBvZiB0aGVzZVxuICAgICB0d28sIFtiaW5kXSBpcyB0aGUgbW9zdCBnZW5lcmFsLiBTaW5jZSBbYmluZF0gaXMgdGhlIG1vc3QgcmVsZXZhbnRcbiAgICAgc3BlY2lmaWNhbGx5IHRvIGNvbmN1cnJlbmN5LCBhbmQgaXMgYWxzbyB0aGUgbW9zdCBmYW1pbGlhciBmdW5jdGlvbiBpbiBMd3QsXG4gICAgIGl0cyBpbXBsZW1lbnRhdGlvbiBzZXJ2ZXMgYXMgYSBraW5kIG9mIFwibW9kZWxcIiBmb3IgdGhlIHJlc3QuIEl0IGlzIHRoZSBtb3N0XG4gICAgIGNvbW1lbnRlZCwgYW5kIGFsbCB0aGUgb3RoZXIgZnVuY3Rpb25zIGZvbGxvdyBhIHNpbWlsYXIgcGF0dGVybiB0byBbYmluZF0uXG5cbiAgICAgRm91ciBvZiB0aGUgcHJpbWFyeSBmdW5jdGlvbnMgaGF2ZSBbYmFja3RyYWNlXypdIHZlcnNpb25zLCB3aGljaCBhcmUgbm90XG4gICAgIHRydWx5IHB1YmxpYywgYW5kIGV4aXN0IHRvIHN1cHBvcnQgdGhlIFBQWC4gW2JhY2t0cmFjZV9tYXBdIGRvZXMgbm90IGV4aXN0XG4gICAgIGJlY2F1c2UgdGhlIFBQWCBkb2VzIG5vdCBuZWVkIGl0LlxuXG4gICAgIFRoZSByZW1haW5pbmcgZm91ciBmdW5jdGlvbnMgaW4gdGhpcyBzZWN0aW9uIGF0dGFjaCBcImxvd2VyLWxldmVsLWlzaFwiXG4gICAgIG5vbi1wcm9taXNlLXByb2R1Y2luZyBjYWxsYmFja3MgdG8gcHJvbWlzZXM6IHRoZXNlIGFyZSB0aGUgW29uXypdXG4gICAgIGZ1bmN0aW9ucy4gT2YgdGhlc2UsIFtvbl9hbnldIGlzIHRoZSBtb3N0IGdlbmVyYWwuIElmIEx3dCBkaWQgbm90IGNvbmZsYXRlXG4gICAgIGNvbmN1cnJlbmN5IHdpdGggZXJyb3IgaGFuZGxpbmcsIHRoZXJlIHdvdWxkIG9ubHkgYmUgb25lOiBbb25fc3VjY2Vzc10uICopXG5cblxuXG4gICgqIE1ha2VzIFt+dXNlcl9wcm92aWRlZF9wcm9taXNlXSBpbnRvIGEgcHJveHkgb2YgW35vdXRlcl9wcm9taXNlXS4gQWZ0ZXJcbiAgICAgW21ha2VfaW50b19wcm94eV0sIHRoZXNlIHR3byBwcm9taXNlIHJlZmVyZW5jZXMgXCJiZWhhdmUgaWRlbnRpY2FsbHkuXCJcblxuICAgICBOb3RlIHRoYXQgdGhpcyBpcyBub3Qgc3ltbWV0cmljOiBbdXNlcl9wcm92aWRlZF9wcm9taXNlXSBhbHdheXMgYmVjb21lcyB0aGVcbiAgICAgcHJveHkuIFttYWtlX2ludG9fcHJveHldIGlzIGNhbGxlZCBvbmx5IGJ5IFtiaW5kXSBhbmQgc2ltaWxhciBmdW5jdGlvbnMgaW5cbiAgICAgdGhpcyBtb2R1bGUuIFRoaXMgbWVhbnMgdGhhdDpcblxuICAgICAtIHRoZSBvbmx5IHdheSBmb3IgYSBwcm9taXNlIHRvIGJlY29tZSBhIHByb3h5IGlzIGJ5IGJlaW5nIHJldHVybmVkIGZyb21cbiAgICAgICB0aGUgY2FsbGJhY2sgZ2l2ZW4gYnkgdGhlIHVzZXIgdG8gW2JpbmRdLCBvciBhIHNpbWlsYXIgZnVuY3Rpb24sIGFuZFxuICAgICAtIHRoZSBvbmx5IHdheSBmb3IgYSBwcm9taXNlIHRvIGJlY29tZSB1bmRlcmx5aW5nIGZvciBhIHByb21pc2Ugb3RoZXIgdGhhblxuICAgICAgIGl0c2VsZiBpcyB0byBiZSB0aGUgb3V0ZXIgcHJvbWlzZSBvcmlnaW5hbGx5IHJldHVybmVkIHRvIHRoZSB1c2VyIGZyb21cbiAgICAgICBbYmluZF0sIG9yIGEgc2ltaWxhciBmdW5jdGlvbi5cblxuICAgICBUaGVzZSB0d28gZmFjdHMgYXJlIGltcG9ydGFudCBmb3IgcmVhc29uaW5nIGFib3V0IGhvdyBhbmQgd2hpY2ggcHJvbWlzZXNcbiAgICAgY2FuIGJlY29tZSBwcm94aWVzLCB1bmRlcmx5aW5nLCBldGMuOyBpbiBwYXJ0aWN1bGFyLCBpdCBpcyB1c2VkIGluIHRoZVxuICAgICBhcmd1bWVudCBpbiBbbWF5X25vd19iZV9wcm94eV0gZm9yIGNvcnJlY3QgcHJlZGljdGlvbnMgYWJvdXQgc3RhdGUgY2hhbmdlcy5cblxuICAgICBbfm91dGVyX3Byb21pc2VdIGlzIGFsd2F5cyBhIHBlbmRpbmcgcHJvbWlzZSB3aGVuIFttYWtlX2ludG9fcHJveHldIGlzXG4gICAgIGNhbGxlZDsgZm9yIHRoZSBleHBsYW5hdGlvbiwgc2VlIFttYXlfbm93X2JlX3Byb3h5XSAodGhvdWdoIHRoZSBjYWxsZXIgb2ZcbiAgICAgW21ha2VfaW50b19wcm94eV0gYWx3YXlzIGNhbGxzIFt1bmRlcmx5aW5nXSBmaXJzdCB0byBwYXNzIHRoZSB1bmRlcmx5aW5nXG4gICAgIHBlbmRpbmcgcHJvbWlzZSB0byBbbWFrZV9pbnRvX3Byb3h5XSkuXG5cbiAgICAgVGhlIHJlYXNvbnMgcHJveHlpbmcgaXMgdXNlZCwgaW5zdGVhZCBvZiBhZGRpbmcgYSBjYWxsYmFjayB0b1xuICAgICBbfnVzZXJfcHJvdmlkZWRfcHJvbWlzZV0gdG8gcmVzb2x2ZSBbfm91dGVyX3Byb21pc2VdIHdoZW4gdGhlIGZvcm1lclxuICAgICBiZWNvbWVzIHJlc29sdmVkIHByb2JhYmx5IGFyZTpcblxuICAgICAtIFByb21pc2VzIGhhdmUgbW9yZSBiZWhhdmlvcnMgdGhhbiByZXNvbHV0aW9uLiBPbmUgd291bGQgaGF2ZSB0byBhZGQgYVxuICAgICAgIGNhbmNlbGxhdGlvbiBoYW5kbGVyIHRvIFt+b3V0ZXJfcHJvbWlzZV0gdG8gcHJvcGFnYXRlIHRoZSBjYW5jZWxsYXRpb25cbiAgICAgICBiYWNrIHRvIFt+dXNlcl9wcm92aWRlZF9wcm9taXNlXSwgZm9yIGV4YW1wbGUuIEl0IG1heSBiZSBlYXNpZXIgdG8ganVzdFxuICAgICAgIHRoaW5rIG9mIHRoZW0gYXMgdGhlIHNhbWUgcHJvbWlzZS5cbiAgICAgLSBJZiB1c2luZyBjYWxsYmFja3MsIHJlc29sdmluZyBbfnVzZXJfcHJvdmlkZWRfcHJvbWlzZV0gd291bGQgbm90XG4gICAgICAgaW1tZWRpYXRlbHkgcmVzb2x2ZSBbfm91dGVyX3Byb21pc2VdLiBBbm90aGVyIGNhbGxiYWNrIGFkZGVkIHRvXG4gICAgICAgW351c2VyX3Byb3ZpZGVkX3Byb21pc2VdIG1pZ2h0IHNlZSBbfnVzZXJfcHJvdmlkZWRfcHJvbWlzZV0gcmVzb2x2ZWQsXG4gICAgICAgYnV0IFt+b3V0ZXJfcHJvbWlzZV0gc3RpbGwgcGVuZGluZywgZGVwZW5kaW5nIG9uIHRoZSBvcmRlciBpbiB3aGljaFxuICAgICAgIGNhbGxiYWNrcyBhcmUgcnVuLiAqKVxuICBsZXQgbWFrZV9pbnRvX3Byb3h5XG4gICAgICAodHlwZSBjKVxuICAgICAgfihvdXRlcl9wcm9taXNlIDogKCdhLCB1bmRlcmx5aW5nLCBwZW5kaW5nKSBwcm9taXNlKVxuICAgICAgfih1c2VyX3Byb3ZpZGVkX3Byb21pc2UgOiAoJ2EsIF8sIGMpIHByb21pc2UpXG4gICAgICAgIDogKCdhLCB1bmRlcmx5aW5nLCBjKSBzdGF0ZV9jaGFuZ2VkID1cblxuICAgICgqIFVzaW5nIFtwJ10gYXMgaXQncyB0aGUgbmFtZSB1c2VkIGluc2lkZSBbYmluZF0sIGV0Yy4sIGZvciBwcm9taXNlcyB3aXRoXG4gICAgICAgdGhpcyByb2xlIC0tIFtwJ10gaXMgdGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlIHVzZXIncyBmdW5jdGlvbi4gKilcbiAgICBsZXQgcCcgPSB1bmRlcmx5aW5nIHVzZXJfcHJvdmlkZWRfcHJvbWlzZSBpblxuXG4gICAgaWYgaWRlbnRpY2FsIHAnIG91dGVyX3Byb21pc2UgdGhlblxuICAgICAgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJ1xuICAgICAgKCogV2UgcmVhbGx5IHdhbnQgdG8gcmV0dXJuIFtTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIG91dGVyX3Byb21pc2VdLCBidXRcbiAgICAgICAgIHRoZSByZWZlcmVuY2UgdGhyb3VnaCBbcCddIGhhcyB0aGUgcmlnaHQgdHlwZS4gKilcblxuICAgIGVsc2VcbiAgICAgIG1hdGNoIHAnLnN0YXRlIHdpdGhcbiAgICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIG91dGVyX3Byb21pc2UgcCcuc3RhdGVcbiAgICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2Ugb3V0ZXJfcHJvbWlzZSBwJy5zdGF0ZVxuXG4gICAgICB8IFBlbmRpbmcgcCdfY2FsbGJhY2tzIC0+XG4gICAgICAgIGxldCBQZW5kaW5nIG91dGVyX2NhbGxiYWNrcyA9IG91dGVyX3Byb21pc2Uuc3RhdGUgaW5cblxuICAgICAgICBtZXJnZV9jYWxsYmFja3MgfmZyb206cCdfY2FsbGJhY2tzIH5pbnRvOm91dGVyX2NhbGxiYWNrcztcbiAgICAgICAgb3V0ZXJfY2FsbGJhY2tzLmhvd190b19jYW5jZWwgPC0gcCdfY2FsbGJhY2tzLmhvd190b19jYW5jZWw7XG5cbiAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcgPVxuICAgICAgICAgIHNldF9wcm9taXNlX3N0YXRlIHAnIChQcm94eSBvdXRlcl9wcm9taXNlKSBpblxuICAgICAgICBpZ25vcmUgcCc7XG5cbiAgICAgICAgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBvdXRlcl9wcm9taXNlXG4gICAgICAgICgqIFRoZSBzdGF0ZSBoYXNuJ3QgYWN0dWFsbHkgY2hhbmdlZCwgYnV0IHdlIHN0aWxsIGhhdmUgdG8gd3JhcFxuICAgICAgICAgICBbb3V0ZXJfcHJvbWlzZV0gZm9yIHR5cGUgY2hlY2tpbmcuICopXG5cbiAgICAgICAgKCogVGhlIHN0YXRlIG9mIFtwJ10gbWF5IGluc3RlYWQgaGF2ZSBjaGFuZ2VkIC0tIGl0IG1heSBoYXZlIGJlY29tZSBhXG4gICAgICAgICAgIHByb3h5LiBIb3dldmVyLCBjYWxsZXJzIG9mIFttYWtlX2ludG9fcHJveHldIGRvbid0IGtub3cgaWZcbiAgICAgICAgICAgW3VzZXJfcHJvdmlkZWRfcHJvbWlzZV0gd2FzIGEgcHJveHkgb3Igbm90ICh0aGF0J3Mgd2h5IHdlIGNhbGxcbiAgICAgICAgICAgdW5kZXJseWluZyBvbiBpdCBhdCB0aGUgdG9wIG9mIHRoaXMgZnVuY3Rpb24sIHRvIGdldCBbcCddKS4gV2UgY2FuXG4gICAgICAgICAgIHRoZXJlZm9yZSB0YWtlIGEgZGFuZ2Vyb3VzIHNob3J0Y3V0IGFuZCBub3QgYm90aGVyIHJldHVybmluZyBhIG5ld1xuICAgICAgICAgICByZWZlcmVuY2UgdG8gW3VzZXJfcHJvdmlkZWRfcHJvbWlzZV0gZm9yIHNoYWRvd2luZy4gKilcblxuXG5cbiAgKCogTWFpbnRhaW5lcidzIG5vdGU6IGEgbG90IG9mIHRoZSBjb2RlIGJlbG93IGNhbiBwcm9iYWJseSBiZSBkZWR1cGxpY2F0ZWQgaW5cbiAgICAgc29tZSB3YXksIGVzcGVjaWFsbHkgaWYgYXNzdW1pbmcgRmxhbWJkYS4gKilcblxuICBsZXQgYmluZCBwIGYgPVxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgICgqIEluIGNhc2UgW0x3dC5iaW5kXSBuZWVkcyB0byBkZWZlciB0aGUgY2FsbCB0byBbZl0sIHRoaXMgZnVuY3Rpb24gd2lsbCBiZVxuICAgICAgIGNhbGxlZCB0byBjcmVhdGU6XG5cbiAgICAgICAxLiBUaGUgcHJvbWlzZSwgW3AnJ10sIHRoYXQgbXVzdCBiZSByZXR1cm5lZCB0byB0aGUgY2FsbGVyIGltbWVkaWF0ZWx5LlxuICAgICAgIDIuIFRoZSBjYWxsYmFjayB0aGF0IHJlc29sdmVzIFtwJyddLlxuXG4gICAgICAgW0x3dC5iaW5kXSBkZWZlcnMgdGhlIGNhbGwgdG8gW2ZdIGluIHR3byBjaXJjdW1zdGFuY2VzOlxuXG4gICAgICAgMS4gVGhlIHByb21pc2UgW3BdIGlzIHBlbmRpbmcuXG4gICAgICAgMi4gVGhlIHByb21pc2UgW3BdIGlzIGZ1bGZpbGxlZCwgYnV0IHRoZSBjdXJyZW50IGNhbGxiYWNrIGNhbGwgbmVzdGluZ1xuICAgICAgICAgIGRlcHRoIGlzIHN1Y2ggdGhhdCB0aGUgY2FsbCB0byBbZl0gbXVzdCBnbyBpbnRvIHRoZSBjYWxsYmFjayBxdWV1ZSwgaW5cbiAgICAgICAgICBvcmRlciB0byBhdm9pZCBzdGFjayBvdmVyZmxvdy5cblxuICAgICAgTWVjaGFuaXNtICgyKSBpcyBjdXJyZW50bHkgZGlzYWJsZWQuIEl0IG1heSBiZSB1c2VkIGluIGFuIGFsdGVybmF0aXZlIEx3dFxuICAgICAgQVBJLlxuXG4gICAgICBGdW5jdGlvbnMgb3RoZXIgdGhhbiBbTHd0LmJpbmRdIGhhdmUgYW5hbG9nb3VzIGRlZmVycmFsIGJlaGF2aW9yLiAqKVxuICAgIGxldCBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBwJycgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDooUHJvcGFnYXRlX2NhbmNlbF90b19vbmUgcCkgaW5cbiAgICAgICgqIFRoZSByZXN1bHQgcHJvbWlzZSBpcyBhIGZyZXNoIHBlbmRpbmcgcHJvbWlzZS5cblxuICAgICAgICAgSW5pdGlhbGx5LCB0cnlpbmcgdG8gY2FuY2VsIHRoaXMgZnJlc2ggcGVuZGluZyBwcm9taXNlIFtwJyddIHdpbGxcbiAgICAgICAgIHByb3BhZ2F0ZSB0aGUgY2FuY2VsbGF0aW9uIGF0dGVtcHQgdG8gW3BdIChiYWNrd2FyZHMgdGhyb3VnaCB0aGVcbiAgICAgICAgIHByb21pc2UgZGVwZW5kZW5jeSBncmFwaCkuIElmL3doZW4gW3BdIGlzIGZ1bGZpbGxlZCwgTHd0IHdpbGwgY2FsbCB0aGVcbiAgICAgICAgIHVzZXIncyBjYWxsYmFjayBbZl0gYmVsb3csIHdoaWNoIHdpbGwgcHJvdmlkZSBhIG5ldyBwcm9taXNlIFtwJ10sIGFuZFxuICAgICAgICAgW3AnXSB3aWxsIGJlY29tZSBhIHByb3h5IG9mIFtwJyddLiBBdCB0aGF0IHBvaW50LCB0cnlpbmcgdG8gY2FuY2VsXG4gICAgICAgICBbcCcnXSB3aWxsIGJlIGVxdWl2YWxlbnQgdG8gdHJ5aW5nIHRvIGNhbmNlbCBbcCddLCBzbyB0aGUgYmVoYXZpb3Igd2lsbFxuICAgICAgICAgZGVwZW5kIG9uIGhvdyB0aGUgdXNlciBvYnRhaW5lZCBbcCddLiAqKVxuXG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcF9yZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG5cbiAgICAgICAgICBsZXQgcCcgPSB0cnkgZiB2IHdpdGggZXhuIC0+IGZhaWwgZXhuIGluXG4gICAgICAgICAgbGV0IEludGVybmFsIHAnID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwJyBpblxuICAgICAgICAgICgqIFJ1biB0aGUgdXNlcidzIGZ1bmN0aW9uIFtmXS4gKilcblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cbiAgICAgICAgICAoKiBbcCcnXSB3YXMgYW4gdW5kZXJseWluZyBwcm9taXNlIHdoZW4gaXQgd2FzIGNyZWF0ZWQgYWJvdmUsIGJ1dCBpdFxuICAgICAgICAgICAgIG1heSBoYXZlIGJlY29tZSBhIHByb3h5IGJ5IHRoZSB0aW1lIHRoaXMgY29kZSBpcyBiZWluZyBleGVjdXRlZC5cbiAgICAgICAgICAgICBIb3dldmVyLCBpdCBpcyBzdGlsbCBlaXRoZXIgYW4gdW5kZXJseWluZyBwZW5kaW5nIHByb21pc2UsIG9yIGFcbiAgICAgICAgICAgICBwcm94eSBmb3IgYSBwZW5kaW5nIHByb21pc2UuIFRoZXJlZm9yZSwgW21heV9ub3dfYmVfcHJveHldIHByb2R1Y2VzXG4gICAgICAgICAgICAgYSByZWZlcmVuY2Ugd2l0aCB0aGUgcmlnaHQgdHlwZSB2YXJpYWJsZXMuIFdlIGltbWVkaWF0ZWx5IGdldFxuICAgICAgICAgICAgIFtwJyddJ3MgY3VycmVudCB1bmRlcmx5aW5nIHByb21pc2UuICopXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgbWFrZV9pbnRvX3Byb3h5IH5vdXRlcl9wcm9taXNlOnAnJyB+dXNlcl9wcm92aWRlZF9wcm9taXNlOnAnIGluXG4gICAgICAgICAgaWdub3JlIHAnJ1xuICAgICAgICAgICgqIE1ha2UgdGhlIG91dGVyIHByb21pc2UgW3AnJ10gYmVoYXZpb3JhbGx5IGlkZW50aWNhbCB0byB0aGUgcHJvbWlzZVxuICAgICAgICAgICAgIFtwJ10gcmV0dXJuZWQgYnkgW2ZdIGJ5IG1ha2luZyBbcCddIGludG8gYSBwcm94eSBvZiBbcCcnXS4gKilcblxuICAgICAgICB8IFJlamVjdGVkIF8gYXMgcF9yZXN1bHQgLT5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHAnJyBwX3Jlc3VsdCBpblxuICAgICAgICAgIGlnbm9yZSBwJydcbiAgICAgIGluXG5cbiAgICAgICh0b19wdWJsaWNfcHJvbWlzZSBwJycsIGNhbGxiYWNrKVxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGYgdilcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgKHAnJywgY2FsbGJhY2spID1cbiAgICAgICAgICAgIGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAocCcnLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFJlamVjdGVkIF8gYXMgcmVzdWx0IC0+XG4gICAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSByZXN1bHR9XG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPSBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrO1xuICAgICAgcCcnXG5cbiAgbGV0IGJhY2t0cmFjZV9iaW5kIGFkZF9sb2MgcCBmID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBsZXQgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSA9XG4gICAgICBsZXQgcCcnID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KFByb3BhZ2F0ZV9jYW5jZWxfdG9fb25lIHApIGluXG5cbiAgICAgIGxldCBzYXZlZF9zdG9yYWdlID0gIWN1cnJlbnRfc3RvcmFnZSBpblxuXG4gICAgICBsZXQgY2FsbGJhY2sgcF9yZXN1bHQgPVxuICAgICAgICBtYXRjaCBwX3Jlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcblxuICAgICAgICAgIGxldCBwJyA9IHRyeSBmIHYgd2l0aCBleG4gLT4gZmFpbCAoYWRkX2xvYyBleG4pIGluXG4gICAgICAgICAgbGV0IEludGVybmFsIHAnID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIG1ha2VfaW50b19wcm94eSB+b3V0ZXJfcHJvbWlzZTpwJycgfnVzZXJfcHJvdmlkZWRfcHJvbWlzZTpwJyBpblxuICAgICAgICAgIGlnbm9yZSBwJydcblxuICAgICAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCcnIChSZWplY3RlZCAoYWRkX2xvYyBleG4pKSBpblxuICAgICAgICAgIGlnbm9yZSBwJydcbiAgICAgIGluXG5cbiAgICAgICh0b19wdWJsaWNfcHJvbWlzZSBwJycsIGNhbGxiYWNrKVxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGYgdilcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgKHAnJywgY2FsbGJhY2spID1cbiAgICAgICAgICAgIGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAocCcnLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gUmVqZWN0ZWQgKGFkZF9sb2MgZXhuKX1cblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICBwJydcblxuICBsZXQgbWFwIGYgcCA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHAnJyA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihQcm9wYWdhdGVfY2FuY2VsX3RvX29uZSBwKSBpblxuXG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcF9yZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG5cbiAgICAgICAgICBsZXQgcCcnX3Jlc3VsdCA9IHRyeSBGdWxmaWxsZWQgKGYgdikgd2l0aCBleG4gLT4gUmVqZWN0ZWQgZXhuIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHAnJyBwJydfcmVzdWx0IGluXG4gICAgICAgICAgaWdub3JlIHAnJ1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyBhcyBwX3Jlc3VsdCAtPlxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCcnIHBfcmVzdWx0IGluXG4gICAgICAgICAgaWdub3JlIHAnJ1xuICAgICAgaW5cblxuICAgICAgKHRvX3B1YmxpY19wcm9taXNlIHAnJywgY2FsbGJhY2spXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT5cbiAgICAgICAgICB0b19wdWJsaWNfcHJvbWlzZVxuICAgICAgICAgICAge3N0YXRlID0gdHJ5IEZ1bGZpbGxlZCAoZiB2KSB3aXRoIGV4biAtPiBSZWplY3RlZCBleG59KVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUmVqZWN0ZWQgXyBhcyByZXN1bHQgLT5cbiAgICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IHJlc3VsdH1cblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICBwJydcblxuICBsZXQgY2F0Y2ggZiBoID1cbiAgICBsZXQgcCA9IHRyeSBmICgpIHdpdGggZXhuIC0+IGZhaWwgZXhuIGluXG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHAnJyA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihQcm9wYWdhdGVfY2FuY2VsX3RvX29uZSBwKSBpblxuXG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcF9yZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCBfIGFzIHBfcmVzdWx0IC0+XG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwJycgcF9yZXN1bHQgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG5cbiAgICAgICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcblxuICAgICAgICAgIGxldCBwJyA9IHRyeSBoIGV4biB3aXRoIGV4biAtPiBmYWlsIGV4biBpblxuICAgICAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCcgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICBtYWtlX2ludG9fcHJveHkgfm91dGVyX3Byb21pc2U6cCcnIH51c2VyX3Byb3ZpZGVkX3Byb21pc2U6cCcgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG4gICAgICBpblxuXG4gICAgICAodG9fcHVibGljX3Byb21pc2UgcCcnLCBjYWxsYmFjaylcbiAgICBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgdG9fcHVibGljX3Byb21pc2UgcFxuXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaCBleG4pXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9XG4gICAgICAgICAgICBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKHAnJywgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgKHAnJywgY2FsbGJhY2spID0gY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFjaztcbiAgICAgIHAnJ1xuXG4gIGxldCBiYWNrdHJhY2VfY2F0Y2ggYWRkX2xvYyBmIGggPVxuICAgIGxldCBwID0gdHJ5IGYgKCkgd2l0aCBleG4gLT4gZmFpbCBleG4gaW5cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBsZXQgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSA9XG4gICAgICBsZXQgcCcnID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KFByb3BhZ2F0ZV9jYW5jZWxfdG9fb25lIHApIGluXG5cbiAgICAgIGxldCBzYXZlZF9zdG9yYWdlID0gIWN1cnJlbnRfc3RvcmFnZSBpblxuXG4gICAgICBsZXQgY2FsbGJhY2sgcF9yZXN1bHQgPVxuICAgICAgICBtYXRjaCBwX3Jlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIF8gYXMgcF9yZXN1bHQgLT5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHAnJyBwX3Jlc3VsdCBpblxuICAgICAgICAgIGlnbm9yZSBwJydcblxuICAgICAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuXG4gICAgICAgICAgbGV0IHAnID0gdHJ5IGggZXhuIHdpdGggZXhuIC0+IGZhaWwgKGFkZF9sb2MgZXhuKSBpblxuICAgICAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCcgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICBtYWtlX2ludG9fcHJveHkgfm91dGVyX3Byb21pc2U6cCcnIH51c2VyX3Byb3ZpZGVkX3Byb21pc2U6cCcgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG4gICAgICBpblxuXG4gICAgICAodG9fcHVibGljX3Byb21pc2UgcCcnLCBjYWxsYmFjaylcbiAgICBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgdG9fcHVibGljX3Byb21pc2UgcFxuXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaCAoYWRkX2xvYyBleG4pKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICBwJydcblxuICBsZXQgdHJ5X2JpbmQgZiBmJyBoID1cbiAgICBsZXQgcCA9IHRyeSBmICgpIHdpdGggZXhuIC0+IGZhaWwgZXhuIGluXG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHAnJyA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihQcm9wYWdhdGVfY2FuY2VsX3RvX29uZSBwKSBpblxuXG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcF9yZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG5cbiAgICAgICAgICBsZXQgcCcgPSB0cnkgZicgdiB3aXRoIGV4biAtPiBmYWlsIGV4biBpblxuICAgICAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCcgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICBtYWtlX2ludG9fcHJveHkgfm91dGVyX3Byb21pc2U6cCcnIH51c2VyX3Byb3ZpZGVkX3Byb21pc2U6cCcgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG5cbiAgICAgICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcblxuICAgICAgICAgIGxldCBwJyA9IHRyeSBoIGV4biB3aXRoIGV4biAtPiBmYWlsIGV4biBpblxuICAgICAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCcgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICBtYWtlX2ludG9fcHJveHkgfm91dGVyX3Byb21pc2U6cCcnIH51c2VyX3Byb3ZpZGVkX3Byb21pc2U6cCcgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG4gICAgICBpblxuXG4gICAgICAodG9fcHVibGljX3Byb21pc2UgcCcnLCBjYWxsYmFjaylcbiAgICBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBmJyB2KVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGggZXhuKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICBwJydcblxuICBsZXQgYmFja3RyYWNlX3RyeV9iaW5kIGFkZF9sb2MgZiBmJyBoID1cbiAgICBsZXQgcCA9IHRyeSBmICgpIHdpdGggZXhuIC0+IGZhaWwgZXhuIGluXG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHAnJyA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihQcm9wYWdhdGVfY2FuY2VsX3RvX29uZSBwKSBpblxuXG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcF9yZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG5cbiAgICAgICAgICBsZXQgcCcgPSB0cnkgZicgdiB3aXRoIGV4biAtPiBmYWlsIChhZGRfbG9jIGV4bikgaW5cbiAgICAgICAgICBsZXQgSW50ZXJuYWwgcCcgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgbWFrZV9pbnRvX3Byb3h5IH5vdXRlcl9wcm9taXNlOnAnJyB+dXNlcl9wcm92aWRlZF9wcm9taXNlOnAnIGluXG4gICAgICAgICAgaWdub3JlIHAnJ1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG5cbiAgICAgICAgICBsZXQgcCcgPSB0cnkgaCBleG4gd2l0aCBleG4gLT4gZmFpbCAoYWRkX2xvYyBleG4pIGluXG4gICAgICAgICAgbGV0IEludGVybmFsIHAnID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIG1ha2VfaW50b19wcm94eSB+b3V0ZXJfcHJvbWlzZTpwJycgfnVzZXJfcHJvdmlkZWRfcHJvbWlzZTpwJyBpblxuICAgICAgICAgIGlnbm9yZSBwJydcbiAgICAgIGluXG5cbiAgICAgICh0b19wdWJsaWNfcHJvbWlzZSBwJycsIGNhbGxiYWNrKVxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGYnIHYpXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9XG4gICAgICAgICAgICBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKHAnJywgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaCAoYWRkX2xvYyBleG4pKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICBwJydcblxuICBsZXQgZmluYWxpemUgZiBmJyA9XG4gICAgdHJ5X2JpbmQgZlxuICAgICAgKGZ1biB4IC0+IGJpbmQgKGYnICgpKSAoZnVuICgpIC0+IHJldHVybiB4KSlcbiAgICAgIChmdW4gZSAtPiBiaW5kIChmJyAoKSkgKGZ1biAoKSAtPiBmYWlsIGUpKVxuXG4gIGxldCBiYWNrdHJhY2VfZmluYWxpemUgYWRkX2xvYyBmIGYnID1cbiAgICBiYWNrdHJhY2VfdHJ5X2JpbmQgYWRkX2xvYyBmXG4gICAgICAoZnVuIHggLT4gYmluZCAoZicgKCkpIChmdW4gKCkgLT4gcmV0dXJuIHgpKVxuICAgICAgKGZ1biBlIC0+IGJpbmQgKGYnICgpKSAoZnVuICgpIC0+IGZhaWwgKGFkZF9sb2MgZSkpKVxuXG5cblxuICBsZXQgb25fY2FuY2VsIHAgZiA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBSZWplY3RlZCBDYW5jZWxlZCAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmICgpKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgICgoKSwgKGZ1biBfIC0+IGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGYgKCkpLCBGdWxmaWxsZWQgKCkpKVxuXG4gICAgfCBSZWplY3RlZCBfIC0+XG4gICAgICAoKVxuXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgKClcblxuICAgIHwgUGVuZGluZyBjYWxsYmFja3MgLT5cbiAgICAgIGFkZF9jYW5jZWxfY2FsbGJhY2sgY2FsbGJhY2tzIGZcblxuXG5cbiAgbGV0IG9uX3N1Y2Nlc3MgcCBmID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBsZXQgY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGZ1biByZXN1bHQgLT5cbiAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuICAgICAgICAgIGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGYgdlxuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgICAgICgpXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiB2KVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKCgpLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFJlamVjdGVkIF8gLT5cbiAgICAgICgpXG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrXG5cbiAgbGV0IG9uX2ZhaWx1cmUgcCBmID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBsZXQgY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGZ1biByZXN1bHQgLT5cbiAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICAgICgpXG5cbiAgICAgICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcbiAgICAgICAgICBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmIGV4blxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICAoKVxuXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiBleG4pXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IGNhbGxiYWNrID0gY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAoKCksIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IGNhbGxiYWNrID0gY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2tcblxuICBsZXQgb25fdGVybWluYXRpb24gcCBmID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBsZXQgY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGZ1biBfcmVzdWx0IC0+XG4gICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuICAgICAgICBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmICgpXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiAoKSlcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgY2FsbGJhY2sgPSBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgICgoKSwgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBSZWplY3RlZCBfIC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmICgpKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKCgpLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrXG5cbiAgbGV0IG9uX2FueSBwIGYgZyA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBzYXZlZF9zdG9yYWdlID0gIWN1cnJlbnRfc3RvcmFnZSBpblxuXG4gICAgICBmdW4gcmVzdWx0IC0+XG4gICAgICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcbiAgICAgICAgICBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmIHZcblxuICAgICAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuICAgICAgICAgIGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGcgZXhuXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiB2KVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKCgpLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBnIGV4bilcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgY2FsbGJhY2sgPSBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgICgoKSwgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgY2FsbGJhY2sgPSBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFja1xuZW5kXG5pbmNsdWRlIFNlcXVlbnRpYWxfY29tcG9zaXRpb25cblxuXG4oKiBUaGlzIGJlbG9uZ3Mgd2l0aCB0aGUgW3Byb3RlY3RlZF0gYW5kIHN1Y2gsIGJ1dCBpdCBkZXBlbmRzIG9uIHByaW1pdGl2ZXMgZnJvbVxuICAgW1NlcXVlbnRpYWxfY29tcG9zaXRpb25dLiAqKVxubGV0IHdyYXBfaW5fY2FuY2VsYWJsZSBwID1cbiBsZXQgSW50ZXJuYWwgcF9pbnRlcm5hbCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuIGxldCBwX3VuZGVybHlpbmcgPSB1bmRlcmx5aW5nIHBfaW50ZXJuYWwgaW5cbiBtYXRjaCBwX3VuZGVybHlpbmcuc3RhdGUgd2l0aFxuIHwgRnVsZmlsbGVkIF8gLT4gcFxuIHwgUmVqZWN0ZWQgXyAtPiBwXG4gfCBQZW5kaW5nIF8gLT5cbiAgIGxldCBwJywgciA9IHRhc2sgKCkgaW5cbiAgIG9uX2NhbmNlbCBwJyAoZnVuICgpIC0+IGNhbmNlbCBwKTtcbiAgIG9uX2FueSBwICh3YWtldXAgcikgKHdha2V1cF9leG4gcik7XG4gICBwJ1xuXG5cbm1vZHVsZSBDb25jdXJyZW50X2NvbXBvc2l0aW9uIDpcbnNpZ1xuICB2YWwgZG9udF93YWl0IDogKHVuaXQgLT4gXyB0KSAtPiAoZXhuIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGFzeW5jIDogKHVuaXQgLT4gXyB0KSAtPiB1bml0XG4gIHZhbCBpZ25vcmVfcmVzdWx0IDogXyB0IC0+IHVuaXRcblxuICB2YWwgYm90aCA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EgKiAnYikgdFxuICB2YWwgam9pbiA6IHVuaXQgdCBsaXN0IC0+IHVuaXQgdFxuICB2YWwgYWxsIDogKCdhIHQpIGxpc3QgLT4gKCdhIGxpc3QpIHRcblxuICB2YWwgY2hvb3NlIDogJ2EgdCBsaXN0IC0+ICdhIHRcbiAgdmFsIHBpY2sgOiAnYSB0IGxpc3QgLT4gJ2EgdFxuXG4gIHZhbCBuY2hvb3NlIDogJ2EgdCBsaXN0IC0+ICdhIGxpc3QgdFxuICB2YWwgbnBpY2sgOiAnYSB0IGxpc3QgLT4gJ2EgbGlzdCB0XG5cbiAgdmFsIG5jaG9vc2Vfc3BsaXQgOiAnYSB0IGxpc3QgLT4gKCdhIGxpc3QgKiAnYSB0IGxpc3QpIHRcbmVuZCA9XG5zdHJ1Y3RcbiAgZXh0ZXJuYWwgcmVyYWlzZSA6IGV4biAtPiAnYSA9IFwiJXJlcmFpc2VcIlxuXG4gIGxldCBkb250X3dhaXQgZiBoID1cbiAgICBsZXQgcCA9IHRyeSBmICgpIHdpdGggZXhuIC0+IGZhaWwgZXhuIGluXG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cblxuICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICAoKVxuICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICBoIGV4blxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgY2FsbGJhY2sgcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICAgICgpXG4gICAgICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICAgICAgaCBleG5cbiAgICAgIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrXG5cbiAgbGV0IGFzeW5jIGYgPVxuICAgIGxldCBwID0gdHJ5IGYgKCkgd2l0aCBleG4gLT4gZmFpbCBleG4gaW5cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuXG4gICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICgpXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICFhc3luY19leGNlcHRpb25faG9vayBleG5cblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IGNhbGxiYWNrIHJlc3VsdCA9XG4gICAgICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICAgICAoKVxuICAgICAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgICAgICFhc3luY19leGNlcHRpb25faG9vayBleG5cbiAgICAgIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrXG5cbiAgbGV0IGlnbm9yZV9yZXN1bHQgcCA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cblxuICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICAoKVxuICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICByZXJhaXNlIGV4blxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgY2FsbGJhY2sgcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICAgICgpXG4gICAgICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICAgICAgIWFzeW5jX2V4Y2VwdGlvbl9ob29rIGV4blxuICAgICAgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2tcblxuXG5cbiAgbGV0IGpvaW4gcHMgPVxuICAgIGxldCBwJyA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihwcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgcHMpIGluXG5cbiAgICBsZXQgbnVtYmVyX3BlbmRpbmdfaW5fcHMgPSByZWYgMCBpblxuICAgIGxldCBqb2luX3Jlc3VsdCA9IHJlZiAoRnVsZmlsbGVkICgpKSBpblxuXG4gICAgKCogQ2FsbGJhY2sgYXR0YWNoZWQgdG8gZWFjaCBwcm9taXNlIGluIFtwc10gdGhhdCBpcyBzdGlsbCBwZW5kaW5nIGF0IHRoZVxuICAgICAgIHRpbWUgW2pvaW5dIGlzIGNhbGxlZC4gKilcbiAgICBsZXQgY2FsbGJhY2sgbmV3X3Jlc3VsdCA9XG4gICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnID0gbWF5X25vd19iZV9wcm94eSBwJyBpblxuXG4gICAgICBiZWdpbiBtYXRjaCBuZXdfcmVzdWx0IHdpdGhcbiAgICAgIHwgRnVsZmlsbGVkICgpIC0+ICgpXG4gICAgICB8IFJlamVjdGVkIF8gLT5cbiAgICAgICgqIEZvciB0aGUgZmlyc3QgcHJvbWlzZSBpbiBbcHNdIHRvIGJlIHJlamVjdGVkLCBzZXQgdGhlIHJlc3VsdCBvZiB0aGVcbiAgICAgICAgIFtqb2luXSB0byByZWplY3RlZCB3aXRoIHRoZSBzYW1lIGV4Y2VwdGlvbi4uICopXG4gICAgICAgIG1hdGNoICFqb2luX3Jlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkICgpIC0+IGpvaW5fcmVzdWx0IDo9IG5ld19yZXN1bHRcbiAgICAgICAgfCBSZWplY3RlZCBfIC0+ICgpXG4gICAgICBlbmQ7XG5cbiAgICAgICgqIEluIGFsbCBjYXNlcywgZGVjcmVtZW50IHRoZSBudW1iZXIgb2YgcHJvbWlzZXMgc3RpbGwgcGVuZGluZywgYW5kXG4gICAgICAgICByZXNvbHZlIHRoZSBbam9pbl0gb25jZSBhbGwgcHJvbWlzZXMgcmVzb2x2ZS4gKilcbiAgICAgIG51bWJlcl9wZW5kaW5nX2luX3BzIDo9ICFudW1iZXJfcGVuZGluZ19pbl9wcyAtIDE7XG4gICAgICBpZiAhbnVtYmVyX3BlbmRpbmdfaW5fcHMgPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IHAnID0gdW5kZXJseWluZyBwJyBpblxuICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJyA9XG4gICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlICh1bmRlcmx5aW5nIHAnKSAham9pbl9yZXN1bHQgaW5cbiAgICAgICAgaWdub3JlIHAnXG4gICAgICBlbmRcbiAgICBpblxuXG4gICAgKCogQXR0YWNoIHRoZSBhYm92ZSBjYWxsYmFjay4gU2ltdWx0YW5lb3VzbHkgY291bnQgaG93IG1hbnkgcGVuZGluZyBwcm9taXNlc1xuICAgICAgIHRoZXJlIGFyZSBpbiBbcHNdIChpbml0aWFsbHkpLiBJZiB0aGF0IG51bWJlciBpcyB6ZXJvLCB0aGUgW2pvaW5dIG11c3RcbiAgICAgICByZXNvbHZlIGltbWVkaWF0ZWx5LiAqKVxuICAgIGxldCByZWMgYXR0YWNoX2NhbGxiYWNrX29yX3Jlc29sdmVfaW1tZWRpYXRlbHkgcHMgPVxuICAgICAgbWF0Y2ggcHMgd2l0aFxuICAgICAgfCBbXSAtPlxuICAgICAgICBpZiAhbnVtYmVyX3BlbmRpbmdfaW5fcHMgPSAwIHRoZW5cbiAgICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSAham9pbl9yZXN1bHR9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSBwJ1xuXG4gICAgICB8IHA6OnBzIC0+XG4gICAgICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG5cbiAgICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgICAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgICAgICBudW1iZXJfcGVuZGluZ19pbl9wcyA6PSAhbnVtYmVyX3BlbmRpbmdfaW5fcHMgKyAxO1xuICAgICAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICAgICAgYXR0YWNoX2NhbGxiYWNrX29yX3Jlc29sdmVfaW1tZWRpYXRlbHkgcHNcblxuICAgICAgICB8IFJlamVjdGVkIF8gYXMgcF9yZXN1bHQgLT5cbiAgICAgICAgICAoKiBBcyBpbiB0aGUgY2FsbGJhY2sgYWJvdmUsIGJ1dCBmb3IgYWxyZWFkeS1yZXNvbHZlZCBwcm9taXNlcyBpblxuICAgICAgICAgICAgIFtwc106IHJlamVjdCB0aGUgW2pvaW5dIHdpdGggdGhlIHNhbWUgZXhjZXB0aW9uIGFzIGluIHRoZSBmaXJzdFxuICAgICAgICAgICAgIHJlamVjdGVkIHByb21pc2UgZm91bmQuIFtqb2luXSBzdGlsbCB3YWl0cyBmb3IgYW55IHBlbmRpbmcgcHJvbWlzZXNcbiAgICAgICAgICAgICBiZWZvcmUgYWN0dWFsbHkgcmVzb2x2aW5nLCB0aG91Z2guICopXG4gICAgICAgICAgYmVnaW4gbWF0Y2ggIWpvaW5fcmVzdWx0IHdpdGhcbiAgICAgICAgICB8IEZ1bGZpbGxlZCAoKSAtPiBqb2luX3Jlc3VsdCA6PSBwX3Jlc3VsdDtcbiAgICAgICAgICB8IFJlamVjdGVkIF8gLT4gKClcbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgYXR0YWNoX2NhbGxiYWNrX29yX3Jlc29sdmVfaW1tZWRpYXRlbHkgcHNcblxuICAgICAgICB8IEZ1bGZpbGxlZCAoKSAtPlxuICAgICAgICAgIGF0dGFjaF9jYWxsYmFja19vcl9yZXNvbHZlX2ltbWVkaWF0ZWx5IHBzXG4gICAgaW5cblxuICAgIGF0dGFjaF9jYWxsYmFja19vcl9yZXNvbHZlX2ltbWVkaWF0ZWx5IHBzXG5cbiAgKCogdGhpcyBpcyAzIHdvcmRzLCBzbWFsbGVyIHRoYW4gdGhlIDIgdGltZXMgMiB3b3JkcyBhIHBhaXIgb2YgcmVmZXJlbmNlc1xuICAgICB3b3VsZCB0YWtlLiAqKVxuICB0eXBlICgnYSwnYikgcGFpciA9IHtcbiAgICBtdXRhYmxlIHgxOiAnYSBvcHRpb247XG4gICAgbXV0YWJsZSB4MjogJ2Igb3B0aW9uO1xuICB9XG5cbiAgbGV0IGJvdGggcDEgcDIgPVxuICAgIGxldCBwYWlyID0ge3gxID0gTm9uZTsgeDIgPSBOb25lfSBpblxuICAgIGxldCBwMScgPSBiaW5kIHAxIChmdW4gdiAtPiBwYWlyLngxIDwtIFNvbWUgdjsgcmV0dXJuX3VuaXQpIGluXG4gICAgbGV0IHAyJyA9IGJpbmQgcDIgKGZ1biB2IC0+IHBhaXIueDIgPC0gU29tZSB2OyByZXR1cm5fdW5pdCkgaW5cbiAgICBqb2luIFtwMSc7IHAyJ10gfD4gbWFwIChmdW4gKCkgLT5cbiAgICAgIG1hdGNoIHBhaXIueDEsIHBhaXIueDIgd2l0aFxuICAgICAgfCBTb21lIHYxLCBTb21lIHYyIC0+IHYxLCB2MlxuICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcblxuICBsZXQgYWxsIHBzID1cbiAgICBtYXRjaCBwcyB3aXRoXG4gICAgfCBbXSAtPiByZXR1cm5fbmlsXG4gICAgfCBbeF0gLT4gbWFwIChmdW4geSAtPiBbeV0pIHhcbiAgICB8IFt4OyB5XSAtPiBtYXAgKGZ1biAoeCwgeSkgLT4gW3g7IHldKSAoYm90aCB4IHkpXG4gICAgfCBfIC0+XG4gICAgICBsZXQgdnMgPSBBcnJheS5tYWtlIChMaXN0Lmxlbmd0aCBwcykgTm9uZSBpblxuICAgICAgcHNcbiAgICAgIHw+IExpc3QubWFwaSAoZnVuIGluZGV4IHAgLT5cbiAgICAgICAgYmluZCBwIChmdW4gdiAtPiB2cy4oaW5kZXgpIDwtIFNvbWUgdjsgcmV0dXJuX3VuaXQpKVxuICAgICAgfD4gam9pblxuICAgICAgfD4gbWFwIChmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgcmVjIHRvX2xpc3RfdW5vcHQgaSBhY2MgPVxuICAgICAgICAgICAgaWYgaSA8IDAgdGhlblxuICAgICAgICAgICAgICBhY2NcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggQXJyYXkudW5zYWZlX2dldCB2cyBpIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICAgICB8IFNvbWUgeCAtPiB0b19saXN0X3Vub3B0IChpIC0gMSkgKHg6OmFjYylcbiAgICAgICAgICBpblxuICAgICAgICAgIHRvX2xpc3RfdW5vcHQgKEFycmF5Lmxlbmd0aCB2cyAtIDEpIFtdKVxuXG4gICgqIE1haW50YWluZXIncyBub3RlOiB0aGUgbmV4dCBmZXcgZnVuY3Rpb25zIGFyZSBoZWxwZXJzIGZvciBbY2hvb3NlXSBhbmRcbiAgICAgW3BpY2tdLiBQZXJoYXBzIHRoZXkgc2hvdWxkIGJlIGZhY3RvcmVkIGludG8gc29tZSBraW5kIG9mIGdlbmVyaWNcbiAgICAgW2Nob29zZV0vW3BpY2tdIGltcGxlbWVudGF0aW9uLCB3aGljaCBtYXkgYWN0dWFsbHkgYmUgb3B0aW1hbCBhbnl3YXkgd2l0aFxuICAgICBGbGFtYmRhLiAqKVxuXG4gIGxldCBjb3VudF9yZXNvbHZlZF9wcm9taXNlc19pbiAocHMgOiAnYSB0IGxpc3QpID1cbiAgICBsZXQgcmVjIGNvdW50X2FuZF9nYXRoZXJfcmVqZWN0ZWQgdG90YWwgcmVqZWN0ZWQgcHMgPVxuICAgICAgIG1hdGNoIHBzIHdpdGhcbiAgICAgICB8IFtdIC0+IFJlc3VsdC5FcnJvciAodG90YWwsIHJlamVjdGVkKVxuICAgICAgIHwgcCA6OiBwcyAtPlxuICAgICAgICAgICAgbGV0IEludGVybmFsIHEgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICAgICAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHEpLnN0YXRlIHdpdGhcbiAgICAgICAgICAgIHwgRnVsZmlsbGVkIF8gLT4gY291bnRfYW5kX2dhdGhlcl9yZWplY3RlZCB0b3RhbCByZWplY3RlZCBwc1xuICAgICAgICAgICAgfCBSZWplY3RlZCBfIC0+IGNvdW50X2FuZF9nYXRoZXJfcmVqZWN0ZWQgKHRvdGFsICsgMSkgKHAgOjogcmVqZWN0ZWQpIHBzXG4gICAgICAgICAgICB8IFBlbmRpbmcgXyAtPiBjb3VudF9hbmRfZ2F0aGVyX3JlamVjdGVkIHRvdGFsIHJlamVjdGVkIHBzXG4gICAgaW5cbiAgICBsZXQgcmVjIGNvdW50X2Z1bGZpbGxlZCB0b3RhbCBwcyA9XG4gICAgICAgbWF0Y2ggcHMgd2l0aFxuICAgICAgIHwgW10gLT4gUmVzdWx0Lk9rIHRvdGFsXG4gICAgICAgfCBwIDo6IHBzIC0+XG4gICAgICAgICAgICBsZXQgSW50ZXJuYWwgcSA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcSkuc3RhdGUgd2l0aFxuICAgICAgICAgICAgfCBGdWxmaWxsZWQgXyAtPiBjb3VudF9mdWxmaWxsZWQgKHRvdGFsICsgMSkgcHNcbiAgICAgICAgICAgIHwgUmVqZWN0ZWQgXyAtPiBjb3VudF9hbmRfZ2F0aGVyX3JlamVjdGVkIDEgW3BdIHBzXG4gICAgICAgICAgICB8IFBlbmRpbmcgXyAtPiBjb3VudF9mdWxmaWxsZWQgdG90YWwgcHNcbiAgICBpblxuICAgIGNvdW50X2Z1bGZpbGxlZCAwIHBzXG5cbiAgKCogRXZhbHVhdGVzIHRvIHRoZSBbbl10aCBwcm9taXNlIGluIFtwc10sIGFtb25nIG9ubHkgdGhvc2UgcHJvbWlzZXMgaW4gW3BzXVxuICAgICB0aGF0IGFyZSByZXNvbHZlZC4gVGhlIGNhbGxlciBpcyBleHBlY3RlZCB0byBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgYXRcbiAgICAgbGVhc3QgW25dIHJlc29sdmVkIHByb21pc2VzIGluIFtwc10uICopXG4gIGxldCByZWMgbnRoX3Jlc29sdmVkIChwcyA6ICdhIHQgbGlzdCkgKG4gOiBpbnQpIDogJ2EgdCA9XG4gICAgbWF0Y2ggcHMgd2l0aFxuICAgIHwgW10gLT5cbiAgICAgIGFzc2VydCBmYWxzZVxuXG4gICAgfCBwOjpwcyAtPlxuICAgICAgbGV0IEludGVybmFsIHAnID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICBtYXRjaCAodW5kZXJseWluZyBwJykuc3RhdGUgd2l0aFxuICAgICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgICAgbnRoX3Jlc29sdmVkIHBzIG5cblxuICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICBpZiBuIDw9IDAgdGhlbiBwXG4gICAgICAgIGVsc2UgbnRoX3Jlc29sdmVkIHBzIChuIC0gMSlcbiAgICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgICBpZiBuIDw9IDAgdGhlbiBwXG4gICAgICAgIGVsc2UgbnRoX3Jlc29sdmVkIHBzIChuIC0gMSlcblxuICAoKiBMaWtlIFtudGhfcmVzb2x2ZWRdLCBidXQgY2FuY2VscyBhbGwgcGVuZGluZyBwcm9taXNlcyBmb3VuZCB3aGlsZVxuICAgICB0cmF2ZXJzaW5nIFtwc10uICopXG4gIGxldCByZWMgbnRoX3Jlc29sdmVkX2FuZF9jYW5jZWxfcGVuZGluZyAocHMgOiAnYSB0IGxpc3QpIChuIDogaW50KSA6ICdhIHQgPVxuICAgIG1hdGNoIHBzIHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICBhc3NlcnQgZmFsc2VcblxuICAgIHwgcDo6cHMgLT5cbiAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCcpLnN0YXRlIHdpdGhcbiAgICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICAgIGNhbmNlbCBwO1xuICAgICAgICBudGhfcmVzb2x2ZWRfYW5kX2NhbmNlbF9wZW5kaW5nIHBzIG5cblxuICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICBpZiBuIDw9IDAgdGhlbiAoTGlzdC5pdGVyIGNhbmNlbCBwczsgcClcbiAgICAgICAgZWxzZSBudGhfcmVzb2x2ZWRfYW5kX2NhbmNlbF9wZW5kaW5nIHBzIChuIC0gMSlcbiAgICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgICBpZiBuIDw9IDAgdGhlbiAoTGlzdC5pdGVyIGNhbmNlbCBwczsgcClcbiAgICAgICAgZWxzZSBudGhfcmVzb2x2ZWRfYW5kX2NhbmNlbF9wZW5kaW5nIHBzIChuIC0gMSlcblxuICAoKiBUaGUgUFJORyBzdGF0ZSBpcyBpbml0aWFsaXplZCB3aXRoIGEgY29uc3RhbnQgdG8gbWFrZSBub24tSU8tYmFzZWQgcHJvZ3JhbXNcbiAgICAgZGV0ZXJtaW5pc3RpYy4gKilcbiAgKCogTWFpbnRhaW5lcidzIG5vdGU6IGlzIHRoaXMgbmVjZXNzYXJ5PyAqKVxuICBsZXQgcHJuZyA9IGxhenkgKFJhbmRvbS5TdGF0ZS5tYWtlIFt8fF0pXG5cbiAgbGV0IGNob29zZSBwcyA9XG4gICAgaWYgcHMgPSBbXSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZ1xuICAgICAgICBcIkx3dC5jaG9vc2UgW10gd291bGQgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIHBlbmRpbmcgZm9yZXZlclwiO1xuICAgIG1hdGNoIGNvdW50X3Jlc29sdmVkX3Byb21pc2VzX2luIHBzIHdpdGhcbiAgICB8IFJlc3VsdC5PayAwIC0+XG4gICAgICBsZXQgcCA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihwcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgcHMpIGluXG5cbiAgICAgIGxldCBjYWxsYmFjayByZXN1bHQgPVxuICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAgPSBtYXlfbm93X2JlX3Byb3h5IHAgaW5cbiAgICAgICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cbiAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCA9XG4gICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHAgcmVzdWx0IGluXG4gICAgICAgIGlnbm9yZSBwXG4gICAgICBpblxuICAgICAgYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX3RvX2VhY2hfb2YgcHMgY2FsbGJhY2s7XG5cbiAgICAgIHRvX3B1YmxpY19wcm9taXNlIHBcblxuICAgIHwgUmVzdWx0Lk9rIDEgLT5cbiAgICAgIG50aF9yZXNvbHZlZCBwcyAwXG5cbiAgICB8IFJlc3VsdC5PayBuIC0+XG4gICAgICBudGhfcmVzb2x2ZWQgcHMgKFJhbmRvbS5TdGF0ZS5pbnQgKExhenkuZm9yY2UgcHJuZykgbilcblxuICAgIHwgUmVzdWx0LkVycm9yIChuLCBwcykgLT5cbiAgICAgIG50aF9yZXNvbHZlZCBwcyAoUmFuZG9tLlN0YXRlLmludCAoTGF6eS5mb3JjZSBwcm5nKSBuKVxuXG4gIGxldCBwaWNrIHBzID1cbiAgICBpZiBwcyA9IFtdIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiTHd0LnBpY2sgW10gd291bGQgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIHBlbmRpbmcgZm9yZXZlclwiO1xuICAgIG1hdGNoIGNvdW50X3Jlc29sdmVkX3Byb21pc2VzX2luIHBzIHdpdGhcbiAgICB8IE9rIDAgLT5cbiAgICAgIGxldCBwID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KHByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCBwcykgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHJlc3VsdCA9XG4gICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCA9IG1heV9ub3dfYmVfcHJveHkgcCBpblxuICAgICAgICBMaXN0Lml0ZXIgY2FuY2VsIHBzO1xuICAgICAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwID1cbiAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCByZXN1bHQgaW5cbiAgICAgICAgaWdub3JlIHBcbiAgICAgIGluXG4gICAgICBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfdG9fZWFjaF9vZiBwcyBjYWxsYmFjaztcblxuICAgICAgdG9fcHVibGljX3Byb21pc2UgcFxuXG4gICAgfCBPayAxIC0+XG4gICAgICBudGhfcmVzb2x2ZWRfYW5kX2NhbmNlbF9wZW5kaW5nIHBzIDBcblxuICAgIHwgT2sgbiAtPlxuICAgICAgbnRoX3Jlc29sdmVkX2FuZF9jYW5jZWxfcGVuZGluZyBwc1xuICAgICAgICAoUmFuZG9tLlN0YXRlLmludCAoTGF6eS5mb3JjZSBwcm5nKSBuKVxuXG4gICAgfCBFcnJvciAobiwgcXMpIC0+XG4gICAgICBMaXN0Lml0ZXIgY2FuY2VsIHBzO1xuICAgICAgbnRoX3Jlc29sdmVkIHFzIChSYW5kb20uU3RhdGUuaW50IChMYXp5LmZvcmNlIHBybmcpIG4pXG5cblxuXG4gICgqIElmIFtuY2hvb3NlIHBzXSBvciBbbnBpY2sgcHNdIGZvdW5kIGFsbCBwcm9taXNlcyBpbiBbcHNdIHBlbmRpbmcsIHRoZVxuICAgICBjYWxsYmFjayBhZGRlZCB0byBlYWNoIHByb21pc2UgaW4gW3BzXSBldmVudHVhbGx5IGNhbGxzIHRoaXMgZnVuY3Rpb24uIFRoZVxuICAgICBmdW5jdGlvbiBjb2xsZWN0cyBwcm9taXNlcyBpbiBbcHNdIHRoYXQgaGF2ZSBiZWNvbWUgZnVsZmlsbGVkLCBvciBmaW5kcyBvbmVcbiAgICAgcHJvbWlzZSBpbiBbcHNdIHRoYXQgaGFzIGJlZW4gcmVqZWN0ZWQuIEl0IHRoZW4gcmV0dXJucyB0aGUgZGVzaXJlZCBzdGF0ZVxuICAgICBvZiB0aGUgZmluYWwgcHJvbWlzZTogZWl0aGVyIHRoZSBsaXN0IG9mIHJlc3VsdHMgY29sbGVjdGVkLCBvciB0aGVcbiAgICAgZXhjZXB0aW9uIGZvdW5kLiAqKVxuICBsZXQgcmVjIGNvbGxlY3RfZnVsZmlsbGVkX3Byb21pc2VzX2FmdGVyX3BlbmRpbmdcbiAgICAgIChyZXN1bHRzIDogJ2EgbGlzdClcbiAgICAgIChwcyA6ICdhIHQgbGlzdCkgOlxuICAgICAgICAoJ2EgbGlzdCByZXNvbHZlZF9zdGF0ZSkgPVxuXG4gICAgbWF0Y2ggcHMgd2l0aFxuICAgIHwgW10gLT5cbiAgICAgIEZ1bGZpbGxlZCAoTGlzdC5yZXYgcmVzdWx0cylcblxuICAgIHwgcDo6cHMgLT5cbiAgICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG5cbiAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgY29sbGVjdF9mdWxmaWxsZWRfcHJvbWlzZXNfYWZ0ZXJfcGVuZGluZyAodjo6cmVzdWx0cykgcHNcblxuICAgICAgfCBSZWplY3RlZCBfIGFzIHJlc3VsdCAtPlxuICAgICAgICByZXN1bHRcblxuICAgICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgICAgY29sbGVjdF9mdWxmaWxsZWRfcHJvbWlzZXNfYWZ0ZXJfcGVuZGluZyByZXN1bHRzIHBzXG5cbiAgbGV0IG5jaG9vc2UgcHMgPVxuICAgICgqIElmIGF0IGxlYXN0IG9uZSBwcm9taXNlIGluIFtwc10gaXMgZm91bmQgZnVsZmlsbGVkLCB0aGlzIGZ1bmN0aW9uIGlzXG4gICAgICAgY2FsbGVkIHRvIGZpbmQgYWxsIHN1Y2ggcHJvbWlzZXMuICopXG4gICAgaWYgcHMgPSBbXSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZ1xuICAgICAgICBcIkx3dC5uY2hvb3NlIFtdIHdvdWxkIHJldHVybiBhIHByb21pc2UgdGhhdCBpcyBwZW5kaW5nIGZvcmV2ZXJcIjtcbiAgICBsZXQgcmVjIGNvbGxlY3RfYWxyZWFkeV9mdWxmaWxsZWRfcHJvbWlzZXNfb3JfZmluZF9yZWplY3RlZCBhY2MgcHMgPVxuICAgICAgbWF0Y2ggcHMgd2l0aFxuICAgICAgfCBbXSAtPlxuICAgICAgICByZXR1cm4gKExpc3QucmV2IGFjYylcblxuICAgICAgfCBwOjpwcyAtPlxuICAgICAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjb2xsZWN0X2FscmVhZHlfZnVsZmlsbGVkX3Byb21pc2VzX29yX2ZpbmRfcmVqZWN0ZWQgKHY6OmFjYykgcHNcblxuICAgICAgICB8IFJlamVjdGVkIF8gYXMgcmVzdWx0IC0+XG4gICAgICAgICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gcmVzdWx0fVxuXG4gICAgICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICAgICAgY29sbGVjdF9hbHJlYWR5X2Z1bGZpbGxlZF9wcm9taXNlc19vcl9maW5kX3JlamVjdGVkIGFjYyBwc1xuICAgIGluXG5cbiAgICAoKiBMb29rcyBmb3IgYWxyZWFkeS1yZXNvbHZlZCBwcm9taXNlcyBpbiBbcHNdLiBJZiBub25lIGFyZSBmdWxmaWxsZWQgb3JcbiAgICAgICByZWplY3RlZCwgYWRkcyBhIGNhbGxiYWNrIHRvIGFsbCBwcm9taXNlcyBpbiBbcHNdIChhbGwgb2Ygd2hpY2ggYXJlXG4gICAgICAgcGVuZGluZykuICopXG4gICAgbGV0IHJlYyBjaGVja19mb3JfYWxyZWFkeV9yZXNvbHZlZF9wcm9taXNlcyBwcycgPVxuICAgICAgbWF0Y2ggcHMnIHdpdGhcbiAgICAgIHwgW10gLT5cbiAgICAgICAgbGV0IHAgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDoocHJvcGFnYXRlX2NhbmNlbF90b19zZXZlcmFsIHBzKSBpblxuXG4gICAgICAgIGxldCBjYWxsYmFjayBfcmVzdWx0ID1cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAgPSBtYXlfbm93X2JlX3Byb3h5IHAgaW5cbiAgICAgICAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuICAgICAgICAgIGxldCByZXN1bHQgPSBjb2xsZWN0X2Z1bGZpbGxlZF9wcm9taXNlc19hZnRlcl9wZW5kaW5nIFtdIHBzIGluXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCA9XG4gICAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCByZXN1bHQgaW5cbiAgICAgICAgICBpZ25vcmUgcFxuICAgICAgICBpblxuICAgICAgICBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfdG9fZWFjaF9vZiBwcyBjYWxsYmFjaztcblxuICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSBwXG5cbiAgICAgIHwgcDo6cHMgLT5cbiAgICAgICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY29sbGVjdF9hbHJlYWR5X2Z1bGZpbGxlZF9wcm9taXNlc19vcl9maW5kX3JlamVjdGVkIFt2XSBwc1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyBhcyByZXN1bHQgLT5cbiAgICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSByZXN1bHR9XG5cbiAgICAgICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgICAgICBjaGVja19mb3JfYWxyZWFkeV9yZXNvbHZlZF9wcm9taXNlcyBwc1xuICAgIGluXG5cbiAgICBsZXQgcCA9IGNoZWNrX2Zvcl9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIHBzIGluXG4gICAgcFxuXG4gICgqIFNlZSBbbmNob29zZV0uIFRoaXMgZnVuY3Rpb24gZGlmZmVycyBvbmx5IGluIGhhdmluZyBhZGRpdGlvbmFsIGNhbGxzIHRvXG4gICAgIFtjYW5jZWxdLiAqKVxuICBsZXQgbnBpY2sgcHMgPVxuICAgIGlmIHBzID0gW10gdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJMd3QubnBpY2sgW10gd291bGQgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIHBlbmRpbmcgZm9yZXZlclwiO1xuICAgIGxldCByZWMgY29sbGVjdF9hbHJlYWR5X2Z1bGZpbGxlZF9wcm9taXNlc19vcl9maW5kX3JlamVjdGVkIGFjYyBwcycgPVxuICAgICAgbWF0Y2ggcHMnIHdpdGhcbiAgICAgIHwgW10gLT5cbiAgICAgICAgTGlzdC5pdGVyIGNhbmNlbCBwcztcbiAgICAgICAgcmV0dXJuIChMaXN0LnJldiBhY2MpXG5cbiAgICAgIHwgcDo6cHMnIC0+XG4gICAgICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGNvbGxlY3RfYWxyZWFkeV9mdWxmaWxsZWRfcHJvbWlzZXNfb3JfZmluZF9yZWplY3RlZCAodjo6YWNjKSBwcydcblxuICAgICAgICB8IFJlamVjdGVkIF8gYXMgcmVzdWx0IC0+XG4gICAgICAgICAgTGlzdC5pdGVyIGNhbmNlbCBwcztcbiAgICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSByZXN1bHR9XG5cbiAgICAgICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgICAgICBjb2xsZWN0X2FscmVhZHlfZnVsZmlsbGVkX3Byb21pc2VzX29yX2ZpbmRfcmVqZWN0ZWQgYWNjIHBzJ1xuICAgIGluXG5cbiAgICBsZXQgcmVjIGNoZWNrX2Zvcl9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIHBzJyA9XG4gICAgICBtYXRjaCBwcycgd2l0aFxuICAgICAgfCBbXSAtPlxuICAgICAgICBsZXQgcCA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihwcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgcHMpIGluXG5cbiAgICAgICAgbGV0IGNhbGxiYWNrIF9yZXN1bHQgPVxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCA9IG1heV9ub3dfYmVfcHJveHkgcCBpblxuICAgICAgICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGNvbGxlY3RfZnVsZmlsbGVkX3Byb21pc2VzX2FmdGVyX3BlbmRpbmcgW10gcHMgaW5cbiAgICAgICAgICBMaXN0Lml0ZXIgY2FuY2VsIHBzO1xuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAgPVxuICAgICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHAgcmVzdWx0IGluXG4gICAgICAgICAgaWdub3JlIHBcbiAgICAgICAgaW5cbiAgICAgICAgYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX3RvX2VhY2hfb2YgcHMgY2FsbGJhY2s7XG5cbiAgICAgICAgdG9fcHVibGljX3Byb21pc2UgcFxuXG4gICAgICB8IHA6OnBzJyAtPlxuICAgICAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjb2xsZWN0X2FscmVhZHlfZnVsZmlsbGVkX3Byb21pc2VzX29yX2ZpbmRfcmVqZWN0ZWQgW3ZdIHBzJ1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyBhcyByZXN1bHQgLT5cbiAgICAgICAgICBMaXN0Lml0ZXIgY2FuY2VsIHBzO1xuICAgICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IHJlc3VsdH1cblxuICAgICAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgICAgIGNoZWNrX2Zvcl9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIHBzJ1xuICAgIGluXG5cbiAgICBsZXQgcCA9IGNoZWNrX2Zvcl9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIHBzIGluXG4gICAgcFxuXG5cblxuICAoKiBTYW1lIGdlbmVyYWwgcGF0dGVybiBhcyBbbnBpY2tdIGFuZCBbbmNob29zZV0uICopXG4gIGxldCBuY2hvb3NlX3NwbGl0IHBzID1cbiAgICBpZiBwcyA9IFtdIHRoZW5cbiAgICAgIGludmFsaWRfYXJnXG4gICAgICAgIFwiTHd0Lm5jaG9vc2Vfc3BsaXQgW10gd291bGQgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIHBlbmRpbmcgZm9yZXZlclwiO1xuICAgIGxldCByZWMgZmluaXNoXG4gICAgICAgICh0b19yZXNvbHZlIDogKCdhIGxpc3QgKiAnYSB0IGxpc3QsIHVuZGVybHlpbmcsIHBlbmRpbmcpIHByb21pc2UpXG4gICAgICAgIChmdWxmaWxsZWQgOiAnYSBsaXN0KVxuICAgICAgICAocGVuZGluZyA6ICdhIHQgbGlzdClcbiAgICAgICAgKHBzIDogJ2EgdCBsaXN0KVxuICAgICAgICAgIDogKCdhIGxpc3QgKiAnYSB0IGxpc3QsIHVuZGVybHlpbmcsIHJlc29sdmVkKSBzdGF0ZV9jaGFuZ2VkID1cblxuICAgICAgbWF0Y2ggcHMgd2l0aFxuICAgICAgfCBbXSAtPlxuICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgdG9fcmVzb2x2ZVxuICAgICAgICAgIChGdWxmaWxsZWQgKExpc3QucmV2IGZ1bGZpbGxlZCwgTGlzdC5yZXYgcGVuZGluZykpXG5cbiAgICAgIHwgcDo6cHMgLT5cbiAgICAgICAgbGV0IEludGVybmFsIHBfaW50ZXJuYWwgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcF9pbnRlcm5hbCkuc3RhdGUgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgZmluaXNoIHRvX3Jlc29sdmUgKHY6OmZ1bGZpbGxlZCkgcGVuZGluZyBwc1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyBhcyByZXN1bHQgLT5cbiAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgdG9fcmVzb2x2ZSByZXN1bHRcblxuICAgICAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgICAgIGZpbmlzaCB0b19yZXNvbHZlIGZ1bGZpbGxlZCAocDo6cGVuZGluZykgcHNcbiAgICBpblxuXG4gICAgbGV0IHJlYyBjb2xsZWN0X2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgcmVzdWx0cyBwZW5kaW5nIHBzID1cbiAgICAgIG1hdGNoIHBzIHdpdGhcbiAgICAgIHwgW10gLT5cbiAgICAgICAgKCogTWFpbnRhaW5lcidzIG5vdGU6IHNob3VsZCB0aGUgcGVuZGluZyBwcm9taXNlIGxpc3QgYWxzbyBiZVxuICAgICAgICAgICByZXZlcnNlZD8gSXQgaXMgcmV2ZXJzZWQgaW4gZmluaXNoLiAqKVxuICAgICAgICByZXR1cm4gKExpc3QucmV2IHJlc3VsdHMsIHBlbmRpbmcpXG5cbiAgICAgIHwgcDo6cHMgLT5cbiAgICAgICAgbGV0IEludGVybmFsIHBfaW50ZXJuYWwgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcF9pbnRlcm5hbCkuc3RhdGUgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY29sbGVjdF9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzICh2OjpyZXN1bHRzKSBwZW5kaW5nIHBzXG5cbiAgICAgICAgfCBSZWplY3RlZCBfIGFzIHJlc3VsdCAtPlxuICAgICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IHJlc3VsdH1cblxuICAgICAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgICAgIGNvbGxlY3RfYWxyZWFkeV9yZXNvbHZlZF9wcm9taXNlcyByZXN1bHRzIChwOjpwZW5kaW5nKSBwc1xuICAgIGluXG5cbiAgICBsZXQgcmVjIGNoZWNrX2Zvcl9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIHBlbmRpbmdfYWNjIHBzJyA9XG4gICAgICBtYXRjaCBwcycgd2l0aFxuICAgICAgfCBbXSAtPlxuICAgICAgICBsZXQgcCA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihwcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgcHMpIGluXG5cbiAgICAgICAgbGV0IGNhbGxiYWNrIF9yZXN1bHQgPVxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCA9IG1heV9ub3dfYmVfcHJveHkgcCBpblxuICAgICAgICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCA9IGZpbmlzaCBwIFtdIFtdIHBzIGluXG4gICAgICAgICAgaWdub3JlIHBcbiAgICAgICAgaW5cbiAgICAgICAgYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX3RvX2VhY2hfb2YgcHMgY2FsbGJhY2s7XG5cbiAgICAgICAgdG9fcHVibGljX3Byb21pc2UgcFxuXG4gICAgICB8IHA6OnBzJyAtPlxuICAgICAgICBsZXQgSW50ZXJuYWwgcF9pbnRlcm5hbCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgICBtYXRjaCAodW5kZXJseWluZyBwX2ludGVybmFsKS5zdGF0ZSB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjb2xsZWN0X2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgW3ZdIHBlbmRpbmdfYWNjIHBzJ1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyBhcyByZXN1bHQgLT5cbiAgICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSByZXN1bHR9XG5cbiAgICAgICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgICAgICBjaGVja19mb3JfYWxyZWFkeV9yZXNvbHZlZF9wcm9taXNlcyAocDo6cGVuZGluZ19hY2MpIHBzJ1xuICAgIGluXG5cbiAgICBsZXQgcCA9IGNoZWNrX2Zvcl9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIFtdIHBzIGluXG4gICAgcFxuZW5kXG5pbmNsdWRlIENvbmN1cnJlbnRfY29tcG9zaXRpb25cblxuXG5cbm1vZHVsZSBNaXNjZWxsYW5lb3VzIDpcbnNpZ1xuICAoKiBQcm9taXNlIHN0YXRlIHF1ZXJ5ICopXG4gIHR5cGUgJ2Egc3RhdGUgPVxuICAgIHwgUmV0dXJuIG9mICdhXG4gICAgfCBGYWlsIG9mIGV4blxuICAgIHwgU2xlZXBcblxuICB2YWwgc3RhdGUgOiAnYSB0IC0+ICdhIHN0YXRlXG4gIHZhbCBpc19zbGVlcGluZyA6ICdhIHQgLT4gYm9vbFxuICB2YWwgZGVidWdfc3RhdGVfaXMgOiAnYSBzdGF0ZSAtPiAnYSB0IC0+IGJvb2wgdFxuXG4gICgqIEZ1bmN0aW9uIGxpZnRlcnMgKilcbiAgdmFsIGFwcGx5IDogKCdhIC0+ICdiIHQpIC0+ICdhIC0+ICdiIHRcblxuICB2YWwgd3JhcCA6XG4gICAgKHVuaXQgLT4gJ2IpIC0+XG4gICAgJ2IgdFxuICB2YWwgd3JhcDEgOlxuICAgICgnYTEgLT4gJ2IpIC0+XG4gICAgKCdhMSAtPiAnYiB0KVxuICB2YWwgd3JhcDIgOlxuICAgICgnYTEgLT4gJ2EyIC0+ICdiKSAtPlxuICAgICgnYTEgLT4gJ2EyIC0+ICdiIHQpXG4gIHZhbCB3cmFwMyA6XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdiKSAtPlxuICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYiB0KVxuICB2YWwgd3JhcDQgOlxuICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYTQgLT4gJ2IpIC0+XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYiB0KVxuICB2YWwgd3JhcDUgOlxuICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYTQgLT4gJ2E1IC0+ICdiKSAtPlxuICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYTQgLT4gJ2E1IC0+ICdiIHQpXG4gIHZhbCB3cmFwNiA6XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYTUgLT4gJ2E2IC0+ICdiKSAtPlxuICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYTQgLT4gJ2E1IC0+ICdhNiAtPiAnYiB0KVxuICB2YWwgd3JhcDcgOlxuICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYTQgLT4gJ2E1IC0+ICdhNiAtPiAnYTcgLT4gJ2IpIC0+XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYTUgLT4gJ2E2IC0+ICdhNyAtPiAnYiB0KVxuXG4gICgqIFBhdXNlZCBwcm9taXNlcyAqKVxuICB2YWwgcGF1c2UgOiB1bml0IC0+IHVuaXQgdFxuICB2YWwgd2FrZXVwX3BhdXNlZCA6IHVuaXQgLT4gdW5pdFxuICB2YWwgcGF1c2VkX2NvdW50IDogdW5pdCAtPiBpbnRcbiAgdmFsIHJlZ2lzdGVyX3BhdXNlX25vdGlmaWVyIDogKGludCAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBhYmFuZG9uX3BhdXNlZCA6IHVuaXQgLT4gdW5pdFxuXG4gICgqIEludGVybmFsIGludGVyZmFjZSBmb3Igb3RoZXIgbW9kdWxlcyBpbiBMd3QgKilcbiAgdmFsIHBvbGwgOiAnYSB0IC0+ICdhIG9wdGlvblxuZW5kID1cbnN0cnVjdFxuICB0eXBlICdhIHN0YXRlID1cbiAgICB8IFJldHVybiBvZiAnYVxuICAgIHwgRmFpbCBvZiBleG5cbiAgICB8IFNsZWVwXG5cbiAgZXh0ZXJuYWwgcmVyYWlzZSA6IGV4biAtPiAnYSA9IFwiJXJlcmFpc2VcIlxuXG4gIGxldCBzdGF0ZSBwID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCB2IC0+IFJldHVybiB2XG4gICAgfCBSZWplY3RlZCBleG4gLT4gRmFpbCBleG5cbiAgICB8IFBlbmRpbmcgXyAtPiBTbGVlcFxuXG4gIGxldCBkZWJ1Z19zdGF0ZV9pcyBleHBlY3RlZF9zdGF0ZSBwID1cbiAgICByZXR1cm4gKHN0YXRlIHAgPSBleHBlY3RlZF9zdGF0ZSlcblxuICBsZXQgaXNfc2xlZXBpbmcgcCA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPiBmYWxzZVxuICAgIHwgUmVqZWN0ZWQgXyAtPiBmYWxzZVxuICAgIHwgUGVuZGluZyBfIC0+IHRydWVcblxuICBsZXQgcG9sbCBwID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICB8IFJlamVjdGVkIGUgLT4gcmVyYWlzZSBlXG4gICAgfCBGdWxmaWxsZWQgdiAtPiBTb21lIHZcbiAgICB8IFBlbmRpbmcgXyAtPiBOb25lXG5cblxuXG4gIGxldCBhcHBseSBmIHggPSB0cnkgZiB4IHdpdGggZXhuIC0+IGZhaWwgZXhuXG5cbiAgbGV0IHdyYXAgZiA9IHRyeSByZXR1cm4gKGYgKCkpIHdpdGggZXhuIC0+IGZhaWwgZXhuXG5cbiAgbGV0IHdyYXAxIGYgeDEgPVxuICAgIHRyeSByZXR1cm4gKGYgeDEpXG4gICAgd2l0aCBleG4gLT4gZmFpbCBleG5cblxuICBsZXQgd3JhcDIgZiB4MSB4MiA9XG4gICAgdHJ5IHJldHVybiAoZiB4MSB4MilcbiAgICB3aXRoIGV4biAtPiBmYWlsIGV4blxuXG4gIGxldCB3cmFwMyBmIHgxIHgyIHgzID1cbiAgICB0cnkgcmV0dXJuIChmIHgxIHgyIHgzKVxuICAgIHdpdGggZXhuIC0+IGZhaWwgZXhuXG5cbiAgbGV0IHdyYXA0IGYgeDEgeDIgeDMgeDQgPVxuICAgIHRyeSByZXR1cm4gKGYgeDEgeDIgeDMgeDQpXG4gICAgd2l0aCBleG4gLT4gZmFpbCBleG5cblxuICBsZXQgd3JhcDUgZiB4MSB4MiB4MyB4NCB4NSA9XG4gICAgdHJ5IHJldHVybiAoZiB4MSB4MiB4MyB4NCB4NSlcbiAgICB3aXRoIGV4biAtPiBmYWlsIGV4blxuXG4gIGxldCB3cmFwNiBmIHgxIHgyIHgzIHg0IHg1IHg2ID1cbiAgICB0cnkgcmV0dXJuIChmIHgxIHgyIHgzIHg0IHg1IHg2KVxuICAgIHdpdGggZXhuIC0+IGZhaWwgZXhuXG5cbiAgbGV0IHdyYXA3IGYgeDEgeDIgeDMgeDQgeDUgeDYgeDcgPVxuICAgIHRyeSByZXR1cm4gKGYgeDEgeDIgeDMgeDQgeDUgeDYgeDcpXG4gICAgd2l0aCBleG4gLT4gZmFpbCBleG5cblxuXG5cbiAgbGV0IHBhdXNlX2hvb2sgPSByZWYgaWdub3JlXG5cbiAgbGV0IHBhdXNlZCA9IEx3dF9zZXF1ZW5jZS5jcmVhdGUgKClcbiAgbGV0IHBhdXNlZF9jb3VudCA9IHJlZiAwXG5cbiAgbGV0IHBhdXNlICgpID1cbiAgICBsZXQgcCA9IGFkZF90YXNrX3IgcGF1c2VkIGluXG4gICAgaW5jciBwYXVzZWRfY291bnQ7XG4gICAgIXBhdXNlX2hvb2sgIXBhdXNlZF9jb3VudDtcbiAgICBwXG5cbiAgbGV0IHdha2V1cF9wYXVzZWQgKCkgPVxuICAgIGlmIEx3dF9zZXF1ZW5jZS5pc19lbXB0eSBwYXVzZWQgdGhlblxuICAgICAgcGF1c2VkX2NvdW50IDo9IDBcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgdG1wID0gTHd0X3NlcXVlbmNlLmNyZWF0ZSAoKSBpblxuICAgICAgTHd0X3NlcXVlbmNlLnRyYW5zZmVyX3IgcGF1c2VkIHRtcDtcbiAgICAgIHBhdXNlZF9jb3VudCA6PSAwO1xuICAgICAgTHd0X3NlcXVlbmNlLml0ZXJfbCAoZnVuIHIgLT4gd2FrZXVwIHIgKCkpIHRtcFxuICAgIGVuZFxuXG4gIGxldCByZWdpc3Rlcl9wYXVzZV9ub3RpZmllciBmID0gcGF1c2VfaG9vayA6PSBmXG5cbiAgbGV0IGFiYW5kb25fcGF1c2VkICgpID1cbiAgICBMd3Rfc2VxdWVuY2UuY2xlYXIgcGF1c2VkO1xuICAgIHBhdXNlZF9jb3VudCA6PSAwXG5cbiAgbGV0IHBhdXNlZF9jb3VudCAoKSA9ICFwYXVzZWRfY291bnRcbmVuZFxuaW5jbHVkZSBNaXNjZWxsYW5lb3VzXG5cbm1vZHVsZSBMZXRfc3ludGF4ID1cbnN0cnVjdFxuICBtb2R1bGUgTGV0X3N5bnRheCA9XG4gIHN0cnVjdFxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICBsZXQgbWFwIHQgfmYgPSBtYXAgZiB0XG4gICAgbGV0IGJpbmQgdCB+ZiA9IGJpbmQgdCBmXG4gICAgbGV0IGJvdGggPSBib3RoXG5cbiAgICBtb2R1bGUgT3Blbl9vbl9yaHMgPVxuICAgIHN0cnVjdFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgSW5maXggPVxuc3RydWN0XG4gIGxldCAoPj49KSA9IGJpbmRcbiAgbGV0ICg9PDwpIGYgcCA9IGJpbmQgcCBmXG4gIGxldCAoPnw9KSBwIGYgPSBtYXAgZiBwXG4gIGxldCAoPXw8KSA9IG1hcFxuICBsZXQgKDwmPikgcCBwJyA9IGpvaW4gW3A7IHAnXVxuICBsZXQgKDw/PikgcCBwJyA9IGNob29zZSBbcDsgcCddXG5cbiAgaW5jbHVkZSBMZXRfc3ludGF4XG5lbmRcbmluY2x1ZGUgKCBJbmZpeCA6IG1vZHVsZSB0eXBlIG9mIEluZml4IHdpdGggbW9kdWxlIExldF9zeW50YXggOj0gTGV0X3N5bnRheC5MZXRfc3ludGF4IClcblxubW9kdWxlIFN5bnRheCA9XG5zdHJ1Y3RcbiAgbGV0IChsZXQqKSA9IGJpbmRcbiAgbGV0IChhbmQqKSA9IGJvdGhcblxuICBsZXQgKGxldCspIHggZiA9IG1hcCBmIHhcbiAgbGV0IChhbmQrKSA9IGJvdGhcbmVuZFxuXG5cbm1vZHVsZSBMd3RfcmVzdWx0X3R5cGUgPVxuc3RydWN0XG4gIHR5cGUgKydhIHJlc3VsdCA9ICdhIGx3dF9yZXN1bHRcblxuICAoKiBEZXByZWNhdGVkLiAqKVxuICBsZXQgbWFrZV92YWx1ZSB2ID0gUmVzdWx0Lk9rIHZcbiAgbGV0IG1ha2VfZXJyb3IgZXhuID0gUmVzdWx0LkVycm9yIGV4blxuZW5kXG5pbmNsdWRlIEx3dF9yZXN1bHRfdHlwZVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogIE9jYW1sZ3JhcGg6IGEgZ2VuZXJpYyBncmFwaCBsaWJyYXJ5IGZvciBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogIENvcHlyaWdodCAoQykgMjAwNC0yMDEwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogIFN5bHZhaW4gQ29uY2hvbiwgSmVhbi1DaHJpc3RvcGhlIEZpbGxpYXRyZSBhbmQgSnVsaWVuIFNpZ25vbGVzICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogIFRoaXMgc29mdHdhcmUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yICAgICAgICAqKVxuKCogIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMaWJyYXJ5IEdlbmVyYWwgUHVibGljICAgICAgICAgICAqKVxuKCogIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgICAgICAgICAgICAqKVxuKCogIGRlc2NyaWJlZCBpbiBmaWxlIExJQ0VOU0UuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogIFRoaXMgc29mdHdhcmUgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgICAgICAqKVxuKCogIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mICAgICAgICAqKVxuKCogIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIFNpZ1xuXG5tb2R1bGUgT1RQcm9kdWN0KFg6IE9SREVSRURfVFlQRSkoWTogT1JERVJFRF9UWVBFKSA9IHN0cnVjdFxuICB0eXBlIHQgPSBYLnQgKiBZLnRcbiAgbGV0IGNvbXBhcmUgKHgxLCB5MSkgKHgyLCB5MikgPVxuICAgIGxldCBjdiA9IFguY29tcGFyZSB4MSB4MiBpblxuICAgIGlmIGN2ICE9IDAgdGhlbiBjdiBlbHNlIFkuY29tcGFyZSB5MSB5MlxuZW5kXG5cbm1vZHVsZSBIVFByb2R1Y3QoWDogSEFTSEFCTEUpKFk6IEhBU0hBQkxFKSA9IHN0cnVjdFxuICB0eXBlIHQgPSBYLnQgKiBZLnRcbiAgbGV0IGVxdWFsICh4MSwgeTEpICh4MiwgeTIpID0gWC5lcXVhbCB4MSB4MiAmJiBZLmVxdWFsIHkxIHkyXG4gIGxldCBoYXNoICh4LCB5KSA9IEhhc2h0YmwuaGFzaCAoWC5oYXNoIHgsIFkuaGFzaCB5KVxuZW5kXG5cbm1vZHVsZSBDTVBQcm9kdWN0KFg6IENPTVBBUkFCTEUpKFk6IENPTVBBUkFCTEUpID0gc3RydWN0XG4gIGluY2x1ZGUgSFRQcm9kdWN0KFgpKFkpXG4gIGluY2x1ZGUgKE9UUHJvZHVjdChYKShZKTogc2lnIHZhbCBjb21wYXJlIDogdCAtPiB0IC0+IGludCBlbmQpXG5lbmRcblxubW9kdWxlIERhdGFWKEwgOiBzaWcgdHlwZSB0IGVuZCkoViA6IFNpZy5DT01QQVJBQkxFKSA9IHN0cnVjdFxuICB0eXBlIGRhdGEgPSBMLnRcbiAgdHlwZSBsYWJlbCA9IFYudFxuICB0eXBlIHQgPSBkYXRhIHJlZiAqIFYudFxuICBsZXQgY29tcGFyZSAoXywgeCkgKF8sIHgnKSA9IFYuY29tcGFyZSB4IHgnXG4gIGxldCBoYXNoIChfLCB4KSA9IFYuaGFzaCB4XG4gIGxldCBlcXVhbCAoXywgeCkgKF8sIHgnKSA9IFYuZXF1YWwgeCB4J1xuICBsZXQgY3JlYXRlIHkgbGJsID0gKHJlZiB5LCBsYmwpXG4gIGxldCBsYWJlbCAoXywgeikgPSB6XG4gIGxldCBkYXRhICh5LCBfKSA9ICF5XG4gIGxldCBzZXRfZGF0YSAoeSwgXykgPSAoOj0pIHlcbmVuZFxuXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgT2NhbWxncmFwaDogYSBnZW5lcmljIGdyYXBoIGxpYnJhcnkgZm9yIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgQ29weXJpZ2h0IChDKSAyMDA0LTIwMTAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgU3lsdmFpbiBDb25jaG9uLCBKZWFuLUNocmlzdG9waGUgRmlsbGlhdHJlIGFuZCBKdWxpZW4gU2lnbm9sZXMgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgVGhpcyBzb2Z0d2FyZSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgICAgICAgICopXG4oKiAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExpYnJhcnkgR2VuZXJhbCBQdWJsaWMgICAgICAgICAgICopXG4oKiAgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyAgICAgICAgICAgICopXG4oKiAgZGVzY3JpYmVkIGluIGZpbGUgTElDRU5TRS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgVGhpcyBzb2Z0d2FyZSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCAgICAgICopXG4oKiAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgICAgICAgICopXG4oKiAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEdyYXBoIHRyYXZlcnNhbCAqKVxuXG5tb2R1bGUgdHlwZSBHID0gc2lnXG4gIHZhbCBpc19kaXJlY3RlZCA6IGJvb2xcbiAgdHlwZSB0XG4gIG1vZHVsZSBWIDogU2lnLkNPTVBBUkFCTEVcbiAgdmFsIGl0ZXJfdmVydGV4IDogKFYudCAtPiB1bml0KSAtPiB0IC0+IHVuaXRcbiAgdmFsIGZvbGRfdmVydGV4IDogKFYudCAtPiAnYSAtPiAnYSkgLT4gdCAgLT4gJ2EgLT4gJ2FcbiAgdmFsIGl0ZXJfc3VjYyA6IChWLnQgLT4gdW5pdCkgLT4gdCAtPiBWLnQgLT4gdW5pdFxuICB2YWwgZm9sZF9zdWNjIDogKFYudCAtPiAnYSAtPiAnYSkgLT4gdCAtPiBWLnQgLT4gJ2EgLT4gJ2FcbmVuZFxuXG4oKiBkZXB0aC1maXJzdCBzZWFyY2ggKilcbm1vZHVsZSBEZnMoRyA6IEcpID0gc3RydWN0XG4gIG1vZHVsZSBIID0gSGFzaHRibC5NYWtlKEcuVilcblxuICBsZXQgZm9sZCBmIGkgZyA9XG4gICAgbGV0IGggPSBILmNyZWF0ZSA5NyBpblxuICAgIGxldCBzID0gU3RhY2suY3JlYXRlICgpIGluXG4gICAgbGV0IHB1c2ggdiA9XG4gICAgICBpZiBub3QgKEgubWVtIGggdikgdGhlbiBiZWdpbiBILmFkZCBoIHYgKCk7IFN0YWNrLnB1c2ggdiBzIGVuZFxuICAgIGluXG4gICAgbGV0IHJlYyBsb29wIGFjYyA9XG4gICAgICBpZiBub3QgKFN0YWNrLmlzX2VtcHR5IHMpIHRoZW5cbiAgICAgICAgbGV0IHYgPSBTdGFjay5wb3AgcyBpblxuICAgICAgICBsZXQgbnMgPSBmIHYgYWNjIGluXG4gICAgICAgIEcuaXRlcl9zdWNjIHB1c2ggZyB2O1xuICAgICAgICBsb29wIG5zXG4gICAgICBlbHNlXG4gICAgICAgIGFjY1xuICAgIGluXG4gICAgRy5mb2xkX3ZlcnRleCAoZnVuIHYgcyAtPiBwdXNoIHY7IGxvb3AgcykgZyBpXG5cbiAgbGV0IGl0ZXIgPyhwcmU9ZnVuIF8gLT4gKCkpID8ocG9zdD1mdW4gXyAtPiAoKSkgZyA9XG4gICAgbGV0IGggPSBILmNyZWF0ZSA5NyBpblxuICAgIGxldCByZWMgdmlzaXQgdiA9XG4gICAgICBpZiBub3QgKEgubWVtIGggdikgdGhlbiBiZWdpblxuICAgICAgICBILmFkZCBoIHYgKCk7XG4gICAgICAgIHByZSB2O1xuICAgICAgICBHLml0ZXJfc3VjYyB2aXNpdCBnIHY7XG4gICAgICAgIHBvc3QgdlxuICAgICAgZW5kXG4gICAgaW5cbiAgICBHLml0ZXJfdmVydGV4IHZpc2l0IGdcblxuICBsZXQgcG9zdGZpeCBwb3N0IGcgPSBpdGVyIH5wb3N0IGdcblxuICBsZXQgZm9sZF9jb21wb25lbnQgZiBpIGcgdjAgPVxuICAgIGxldCBoID0gSC5jcmVhdGUgOTcgaW5cbiAgICBsZXQgcyA9IFN0YWNrLmNyZWF0ZSAoKSBpblxuICAgICgqIGludmFyaWFudDogW2hdIGNvbnRhaW5zIGV4YWN0bHkgdGhlIHZlcnRpY2VzIHdoaWNoIGhhdmUgYmVlbiBwdXNoZWQgKilcbiAgICBsZXQgcHVzaCB2ID1cbiAgICAgIGlmIG5vdCAoSC5tZW0gaCB2KSB0aGVuIGJlZ2luIEguYWRkIGggdiAoKTsgU3RhY2sucHVzaCB2IHMgZW5kXG4gICAgaW5cbiAgICBwdXNoIHYwO1xuICAgIGxldCByZWMgbG9vcCBhY2MgPVxuICAgICAgaWYgbm90IChTdGFjay5pc19lbXB0eSBzKSB0aGVuXG4gICAgICAgIGxldCB2ID0gU3RhY2sucG9wIHMgaW5cbiAgICAgICAgbGV0IG5zID0gZiB2IGFjYyBpblxuICAgICAgICBHLml0ZXJfc3VjYyBwdXNoIGcgdjtcbiAgICAgICAgbG9vcCBuc1xuICAgICAgZWxzZVxuICAgICAgICBhY2NcbiAgICBpblxuICAgIGxvb3AgaVxuXG4gIGxldCBpdGVyX2NvbXBvbmVudCA/KHByZT1mdW4gXyAtPiAoKSkgPyhwb3N0PWZ1biBfIC0+ICgpKSBnIHYgPVxuICAgIGxldCBoID0gSC5jcmVhdGUgOTcgaW5cbiAgICBsZXQgcmVjIHZpc2l0IHYgPVxuICAgICAgSC5hZGQgaCB2ICgpO1xuICAgICAgcHJlIHY7XG4gICAgICBHLml0ZXJfc3VjYyAoZnVuIHcgLT4gaWYgbm90IChILm1lbSBoIHcpIHRoZW4gdmlzaXQgdykgZyB2O1xuICAgICAgcG9zdCB2XG4gICAgaW5cbiAgICB2aXNpdCB2XG5cbiAgbGV0IHBvc3RmaXhfY29tcG9uZW50IHBvc3QgZyA9IGl0ZXJfY29tcG9uZW50IH5wb3N0IGdcblxuICBtb2R1bGUgVGFpbCA9IHN0cnVjdFxuXG4gICAgbGV0IGhhc19jeWNsZSBnID1cbiAgICAgIGxldCBoID0gSC5jcmVhdGUgOTcgaW5cbiAgICAgIGxldCBzdGFjayA9IFN0YWNrLmNyZWF0ZSAoKSBpblxuICAgICAgbGV0IGxvb3AgKCkgPVxuICAgICAgICB3aGlsZSBub3QgKFN0YWNrLmlzX2VtcHR5IHN0YWNrKSBkb1xuICAgICAgICAgIGxldCB2ID0gU3RhY2sudG9wIHN0YWNrIGluXG4gICAgICAgICAgaWYgSC5tZW0gaCB2IHRoZW4gYmVnaW5cbiAgICAgICAgICAgICgqIHdlIGFyZSBub3cgZG9uZSB3aXRoIG5vZGUgdiAqKVxuICAgICAgICAgICAgKCogYXNzZXJ0IChILmZpbmQgaCB2ID0gdHJ1ZSk7ICopXG4gICAgICAgICAgICBILnJlcGxhY2UgaCB2IGZhbHNlO1xuICAgICAgICAgICAgaWdub3JlIChTdGFjay5wb3Agc3RhY2spXG4gICAgICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICgqIHdlIHN0YXJ0IERGUyBmcm9tIG5vZGUgdiAqKVxuICAgICAgICAgICAgSC5hZGQgaCB2IHRydWU7XG4gICAgICAgICAgICBHLml0ZXJfc3VjY1xuICAgICAgICAgICAgICAoZnVuIHcgLT5cbiAgICAgICAgICAgICAgICAgdHJ5IGlmIEguZmluZCBoIHcgdGhlbiByYWlzZSBFeGl0XG4gICAgICAgICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+IFN0YWNrLnB1c2ggdyBzdGFjaylcbiAgICAgICAgICAgICAgZyB2O1xuICAgICAgICAgIGVuZFxuICAgICAgICBkb25lXG4gICAgICBpblxuICAgICAgdHJ5XG4gICAgICAgIEcuaXRlcl92ZXJ0ZXhcbiAgICAgICAgICAoZnVuIHYgLT5cbiAgICAgICAgICAgICBpZiBub3QgKEgubWVtIGggdikgdGhlbiBiZWdpbiBTdGFjay5wdXNoIHYgc3RhY2s7IGxvb3AgKCkgZW5kKVxuICAgICAgICAgIGc7XG4gICAgICAgIGZhbHNlXG4gICAgICB3aXRoIEV4aXQgLT5cbiAgICAgICAgdHJ1ZVxuXG4gICAgbGV0IGhhc19jeWNsZV91bmRpcmVjdGVkIGcgPVxuICAgICAgbGV0IGggPSBILmNyZWF0ZSA5NyBpblxuICAgICAgbGV0IGZhdGhlciA9IEguY3JlYXRlIDk3IGluXG4gICAgICBsZXQgaXNfZmF0aGVyIHUgdiA9ICgqIHUgaXMgdGhlIGZhdGhlciBvZiB2IGluIHRoZSBERlMgZGVzY2VudCAqKVxuICAgICAgICB0cnkgRy5WLmVxdWFsIChILmZpbmQgZmF0aGVyIHYpIHUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcbiAgICAgIGluXG4gICAgICBsZXQgc3RhY2sgPSBTdGFjay5jcmVhdGUgKCkgaW5cbiAgICAgIGxldCBsb29wICgpID1cbiAgICAgICAgd2hpbGUgbm90IChTdGFjay5pc19lbXB0eSBzdGFjaykgZG9cbiAgICAgICAgICBsZXQgdiA9IFN0YWNrLnRvcCBzdGFjayBpblxuICAgICAgICAgIGlmIEgubWVtIGggdiB0aGVuIGJlZ2luXG4gICAgICAgICAgICAoKiB3ZSBhcmUgbm93IGRvbmUgd2l0aCBub2RlIHYgKilcbiAgICAgICAgICAgICgqIGFzc2VydCAoSC5maW5kIGggdiA9IHRydWUpOyAqKVxuICAgICAgICAgICAgSC5yZW1vdmUgZmF0aGVyIHY7XG4gICAgICAgICAgICBILnJlcGxhY2UgaCB2IGZhbHNlO1xuICAgICAgICAgICAgaWdub3JlIChTdGFjay5wb3Agc3RhY2spXG4gICAgICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICgqIHdlIHN0YXJ0IERGUyBmcm9tIG5vZGUgdiAqKVxuICAgICAgICAgICAgSC5hZGQgaCB2IHRydWU7XG4gICAgICAgICAgICBHLml0ZXJfc3VjY1xuICAgICAgICAgICAgICAoZnVuIHcgLT5cbiAgICAgICAgICAgICAgICAgdHJ5IGlmIEguZmluZCBoIHcgJiYgbm90IChpc19mYXRoZXIgdyB2KSB0aGVuIHJhaXNlIEV4aXRcbiAgICAgICAgICAgICAgICAgd2l0aCBOb3RfZm91bmQgLT4gSC5hZGQgZmF0aGVyIHcgdjsgU3RhY2sucHVzaCB3IHN0YWNrKVxuICAgICAgICAgICAgICBnIHY7XG4gICAgICAgICAgZW5kXG4gICAgICAgIGRvbmVcbiAgICAgIGluXG4gICAgICB0cnlcbiAgICAgICAgRy5pdGVyX3ZlcnRleFxuICAgICAgICAgIChmdW4gdiAtPlxuICAgICAgICAgICAgIGlmIG5vdCAoSC5tZW0gaCB2KSB0aGVuIGJlZ2luIFN0YWNrLnB1c2ggdiBzdGFjazsgbG9vcCAoKSBlbmQpXG4gICAgICAgICAgZztcbiAgICAgICAgZmFsc2VcbiAgICAgIHdpdGggRXhpdCAtPlxuICAgICAgICB0cnVlXG5cbiAgICBsZXQgaGFzX2N5Y2xlIGcgPVxuICAgICAgaWYgRy5pc19kaXJlY3RlZCB0aGVuIGhhc19jeWNsZSBnIGVsc2UgaGFzX2N5Y2xlX3VuZGlyZWN0ZWQgZ1xuXG4gICAgbGV0IGl0ZXIgZiBnID1cbiAgICAgIGxldCBoID0gSC5jcmVhdGUgOTcgaW5cbiAgICAgIGxldCBzdGFjayA9IFN0YWNrLmNyZWF0ZSAoKSBpblxuICAgICAgbGV0IGxvb3AgKCkgPVxuICAgICAgICB3aGlsZSBub3QgKFN0YWNrLmlzX2VtcHR5IHN0YWNrKSBkb1xuICAgICAgICAgIGxldCB2ID0gU3RhY2sucG9wIHN0YWNrIGluXG4gICAgICAgICAgaWYgbm90IChILm1lbSBoIHYpIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIEguYWRkIGggdiAoKTtcbiAgICAgICAgICAgIGYgdjtcbiAgICAgICAgICAgIEcuaXRlcl9zdWNjXG4gICAgICAgICAgICAgIChmdW4gdyAtPiBpZiBub3QgKEgubWVtIGggdykgdGhlbiBTdGFjay5wdXNoIHcgc3RhY2spIGcgdlxuICAgICAgICAgIGVuZFxuICAgICAgICBkb25lXG4gICAgICBpblxuICAgICAgRy5pdGVyX3ZlcnRleFxuICAgICAgICAoZnVuIHYgLT5cbiAgICAgICAgICAgaWYgbm90IChILm1lbSBoIHYpIHRoZW4gYmVnaW4gU3RhY2sucHVzaCB2IHN0YWNrOyBsb29wICgpIGVuZClcbiAgICAgICAgZ1xuXG4gICAgbGV0IGl0ZXJfY29tcG9uZW50IGYgZyB2MCA9XG4gICAgICBsZXQgaCA9IEguY3JlYXRlIDk3IGluXG4gICAgICBsZXQgc3RhY2sgPSBTdGFjay5jcmVhdGUgKCkgaW5cbiAgICAgIFN0YWNrLnB1c2ggdjAgc3RhY2s7XG4gICAgICB3aGlsZSBub3QgKFN0YWNrLmlzX2VtcHR5IHN0YWNrKSBkb1xuICAgICAgICBsZXQgdiA9IFN0YWNrLnBvcCBzdGFjayBpblxuICAgICAgICBpZiBub3QgKEgubWVtIGggdikgdGhlbiBiZWdpblxuICAgICAgICAgIEguYWRkIGggdiAoKTtcbiAgICAgICAgICBmIHY7XG4gICAgICAgICAgRy5pdGVyX3N1Y2MgKGZ1biB3IC0+IGlmIG5vdCAoSC5tZW0gaCB3KSB0aGVuIFN0YWNrLnB1c2ggdyBzdGFjaykgZyB2XG4gICAgICAgIGVuZFxuICAgICAgZG9uZVxuXG4gIGVuZFxuXG4gIGxldCBwcmVmaXggPSBUYWlsLml0ZXJcbiAgbGV0IGhhc19jeWNsZSA9IFRhaWwuaGFzX2N5Y2xlXG4gIGxldCBwcmVmaXhfY29tcG9uZW50ID0gVGFpbC5pdGVyX2NvbXBvbmVudFxuXG4gICgqIHN0ZXAtYnktc3RlcCBpdGVyYXRvciAqKVxuICBtb2R1bGUgUyA9IFNldC5NYWtlKEcuVilcblxuICB0eXBlIGl0ZXJhdG9yID0gUy50ICogRy5WLnQgbGlzdCAqIEcudFxuICAoKiogKGgsIHN0LCBnKSB3aGVyZSBoIGlzIHRoZSBzZXQgb2YgbWFya2VkIHZlcnRpY2VzIGFuZCBzdCB0aGUgc3RhY2tcbiAgICAgIGludmFyaWFudDogdGhlIGZpcnN0IGVsZW1lbnQgb2Ygc3QgaXMgbm90IGluIGggaS5lLiB0byBiZSB2aXNpdGVkICopXG5cbiAgbGV0IHN0YXJ0IGcgPVxuICAgIGxldCBzdCA9IEcuZm9sZF92ZXJ0ZXggKGZ1biB2IHN0IC0+IHYgOjogc3QpIGcgW10gaW5cbiAgICBTLmVtcHR5LCBzdCwgZ1xuXG4gIGxldCBnZXQgKF8sc3QsXykgPSBtYXRjaCBzdCB3aXRoXG4gICAgfCBbXSAtPiByYWlzZSBFeGl0XG4gICAgfCB2IDo6IF8gIC0+IHZcblxuICBsZXQgc3RlcCAocyxzdCxnKSA9IG1hdGNoIHN0IHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICByYWlzZSBFeGl0XG4gICAgfCB2IDo6IHN0IC0+XG4gICAgICBsZXQgcycgPSBTLmFkZCB2IHMgaW5cbiAgICAgIGxldCBzdCcgPSBHLmZvbGRfc3VjYyAoZnVuIHcgc3QgLT4gdyA6OiBzdCkgZyB2IHN0IGluXG4gICAgICBsZXQgcmVjIGNsZWFuID0gZnVuY3Rpb25cbiAgICAgICAgfCB3IDo6IHN0IHdoZW4gUy5tZW0gdyBzJyAtPiBjbGVhbiBzdFxuICAgICAgICB8IHN0IC0+IHN0XG4gICAgICBpblxuICAgICAgKHMnLCBjbGVhbiBzdCcsIGcpXG5cbmVuZFxuXG4oKiBicmVhZHRoLWZpcnN0IHNlYXJjaCAqKVxubW9kdWxlIEJmcyhHIDogRykgPSBzdHJ1Y3RcbiAgbW9kdWxlIEggPSBIYXNodGJsLk1ha2UoRy5WKVxuXG4gIGxldCBmb2xkIGYgaSAoZyA6IEcudCkgPVxuICAgIGxldCBoID0gSC5jcmVhdGUgOTcgaW5cbiAgICBsZXQgcSA9IFF1ZXVlLmNyZWF0ZSAoKSBpblxuICAgICgqIGludmFyaWFudDogW2hdIGNvbnRhaW5zIGV4YWN0bHkgdGhlIHZlcnRpY2VzIHdoaWNoIGhhdmUgYmVlbiBwdXNoZWQgKilcbiAgICBsZXQgcHVzaCB2ID1cbiAgICAgIGlmIG5vdCAoSC5tZW0gaCB2KSB0aGVuIGJlZ2luIEguYWRkIGggdiAoKTsgUXVldWUuYWRkIHYgcSBlbmRcbiAgICBpblxuICAgIGxldCByZWMgbG9vcCBzID1cbiAgICAgIGlmIG5vdCAoUXVldWUuaXNfZW1wdHkgcSkgdGhlblxuICAgICAgICBsZXQgdiAgPSBRdWV1ZS5wb3AgcSBpblxuICAgICAgICBsZXQgbnMgPSBmIHYgcyBpbiAgICAgICAgICAgICAgICgqIFN0aWNraW5nIHRvIE9DYW1sR3JhcGgncyBmb2xkIGNvbnYgKilcbiAgICAgICAgRy5pdGVyX3N1Y2MgcHVzaCBnIHY7XG4gICAgICAgIGxvb3AgbnNcbiAgICAgIGVsc2VcbiAgICAgICAgc1xuICAgIGluXG4gICAgRy5mb2xkX3ZlcnRleCAoZnVuIHYgcyAtPiBwdXNoIHY7IGxvb3AgcykgZyBpXG5cbiAgbGV0IGl0ZXIgZiA9IGZvbGQgKGZ1biB2ICgpIC0+IGYgdikgKClcblxuICBsZXQgZm9sZF9jb21wb25lbnQgZiBpIGcgdjAgPVxuICAgIGxldCBoID0gSC5jcmVhdGUgOTcgaW5cbiAgICBsZXQgcSA9IFF1ZXVlLmNyZWF0ZSAoKSBpblxuICAgICgqIGludmFyaWFudDogW2hdIGNvbnRhaW5zIGV4YWN0bHkgdGhlIHZlcnRpY2VzIHdoaWNoIGhhdmUgYmVlbiBwdXNoZWQgKilcbiAgICBsZXQgcHVzaCB2ID1cbiAgICAgIGlmIG5vdCAoSC5tZW0gaCB2KSB0aGVuIGJlZ2luIEguYWRkIGggdiAoKTsgUXVldWUuYWRkIHYgcSBlbmRcbiAgICBpblxuICAgIHB1c2ggdjA7XG4gICAgbGV0IHJlYyBsb29wIHMgPVxuICAgICAgaWYgbm90IChRdWV1ZS5pc19lbXB0eSBxKSB0aGVuXG4gICAgICAgIGxldCB2ICA9IFF1ZXVlLnBvcCBxIGluXG4gICAgICAgIGxldCBucyA9IGYgdiBzIGluXG4gICAgICAgIEcuaXRlcl9zdWNjIHB1c2ggZyB2O1xuICAgICAgICBsb29wIG5zXG4gICAgICBlbHNlXG4gICAgICAgIHNcbiAgICBpblxuICAgIGxvb3AgaVxuXG4gIGxldCBpdGVyX2NvbXBvbmVudCBmID0gZm9sZF9jb21wb25lbnQgKGZ1biB2ICgpIC0+IGYgdikgKClcblxuICAoKiBzdGVwLWJ5LXN0ZXAgaXRlcmF0b3IgKilcblxuICAoKiBzaW1wbGUsIHlldCBPKDEpLWFtb3J0aXplZCwgcGVyc2lzdGVudCBxdWV1ZXMgKilcbiAgbW9kdWxlIFEgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYSBsaXN0ICogJ2EgbGlzdFxuICAgIGV4Y2VwdGlvbiBFbXB0eVxuICAgIGxldCBlbXB0eSA9IFtdLCBbXVxuICAgIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uIFtdLCBbXSAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuICAgIGxldCBwdXNoIHggKGksbykgPSAoeCA6OiBpLCBvKVxuICAgIGxldCBwb3AgPSBmdW5jdGlvblxuICAgICAgfCBpLCB5IDo6IG8gLT4geSwgKGksbylcbiAgICAgIHwgW10sIFtdIC0+IHJhaXNlIEVtcHR5XG4gICAgICB8IGksIFtdIC0+IG1hdGNoIExpc3QucmV2IGkgd2l0aFxuICAgICAgICB8IHggOjogbyAtPiB4LCAoW10sIG8pXG4gICAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgbGV0IHBlZWsgcSA9IGZzdCAocG9wIHEpXG4gIGVuZFxuXG4gIG1vZHVsZSBTID0gU2V0Lk1ha2UoRy5WKVxuXG4gICgqIHN0YXRlIGlzIFsocyxxLGcpXSA6IFtzXSBjb250YWlucyBlbGVtZW50cyBuZXZlciBiZWVuIHB1c2hlZCBpbiBbcV0gKilcbiAgdHlwZSBpdGVyYXRvciA9IFMudCAqIEcuVi50IFEudCAqIEcudFxuXG4gIGxldCBzdGFydCBnID1cbiAgICBsZXQgcyA9IEcuZm9sZF92ZXJ0ZXggUy5hZGQgZyBTLmVtcHR5IGluXG4gICAgcywgUS5lbXB0eSwgZ1xuXG4gIGxldCBnZXQgKHMscSxfKSA9XG4gICAgaWYgUS5pc19lbXB0eSBxIHRoZW5cbiAgICAgIGlmIFMuaXNfZW1wdHkgcyB0aGVuIHJhaXNlIEV4aXQgZWxzZSBTLmNob29zZSBzXG4gICAgZWxzZVxuICAgICAgUS5wZWVrIHFcblxuICBsZXQgc3RlcCAocyxxLGcpID1cbiAgICBsZXQgcHVzaCB2IChzLHEgYXMgYWNjKSA9XG4gICAgICBpZiBTLm1lbSB2IHMgdGhlblxuICAgICAgICBTLnJlbW92ZSB2IHMsIFEucHVzaCB2IHFcbiAgICAgIGVsc2VcbiAgICAgICAgYWNjXG4gICAgaW5cbiAgICBsZXQgdixzJyxxJyA9XG4gICAgICBpZiBRLmlzX2VtcHR5IHEgdGhlbiBiZWdpblxuICAgICAgICBpZiBTLmlzX2VtcHR5IHMgdGhlbiByYWlzZSBFeGl0O1xuICAgICAgICBsZXQgdiA9IFMuY2hvb3NlIHMgaW5cbiAgICAgICAgdiwgUy5yZW1vdmUgdiBzLCBxXG4gICAgICBlbmQgZWxzZVxuICAgICAgICBsZXQgdixxJyA9IFEucG9wIHEgaW5cbiAgICAgICAgdiwgcywgcSdcbiAgICBpblxuICAgIGxldCBzJycscScnID0gRy5mb2xkX3N1Y2MgcHVzaCBnIHYgKHMnLHEnKSBpblxuICAgIChzJycscScnLGcpXG5cbmVuZFxuXG5cbigqIEdyYXBoIHRyYXZlcnNhbCB3aXRoIG1hcmtpbmcuICopXG5cbm1vZHVsZSB0eXBlIEdNID0gc2lnXG4gIHR5cGUgdFxuICBtb2R1bGUgViA6IHNpZyB0eXBlIHQgZW5kXG4gIHZhbCBpdGVyX3ZlcnRleCA6IChWLnQgLT4gdW5pdCkgLT4gdCAtPiB1bml0XG4gIHZhbCBpdGVyX3N1Y2MgOiAoVi50IC0+IHVuaXQpIC0+IHQgLT4gVi50IC0+IHVuaXRcbiAgbW9kdWxlIE1hcmsgOiBzaWdcbiAgICB2YWwgY2xlYXIgOiB0IC0+IHVuaXRcbiAgICB2YWwgZ2V0IDogVi50IC0+IGludFxuICAgIHZhbCBzZXQgOiBWLnQgLT4gaW50IC0+IHVuaXRcbiAgZW5kXG5lbmRcblxubW9kdWxlIE1hcmsoRyA6IEdNKSA9IHN0cnVjdFxuXG4gIGxldCBkZnMgZyA9XG4gICAgRy5NYXJrLmNsZWFyIGc7XG4gICAgbGV0IG4gPSByZWYgMCBpblxuICAgIGxldCByZWMgdmlzaXQgdiA9XG4gICAgICBpZiBHLk1hcmsuZ2V0IHYgPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgaW5jciBuO1xuICAgICAgICBHLk1hcmsuc2V0IHYgIW47XG4gICAgICAgIEcuaXRlcl9zdWNjIHZpc2l0IGcgdlxuICAgICAgZW5kXG4gICAgaW5cbiAgICBHLml0ZXJfdmVydGV4IHZpc2l0IGdcblxuICAoKiBpbnZhcmlhbnQ6IFtoIHYgPSAwXSBtZWFucyBub3QgdmlzaXRlZCBhdCBhbGw7IFtoIHYgPSAxXSBtZWFuc1xuICAgICBhbHJlYWR5IHZpc2l0ZWQgaW4gdGhlIGN1cnJlbnQgY29tcG9uZW50OyBbaCB2ID0gMl0gbWVhbnNcbiAgICAgYWxyZWFkeSB2aXNpdGVkIGluIGFub3RoZXIgdHJlZSAqKVxuICBsZXQgaGFzX2N5Y2xlIGcgPVxuICAgIEcuTWFyay5jbGVhciBnO1xuICAgIGxldCByZWMgdmlzaXQgdiA9XG4gICAgICBHLk1hcmsuc2V0IHYgMTtcbiAgICAgIEcuaXRlcl9zdWNjXG4gICAgICAgIChmdW4gdyAtPlxuICAgICAgICAgICBsZXQgbSA9IEcuTWFyay5nZXQgdyBpblxuICAgICAgICAgICBpZiBtID0gMSB0aGVuIHJhaXNlIEV4aXQ7XG4gICAgICAgICAgIGlmIG0gPSAwIHRoZW4gdmlzaXQgdylcbiAgICAgICAgZyB2O1xuICAgICAgRy5NYXJrLnNldCB2IDJcbiAgICBpblxuICAgIHRyeSBHLml0ZXJfdmVydGV4IChmdW4gdiAtPiBpZiBHLk1hcmsuZ2V0IHYgPSAwIHRoZW4gdmlzaXQgdikgZzsgZmFsc2VcbiAgICB3aXRoIEV4aXQgLT4gdHJ1ZVxuXG5lbmRcblxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogIE9jYW1sZ3JhcGg6IGEgZ2VuZXJpYyBncmFwaCBsaWJyYXJ5IGZvciBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogIENvcHlyaWdodCAoQykgMjAwNC0yMDEwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogIFN5bHZhaW4gQ29uY2hvbiwgSmVhbi1DaHJpc3RvcGhlIEZpbGxpYXRyZSBhbmQgSnVsaWVuIFNpZ25vbGVzICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogIFRoaXMgc29mdHdhcmUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yICAgICAgICAqKVxuKCogIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMaWJyYXJ5IEdlbmVyYWwgUHVibGljICAgICAgICAgICAqKVxuKCogIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgICAgICAgICAgICAqKVxuKCogIGRlc2NyaWJlZCBpbiBmaWxlIExJQ0VOU0UuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogIFRoaXMgc29mdHdhcmUgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgICAgICAqKVxuKCogIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mICAgICAgICAqKVxuKCogIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiogQ29tbW9uIGltcGxlbWVudGF0aW9uIHRvIHBlcnNpc3RlbnQgYW5kIGltcGVyYXRpdmUgZ3JhcGhzLiAqKVxuXG5vcGVuIFNpZ1xub3BlbiBVdGlsXG5cbmxldCBmaXJzdF92YWx1ZV9mb3JfY3B0X3ZlcnRleCA9IDBcbmxldCBjcHRfdmVydGV4ID0gcmVmIGZpcnN0X3ZhbHVlX2Zvcl9jcHRfdmVydGV4XG4oKiBnbG9iYWwgY291bnRlciBmb3IgYWJzdHJhY3QgdmVydGV4ICopXG5cbigqIFttYXhfY3B0IHQxIHQyXSByZXR1cm5zIHRoZSBtYXhpbXVtIG9mIFt0MV0gYW5kIFt0Ml0gd3J0IHRoZSB0b3RhbCBvcmRlcmluZ1xuICAgaW5kdWNlZCBieSB0YWdzIGNyZWF0aW9uLiBUaGlzIG9yZGVyaW5nIGlzIGRlZmluZWQgYXMgZm9sbG93OlxuICAgZm9yYWxsIHRhZ3MgdDEgdDIsXG4gICB0MSA8PSB0MiBpZmZcbiAgIHQxIGlzIGJlZm9yZSB0MiBpbiB0aGUgZmluaXRlIHNlcXVlbmNlXG4gICBbMDsgMTsgLi47IG1heF9pbnQ7IG1pbl9pbnQ7IG1pbl9pbnQtMTsgLTFdICopXG5sZXQgbWF4X2NwdCBjMSBjMiA9IG1heCAoYzEgKyBtaW5faW50KSAoYzIgKyBtaW5faW50KSAtIG1pbl9pbnRcblxuKCogVGhpcyBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCBhZnRlciB0aGUgdW5zZXJpYWxpc2F0aW9uIG9mIGFueSBhYnN0cmFjdFxuICAgdmVydGV4IGlmIHlvdSB3YW50IHRvIGNyZWF0ZSBuZXcgdmVydGljZXMuICopXG5sZXQgYWZ0ZXJfdW5zZXJpYWxpemF0aW9uIHNlcmlhbGl6ZWRfY3B0X3ZlcnRleCA9XG4gIGNwdF92ZXJ0ZXggOj0gbWF4X2NwdCBzZXJpYWxpemVkX2NwdF92ZXJ0ZXggIWNwdF92ZXJ0ZXhcblxuKCogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqKVxuKCoqIHsyIEFzc29jaWF0aW9uIHRhYmxlIGJ1aWxkZXJ9ICopXG4oKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICopXG5cbigqKiBDb21tb24gc2lnbmF0dXJlIHRvIGFuIGltcGVyYXRpdmUvcGVyc2lzdGVudCBhc3NvY2lhdGlvbiB0YWJsZSAqKVxubW9kdWxlIHR5cGUgSE0gPSBzaWdcbiAgdHlwZSAnYSByZXR1cm5cbiAgdHlwZSAnYSB0XG4gIHR5cGUga2V5XG4gIHZhbCBjcmVhdGUgOiA/c2l6ZTppbnQgLT4gdW5pdCAtPiAnYSB0XG4gIHZhbCBjcmVhdGVfZnJvbSA6ICdhIHQgLT4gJ2EgdFxuICB2YWwgZW1wdHkgOiAnYSByZXR1cm5cbiAgdmFsIGNsZWFyOiAnYSB0IC0+IHVuaXRcbiAgdmFsIGlzX2VtcHR5IDogJ2EgdCAtPiBib29sXG4gIHZhbCBhZGQgOiBrZXkgLT4gJ2EgLT4gJ2EgdCAtPiAnYSB0XG4gIHZhbCByZW1vdmUgOiBrZXkgLT4gJ2EgdCAtPiAnYSB0XG4gIHZhbCBtZW0gOiBrZXkgLT4gJ2EgdCAtPiBib29sXG4gIHZhbCBmaW5kIDoga2V5IC0+ICdhIHQgLT4gJ2FcbiAgdmFsIGZpbmRfYW5kX3JhaXNlIDoga2V5IC0+ICdhIHQgLT4gc3RyaW5nIC0+ICdhXG4gICgqKiBbZmluZF9hbmRfcmFpc2UgayB0IHNdIGlzIGVxdWl2YWxlbnQgdG8gW2ZpbmQgayB0XSBidXRcbiAgICAgIHJhaXNlcyBbSW52YWxpZF9hcmd1bWVudCBzXSB3aGVuIFtmaW5kIGsgdF0gcmFpc2VzIFtOb3RfZm91bmRdICopXG5cbiAgdmFsIGl0ZXIgOiAoa2V5IC0+ICdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICB2YWwgbWFwIDogKGtleSAtPiAnYSAtPiBrZXkgKiAnYSkgLT4gJ2EgdCAtPiAnYSB0XG4gIHZhbCBmb2xkIDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICB2YWwgY29weSA6ICdhIHQgLT4gJ2EgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFRCTF9CVUlMREVSID0gZnVuY3RvcihYOiBDT01QQVJBQkxFKSAtPiBITSB3aXRoIHR5cGUga2V5ID0gWC50XG5cbigqKiBbSE1dIGltcGxlbWVudGF0aW9uIHVzaW5nIGhhc2h0YmwuICopXG5tb2R1bGUgTWFrZV9IYXNodGJsKFg6IENPTVBBUkFCTEUpID0gc3RydWN0XG5cbiAgaW5jbHVkZSBIYXNodGJsLk1ha2UoWClcblxuICB0eXBlICdhIHJldHVybiA9IHVuaXRcbiAgbGV0IGVtcHR5ID0gKClcbiAgKCogbmV2ZXIgY2FsbCBhbmQgbm90IHZpc2libGUgZm9yIHRoZSB1c2VyIHRoYW5rJ3MgdG8gc2lnbmF0dXJlXG4gICAgIGNvbnN0cmFpbnRzICopXG5cbiAgbGV0IGNyZWF0ZV9mcm9tIGggPSBjcmVhdGUgKGxlbmd0aCBoKVxuICBsZXQgY3JlYXRlID8oc2l6ZT05NykgKCkgPSBjcmVhdGUgc2l6ZVxuXG4gIGxldCBpc19lbXB0eSBoID0gKGxlbmd0aCBoID0gMClcblxuICBsZXQgZmluZF9hbmRfcmFpc2UgayBoIHMgPSB0cnkgZmluZCBoIGsgd2l0aCBOb3RfZm91bmQgLT4gaW52YWxpZF9hcmcgc1xuXG4gIGxldCBtYXAgZiBoID1cbiAgICBsZXQgaCcgPSBjcmVhdGVfZnJvbSBoICBpblxuICAgIGl0ZXIgKGZ1biBrIHYgLT4gbGV0IGssIHYgPSBmIGsgdiBpbiBhZGQgaCcgayB2KSBoO1xuICAgIGgnXG5cbiAgbGV0IGFkZCBrIHYgaCA9IHJlcGxhY2UgaCBrIHY7IGhcbiAgbGV0IHJlbW92ZSBrIGggPSByZW1vdmUgaCBrOyBoXG4gIGxldCBtZW0gayBoID0gbWVtIGgga1xuICBsZXQgZmluZCBrIGggPSBmaW5kIGgga1xuXG5lbmRcblxuKCoqIFtITV0gaW1wbGVtZW50YXRpb24gdXNpbmcgbWFwICopXG5tb2R1bGUgTWFrZV9NYXAoWDogQ09NUEFSQUJMRSkgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYXAuTWFrZShYKVxuICB0eXBlICdhIHJldHVybiA9ICdhIHRcbiAgbGV0IGNyZWF0ZSA/c2l6ZTpfICgpID0gYXNzZXJ0IGZhbHNlXG4gICgqIG5ldmVyIGNhbGwgYW5kIG5vdCB2aXNpYmxlIGZvciB0aGUgdXNlciB0aGFuaydzIHRvXG4gICAgIHNpZ25hdHVyZSBjb25zdHJhaW50cyAqKVxuICBsZXQgY3JlYXRlX2Zyb20gXyA9IGVtcHR5XG4gIGxldCBjb3B5IG0gPSBtXG4gIGxldCBtYXAgZiBtID0gZm9sZCAoZnVuIGsgdiBtIC0+IGxldCBrLCB2ID0gZiBrIHYgaW4gYWRkIGsgdiBtKSBtIGVtcHR5XG4gIGxldCBmaW5kX2FuZF9yYWlzZSBrIGggcyA9IHRyeSBmaW5kIGsgaCB3aXRoIE5vdF9mb3VuZCAtPiBpbnZhbGlkX2FyZyBzXG4gIGxldCBjbGVhciBfID0gYXNzZXJ0IGZhbHNlXG4gICgqIG5ldmVyIGNhbGwgYW5kIG5vdCB2aXNpYmxlIGZvciB0aGUgdXNlciB0aGFuaydzIHRvXG4gICAgIHNpZ25hdHVyZSBjb25zdHJhaW50cyAqKVxuZW5kXG5cbigqICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKilcbigqKiB7MiBCbG9ja3MgYnVpbGRlcn0gKilcbigqICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKilcblxuKCoqIENvbW1vbiBpbXBsZW1lbnRhdGlvbiB0byBhbGwgKGRpcmVjdGVkKSBncmFwaCBpbXBsZW1lbnRhdGlvbnMuICopXG5tb2R1bGUgTWluaW1hbChTOiBTZXQuUykoSE06IEhNKSA9IHN0cnVjdFxuXG4gIHR5cGUgdmVydGV4ID0gSE0ua2V5XG5cbiAgbGV0IGlzX2RpcmVjdGVkID0gdHJ1ZVxuICBsZXQgZW1wdHkgPSBITS5lbXB0eVxuICBsZXQgY3JlYXRlID0gSE0uY3JlYXRlXG4gIGxldCBpc19lbXB0eSA9IEhNLmlzX2VtcHR5XG4gIGxldCBjb3B5ID0gSE0uY29weVxuICBsZXQgY2xlYXIgPSBITS5jbGVhclxuXG4gIGxldCBuYl92ZXJ0ZXggZyA9IEhNLmZvbGQgKGZ1biBfIF8gLT4gc3VjYykgZyAwXG4gIGxldCBuYl9lZGdlcyBnID0gSE0uZm9sZCAoZnVuIF8gcyBuIC0+IG4gKyBTLmNhcmRpbmFsIHMpIGcgMFxuICBsZXQgb3V0X2RlZ3JlZSBnIHYgPVxuICAgIFMuY2FyZGluYWxcbiAgICAgICh0cnkgSE0uZmluZCB2IGcgd2l0aCBOb3RfZm91bmQgLT4gaW52YWxpZF9hcmcgXCJbb2NhbWxncmFwaF0gb3V0X2RlZ3JlZVwiKVxuXG4gIGxldCBtZW1fdmVydGV4IGcgdiA9IEhNLm1lbSB2IGdcblxuICBsZXQgdW5zYWZlX2FkZF92ZXJ0ZXggZyB2ID0gSE0uYWRkIHYgUy5lbXB0eSBnXG4gIGxldCB1bnNhZmVfYWRkX2VkZ2UgZyB2MSB2MiA9IEhNLmFkZCB2MSAoUy5hZGQgdjIgKEhNLmZpbmQgdjEgZykpIGdcblxuICBsZXQgYWRkX3ZlcnRleCBnIHYgPSBpZiBITS5tZW0gdiBnIHRoZW4gZyBlbHNlIHVuc2FmZV9hZGRfdmVydGV4IGcgdlxuXG4gIGxldCBpdGVyX3ZlcnRleCBmID0gSE0uaXRlciAoZnVuIHYgXyAtPiBmIHYpXG4gIGxldCBmb2xkX3ZlcnRleCBmID0gSE0uZm9sZCAoZnVuIHYgXyAtPiBmIHYpXG5cbmVuZFxuXG4oKiogQWxsIHRoZSBwcmVkZWNlc3NvciBvcGVyYXRpb25zIGZyb20gdGhlIGl0ZXJhdG9ycyBvbiB0aGUgZWRnZXMgKilcbm1vZHVsZSBQcmVkXG4gICAgKFM6IHNpZ1xuICAgICAgIG1vZHVsZSBQVjogQ09NUEFSQUJMRVxuICAgICAgIG1vZHVsZSBQRTogRURHRSB3aXRoIHR5cGUgdmVydGV4ID0gUFYudFxuICAgICAgIHR5cGUgdFxuICAgICAgIHZhbCBtZW1fdmVydGV4IDogUFYudCAtPiB0IC0+IGJvb2xcbiAgICAgICB2YWwgaXRlcl9lZGdlcyA6IChQVi50IC0+IFBWLnQgLT4gdW5pdCkgLT4gdCAtPiB1bml0XG4gICAgICAgdmFsIGZvbGRfZWRnZXMgOiAoUFYudCAtPiBQVi50IC0+ICdhIC0+ICdhKSAtPiB0IC0+ICdhIC0+ICdhXG4gICAgICAgdmFsIGl0ZXJfZWRnZXNfZSA6IChQRS50IC0+IHVuaXQpIC0+IHQgLT4gdW5pdFxuICAgICAgIHZhbCBmb2xkX2VkZ2VzX2UgOiAoUEUudCAtPiAnYSAtPiAnYSkgLT4gdCAtPiAnYSAtPiAnYVxuICAgICBlbmQpID1cbnN0cnVjdFxuXG4gIG9wZW4gU1xuXG4gIGxldCBpdGVyX3ByZWQgZiBnIHYgPVxuICAgIGlmIG5vdCAobWVtX3ZlcnRleCB2IGcpIHRoZW4gaW52YWxpZF9hcmcgXCJbb2NhbWxncmFwaF0gaXRlcl9wcmVkXCI7XG4gICAgaXRlcl9lZGdlcyAoZnVuIHYxIHYyIC0+IGlmIFBWLmVxdWFsIHYgdjIgdGhlbiBmIHYxKSBnXG5cbiAgbGV0IGZvbGRfcHJlZCBmIGcgdiA9XG4gICAgaWYgbm90IChtZW1fdmVydGV4IHYgZykgdGhlbiBpbnZhbGlkX2FyZyBcIltvY2FtbGdyYXBoXSBmb2xkX3ByZWRcIjtcbiAgICBmb2xkX2VkZ2VzIChmdW4gdjEgdjIgYSAtPiBpZiBQVi5lcXVhbCB2IHYyIHRoZW4gZiB2MSBhIGVsc2UgYSkgZ1xuXG4gIGxldCBwcmVkIGcgdiA9IGZvbGRfcHJlZCAoZnVuIHYgbCAtPiB2IDo6IGwpIGcgdiBbXVxuXG4gIGxldCBpbl9kZWdyZWUgZyB2ID1cbiAgICBpZiBub3QgKG1lbV92ZXJ0ZXggdiBnKSB0aGVuIGludmFsaWRfYXJnIFwiW29jYW1sZ3JhcGhdIGluX2RlZ3JlZVwiO1xuICAgIGZvbGRfcHJlZCAoZnVuIF8gbiAtPiBuICsgMSkgZyB2IDBcblxuICBsZXQgaXRlcl9wcmVkX2UgZiBnIHYgPVxuICAgIGlmIG5vdCAobWVtX3ZlcnRleCB2IGcpIHRoZW4gaW52YWxpZF9hcmcgXCJbb2NhbWxncmFwaF0gaXRlcl9wcmVkX2VcIjtcbiAgICBpdGVyX2VkZ2VzX2UgKGZ1biBlIC0+IGlmIFBWLmVxdWFsIHYgKFBFLmRzdCBlKSB0aGVuIGYgZSkgZ1xuXG4gIGxldCBmb2xkX3ByZWRfZSBmIGcgdiA9XG4gICAgaWYgbm90IChtZW1fdmVydGV4IHYgZykgdGhlbiBpbnZhbGlkX2FyZyBcIltvY2FtbGdyYXBoXSBmb2xkX3ByZWRfZVwiO1xuICAgIGZvbGRfZWRnZXNfZSAoZnVuIGUgYSAtPiBpZiBQVi5lcXVhbCB2IChQRS5kc3QgZSkgdGhlbiBmIGUgYSBlbHNlIGEpIGdcblxuICBsZXQgcHJlZF9lIGcgdiA9IGZvbGRfcHJlZF9lIChmdW4gdiBsIC0+IHYgOjogbCkgZyB2IFtdXG5cbmVuZFxuXG4oKiogQ29tbW9uIGltcGxlbWVudGF0aW9uIHRvIGFsbCB0aGUgdW5sYWJlbGVkIChkaXJlY3RlZCkgZ3JhcGhzLiAqKVxubW9kdWxlIFVubGFiZWxlZChWOiBDT01QQVJBQkxFKShITTogSE0gd2l0aCB0eXBlIGtleSA9IFYudCkgPSBzdHJ1Y3RcblxuICBtb2R1bGUgUyA9IFNldC5NYWtlKFYpXG5cbiAgbW9kdWxlIEUgPSBzdHJ1Y3RcbiAgICB0eXBlIHZlcnRleCA9IFYudFxuICAgIGluY2x1ZGUgT1RQcm9kdWN0KFYpKFYpXG4gICAgbGV0IHNyYyA9IGZzdFxuICAgIGxldCBkc3QgPSBzbmRcbiAgICB0eXBlIGxhYmVsID0gdW5pdFxuICAgIGxldCBsYWJlbCBfID0gKClcbiAgICBsZXQgY3JlYXRlIHYxICgpIHYyID0gdjEsIHYyXG4gIGVuZFxuICB0eXBlIGVkZ2UgPSBFLnRcblxuICBsZXQgbWVtX2VkZ2UgZyB2MSB2MiA9XG4gICAgdHJ5IFMubWVtIHYyIChITS5maW5kIHYxIGcpXG4gICAgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuICBsZXQgbWVtX2VkZ2VfZSBnICh2MSwgdjIpID0gbWVtX2VkZ2UgZyB2MSB2MlxuXG4gIGxldCBmaW5kX2VkZ2UgZyB2MSB2MiA9IGlmIG1lbV9lZGdlIGcgdjEgdjIgdGhlbiB2MSwgdjIgZWxzZSByYWlzZSBOb3RfZm91bmRcbiAgbGV0IGZpbmRfYWxsX2VkZ2VzIGcgdjEgdjIgPSB0cnkgWyBmaW5kX2VkZ2UgZyB2MSB2MiBdIHdpdGggTm90X2ZvdW5kIC0+IFtdXG5cbiAgbGV0IHVuc2FmZV9yZW1vdmVfZWRnZSBnIHYxIHYyID0gSE0uYWRkIHYxIChTLnJlbW92ZSB2MiAoSE0uZmluZCB2MSBnKSkgZ1xuICBsZXQgdW5zYWZlX3JlbW92ZV9lZGdlX2UgZyAodjEsIHYyKSA9IHVuc2FmZV9yZW1vdmVfZWRnZSBnIHYxIHYyXG5cbiAgbGV0IHJlbW92ZV9lZGdlIGcgdjEgdjIgPVxuICAgIGlmIG5vdCAoSE0ubWVtIHYyIGcpIHRoZW4gaW52YWxpZF9hcmcgXCJbb2NhbWxncmFwaF0gcmVtb3ZlX2VkZ2VcIjtcbiAgICBITS5hZGRcbiAgICAgIHYxIChTLnJlbW92ZSB2MiAoSE0uZmluZF9hbmRfcmFpc2UgdjEgZyBcIltvY2FtbGdyYXBoXSByZW1vdmVfZWRnZVwiKSkgZ1xuXG4gIGxldCByZW1vdmVfZWRnZV9lIGcgKHYxLCB2MikgPSByZW1vdmVfZWRnZSBnIHYxIHYyXG5cbiAgbGV0IGl0ZXJfc3VjYyBmIGcgdiA9XG4gICAgUy5pdGVyIGYgKEhNLmZpbmRfYW5kX3JhaXNlIHYgZyBcIltvY2FtbGdyYXBoXSBpdGVyX3N1Y2NcIilcblxuICBsZXQgZm9sZF9zdWNjIGYgZyB2ID1cbiAgICBTLmZvbGQgZiAoSE0uZmluZF9hbmRfcmFpc2UgdiBnIFwiW29jYW1sZ3JhcGhdIGZvbGRfc3VjY1wiKVxuXG4gIGxldCBpdGVyX3N1Y2NfZSBmIGcgdiA9IGl0ZXJfc3VjYyAoZnVuIHYyIC0+IGYgKHYsIHYyKSkgZyB2XG4gIGxldCBmb2xkX3N1Y2NfZSBmIGcgdiA9IGZvbGRfc3VjYyAoZnVuIHYyIC0+IGYgKHYsIHYyKSkgZyB2XG5cbiAgbGV0IHN1Y2MgZyB2ID0gUy5lbGVtZW50cyAoSE0uZmluZF9hbmRfcmFpc2UgdiBnIFwiW29jYW1sZ3JhcGhdIHN1Y2NcIilcbiAgbGV0IHN1Y2NfZSBnIHYgPSBmb2xkX3N1Y2NfZSAoZnVuIGUgbCAtPiBlIDo6IGwpIGcgdiBbXVxuXG4gIGxldCBtYXBfdmVydGV4IGYgPVxuICAgIEhNLm1hcCAoZnVuIHYgcyAtPiBmIHYsIFMuZm9sZCAoZnVuIHYgcyAtPiBTLmFkZCAoZiB2KSBzKSBzIFMuZW1wdHkpXG5cbiAgbW9kdWxlIEkgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBTLnQgSE0udFxuICAgIG1vZHVsZSBQViA9IFZcbiAgICBtb2R1bGUgUEUgPSBFXG4gICAgbGV0IGl0ZXJfZWRnZXMgZiA9IEhNLml0ZXIgKGZ1biB2IC0+IFMuaXRlciAoZiB2KSlcbiAgICBsZXQgZm9sZF9lZGdlcyBmID0gSE0uZm9sZCAoZnVuIHYgLT4gUy5mb2xkIChmIHYpKVxuICAgIGxldCBpdGVyX2VkZ2VzX2UgZiA9IGl0ZXJfZWRnZXMgKGZ1biB2MSB2MiAtPiBmICh2MSwgdjIpKVxuICAgIGxldCBmb2xkX2VkZ2VzX2UgZiA9IGZvbGRfZWRnZXMgKGZ1biB2MSB2MiBhIC0+IGYgKHYxLCB2MikgYSlcbiAgZW5kXG4gIGluY2x1ZGUgSVxuXG4gIGluY2x1ZGUgUHJlZChzdHJ1Y3QgaW5jbHVkZSBJIGxldCBtZW1fdmVydGV4ID0gSE0ubWVtIGVuZClcblxuZW5kXG5cbigqKiBDb21tb24gaW1wbGVtZW50YXRpb24gdG8gYWxsIHRoZSBsYWJlbGVkIChkaXJlY3RlZCkgZ3JhcGhzLiAqKVxubW9kdWxlIExhYmVsZWQoVjogQ09NUEFSQUJMRSkoRTogT1JERVJFRF9UWVBFKShITTogSE0gd2l0aCB0eXBlIGtleSA9IFYudCkgPVxuc3RydWN0XG5cbiAgbW9kdWxlIFZFID0gT1RQcm9kdWN0KFYpKEUpXG4gIG1vZHVsZSBTID0gU2V0Lk1ha2UoVkUpXG5cbiAgbW9kdWxlIEUgPSBzdHJ1Y3RcbiAgICB0eXBlIHZlcnRleCA9IFYudFxuICAgIHR5cGUgbGFiZWwgPSBFLnRcbiAgICB0eXBlIHQgPSB2ZXJ0ZXggKiBsYWJlbCAqIHZlcnRleFxuICAgIGxldCBzcmMgKHYsIF8sIF8pID0gdlxuICAgIGxldCBkc3QgKF8sIF8sIHYpID0gdlxuICAgIGxldCBsYWJlbCAoXywgbCwgXykgPSBsXG4gICAgbGV0IGNyZWF0ZSB2MSBsIHYyID0gdjEsIGwsIHYyXG4gICAgbW9kdWxlIEMgPSBPVFByb2R1Y3QoVikoVkUpXG4gICAgbGV0IGNvbXBhcmUgKHgxLCB4MiwgeDMpICh5MSwgeTIsIHkzKSA9XG4gICAgICBDLmNvbXBhcmUgKHgxLCAoeDMsIHgyKSkgKHkxLCAoeTMsIHkyKSlcbiAgZW5kXG4gIHR5cGUgZWRnZSA9IEUudFxuXG4gIGxldCBtZW1fZWRnZSBnIHYxIHYyID1cbiAgICB0cnkgUy5leGlzdHMgKGZ1biAodjInLCBfKSAtPiBWLmVxdWFsIHYyIHYyJykgKEhNLmZpbmQgdjEgZylcbiAgICB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG4gIGxldCBtZW1fZWRnZV9lIGcgKHYxLCBsLCB2MikgPVxuICAgIHRyeVxuICAgICAgbGV0IHZlID0gdjIsIGwgaW5cbiAgICAgIFMuZXhpc3RzIChmdW4gdmUnIC0+IFZFLmNvbXBhcmUgdmUgdmUnID0gMCkgKEhNLmZpbmQgdjEgZylcbiAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgZmFsc2VcblxuICBleGNlcHRpb24gRm91bmQgb2YgZWRnZVxuICBsZXQgZmluZF9lZGdlIGcgdjEgdjIgPVxuICAgIHRyeVxuICAgICAgUy5pdGVyXG4gICAgICAgIChmdW4gKHYyJywgbCkgLT4gaWYgVi5lcXVhbCB2MiB2MicgdGhlbiByYWlzZSAoRm91bmQgKHYxLCBsLCB2MicpKSlcbiAgICAgICAgKEhNLmZpbmQgdjEgZyk7XG4gICAgICByYWlzZSBOb3RfZm91bmRcbiAgICB3aXRoIEZvdW5kIGUgLT5cbiAgICAgIGVcblxuICBsZXQgZmluZF9hbGxfZWRnZXMgZyB2MSB2MiA9XG4gICAgdHJ5XG4gICAgICBTLmZvbGRcbiAgICAgICAgKGZ1biAodjInLCBsKSBhY2MgLT5cbiAgICAgICAgICAgaWYgVi5lcXVhbCB2MiB2MicgdGhlbiAodjEsIGwsIHYyJykgOjogYWNjIGVsc2UgYWNjKVxuICAgICAgICAoSE0uZmluZCB2MSBnKVxuICAgICAgICBbXVxuICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICBbXVxuXG4gIGxldCB1bnNhZmVfcmVtb3ZlX2VkZ2UgZyB2MSB2MiA9XG4gICAgSE0uYWRkXG4gICAgICB2MVxuICAgICAgKFMuZmlsdGVyIChmdW4gKHYyJywgXykgLT4gbm90IChWLmVxdWFsIHYyIHYyJykpIChITS5maW5kIHYxIGcpKVxuICAgICAgZ1xuXG4gIGxldCB1bnNhZmVfcmVtb3ZlX2VkZ2VfZSBnICh2MSwgbCwgdjIpID1cbiAgICBITS5hZGQgdjEgKFMucmVtb3ZlICh2MiwgbCkgKEhNLmZpbmQgdjEgZykpIGdcblxuICBsZXQgcmVtb3ZlX2VkZ2UgZyB2MSB2MiA9XG4gICAgaWYgbm90IChITS5tZW0gdjIgZykgdGhlbiBpbnZhbGlkX2FyZyBcIltvY2FtbGdyYXBoXSByZW1vdmVfZWRnZVwiO1xuICAgIEhNLmFkZFxuICAgICAgdjFcbiAgICAgIChTLmZpbHRlclxuICAgICAgICAgKGZ1biAodjInLCBfKSAtPiBub3QgKFYuZXF1YWwgdjIgdjInKSlcbiAgICAgICAgIChITS5maW5kX2FuZF9yYWlzZSB2MSBnIFwiW29jYW1sZ3JhcGhdIHJlbW92ZV9lZGdlXCIpKVxuICAgICAgZ1xuXG4gIGxldCByZW1vdmVfZWRnZV9lIGcgKHYxLCBsLCB2MikgPVxuICAgIGlmIG5vdCAoSE0ubWVtIHYyIGcpIHRoZW4gaW52YWxpZF9hcmcgXCJbb2NhbWxncmFwaF0gcmVtb3ZlX2VkZ2VfZVwiO1xuICAgIEhNLmFkZFxuICAgICAgdjFcbiAgICAgIChTLnJlbW92ZSAodjIsIGwpIChITS5maW5kX2FuZF9yYWlzZSB2MSBnIFwiW29jYW1sZ3JhcGhdIHJlbW92ZV9lZGdlX2VcIikpXG4gICAgICBnXG5cbiAgbGV0IGl0ZXJfc3VjYyBmIGcgdiA9XG4gICAgUy5pdGVyIChmdW4gKHcsIF8pIC0+IGYgdykgKEhNLmZpbmRfYW5kX3JhaXNlIHYgZyBcIltvY2FtbGdyYXBoXSBpdGVyX3N1Y2NcIilcbiAgbGV0IGZvbGRfc3VjYyBmIGcgdiA9XG4gICAgUy5mb2xkIChmdW4gKHcsIF8pIC0+IGYgdykgKEhNLmZpbmRfYW5kX3JhaXNlIHYgZyBcIltvY2FtbGdyYXBoXSBmb2xkX3N1Y2NcIilcblxuICBsZXQgaXRlcl9zdWNjX2UgZiBnIHYgPVxuICAgIFMuaXRlclxuICAgICAgKGZ1biAodywgbCkgLT4gZiAodiwgbCwgdykpXG4gICAgICAoSE0uZmluZF9hbmRfcmFpc2UgdiBnIFwiW29jYW1sZ3JhcGhdIGl0ZXJfc3VjY19lXCIpXG5cbiAgbGV0IGZvbGRfc3VjY19lIGYgZyB2ID1cbiAgICBTLmZvbGRcbiAgICAgIChmdW4gKHcsIGwpIC0+IGYgKHYsIGwsIHcpKVxuICAgICAgKEhNLmZpbmRfYW5kX3JhaXNlIHYgZyBcIltvY2FtbGdyYXBoXSBmb2xkX3N1Y2NfZVwiKVxuXG4gIGxldCBzdWNjIGcgdiA9IGZvbGRfc3VjYyAoZnVuIHcgbCAtPiB3IDo6IGwpIGcgdiBbXVxuICBsZXQgc3VjY19lIGcgdiA9IGZvbGRfc3VjY19lIChmdW4gZSBsIC0+IGUgOjogbCkgZyB2IFtdXG5cbiAgbGV0IG1hcF92ZXJ0ZXggZiA9XG4gICAgSE0ubWFwXG4gICAgICAoZnVuIHYgcyAtPiBmIHYsIFMuZm9sZCAoZnVuICh2LCBsKSBzIC0+IFMuYWRkIChmIHYsIGwpIHMpIHMgUy5lbXB0eSlcblxuICBtb2R1bGUgSSA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IFMudCBITS50XG4gICAgbW9kdWxlIFBWID0gVlxuICAgIG1vZHVsZSBQRSA9IEVcbiAgICBsZXQgaXRlcl9lZGdlcyBmID0gSE0uaXRlciAoZnVuIHYgLT4gUy5pdGVyIChmdW4gKHcsIF8pIC0+IGYgdiB3KSlcbiAgICBsZXQgZm9sZF9lZGdlcyBmID0gSE0uZm9sZCAoZnVuIHYgLT4gUy5mb2xkIChmdW4gKHcsIF8pIC0+IGYgdiB3KSlcbiAgICBsZXQgaXRlcl9lZGdlc19lIGYgPVxuICAgICAgSE0uaXRlciAoZnVuIHYgLT4gUy5pdGVyIChmdW4gKHcsIGwpIC0+IGYgKHYsIGwsIHcpKSlcbiAgICBsZXQgZm9sZF9lZGdlc19lIGYgPVxuICAgICAgSE0uZm9sZCAoZnVuIHYgLT4gUy5mb2xkIChmdW4gKHcsIGwpIC0+IGYgKHYsIGwsIHcpKSlcbiAgZW5kXG4gIGluY2x1ZGUgSVxuXG4gIGluY2x1ZGUgUHJlZChzdHJ1Y3QgaW5jbHVkZSBJIGxldCBtZW1fdmVydGV4ID0gSE0ubWVtIGVuZClcblxuZW5kXG5cbigqKiBUaGUgdmVydGV4IG1vZHVsZSBhbmQgdGhlIHZlcnRleCB0YWJsZSBmb3IgdGhlIGNvbmNyZXRlIGdyYXBocy4gKilcbm1vZHVsZSBDb25jcmV0ZVZlcnRleChGIDogVEJMX0JVSUxERVIpKFY6IENPTVBBUkFCTEUpID0gc3RydWN0XG4gIG1vZHVsZSBWID0gc3RydWN0XG4gICAgaW5jbHVkZSBWXG4gICAgdHlwZSBsYWJlbCA9IHRcbiAgICBsZXQgbGFiZWwgdiA9IHZcbiAgICBsZXQgY3JlYXRlIHYgPSB2XG4gIGVuZFxuICBtb2R1bGUgSE0gPSBGKFYpXG5lbmRcblxubW9kdWxlIE1ha2VfQWJzdHJhY3RcbiAgICAoRzogc2lnXG4gICAgICAgbW9kdWxlIEhNOiBITVxuICAgICAgIG1vZHVsZSBTOiBTZXQuU1xuICAgICAgIGluY2x1ZGUgRyB3aXRoIHR5cGUgdCA9IFMudCBITS50IGFuZCB0eXBlIFYudCA9IEhNLmtleVxuICAgICAgIHZhbCByZW1vdmVfZWRnZTogdCAtPiB2ZXJ0ZXggLT4gdmVydGV4IC0+IHRcbiAgICAgICB2YWwgcmVtb3ZlX2VkZ2VfZTogdCAtPiBlZGdlIC0+IHRcbiAgICAgICAoKiB2YWwgdW5zYWZlX2FkZF92ZXJ0ZXg6IHQgLT4gdmVydGV4IC0+IHQgKikgKCogV2FzIHVudXNlZCAqKVxuICAgICAgIHZhbCB1bnNhZmVfYWRkX2VkZ2U6IHQgLT4gdmVydGV4IC0+IFMuZWx0IC0+IHRcbiAgICAgICB2YWwgdW5zYWZlX3JlbW92ZV9lZGdlOiB0IC0+IHZlcnRleCAtPiB2ZXJ0ZXggLT4gdFxuICAgICAgIHZhbCB1bnNhZmVfcmVtb3ZlX2VkZ2VfZTogdCAtPiBlZGdlIC0+IHRcbiAgICAgICB2YWwgY3JlYXRlOiA/c2l6ZTppbnQgLT4gdW5pdCAtPiB0XG4gICAgICAgdmFsIGNsZWFyOiB0IC0+IHVuaXRcbiAgICAgZW5kKSA9XG5zdHJ1Y3RcblxuICBtb2R1bGUgSSA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IHsgZWRnZXMgOiBHLnQ7IG11dGFibGUgc2l6ZSA6IGludCB9XG4gICAgKCogQkUgQ0FSRUZVTDogW3NpemVdIGlzIG9ubHkgbXV0YWJsZSBpbiB0aGUgaW1wZXJhdGl2ZSB2ZXJzaW9uLiBBc1xuICAgICAgIHRoZXJlIGlzIG5vIGV4dGVuc2libGUgcmVjb3JkcyBpbiBjdXJyZW50IG9jYW1sIHZlcnNpb24sIGFuZCBmb3JcbiAgICAgICBnZW5lcmljaXR5IHB1cnBvc2UsIFtzaXplXSBpcyBtdXRhYmxlIGluIGJvdGggaW1wZXJhdGl2ZSBhbmRcbiAgICAgICBwZXJzaXN0ZW50IGltcGxlbWVudGF0aW9ucy5cbiAgICAgICBEbyBub3QgbW9kaWZ5IHNpemUgaW4gdGhlIHBlcnNpc3RlbnQgaW1wbGVtZW50YXRpb24hICopXG5cbiAgICB0eXBlIHZlcnRleCA9IEcudmVydGV4XG4gICAgdHlwZSBlZGdlID0gRy5lZGdlXG5cbiAgICBtb2R1bGUgUFYgPSBHLlZcbiAgICBtb2R1bGUgUEUgPSBHLkVcblxuICAgIGxldCBpdGVyX2VkZ2VzIGYgZyA9IEcuaXRlcl9lZGdlcyBmIGcuZWRnZXNcbiAgICBsZXQgZm9sZF9lZGdlcyBmIGcgPSBHLmZvbGRfZWRnZXMgZiBnLmVkZ2VzXG4gICAgbGV0IGl0ZXJfZWRnZXNfZSBmIGcgPSBHLml0ZXJfZWRnZXNfZSBmIGcuZWRnZXNcbiAgICBsZXQgZm9sZF9lZGdlc19lIGYgZyA9IEcuZm9sZF9lZGdlc19lIGYgZy5lZGdlc1xuICAgIGxldCBtZW1fdmVydGV4IHYgZyA9IEcubWVtX3ZlcnRleCBnLmVkZ2VzIHZcbiAgICBsZXQgY3JlYXRlID9zaXplICgpID0geyBlZGdlcyA9IEcuY3JlYXRlID9zaXplICgpOyBzaXplID0gMCB9XG4gICAgbGV0IGNsZWFyIGcgPSBHLmNsZWFyIGcuZWRnZXM7IGcuc2l6ZSA8LSAwXG4gIGVuZFxuICBpbmNsdWRlIElcblxuICBpbmNsdWRlIFByZWQoSSlcblxuICAoKiBvcHRpbWlzYXRpb25zICopXG5cbiAgbGV0IGlzX2VtcHR5IGcgPSBnLnNpemUgPSAwXG4gIGxldCBuYl92ZXJ0ZXggZyA9IGcuc2l6ZVxuXG4gICgqIHJlZGVmaW5pdGlvbnMgKilcbiAgbW9kdWxlIFYgPSBHLlZcbiAgbW9kdWxlIEUgPSBHLkVcbiAgbW9kdWxlIEhNID0gRy5ITVxuICBtb2R1bGUgUyA9IEcuU1xuXG4gIGxldCB1bnNhZmVfYWRkX2VkZ2UgPSBHLnVuc2FmZV9hZGRfZWRnZVxuICBsZXQgdW5zYWZlX3JlbW92ZV9lZGdlID0gRy51bnNhZmVfcmVtb3ZlX2VkZ2VcbiAgbGV0IHVuc2FmZV9yZW1vdmVfZWRnZV9lID0gRy51bnNhZmVfcmVtb3ZlX2VkZ2VfZVxuICBsZXQgaXNfZGlyZWN0ZWQgPSBHLmlzX2RpcmVjdGVkXG5cbiAgbGV0IHJlbW92ZV9lZGdlIGcgPSBHLnJlbW92ZV9lZGdlIGcuZWRnZXNcbiAgbGV0IHJlbW92ZV9lZGdlX2UgZyA9IEcucmVtb3ZlX2VkZ2VfZSBnLmVkZ2VzXG5cbiAgbGV0IG91dF9kZWdyZWUgZyA9IEcub3V0X2RlZ3JlZSBnLmVkZ2VzXG4gIGxldCBpbl9kZWdyZWUgZyA9IEcuaW5fZGVncmVlIGcuZWRnZXNcblxuICBsZXQgbmJfZWRnZXMgZyA9IEcubmJfZWRnZXMgZy5lZGdlc1xuICBsZXQgc3VjYyBnID0gRy5zdWNjIGcuZWRnZXNcbiAgbGV0IG1lbV92ZXJ0ZXggZyA9IEcubWVtX3ZlcnRleCBnLmVkZ2VzXG4gIGxldCBtZW1fZWRnZSBnID0gRy5tZW1fZWRnZSBnLmVkZ2VzXG4gIGxldCBtZW1fZWRnZV9lIGcgPSBHLm1lbV9lZGdlX2UgZy5lZGdlc1xuICBsZXQgZmluZF9lZGdlIGcgPSBHLmZpbmRfZWRnZSBnLmVkZ2VzXG4gIGxldCBmaW5kX2FsbF9lZGdlcyBnID0gRy5maW5kX2FsbF9lZGdlcyBnLmVkZ2VzXG5cbiAgbGV0IGl0ZXJfdmVydGV4IGYgZyA9IEcuaXRlcl92ZXJ0ZXggZiBnLmVkZ2VzXG4gIGxldCBmb2xkX3ZlcnRleCBmIGcgPSBHLmZvbGRfdmVydGV4IGYgZy5lZGdlc1xuICBsZXQgaXRlcl9zdWNjIGYgZyA9IEcuaXRlcl9zdWNjIGYgZy5lZGdlc1xuICBsZXQgZm9sZF9zdWNjIGYgZyA9IEcuZm9sZF9zdWNjIGYgZy5lZGdlc1xuICBsZXQgc3VjY19lIGcgPSBHLnN1Y2NfZSBnLmVkZ2VzXG4gIGxldCBpdGVyX3N1Y2NfZSBmIGcgPSBHLml0ZXJfc3VjY19lIGYgZy5lZGdlc1xuICBsZXQgZm9sZF9zdWNjX2UgZiBnID0gRy5mb2xkX3N1Y2NfZSBmIGcuZWRnZXNcbiAgbGV0IG1hcF92ZXJ0ZXggZiBnID0geyBnIHdpdGggZWRnZXMgPSBHLm1hcF92ZXJ0ZXggZiBnLmVkZ2VzIH1cblxuICAoKiByZWltcGxlbWVudGF0aW9uICopXG5cbiAgbGV0IGNvcHkgZyA9XG4gICAgbGV0IGggPSBITS5jcmVhdGUgKCkgaW5cbiAgICBsZXQgdmVydGV4IHYgPVxuICAgICAgdHJ5XG4gICAgICAgIEhNLmZpbmQgdiBoXG4gICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICBsZXQgdicgPSBWLmNyZWF0ZSAoVi5sYWJlbCB2KSBpblxuICAgICAgICBsZXQgaCcgPSBITS5hZGQgdiB2JyBoIGluXG4gICAgICAgIGFzc2VydCAoaCA9PSBoJyk7XG4gICAgICAgIHYnXG4gICAgaW5cbiAgICBtYXBfdmVydGV4IHZlcnRleCBnXG5cbmVuZFxuXG4oKiogU3VwcG9ydCBmb3IgZXhwbGljaXRseSBtYWludGFpbmluZyBlZGdlIHNldCBvZlxuICAgIHByZWRlY2Vzc29ycy4gIENydWNpYWwgZm9yIGFsZ29yaXRobXMgdGhhdCBkbyBhIGxvdCBvZiBiYWNrd2FyZHNcbiAgICB0cmF2ZXJzYWwuICopXG5cbm1vZHVsZSBCaWRpcmVjdGlvbmFsTWluaW1hbChTOlNldC5TKShITTpITSkgPSBzdHJ1Y3RcblxuICB0eXBlIHZlcnRleCA9IEhNLmtleVxuXG4gIGxldCBpc19kaXJlY3RlZCA9IHRydWVcbiAgbGV0IGVtcHR5ID0gSE0uZW1wdHlcbiAgbGV0IGNyZWF0ZSA9IEhNLmNyZWF0ZVxuICBsZXQgY2xlYXIgPSBITS5jbGVhclxuICBsZXQgaXNfZW1wdHkgPSBITS5pc19lbXB0eVxuICBsZXQgY29weSA9IEhNLmNvcHlcblxuICBsZXQgbmJfdmVydGV4IGcgPSBITS5mb2xkIChmdW4gXyBfIC0+IHN1Y2MpIGcgMFxuICBsZXQgbmJfZWRnZXMgZyA9IEhNLmZvbGQgKGZ1biBfIChfLHMpIG4gLT4gbiArIFMuY2FyZGluYWwgcykgZyAwXG4gIGxldCBvdXRfZGVncmVlIGcgdiA9XG4gICAgUy5jYXJkaW5hbFxuICAgICAgKHNuZCAodHJ5IEhNLmZpbmQgdiBnXG4gICAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPiBpbnZhbGlkX2FyZyBcIltvY2FtbGdyYXBoXSBvdXRfZGVncmVlXCIpKVxuXG4gIGxldCBtZW1fdmVydGV4IGcgdiA9IEhNLm1lbSB2IGdcblxuICBsZXQgdW5zYWZlX2FkZF92ZXJ0ZXggZyB2ID0gSE0uYWRkIHYgKFMuZW1wdHksIFMuZW1wdHkpIGdcbiAgbGV0IGFkZF92ZXJ0ZXggZyB2ID0gaWYgSE0ubWVtIHYgZyB0aGVuIGcgZWxzZSB1bnNhZmVfYWRkX3ZlcnRleCBnIHZcblxuICBsZXQgaXRlcl92ZXJ0ZXggZiA9IEhNLml0ZXIgKGZ1biB2IF8gLT4gZiB2KVxuICBsZXQgZm9sZF92ZXJ0ZXggZiA9IEhNLmZvbGQgKGZ1biB2IF8gLT4gZiB2KVxuXG5lbmRcblxubW9kdWxlIEJpZGlyZWN0aW9uYWxVbmxhYmVsZWQoVjpDT01QQVJBQkxFKShITTpITSB3aXRoIHR5cGUga2V5ID0gVi50KSA9IHN0cnVjdFxuXG4gIG1vZHVsZSBTID0gU2V0Lk1ha2UoVilcblxuICBtb2R1bGUgRSA9IHN0cnVjdFxuICAgIHR5cGUgdmVydGV4ID0gVi50XG4gICAgaW5jbHVkZSBPVFByb2R1Y3QoVikoVilcbiAgICBsZXQgc3JjID0gZnN0XG4gICAgbGV0IGRzdCA9IHNuZFxuICAgIHR5cGUgbGFiZWwgPSB1bml0XG4gICAgbGV0IGxhYmVsIF8gPSAoKVxuICAgIGxldCBjcmVhdGUgdjEgKCkgdjIgPSB2MSwgdjJcbiAgZW5kXG4gIHR5cGUgZWRnZSA9IEUudFxuXG4gIGxldCBtZW1fZWRnZSBnIHYxIHYyID1cbiAgICB0cnkgUy5tZW0gdjIgKHNuZCAoSE0uZmluZCB2MSBnKSlcbiAgICB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG4gIGxldCBtZW1fZWRnZV9lIGcgKHYxLHYyKSA9IG1lbV9lZGdlIGcgdjEgdjJcblxuICBsZXQgZmluZF9lZGdlIGcgdjEgdjIgPSBpZiBtZW1fZWRnZSBnIHYxIHYyIHRoZW4gdjEsIHYyIGVsc2UgcmFpc2UgTm90X2ZvdW5kXG4gIGxldCBmaW5kX2FsbF9lZGdlcyBnIHYxIHYyID0gdHJ5IFsgZmluZF9lZGdlIGcgdjEgdjIgXSB3aXRoIE5vdF9mb3VuZCAtPiBbXVxuXG4gIGxldCB1bnNhZmVfcmVtb3ZlX2VkZ2UgZyB2MSB2MiA9XG4gICAgbGV0IGluX3NldCwgb3V0X3NldCA9IEhNLmZpbmQgdjEgZyBpblxuICAgIGxldCBnID0gSE0uYWRkIHYxIChpbl9zZXQsIFMucmVtb3ZlIHYyIG91dF9zZXQpIGcgaW5cbiAgICBsZXQgaW5fc2V0LCBvdXRfc2V0ID0gSE0uZmluZCB2MiBnIGluXG4gICAgSE0uYWRkIHYyIChTLnJlbW92ZSB2MSBpbl9zZXQsIG91dF9zZXQpIGdcblxuICBsZXQgdW5zYWZlX3JlbW92ZV9lZGdlX2UgZyAodjEsdjIpID0gdW5zYWZlX3JlbW92ZV9lZGdlIGcgdjEgdjJcblxuICBsZXQgcmVtb3ZlX2VkZ2UgZyB2MSB2MiA9XG4gICAgaWYgbm90IChITS5tZW0gdjIgZyAmJiBITS5tZW0gdjEgZykgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJbb2NhbWxncmFwaF0gcmVtb3ZlX2VkZ2VcIjtcbiAgICB1bnNhZmVfcmVtb3ZlX2VkZ2UgZyB2MSB2MlxuXG4gIGxldCByZW1vdmVfZWRnZV9lIGcgKHYxLCB2MikgPSByZW1vdmVfZWRnZSBnIHYxIHYyXG5cbiAgbGV0IGl0ZXJfc3VjYyBmIGcgdiA9XG4gICAgUy5pdGVyIGYgKHNuZCAoSE0uZmluZF9hbmRfcmFpc2UgdiBnIFwiW29jYW1sZ3JhcGhdIGl0ZXJfc3VjY1wiKSlcblxuICBsZXQgZm9sZF9zdWNjIGYgZyB2ID1cbiAgICBTLmZvbGQgZiAoc25kIChITS5maW5kX2FuZF9yYWlzZSB2IGcgXCJbb2NhbWxncmFwaF0gZm9sZF9zdWNjXCIpKVxuXG4gIGxldCBpdGVyX3N1Y2NfZSBmIGcgdiA9IGl0ZXJfc3VjYyAoZnVuIHYyIC0+IGYgKHYsIHYyKSkgZyB2XG4gIGxldCBmb2xkX3N1Y2NfZSBmIGcgdiA9IGZvbGRfc3VjYyAoZnVuIHYyIC0+IGYgKHYsIHYyKSkgZyB2XG5cbiAgbGV0IHN1Y2MgZyB2ID0gUy5lbGVtZW50cyAoc25kIChITS5maW5kX2FuZF9yYWlzZSB2IGcgXCJbb2NhbWxncmFwaF0gc3VjY1wiKSlcbiAgbGV0IHN1Y2NfZSBnIHYgPSBmb2xkX3N1Y2NfZSAoZnVuIGUgbCAtPiBlIDo6IGwpIGcgdiBbXVxuXG4gIGxldCBtYXBfdmVydGV4IGYgPVxuICAgIEhNLm1hcFxuICAgICAgKGZ1biB2IChzMSxzMikgLT5cbiAgICAgICAgIGYgdixcbiAgICAgICAgIChTLmZvbGQgKGZ1biB2IHMgLT4gUy5hZGQgKGYgdikgcykgczEgUy5lbXB0eSxcbiAgICAgICAgICBTLmZvbGQgKGZ1biB2IHMgLT4gUy5hZGQgKGYgdikgcykgczIgUy5lbXB0eSkpXG5cbiAgbW9kdWxlIEkgPSBzdHJ1Y3RcbiAgICAoKiB3ZSBrZWVwIHNldHMgZm9yIGJvdGggaW5jb21pbmcgYW5kIG91dGdvaW5nIGVkZ2VzICopXG4gICAgdHlwZSB0ID0gKFMudCAoKiBpbmNvbWluZyAqKSAqIFMudCAoKiBvdXRnb2luZyAqKSkgSE0udFxuICAgIG1vZHVsZSBQViA9IFZcbiAgICBtb2R1bGUgUEUgPSBFXG4gICAgbGV0IGl0ZXJfZWRnZXMgZiA9IEhNLml0ZXIgKGZ1biB2IChfLCBvdXRzZXQpIC0+IFMuaXRlciAoZiB2KSBvdXRzZXQpXG4gICAgbGV0IGZvbGRfZWRnZXMgZiA9IEhNLmZvbGQgKGZ1biB2IChfLCBvdXRzZXQpIC0+IFMuZm9sZCAoZiB2KSBvdXRzZXQpXG4gICAgbGV0IGl0ZXJfZWRnZXNfZSBmID0gaXRlcl9lZGdlcyAoZnVuIHYxIHYyIC0+IGYgKHYxLCB2MikpXG4gICAgbGV0IGZvbGRfZWRnZXNfZSBmID0gZm9sZF9lZGdlcyAoZnVuIHYxIHYyIGEgLT4gZiAodjEsIHYyKSBhKVxuICBlbmRcbiAgaW5jbHVkZSBJXG5cbiAgbGV0IGl0ZXJfcHJlZCBmIGcgdiA9XG4gICAgUy5pdGVyIGYgKGZzdCAoSE0uZmluZF9hbmRfcmFpc2UgdiBnIFwiW29jYW1sZ3JhcGhdIGl0ZXJfcHJlZFwiKSlcblxuICBsZXQgZm9sZF9wcmVkIGYgZyB2ID1cbiAgICBTLmZvbGQgZiAoZnN0IChITS5maW5kX2FuZF9yYWlzZSB2IGcgXCJbb2NhbWxncmFwaF0gZm9sZF9wcmVkXCIpKVxuXG4gIGxldCBwcmVkIGcgdiA9IFMuZWxlbWVudHMgKGZzdCAoSE0uZmluZF9hbmRfcmFpc2UgdiBnIFwiW29jYW1sZ3JhcGhdIHByZWRcIikpXG5cbiAgbGV0IGluX2RlZ3JlZSBnIHYgPVxuICAgIFMuY2FyZGluYWxcbiAgICAgIChmc3QgKHRyeSBITS5maW5kIHYgZ1xuICAgICAgICAgICAgd2l0aCBOb3RfZm91bmQgLT4gaW52YWxpZF9hcmcgXCJbb2NhbWxncmFwaF0gaW5fZGVncmVlXCIpKVxuXG4gIGxldCBpdGVyX3ByZWRfZSBmIGcgdiA9IGl0ZXJfcHJlZCAoZnVuIHYyIC0+IGYgKHYyLCB2KSkgZyB2XG4gIGxldCBmb2xkX3ByZWRfZSBmIGcgdiA9IGZvbGRfcHJlZCAoZnVuIHYyIC0+IGYgKHYyLCB2KSkgZyB2XG5cbiAgbGV0IHByZWRfZSBnIHYgPSBmb2xkX3ByZWRfZSAoZnVuIGUgbCAtPiBlIDo6IGwpIGcgdiBbXVxuXG5lbmRcblxubW9kdWxlIEJpZGlyZWN0aW9uYWxMYWJlbGVkXG4gICAgKFY6Q09NUEFSQUJMRSkoRTpPUkRFUkVEX1RZUEUpKEhNOkhNIHdpdGggdHlwZSBrZXkgPSBWLnQpID1cbnN0cnVjdFxuXG4gIG1vZHVsZSBWRSA9IE9UUHJvZHVjdChWKShFKVxuICBtb2R1bGUgUyA9IFNldC5NYWtlKFZFKVxuXG4gIG1vZHVsZSBFID0gc3RydWN0XG4gICAgdHlwZSB2ZXJ0ZXggPSBWLnRcbiAgICB0eXBlIGxhYmVsID0gRS50XG4gICAgdHlwZSB0ID0gdmVydGV4ICogbGFiZWwgKiB2ZXJ0ZXhcbiAgICBsZXQgc3JjICh2LCBfLCBfKSA9IHZcbiAgICBsZXQgZHN0IChfLCBfLCB2KSA9IHZcbiAgICBsZXQgbGFiZWwgKF8sIGwsIF8pID0gbFxuICAgIGxldCBjcmVhdGUgdjEgbCB2MiA9IHYxLCBsLCB2MlxuICAgIG1vZHVsZSBDID0gT1RQcm9kdWN0KFYpKFZFKVxuICAgIGxldCBjb21wYXJlICh4MSwgeDIsIHgzKSAoeTEsIHkyLCB5MykgPVxuICAgICAgQy5jb21wYXJlICh4MSwgKHgzLCB4MikpICh5MSwgKHkzLCB5MikpXG4gIGVuZFxuICB0eXBlIGVkZ2UgPSBFLnRcblxuICBsZXQgbWVtX2VkZ2UgZyB2MSB2MiA9XG4gICAgdHJ5IFMuZXhpc3RzIChmdW4gKHYyJywgXykgLT4gVi5lcXVhbCB2MiB2MicpIChzbmQgKEhNLmZpbmQgdjEgZykpXG4gICAgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuICBsZXQgbWVtX2VkZ2VfZSBnICh2MSwgbCwgdjIpID1cbiAgICB0cnlcbiAgICAgIGxldCB2ZSA9IHYyLCBsIGluXG4gICAgICBTLmV4aXN0cyAoZnVuIHZlJyAtPiBWRS5jb21wYXJlIHZlIHZlJyA9IDApIChzbmQgKEhNLmZpbmQgdjEgZykpXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgIGZhbHNlXG5cbiAgZXhjZXB0aW9uIEZvdW5kIG9mIGVkZ2VcbiAgbGV0IGZpbmRfZWRnZSBnIHYxIHYyID1cbiAgICB0cnlcbiAgICAgIFMuaXRlclxuICAgICAgICAoZnVuICh2MicsIGwpIC0+IGlmIFYuZXF1YWwgdjIgdjInIHRoZW4gcmFpc2UgKEZvdW5kICh2MSwgbCwgdjInKSkpXG4gICAgICAgIChzbmQgKEhNLmZpbmQgdjEgZykpO1xuICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgd2l0aCBGb3VuZCBlIC0+XG4gICAgICBlXG5cbiAgbGV0IGZpbmRfYWxsX2VkZ2VzIGcgdjEgdjIgPVxuICAgIHRyeVxuICAgICAgUy5mb2xkXG4gICAgICAgIChmdW4gKHYyJywgbCkgYWNjIC0+XG4gICAgICAgICAgIGlmIFYuZXF1YWwgdjIgdjInIHRoZW4gKHYxLCBsLCB2MicpIDo6IGFjYyBlbHNlIGFjYylcbiAgICAgICAgKHNuZCAoSE0uZmluZCB2MSBnKSlcbiAgICAgICAgW11cbiAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgW11cblxuICBsZXQgdW5zYWZlX3JlbW92ZV9lZGdlIGcgdjEgdjIgPVxuICAgIGxldCBpbl9zZXQsIG91dF9zZXQgPSBITS5maW5kIHYxIGcgaW5cbiAgICBsZXQgZGVsIHYgc2V0ID0gUy5maWx0ZXIgKGZ1biAodicsIF8pIC0+IG5vdCAoVi5lcXVhbCB2IHYnKSkgc2V0IGluXG4gICAgbGV0IGcgPSBITS5hZGQgdjEgKGluX3NldCwgZGVsIHYyIG91dF9zZXQpIGcgaW5cbiAgICBsZXQgaW5fc2V0LCBvdXRfc2V0ID0gSE0uZmluZCB2MiBnIGluXG4gICAgSE0uYWRkIHYyIChkZWwgdjEgaW5fc2V0LCBvdXRfc2V0KSBnXG5cbiAgbGV0IHVuc2FmZV9yZW1vdmVfZWRnZV9lIGcgKHYxLCBsLCB2MikgPVxuICAgIGxldCBpbl9zZXQsIG91dF9zZXQgPSBITS5maW5kIHYxIGcgaW5cbiAgICBsZXQgZyA9IEhNLmFkZCB2MSAoaW5fc2V0LCBTLnJlbW92ZSAodjIsIGwpIG91dF9zZXQpIGcgaW5cbiAgICBsZXQgaW5fc2V0LCBvdXRfc2V0ID0gSE0uZmluZCB2MiBnIGluXG4gICAgSE0uYWRkIHYyIChTLnJlbW92ZSAodjEsIGwpIGluX3NldCwgb3V0X3NldCkgZ1xuXG4gIGxldCByZW1vdmVfZWRnZSBnIHYxIHYyID1cbiAgICAoKiAgICBpZiBub3QgKEhNLm1lbSB2MiBnKSB0aGVuIGludmFsaWRfYXJnIFwiW29jYW1sZ3JhcGhdIHJlbW92ZV9lZGdlXCI7KilcbiAgICBsZXQgaW5fc2V0LCBvdXRfc2V0ID0gSE0uZmluZF9hbmRfcmFpc2UgdjEgZyBcIltvY2FtbGdyYXBoXSByZW1vdmVfZWRnZVwiIGluXG4gICAgbGV0IGRlbCB2IHNldCA9IFMuZmlsdGVyIChmdW4gKHYnLCBfKSAtPiBub3QgKFYuZXF1YWwgdiB2JykpIHNldCBpblxuICAgIGxldCBnID0gSE0uYWRkIHYxIChpbl9zZXQsIGRlbCB2MiBvdXRfc2V0KSBnIGluXG4gICAgbGV0IGluX3NldCwgb3V0X3NldCA9IEhNLmZpbmRfYW5kX3JhaXNlIHYyIGcgXCJbb2NhbWxncmFwaF0gcmVtb3ZlX2VkZ2VcIiBpblxuICAgIEhNLmFkZCB2MiAoZGVsIHYxIGluX3NldCwgb3V0X3NldCkgZ1xuXG4gIGxldCByZW1vdmVfZWRnZV9lIGcgKHYxLCBsLCB2MikgPVxuICAgICgqICAgIGlmIG5vdCAoSE0ubWVtIHYyIGcpIHRoZW4gaW52YWxpZF9hcmcgXCJbb2NhbWxncmFwaF0gcmVtb3ZlX2VkZ2VfZVwiOyopXG4gICAgbGV0IGluX3NldCwgb3V0X3NldCA9IEhNLmZpbmRfYW5kX3JhaXNlIHYxIGcgXCJbb2NhbWxncmFwaF0gcmVtb3ZlX2VkZ2VfZVwiIGluXG4gICAgbGV0IGcgPSBITS5hZGQgdjEgKGluX3NldCwgUy5yZW1vdmUgKHYyLCBsKSBvdXRfc2V0KSBnIGluXG4gICAgbGV0IGluX3NldCwgb3V0X3NldCA9IEhNLmZpbmRfYW5kX3JhaXNlIHYyIGcgXCJbb2NhbWxncmFwaF0gcmVtb3ZlX2VkZ2VfZVwiIGluXG4gICAgSE0uYWRkIHYyIChTLnJlbW92ZSAodjEsIGwpIGluX3NldCwgb3V0X3NldCkgZ1xuXG4gIGxldCBpdGVyX3N1Y2MgZiBnIHYgPVxuICAgIFMuaXRlclxuICAgICAgKGZ1biAodywgXykgLT4gZiB3KVxuICAgICAgKHNuZCAoSE0uZmluZF9hbmRfcmFpc2UgdiBnIFwiW29jYW1sZ3JhcGhdIGl0ZXJfc3VjY1wiKSlcblxuICBsZXQgZm9sZF9zdWNjIGYgZyB2ID1cbiAgICBTLmZvbGRcbiAgICAgIChmdW4gKHcsIF8pIC0+IGYgdylcbiAgICAgIChzbmQgKEhNLmZpbmRfYW5kX3JhaXNlIHYgZyBcIltvY2FtbGdyYXBoXSBmb2xkX3N1Y2NcIikpXG5cbiAgbGV0IGl0ZXJfc3VjY19lIGYgZyB2ID1cbiAgICBTLml0ZXJcbiAgICAgIChmdW4gKHcsIGwpIC0+IGYgKHYsIGwsIHcpKVxuICAgICAgKHNuZCAoSE0uZmluZF9hbmRfcmFpc2UgdiBnIFwiW29jYW1sZ3JhcGhdIGl0ZXJfc3VjY19lXCIpKVxuXG4gIGxldCBmb2xkX3N1Y2NfZSBmIGcgdiA9XG4gICAgUy5mb2xkXG4gICAgICAoZnVuICh3LCBsKSAtPiBmICh2LCBsLCB3KSlcbiAgICAgIChzbmQgKEhNLmZpbmRfYW5kX3JhaXNlIHYgZyBcIltvY2FtbGdyYXBoXSBmb2xkX3N1Y2NfZVwiKSlcblxuICBsZXQgc3VjYyBnIHYgPSBmb2xkX3N1Y2MgKGZ1biB3IGwgLT4gdyA6OiBsKSBnIHYgW11cbiAgbGV0IHN1Y2NfZSBnIHYgPSBmb2xkX3N1Y2NfZSAoZnVuIGUgbCAtPiBlIDo6IGwpIGcgdiBbXVxuXG4gIGxldCBtYXBfdmVydGV4IGYgPVxuICAgIEhNLm1hcFxuICAgICAgKGZ1biB2IChzMSxzMikgLT5cbiAgICAgICAgIGYgdixcbiAgICAgICAgIChTLmZvbGQgKGZ1biAodiwgbCkgcyAtPiBTLmFkZCAoZiB2LCBsKSBzKSBzMSBTLmVtcHR5LFxuICAgICAgICAgIFMuZm9sZCAoZnVuICh2LCBsKSBzIC0+IFMuYWRkIChmIHYsIGwpIHMpIHMyIFMuZW1wdHkpKVxuXG4gIG1vZHVsZSBJID0gc3RydWN0XG4gICAgdHlwZSB0ID0gKFMudCAqIFMudCkgSE0udFxuICAgIG1vZHVsZSBQViA9IFZcbiAgICBtb2R1bGUgUEUgPSBFXG4gICAgbGV0IGl0ZXJfZWRnZXMgZiA9IEhNLml0ZXIgKGZ1biB2IChfLG91dHNldCkgLT5cbiAgICAgICAgUy5pdGVyIChmdW4gKHcsIF8pIC0+IGYgdiB3KSBvdXRzZXQpXG4gICAgbGV0IGZvbGRfZWRnZXMgZiA9IEhNLmZvbGQgKGZ1biB2IChfLG91dHNldCkgLT5cbiAgICAgICAgUy5mb2xkIChmdW4gKHcsIF8pIC0+IGYgdiB3KSBvdXRzZXQpXG4gICAgbGV0IGl0ZXJfZWRnZXNfZSBmID0gSE0uaXRlciAoZnVuIHYgKF8sb3V0c2V0KSAtPlxuICAgICAgICBTLml0ZXIgKGZ1biAodywgbCkgLT4gZiAodiwgbCwgdykpIG91dHNldClcbiAgICBsZXQgZm9sZF9lZGdlc19lIGYgPSBITS5mb2xkIChmdW4gdiAoXyxvdXRzZXQpIC0+XG4gICAgICAgIFMuZm9sZCAoZnVuICh3LCBsKSAtPiBmICh2LCBsLCB3KSkgb3V0c2V0KVxuICBlbmRcbiAgaW5jbHVkZSBJXG5cbiAgbGV0IGl0ZXJfcHJlZCBmIGcgdiA9XG4gICAgUy5pdGVyXG4gICAgICAoZnVuICh3LCBfKSAtPiBmIHcpXG4gICAgICAoZnN0IChITS5maW5kX2FuZF9yYWlzZSB2IGcgXCJbb2NhbWxncmFwaF0gaXRlcl9wcmVkXCIpKVxuXG4gIGxldCBmb2xkX3ByZWQgZiBnIHYgPVxuICAgIFMuZm9sZFxuICAgICAgKGZ1biAodywgXykgLT4gZiB3KVxuICAgICAgKGZzdCAoSE0uZmluZF9hbmRfcmFpc2UgdiBnIFwiW29jYW1sZ3JhcGhdIGZvbGRfcHJlZFwiKSlcblxuICBsZXQgaW5fZGVncmVlIGcgdiA9XG4gICAgUy5jYXJkaW5hbFxuICAgICAgKGZzdCAodHJ5IEhNLmZpbmQgdiBnXG4gICAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPiBpbnZhbGlkX2FyZyBcIltvY2FtbGdyYXBoXSBpbl9kZWdyZWVcIikpXG5cbiAgbGV0IGl0ZXJfcHJlZF9lIGYgZyB2ID1cbiAgICBTLml0ZXJcbiAgICAgIChmdW4gKHcsIGwpIC0+IGYgKHcsIGwsIHYpKVxuICAgICAgKGZzdCAoSE0uZmluZF9hbmRfcmFpc2UgdiBnIFwiW29jYW1sZ3JhcGhdIGl0ZXJfcHJlZF9lXCIpKVxuXG4gIGxldCBmb2xkX3ByZWRfZSBmIGcgdiA9XG4gICAgUy5mb2xkXG4gICAgICAoZnVuICh3LCBsKSAtPiBmICh3LCBsLCB2KSlcbiAgICAgIChmc3QgKEhNLmZpbmRfYW5kX3JhaXNlIHYgZyBcIltvY2FtbGdyYXBoXSBmb2xkX3ByZWRfZVwiKSlcblxuICBsZXQgcHJlZCBnIHYgPSBmb2xkX3ByZWQgKGZ1biB3IGwgLT4gdyA6OiBsKSBnIHYgW11cbiAgbGV0IHByZWRfZSBnIHYgPSBmb2xkX3ByZWRfZSAoZnVuIGUgbCAtPiBlIDo6IGwpIGcgdiBbXVxuXG5lbmRcblxuKCoqIEJ1aWxkIHBlcnNpc3RlbnQgKHJlc3AuIGltcGVyYXRpdmUpIGdyYXBocyBmcm9tIGEgcGVyc2lzdGVudCAocmVzcC5cbiAgICBpbXBlcmF0aXZlKSBhc3NvY2lhdGlvbiB0YWJsZSAqKVxubW9kdWxlIE1ha2UoRiA6IFRCTF9CVUlMREVSKSA9IHN0cnVjdFxuXG4gIG1vZHVsZSBEaWdyYXBoID0gc3RydWN0XG5cbiAgICBtb2R1bGUgQ29uY3JldGUoVjogQ09NUEFSQUJMRSkgPSBzdHJ1Y3RcblxuICAgICAgaW5jbHVkZSBDb25jcmV0ZVZlcnRleChGKShWKVxuICAgICAgaW5jbHVkZSBVbmxhYmVsZWQoVikoSE0pXG4gICAgICBpbmNsdWRlIE1pbmltYWwoUykoSE0pXG5cbiAgICAgIGxldCBhZGRfZWRnZSBnIHYxIHYyID1cbiAgICAgICAgaWYgbWVtX2VkZ2UgZyB2MSB2MiB0aGVuIGdcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxldCBnID0gYWRkX3ZlcnRleCBnIHYxIGluXG4gICAgICAgICAgbGV0IGcgPSBhZGRfdmVydGV4IGcgdjIgaW5cbiAgICAgICAgICB1bnNhZmVfYWRkX2VkZ2UgZyB2MSB2MlxuXG4gICAgICBsZXQgYWRkX2VkZ2VfZSBnICh2MSwgdjIpID0gYWRkX2VkZ2UgZyB2MSB2MlxuXG4gICAgZW5kXG5cbiAgICBtb2R1bGUgQ29uY3JldGVCaWRpcmVjdGlvbmFsKFY6IENPTVBBUkFCTEUpID0gc3RydWN0XG5cbiAgICAgIGluY2x1ZGUgQ29uY3JldGVWZXJ0ZXgoRikoVilcbiAgICAgIGluY2x1ZGUgQmlkaXJlY3Rpb25hbFVubGFiZWxlZChWKShITSlcbiAgICAgIGluY2x1ZGUgQmlkaXJlY3Rpb25hbE1pbmltYWwoUykoSE0pXG5cbiAgICAgIGxldCB1bnNhZmVfYWRkX2VkZ2UgZyB2MSB2MiA9XG4gICAgICAgIGxldCBmaW5kIHYgZyA9IHRyeSBITS5maW5kIHYgZyB3aXRoIE5vdF9mb3VuZCAtPiBTLmVtcHR5LCBTLmVtcHR5IGluXG4gICAgICAgIGxldCBpbl9zZXQsIG91dF9zZXQgPSBmaW5kIHYxIGcgaW5cbiAgICAgICAgbGV0IGcgPSBITS5hZGQgdjEgKGluX3NldCxTLmFkZCB2MiBvdXRfc2V0KSBnIGluXG4gICAgICAgIGxldCBpbl9zZXQsIG91dF9zZXQgPSBmaW5kIHYyIGcgaW5cbiAgICAgICAgSE0uYWRkIHYyIChTLmFkZCB2MSBpbl9zZXQsb3V0X3NldCkgZ1xuXG4gICAgICBsZXQgYWRkX2VkZ2UgZyB2MSB2MiA9XG4gICAgICAgIGlmIG1lbV9lZGdlIGcgdjEgdjIgdGhlbiBnXG4gICAgICAgIGVsc2UgdW5zYWZlX2FkZF9lZGdlIGcgdjEgdjJcblxuICAgICAgbGV0IGFkZF9lZGdlX2UgZyAodjEsIHYyKSA9IGFkZF9lZGdlIGcgdjEgdjJcblxuICAgIGVuZFxuXG4gICAgbW9kdWxlIENvbmNyZXRlTGFiZWxlZChWOiBDT01QQVJBQkxFKShFZGdlOiBPUkRFUkVEX1RZUEVfREZUKSA9IHN0cnVjdFxuXG4gICAgICBpbmNsdWRlIENvbmNyZXRlVmVydGV4KEYpKFYpXG4gICAgICBpbmNsdWRlIExhYmVsZWQoVikoRWRnZSkoSE0pXG4gICAgICBpbmNsdWRlIE1pbmltYWwoUykoSE0pXG5cbiAgICAgIGxldCBhZGRfZWRnZV9lIGcgKHYxLCBsLCB2MiBhcyBlKSA9XG4gICAgICAgIGlmIG1lbV9lZGdlX2UgZyBlIHRoZW4gZ1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbGV0IGcgPSBhZGRfdmVydGV4IGcgdjEgaW5cbiAgICAgICAgICBsZXQgZyA9IGFkZF92ZXJ0ZXggZyB2MiBpblxuICAgICAgICAgIHVuc2FmZV9hZGRfZWRnZSBnIHYxICh2MiwgbClcblxuICAgICAgbGV0IGFkZF9lZGdlIGcgdjEgdjIgPSBhZGRfZWRnZV9lIGcgKHYxLCBFZGdlLmRlZmF1bHQsIHYyKVxuXG4gICAgZW5kXG5cbiAgICBtb2R1bGUgQ29uY3JldGVCaWRpcmVjdGlvbmFsTGFiZWxlZFxuICAgICAgICAoVjogQ09NUEFSQUJMRSkoRWRnZTogT1JERVJFRF9UWVBFX0RGVCkgPVxuICAgIHN0cnVjdFxuXG4gICAgICBpbmNsdWRlIENvbmNyZXRlVmVydGV4KEYpKFYpXG4gICAgICBpbmNsdWRlIEJpZGlyZWN0aW9uYWxMYWJlbGVkKFYpKEVkZ2UpKEhNKVxuICAgICAgaW5jbHVkZSBCaWRpcmVjdGlvbmFsTWluaW1hbChTKShITSlcblxuICAgICAgbGV0IHVuc2FmZV9hZGRfZWRnZV9lIGcgKHYxLCBsLCB2MikgPVxuICAgICAgICBsZXQgZmluZCB2IGcgPSB0cnkgSE0uZmluZCB2IGcgd2l0aCBOb3RfZm91bmQgLT4gUy5lbXB0eSwgUy5lbXB0eSBpblxuICAgICAgICBsZXQgaW5fc2V0LCBvdXRfc2V0ID0gZmluZCB2MSBnIGluXG4gICAgICAgIGxldCBnID0gSE0uYWRkIHYxIChpbl9zZXQsUy5hZGQgKHYyLGwpIG91dF9zZXQpIGcgaW5cbiAgICAgICAgbGV0IGluX3NldCwgb3V0X3NldCA9IGZpbmQgdjIgZyBpblxuICAgICAgICBITS5hZGQgdjIgKFMuYWRkICh2MSxsKSBpbl9zZXQsb3V0X3NldCkgZ1xuXG4gICAgICBsZXQgYWRkX2VkZ2VfZSBnIGUgPSBpZiBtZW1fZWRnZV9lIGcgZSB0aGVuIGcgZWxzZSB1bnNhZmVfYWRkX2VkZ2VfZSBnIGVcblxuICAgICAgbGV0IGFkZF9lZGdlIGcgdjEgdjIgPSBhZGRfZWRnZV9lIGcgKHYxLCBFZGdlLmRlZmF1bHQsIHYyKVxuXG4gICAgZW5kXG5cbiAgICBtb2R1bGUgQWJzdHJhY3QoVjogVkVSVEVYKSA9IHN0cnVjdFxuICAgICAgbW9kdWxlIEcgPSBzdHJ1Y3RcbiAgICAgICAgbW9kdWxlIFYgPSBWXG4gICAgICAgIG1vZHVsZSBITSA9IEYoVilcbiAgICAgICAgaW5jbHVkZSBVbmxhYmVsZWQoVikoSE0pXG4gICAgICAgIGluY2x1ZGUgTWluaW1hbChTKShITSlcbiAgICAgIGVuZFxuICAgICAgaW5jbHVkZSBNYWtlX0Fic3RyYWN0KEcpXG4gICAgZW5kXG5cbiAgICBtb2R1bGUgQWJzdHJhY3RMYWJlbGVkKFY6IFZFUlRFWCkoRTogT1JERVJFRF9UWVBFX0RGVCkgPSBzdHJ1Y3RcbiAgICAgIG1vZHVsZSBHID0gc3RydWN0XG4gICAgICAgIG1vZHVsZSBWID0gVlxuICAgICAgICBtb2R1bGUgSE0gPSBGKFYpXG4gICAgICAgIGluY2x1ZGUgTGFiZWxlZChWKShFKShITSlcbiAgICAgICAgaW5jbHVkZSBNaW5pbWFsKFMpKEhNKVxuICAgICAgZW5kXG4gICAgICBpbmNsdWRlIE1ha2VfQWJzdHJhY3QoRylcbiAgICBlbmRcblxuICBlbmRcblxuZW5kXG5cbigqKiBJbXBsZW1lbnRhdGlvbiBvZiB1bmRpcmVjdGVkIGdyYXBocyBmcm9tIGltcGxlbWVudGF0aW9uIG9mIGRpcmVjdGVkXG4gICAgZ3JhcGhzLiAqKVxubW9kdWxlIEdyYXBoXG4gICAgKEc6IHNpZ1xuICAgICAgIGluY2x1ZGUgU2lnLkdcbiAgICAgICB2YWwgY3JlYXRlOiA/c2l6ZTppbnQgLT4gdW5pdCAtPiB0XG4gICAgICAgdmFsIGNsZWFyOiB0IC0+IHVuaXRcbiAgICAgICB2YWwgY29weTogdCAtPiB0XG4gICAgICAgdHlwZSByZXR1cm5cbiAgICAgICB2YWwgYWRkX3ZlcnRleDogdCAtPiB2ZXJ0ZXggLT4gcmV0dXJuXG4gICAgICAgdmFsIHJlbW92ZV92ZXJ0ZXg6IHQgLT4gdmVydGV4IC0+IHJldHVyblxuICAgICBlbmQpID1cbnN0cnVjdFxuXG4gIGluY2x1ZGUgR1xuXG4gIGxldCBpc19kaXJlY3RlZCA9IGZhbHNlXG5cbiAgKCogUmVkZWZpbmUgaXRlcmF0b3JzIGFuZCBbbmJfZWRnZXNdLiAqKVxuXG4gIGxldCBpdGVyX2VkZ2VzIGYgPVxuICAgIGl0ZXJfZWRnZXMgKGZ1biB2MSB2MiAtPiBpZiBWLmNvbXBhcmUgdjEgdjIgPj0gMCB0aGVuIGYgdjEgdjIpXG5cbiAgbGV0IGZvbGRfZWRnZXMgZiA9XG4gICAgZm9sZF9lZGdlc1xuICAgICAgKGZ1biB2MSB2MiBhY2MgLT4gaWYgVi5jb21wYXJlIHYxIHYyID49IDAgdGhlbiBmIHYxIHYyIGFjYyBlbHNlIGFjYylcblxuICBsZXQgaXRlcl9lZGdlc19lIGYgPVxuICAgIGl0ZXJfZWRnZXNfZSAoZnVuIGUgLT4gaWYgVi5jb21wYXJlIChFLnNyYyBlKSAoRS5kc3QgZSkgPj0gMCB0aGVuIGYgZSlcblxuICBsZXQgZm9sZF9lZGdlc19lIGYgPVxuICAgIGZvbGRfZWRnZXNfZVxuICAgICAgKGZ1biBlIGFjYyAtPlxuICAgICAgICAgaWYgVi5jb21wYXJlIChFLnNyYyBlKSAoRS5kc3QgZSkgPj0gMCB0aGVuIGYgZSBhY2MgZWxzZSBhY2MpXG5cbiAgbGV0IG5iX2VkZ2VzIGcgPSBmb2xkX2VkZ2VzX2UgKGZ1biBfIC0+ICgrKSAxKSBnIDBcblxuICAoKiBSZWRlZmluZSBvcGVyYXRpb25zIG9uIHByZWRlY2Vzc29yczpcbiAgICAgcHJlZGVjZXNzb3JzIGFyZSBzdWNjZXNzb3JzIGluIGFuIHVuZGlyZWN0ZWQgZ3JhcGguICopXG5cbiAgbGV0IHByZWQgPSBzdWNjXG4gIGxldCBpbl9kZWdyZWUgPSBvdXRfZGVncmVlXG4gIGxldCBpdGVyX3ByZWQgPSBpdGVyX3N1Y2NcbiAgbGV0IGZvbGRfcHJlZCA9IGZvbGRfc3VjY1xuICBsZXQgcHJlZF9lID0gc3VjY19lXG4gIGxldCBpdGVyX3ByZWRfZSA9IGl0ZXJfc3VjY19lXG4gIGxldCBmb2xkX3ByZWRfZSA9IGZvbGRfc3VjY19lXG5cbmVuZFxuXG4oKlxuTG9jYWwgVmFyaWFibGVzOlxuY29tcGlsZS1jb21tYW5kOiBcIm1ha2UgLUMgLi5cIlxuRW5kOlxuKilcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICBPY2FtbGdyYXBoOiBhIGdlbmVyaWMgZ3JhcGggbGlicmFyeSBmb3IgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICBDb3B5cmlnaHQgKEMpIDIwMDQtMjAxMCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICBTeWx2YWluIENvbmNob24sIEplYW4tQ2hyaXN0b3BoZSBGaWxsaWF0cmUgYW5kIEp1bGllbiBTaWdub2xlcyAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICBUaGlzIHNvZnR3YXJlIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciAgICAgICAgKilcbigqICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGlicmFyeSBHZW5lcmFsIFB1YmxpYyAgICAgICAgICAgKilcbigqICBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nICAgICAgICAgICAgKilcbigqICBkZXNjcmliZWQgaW4gZmlsZSBMSUNFTlNFLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICBUaGlzIHNvZnR3YXJlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsICAgICAgKilcbigqICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiAgICAgICAgKilcbigqICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBTaWdcbm9wZW4gQmxvY2tzXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcblxuICAoKiogUGVyc2lzdGVudCBVbmxhYmVsZWQgR3JhcGhzICopXG4gIG1vZHVsZSBDb25jcmV0ZSAoVjogQ09NUEFSQUJMRSkgOlxuICAgIFNpZy5QIHdpdGggdHlwZSBWLnQgPSBWLnQgYW5kIHR5cGUgVi5sYWJlbCA9IFYudCBhbmQgdHlwZSBFLnQgPSBWLnQgKiBWLnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHR5cGUgRS5sYWJlbCA9IHVuaXRcblxuICAoKiogQWJzdHJhY3QgUGVyc2lzdGVudCBVbmxhYmVsZWQgR3JhcGhzICopXG4gIG1vZHVsZSBBYnN0cmFjdChWOiBzaWcgdHlwZSB0IGVuZCkgOiBTaWcuUCB3aXRoIHR5cGUgVi5sYWJlbCA9IFYudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCB0eXBlIEUubGFiZWwgPSB1bml0XG5cbiAgKCoqIFBlcnNpc3RlbnQgTGFiZWxlZCBHcmFwaHMgKilcbiAgbW9kdWxlIENvbmNyZXRlTGFiZWxlZCAoVjogQ09NUEFSQUJMRSkoRTogT1JERVJFRF9UWVBFX0RGVCkgOlxuICAgIFNpZy5QIHdpdGggdHlwZSBWLnQgPSBWLnQgYW5kIHR5cGUgVi5sYWJlbCA9IFYudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHR5cGUgRS50ID0gVi50ICogRS50ICogVi50IGFuZCB0eXBlIEUubGFiZWwgPSBFLnRcblxuICAoKiogQWJzdHJhY3QgUGVyc2lzdGVudCBMYWJlbGVkIEdyYXBocyAqKVxuICBtb2R1bGUgQWJzdHJhY3RMYWJlbGVkIChWOiBzaWcgdHlwZSB0IGVuZCkoRTogT1JERVJFRF9UWVBFX0RGVCkgOlxuICAgIFNpZy5QIHdpdGggdHlwZSBWLmxhYmVsID0gVi50IGFuZCB0eXBlIEUubGFiZWwgPSBFLnRcblxuZW5kXG5cbm1vZHVsZSBQID0gTWFrZShNYWtlX01hcClcblxudHlwZSAnYSBhYnN0cmFjdF92ZXJ0ZXggPSB7IHRhZyA6IGludDsgbGFiZWwgOiAnYSB9XG5cbigqIFZlcnRleCBmb3IgdGhlIGFic3RyYWN0IHBlcnNpc3RlbnQgZ3JhcGhzLiAqKVxubW9kdWxlIEFic3RyYWN0VmVydGV4KFY6IHNpZyB0eXBlIHQgZW5kKSA9IHN0cnVjdFxuICB0eXBlIGxhYmVsID0gVi50XG4gIHR5cGUgdCA9IGxhYmVsIGFic3RyYWN0X3ZlcnRleFxuICBsZXQgY29tcGFyZSB4IHkgPSBTdGRsaWIuY29tcGFyZSB4LnRhZyB5LnRhZ1xuICBsZXQgaGFzaCB4ID0geC50YWdcbiAgbGV0IGVxdWFsIHggeSA9IHgudGFnID0geS50YWdcbiAgbGV0IGxhYmVsIHggPSB4LmxhYmVsXG4gIGxldCBjcmVhdGUgbCA9XG4gICAgaWYgIWNwdF92ZXJ0ZXggPSBmaXJzdF92YWx1ZV9mb3JfY3B0X3ZlcnRleCAtIDEgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJUb28gbXVjaCB2ZXJ0aWNlc1wiO1xuICAgIGluY3IgY3B0X3ZlcnRleDtcbiAgICB7IHRhZyA9ICFjcHRfdmVydGV4OyBsYWJlbCA9IGwgfVxuZW5kXG5cbm1vZHVsZSBEaWdyYXBoID0gc3RydWN0XG5cbiAgbW9kdWxlIENvbmNyZXRlKFY6Q09NUEFSQUJMRSkgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFAuRGlncmFwaC5Db25jcmV0ZShWKVxuICAgIGxldCByZW1vdmVfdmVydGV4IGcgdiA9XG4gICAgICBpZiBITS5tZW0gdiBnIHRoZW5cbiAgICAgICAgbGV0IGcgPSBITS5yZW1vdmUgdiBnIGluXG4gICAgICAgIEhNLmZvbGQgKGZ1biBrIHMgLT4gSE0uYWRkIGsgKFMucmVtb3ZlIHYgcykpIGcgZW1wdHlcbiAgICAgIGVsc2VcbiAgICAgICAgZ1xuICBlbmRcblxuICBtb2R1bGUgQ29uY3JldGVMYWJlbGVkKFY6Q09NUEFSQUJMRSkoRTpPUkRFUkVEX1RZUEVfREZUKSA9IHN0cnVjdFxuICAgIGluY2x1ZGUgUC5EaWdyYXBoLkNvbmNyZXRlTGFiZWxlZChWKShFKVxuICAgIGxldCByZW1vdmVfdmVydGV4IGcgdiA9XG4gICAgICBpZiBITS5tZW0gdiBnIHRoZW5cbiAgICAgICAgbGV0IGcgPSBITS5yZW1vdmUgdiBnIGluXG4gICAgICAgIGxldCByZW1vdmUgdiA9IFMuZmlsdGVyIChmdW4gKHYyLCBfKSAtPiBub3QgKFYuZXF1YWwgdiB2MikpIGluXG4gICAgICAgIEhNLmZvbGQgKGZ1biBrIHMgLT4gSE0uYWRkIGsgKHJlbW92ZSB2IHMpKSBnIGVtcHR5XG4gICAgICBlbHNlXG4gICAgICAgIGdcbiAgZW5kXG5cbiAgbW9kdWxlIENvbmNyZXRlQmlkaXJlY3Rpb25hbChWOiBDT01QQVJBQkxFKSA9IHN0cnVjdFxuICAgIGluY2x1ZGUgUC5EaWdyYXBoLkNvbmNyZXRlQmlkaXJlY3Rpb25hbChWKVxuICAgIGxldCByZW1vdmVfdmVydGV4IGcgdiA9XG4gICAgICBpZiBITS5tZW0gdiBnIHRoZW5cbiAgICAgICAgbGV0IHJlbW92ZSB2ID0gUy5maWx0ZXIgKGZ1biB2JyAtPiBub3QgKFYuZXF1YWwgdiB2JykpIGluXG4gICAgICAgIGxldCBnID1cbiAgICAgICAgICBmb2xkX3ByZWRcbiAgICAgICAgICAgIChmdW4gdicgYWNjIC0+XG4gICAgICAgICAgICAgICBsZXQgaW5fc2V0LCBvdXRfc2V0ID0gSE0uZmluZCB2JyBhY2MgaW5cbiAgICAgICAgICAgICAgIEhNLmFkZCB2JyAoaW5fc2V0LCByZW1vdmUgdiBvdXRfc2V0KSBhY2MpXG4gICAgICAgICAgICBnIHYgZ1xuICAgICAgICBpblxuICAgICAgICBsZXQgZyA9XG4gICAgICAgICAgZm9sZF9zdWNjXG4gICAgICAgICAgICAoZnVuIHYnIGFjYyAtPlxuICAgICAgICAgICAgICAgbGV0IGluX3NldCwgb3V0X3NldCA9IEhNLmZpbmQgdicgYWNjIGluXG4gICAgICAgICAgICAgICBITS5hZGQgdicgKHJlbW92ZSB2IGluX3NldCwgb3V0X3NldCkgYWNjKVxuICAgICAgICAgICAgZyB2IGdcbiAgICAgICAgaW5cbiAgICAgICAgSE0ucmVtb3ZlIHYgZ1xuICAgICAgZWxzZVxuICAgICAgICBnXG4gIGVuZFxuXG4gIG1vZHVsZSBDb25jcmV0ZUJpZGlyZWN0aW9uYWxMYWJlbGVkKFY6Q09NUEFSQUJMRSkoRTpPUkRFUkVEX1RZUEVfREZUKSA9IHN0cnVjdFxuICAgIGluY2x1ZGUgUC5EaWdyYXBoLkNvbmNyZXRlQmlkaXJlY3Rpb25hbExhYmVsZWQoVikoRSlcbiAgICBsZXQgcmVtb3ZlX3ZlcnRleCAoZzp0KSAodjp2ZXJ0ZXgpID1cbiAgICAgIGlmIEhNLm1lbSB2IGcgdGhlblxuICAgICAgICBsZXQgcmVtb3ZlIHYgPSBTLmZpbHRlciAoZnVuICh2JywgXykgLT4gbm90IChWLmVxdWFsIHYgdicpKSBpblxuICAgICAgICBsZXQgZyA9XG4gICAgICAgICAgZm9sZF9wcmVkXG4gICAgICAgICAgICAoZnVuIHYnIGFjYyAtPlxuICAgICAgICAgICAgICAgbGV0IGluX3NldCwgb3V0X3NldCA9IEhNLmZpbmQgdicgYWNjIGluXG4gICAgICAgICAgICAgICBITS5hZGQgdicgKGluX3NldCwgcmVtb3ZlIHYgb3V0X3NldCkgYWNjKVxuICAgICAgICAgICAgZyB2IGdcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGcgPVxuICAgICAgICAgIGZvbGRfc3VjY1xuICAgICAgICAgICAgKGZ1biB2JyBhY2MgLT5cbiAgICAgICAgICAgICAgIGxldCBpbl9zZXQsIG91dF9zZXQgPSBITS5maW5kIHYnIGFjYyBpblxuICAgICAgICAgICAgICAgSE0uYWRkIHYnIChyZW1vdmUgdiBpbl9zZXQsIG91dF9zZXQpIGFjYylcbiAgICAgICAgICAgIGcgdiBnXG4gICAgICAgIGluXG4gICAgICAgIEhNLnJlbW92ZSB2IGdcbiAgICAgIGVsc2VcbiAgICAgICAgZ1xuICBlbmRcblxuICBtb2R1bGUgQWJzdHJhY3QoVjogc2lnIHR5cGUgdCBlbmQpID0gc3RydWN0XG5cbiAgICBpbmNsdWRlIFAuRGlncmFwaC5BYnN0cmFjdChBYnN0cmFjdFZlcnRleChWKSlcblxuICAgIGxldCBlbXB0eSA9IHsgZWRnZXMgPSBHLmVtcHR5OyBzaXplID0gMCB9XG5cbiAgICBsZXQgYWRkX3ZlcnRleCBnIHYgPVxuICAgICAgaWYgbWVtX3ZlcnRleCBnIHYgdGhlblxuICAgICAgICBnXG4gICAgICBlbHNlXG4gICAgICAgIHsgZWRnZXMgPSBHLnVuc2FmZV9hZGRfdmVydGV4IGcuZWRnZXMgdjtcbiAgICAgICAgICBzaXplID0gU3RkbGliLnN1Y2MgZy5zaXplIH1cblxuICAgIGxldCBhZGRfZWRnZSBnIHYxIHYyID1cbiAgICAgIGxldCBnID0gYWRkX3ZlcnRleCBnIHYxIGluXG4gICAgICBsZXQgZyA9IGFkZF92ZXJ0ZXggZyB2MiBpblxuICAgICAgeyBnIHdpdGggZWRnZXMgPSBHLnVuc2FmZV9hZGRfZWRnZSBnLmVkZ2VzIHYxIHYyIH1cblxuICAgIGxldCBhZGRfZWRnZV9lIGcgKHYxLCB2MikgPSBhZGRfZWRnZSBnIHYxIHYyXG5cbiAgICBsZXQgcmVtb3ZlX3ZlcnRleCBnIHYgPVxuICAgICAgaWYgSE0ubWVtIHYgZy5lZGdlcyB0aGVuXG4gICAgICAgIGxldCBlID0gSE0ucmVtb3ZlIHYgZy5lZGdlcyBpblxuICAgICAgICBsZXQgZSA9IEhNLmZvbGQgKGZ1biBrIHMgZyAtPiBITS5hZGQgayAoUy5yZW1vdmUgdiBzKSBnKSBlIEhNLmVtcHR5IGluXG4gICAgICAgIHsgZWRnZXMgPSBlOyBzaXplID0gU3RkbGliLnByZWQgZy5zaXplIH1cbiAgICAgIGVsc2VcbiAgICAgICAgZ1xuXG4gICAgbGV0IHJlbW92ZV9lZGdlIGcgdjEgdjIgPSB7IGcgd2l0aCBlZGdlcyA9IHJlbW92ZV9lZGdlIGcgdjEgdjIgfVxuICAgIGxldCByZW1vdmVfZWRnZV9lIGcgZSA9IHsgZyB3aXRoIGVkZ2VzID0gcmVtb3ZlX2VkZ2VfZSBnIGUgfVxuXG4gIGVuZFxuXG4gIG1vZHVsZSBBYnN0cmFjdExhYmVsZWQoVjogc2lnIHR5cGUgdCBlbmQpKEVkZ2U6IE9SREVSRURfVFlQRV9ERlQpID0gc3RydWN0XG5cbiAgICBpbmNsdWRlIFAuRGlncmFwaC5BYnN0cmFjdExhYmVsZWQoQWJzdHJhY3RWZXJ0ZXgoVikpKEVkZ2UpXG5cbiAgICBsZXQgZW1wdHkgPSB7IGVkZ2VzID0gRy5lbXB0eTsgc2l6ZSA9IDAgfVxuXG4gICAgbGV0IGFkZF92ZXJ0ZXggZyB2ID1cbiAgICAgIGlmIG1lbV92ZXJ0ZXggZyB2IHRoZW5cbiAgICAgICAgZ1xuICAgICAgZWxzZVxuICAgICAgICB7IGVkZ2VzID0gRy51bnNhZmVfYWRkX3ZlcnRleCBnLmVkZ2VzIHY7XG4gICAgICAgICAgc2l6ZSA9IFN0ZGxpYi5zdWNjIGcuc2l6ZSB9XG5cbiAgICBsZXQgYWRkX2VkZ2VfZSBnICh2MSwgbCwgdjIpID1cbiAgICAgIGxldCBnID0gYWRkX3ZlcnRleCBnIHYxIGluXG4gICAgICBsZXQgZyA9IGFkZF92ZXJ0ZXggZyB2MiBpblxuICAgICAgeyBnIHdpdGggZWRnZXMgPSBHLnVuc2FmZV9hZGRfZWRnZSBnLmVkZ2VzIHYxICh2MiwgbCkgfVxuXG4gICAgbGV0IGFkZF9lZGdlIGcgdjEgdjIgPSBhZGRfZWRnZV9lIGcgKHYxLCBFZGdlLmRlZmF1bHQsIHYyKVxuXG4gICAgbGV0IHJlbW92ZV92ZXJ0ZXggZyB2ID1cbiAgICAgIGlmIEhNLm1lbSB2IGcuZWRnZXMgdGhlblxuICAgICAgICBsZXQgcmVtb3ZlIHYgcyA9XG4gICAgICAgICAgUy5mb2xkXG4gICAgICAgICAgICAoZnVuICh2MiwgXyBhcyBlKSBzIC0+IGlmIG5vdCAoVi5lcXVhbCB2IHYyKSB0aGVuIFMuYWRkIGUgcyBlbHNlIHMpXG4gICAgICAgICAgICBzIFMuZW1wdHlcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGVkZ2VzID0gSE0ucmVtb3ZlIHYgZy5lZGdlcyBpblxuICAgICAgICB7IGVkZ2VzID1cbiAgICAgICAgICAgIEhNLmZvbGQgKGZ1biBrIHMgZyAtPiBITS5hZGQgayAocmVtb3ZlIHYgcykgZykgZWRnZXMgSE0uZW1wdHk7XG4gICAgICAgICAgc2l6ZSA9IFN0ZGxpYi5wcmVkIGcuc2l6ZSB9XG4gICAgICBlbHNlXG4gICAgICAgIGdcblxuICAgIGxldCByZW1vdmVfZWRnZSBnIHYxIHYyID0geyBnIHdpdGggZWRnZXMgPSByZW1vdmVfZWRnZSBnIHYxIHYyIH1cbiAgICBsZXQgcmVtb3ZlX2VkZ2VfZSBnIGUgPSB7IGcgd2l0aCBlZGdlcyA9IHJlbW92ZV9lZGdlX2UgZyBlIH1cblxuICBlbmRcblxuZW5kXG5cbm1vZHVsZSBHcmFwaCA9IHN0cnVjdFxuXG4gIG1vZHVsZSBDb25jcmV0ZShWOiBDT01QQVJBQkxFKSA9IHN0cnVjdFxuXG4gICAgbW9kdWxlIEcgPSBzdHJ1Y3QgaW5jbHVkZSBEaWdyYXBoLkNvbmNyZXRlKFYpIHR5cGUgcmV0dXJuID0gdCBlbmRcbiAgICBpbmNsdWRlIEJsb2Nrcy5HcmFwaChHKVxuXG4gICAgKCogRXhwb3J0IHNvbWUgZGVmaW5pdGlvbnMgb2YgW0ddICopXG4gICAgbGV0IGVtcHR5ID0gRy5lbXB0eVxuXG4gICAgKCogUmVkZWZpbmUgdGhlIFthZGRfZWRnZV0gYW5kIFtyZW1vdmVfZWRnZV0gb3BlcmF0aW9ucyAqKVxuXG4gICAgbGV0IGFkZF9lZGdlIGcgdjEgdjIgPVxuICAgICAgbGV0IGcgPSBHLmFkZF9lZGdlIGcgdjEgdjIgaW5cbiAgICAgIGFzc2VydCAoRy5ITS5tZW0gdjEgZyAmJiBHLkhNLm1lbSB2MiBnKTtcbiAgICAgIEcudW5zYWZlX2FkZF9lZGdlIGcgdjIgdjFcblxuICAgIGxldCBhZGRfZWRnZV9lIGcgKHYxLCB2MikgPSBhZGRfZWRnZSBnIHYxIHYyXG5cbiAgICBsZXQgcmVtb3ZlX2VkZ2UgZyB2MSB2MiA9XG4gICAgICBsZXQgZyA9IEcucmVtb3ZlX2VkZ2UgZyB2MSB2MiBpblxuICAgICAgYXNzZXJ0IChHLkhNLm1lbSB2MSBnICYmIEcuSE0ubWVtIHYyIGcpO1xuICAgICAgRy51bnNhZmVfcmVtb3ZlX2VkZ2UgZyB2MiB2MVxuXG4gICAgbGV0IHJlbW92ZV9lZGdlX2UgZyAodjEsIHYyKSA9IHJlbW92ZV9lZGdlIGcgdjEgdjJcblxuICBlbmRcblxuICBtb2R1bGUgQ29uY3JldGVMYWJlbGVkKFY6IENPTVBBUkFCTEUpKEVkZ2U6IE9SREVSRURfVFlQRV9ERlQpID0gc3RydWN0XG5cbiAgICBtb2R1bGUgRyA9IHN0cnVjdFxuICAgICAgaW5jbHVkZSBEaWdyYXBoLkNvbmNyZXRlTGFiZWxlZChWKShFZGdlKVxuICAgICAgdHlwZSByZXR1cm4gPSB0XG4gICAgZW5kXG4gICAgaW5jbHVkZSBCbG9ja3MuR3JhcGgoRylcblxuICAgICgqIEV4cG9ydCBzb21lIGRlZmluaXRpb25zIG9mIFtHXSAqKVxuICAgIGxldCBlbXB0eSA9IEcuZW1wdHlcblxuICAgICgqIFJlZGVmaW5lIHRoZSBbYWRkX2VkZ2VdIGFuZCBbcmVtb3ZlX2VkZ2VdIG9wZXJhdGlvbnMgKilcblxuICAgIGxldCBhZGRfZWRnZV9lIGcgKHYxLCBsLCB2MiBhcyBlKSA9XG4gICAgICBsZXQgZyA9IEcuYWRkX2VkZ2VfZSBnIGUgaW5cbiAgICAgIGFzc2VydCAoRy5ITS5tZW0gdjEgZyAmJiBHLkhNLm1lbSB2MiBnKTtcbiAgICAgIEcudW5zYWZlX2FkZF9lZGdlIGcgdjIgKHYxLCBsKVxuXG4gICAgbGV0IGFkZF9lZGdlIGcgdjEgdjIgPSBhZGRfZWRnZV9lIGcgKHYxLCBFZGdlLmRlZmF1bHQsIHYyKVxuXG4gICAgbGV0IHJlbW92ZV9lZGdlIGcgdjEgdjIgPVxuICAgICAgbGV0IGcgPSBHLnJlbW92ZV9lZGdlIGcgdjEgdjIgaW5cbiAgICAgIGFzc2VydCAoRy5ITS5tZW0gdjEgZyAmJiBHLkhNLm1lbSB2MiBnKTtcbiAgICAgIEcudW5zYWZlX3JlbW92ZV9lZGdlIGcgdjIgdjFcblxuICAgIGxldCByZW1vdmVfZWRnZV9lIGcgKHYxLCBsLCB2MiBhcyBlKSA9XG4gICAgICBsZXQgZyA9IEcucmVtb3ZlX2VkZ2VfZSBnIGUgaW5cbiAgICAgIGFzc2VydCAoRy5ITS5tZW0gdjEgZyAmJiBHLkhNLm1lbSB2MiBnKTtcbiAgICAgIEcudW5zYWZlX3JlbW92ZV9lZGdlX2UgZyAodjIsIGwsIHYxKVxuXG4gIGVuZFxuXG4gIG1vZHVsZSBBYnN0cmFjdChWOiBzaWcgdHlwZSB0IGVuZCkgPSBzdHJ1Y3RcblxuICAgIG1vZHVsZSBHID0gc3RydWN0IGluY2x1ZGUgRGlncmFwaC5BYnN0cmFjdChWKSB0eXBlIHJldHVybiA9IHQgZW5kXG4gICAgaW5jbHVkZSBCbG9ja3MuR3JhcGgoRylcblxuICAgICgqIEV4cG9ydCBzb21lIGRlZmluaXRpb25zIG9mIFtHXSAqKVxuICAgIGxldCBlbXB0eSA9IEcuZW1wdHlcblxuICAgICgqIFJlZGVmaW5lIHRoZSBbYWRkX2VkZ2VdIGFuZCBbcmVtb3ZlX2VkZ2VdIG9wZXJhdGlvbnMgKilcblxuICAgIGxldCBhZGRfZWRnZSBnIHYxIHYyID1cbiAgICAgIGxldCBnID0gRy5hZGRfZWRnZSBnIHYxIHYyIGluXG4gICAgICBhc3NlcnQgKEcuSE0ubWVtIHYxIGcuRy5lZGdlcyAmJiBHLkhNLm1lbSB2MiBnLkcuZWRnZXMpO1xuICAgICAgeyBnIHdpdGggRy5lZGdlcyA9IEcudW5zYWZlX2FkZF9lZGdlIGcuRy5lZGdlcyB2MiB2MSB9XG5cbiAgICBsZXQgYWRkX2VkZ2VfZSBnICh2MSwgdjIpID0gYWRkX2VkZ2UgZyB2MSB2MlxuXG4gICAgbGV0IHJlbW92ZV9lZGdlIGcgdjEgdjIgPVxuICAgICAgbGV0IGcgPSBHLnJlbW92ZV9lZGdlIGcgdjEgdjIgaW5cbiAgICAgIGFzc2VydCAoRy5ITS5tZW0gdjEgZy5HLmVkZ2VzICYmIEcuSE0ubWVtIHYyIGcuRy5lZGdlcyk7XG4gICAgICB7IGcgd2l0aCBHLmVkZ2VzID0gRy51bnNhZmVfcmVtb3ZlX2VkZ2UgZy5HLmVkZ2VzIHYyIHYxIH1cblxuICAgIGxldCByZW1vdmVfZWRnZV9lIGcgKHYxLCB2MikgPSByZW1vdmVfZWRnZSBnIHYxIHYyXG5cbiAgZW5kXG5cbiAgbW9kdWxlIEFic3RyYWN0TGFiZWxlZCAoVjogc2lnIHR5cGUgdCBlbmQpKEVkZ2U6IE9SREVSRURfVFlQRV9ERlQpID0gc3RydWN0XG5cbiAgICBtb2R1bGUgRyA9IHN0cnVjdFxuICAgICAgaW5jbHVkZSBEaWdyYXBoLkFic3RyYWN0TGFiZWxlZChWKShFZGdlKVxuICAgICAgdHlwZSByZXR1cm4gPSB0XG4gICAgZW5kXG4gICAgaW5jbHVkZSBCbG9ja3MuR3JhcGgoRylcblxuICAgICgqIEV4cG9ydCBzb21lIGRlZmluaXRpb25zIG9mIFtHXSAqKVxuICAgIGxldCBlbXB0eSA9IEcuZW1wdHlcblxuICAgICgqIFJlZGVmaW5lIHRoZSBbYWRkX2VkZ2VdIGFuZCBbcmVtb3ZlX2VkZ2VdIG9wZXJhdGlvbnMgKilcblxuICAgIGxldCBhZGRfZWRnZV9lIGcgKHYxLCBsLCB2MiBhcyBlKSA9XG4gICAgICBsZXQgZyA9IEcuYWRkX2VkZ2VfZSBnIGUgaW5cbiAgICAgIGFzc2VydCAoRy5ITS5tZW0gdjEgZy5HLmVkZ2VzICYmIEcuSE0ubWVtIHYyIGcuRy5lZGdlcyk7XG4gICAgICB7IGcgd2l0aCBHLmVkZ2VzID0gRy51bnNhZmVfYWRkX2VkZ2UgZy5HLmVkZ2VzIHYyICh2MSwgbCkgfVxuXG4gICAgbGV0IGFkZF9lZGdlIGcgdjEgdjIgPSBhZGRfZWRnZV9lIGcgKHYxLCBFZGdlLmRlZmF1bHQsIHYyKVxuXG4gICAgbGV0IHJlbW92ZV9lZGdlIGcgdjEgdjIgPVxuICAgICAgbGV0IGcgPSBHLnJlbW92ZV9lZGdlIGcgdjEgdjIgaW5cbiAgICAgIGFzc2VydCAoRy5ITS5tZW0gdjEgZy5HLmVkZ2VzICYmIEcuSE0ubWVtIHYyIGcuRy5lZGdlcyk7XG4gICAgICB7IGcgd2l0aCBHLmVkZ2VzID0gRy51bnNhZmVfcmVtb3ZlX2VkZ2UgZy5HLmVkZ2VzIHYyIHYxIH1cblxuICAgIGxldCByZW1vdmVfZWRnZV9lIGcgKHYxLCBsLCB2MiBhcyBlKSA9XG4gICAgICBsZXQgZyA9IEcucmVtb3ZlX2VkZ2VfZSBnIGUgaW5cbiAgICAgIGFzc2VydCAoRy5ITS5tZW0gdjEgZy5HLmVkZ2VzICYmIEcuSE0ubWVtIHYyIGcuRy5lZGdlcyk7XG4gICAgICB7IGcgd2l0aCBHLmVkZ2VzID0gRy51bnNhZmVfcmVtb3ZlX2VkZ2VfZSBnLkcuZWRnZXMgKHYyLCBsLCB2MSkgfVxuXG4gIGVuZFxuXG5lbmRcblxuKCpcbkxvY2FsIFZhcmlhYmxlczpcbmNvbXBpbGUtY29tbWFuZDogXCJtYWtlIC1DIC4uXCJcbkVuZDpcbiopXG4iLCJtb2R1bGUgSnMgPSBzdHJ1Y3RcbiAgdHlwZSB0XG5cbiAgdHlwZSAnYSBqc19hcnJheSA9IHRcblxuICB0eXBlICgnYSwgJ2IpIG1ldGhfY2FsbGJhY2sgPSB0XG5cbiAgZXh0ZXJuYWwgc3RyaW5nIDogc3RyaW5nIC0+IHQgPSBcImNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXCJcblxuICBleHRlcm5hbCB0b19zdHJpbmcgOiB0IC0+IHN0cmluZyA9IFwiY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcIlxuXG4gIGV4dGVybmFsIGJ5dGVzdHJpbmcgOiBzdHJpbmcgLT4gdCA9IFwiY2FtbF9qc2J5dGVzX29mX3N0cmluZ1wiXG5cbiAgZXh0ZXJuYWwgdG9fYnl0ZXN0cmluZyA6IHQgLT4gc3RyaW5nID0gXCJjYW1sX3N0cmluZ19vZl9qc2J5dGVzXCJcblxuICBleHRlcm5hbCBib29sIDogYm9vbCAtPiB0ID0gXCJjYW1sX2pzX2Zyb21fYm9vbFwiXG5cbiAgZXh0ZXJuYWwgdG9fYm9vbCA6IHQgLT4gYm9vbCA9IFwiY2FtbF9qc190b19ib29sXCJcblxuICBleHRlcm5hbCBhcnJheSA6ICdhIGFycmF5IC0+IHQgPSBcImNhbWxfanNfZnJvbV9hcnJheVwiXG5cbiAgZXh0ZXJuYWwgdG9fYXJyYXkgOiB0IC0+ICdhIGFycmF5ID0gXCJjYW1sX2pzX3RvX2FycmF5XCJcblxuICBleHRlcm5hbCBudW1iZXJfb2ZfZmxvYXQgOiBmbG9hdCAtPiB0ID0gXCJjYW1sX2pzX2Zyb21fZmxvYXRcIlxuXG4gIGV4dGVybmFsIGZsb2F0X29mX251bWJlciA6IHQgLT4gZmxvYXQgPSBcImNhbWxfanNfdG9fZmxvYXRcIlxuXG4gIGV4dGVybmFsIHR5cGVvZiA6IHQgLT4gdCA9IFwiY2FtbF9qc190eXBlb2ZcIlxuXG4gIGV4dGVybmFsIGluc3RhbmNlb2YgOiB0IC0+IHQgLT4gYm9vbCA9IFwiY2FtbF9qc19pbnN0YW5jZW9mXCJcblxuICBleHRlcm5hbCBkZWJ1Z2dlciA6IHVuaXQgLT4gdW5pdCA9IFwiZGVidWdnZXJcIlxuXG4gIGV4dGVybmFsIGdldCA6IHQgLT4gdCAtPiB0ID0gXCJjYW1sX2pzX2dldFwiXG5cbiAgZXh0ZXJuYWwgc2V0IDogdCAtPiB0IC0+IHQgLT4gdW5pdCA9IFwiY2FtbF9qc19zZXRcIlxuXG4gIGV4dGVybmFsIGRlbGV0ZSA6IHQgLT4gdCAtPiB1bml0ID0gXCJjYW1sX2pzX2RlbGV0ZVwiXG5cbiAgZXh0ZXJuYWwgY2FsbCA6IHQgLT4gdCAtPiB0IGFycmF5IC0+IHQgPSBcImNhbWxfanNfY2FsbFwiXG5cbiAgZXh0ZXJuYWwgZnVuX2NhbGwgOiB0IC0+IHQgYXJyYXkgLT4gdCA9IFwiY2FtbF9qc19mdW5fY2FsbFwiXG5cbiAgZXh0ZXJuYWwgbWV0aF9jYWxsIDogdCAtPiBzdHJpbmcgLT4gdCBhcnJheSAtPiB0ID0gXCJjYW1sX2pzX21ldGhfY2FsbFwiXG5cbiAgZXh0ZXJuYWwgbmV3X29iaiA6IHQgLT4gdCBhcnJheSAtPiB0ID0gXCJjYW1sX2pzX25ld1wiXG5cbiAgZXh0ZXJuYWwgbmV3X29ial9hcnIgOiB0IC0+IHQganNfYXJyYXkgLT4gdCA9IFwiY2FtbF9vanNfbmV3X2FyclwiXG5cbiAgZXh0ZXJuYWwgb2JqIDogKHN0cmluZyAqIHQpIGFycmF5IC0+IHQgPSBcImNhbWxfanNfb2JqZWN0XCJcblxuICBleHRlcm5hbCBlcXVhbHMgOiB0IC0+IHQgLT4gYm9vbCA9IFwiY2FtbF9qc19lcXVhbHNcIlxuXG4gIGV4dGVybmFsIHB1cmVfZXhwciA6ICh1bml0IC0+ICdhKSAtPiAnYSA9IFwiY2FtbF9qc19wdXJlX2V4cHJcIlxuXG4gIGV4dGVybmFsIGV2YWxfc3RyaW5nIDogc3RyaW5nIC0+ICdhID0gXCJjYW1sX2pzX2V2YWxfc3RyaW5nXCJcblxuICBleHRlcm5hbCBqc19leHByIDogc3RyaW5nIC0+ICdhID0gXCJjYW1sX2pzX2V4cHJcIlxuXG4gIGV4dGVybmFsIHB1cmVfanNfZXhwciA6IHN0cmluZyAtPiAnYSA9IFwiY2FtbF9wdXJlX2pzX2V4cHJcIlxuXG4gIGV4dGVybmFsIGNhbGxiYWNrX3dpdGhfYXJndW1lbnRzIDpcbiAgICAodCBqc19hcnJheSAtPiAnYikgLT4gKCdjLCB0IGpzX2FycmF5IC0+ICdiKSBtZXRoX2NhbGxiYWNrXG4gICAgPSBcImNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHNcIlxuXG4gIGV4dGVybmFsIGNhbGxiYWNrX3dpdGhfYXJpdHkgOiBpbnQgLT4gKCdhIC0+ICdiKSAtPiAoJ2MsICdhIC0+ICdiKSBtZXRoX2NhbGxiYWNrXG4gICAgPSBcImNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3RcIlxuXG4gIGV4dGVybmFsIG1ldGhfY2FsbGJhY2sgOiAoJ2IgLT4gJ2EpIC0+ICgnYiwgJ2EpIG1ldGhfY2FsbGJhY2tcbiAgICA9IFwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlXCJcblxuICBleHRlcm5hbCBtZXRoX2NhbGxiYWNrX3dpdGhfYXJpdHkgOiBpbnQgLT4gKCdiIC0+ICdhKSAtPiAoJ2IsICdhKSBtZXRoX2NhbGxiYWNrXG4gICAgPSBcImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdFwiXG5cbiAgZXh0ZXJuYWwgbWV0aF9jYWxsYmFja193aXRoX2FyZ3VtZW50cyA6XG4gICAgKCdiIC0+IHQganNfYXJyYXkgLT4gJ2EpIC0+ICgnYiwgdCBqc19hcnJheSAtPiAnYSkgbWV0aF9jYWxsYmFja1xuICAgID0gXCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHNcIlxuXG4gIGV4dGVybmFsIHdyYXBfY2FsbGJhY2sgOiAoJ2EgLT4gJ2IpIC0+ICgnYywgJ2EgLT4gJ2IpIG1ldGhfY2FsbGJhY2tcbiAgICA9IFwiY2FtbF9qc193cmFwX2NhbGxiYWNrXCJcblxuICBleHRlcm5hbCB3cmFwX21ldGhfY2FsbGJhY2sgOiAoJ2EgLT4gJ2IpIC0+ICgnYSwgJ2IpIG1ldGhfY2FsbGJhY2tcbiAgICA9IFwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tcIlxuZW5kXG5cbm1vZHVsZSBTeXMgPSBzdHJ1Y3RcbiAgdHlwZSAnYSBjYWxsYmFjayA9ICdhXG5cbiAgZXh0ZXJuYWwgY3JlYXRlX2ZpbGUgOiBuYW1lOnN0cmluZyAtPiBjb250ZW50OnN0cmluZyAtPiB1bml0ID0gXCJjYW1sX2NyZWF0ZV9maWxlXCJcblxuICBleHRlcm5hbCByZWFkX2ZpbGUgOiBuYW1lOnN0cmluZyAtPiBzdHJpbmcgPSBcImNhbWxfcmVhZF9maWxlX2NvbnRlbnRcIlxuXG4gIGV4dGVybmFsIHNldF9jaGFubmVsX291dHB1dCcgOiBvdXRfY2hhbm5lbCAtPiAoanNfc3RyaW5nOkpzLnQgLT4gdW5pdCkgY2FsbGJhY2sgLT4gdW5pdFxuICAgID0gXCJjYW1sX21sX3NldF9jaGFubmVsX291dHB1dFwiXG5cbiAgZXh0ZXJuYWwgc2V0X2NoYW5uZWxfaW5wdXQnIDogaW5fY2hhbm5lbCAtPiAodW5pdCAtPiBzdHJpbmcpIGNhbGxiYWNrIC0+IHVuaXRcbiAgICA9IFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGxcIlxuXG4gIGV4dGVybmFsIG1vdW50X3BvaW50IDogdW5pdCAtPiBzdHJpbmcgbGlzdCA9IFwiY2FtbF9saXN0X21vdW50X3BvaW50XCJcblxuICBleHRlcm5hbCBtb3VudF9hdXRvbG9hZCA6IHN0cmluZyAtPiAoc3RyaW5nIC0+IHN0cmluZyAtPiBzdHJpbmcgb3B0aW9uKSBjYWxsYmFjayAtPiB1bml0XG4gICAgPSBcImNhbWxfbW91bnRfYXV0b2xvYWRcIlxuXG4gIGV4dGVybmFsIHVubW91bnQgOiBzdHJpbmcgLT4gdW5pdCA9IFwiY2FtbF91bm1vdW50XCJcbmVuZFxuXG5tb2R1bGUgRXJyb3IgOiBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIHJhaXNlXyA6IHQgLT4gJ2FcblxuICB2YWwgYXR0YWNoX2pzX2JhY2t0cmFjZSA6IGV4biAtPiBmb3JjZTpib29sIC0+IGV4blxuICAoKiogQXR0YWNoIGEgSmF2YXNTY3JpcHQgZXJyb3IgdG8gYW4gT0NhbWwgZXhjZXB0aW9uLiAgaWYgW2ZvcmNlID0gZmFsc2VdIGFuZCBhXG4gICAgSmF2YXNTY3JpcHQgZXJyb3IgaXMgYWxyZWFkeSBhdHRhY2hlZCwgaXQgd2lsbCBkbyBub3RoaW5nLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWZ1bCB0b1xuICAgIHN0b3JlIGFuZCByZXRyaWV2ZSBpbmZvcm1hdGlvbiBhYm91dCBKYXZhU2NyaXB0IHN0YWNrIHRyYWNlcy5cblxuICAgIEF0dGFjaGluZyBKYXZhc1NjcmlwdCBlcnJvcnMgd2lsbCBoYXBwZW4gYXV0b21hdGljYWxseSB3aGVuIGNvbXBpbGluZyB3aXRoXG4gICAgWy0tZW5hYmxlIHdpdGgtanMtZXJyb3JdLiAqKVxuXG4gIHZhbCBvZl9leG4gOiBleG4gLT4gdCBvcHRpb25cbiAgKCoqIEV4dHJhY3QgYSBKYXZhU2NyaXB0IGVycm9yIGF0dGFjaGVkIHRvIGFuIE9DYW1sIGV4Y2VwdGlvbiwgaWYgYW55LiAgVGhpcyBpcyB1c2VmdWwgdG9cbiAgICAgIGluc3BlY3QgYW4gZXZlbnR1YWwgc3RhY2sgc3RyYWNlLCBlc3BlY2lhbGx5IHdoZW4gc291cmNlbWFwIGlzIGVuYWJsZWQuICopXG5cbiAgZXhjZXB0aW9uIEV4biBvZiB0XG4gICgqKiBUaGUgW0Vycm9yXSBleGNlcHRpb24gd3JhcCBqYXZhc2NyaXB0IGV4Y2VwdGlvbnMgd2hlbiBjYXVnaHQgYnkgT0NhbWwgY29kZS5cbiAgICAgIEluIGNhc2UgdGhlIGphdmFzY3JpcHQgZXhjZXB0aW9uIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBqYXZhc2NyaXB0IFtFcnJvcl0sXG4gICAgICBpdCB3aWxsIGJlIHNlcmlhbGl6ZWQgYW5kIHdyYXBwZWQgaW50byBhIFtGYWlsdXJlXSBleGNlcHRpb24uXG4gICopXG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSB0XG5cbiAgZXhjZXB0aW9uIEV4biBvZiB0XG5cbiAgbGV0IF8gPSBDYWxsYmFjay5yZWdpc3Rlcl9leGNlcHRpb24gXCJqc0Vycm9yXCIgKEV4biAoT2JqLm1hZ2ljIFt8fF0pKVxuXG4gIGxldCByYWlzZV8gOiB0IC0+ICdhID0gSnMuanNfZXhwciBcIihmdW5jdGlvbiAoZXhuKSB7IHRocm93IGV4biB9KVwiXG5cbiAgZXh0ZXJuYWwgb2ZfZXhuIDogZXhuIC0+IHQgb3B0aW9uID0gXCJjYW1sX2pzX2Vycm9yX29wdGlvbl9vZl9leGNlcHRpb25cIlxuXG4gIGV4dGVybmFsIGF0dGFjaF9qc19iYWNrdHJhY2UgOiBleG4gLT4gZm9yY2U6Ym9vbCAtPiBleG4gPSBcImNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlXCJcbmVuZFxuXG5bQEBAb2NhbWwud2FybmluZyBcIi0zMi02MFwiXVxuXG5tb2R1bGUgRm9yX2NvbXBhdGliaWxpdHlfb25seSA9IHN0cnVjdFxuICAoKiBBZGQgcHJpbWl0aXZlcyBmb3IgY29tcGF0aWJpbGl0eSByZWFzb25zLiBFeGlzdGluZyB1c2VycyBtaWdodFxuICAgICBkZXBlbmQgb24gaXQgKGUuZy4gZ2VuX2pzX2FwaSksIHdlIGRvbnQgd2FudCB0aGUgb2NhbWwgY29tcGlsZXJcbiAgICAgdG8gY29tcGxhaW4gYWJvdXQgdGhlc2VzIG1pc3NpbmcgcHJpbWl0aXZlcy4gKilcblxuICBleHRlcm5hbCBjYW1sX2pzX2Zyb21fc3RyaW5nIDogc3RyaW5nIC0+IEpzLnQgPSBcImNhbWxfanNfZnJvbV9zdHJpbmdcIlxuXG4gIGV4dGVybmFsIGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcgOiBKcy50IC0+IHN0cmluZyA9IFwiY2FtbF9qc190b19ieXRlX3N0cmluZ1wiXG5cbiAgZXh0ZXJuYWwgY2FtbF9qc190b19zdHJpbmcgOiBKcy50IC0+IHN0cmluZyA9IFwiY2FtbF9qc190b19zdHJpbmdcIlxuXG4gIGV4dGVybmFsIGNhbWxfbGlzdF9vZl9qc19hcnJheSA6ICdhIEpzLmpzX2FycmF5IC0+ICdhIGxpc3QgPSBcImNhbWxfbGlzdF9vZl9qc19hcnJheVwiXG5cbiAgZXh0ZXJuYWwgY2FtbF9saXN0X3RvX2pzX2FycmF5IDogJ2EgbGlzdCAtPiAnYSBKcy5qc19hcnJheSA9IFwiY2FtbF9saXN0X3RvX2pzX2FycmF5XCJcblxuICBleHRlcm5hbCB2YXJpYWJsZSA6IHN0cmluZyAtPiAnYSA9IFwiY2FtbF9qc192YXJcIlxuZW5kXG5cbm1vZHVsZSBUeXBlZF9hcnJheSA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHR5cGVkQXJyYXkgPSBKcy50XG5cbiAgdHlwZSBhcnJheUJ1ZmZlciA9IEpzLnRcblxuICB0eXBlIHVpbnQ4QXJyYXkgPSBKcy50XG5cbiAgZXh0ZXJuYWwga2luZCA6ICgnYSwgJ2IpIHR5cGVkQXJyYXkgLT4gKCdhLCAnYikgQmlnYXJyYXkua2luZFxuICAgID0gXCJjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXlcIlxuXG4gIGV4dGVybmFsIGZyb21fZ2VuYXJyYXkgOlxuICAgICgnYSwgJ2IsIEJpZ2FycmF5LmNfbGF5b3V0KSBCaWdhcnJheS5HZW5hcnJheS50IC0+ICgnYSwgJ2IpIHR5cGVkQXJyYXlcbiAgICA9IFwiY2FtbF9iYV90b190eXBlZF9hcnJheVwiXG5cbiAgZXh0ZXJuYWwgdG9fZ2VuYXJyYXkgOlxuICAgICgnYSwgJ2IpIHR5cGVkQXJyYXkgLT4gKCdhLCAnYiwgQmlnYXJyYXkuY19sYXlvdXQpIEJpZ2FycmF5LkdlbmFycmF5LnRcbiAgICA9IFwiY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5XCJcblxuICBtb2R1bGUgQmlnc3RyaW5nID0gc3RydWN0XG4gICAgdHlwZSB0ID0gKGNoYXIsIEJpZ2FycmF5LmludDhfdW5zaWduZWRfZWx0LCBCaWdhcnJheS5jX2xheW91dCkgQmlnYXJyYXkuQXJyYXkxLnRcblxuICAgIGV4dGVybmFsIHRvX2FycmF5QnVmZmVyIDogdCAtPiBhcnJheUJ1ZmZlciA9IFwiYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlclwiXG5cbiAgICBleHRlcm5hbCB0b191aW50OEFycmF5IDogdCAtPiB1aW50OEFycmF5ID0gXCJiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXlcIlxuXG4gICAgZXh0ZXJuYWwgb2ZfYXJyYXlCdWZmZXIgOiBhcnJheUJ1ZmZlciAtPiB0ID0gXCJiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyXCJcblxuICAgIGV4dGVybmFsIG9mX3VpbnQ4QXJyYXkgOiB1aW50OEFycmF5IC0+IHQgPSBcImJpZ3N0cmluZ19vZl90eXBlZF9hcnJheVwiXG4gIGVuZFxuXG4gIGV4dGVybmFsIG9mX3VpbnQ4QXJyYXkgOiB1aW50OEFycmF5IC0+IHN0cmluZyA9IFwiY2FtbF9zdHJpbmdfb2ZfYXJyYXlcIlxuZW5kXG5cbm1vZHVsZSBJbnQ2NCA9IHN0cnVjdFxuICBleHRlcm5hbCBjcmVhdGVfaW50NjRfbG9fbWlfaGkgOiBpbnQgLT4gaW50IC0+IGludCAtPiBJbnQ2NC50XG4gICAgPSBcImNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpXCJcbmVuZFxuIiwiKCogSnNfb2Zfb2NhbWwgbGlicmFyeVxuICogaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbiAqIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuICogTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbiAqIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gKiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gKiBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuICopXG5vcGVuISBJbXBvcnRcblxuKCogVGhpcyBsb2NhbCBtb2R1bGUgW0pzXSBpcyBuZWVkZWQgc28gdGhhdCB0aGUgcHB4X2pzIGV4dGVuc2lvbiB3b3JrIHdpdGhpbiB0aGF0IGZpbGUuICopXG5tb2R1bGUgSnMgPSBzdHJ1Y3RcbiAgdHlwZSArJ2EgdFxuXG4gIHR5cGUgKC0nYSwgKydiKSBtZXRoX2NhbGxiYWNrXG5cbiAgbW9kdWxlIFVuc2FmZSA9IHN0cnVjdFxuICAgIHR5cGUgdG9wXG5cbiAgICB0eXBlIGFueSA9IHRvcCB0XG5cbiAgICB0eXBlIGFueV9qc19hcnJheSA9IGFueVxuXG4gICAgZXh0ZXJuYWwgaW5qZWN0IDogJ2EgLT4gYW55ID0gXCIlaWRlbnRpdHlcIlxuXG4gICAgZXh0ZXJuYWwgY29lcmNlIDogXyB0IC0+IF8gdCA9IFwiJWlkZW50aXR5XCJcblxuICAgIGV4dGVybmFsIGdldCA6ICdhIC0+ICdiIC0+ICdjID0gXCJjYW1sX2pzX2dldFwiXG5cbiAgICBleHRlcm5hbCBzZXQgOiAnYSAtPiAnYiAtPiAnYyAtPiB1bml0ID0gXCJjYW1sX2pzX3NldFwiXG5cbiAgICBleHRlcm5hbCBkZWxldGUgOiAnYSAtPiAnYiAtPiB1bml0ID0gXCJjYW1sX2pzX2RlbGV0ZVwiXG5cbiAgICBleHRlcm5hbCBjYWxsIDogJ2EgLT4gJ2IgLT4gYW55IGFycmF5IC0+ICdjID0gXCJjYW1sX2pzX2NhbGxcIlxuXG4gICAgZXh0ZXJuYWwgZnVuX2NhbGwgOiAnYSAtPiBhbnkgYXJyYXkgLT4gJ2IgPSBcImNhbWxfanNfZnVuX2NhbGxcIlxuXG4gICAgZXh0ZXJuYWwgbWV0aF9jYWxsIDogJ2EgLT4gc3RyaW5nIC0+IGFueSBhcnJheSAtPiAnYiA9IFwiY2FtbF9qc19tZXRoX2NhbGxcIlxuXG4gICAgZXh0ZXJuYWwgbmV3X29iaiA6ICdhIC0+IGFueSBhcnJheSAtPiAnYiA9IFwiY2FtbF9qc19uZXdcIlxuXG4gICAgZXh0ZXJuYWwgbmV3X29ial9hcnIgOiAnYSAtPiBhbnlfanNfYXJyYXkgLT4gJ2IgPSBcImNhbWxfb2pzX25ld19hcnJcIlxuXG4gICAgZXh0ZXJuYWwgb2JqIDogKHN0cmluZyAqIGFueSkgYXJyYXkgLT4gJ2EgPSBcImNhbWxfanNfb2JqZWN0XCJcblxuICAgIGV4dGVybmFsIGVxdWFscyA6ICdhIC0+ICdiIC0+IGJvb2wgPSBcImNhbWxfanNfZXF1YWxzXCJcblxuICAgIGV4dGVybmFsIHB1cmVfZXhwciA6ICh1bml0IC0+ICdhKSAtPiAnYSA9IFwiY2FtbF9qc19wdXJlX2V4cHJcIlxuXG4gICAgZXh0ZXJuYWwgZXZhbF9zdHJpbmcgOiBzdHJpbmcgLT4gJ2EgPSBcImNhbWxfanNfZXZhbF9zdHJpbmdcIlxuXG4gICAgZXh0ZXJuYWwganNfZXhwciA6IHN0cmluZyAtPiAnYSA9IFwiY2FtbF9qc19leHByXCJcblxuICAgIGV4dGVybmFsIHB1cmVfanNfZXhwciA6IHN0cmluZyAtPiAnYSA9IFwiY2FtbF9wdXJlX2pzX2V4cHJcIlxuXG4gICAgbGV0IGdsb2JhbCA9IHB1cmVfanNfZXhwciBcImdsb2JhbFRoaXNcIlxuXG4gICAgZXh0ZXJuYWwgY2FsbGJhY2sgOiAoJ2EgLT4gJ2IpIC0+ICgnYywgJ2EgLT4gJ2IpIG1ldGhfY2FsbGJhY2sgPSBcIiVpZGVudGl0eVwiXG5cbiAgICBleHRlcm5hbCBjYWxsYmFja193aXRoX2FyZ3VtZW50cyA6XG4gICAgICAoYW55X2pzX2FycmF5IC0+ICdiKSAtPiAoJ2MsIGFueV9qc19hcnJheSAtPiAnYikgbWV0aF9jYWxsYmFja1xuICAgICAgPSBcImNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHNcIlxuXG4gICAgZXh0ZXJuYWwgY2FsbGJhY2tfd2l0aF9hcml0eSA6IGludCAtPiAoJ2EgLT4gJ2IpIC0+ICgnYywgJ2EgLT4gJ2IpIG1ldGhfY2FsbGJhY2tcbiAgICAgID0gXCJjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0XCJcblxuICAgIGV4dGVybmFsIG1ldGhfY2FsbGJhY2sgOiAoJ2IgLT4gJ2EpIC0+ICgnYiwgJ2EpIG1ldGhfY2FsbGJhY2tcbiAgICAgID0gXCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmVcIlxuXG4gICAgZXh0ZXJuYWwgbWV0aF9jYWxsYmFja193aXRoX2FyaXR5IDogaW50IC0+ICgnYiAtPiAnYSkgLT4gKCdiLCAnYSkgbWV0aF9jYWxsYmFja1xuICAgICAgPSBcImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdFwiXG5cbiAgICBleHRlcm5hbCBtZXRoX2NhbGxiYWNrX3dpdGhfYXJndW1lbnRzIDpcbiAgICAgICgnYiAtPiBhbnlfanNfYXJyYXkgLT4gJ2EpIC0+ICgnYiwgYW55X2pzX2FycmF5IC0+ICdhKSBtZXRoX2NhbGxiYWNrXG4gICAgICA9IFwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzXCJcblxuICAgICgqIERFUFJFQ0FURUQgKilcbiAgICBleHRlcm5hbCB2YXJpYWJsZSA6IHN0cmluZyAtPiAnYSA9IFwiY2FtbF9qc192YXJcIlxuICBlbmRcblxuICAoKioqKilcblxuICB0eXBlICdhIG9wdCA9ICdhXG5cbiAgdHlwZSAnYSBvcHRkZWYgPSAnYVxuXG4gIGV4dGVybmFsIGRlYnVnZ2VyIDogdW5pdCAtPiB1bml0ID0gXCJkZWJ1Z2dlclwiXG5cbiAgbGV0IG51bGwgOiAnYSBvcHQgPSBVbnNhZmUucHVyZV9qc19leHByIFwibnVsbFwiXG5cbiAgZXh0ZXJuYWwgc29tZSA6ICdhIC0+ICdhIG9wdCA9IFwiJWlkZW50aXR5XCJcblxuICBsZXQgdW5kZWZpbmVkIDogJ2Egb3B0ZGVmID0gVW5zYWZlLnB1cmVfanNfZXhwciBcInVuZGVmaW5lZFwiXG5cbiAgZXh0ZXJuYWwgZGVmIDogJ2EgLT4gJ2Egb3B0ZGVmID0gXCIlaWRlbnRpdHlcIlxuXG4gIG1vZHVsZSB0eXBlIE9QVCA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGVtcHR5IDogJ2EgdFxuXG4gICAgdmFsIHJldHVybiA6ICdhIC0+ICdhIHRcblxuICAgIHZhbCBtYXAgOiAnYSB0IC0+ICgnYSAtPiAnYikgLT4gJ2IgdFxuXG4gICAgdmFsIGJpbmQgOiAnYSB0IC0+ICgnYSAtPiAnYiB0KSAtPiAnYiB0XG5cbiAgICB2YWwgdGVzdCA6ICdhIHQgLT4gYm9vbFxuXG4gICAgdmFsIGl0ZXIgOiAnYSB0IC0+ICgnYSAtPiB1bml0KSAtPiB1bml0XG5cbiAgICB2YWwgY2FzZSA6ICdhIHQgLT4gKHVuaXQgLT4gJ2IpIC0+ICgnYSAtPiAnYikgLT4gJ2JcblxuICAgIHZhbCBnZXQgOiAnYSB0IC0+ICh1bml0IC0+ICdhKSAtPiAnYVxuXG4gICAgdmFsIG9wdGlvbiA6ICdhIG9wdGlvbiAtPiAnYSB0XG5cbiAgICB2YWwgdG9fb3B0aW9uIDogJ2EgdCAtPiAnYSBvcHRpb25cbiAgZW5kXG5cbiAgbW9kdWxlIE9wdCA6IE9QVCB3aXRoIHR5cGUgJ2EgdCA9ICdhIG9wdCA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICdhIG9wdFxuXG4gICAgbGV0IGVtcHR5ID0gbnVsbFxuXG4gICAgbGV0IHJldHVybiA9IHNvbWVcblxuICAgIGxldCBtYXAgeCBmID0gaWYgVW5zYWZlLmVxdWFscyB4IG51bGwgdGhlbiBudWxsIGVsc2UgcmV0dXJuIChmIHgpXG5cbiAgICBsZXQgYmluZCB4IGYgPSBpZiBVbnNhZmUuZXF1YWxzIHggbnVsbCB0aGVuIG51bGwgZWxzZSBmIHhcblxuICAgIGxldCB0ZXN0IHggPSBub3QgKFVuc2FmZS5lcXVhbHMgeCBudWxsKVxuXG4gICAgbGV0IGl0ZXIgeCBmID0gaWYgbm90IChVbnNhZmUuZXF1YWxzIHggbnVsbCkgdGhlbiBmIHhcblxuICAgIGxldCBjYXNlIHggZiBnID0gaWYgVW5zYWZlLmVxdWFscyB4IG51bGwgdGhlbiBmICgpIGVsc2UgZyB4XG5cbiAgICBsZXQgZ2V0IHggZiA9IGlmIFVuc2FmZS5lcXVhbHMgeCBudWxsIHRoZW4gZiAoKSBlbHNlIHhcblxuICAgIGxldCBvcHRpb24geCA9XG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBlbXB0eVxuICAgICAgfCBTb21lIHggLT4gcmV0dXJuIHhcblxuICAgIGxldCB0b19vcHRpb24geCA9IGNhc2UgeCAoZnVuICgpIC0+IE5vbmUpIChmdW4geCAtPiBTb21lIHgpXG4gIGVuZFxuXG4gIG1vZHVsZSBPcHRkZWYgOiBPUFQgd2l0aCB0eXBlICdhIHQgPSAnYSBvcHRkZWYgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYSBvcHRkZWZcblxuICAgIGxldCBlbXB0eSA9IHVuZGVmaW5lZFxuXG4gICAgbGV0IHJldHVybiA9IGRlZlxuXG4gICAgbGV0IG1hcCB4IGYgPSBpZiB4ID09IHVuZGVmaW5lZCB0aGVuIHVuZGVmaW5lZCBlbHNlIHJldHVybiAoZiB4KVxuXG4gICAgbGV0IGJpbmQgeCBmID0gaWYgeCA9PSB1bmRlZmluZWQgdGhlbiB1bmRlZmluZWQgZWxzZSBmIHhcblxuICAgIGxldCB0ZXN0IHggPSB4ICE9IHVuZGVmaW5lZFxuXG4gICAgbGV0IGl0ZXIgeCBmID0gaWYgeCAhPSB1bmRlZmluZWQgdGhlbiBmIHhcblxuICAgIGxldCBjYXNlIHggZiBnID0gaWYgeCA9PSB1bmRlZmluZWQgdGhlbiBmICgpIGVsc2UgZyB4XG5cbiAgICBsZXQgZ2V0IHggZiA9IGlmIHggPT0gdW5kZWZpbmVkIHRoZW4gZiAoKSBlbHNlIHhcblxuICAgIGxldCBvcHRpb24geCA9XG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBlbXB0eVxuICAgICAgfCBTb21lIHggLT4gcmV0dXJuIHhcblxuICAgIGxldCB0b19vcHRpb24geCA9IGNhc2UgeCAoZnVuICgpIC0+IE5vbmUpIChmdW4geCAtPiBTb21lIHgpXG4gIGVuZFxuXG4gICgqKioqKVxuXG4gIGxldCBjb2VyY2UgeCBmIGcgPSBPcHQuZ2V0IChmIHgpIChmdW4gKCkgLT4gZyB4KVxuXG4gIGxldCBjb2VyY2Vfb3B0IHggZiBnID0gT3B0LmdldCAoT3B0LmJpbmQgeCBmKSAoZnVuICgpIC0+IGcgeClcblxuICAoKioqKilcblxuICB0eXBlICsnYSBtZXRoXG5cbiAgdHlwZSArJ2EgZ2VuX3Byb3BcblxuICB0eXBlICdhIHJlYWRvbmx5X3Byb3AgPSA8IGdldCA6ICdhID4gZ2VuX3Byb3BcblxuICB0eXBlICdhIHdyaXRlb25seV9wcm9wID0gPCBzZXQgOiAnYSAtPiB1bml0ID4gZ2VuX3Byb3BcblxuICB0eXBlICdhIHByb3AgPSA8IGdldCA6ICdhIDsgc2V0IDogJ2EgLT4gdW5pdCA+IGdlbl9wcm9wXG5cbiAgdHlwZSAnYSBvcHRkZWZfcHJvcCA9IDwgZ2V0IDogJ2Egb3B0ZGVmIDsgc2V0IDogJ2EgLT4gdW5pdCA+IGdlbl9wcm9wXG5cbiAgdHlwZSArJ2EgY29uc3RyXG5cbiAgKCoqKiopXG5cbiAgdHlwZSAnYSBjYWxsYmFjayA9ICh1bml0LCAnYSkgbWV0aF9jYWxsYmFja1xuXG4gIGV4dGVybmFsIHdyYXBfY2FsbGJhY2sgOiAoJ2EgLT4gJ2IpIC0+ICgnYywgJ2EgLT4gJ2IpIG1ldGhfY2FsbGJhY2tcbiAgICA9IFwiY2FtbF9qc193cmFwX2NhbGxiYWNrXCJcblxuICBleHRlcm5hbCB3cmFwX21ldGhfY2FsbGJhY2sgOiAoJ2EgLT4gJ2IpIC0+ICgnYSwgJ2IpIG1ldGhfY2FsbGJhY2tcbiAgICA9IFwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tcIlxuXG4gICgqKioqKVxuXG4gIGxldCBfdHJ1ZSA9IFVuc2FmZS5wdXJlX2pzX2V4cHIgXCJ0cnVlXCJcblxuICBsZXQgX2ZhbHNlID0gVW5zYWZlLnB1cmVfanNfZXhwciBcImZhbHNlXCJcblxuICB0eXBlIG1hdGNoX3Jlc3VsdF9oYW5kbGVcblxuICB0eXBlIHN0cmluZ19hcnJheVxuXG4gIGNsYXNzIHR5cGUganNfc3RyaW5nID1cbiAgICBvYmplY3RcbiAgICAgIG1ldGhvZCB0b1N0cmluZyA6IGpzX3N0cmluZyB0IG1ldGhcblxuICAgICAgbWV0aG9kIHZhbHVlT2YgOiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICAgIG1ldGhvZCBjaGFyQXQgOiBpbnQgLT4ganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgICBtZXRob2QgY2hhckNvZGVBdCA6IGludCAtPiBmbG9hdCBtZXRoXG5cbiAgICAgICgqIFRoaXMgbWF5IHJldHVybiBOYU4uLi4gKilcbiAgICAgIG1ldGhvZCBjb25jYXQgOiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICAgIG1ldGhvZCBjb25jYXRfMiA6IGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0IG1ldGhcblxuICAgICAgbWV0aG9kIGNvbmNhdF8zIDoganNfc3RyaW5nIHQgLT4ganNfc3RyaW5nIHQgLT4ganNfc3RyaW5nIHQgLT4ganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgICBtZXRob2QgY29uY2F0XzQgOlxuICAgICAgICBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICAgIG1ldGhvZCBpbmRleE9mIDoganNfc3RyaW5nIHQgLT4gaW50IG1ldGhcblxuICAgICAgbWV0aG9kIGluZGV4T2ZfZnJvbSA6IGpzX3N0cmluZyB0IC0+IGludCAtPiBpbnQgbWV0aFxuXG4gICAgICBtZXRob2QgbGFzdEluZGV4T2YgOiBqc19zdHJpbmcgdCAtPiBpbnQgbWV0aFxuXG4gICAgICBtZXRob2QgbGFzdEluZGV4T2ZfZnJvbSA6IGpzX3N0cmluZyB0IC0+IGludCAtPiBpbnQgbWV0aFxuXG4gICAgICBtZXRob2QgbG9jYWxlQ29tcGFyZSA6IGpzX3N0cmluZyB0IC0+IGZsb2F0IG1ldGhcblxuICAgICAgbWV0aG9kIF9tYXRjaCA6IHJlZ0V4cCB0IC0+IG1hdGNoX3Jlc3VsdF9oYW5kbGUgdCBvcHQgbWV0aFxuXG4gICAgICBtZXRob2QgcmVwbGFjZSA6IHJlZ0V4cCB0IC0+IGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0IG1ldGhcblxuICAgICAgbWV0aG9kIHJlcGxhY2Vfc3RyaW5nIDoganNfc3RyaW5nIHQgLT4ganNfc3RyaW5nIHQgLT4ganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgICBtZXRob2Qgc2VhcmNoIDogcmVnRXhwIHQgLT4gaW50IG1ldGhcblxuICAgICAgbWV0aG9kIHNsaWNlIDogaW50IC0+IGludCAtPiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICAgIG1ldGhvZCBzbGljZV9lbmQgOiBpbnQgLT4ganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgICBtZXRob2Qgc3BsaXQgOiBqc19zdHJpbmcgdCAtPiBzdHJpbmdfYXJyYXkgdCBtZXRoXG5cbiAgICAgIG1ldGhvZCBzcGxpdF9saW1pdGVkIDoganNfc3RyaW5nIHQgLT4gaW50IC0+IHN0cmluZ19hcnJheSB0IG1ldGhcblxuICAgICAgbWV0aG9kIHNwbGl0X3JlZ0V4cCA6IHJlZ0V4cCB0IC0+IHN0cmluZ19hcnJheSB0IG1ldGhcblxuICAgICAgbWV0aG9kIHNwbGl0X3JlZ0V4cExpbWl0ZWQgOiByZWdFeHAgdCAtPiBpbnQgLT4gc3RyaW5nX2FycmF5IHQgbWV0aFxuXG4gICAgICBtZXRob2Qgc3Vic3RyaW5nIDogaW50IC0+IGludCAtPiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICAgIG1ldGhvZCBzdWJzdHJpbmdfdG9FbmQgOiBpbnQgLT4ganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgICBtZXRob2QgdG9Mb3dlckNhc2UgOiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICAgIG1ldGhvZCB0b0xvY2FsZUxvd2VyQ2FzZSA6IGpzX3N0cmluZyB0IG1ldGhcblxuICAgICAgbWV0aG9kIHRvVXBwZXJDYXNlIDoganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgICBtZXRob2QgdG9Mb2NhbGVVcHBlckNhc2UgOiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICAgIG1ldGhvZCB0cmltIDoganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgICBtZXRob2QgbGVuZ3RoIDogaW50IHJlYWRvbmx5X3Byb3BcbiAgICBlbmRcblxuICBhbmQgcmVnRXhwID1cbiAgICBvYmplY3RcbiAgICAgIG1ldGhvZCBleGVjIDoganNfc3RyaW5nIHQgLT4gbWF0Y2hfcmVzdWx0X2hhbmRsZSB0IG9wdCBtZXRoXG5cbiAgICAgIG1ldGhvZCB0ZXN0IDoganNfc3RyaW5nIHQgLT4gYm9vbCB0IG1ldGhcblxuICAgICAgbWV0aG9kIHRvU3RyaW5nIDoganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgICBtZXRob2Qgc291cmNlIDoganNfc3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgICBtZXRob2QgZ2xvYmFsIDogYm9vbCB0IHJlYWRvbmx5X3Byb3BcblxuICAgICAgbWV0aG9kIGlnbm9yZUNhc2UgOiBib29sIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgICBtZXRob2QgbXVsdGlsaW5lIDogYm9vbCB0IHJlYWRvbmx5X3Byb3BcblxuICAgICAgbWV0aG9kIGxhc3RJbmRleCA6IGludCBwcm9wXG4gICAgZW5kXG5cbiAgKCogc3RyaW5nIGlzIHVzZWQgYnkgcHB4X2pzLCBpdCBuZWVkcyB0byBjb21lIGJlZm9yZSBhbnkgdXNlIG9mIHRoZVxuICAgICBuZXcgc3ludGF4IGluIHRoaXMgZmlsZSAqKVxuICBleHRlcm5hbCBzdHJpbmcgOiBzdHJpbmcgLT4ganNfc3RyaW5nIHQgPSBcImNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXCJcblxuICBleHRlcm5hbCB0b19zdHJpbmcgOiBqc19zdHJpbmcgdCAtPiBzdHJpbmcgPSBcImNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXCJcbmVuZFxuXG5pbmNsdWRlIEpzXG5cbmNsYXNzIHR5cGUgc3RyaW5nX2NvbnN0ciA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBmcm9tQ2hhckNvZGUgOiBpbnQgLT4ganNfc3RyaW5nIHQgbWV0aFxuICBlbmRcblxubGV0IHN0cmluZ19jb25zdHIgPSBVbnNhZmUuZ2xvYmFsIyMuX1N0cmluZ1xuXG5sZXQgcmVnRXhwID0gVW5zYWZlLmdsb2JhbCMjLl9SZWdFeHBcblxubGV0IHJlZ0V4cF9jb3B5ID0gcmVnRXhwXG5cbmxldCByZWdFeHBfd2l0aEZsYWdzID0gcmVnRXhwXG5cbmNsYXNzIHR5cGUgWydhXSBqc19hcnJheSA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCB0b1N0cmluZyA6IGpzX3N0cmluZyB0IG1ldGhcblxuICAgIG1ldGhvZCB0b0xvY2FsZVN0cmluZyA6IGpzX3N0cmluZyB0IG1ldGhcblxuICAgIG1ldGhvZCBjb25jYXQgOiAnYSBqc19hcnJheSB0IC0+ICdhIGpzX2FycmF5IHQgbWV0aFxuXG4gICAgbWV0aG9kIGpvaW4gOiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICBtZXRob2QgcG9wIDogJ2Egb3B0ZGVmIG1ldGhcblxuICAgIG1ldGhvZCBwdXNoIDogJ2EgLT4gaW50IG1ldGhcblxuICAgIG1ldGhvZCBwdXNoXzIgOiAnYSAtPiAnYSAtPiBpbnQgbWV0aFxuXG4gICAgbWV0aG9kIHB1c2hfMyA6ICdhIC0+ICdhIC0+ICdhIC0+IGludCBtZXRoXG5cbiAgICBtZXRob2QgcHVzaF80IDogJ2EgLT4gJ2EgLT4gJ2EgLT4gJ2EgLT4gaW50IG1ldGhcblxuICAgIG1ldGhvZCByZXZlcnNlIDogJ2EganNfYXJyYXkgdCBtZXRoXG5cbiAgICBtZXRob2Qgc2hpZnQgOiAnYSBvcHRkZWYgbWV0aFxuXG4gICAgbWV0aG9kIHNsaWNlIDogaW50IC0+IGludCAtPiAnYSBqc19hcnJheSB0IG1ldGhcblxuICAgIG1ldGhvZCBzbGljZV9lbmQgOiBpbnQgLT4gJ2EganNfYXJyYXkgdCBtZXRoXG5cbiAgICBtZXRob2Qgc29ydCA6ICgnYSAtPiAnYSAtPiBmbG9hdCkgY2FsbGJhY2sgLT4gJ2EganNfYXJyYXkgdCBtZXRoXG5cbiAgICBtZXRob2Qgc29ydF9hc1N0cmluZ3MgOiAnYSBqc19hcnJheSB0IG1ldGhcblxuICAgIG1ldGhvZCBzcGxpY2UgOiBpbnQgLT4gaW50IC0+ICdhIGpzX2FycmF5IHQgbWV0aFxuXG4gICAgbWV0aG9kIHNwbGljZV8xIDogaW50IC0+IGludCAtPiAnYSAtPiAnYSBqc19hcnJheSB0IG1ldGhcblxuICAgIG1ldGhvZCBzcGxpY2VfMiA6IGludCAtPiBpbnQgLT4gJ2EgLT4gJ2EgLT4gJ2EganNfYXJyYXkgdCBtZXRoXG5cbiAgICBtZXRob2Qgc3BsaWNlXzMgOiBpbnQgLT4gaW50IC0+ICdhIC0+ICdhIC0+ICdhIC0+ICdhIGpzX2FycmF5IHQgbWV0aFxuXG4gICAgbWV0aG9kIHNwbGljZV80IDogaW50IC0+IGludCAtPiAnYSAtPiAnYSAtPiAnYSAtPiAnYSAtPiAnYSBqc19hcnJheSB0IG1ldGhcblxuICAgIG1ldGhvZCB1bnNoaWZ0IDogJ2EgLT4gaW50IG1ldGhcblxuICAgIG1ldGhvZCB1bnNoaWZ0XzIgOiAnYSAtPiAnYSAtPiBpbnQgbWV0aFxuXG4gICAgbWV0aG9kIHVuc2hpZnRfMyA6ICdhIC0+ICdhIC0+ICdhIC0+IGludCBtZXRoXG5cbiAgICBtZXRob2QgdW5zaGlmdF80IDogJ2EgLT4gJ2EgLT4gJ2EgLT4gJ2EgLT4gaW50IG1ldGhcblxuICAgIG1ldGhvZCBzb21lIDogKCdhIC0+IGludCAtPiAnYSBqc19hcnJheSB0IC0+IGJvb2wgdCkgY2FsbGJhY2sgLT4gYm9vbCB0IG1ldGhcblxuICAgIG1ldGhvZCBldmVyeSA6ICgnYSAtPiBpbnQgLT4gJ2EganNfYXJyYXkgdCAtPiBib29sIHQpIGNhbGxiYWNrIC0+IGJvb2wgdCBtZXRoXG5cbiAgICBtZXRob2QgZm9yRWFjaCA6ICgnYSAtPiBpbnQgLT4gJ2EganNfYXJyYXkgdCAtPiB1bml0KSBjYWxsYmFjayAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBtYXAgOiAoJ2EgLT4gaW50IC0+ICdhIGpzX2FycmF5IHQgLT4gJ2IpIGNhbGxiYWNrIC0+ICdiIGpzX2FycmF5IHQgbWV0aFxuXG4gICAgbWV0aG9kIGZpbHRlciA6ICgnYSAtPiBpbnQgLT4gJ2EganNfYXJyYXkgdCAtPiBib29sIHQpIGNhbGxiYWNrIC0+ICdhIGpzX2FycmF5IHQgbWV0aFxuXG4gICAgbWV0aG9kIHJlZHVjZV9pbml0IDpcbiAgICAgICgnYiAtPiAnYSAtPiBpbnQgLT4gJ2EganNfYXJyYXkgdCAtPiAnYikgY2FsbGJhY2sgLT4gJ2IgLT4gJ2IgbWV0aFxuXG4gICAgbWV0aG9kIHJlZHVjZSA6ICgnYSAtPiAnYSAtPiBpbnQgLT4gJ2EganNfYXJyYXkgdCAtPiAnYSkgY2FsbGJhY2sgLT4gJ2EgbWV0aFxuXG4gICAgbWV0aG9kIHJlZHVjZVJpZ2h0X2luaXQgOlxuICAgICAgKCdiIC0+ICdhIC0+IGludCAtPiAnYSBqc19hcnJheSB0IC0+ICdiKSBjYWxsYmFjayAtPiAnYiAtPiAnYiBtZXRoXG5cbiAgICBtZXRob2QgcmVkdWNlUmlnaHQgOiAoJ2EgLT4gJ2EgLT4gaW50IC0+ICdhIGpzX2FycmF5IHQgLT4gJ2EpIGNhbGxiYWNrIC0+ICdhIG1ldGhcblxuICAgIG1ldGhvZCBsZW5ndGggOiBpbnQgcHJvcFxuICBlbmRcblxubGV0IG9iamVjdF9jb25zdHJ1Y3RvciA9IFVuc2FmZS5nbG9iYWwjIy5fT2JqZWN0XG5cbmxldCBvYmplY3Rfa2V5cyBvIDoganNfc3RyaW5nIHQganNfYXJyYXkgdCA9IG9iamVjdF9jb25zdHJ1Y3RvciMja2V5cyBvXG5cbmxldCBhcnJheV9jb25zdHJ1Y3RvciA9IFVuc2FmZS5nbG9iYWwjIy5fQXJyYXlcblxubGV0IGFycmF5X2VtcHR5ID0gYXJyYXlfY29uc3RydWN0b3JcblxubGV0IGFycmF5X2xlbmd0aCA9IGFycmF5X2NvbnN0cnVjdG9yXG5cbmxldCBhcnJheV9nZXQgOiAnYSAjanNfYXJyYXkgdCAtPiBpbnQgLT4gJ2Egb3B0ZGVmID0gVW5zYWZlLmdldFxuXG5sZXQgYXJyYXlfc2V0IDogJ2EgI2pzX2FycmF5IHQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBVbnNhZmUuc2V0XG5cbmxldCBhcnJheV9tYXBfcG9seSA6XG4gICAgJ2EgI2pzX2FycmF5IHQgLT4gKCdhIC0+IGludCAtPiAnYSAjanNfYXJyYXkgdCAtPiAnYikgY2FsbGJhY2sgLT4gJ2IgI2pzX2FycmF5IHQgPVxuIGZ1biBhIGNiIC0+IChVbnNhZmUuY29lcmNlIGEpIyNtYXAgY2JcblxubGV0IGFycmF5X21hcCBmIGEgPSBhcnJheV9tYXBfcG9seSBhICh3cmFwX2NhbGxiYWNrIChmdW4geCBfaWR4IF8gLT4gZiB4KSlcblxubGV0IGFycmF5X21hcGkgZiBhID0gYXJyYXlfbWFwX3BvbHkgYSAod3JhcF9jYWxsYmFjayAoZnVuIHggaWR4IF8gLT4gZiBpZHggeCkpXG5cbmNsYXNzIHR5cGUgbWF0Y2hfcmVzdWx0ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBbanNfc3RyaW5nIHRdIGpzX2FycmF5XG5cbiAgICBtZXRob2QgaW5kZXggOiBpbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGlucHV0IDoganNfc3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxubGV0IHN0cl9hcnJheSA6IHN0cmluZ19hcnJheSB0IC0+IGpzX3N0cmluZyB0IGpzX2FycmF5IHQgPSBVbnNhZmUuY29lcmNlXG5cbmxldCBtYXRjaF9yZXN1bHQgOiBtYXRjaF9yZXN1bHRfaGFuZGxlIHQgLT4gbWF0Y2hfcmVzdWx0IHQgPSBVbnNhZmUuY29lcmNlXG5cbmNsYXNzIHR5cGUgbnVtYmVyID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIHRvU3RyaW5nIDoganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgbWV0aG9kIHRvU3RyaW5nX3JhZGl4IDogaW50IC0+IGpzX3N0cmluZyB0IG1ldGhcblxuICAgIG1ldGhvZCB0b0xvY2FsZVN0cmluZyA6IGpzX3N0cmluZyB0IG1ldGhcblxuICAgIG1ldGhvZCB0b0ZpeGVkIDogaW50IC0+IGpzX3N0cmluZyB0IG1ldGhcblxuICAgIG1ldGhvZCB0b0V4cG9uZW50aWFsIDoganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgbWV0aG9kIHRvRXhwb25lbnRpYWxfZGlnaXRzIDogaW50IC0+IGpzX3N0cmluZyB0IG1ldGhcblxuICAgIG1ldGhvZCB0b1ByZWNpc2lvbiA6IGludCAtPiBqc19zdHJpbmcgdCBtZXRoXG4gIGVuZFxuXG5leHRlcm5hbCBudW1iZXJfb2ZfZmxvYXQgOiBmbG9hdCAtPiBudW1iZXIgdCA9IFwiY2FtbF9qc19mcm9tX2Zsb2F0XCJcblxuZXh0ZXJuYWwgZmxvYXRfb2ZfbnVtYmVyIDogbnVtYmVyIHQgLT4gZmxvYXQgPSBcImNhbWxfanNfdG9fZmxvYXRcIlxuXG5jbGFzcyB0eXBlIGRhdGUgPVxuICBvYmplY3RcbiAgICBtZXRob2QgdG9TdHJpbmcgOiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICBtZXRob2QgdG9EYXRlU3RyaW5nIDoganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgbWV0aG9kIHRvVGltZVN0cmluZyA6IGpzX3N0cmluZyB0IG1ldGhcblxuICAgIG1ldGhvZCB0b0xvY2FsZVN0cmluZyA6IGpzX3N0cmluZyB0IG1ldGhcblxuICAgIG1ldGhvZCB0b0xvY2FsZURhdGVTdHJpbmcgOiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICBtZXRob2QgdG9Mb2NhbGVUaW1lU3RyaW5nIDoganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgbWV0aG9kIHZhbHVlT2YgOiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0VGltZSA6IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRGdWxsWWVhciA6IGludCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0VVRDRnVsbFllYXIgOiBpbnQgbWV0aFxuXG4gICAgbWV0aG9kIGdldE1vbnRoIDogaW50IG1ldGhcblxuICAgIG1ldGhvZCBnZXRVVENNb250aCA6IGludCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0RGF0ZSA6IGludCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0VVRDRGF0ZSA6IGludCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0RGF5IDogaW50IG1ldGhcblxuICAgIG1ldGhvZCBnZXRVVENEYXkgOiBpbnQgbWV0aFxuXG4gICAgbWV0aG9kIGdldEhvdXJzIDogaW50IG1ldGhcblxuICAgIG1ldGhvZCBnZXRVVENIb3VycyA6IGludCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0TWludXRlcyA6IGludCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0VVRDTWludXRlcyA6IGludCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0U2Vjb25kcyA6IGludCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0VVRDU2Vjb25kcyA6IGludCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0TWlsbGlzZWNvbmRzIDogaW50IG1ldGhcblxuICAgIG1ldGhvZCBnZXRVVENNaWxsaXNlY29uZHMgOiBpbnQgbWV0aFxuXG4gICAgbWV0aG9kIGdldFRpbWV6b25lT2Zmc2V0IDogaW50IG1ldGhcblxuICAgIG1ldGhvZCBzZXRUaW1lIDogZmxvYXQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldEZ1bGxZZWFyIDogaW50IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBzZXRVVENGdWxsWWVhciA6IGludCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0TW9udGggOiBpbnQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldFVUQ01vbnRoIDogaW50IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBzZXREYXRlIDogaW50IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBzZXRVVENEYXRlIDogaW50IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBzZXREYXkgOiBpbnQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldFVUQ0RheSA6IGludCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0SG91cnMgOiBpbnQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldFVUQ0hvdXJzIDogaW50IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBzZXRNaW51dGVzIDogaW50IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBzZXRVVENNaW51dGVzIDogaW50IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBzZXRTZWNvbmRzIDogaW50IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBzZXRVVENTZWNvbmRzIDogaW50IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBzZXRNaWxsaXNlY29uZHMgOiBpbnQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldFVUQ01pbGxpc2Vjb25kcyA6IGludCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgdG9VVENTdHJpbmcgOiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICBtZXRob2QgdG9JU09TdHJpbmcgOiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICBtZXRob2QgdG9KU09OIDogJ2EgLT4ganNfc3RyaW5nIHQgbWV0aFxuICBlbmRcblxuY2xhc3MgdHlwZSBkYXRlX2NvbnN0ciA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBwYXJzZSA6IGpzX3N0cmluZyB0IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBfVVRDX21vbnRoIDogaW50IC0+IGludCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgX1VUQ19kYXkgOiBpbnQgLT4gaW50IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBfVVRDX2hvdXIgOiBpbnQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIF9VVENfbWluIDogaW50IC0+IGludCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgX1VUQ19zZWMgOiBpbnQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgX1VUQ19tcyA6IGludCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2Qgbm93IDogZmxvYXQgbWV0aFxuICBlbmRcblxubGV0IGRhdGVfY29uc3RyID0gVW5zYWZlLmdsb2JhbCMjLl9EYXRlXG5cbmxldCBkYXRlIDogZGF0ZV9jb25zdHIgdCA9IGRhdGVfY29uc3RyXG5cbmxldCBkYXRlX25vdyA6IGRhdGUgdCBjb25zdHIgPSBkYXRlX2NvbnN0clxuXG5sZXQgZGF0ZV9mcm9tVGltZVZhbHVlIDogKGZsb2F0IC0+IGRhdGUgdCkgY29uc3RyID0gZGF0ZV9jb25zdHJcblxubGV0IGRhdGVfbW9udGggOiAoaW50IC0+IGludCAtPiBkYXRlIHQpIGNvbnN0ciA9IGRhdGVfY29uc3RyXG5cbmxldCBkYXRlX2RheSA6IChpbnQgLT4gaW50IC0+IGludCAtPiBkYXRlIHQpIGNvbnN0ciA9IGRhdGVfY29uc3RyXG5cbmxldCBkYXRlX2hvdXIgOiAoaW50IC0+IGludCAtPiBpbnQgLT4gaW50IC0+IGRhdGUgdCkgY29uc3RyID0gZGF0ZV9jb25zdHJcblxubGV0IGRhdGVfbWluIDogKGludCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gZGF0ZSB0KSBjb25zdHIgPSBkYXRlX2NvbnN0clxuXG5sZXQgZGF0ZV9zZWMgOiAoaW50IC0+IGludCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gZGF0ZSB0KSBjb25zdHIgPSBkYXRlX2NvbnN0clxuXG5sZXQgZGF0ZV9tcyA6IChpbnQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gZGF0ZSB0KSBjb25zdHIgPVxuICBkYXRlX2NvbnN0clxuXG5jbGFzcyB0eXBlIG1hdGggPVxuICBvYmplY3RcbiAgICBtZXRob2QgX0UgOiBmbG9hdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0xOMiA6IGZsb2F0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfTE4xMCA6IGZsb2F0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfTE9HMkUgOiBmbG9hdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0xPRzEwRSA6IGZsb2F0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfUEkgOiBmbG9hdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1NRUlQxXzJfIDogZmxvYXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9TUVJUMiA6IGZsb2F0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBhYnMgOiBmbG9hdCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgYWNvcyA6IGZsb2F0IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBhc2luIDogZmxvYXQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIGF0YW4gOiBmbG9hdCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgY2VpbCA6IGZsb2F0IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBjb3MgOiBmbG9hdCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgZXhwIDogZmxvYXQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIGZsb29yIDogZmxvYXQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIGxvZyA6IGZsb2F0IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBtYXggOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgbWF4XzMgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgbWF4XzQgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgbWluIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIG1pbl8zIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIG1pbl80IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIHBvdyA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCByYW5kb20gOiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2Qgcm91bmQgOiBmbG9hdCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2Qgc2luIDogZmxvYXQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIHNxcnQgOiBmbG9hdCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgdGFuIDogZmxvYXQgLT4gZmxvYXQgbWV0aFxuICBlbmRcblxubGV0IG1hdGggPSBVbnNhZmUuZ2xvYmFsIyMuX01hdGhcblxuY2xhc3MgdHlwZSBlcnJvciA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBuYW1lIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIG1lc3NhZ2UgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2Qgc3RhY2sgOiBqc19zdHJpbmcgdCBvcHRkZWYgcHJvcFxuXG4gICAgbWV0aG9kIHRvU3RyaW5nIDoganNfc3RyaW5nIHQgbWV0aFxuICBlbmRcblxubGV0IGVycm9yX2NvbnN0ciA9IFVuc2FmZS5nbG9iYWwjIy5fRXJyb3JcblxubW9kdWxlIEpzX2Vycm9yID0gc3RydWN0XG4gIHR5cGUgZXJyb3JfdCA9IGVycm9yIHRcblxuICBpbmNsdWRlIEpzb29fcnVudGltZS5FcnJvclxuXG4gIGV4dGVybmFsIG9mX2Vycm9yIDogZXJyb3JfdCAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuXG4gIGV4dGVybmFsIHRvX2Vycm9yIDogdCAtPiBlcnJvcl90ID0gXCIlaWRlbnRpdHlcIlxuXG4gIGxldCBuYW1lIGUgPSB0b19zdHJpbmcgKHRvX2Vycm9yIGUpIyMubmFtZVxuXG4gIGxldCBtZXNzYWdlIGUgPSB0b19zdHJpbmcgKHRvX2Vycm9yIGUpIyMubWVzc2FnZVxuXG4gIGxldCBzdGFjayAoZSA6IHQpIDogc3RyaW5nIG9wdGlvbiA9XG4gICAgT3B0LnRvX29wdGlvbiAoT3B0Lm1hcCAodG9fZXJyb3IgZSkjIy5zdGFjayB0b19zdHJpbmcpXG5cbiAgbGV0IHRvX3N0cmluZyBlID0gdG9fc3RyaW5nICh0b19lcnJvciBlKSMjdG9TdHJpbmdcbmVuZFxuXG5tb2R1bGUgTWFnaWMgPSBzdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgVCA9IHNpZ1xuICAgIGV4Y2VwdGlvbiBFcnJvciBvZiBlcnJvciB0XG4gIGVuZFxuXG4gIHR5cGUgKCdhLCAnYikgZXEgPSBFcSA6ICgnYSwgJ2EpIGVxXG5cbiAgbGV0IChlcSA6IChlcnJvciB0LCBKc19lcnJvci50KSBlcSkgPSBPYmoubWFnaWMgRXFcblxuICBsZXQgbSA9XG4gICAgbWF0Y2ggZXEgd2l0aFxuICAgIHwgRXEgLT5cbiAgICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgICBleGNlcHRpb24gRXJyb3IgPSBKc19lcnJvci5FeG5cbiAgICAgICAgZW5kIDogVClcblxuICBtb2R1bGUgRXJyb3IgPSAodmFsIG0gOiBUKVxuZW5kXG5cbmluY2x1ZGUgTWFnaWMuRXJyb3JcblxubGV0IHJhaXNlX2pzX2Vycm9yIGUgPSBKc19lcnJvci5yYWlzZV8gKEpzX2Vycm9yLm9mX2Vycm9yIGUpXG5cbmxldCBzdHJpbmdfb2ZfZXJyb3IgZSA9IEpzX2Vycm9yLnRvX3N0cmluZyAoSnNfZXJyb3Iub2ZfZXJyb3IgZSlcblxubGV0IGV4bl93aXRoX2pzX2JhY2t0cmFjZSA9IEpzX2Vycm9yLmF0dGFjaF9qc19iYWNrdHJhY2VcblxuZXh0ZXJuYWwganNfZXJyb3Jfb2ZfZXhuIDogZXhuIC0+IGVycm9yIHQgb3B0ID0gXCJjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvblwiXG5cbmNsYXNzIHR5cGUganNvbiA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBwYXJzZSA6IGpzX3N0cmluZyB0IC0+ICdhIG1ldGhcblxuICAgIG1ldGhvZCBzdHJpbmdpZnkgOiAnYSAtPiBqc19zdHJpbmcgdCBtZXRoXG4gIGVuZFxuXG5sZXQgX0pTT04gOiBqc29uIHQgPSBVbnNhZmUuZ2xvYmFsIyMuX0pTT05cblxubGV0IGRlY29kZVVSSSAocyA6IGpzX3N0cmluZyB0KSA6IGpzX3N0cmluZyB0ID1cbiAgVW5zYWZlLmZ1bl9jYWxsIFVuc2FmZS5nbG9iYWwjIy5kZWNvZGVVUkkgW3wgVW5zYWZlLmluamVjdCBzIHxdXG5cbmxldCBkZWNvZGVVUklDb21wb25lbnQgKHMgOiBqc19zdHJpbmcgdCkgOiBqc19zdHJpbmcgdCA9XG4gIFVuc2FmZS5mdW5fY2FsbCBVbnNhZmUuZ2xvYmFsIyMuZGVjb2RlVVJJQ29tcG9uZW50IFt8IFVuc2FmZS5pbmplY3QgcyB8XVxuXG5sZXQgZW5jb2RlVVJJIChzIDoganNfc3RyaW5nIHQpIDoganNfc3RyaW5nIHQgPVxuICBVbnNhZmUuZnVuX2NhbGwgVW5zYWZlLmdsb2JhbCMjLmVuY29kZVVSSSBbfCBVbnNhZmUuaW5qZWN0IHMgfF1cblxubGV0IGVuY29kZVVSSUNvbXBvbmVudCAocyA6IGpzX3N0cmluZyB0KSA6IGpzX3N0cmluZyB0ID1cbiAgVW5zYWZlLmZ1bl9jYWxsIFVuc2FmZS5nbG9iYWwjIy5lbmNvZGVVUklDb21wb25lbnQgW3wgVW5zYWZlLmluamVjdCBzIHxdXG5cbmxldCBlc2NhcGUgKHMgOiBqc19zdHJpbmcgdCkgOiBqc19zdHJpbmcgdCA9XG4gIFVuc2FmZS5mdW5fY2FsbCBVbnNhZmUuZ2xvYmFsIyMuZXNjYXBlIFt8IFVuc2FmZS5pbmplY3QgcyB8XVxuXG5sZXQgdW5lc2NhcGUgKHMgOiBqc19zdHJpbmcgdCkgOiBqc19zdHJpbmcgdCA9XG4gIFVuc2FmZS5mdW5fY2FsbCBVbnNhZmUuZ2xvYmFsIyMudW5lc2NhcGUgW3wgVW5zYWZlLmluamVjdCBzIHxdXG5cbmV4dGVybmFsIGJvb2wgOiBib29sIC0+IGJvb2wgdCA9IFwiY2FtbF9qc19mcm9tX2Jvb2xcIlxuXG5leHRlcm5hbCB0b19ib29sIDogYm9vbCB0IC0+IGJvb2wgPSBcImNhbWxfanNfdG9fYm9vbFwiXG5cbmV4dGVybmFsIGFycmF5IDogJ2EgYXJyYXkgLT4gJ2EganNfYXJyYXkgdCA9IFwiY2FtbF9qc19mcm9tX2FycmF5XCJcblxuZXh0ZXJuYWwgdG9fYXJyYXkgOiAnYSBqc19hcnJheSB0IC0+ICdhIGFycmF5ID0gXCJjYW1sX2pzX3RvX2FycmF5XCJcblxuZXh0ZXJuYWwgYnl0ZXN0cmluZyA6IHN0cmluZyAtPiBqc19zdHJpbmcgdCA9IFwiY2FtbF9qc2J5dGVzX29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIHRvX2J5dGVzdHJpbmcgOiBqc19zdHJpbmcgdCAtPiBzdHJpbmcgPSBcImNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcIlxuXG5leHRlcm5hbCB0eXBlb2YgOiBfIHQgLT4ganNfc3RyaW5nIHQgPSBcImNhbWxfanNfdHlwZW9mXCJcblxuZXh0ZXJuYWwgaW5zdGFuY2VvZiA6IF8gdCAtPiBfIGNvbnN0ciAtPiBib29sID0gXCJjYW1sX2pzX2luc3RhbmNlb2ZcIlxuXG5sZXQgaXNOYU4gKGkgOiAnYSkgOiBib29sID1cbiAgdG9fYm9vbCAoVW5zYWZlLmZ1bl9jYWxsIFVuc2FmZS5nbG9iYWwjIy5pc05hTiBbfCBVbnNhZmUuaW5qZWN0IGkgfF0pXG5cbmxldCBwYXJzZUludCAocyA6IGpzX3N0cmluZyB0KSA6IGludCA9XG4gIGxldCBzID0gVW5zYWZlLmZ1bl9jYWxsIFVuc2FmZS5nbG9iYWwjIy5wYXJzZUludCBbfCBVbnNhZmUuaW5qZWN0IHMgfF0gaW5cbiAgaWYgaXNOYU4gcyB0aGVuIGZhaWx3aXRoIFwicGFyc2VJbnRcIiBlbHNlIHNcblxubGV0IHBhcnNlRmxvYXQgKHMgOiBqc19zdHJpbmcgdCkgOiBmbG9hdCA9XG4gIGxldCBzID0gVW5zYWZlLmZ1bl9jYWxsIFVuc2FmZS5nbG9iYWwjIy5wYXJzZUZsb2F0IFt8IFVuc2FmZS5pbmplY3QgcyB8XSBpblxuICBpZiBpc05hTiBzIHRoZW4gZmFpbHdpdGggXCJwYXJzZUZsb2F0XCIgZWxzZSBzXG5cbmxldCBfID1cbiAgUHJpbnRleGMucmVnaXN0ZXJfcHJpbnRlciAoZnVuY3Rpb25cbiAgICAgIHwgSnNfZXJyb3IuRXhuIGUgLT4gU29tZSAoSnNfZXJyb3IudG9fc3RyaW5nIGUpXG4gICAgICB8IF8gLT4gTm9uZSlcblxubGV0IF8gPVxuICBQcmludGV4Yy5yZWdpc3Rlcl9wcmludGVyIChmdW4gZSAtPlxuICAgICAgbGV0IGUgOiA8IC4uID4gdCA9IE9iai5tYWdpYyBlIGluXG4gICAgICBpZiBpbnN0YW5jZW9mIGUgYXJyYXlfY29uc3RydWN0b3IgdGhlbiBOb25lIGVsc2UgU29tZSAodG9fc3RyaW5nIGUjI3RvU3RyaW5nKSlcblxubGV0IGV4cG9ydF9qcyAoZmllbGQgOiBqc19zdHJpbmcgdCkgeCA9XG4gIFVuc2FmZS5zZXQgKFVuc2FmZS5wdXJlX2pzX2V4cHIgXCJqc29vX2V4cG9ydHNcIikgZmllbGQgeFxuXG5sZXQgZXhwb3J0IGZpZWxkIHggPSBleHBvcnRfanMgKHN0cmluZyBmaWVsZCkgeFxuXG5sZXQgZXhwb3J0X2FsbCBvYmogPVxuICBsZXQga2V5cyA9IG9iamVjdF9rZXlzIG9iaiBpblxuICBrZXlzIyNmb3JFYWNoXG4gICAgKHdyYXBfY2FsbGJhY2sgKGZ1biAoa2V5IDoganNfc3RyaW5nIHQpIF8gXyAtPiBleHBvcnRfanMga2V5IChVbnNhZmUuZ2V0IG9iaiBrZXkpKSlcblxuKCoqKiopXG5cbigqIERFUFJFQ0FURUQgKilcblxudHlwZSBmbG9hdF9wcm9wID0gZmxvYXQgcHJvcFxuXG5leHRlcm5hbCBmbG9hdCA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlaWRlbnRpdHlcIlxuXG5leHRlcm5hbCB0b19mbG9hdCA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlaWRlbnRpdHlcIlxuIiwiKCogSnNfb2Zfb2NhbWwgbGlicmFyeVxuICogaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbiAqIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuICogTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbiAqIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gKiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gKiBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuICopXG5cbm9wZW4gSnNcbm9wZW4hIEltcG9ydFxuXG5jbGFzcyB0eXBlIGNvbnNvbGUgPVxuICBvYmplY3RcbiAgICBtZXRob2QgbG9nIDogXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBsb2dfMiA6IF8gLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBsb2dfMyA6IF8gLT4gXyAtPiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGxvZ180IDogXyAtPiBfIC0+IF8gLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBsb2dfNSA6IF8gLT4gXyAtPiBfIC0+IF8gLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBsb2dfNiA6IF8gLT4gXyAtPiBfIC0+IF8gLT4gXyAtPiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGxvZ183IDogXyAtPiBfIC0+IF8gLT4gXyAtPiBfIC0+IF8gLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBsb2dfOCA6IF8gLT4gXyAtPiBfIC0+IF8gLT4gXyAtPiBfIC0+IF8gLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBkZWJ1ZyA6IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZGVidWdfMiA6IF8gLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBkZWJ1Z18zIDogXyAtPiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZGVidWdfNCA6IF8gLT4gXyAtPiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZGVidWdfNSA6IF8gLT4gXyAtPiBfIC0+IF8gLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBpbmZvIDogXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBpbmZvXzIgOiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgaW5mb18zIDogXyAtPiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgaW5mb180IDogXyAtPiBfIC0+IF8gLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBpbmZvXzUgOiBfIC0+IF8gLT4gXyAtPiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgd2FybiA6IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgd2Fybl8yIDogXyAtPiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHdhcm5fMyA6IF8gLT4gXyAtPiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHdhcm5fNCA6IF8gLT4gXyAtPiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgd2Fybl81IDogXyAtPiBfIC0+IF8gLT4gXyAtPiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGVycm9yIDogXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBlcnJvcl8yIDogXyAtPiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGVycm9yXzMgOiBfIC0+IF8gLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBlcnJvcl80IDogXyAtPiBfIC0+IF8gLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBlcnJvcl81IDogXyAtPiBfIC0+IF8gLT4gXyAtPiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGFzc2VydF8gOiBib29sIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgYXNzZXJ0XzEgOiBib29sIHQgLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBhc3NlcnRfMiA6IGJvb2wgdCAtPiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgYXNzZXJ0XzMgOiBib29sIHQgLT4gXyAtPiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgYXNzZXJ0XzQgOiBib29sIHQgLT4gXyAtPiBfIC0+IF8gLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBhc3NlcnRfNSA6IGJvb2wgdCAtPiBfIC0+IF8gLT4gXyAtPiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZGlyIDogXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBkaXJ4bWwgOiBEb20ubm9kZSB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHRyYWNlIDogdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZ3JvdXAgOiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGdyb3VwXzIgOiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZ3JvdXBfMyA6IF8gLT4gXyAtPiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGdyb3VwXzQgOiBfIC0+IF8gLT4gXyAtPiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGdyb3VwXzUgOiBfIC0+IF8gLT4gXyAtPiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZ3JvdXBDb2xsYXBzZWQgOiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGdyb3VwQ29sbGFwc2VkXzIgOiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZ3JvdXBDb2xsYXBzZWRfMyA6IF8gLT4gXyAtPiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGdyb3VwQ29sbGFwc2VkXzQgOiBfIC0+IF8gLT4gXyAtPiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGdyb3VwQ29sbGFwc2VkXzUgOiBfIC0+IF8gLT4gXyAtPiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZ3JvdXBFbmQgOiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB0aW1lIDoganNfc3RyaW5nIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdGltZUVuZCA6IGpzX3N0cmluZyB0IC0+IHVuaXQgbWV0aFxuICBlbmRcblxuZXh0ZXJuYWwgZ2V0X2NvbnNvbGUgOiB1bml0IC0+IGNvbnNvbGUgdCA9IFwiY2FtbF9qc19nZXRfY29uc29sZVwiXG5cbmxldCBjb25zb2xlID0gZ2V0X2NvbnNvbGUgKClcbiIsIigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5tb2R1bGUgRW51bSAgICA9IEJhdEVudW1cbm1vZHVsZSBNYXAgICAgID0gQmF0TWFwXG5tb2R1bGUgU2V0ICAgICA9IEJhdFNldFxubW9kdWxlIFVDaGFyICAgPSBCYXRVQ2hhclxubW9kdWxlIFVURjggICAgPSBCYXRVVEY4XG5tb2R1bGUgQklPICAgICA9IEJhdElPXG5tb2R1bGUgTGV4aW5nICA9IEJhdExleGluZ1xubW9kdWxlIFN0cmluZyAgPSBCYXRTdHJpbmdcblxuaW5jbHVkZSBCYXRQZXJ2YXNpdmVzXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5sZXQganNfbG9nIHMgPSBcbiAgSnNfb2Zfb2NhbWwuKEZpcmVidWcuY29uc29sZSMjbG9nIChKcy5zdHJpbmcgcykpXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5sZXQgZnN0X21hcCBmICh4LCB5KSA9IChmIHgsIHkpXG5sZXQgc25kX21hcCBmICh4LCB5KSA9ICh4LCBmIHkpXG5cbmxldCBwYWlyX21hcCBmICh4LCB5KSA9IChmIHgsIGYgeSlcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbmxldCAofD4+KSBmIGcgPSBmdW4geCAtPiBnIChmIHgpXG5sZXQgKDw8fCkgZiBnID0gZnVuIHggLT4gZiAoZyB4KVxuXG5sZXQgY3VycnkgICBmICh4LCB5KSA9IGYgeCB5XG5sZXQgdW5jdXJyeSBmIHggeSA9IGYgKHgsIHkpXG5cbmxldCAoXn4pIGYgPSBmdW4geCB5IC0+IGYgeSB4XG5cbmxldCAoLz4pICh4IDogJ2Egb3B0aW9uKSAoZiA6ICdhIC0+ICdiKSA9XG4gIEJhdE9wdGlvbi5tYXAgZiB4XG5cbmxldCB1ZXRhIChmIDogdW5pdCAtPiAnYSkgOiAnYiAtPiAnYSA9XG4gIGZ1biBfIC0+IGYgKClcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbm1vZHVsZSBPcHRpb24gOiBzaWdcbiAgaW5jbHVkZSBtb2R1bGUgdHlwZSBvZiBCYXRPcHRpb25cblxuICB2YWwgZm9sZCA6ICgnYSAtPiAnYiAtPiAnYSkgLT4gJ2EgLT4gJ2Igb3B0aW9uIC0+ICdhXG4gIHZhbCB0b19zdHJpbmcgOiAoJ2EgLT4gc3RyaW5nKSAtPiAnYSBvcHRpb24gLT4gc3RyaW5nXG5lbmQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBCYXRPcHRpb25cblxuICBsZXQgZm9sZCBmIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBOb25lICAgLT4gYWNjXG4gICAgfCBTb21lIHYgLT4gZiBhY2MgdlxuICBcbiAgbGV0IHRvX3N0cmluZyBwcCA9XG4gICAgbWFwX2RlZmF1bHQgcHAgXCJOb25lXCJcbmVuZFxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxubW9kdWxlIExpc3QgOiBzaWdcbiAgaW5jbHVkZSBtb2R1bGUgdHlwZSBvZiBCYXRMaXN0XG5cbiAgdmFsIG5zIDogaW50IC0+IGludCBsaXN0XG5cbiAgdmFsIGZzdCA6ICgnYSAqICdiKSBsaXN0IC0+ICdhIGxpc3RcbiAgdmFsIHNuZCA6ICgnYSAqICdiKSBsaXN0IC0+ICdiIGxpc3RcblxuICB2YWwgcG9wX2F0IDogaW50IC0+ICdhIGxpc3QgLT4gJ2EgKiAnYSBsaXN0XG4gIHZhbCBwb3BfYXNzb2MgOiAnYSAtPiAoJ2EgKiAnYikgbGlzdCAtPiAoJ2EgKiAnYikgbGlzdCAqICdiXG5cbiAgdmFsIGZpbmRleCA6ICgnYSAtPiBib29sKSAtPiAnYSBsaXN0IC0+IGludCBvcHRpb25cbiAgdmFsIGpvaW4gICA6ICdhIC0+ICdhIGxpc3QgLT4gJ2EgbGlzdFxuXG4gIHR5cGUgJ2EgcGl2b3QgPSAnYSBsaXN0ICogJ2EgKiAnYSBsaXN0XG5cbiAgdmFsIG9mX29wdGlvbiA6ICdhIG9wdGlvbiAtPiAnYSBsaXN0XG4gIHZhbCBwaXZvdCAgICAgOiAoJ2EgLT4gYm9vbCkgLT4gJ2EgbGlzdCAtPiAnYSBwaXZvdFxuICB2YWwgcGl2b3RpICAgIDogKGludCAtPiAnYSAtPiBib29sKSAtPiAnYSBsaXN0IC0+ICdhIHBpdm90XG4gIHZhbCBwaXZvdF9hdCAgOiBpbnQgLT4gJ2EgbGlzdCAtPiAnYSBwaXZvdFxuXG4gIGV4Y2VwdGlvbiBUb3BvRmFpbHVyZVxuXG4gIHZhbCB0b3BvIDogKCdhIC0+IGludCkgLT4gKCdhIC0+IGludCBsaXN0KSAtPiAnYSBsaXN0IC0+ICdhIGxpc3RcblxuICB2YWwgZmluZF9tYXBfb3B0IDogKCdhIC0+ICdiIG9wdGlvbikgLT4gJ2EgbGlzdCAtPiAnYiBvcHRpb25cblxuICB2YWwgaXNfcHJlZml4IDogJ2EgbGlzdCAtPiAnYSBsaXN0IC0+IGJvb2xcbiAgXG4gIHZhbCB0b19zdHJpbmcgOlxuICAgID9zZXAgOiBzdHJpbmcgLT4gP2xlZnQgOiBzdHJpbmcgLT4gP3JpZ2h0IDogc3RyaW5nIC0+XG4gICAgKCdhIC0+IHN0cmluZykgLT4gJ2EgbGlzdCAtPiBzdHJpbmcgXG5lbmQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBCYXRMaXN0XG5cbiAgbGV0IG5zIG4gPSBMaXN0LmluaXQgbiAoZnVuIGkgLT4gaSlcblxuICBsZXQgZnN0IHhzID0gTGlzdC5tYXAgZnN0IHhzXG4gIGxldCBzbmQgeHMgPSBMaXN0Lm1hcCBzbmQgeHNcbiAgXG4gIGxldCBwb3BfYXQgaSBsID1cbiAgICBsZXQgcmVjIGF1eCBhY2MgaSBsID1cbiAgICAgIG1hdGNoIGksIGwgd2l0aFxuICAgICAgfCAwLCB4IDo6IGwgLT4geCwgTGlzdC5yZXZfYXBwZW5kIGFjYyBsXG4gICAgICB8IF8sIHggOjogbCAtPiBhdXggKHggOjogYWNjKSAoaS0xKSBsXG4gICAgICB8IF8gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgaW4gYXV4IFtdIGkgbFxuXG4gIGxldCBwb3BfYXNzb2MgYSBsID1cbiAgICBsZXQgcmVjIGF1eCBhY2MgYSA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCAoYiwgeCkgOjogbCB3aGVuIGEgPSBiIC0+IExpc3QucmV2X2FwcGVuZCBhY2MgbCwgeFxuICAgICAgfCBpIDo6IGwgLT4gYXV4IChpIDo6IGFjYykgYSBsXG4gICAgaW4gYXV4IFtdIGEgbFxuXG4gIGxldCBmaW5kZXggKHR5cGUgYSkgKGNoZWNrIDogYSAtPiBib29sKSAoeHMgOiBhIGxpc3QpIDogaW50IG9wdGlvbiA9XG4gICAgbWF0Y2ggRXhjZXB0aW9ubGVzcy5maW5kaSAoZnVuIF8geCAtPiBjaGVjayB4KSB4cyB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmUgfCBTb21lIChpLCBfKSAtPiBTb21lIGlcblxuICBsZXQgam9pbiAoc2VwIDogJ2EpID1cbiAgICBsZXQgcmVjIGRvaXQgYWNjIHhzID1cbiAgICAgIG1hdGNoIHhzIHdpdGhcbiAgICAgIHwgW10gLT4gTGlzdC5yZXYgYWNjXG4gICAgICB8IHggOjogeHMgLT4gZG9pdCAoeCA6OiBzZXAgOjogYWNjKSB4c1xuICAgIGluIGZ1bmN0aW9uIChbXSB8IFtfXSkgYXMgeHMgLT4geHMgfCB4IDo6IHhzIC0+IGRvaXQgW3hdIHhzXG5cbiAgdHlwZSAnYSBwaXZvdCA9ICdhIGxpc3QgKiAnYSAqICdhIGxpc3RcblxuICBsZXQgb2Zfb3B0aW9uICh4IDogJ2Egb3B0aW9uKSA6ICdhIGxpc3QgPVxuICAgIG1hdGNoIHggd2l0aCBOb25lIC0+IFtdIHwgU29tZSB4IC0+IFt4XVxuXG4gIGxldCBwaXZvdGkgKGYgOiBpbnQgLT4gJ2EgLT4gYm9vbCkgPVxuICAgIGxldCByZWMgYXV4IGkgcHJlIHMgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICB8IFtdIC0+IGludmFsaWRfYXJnIFwiTGlzdC5waXZvdGlcIlxuICAgICAgfCB4IDo6IHMgLT5cbiAgICAgICAgICBpZiBmIGkgeCB0aGVuXG4gICAgICAgICAgICAoTGlzdC5yZXYgcHJlLCB4LCBzKVxuICAgICAgICAgIGVsc2UgYXV4IChpKzEpICh4IDo6IHByZSkgc1xuICAgIGluIGZ1biAocyA6ICdhIGxpc3QpIC0+IGF1eCAwIFtdIHNcblxuICBsZXQgcGl2b3QgKGYgOiAnYSAtPiBib29sKSAocyA6ICdhIGxpc3QpID1cbiAgICBwaXZvdGkgKGZ1biBfIC0+IGYpIHNcblxuICBsZXQgcGl2b3RfYXQgKGkgOiBpbnQpIChzIDogJ2EgbGlzdCkgPVxuICAgIHBpdm90aSAoZnVuIGogXyAtPiBpID0gaikgc1xuXG4gIGV4Y2VwdGlvbiBUb3BvRmFpbHVyZVxuXG4gIGxldCB0b3BvICh0eXBlIGEpIChrZXkgOiBhIC0+IGludCkgKGRlcHMgOiBhIC0+IGludCBsaXN0KSA9XG4gICAgbGV0IHJlYyBhdXggYWNjIGxhdGVyIHRvZG8gcHJvZ3Jlc3MgPVxuICAgICAgbWF0Y2ggdG9kbywgbGF0ZXIgd2l0aFxuICAgICAgfCBbXSwgW10gLT5cbiAgICAgICAgICBMaXN0LnJldiBhY2NcblxuICAgICAgfCBbXSwgXyAtPlxuICAgICAgICAgIGlmIG5vdCBwcm9ncmVzcyB0aGVuIHJhaXNlIFRvcG9GYWlsdXJlO1xuICAgICAgICAgIGF1eCBhY2MgW10gbGF0ZXIgZmFsc2VcblxuICAgICAgfCB4Ojp4cywgXyAtPlxuICAgICAgICBsZXQgb2sgPVxuICAgICAgICAgIExpc3QuZm9yX2FsbFxuICAgICAgICAgICAgKGZ1biBkZXAgLT4gZXhpc3RzIChmdW4geSAtPiBrZXkgeSA9IGRlcCkgYWNjKVxuICAgICAgICAgICAgKGRlcHMgeCkgaW5cblxuICAgICAgICBpZiAgIG9rXG4gICAgICAgIHRoZW4gYXV4ICh4OjphY2MpIGxhdGVyIHhzIHRydWVcbiAgICAgICAgZWxzZSBhdXggYWNjICh4OjpsYXRlcikgeHMgcHJvZ3Jlc3NcbiAgICBpblxuXG4gICAgZnVuICh4cyA6IGEgbGlzdCkgLT5cbiAgICAgIGxldCBzdGFydHMsIHRvZG8gPVxuICAgICAgICBMaXN0LnBhcnRpdGlvbiAoZnVuIHggLT4gaXNfZW1wdHkgKGRlcHMgeCkpIHhzXG4gICAgICBpbiBhdXggc3RhcnRzIFtdIHRvZG8gZmFsc2VcblxuICBsZXQgZmluZF9tYXBfb3B0IChmIDogJ2EgLT4gJ2Igb3B0aW9uKSA9XG4gICAgbGV0IHJlYyBkb2l0IHhzID1cbiAgICAgIG1hdGNoIHhzIHdpdGhcbiAgICAgIHwgW10gLT4gTm9uZVxuXG4gICAgICB8IHggOjogeHMgLT5cbiAgICAgICAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgICAgIHwgTm9uZSAgIC0+IGRvaXQgeHNcbiAgICAgICAgICB8IFNvbWUgdiAtPiBTb21lIHZcbiAgICBpbiBmdW4geHMgLT4gZG9pdCB4c1xuXG4gIGxldCByZWMgaXNfcHJlZml4ICh4cyA6ICdhIGxpc3QpIChwciA6ICdhIGxpc3QpID1cbiAgICBtYXRjaCB4cywgcHIgd2l0aFxuICAgIHwgXywgW10gLT4gdHJ1ZVxuICAgIHwgeCA6OiB4cywgeSA6OiBwciAtPiAoeCA9IHkpICYmIGlzX3ByZWZpeCB4cyBwclxuICAgIHwgXywgXyAtPiBmYWxzZVxuICAgIFxuICBsZXQgdG9fc3RyaW5nID8oc2VwID0gXCI7IFwiKSA/KGxlZnQgPSBcIltcIikgPyhyaWdodCA9IFwiXVwiKSBwcmludCA9XG4gICAgTGlzdC5tYXAgcHJpbnQgfD4+IFN0cmluZy5qb2luIHNlcCB8Pj4gZnVuIHMgLT4gbGVmdCBeIHMgXiByaWdodFxuZW5kXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5tb2R1bGUgQmlNYXAgOiBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgdmFsIGVtcHR5ICAgICAgIDogKCdhLCAnYikgdFxuXG4gIHZhbCBpbnZlcnNlICAgICA6ICgnYSwgJ2IpIHQgLT4gKCdiLCAnYSkgdFxuXG4gIHZhbCBhZGQgICAgICAgICA6ICdhIC0+ICdiIC0+ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdFxuICB2YWwgcmVtb3ZlICAgICAgOiAnYSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHRcblxuICB2YWwgZmluZCAgICAgICAgOiAnYSAtPiAoJ2EsICdiKSB0IC0+ICdiXG4gIHZhbCBmaW5kX29wdCAgICA6ICdhIC0+ICgnYSwgJ2IpIHQgLT4gJ2Igb3B0aW9uXG4gIFxuICB2YWwgZG9tYWluICAgICAgOiAoJ2EsICdiKSB0IC0+ICdhIGxpc3RcbiAgdmFsIGNvZG9tYWluICAgIDogKCdhLCAnYikgdCAtPiAnYiBsaXN0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTWFwLnQgKiAoJ2IsICdhKSBNYXAudFxuICBcbiAgbGV0IGVtcHR5ID1cbiAgICBNYXAuZW1wdHksIE1hcC5lbXB0eVxuXG4gIGxldCBpbnZlcnNlIChyLCBsKSA9XG4gICAgKGwsIHIpXG4gIFxuICBsZXQgYWRkIGsgdiAociwgbCkgPVxuICAgIE1hcC5hZGQgayB2IHIsIE1hcC5hZGQgdiBrIGxcbiAgXG4gIGxldCByZW1vdmUgayAociwgbCkgPVxuICAgIGxldCB2ID0gTWFwLmZpbmQgayByIGluXG4gICAgTWFwLnJlbW92ZSBrIHIsIE1hcC5yZW1vdmUgdiBsXG4gIFxuICBsZXQgZmluZCBrIChyLCBfKSA9XG4gICAgTWFwLmZpbmQgayByXG5cbiAgbGV0IGZpbmRfb3B0IGsgKHIsIF8pID1cbiAgICBNYXAuZmluZF9vcHQgayByXG4gIFxuICBsZXQgZG9tYWluIChyLCBfKSA9XG4gICAgTWFwLmtleXMgciB8PiBMaXN0Lm9mX2VudW1cblxuICBsZXQgY29kb21haW4gKF8sIGwpID1cbiAgICBNYXAua2V5cyBsIHw+IExpc3Qub2ZfZW51bVxuZW5kXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG50eXBlIHVpZCA9IGludFxuXG5tb2R1bGUgVWlkIDogc2lnXG4gIHZhbCBmcmVzaCA6IHVuaXQgLT4gdWlkXG5lbmQgPSBzdHJ1Y3RcbiAgbGV0IGZyZXNoIDogdW5pdCAtPiB1aWQgPSAgICAgKCogbm90IG10LXNhZmUgKilcbiAgICBsZXQgY291bnQgPSByZWYgKC0xKSBpblxuICAgIGZ1biAoKSAtPiBpbmNyIGNvdW50OyAhY291bnRcbmVuZFxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxubW9kdWxlIERpc3Bvc2FibGUgOiBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgZXhjZXB0aW9uIERpc3Bvc2VkXG5cbiAgdmFsIGNyZWF0ZSAgOiA/Y2I6KCdhIC0+IHVuaXQpIC0+ICdhIC0+ICdhIHRcbiAgdmFsIGdldCAgICAgOiAnYSB0IC0+ICdhXG4gIHZhbCBkaXNwb3NlIDogJ2EgdCAtPiB1bml0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gKCgoJ2EgLT4gdW5pdCkgb3B0aW9uICogJ2EpIG9wdGlvbikgcmVmXG5cbiAgZXhjZXB0aW9uIERpc3Bvc2VkXG5cbiAgbGV0IGdldCAocCA6ICdhIHQpID1cbiAgICBtYXRjaCAhcCB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIERpc3Bvc2VkXG4gICAgfCBTb21lIChfLCB4KSAtPiB4XG5cbiAgbGV0IGRpc3Bvc2UgKHAgOiAnYSB0KSA9XG4gICAgbGV0IGRvX2Rpc3Bvc2UgcCA9XG4gICAgICBtYXRjaCBwIHdpdGhcbiAgICAgIHwgU29tZSAoU29tZSBjYiwgeCkgLT4gY2IgeFxuICAgICAgfCBfIC0+ICgpXG4gICAgaW5cblxuICAgIGxldCBvbGRwID0gIXAgaW5cbiAgICAgIHAgOj0gTm9uZTsgZG9fZGlzcG9zZSBvbGRwXG5cbiAgbGV0IGNyZWF0ZSA/KGNiIDogKCdhIC0+IHVuaXQpIG9wdGlvbikgKHggOiAnYSkgPVxuICAgIGxldCByID0gcmVmIChTb21lIChjYiwgeCkpIGluXG4gICAgR2MuZmluYWxpc2UgKGZ1biByIC0+IGRpc3Bvc2UgcikgcjsgclxuZW5kXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbm1vZHVsZSBUZXh0IDogc2lnXG4gIHZhbCBzcGFjZWQgOiA/bGVmdDpib29sIC0+ID9yaWdodDpib29sIC0+IHN0cmluZyAtPiBzdHJpbmdcbiAgdmFsIHByICAgICA6ID9kb2l0OmJvb2wgLT4gc3RyaW5nIC0+IHN0cmluZ1xuZW5kID0gc3RydWN0XG4gIGxldCBwciA/KGRvaXQgPSB0cnVlKSBjID1cbiAgICBpZiBkb2l0IHRoZW4gRm9ybWF0LnNwcmludGYgXCIoJXMpXCIgYyBlbHNlIGNcblxuICBsZXQgc3BhY2VkID8obGVmdCA9IHRydWUpID8ocmlnaHQgPSB0cnVlKSBjID1cbiAgICBGb3JtYXQuc3ByaW50ZiBcIiVzJXMlc1wiXG4gICAgICAoaWYgbGVmdCB0aGVuIFwiIFwiIGVsc2UgXCJcIikgYyAoaWYgcmlnaHQgdGhlbiBcIiBcIiBlbHNlIFwiXCIpXG5lbmRcblxub3BlbiBUeXhtbFxubW9kdWxlIEh0bWwgOiBzaWdcbiAgdmFsIHNwYW4gOiA/YTpYbWwuYXR0cmliIGxpc3QgLT4gWG1sLmVsdCBsaXN0IC0+IFhtbC5lbHRcblxuICB2YWwgc3BhY2VkIDogP2xlZnQ6Ym9vbCAtPiA/cmlnaHQ6Ym9vbCAtPiBYbWwuZWx0IGxpc3QgLT4gWG1sLmVsdCBsaXN0XG4gIHZhbCBwciAgICAgOiA/ZG9pdDpib29sIC0+IFhtbC5lbHQgbGlzdCAtPiBYbWwuZWx0IGxpc3RcbmVuZCA9IHN0cnVjdFxuICBsZXQgc3BhbiA/YSA9IFhtbC5ub2RlID9hIFwic3BhblwiXG5cbiAgbGV0IHNwYWNlZCA/KGxlZnQgPSB0cnVlKSA/KHJpZ2h0ID0gdHJ1ZSkgYyA9XG4gICAgbGV0IHNwID0gW3NwYW4gW1htbC5lbnRpdHkgXCJuYnNwXCJdXSBpblxuICAgIGxldCBjID0gaWYgbGVmdCAgdGhlbiBzcCBAIGMgZWxzZSBjIGluXG4gICAgbGV0IGMgPSBpZiByaWdodCB0aGVuIGMgQCBzcCBlbHNlIGMgaW5cbiAgICBjXG5cbiAgbGV0IHByID8oZG9pdCA9IHRydWUpIGMgPVxuICAgIGxldCBsID0gW3NwYW4gW1htbC5wY2RhdGEgXCIoXCJdXSBpblxuICAgIGxldCByID0gW3NwYW4gW1htbC5wY2RhdGEgXCIpXCJdXSBpblxuICAgIGlmIGRvaXQgdGhlbiBsIEAgYyBAIHIgZWxzZSBjXG5lbmRcblxubW9kdWxlIE1hdGhtbCA6IHNpZ1xuICB2YWwgbWF0aCAgIDogP2E6WG1sLmF0dHJpYiBsaXN0IC0+IFhtbC5lbHQgbGlzdCAtPiBYbWwuZWx0XG4gIHZhbCByb3cgICAgOiA/YTpYbWwuYXR0cmliIGxpc3QgLT4gWG1sLmVsdCBsaXN0IC0+IFhtbC5lbHRcblxuICB2YWwgbW8gICAgIDogc3RyaW5nIC0+IFhtbC5lbHRcbiAgdmFsIG1pICAgICA6IHN0cmluZyAtPiBYbWwuZWx0XG4gIHZhbCBtbiAgICAgOiBzdHJpbmcgLT4gWG1sLmVsdFxuXG4gIHZhbCBzcGFjZWQgOiA/bGVmdDpib29sIC0+ID9yaWdodDpib29sIC0+IFhtbC5lbHQgbGlzdCAtPiBYbWwuZWx0IGxpc3RcbiAgdmFsIHByICAgICA6ID9kb2l0OmJvb2wgLT4gWG1sLmVsdCAtPiBYbWwuZWx0XG5lbmQgPSBzdHJ1Y3RcbiAgbGV0IG1hdGggP2EgPSBYbWwubm9kZSA/YSBcIm1hdGhcIlxuICBsZXQgcm93ID9hID0gWG1sLm5vZGUgP2EgXCJtcm93XCJcbiAgXG4gIGxldCBtbyBjID0gWG1sLm5vZGUgXCJtb1wiIFtYbWwucGNkYXRhIGNdXG4gIGxldCBtaSBjID0gWG1sLm5vZGUgXCJtaVwiIFtYbWwucGNkYXRhIGNdXG4gIGxldCBtbiBjID0gWG1sLm5vZGUgXCJtblwiIFtYbWwucGNkYXRhIGNdXG4gIFxuICBsZXQgc3BhY2VkID8obGVmdCA9IHRydWUpID8ocmlnaHQgPSB0cnVlKSBjID1cbiAgICBsZXQgc3AgPSBbWG1sLm5vZGUgXCJtb1wiIFtYbWwuZW50aXR5IFwibmJzcFwiXV0gaW5cbiAgICBsZXQgYyA9IGlmIGxlZnQgIHRoZW4gc3AgQCBjIGVsc2UgYyBpblxuICAgIGxldCBjID0gaWYgcmlnaHQgdGhlbiBjIEAgc3AgZWxzZSBjIGluXG4gICAgY1xuXG4gIGxldCBwciA/KGRvaXQgPSB0cnVlKSBjID1cbiAgICBpZiBkb2l0IHRoZW4gcm93IFttbyBcIihcIjsgYzsgbW8gXCIpXCJdIGVsc2UgY1xuZW5kIiwiXG4oKiogVXNlZnVsIG1vbmFkcyAqKVxuXG5vcGVuIFV0aWxzXG5cbm1vZHVsZSB0eXBlIFR5cGUgPSBzaWcgdHlwZSB0IGVuZFxuXG4oKiogQmFzaWMgbW9uYWQgKilcblxubW9kdWxlIHR5cGUgQ29yZSA9IHNpZ1xuICB0eXBlICdhIHRcbiAgdmFsIHJldHVybiA6ICdhIC0+ICdhIHRcbiAgdmFsIGJpbmQgOiAnYSB0IC0+ICgnYSAtPiAnYiB0KSAtPiAnYiB0XG4gIHZhbCAoID4+PSApIDogJ2EgdCAtPiAoJ2EgLT4gJ2IgdCkgLT4gJ2IgdFxuICB2YWwgKCBsZXQqICkgOiAnYSB0IC0+ICgnYSAtPiAnYiB0KSAtPiAnYiB0XG5lbmRcblxuKCoqIEJhc2ljIG1vbmFkIHdpdGggYW4gYWRkaXRpb25hbCBtb25vaWQgc3RydWN0dXJlICopXG5cbm1vZHVsZSB0eXBlIFBsdXMgPSBzaWdcbiAgaW5jbHVkZSBDb3JlXG4gIHZhbCB6ZXJvIDogJ2EgdFxuICB2YWwgKCArICkgOiAnYSB0IC0+ICdhIHQgLT4gJ2EgdFxuZW5kXG5cbigqKiBCYXNpYyBtb25hZCB3aXRoIGFuIGFkZGl0aW9uYWwgZW52aXJvbm1lbnQgdHlwZSAqKVxuXG5tb2R1bGUgdHlwZSBFbnYgPSBzaWdcbiAgaW5jbHVkZSBDb3JlXG4gIHR5cGUgZW52XG5lbmRcblxuKCoqIFJlYWRlciBtb25hZCB0byBjYXJyeSBzb21lIGVudmlyb25tZW50IGluIHJlYWQtb25seSBtb2RlICopXG5cbm1vZHVsZSBSZWFkZXIgKFQgOiBUeXBlKSA6IHNpZ1xuICBpbmNsdWRlIEVudiB3aXRoIHR5cGUgJ2EgdCA9IFQudCAtPiAnYVxuXG4gICgqIE1vbmFkaWMgdmVyc2lvbiBvZiBMaXN0Lm1hcCAqKVxuICB2YWwgbWFwIDogKCdhIC0+ICdiIHQpIC0+ICdhIGxpc3QgLT4gJ2IgbGlzdCB0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSBlbnYgPSBULnRcbiAgdHlwZSAnYSB0ID0gZW52IC0+ICdhXG4gIGxldCByZXR1cm4geCA9IGZ1biBfc3QgLT4geFxuICBsZXQgYmluZCBtIGYgPSBmdW4gc3QgLT4gZiAobSBzdCkgc3RcbiAgbGV0ICggPj49ICkgPSBiaW5kXG4gIGxldCAoIGxldCogKSA9IGJpbmRcbiAgbGV0IG1hcCBmIGwgPSBmdW4gc3QgLT5cbiAgICBMaXN0Lm1hcCAoZnVuIHggLT4gZiB4IHN0KSBsXG5lbmRcblxuKCoqIFN0YXRlIG1vbmFkIHRvIGNhcnJ5IHNvbWUgZW52aXJvbm1lbnQgaW4gcmVhZC13cml0ZSBtb2RlICopXG5cbm1vZHVsZSBTdGF0ZSAoVCA6IFR5cGUpIDogc2lnXG4gIGluY2x1ZGUgRW52IHdpdGggdHlwZSAnYSB0ID0gVC50IC0+ICdhICogVC50XG5cbiAgKCogTW9uYWRpYyB2ZXJzaW9uIG9mIExpc3QuaXRlciBhbmQgTGlzdC5mb2xkX2xlZnQgKilcbiAgdmFsIGZvbGQgOiAoJ2EgLT4gJ2IgLT4gJ2EgdCkgLT4gJ2EgLT4gJ2IgbGlzdCAtPiAnYSB0XG4gIHZhbCBpdGVyIDogKCdhIC0+IHVuaXQgdCkgLT4gJ2EgbGlzdCAtPiB1bml0IHRcblxuICB2YWwgZ2V0IDogVC50IHRcbiAgdmFsIHB1dCA6IFQudCAtPiB1bml0IHRcbiAgdmFsIHJ1biA6ICdhIHQgLT4gVC50IC0+ICdhXG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSBlbnYgPSBULnRcbiAgdHlwZSAnYSB0ID0gZW52IC0+ICdhICogZW52XG4gIGxldCByZXR1cm4geCA9IGZ1biBzdCAtPiB4LCBzdFxuICBsZXQgYmluZCBtIGYgPSBmdW4gc3QgLT5cbiAgICBsZXQgeCwgc3QnID0gbSBzdCBpblxuICAgIGYgeCBzdCdcbiAgbGV0ICggPj49ICkgPSBiaW5kXG4gIGxldCAoIGxldCogKSA9IGJpbmRcbiAgbGV0IGZvbGQgZiB4IGwgPSBmdW4gc3QgLT5cbiAgICBMaXN0LmZvbGRfbGVmdFxuICAgICAgKGZ1biAoeCwgc3QpIHkgLT4gZiB4IHkgc3QpXG4gICAgICAoeCwgc3QpIGxcbiAgbGV0IGl0ZXIgZiBsID0gZm9sZCAoZnVuIF8geSAtPiBmIHkpICgpIGxcbiAgbGV0IGdldCA9IGZ1biBzdCAtPiAoc3QsIHN0KVxuICBsZXQgcHV0IHN0ID0gZnVuIF8gLT4gKCgpLCBzdClcbiAgbGV0IHJ1biBtID0gbSB8Pj4gZnN0XG5lbmRcblxuKCoqIExpc3QgbW9uYWQgdG8gaW1wbGVtZW50IGxpc3QgY29tcHJlaGVuc2lvbiAqKVxuXG5tb2R1bGUgTGlzdCA6IFBsdXNcbiAgd2l0aCB0eXBlICdhIHQgPSAnYSBsaXN0ID1cbnN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBsaXN0XG4gIGxldCByZXR1cm4geCA9IFt4XVxuICBsZXQgYmluZCBtIGYgPSAgTGlzdC5jb25jYXQgKExpc3QubWFwIGYgbSlcbiAgbGV0ICggPj49ICkgPSBiaW5kXG4gIGxldCAoIGxldCogKSA9IGJpbmRcbiAgbGV0IHplcm8gPSBbXVxuICBsZXQgKCArICkgPSAoIEAgKVxuZW5kXG5cbm1vZHVsZSBPcHRpb24gOiBzaWdcbiAgaW5jbHVkZSBDb3JlIHdpdGggdHlwZSAnYSB0ID0gJ2Egb3B0aW9uXG5cbiAgdmFsIGZvbGQgICAgICAgOiAoJ2EgLT4gJ2IgLT4gJ2EpIC0+ICdhIC0+ICdiIHQgLT4gJ2FcbiAgdmFsIGNvbmNhdCAgICAgOiAnYSB0IHQgLT4gJ2EgdFxuICB2YWwgY29uY2F0X21hcCA6ICgnYSAtPiAnYiB0KSAtPiAnYSB0IC0+ICdiIHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBvcHRpb25cblxuICBsZXQgZm9sZCBmIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBOb25lICAgLT4gYWNjXG4gICAgfCBTb21lIHYgLT4gZiBhY2MgdlxuICBcbiAgbGV0IGNvbmNhdCA9IGZ1bmN0aW9uXG4gICAgfCBTb21lIChTb21lIHgpIC0+IFNvbWUgeFxuICAgIHwgXyAtPiBOb25lXG4gIFxuICBsZXQgY29uY2F0X21hcCBmIHggPVxuICAgIE9wdGlvbi4oY29uY2F0IChtYXAgZiB4KSlcbiAgXG4gIGxldCByZXR1cm4geCA9XG4gICAgU29tZSB4XG4gIFxuICBsZXQgYmluZCB4IGYgPVxuICAgIGNvbmNhdF9tYXAgZiB4XG5cbiAgbGV0ICggPj49ICkgPVxuICAgIGJpbmRcbiAgXG4gIGxldCAoIGxldCogKSA9XG4gICAgYmluZFxuZW5kIiwiJXtcbiAgb3BlbiBMb2NhdGlvblxuICBvcGVuIFN5bnRheFxuJX1cblxuJXRva2VuIDxTeW50YXguc3ltYm9sPiBJREVOVFxuJXRva2VuIDxpbnQ+IE5BVFxuXG4ldG9rZW4gTFBBUkVOIFJQQVJFTlxuJXRva2VuIExCUkFDRSBSQlJBQ0VcbiV0b2tlbiBUUlVFXG4ldG9rZW4gRVhJU1RTXG4ldG9rZW4gRkFMU0VcbiV0b2tlbiBGT1JBTExcbiV0b2tlbiBSRUNcbiV0b2tlbiBUWVBFXG4ldG9rZW4gTEFSUk9XXG4ldG9rZW4gTFJBUlJPV1xuJXRva2VuIEVPRlxuJXRva2VuIFBST09GXG5cbiV0b2tlbiBMQU5EIExPUiBMTkVHIFBMVVMgU1RBUlxuJXRva2VuIEFNUCBEQ09MT04gQ09MT04gRVEgQ09MT05FUSBDT01NQSBET1QgU0VNSUNPTE9OXG5cbiVub25hc3NvYyBCSU5ESU5HX3ByZWNcbiVyaWdodCAgICBMQVJST1cgTFJBUlJPV1xuJW5vbmFzc29jIFJFQ19wcmVjXG4lbGVmdCAgICAgTE9SICBQTFVTXG4lbGVmdCAgICAgTEFORCBTVEFSXG4lbGVmdCAgICAgTE5FR1xuXG4ldHlwZSA8U3ludGF4LnB0eXBlID4geHR5cGVcbiV0eXBlIDxTeW50YXgucGV4cHIgPiB4ZXhwclxuJXR5cGUgPFN5bnRheC5wbmV4cHI+IHhuZXhwclxuJXR5cGUgPFN5bnRheC5wZm9ybSA+IHhmb3JtXG4ldHlwZSA8U3ludGF4LnBnb2FsID4geGdvYWxcblxuJXN0YXJ0IHh0eXBlXG4lc3RhcnQgeGV4cHJcbiVzdGFydCB4bmV4cHJcbiVzdGFydCB4Zm9ybVxuJXN0YXJ0IHhnb2FsXG4lJVxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxueHR5cGU6XG58IGVycm9yXG4gICAgeyByYWlzZSAoUGFyc2VFcnJvciAoU29tZSAoTG9jYXRpb24ubWFrZSAkc3RhcnRwb3MgJGVuZHBvcyksIE5vbmUpKSB9XG5cbnwgdD10eXBlXyBFT0YgeyB0IH1cblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbnhleHByOlxufCBlcnJvclxuICAgIHsgcmFpc2UgKFBhcnNlRXJyb3IgKFNvbWUgKExvY2F0aW9uLm1ha2UgJHN0YXJ0cG9zICRlbmRwb3MpLCBOb25lKSkgfVxuXG58IGU9ZXhwciBFT0YgeyBlIH1cblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbnhuZXhwcjpcbnwgZXJyb3JcbiAgICB7IHJhaXNlIChQYXJzZUVycm9yIChTb21lIChMb2NhdGlvbi5tYWtlICRzdGFydHBvcyAkZW5kcG9zKSwgTm9uZSkpIH1cblxufCBlPW5leHByIEVPRiB7IGUgfVxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxueGZvcm06XG58IGVycm9yXG4gICB7IHJhaXNlIChQYXJzZUVycm9yIChTb21lIChMb2NhdGlvbi5tYWtlICRzdGFydHBvcyAkZW5kcG9zKSwgTm9uZSkpIH1cblxufCBmPWZvcm0gRU9GIHsgZiB9XG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG54Z29hbDpcbnwgZXJyb3JcbiAgIHsgcmFpc2UgKFBhcnNlRXJyb3IgKFNvbWUgKExvY2F0aW9uLm1ha2UgJHN0YXJ0cG9zICRlbmRwb3MpLCBOb25lKSkgfVxuXG58IHA9Z29hbCBFT0YgeyBwIH1cblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbiVpbmxpbmUgaWRlbnQ6IHg9bG9jKElERU5UKSB7IHggfVxuXG50eWlkZW50OlxufCB4PWlkZW50IENPTE9OIHR5PXR5cGVfIHsgKHgsIHR5KSB9XG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG50eXBlX3I6XG58IHQ9cGFyZW5zKHR5cGVfcilcbiAgICB7IHQgfVxuXG58IHBhcmVucyhlbXB0eSlcbiAgICB7IFBUVW5pdCB9XG5cbnwgeD1pZGVudFxuICAgIHsgUFRWYXIgeCB9XG5cbnwgdDE9dHlwZV8gUExVUyB0Mj10eXBlX1xuICAgIHsgUFRTdW0gKHQxLCB0MikgfVxuXG58IHQxPXR5cGVfIFNUQVIgdDI9dHlwZV9cbiAgICB7IFBUUHJvZCAodDEsIHQyKSB9XG5cbnwgUkVDIHg9aWRlbnQgRE9UIHQ9dHlwZV8gJXByZWMgUkVDX3ByZWNcbiAgICB7IFBUUmVjICh4LCB0KSB9XG5cbnR5cGVfOlxufCB0PWxvYyh0eXBlX3IpIHsgdCB9XG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG51bnBhcmVuc19leHByX3I6XG58IHg9aWRlbnRcbiAgICB7IFBFVmFyICh4LCAwKSB9XG5cbnwgeD1pZGVudCBMQlJBQ0UgaT1OQVQgUkJSQUNFXG4gICAgeyBQRVZhciAoeCwgaSkgfVxuXG58IGY9aWRlbnQgcGFyZW5zKGVtcHR5KVxuICAgIHsgUEVBcHAgKGYsIFtdKSB9XG5cbnwgZj1pZGVudCBhcmdzPXBhcmVucyhwbGlzdDEoZXhwciwgQ09NTUEpKVxuICAgIHsgUEVBcHAgKGYsIGFyZ3MpIH1cblxuZXhwcl9yOlxufCBlPXVucGFyZW5zX2V4cHJfclxuICAgIHsgZSB9XG58IGU9cGFyZW5zKGV4cHJfcilcbiAgICB7IGUgfVxuXG51bnBhcmVuc19leHByOlxufCBlPWxvYyh1bnBhcmVuc19leHByX3IpIHsgZSB9XG5cbmV4cHI6XG58IGU9bG9jKGV4cHJfcikgeyBlIH1cblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbm5leHByOlxufCB4PWlkZW50IENPTE9ORVEgZT1leHByIHsgKHgsIGUpIH1cblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbmZvcm1fcjpcbnwgZj1wYXJlbnMoZm9ybV9yKVxuICAgIHsgZiB9XG5cbnwgVFJVRVxuICAgeyBQRkNzdCB0cnVlIH1cblxufCBGQUxTRVxuICAgeyBQRkNzdCBmYWxzZSB9XG5cbnwgeD1pZGVudFxuICAgIHsgUEZBcHAgKHgsIFtdKSB9XG5cbnwgZTE9dW5wYXJlbnNfZXhwciBFUSBlMj11bnBhcmVuc19leHByXG4gICAgeyBQRkFwcCAobWtsb2MgX2R1bW15IFwiX0VRXCIsIFtlMTsgZTJdKSB9XG5cbnwgeD1pZGVudCBhcmdzPXBhcmVucyhwbGlzdDEoZXhwciwgQ09NTUEpKVxuICAgIHsgUEZBcHAgKHgsIGFyZ3MpIH1cblxufCBmMT1mb3JtIExBTkQgZjI9Zm9ybVxuICAgIHsgUEZBbmQgKGYxLCBmMikgfVxuXG58IGYxPWZvcm0gTE9SIGYyPWZvcm1cbiAgICB7IFBGT3IgKGYxLCBmMikgfVxuXG58IGYxPWZvcm0gTEFSUk9XIGYyPWZvcm1cbiAgICB7IFBGSW1wIChmMSwgZjIpIH1cblxufCBmMT1mb3JtIExSQVJST1cgZjI9Zm9ybVxuICAgIHsgUEZFcXVpdiAoZjEsIGYyKSB9XG5cbnwgTE5FRyBmPWZvcm1cbiAgICB7IFBGTm90IGYgfVxuXG58IEZPUkFMTCB4dHk9dHlpZGVudCBET1QgZj1mb3JtICVwcmVjIEJJTkRJTkdfcHJlY1xuICAgIHsgUEZGb3JhbGwgKHh0eSwgZikgfVxuXG58IEVYSVNUUyB4dHk9dHlpZGVudCBET1QgZj1mb3JtICVwcmVjIEJJTkRJTkdfcHJlY1xuICAgIHsgUEZFeGlzdHMgKHh0eSwgZikgfVxuXG5mb3JtOlxufCBmPWxvYyhmb3JtX3IpIHsgZiB9XG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG4laW5saW5lIGFyaXR5OlxufCB0eXM9cGxpc3QwKHR5cGVfLCBBTVApXG4gICAgeyB0eXMgfVxuXG5zaWduYXR1cmU6XG58IGFyPWFyaXR5IExBUlJPVyB0eT10eXBlX1xuICAgIHsgKGFyLCB0eSkgfVxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuZW50cnk6XG58IHg9aWRlbnRcbiAgICB7IFBQcm9wICh4LCBbXSkgfVxuXG58IHg9aWRlbnQgRENPTE9OIHh0eT1hcml0eVxuICAgIHsgUFByb3AgKHgsIHh0eSkgfVxuXG58IHg9aWRlbnQgQ09MT04geHR5PXNpZ25hdHVyZVxuICAgIHsgUEZ1biAoeCwgeHR5KSB9XG5cbnwgeD1pZGVudCBDT0xPTiB4dHk9dHlwZV9cbiAgICB7IFBWYXIgKHgsIHh0eSkgfVxuXG58IHg9aWRlbnQgQ09MT05FUSBib2R5PWV4cHJcbiAgICB7IFBFeHByICh4LCBib2R5KSB9XG5cbnwgVFlQRSBhPWlkZW50XG4gICAgeyBQVFZhciBhIH1cblxufCBUWVBFIGE9aWRlbnQgQ09MT05FUSB0PXR5cGVfXG4gICAgeyBQVHlwZSAoYSwgdCkgfVxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuZ29hbDpcbnwgcHM9cGxpc3QwKGVudHJ5LCBDT01NQSkgaHM9b3B0aW9uKHByZWNlZGVkKFNFTUlDT0xPTiwgcGxpc3QwKGZvcm0sIENPTU1BKSkpIFBST09GIGY9Zm9ybVxuICAgIHsgKHBzLCBCYXRPcHRpb24uZGVmYXVsdCBbXSBocywgZikgfVxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuJWlubGluZSBsb2MoWCk6XG58IHg9WCB7XG4gICAgeyBwbGRlc2MgPSB4O1xuICAgICAgcGxsb2MgID0gTG9jYXRpb24ubWFrZSAkc3RhcnRwb3MgJGVuZHBvcztcbiAgICB9XG4gIH1cblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbiVpbmxpbmUgZW1wdHk6XG58ICgqIGVtcHR5ICopIHsgKCkgfVxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuJWlubGluZSBwYXJlbnMoWCk6XG58IExQQVJFTiB4PVggUlBBUkVOIHsgeCB9XG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG4laW5saW5lIHBsaXN0MChYLCBTKTpcbnwgYW91dD1zZXBhcmF0ZWRfbGlzdChTLCBYKSB7IGFvdXQgfVxuXG5pcGxpc3QxX3IoWCwgUyk6XG58IHg9WCB7IFt4XSB9XG58IHhzPWlwbGlzdDFfcihYLCBTKSBTIHg9WCB7IHggOjogeHMgfVxuXG4laW5saW5lIGlwbGlzdDEoWCwgUyk6XG58IHhzPWlwbGlzdDFfcihYLCBTKSB7IExpc3QucmV2IHhzIH1cblxuJWlubGluZSBwbGlzdDEoWCwgUyk6XG58IGFvdXQ9c2VwYXJhdGVkX25vbmVtcHR5X2xpc3QoUywgWCkgeyBhb3V0IH1cblxuJWlubGluZSBwbGlzdDIoWCwgUyk6XG58IHg9WCBTIHhzPXBsaXN0MShYLCBTKSB7IHggOjogeHMgfVxuXG4laW5saW5lIGxpc3QyKFgpOlxufCB4PVggeHM9WCsgeyB4IDo6IHhzIH1cbiIsIigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5vcGVuIFV0aWxzXG5cbm1vZHVsZSBQID0gUGFyc2VyXG5tb2R1bGUgTCA9IExleGluZ1xuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxubGV0IGxleGJ1Zl9mcm9tX2NoYW5uZWwgPSBmdW4gbmFtZSBjaGFubmVsIC0+XG4gIGxldCBsZXhidWYgPSBMZXhpbmcuZnJvbV9jaGFubmVsIGNoYW5uZWwgaW5cbiAgICBsZXhidWYuTGV4aW5nLmxleF9jdXJyX3AgPC0ge1xuICAgICAgICBMZXhpbmcucG9zX2ZuYW1lID0gbmFtZTtcbiAgICAgICAgTGV4aW5nLnBvc19sbnVtICA9IDE7XG4gICAgICAgIExleGluZy5wb3NfYm9sICAgPSAwO1xuICAgICAgICBMZXhpbmcucG9zX2NudW0gID0gMFxuICAgICAgfTtcbiAgICBsZXhidWZcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbmxldCBwYXJzZXJmdW5fdHlwZSA9XG4gIE1lbmhpckxpYi5Db252ZXJ0LlNpbXBsaWZpZWQudHJhZGl0aW9uYWwycmV2aXNlZCBQLnh0eXBlXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5sZXQgcGFyc2VyZnVuX2V4cHIgPVxuICAgIE1lbmhpckxpYi5Db252ZXJ0LlNpbXBsaWZpZWQudHJhZGl0aW9uYWwycmV2aXNlZCBQLnhleHByXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5sZXQgcGFyc2VyZnVuX25leHByID1cbiAgICBNZW5oaXJMaWIuQ29udmVydC5TaW1wbGlmaWVkLnRyYWRpdGlvbmFsMnJldmlzZWQgUC54bmV4cHJcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbmxldCBwYXJzZXJmdW5fZm9ybSA9XG4gICAgTWVuaGlyTGliLkNvbnZlcnQuU2ltcGxpZmllZC50cmFkaXRpb25hbDJyZXZpc2VkIFAueGZvcm1cblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbmxldCBwYXJzZXJmdW5fZ29hbCA9XG4gICAgTWVuaGlyTGliLkNvbnZlcnQuU2ltcGxpZmllZC50cmFkaXRpb25hbDJyZXZpc2VkIFAueGdvYWxcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbnR5cGUgcmVhZGVyID0gTGV4aW5nLmxleGJ1ZiBEaXNwb3NhYmxlLnRcblxubGV0IGxleGJ1ZiAocmVhZGVyIDogcmVhZGVyKSA9XG4gIERpc3Bvc2FibGUuZ2V0IHJlYWRlclxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxubGV0IGZyb21fY2hhbm5lbCB+bmFtZSBjaGFubmVsID1cbiAgbGV0IGxleGJ1ZiA9IGxleGJ1Zl9mcm9tX2NoYW5uZWwgbmFtZSBjaGFubmVsIGluXG4gIERpc3Bvc2FibGUuY3JlYXRlIGxleGJ1ZlxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxubGV0IGZyb21fZmlsZSBmaWxlbmFtZSA9XG4gIGxldCBjaGFubmVsID0gb3Blbl9pbiBmaWxlbmFtZSBpblxuXG4gIHRyeVxuICAgIGxldCBsZXhidWYgPSBsZXhidWZfZnJvbV9jaGFubmVsIGZpbGVuYW1lIGNoYW5uZWwgaW5cbiAgICBEaXNwb3NhYmxlLmNyZWF0ZSB+Y2I6KGZ1biBfIC0+IGNsb3NlX2luIGNoYW5uZWwpIGxleGJ1ZlxuXG4gIHdpdGhcbiAgICB8IGUgLT5cbiAgICAgICAgKHRyeSBjbG9zZV9pbiBjaGFubmVsIHdpdGggXyAtPiAoKSk7XG4gICAgICAgIHJhaXNlIGVcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbmxldCBmcm9tX3N0cmluZyBkYXRhID1cbiAgRGlzcG9zYWJsZS5jcmVhdGUgKExleGluZy5mcm9tX3N0cmluZyBkYXRhKVxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxubGV0IGZpbmFsaXplIChyZWFkZXIgOiByZWFkZXIpID1cbiAgRGlzcG9zYWJsZS5kaXNwb3NlIHJlYWRlclxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxubGV0IGxleGVyIChsZXhidWYgOiBMLmxleGJ1ZikgPVxuICBsZXQgdG9rZW4gPSBMZXhlci5tYWluIGxleGJ1ZiBpblxuICAodG9rZW4sIEwubGV4ZW1lX3N0YXJ0X3AgbGV4YnVmLCBMLmxleGVtZV9lbmRfcCBsZXhidWYpXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5sZXQgcGFyc2VfdHlwZSAocmVhZGVyIDogcmVhZGVyKSA9XG4gIHBhcnNlcmZ1bl90eXBlIChmdW4gKCkgLT4gbGV4ZXIgKGxleGJ1ZiByZWFkZXIpKVxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxubGV0IHBhcnNlX2V4cHIgKHJlYWRlciA6IHJlYWRlcikgPVxuICBwYXJzZXJmdW5fZXhwciAoZnVuICgpIC0+IGxleGVyIChsZXhidWYgcmVhZGVyKSlcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbmxldCBwYXJzZV9uZXhwciAocmVhZGVyIDogcmVhZGVyKSA9XG4gIHBhcnNlcmZ1bl9uZXhwciAoZnVuICgpIC0+IGxleGVyIChsZXhidWYgcmVhZGVyKSlcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbmxldCBwYXJzZV9mb3JtIChyZWFkZXIgOiByZWFkZXIpID1cbiAgcGFyc2VyZnVuX2Zvcm0gKGZ1biAoKSAtPiBsZXhlciAobGV4YnVmIHJlYWRlcikpXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5sZXQgcGFyc2VfZ29hbCAocmVhZGVyIDogcmVhZGVyKSA9XG4gIHBhcnNlcmZ1bl9nb2FsIChmdW4gKCkgLT4gbGV4ZXIgKGxleGJ1ZiByZWFkZXIpKVxuIiwib3BlbiBVdGlsc1xuXG50eXBlIHQgPSB7XG4gIGRiX2VudiA6IEZvLmVudjtcbiAgZGJfbWFwIDogKHN0cmluZywgRm8uZm9ybSkgTWFwLnQ7XG59XG5cbmxldCBlbXB0eSBlbnYgPVxuICB7IGRiX2VudiA9IGVudjsgZGJfbWFwID0gTWFwLmVtcHR5IH1cblxuZXhjZXB0aW9uIExlbW1hTm90Rm91bmQgb2Ygc3RyaW5nXG5cbmxldCBmaW5kIGRiIG5hbWUgPVxuICBPcHRpb24uZ2V0X2V4blxuICAgIChNYXAuZmluZF9vcHQgbmFtZSBkYi5kYl9tYXApXG4gICAgKExlbW1hTm90Rm91bmQgbmFtZSlcblxubGV0IGFkZCBkYiB+KG5hbWU6c3RyaW5nKSB+KGZvcm06c3RyaW5nKSA9XG4gIGxldCBmb3JtID0gSW8ucGFyc2VfZm9ybSAoSW8uZnJvbV9zdHJpbmcgZm9ybSkgaW5cbiAgbGV0IGZvcm0gPSBGby5Gb3JtLmNoZWNrIGRiLmRiX2VudiBmb3JtIGluXG4gIHsgZGIgd2l0aCBkYl9tYXAgPSBNYXAuYWRkIG5hbWUgZm9ybSBkYi5kYl9tYXAgfVxuICBcbmxldCBsb2FkIGRiIGxlbW1hcyA9XG4gIExpc3QuZm9sZCAoZnVuIGRiIChuYW1lLCBmb3JtKSAtPiBhZGQgZGIgfm5hbWUgfmZvcm0pIGRiIGxlbW1hc1xuXG5sZXQgYWxsIGRiID1cbiAgTWFwLmJpbmRpbmdzIGRiLmRiX21hcCIsIigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5vcGVuIFV0aWxzXG5vcGVuIEZvXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbm1vZHVsZSBIYW5kbGUgOiBzaWdcbiAgdHlwZSB0ID0gcHJpdmF0ZSBpbnRcblxuICB2YWwgb2ZpbnQgOiBpbnQgLT4gdFxuICB2YWwgZnJlc2ggOiB1bml0IC0+IHRcbiAgdmFsIGVxICAgIDogdCAtPiB0IC0+IGJvb2xcbiAgdmFsIHRvaW50IDogdCAtPiBpbnRcbmVuZCA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcblxuICBsZXQgZnJlc2ggKCkgOiB0ID1cbiAgICBVdGlscy5VaWQuZnJlc2ggKClcblxuICBsZXQgb2ZpbnQgKGkgOiBpbnQpIDogdCA9XG4gICAgaVxuXG4gIGxldCB0b2ludCAodCA6IHQpIDogaW50ID1cbiAgICB0XG5cbiAgbGV0IGVxID0gKCg9KSA6IHQgLT4gdCAtPiBib29sKVxuZW5kXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG50eXBlIHBub2RlID0gLi5cblxuZXhjZXB0aW9uIEludmFsaWRHb2FsSWQgICAgb2YgSGFuZGxlLnRcbmV4Y2VwdGlvbiBJbnZhbGlkSHlwaElkICAgIG9mIEhhbmRsZS50XG5leGNlcHRpb24gU3ViZ29hbE5vdE9wZW5lZCBvZiBIYW5kbGUudFxuXG5tb2R1bGUgUHJvb2YgOiBzaWdcbiAgdHlwZSBwcm9vZlxuXG4gIHR5cGUgaHlwID0ge1xuICAgIGhfc3JjICA6IEhhbmRsZS50IG9wdGlvbjtcbiAgICBoX2dlbiAgOiBpbnQ7XG4gICAgaF9mb3JtIDogZm9ybTtcbiAgfVxuXG4gIHZhbCBta19oeXAgOiA/c3JjOkhhbmRsZS50IC0+ID9nZW46aW50IC0+IGZvcm0gLT4gaHlwXG5cbiAgdHlwZSBoeXBzXG5cbiAgbW9kdWxlIEh5cHMgOiBzaWdcbiAgICB2YWwgZW1wdHkgICA6IGh5cHNcbiAgICB2YWwgYnlpZCAgICA6IGh5cHMgLT4gSGFuZGxlLnQgLT4gaHlwXG4gICAgdmFsIGFkZCAgICAgOiBoeXBzIC0+IEhhbmRsZS50IC0+IGh5cCAtPiBoeXBzXG4gICAgdmFsIHJlbW92ZSAgOiBoeXBzIC0+IEhhbmRsZS50IC0+IGh5cHNcbiAgICB2YWwgbW92ZSAgICA6IGh5cHMgLT4gSGFuZGxlLnQgLT4gSGFuZGxlLnQgb3B0aW9uIC0+IGh5cHNcbiAgICB2YWwgYnVtcCAgICA6IGh5cHMgLT4gaHlwc1xuICAgIHZhbCBpZHMgICAgIDogaHlwcyAtPiBIYW5kbGUudCBsaXN0XG4gICAgdmFsIG1hcCAgICAgOiAoaHlwIC0+IGh5cCkgLT4gaHlwcyAtPiBoeXBzXG4gICAgdmFsIHRvX2xpc3QgOiBoeXBzIC0+IChIYW5kbGUudCAqIGh5cCkgbGlzdFxuICBlbmRcblxuICB0eXBlIHByZWdvYWwgPSB7XG4gICAgZ19lbnYgIDogZW52O1xuICAgIGdfaHlwcyA6IGh5cHM7XG4gICAgZ19nb2FsIDogZm9ybTtcbiAgfVxuXG4gIGFuZCBnb2FsID0geyBnX2lkOiBIYW5kbGUudDsgZ19wcmVnb2FsOiBwcmVnb2FsOyB9XG5cbiAgdHlwZSBwcmVnb2FscyA9IHByZWdvYWwgbGlzdFxuXG4gIHZhbCBpbml0ICAgIDogZW52IC0+IGZvcm0gbGlzdCAtPiBmb3JtIC0+IHByb29mXG4gIHZhbCBkYiAgICAgIDogcHJvb2YgLT4gTGVtbWFEQi50XG4gIHZhbCBsb2FkZGIgIDogcHJvb2YgLT4gKHN0cmluZyAqIHN0cmluZykgbGlzdCAtPiBwcm9vZlxuICB2YWwgY2xvc2VkICA6IHByb29mIC0+IGJvb2xcbiAgdmFsIG9wZW5lZCAgOiBwcm9vZiAtPiBIYW5kbGUudCBsaXN0XG4gIHZhbCBhZnRlciAgIDogcHJvb2YgLT4gSGFuZGxlLnQgLT4gSGFuZGxlLnQgbGlzdFxuICB2YWwgZm9jdXNlZCA6IHByb29mIC0+IEhhbmRsZS50IC0+IEhhbmRsZS50XG4gIHZhbCBieWlkICAgIDogcHJvb2YgLT4gSGFuZGxlLnQgLT4gcHJlZ29hbFxuXG4gIHR5cGUgbWV0YSA9IDwgPiBKc19vZl9vY2FtbC5Kcy50XG5cbiAgdmFsIHNldF9tZXRhIDogcHJvb2YgLT4gSGFuZGxlLnQgLT4gbWV0YSBvcHRpb24gLT4gdW5pdFxuICB2YWwgZ2V0X21ldGEgOiBwcm9vZiAtPiBIYW5kbGUudCAtPiBtZXRhIG9wdGlvblxuXG4gIHZhbCBzZ3Byb2dyZXNzIDpcbiAgICBwcmVnb2FsIC0+ID9jbGVhcjpib29sIC0+XG4gICAgICAoKEhhbmRsZS50IG9wdGlvbiAqIGZvcm0gbGlzdCkgbGlzdCAqIGZvcm0pIGxpc3QgLT4gcHJlZ29hbHNcblxuICB2YWwgcHJvZ3Jlc3MgOlxuICAgIHByb29mIC0+IEhhbmRsZS50IC0+IHBub2RlIC0+IGZvcm0gbGlzdCAtPiBwcm9vZlxuXG4gIHZhbCBzcHJvZ3Jlc3MgOlxuICAgIHByb29mIC0+ID9jbGVhcjpib29sIC0+IEhhbmRsZS50IC0+IHBub2RlIC0+XG4gICAgICAoKEhhbmRsZS50IG9wdGlvbiAqIGZvcm0gbGlzdCkgbGlzdCAqIGZvcm0pIGxpc3QgLT4gcHJvb2ZcblxuICB2YWwgaHByb2dyZXNzIDpcbiAgICBwcm9vZiAtPiBIYW5kbGUudCAtPiBwbm9kZSAtPiBwcmVnb2FsIC0+IEhhbmRsZS50ICogcHJvb2ZcblxuICB2YWwgeHByb2dyZXNzIDpcbiAgICBwcm9vZiAtPiBIYW5kbGUudCAtPiBwbm9kZSAtPiBwcmVnb2FscyAtPiBwcm9vZlxuZW5kID0gc3RydWN0XG4gIG1vZHVsZSBKcyA9IEpzX29mX29jYW1sLkpzXG5cbiAgdHlwZSBoeXAgPSB7XG4gICAgaF9zcmMgIDogSGFuZGxlLnQgb3B0aW9uO1xuICAgIGhfZ2VuICA6IGludDtcbiAgICBoX2Zvcm0gOiBmb3JtO1xuICB9XG5cbiAgbW9kdWxlIEh5cHMgOiBzaWdcbiAgICB0eXBlIGh5cHNcblxuICAgIHZhbCBlbXB0eSAgIDogaHlwc1xuICAgIHZhbCBieWlkICAgIDogaHlwcyAtPiBIYW5kbGUudCAtPiBoeXBcbiAgICB2YWwgYWRkICAgICA6IGh5cHMgLT4gSGFuZGxlLnQgLT4gaHlwIC0+IGh5cHNcbiAgICB2YWwgcmVtb3ZlICA6IGh5cHMgLT4gSGFuZGxlLnQgLT4gaHlwc1xuICAgIHZhbCBtb3ZlICAgIDogaHlwcyAtPiBIYW5kbGUudCAtPiBIYW5kbGUudCBvcHRpb24gLT4gaHlwc1xuICAgIHZhbCBidW1wICAgIDogaHlwcyAtPiBoeXBzXG4gICAgdmFsIGlkcyAgICAgOiBoeXBzIC0+IEhhbmRsZS50IGxpc3RcbiAgICB2YWwgbWFwICAgICA6IChoeXAgLT4gaHlwKSAtPiBoeXBzIC0+IGh5cHNcbiAgICB2YWwgdG9fbGlzdCA6IGh5cHMgLT4gKEhhbmRsZS50ICogaHlwKSBsaXN0XG4gIGVuZCA9IHN0cnVjdFxuICAgIHR5cGUgaHlwcyA9IChIYW5kbGUudCAqIGh5cCkgbGlzdFxuXG4gICAgbGV0IGVtcHR5IDogaHlwcyA9XG4gICAgICBbXVxuXG4gICAgbGV0IGJ5aWQgKGh5cHMgOiBoeXBzKSAoaWQgOiBIYW5kbGUudCkgPVxuICAgICAgT3B0aW9uLmdldF9leG5cbiAgICAgICAgKExpc3QuRXhjZXB0aW9ubGVzcy5hc3NvYyBpZCBoeXBzKVxuICAgICAgICAoSW52YWxpZEh5cGhJZCBpZClcblxuICAgIGxldCBhZGQgKGh5cHMgOiBoeXBzKSAoaWQgOiBIYW5kbGUudCkgKGggOiBoeXApIDogaHlwcyA9XG4gICAgICBhc3NlcnQgKE9wdGlvbi5pc19ub25lIChMaXN0LkV4Y2VwdGlvbmxlc3MuYXNzb2MgaWQgaHlwcykpO1xuICAgICAgKGlkLCBoKSA6OiBoeXBzXG5cbiAgICBsZXQgcmVtb3ZlIChoeXBzIDogaHlwcykgKGlkIDogSGFuZGxlLnQpIDogaHlwcyA9XG4gICAgICBMaXN0LmZpbHRlciAoZnVuICh4LCBfKSAtPiBub3QgKEhhbmRsZS5lcSB4IGlkKSkgaHlwc1xuXG4gICAgbGV0IG1vdmUgKGh5cHMgOiBoeXBzKSAoZnJvbSA6IEhhbmRsZS50KSAoYmVmb3JlIDogSGFuZGxlLnQgb3B0aW9uKSA9XG4gICAgICBsZXQgdGcgICA9IGJ5aWQgaHlwcyBmcm9tIGluXG4gICAgICBsZXQgaHlwcyA9IHJlbW92ZSBoeXBzIGZyb20gaW5cblxuICAgICAgbWF0Y2ggYmVmb3JlIHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIChmcm9tLCB0ZykgOjogaHlwc1xuXG4gICAgICB8IFNvbWUgYmVmb3JlIC0+XG4gICAgICAgICAgbGV0IHBvcywgXyA9XG4gICAgICAgICAgICBPcHRpb24uZ2V0X2V4blxuICAgICAgICAgICAgICAoTGlzdC5FeGNlcHRpb25sZXNzLmZpbmRpIChmdW4gXyAoeCwgXykgLT4gSGFuZGxlLmVxIHggYmVmb3JlKSBoeXBzKVxuICAgICAgICAgICAgICAoSW52YWxpZEh5cGhJZCBiZWZvcmUpIGluXG5cbiAgICAgICAgICBsZXQgcG9zdCwgcHJlID0gTGlzdC5zcGxpdF9hdCAoMStwb3MpIGh5cHMgaW5cblxuICAgICAgICAgIHBvc3QgQCAoZnJvbSwgdGcpIDo6IHByZVxuXG4gICAgbGV0IGJ1bXAgKGh5cHMgOiBoeXBzKSA6IGh5cHMgPVxuICAgICAgTGlzdC5tYXAgKGZ1biAoaWQsIGgpIC0+IChpZCwgeyBoIHdpdGggaF9nZW4gPSBoLmhfZ2VuICsgMSB9KSkgaHlwc1xuXG4gICAgbGV0IGlkcyAoaHlwcyA6IGh5cHMpID1cbiAgICAgIExpc3QuZnN0IGh5cHNcbiAgICBcbiAgICBsZXQgbWFwIGYgKGh5cHMgOiBoeXBzKSA9XG4gICAgICBMaXN0Lm1hcCAoc25kX21hcCBmKSBoeXBzXG5cbiAgICBsZXQgdG9fbGlzdCAoaHlwcyA6IGh5cHMpID1cbiAgICAgIGh5cHNcbiAgZW5kXG5cbiAgdHlwZSBoeXBzID0gSHlwcy5oeXBzXG5cbiAgdHlwZSBwcmVnb2FsID0ge1xuICAgIGdfZW52ICA6IGVudjtcbiAgICBnX2h5cHMgOiBoeXBzO1xuICAgIGdfZ29hbCA6IGZvcm07XG4gIH1cblxuICB0eXBlIHByZWdvYWxzID0gcHJlZ29hbCBsaXN0XG5cbiAgdHlwZSBwcm9vZiA9IHtcbiAgICBwX3Jvb3QgOiBIYW5kbGUudDtcbiAgICBwX21hcHMgOiAoSGFuZGxlLnQsIGdvYWwpIE1hcC50O1xuICAgIHBfY3J0cyA6IEhhbmRsZS50IGxpc3Q7XG4gICAgcF9mcndkIDogKEhhbmRsZS50LCBnZGVwKSBNYXAudDtcbiAgICBwX2Jrd2QgOiAoSGFuZGxlLnQsIGdkZXApIE1hcC50O1xuICAgIHBfbWV0YSA6IChIYW5kbGUudCwgPCA+IEpzLnQpIE1hcC50IHJlZjtcbiAgICBwX2RiICAgOiBMZW1tYURCLnQ7XG4gIH1cblxuICBhbmQgZ29hbCA9IHsgZ19pZDogSGFuZGxlLnQ7IGdfcHJlZ29hbDogcHJlZ29hbDsgfVxuXG4gIGFuZCBnZGVwID0ge1xuICAgIGRfc3JjIDogSGFuZGxlLnQ7XG4gICAgZF9kc3QgOiBIYW5kbGUudCBsaXN0O1xuICAgIGRfbmRuIDogcG5vZGU7XG4gIH1cblxuICBsZXQgbWtfaHlwID8oc3JjIDogSGFuZGxlLnQgb3B0aW9uKSA/KGdlbiA6IGludCA9IDApIGZvcm0gPVxuICAgIHsgaF9zcmMgPSBzcmM7IGhfZ2VuID0gZ2VuOyBoX2Zvcm0gPSBmb3JtOyB9XG5cbiAgbGV0IGluaXQgKGVudiA6IGVudikgKGh5cHMgOiBmb3JtIGxpc3QpIChnb2FsIDogZm9ybSkgPVxuICAgIEZvcm0ucmVjaGVjayBlbnYgZ29hbDtcbiAgICBMaXN0Lml0ZXIgKEZvcm0ucmVjaGVjayBlbnYpIGh5cHM7XG5cbiAgICBsZXQgdWlkICA9IEhhbmRsZS5mcmVzaCAoKSBpblxuICAgIGxldCBnX2h5cHMgPSBMaXN0LmZvbGRfbGVmdFxuICAgICAgKGZ1biBocyBmIC0+ICBIeXBzLmFkZCBocyAoSGFuZGxlLmZyZXNoICgpKSAobWtfaHlwIGYpKVxuICAgICAgSHlwcy5lbXB0eSBoeXBzIGluXG4gICAgbGV0IHJvb3QgPSB7IGdfaWQgPSB1aWQ7IGdfcHJlZ29hbCA9IHtcbiAgICAgICAgZ19lbnYgID0gZW52O1xuICAgICAgICBnX2h5cHM7XG4gICAgICAgIGdfZ29hbCA9IGdvYWw7XG4gICAgICB9XG4gICAgfSBpblxuXG4gICAgeyBwX3Jvb3QgPSB1aWQ7XG4gICAgICBwX21hcHMgPSBNYXAuc2luZ2xldG9uIHVpZCByb290O1xuICAgICAgcF9jcnRzID0gW3VpZF07XG4gICAgICBwX2Zyd2QgPSBNYXAuZW1wdHk7XG4gICAgICBwX2Jrd2QgPSBNYXAuZW1wdHk7XG4gICAgICBwX21ldGEgPSByZWYgTWFwLmVtcHR5O1xuICAgICAgcF9kYiAgID0gTGVtbWFEQi5lbXB0eSBlbnY7IH1cbiAgXG4gIGxldCBkYiAocHJvb2YgOiBwcm9vZikgPVxuICAgIHByb29mLnBfZGJcbiAgICBcbiAgbGV0IGxvYWRkYiAocHJvb2YgOiBwcm9vZikgKGxlbW1hcyA6IChzdHJpbmcgKiBzdHJpbmcpIGxpc3QpID1cbiAgICB7IHByb29mIHdpdGggcF9kYiA9IExlbW1hREIubG9hZCBwcm9vZi5wX2RiIGxlbW1hcyB9XG5cbiAgbGV0IGNsb3NlZCAocHJvb2YgOiBwcm9vZikgPVxuICAgIExpc3QuaXNfZW1wdHkgcHJvb2YucF9jcnRzXG5cbiAgbGV0IG9wZW5lZCAocHJvb2YgOiBwcm9vZikgPVxuICAgIHByb29mLnBfY3J0c1xuXG4gIGxldCBhZnRlciAocHJvb2YgOiBwcm9vZikgKGlkIDogSGFuZGxlLnQpID1cbiAgICAoTWFwLmZpbmQgaWQgcHJvb2YucF9mcndkKS5kX2RzdFxuXG4gIGxldCBmb2N1c2VkIChwcm9vZiA6IHByb29mKSAoaWQgOiBIYW5kbGUudCkgPVxuICAgIExpc3QuaGQgKGFmdGVyIHByb29mIGlkKVxuXG4gIGxldCBieWlkIChwcm9vZiA6IHByb29mKSAoaWQgOiBIYW5kbGUudCkgOiBwcmVnb2FsID1cbiAgICBsZXQgZ29hbCA9XG4gICAgICBPcHRpb24uZ2V0X2V4blxuICAgICAgICAoTWFwLkV4Y2VwdGlvbmxlc3MuZmluZCBpZCBwcm9vZi5wX21hcHMpXG4gICAgICAgIChJbnZhbGlkR29hbElkIGlkKVxuICAgIGluIGdvYWwuZ19wcmVnb2FsXG5cbiAgdHlwZSBtZXRhID0gPCA+IEpzX29mX29jYW1sLkpzLnRcblxuICBsZXQgc2V0X21ldGEgKHByb29mIDogcHJvb2YpIChpZCA6IEhhbmRsZS50KSAobWV0YSA6IG1ldGEgb3B0aW9uKSA6IHVuaXQgPVxuICAgIG1hdGNoIG1ldGEgd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgICBwcm9vZi5wX21ldGEgOj0gTWFwLnJlbW92ZSBpZCAhKHByb29mLnBfbWV0YSlcbiAgICAgICAgXG4gICAgfCBTb21lIG1ldGEgLT5cbiAgICAgICAgcHJvb2YucF9tZXRhIDo9IE1hcC5hZGQgaWQgbWV0YSAhKHByb29mLnBfbWV0YSlcblxuICBsZXQgZ2V0X21ldGEgKHByb29mIDogcHJvb2YpIChpZCA6IEhhbmRsZS50KSA6IG1ldGEgb3B0aW9uID1cbiAgICBNYXAuRXhjZXB0aW9ubGVzcy5maW5kIGlkICEocHJvb2YucF9tZXRhKVxuXG4gIGxldCBocHJvZ3Jlc3MgKHByIDogcHJvb2YpIChpZCA6IEhhbmRsZS50KSAocG4gOiBwbm9kZSkgKHN1YiA6IHByZWdvYWwpID1cbiAgICBsZXQgX2dvYWwgPSBieWlkIHByIGlkIGluXG5cbiAgICBsZXQgZ19pZCA9IEhhbmRsZS5mcmVzaCAoKSBpblxuICAgIGxldCBzdWIgPVxuICAgICAgbGV0IGh5cHMgPSBIeXBzLmJ1bXAgc3ViLmdfaHlwcyBpblxuICAgICAgbGV0IHN1YiAgPSB7IHN1YiB3aXRoIGdfaHlwcyA9IGh5cHMgfSBpblxuICAgICAgeyBnX2lkOyBnX3ByZWdvYWwgPSBzdWI7IH0gaW5cblxuICAgIGxldCBnciwgXywgZ28gPVxuICAgICAgdHJ5ICBMaXN0LnBpdm90IChIYW5kbGUuZXEgaWQpIHByLnBfY3J0c1xuICAgICAgd2l0aCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gcmFpc2UgKFN1YmdvYWxOb3RPcGVuZWQgaWQpIGluXG5cbiAgICBsZXQgZGVwID0geyBkX3NyYyA9IGlkOyBkX2RzdCA9IFtnX2lkXTsgZF9uZG4gPSBwbjsgfSBpblxuXG4gICAgbGV0IG1ldGEgPVxuICAgICAgbWF0Y2ggTWFwLkV4Y2VwdGlvbmxlc3MuZmluZCBpZCAhKHByLnBfbWV0YSkgd2l0aFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgIShwci5wX21ldGEpXG5cbiAgICAgIHwgU29tZSBtZXRhIC0+XG4gICAgICAgICAgTWFwLmFkZCBnX2lkIG1ldGEgIShwci5wX21ldGEpXG4gICAgaW5cblxuICAgIGxldCBtYXAgPVxuICAgICAgTWFwLmFkZCBzdWIuZ19pZCBzdWIgcHIucF9tYXBzIGluXG5cbiAgICBnX2lkLCB7IHByIHdpdGhcbiAgICAgICAgcF9tYXBzID0gbWFwO1xuICAgICAgICBwX2NydHMgPSBnciBAIFtnX2lkXSBAIGdvO1xuICAgICAgICBwX2Zyd2QgPSBNYXAuYWRkIGlkIGRlcCBwci5wX2Zyd2Q7XG4gICAgICAgIHBfYmt3ZCA9IE1hcC5hZGQgZ19pZCBkZXAgcHIucF9ia3dkO1xuICAgICAgICBwX21ldGEgPSByZWYgbWV0YTsgfVxuXG4gIGxldCB4cHJvZ3Jlc3MgKHByIDogcHJvb2YpIChpZCA6IEhhbmRsZS50KSAocG4gOiBwbm9kZSkgKHN1YiA6IHByZWdvYWxzKSA9XG4gICAgbGV0IF9nb2FsID0gYnlpZCBwciBpZCBpblxuXG4gICAgbGV0IHN1YiA9XG4gICAgICBsZXQgZm9yMSBzdWIgPVxuICAgICAgICBsZXQgaHlwcyA9IEh5cHMuYnVtcCBzdWIuZ19oeXBzIGluXG4gICAgICAgIGxldCBzdWIgID0geyBzdWIgd2l0aCBnX2h5cHMgPSBoeXBzIH0gaW5cbiAgICAgICAgeyBnX2lkID0gSGFuZGxlLmZyZXNoICgpOyBnX3ByZWdvYWwgPSBzdWI7IH1cbiAgICAgIGluIExpc3QubWFwIGZvcjEgc3ViIGluXG5cbiAgICBsZXQgc2lkcyA9IExpc3QubWFwIChmdW4geCAtPiB4LmdfaWQpIHN1YiBpblxuXG4gICAgbGV0IGdyLCBfLCBnbyA9XG4gICAgICB0cnkgIExpc3QucGl2b3QgKEhhbmRsZS5lcSBpZCkgcHIucF9jcnRzXG4gICAgICB3aXRoIEludmFsaWRfYXJndW1lbnQgXyAtPiByYWlzZSAoU3ViZ29hbE5vdE9wZW5lZCBpZCkgaW5cblxuICAgIGxldCBkZXAgPSB7IGRfc3JjID0gaWQ7IGRfZHN0ID0gc2lkczsgZF9uZG4gPSBwbjsgfSBpblxuXG4gICAgbGV0IG1ldGEgPVxuICAgICAgbWF0Y2ggTWFwLkV4Y2VwdGlvbmxlc3MuZmluZCBpZCAhKHByLnBfbWV0YSkgd2l0aFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgIShwci5wX21ldGEpXG5cbiAgICAgIHwgU29tZSBtZXRhIC0+XG4gICAgICAgICAgTGlzdC5mb2xkX2xlZnRcbiAgICAgICAgICAgIChmdW4gbWFwIGlkIC0+IE1hcC5hZGQgaWQgbWV0YSBtYXApXG4gICAgICAgICAgICAhKHByLnBfbWV0YSkgc2lkc1xuICAgIGluXG5cbiAgICBsZXQgbWFwID1cbiAgICAgIExpc3QuZm9sZF9yaWdodFxuICAgICAgICAoZnVuIHN1YiBtYXAgLT4gTWFwLmFkZCBzdWIuZ19pZCBzdWIgbWFwKVxuICAgICAgICBzdWIgcHIucF9tYXBzIGluXG5cbiAgICB7IHByIHdpdGhcbiAgICAgICAgcF9tYXBzID0gbWFwO1xuICAgICAgICBwX2NydHMgPSBnciBAIHNpZHMgQCBnbztcbiAgICAgICAgcF9mcndkID0gTWFwLmFkZCBpZCBkZXAgcHIucF9mcndkO1xuICAgICAgICBwX2Jrd2QgPSBMaXN0LmZvbGRfcmlnaHQgKE1hcC5hZGRefiBkZXApIHNpZHMgcHIucF9ia3dkO1xuICAgICAgICBwX21ldGEgPSByZWYgbWV0YTsgfVxuXG4gIGxldCBzZ3Byb2dyZXNzIChnb2FsIDogcHJlZ29hbCkgPyhjbGVhciA9IGZhbHNlKSBzdWIgPVxuICAgIGxldCBmb3IxIChuZXdsYywgY29uY2wpID1cbiAgICAgIGxldCBzdWJmb3IxIGh5cHMgKGhpZCwgbmV3bGMpID1cbiAgICAgICAgbGV0IGh5cHMgPVxuICAgICAgICAgIE9wdGlvbi5mb2xkIChmdW4gaHlwcyBoaWQgLT5cbiAgICAgICAgICAgIGxldCBfaCA9IChIeXBzLmJ5aWQgaHlwcyBoaWQpLmhfZm9ybSBpblxuICAgICAgICAgICAgaWYgY2xlYXIgdGhlbiBIeXBzLnJlbW92ZSBoeXBzIGhpZCBlbHNlIGh5cHMpXG4gICAgICAgICAgaHlwcyBoaWQgaW5cbiAgICAgICAgbGV0IGhzcmMgPSBpZiBjbGVhciB0aGVuIE5vbmUgZWxzZSBoaWQgaW5cblxuICAgICAgICBsZXQgaHlwcyA9IExpc3QuZm9sZF9sZWZ0IChmdW4gaHlwcyBuZXdoIC0+XG4gICAgICAgICAgICBIeXBzLmFkZCBoeXBzIChIYW5kbGUuZnJlc2ggKCkpIChta19oeXAgP3NyYzpoc3JjIG5ld2gpKVxuICAgICAgICAgIGh5cHMgbmV3bGNcbiAgICAgICAgaW4gaHlwcyBpblxuXG4gICAgICBsZXQgaHlwcyA9IExpc3QuZm9sZF9sZWZ0IHN1YmZvcjEgZ29hbC5nX2h5cHMgbmV3bGMgaW5cbiAgICAgIHsgZ19lbnYgPSBnb2FsLmdfZW52OyBnX2h5cHMgPSBoeXBzOyBnX2dvYWwgPSBjb25jbDsgfVxuXG4gICAgaW4gTGlzdC5tYXAgZm9yMSBzdWJcblxuICBsZXQgc3Byb2dyZXNzIChwciA6IHByb29mKSA/KGNsZWFyID0gZmFsc2UpIChpZCA6IEhhbmRsZS50KSAocG4gOiBwbm9kZSkgc3ViID1cbiAgICBsZXQgZ29hbCA9IGJ5aWQgcHIgaWQgaW5cbiAgICBsZXQgc3ViID0gc2dwcm9ncmVzcyBnb2FsIH5jbGVhciBzdWIgaW5cbiAgICB4cHJvZ3Jlc3MgcHIgaWQgcG4gc3ViXG5cbiAgbGV0IHByb2dyZXNzIChwciA6IHByb29mKSAoaWQgOiBIYW5kbGUudCkgKHBuIDogcG5vZGUpIChzdWIgOiBmb3JtIGxpc3QpID1cbiAgICBsZXQgZ29hbCA9IGJ5aWQgcHIgaWQgaW5cbiAgICBsZXQgc3ViICA9IExpc3QubWFwIChmdW4geCAtPiB7IGdvYWwgd2l0aCBnX2dvYWwgPSB4IH0pIHN1YiBpblxuICAgIHhwcm9ncmVzcyBwciBpZCBwbiBzdWJcbmVuZFxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuZXhjZXB0aW9uIFRhY3RpY05vdEFwcGxpY2FibGVcblxubW9kdWxlIENvcmVMb2dpYyA6IHNpZ1xuICB0eXBlIHRhcmcgICA9IFByb29mLnByb29mICogSGFuZGxlLnRcbiAgdHlwZSB0YWN0aWMgPSB0YXJnIC0+IFByb29mLnByb29mXG5cbiAgdHlwZSBwYXRoICAgICAgICA9IHN0cmluZ1xuICB0eXBlIHBraW5kICAgICAgID0gW2BIeXAgfCBgQ29uY2wgfCBgVmFyIG9mIFtgSGVhZCB8IGBCb2R5XV1cbiAgdHlwZSBjdHh0ICAgICAgICA9IHsga2luZCA6IHBraW5kOyBoYW5kbGUgOiBpbnQgfVxuICB0eXBlIGlwYXRoICAgICAgID0geyByb290IDogaW50OyBjdHh0IDogY3R4dDsgc3ViIDogaW50IGxpc3Q7IH1cbiAgdHlwZSBsaW5rICAgICAgICA9IGlwYXRoICogaXBhdGhcbiAgdHlwZSBoeXBlcmxpbmsgICA9IGlwYXRoIGxpc3QgKiBpcGF0aCBsaXN0XG5cbiAgdmFsIGlwYXRoX29mX3BhdGggOiBwYXRoIC0+IGlwYXRoXG5cbiAgdHlwZSBpdGVtID0gW1xuICAgIHwgYEMgb2YgZm9ybVxuICAgIHwgYEggb2YgSGFuZGxlLnQgKiBQcm9vZi5oeXBcbiAgICB8IGBWIG9mIHZuYW1lICogYnZhclxuICBdXG5cbiAgdHlwZSBwb2wgPSBQb3MgfCBOZWcgfCBTdXBcblxuICB2YWwgY3V0ICAgICAgICA6IEZvLmZvcm0gLT4gdGFjdGljXG4gIHZhbCBhc3N1bWUgICAgIDogRm8uZm9ybSAtPiB0YWN0aWNcbiAgdmFsIGFkZF9sb2NhbCAgOiBzdHJpbmcgKiBGby50eXBlXyAqIEZvLmV4cHIgb3B0aW9uIC0+IHRhY3RpY1xuICB2YWwgZ2VuZXJhbGl6ZSA6IEhhbmRsZS50IC0+IHRhY3RpY1xuICB2YWwgbW92ZSAgICAgICA6IEhhbmRsZS50IC0+IEhhbmRsZS50IG9wdGlvbiAtPiB0YWN0aWNcbiAgdmFsIGludHJvICAgICAgOiA/dmFyaWFudDooaW50ICogKGV4cHIgKiB0eXBlXykgb3B0aW9uKSAtPiB0YWN0aWNcbiAgdmFsIGVsaW0gICAgICAgOiA/Y2xlYXI6Ym9vbCAtPiBIYW5kbGUudCAtPiB0YWN0aWNcbiAgdmFsIGl2YXJpYW50cyAgOiB0YXJnIC0+IHN0cmluZyBsaXN0XG4gIHZhbCBmb3J3YXJkICAgIDogKEhhbmRsZS50ICogSGFuZGxlLnQgKiBpbnQgbGlzdCAqIEZvcm0uU3Vic3Quc3Vic3QpIC0+IHRhY3RpY1xuXG4gIHR5cGUgYXNvdXJjZSA9XG4gICAgeyBraW5kIDogYXNvdXJjZV9raW5kOyBzZWxlY3Rpb24gOiBzZWxlY3Rpb247IH1cblxuICBhbmQgYXNvdXJjZV9raW5kID0gW1xuICAgIHwgYENsaWNrIG9mIGlwYXRoXG4gICAgfCBgRG5EICAgb2YgYWRuZFxuICBdXG5cbiAgYW5kIGFkbmQgPSB7XG4gICAgc291cmNlICAgICAgOiBpcGF0aDtcbiAgICBkZXN0aW5hdGlvbiA6IGlwYXRoIG9wdGlvbjtcbiAgfVxuXG4gIGFuZCBzZWxlY3Rpb24gPSBpcGF0aCBsaXN0XG5cbiAgdHlwZSBvc291cmNlID0gW1xuICAgIHwgYENsaWNrIG9mIGlwYXRoXG4gICAgfCBgRG5EICAgb2YgbGlua1xuICBdXG5cbiAgdmFsIHBhdGhfb2ZfaXBhdGggOiBpcGF0aCAtPiBwYXRoXG5cbiAgdHlwZSBsaW5rYWN0aW9uID0gW1xuICAgIHwgYE5vdGhpbmdcbiAgICB8IGBCb3RoIG9mIGxpbmthY3Rpb24gKiBsaW5rYWN0aW9uXG4gICAgfCBgU3ViZm9ybSBvZiBGb3JtLlN1YnN0LnN1YnN0ICogRm9ybS5TdWJzdC5zdWJzdFxuICAgIHwgYEluc3RhbnRpYXRlIG9mIGV4cHIgKiBpcGF0aFxuICAgIHwgYFJld3JpdGUgb2YgZXhwciAqIGV4cHIgKiBpcGF0aCBsaXN0XG4gICAgfCBgRm9sZCBvZiB2bmFtZSAqIGlwYXRoIGxpc3RcbiAgICB8IGBVbmZvbGQgb2Ygdm5hbWUgKiBpcGF0aCBsaXN0XG4gIF1cblxuICB0eXBlIGFjdGlvbiA9IEhhbmRsZS50ICogW1xuICAgIHwgYEludHJvICAgICBvZiBpbnRcbiAgICB8IGBFbGltICAgICAgb2YgSGFuZGxlLnRcbiAgICB8IGBJbmQgICAgICAgb2YgSGFuZGxlLnRcbiAgICB8IGBGb2xkICAgICAgb2Ygdm5hbWVcbiAgICB8IGBVbmZvbGQgICAgb2Ygdm5hbWVcbiAgICB8IGBIeXBlcmxpbmsgb2YgaHlwZXJsaW5rICogbGlua2FjdGlvbiBsaXN0XG4gICAgfCBgRm9yd2FyZCAgIG9mIEhhbmRsZS50ICogSGFuZGxlLnQgKiAoaW50IGxpc3QpICogRm9ybS5TdWJzdC5zdWJzdCBcbiAgICB8IGBEaXNqRHJvcCAgb2YgSGFuZGxlLnQgKiBmb3JtIGxpc3RcbiAgICB8IGBDb25qRHJvcCAgb2YgSGFuZGxlLnRcbiAgXVxuXG4gIGV4Y2VwdGlvbiBJbnZhbGlkUGF0aCBvZiBwYXRoXG4gIGV4Y2VwdGlvbiBJbnZhbGlkU3ViRm9ybVBhdGggb2YgaW50IGxpc3RcbiAgZXhjZXB0aW9uIEludmFsaWRTdWJFeHByUGF0aCBvZiBpbnQgbGlzdFxuXG4gIHZhbCBhY3Rpb25zIDogUHJvb2YucHJvb2YgLT4gYXNvdXJjZSAtPlxuICAgICAgICAgICAgICAgICAgKHN0cmluZyAqIGlwYXRoIGxpc3QgKiBvc291cmNlICogYWN0aW9uKSBsaXN0XG4gKCogc3RyaW5nIDogZG9jXG4gICAgaXBhdGggbGlzdCA6IHN1cmJyaWxsYW5jZVxuICAgIG9zb3VyY2UgXG4gKilcblxuICB2YWwgbGVtbWFzIDogP3NlbGVjdGlvbjpzZWxlY3Rpb24gLT4gUHJvb2YucHJvb2YgLT4gKHN0cmluZyAqIGZvcm0pIGxpc3RcblxuICB2YWwgYXBwbHkgICA6IFByb29mLnByb29mIC0+IGFjdGlvbiAtPiBQcm9vZi5wcm9vZlxuZW5kID0gc3RydWN0XG4gIHR5cGUgdGFyZyAgID0gUHJvb2YucHJvb2YgKiBIYW5kbGUudFxuICB0eXBlIHRhY3RpYyA9IHRhcmcgLT4gUHJvb2YucHJvb2ZcbiAgXG4gIHR5cGUgcG5vZGUgKz0gVElkXG5cbiAgbGV0IGlkX3RhYyA6IHRhY3RpYyA9XG4gICAgZnVuIChwciwgaWQpIC0+IFByb29mLnhwcm9ncmVzcyBwciBpZCBUSWQgW1Byb29mLmJ5aWQgcHIgaWRdXG4gIFxuICBsZXQgdGhlbl90YWMgKHQxIDogdGFjdGljKSAodDIgOiB0YWN0aWMpIDogdGFjdGljID1cbiAgICBmdW4gKF8sIGlkIGFzIHRhcmcpIC0+XG4gICAgICBsZXQgcHIgPSB0MSB0YXJnIGluXG4gICAgICBsZXQgaGQgPSBQcm9vZi5mb2N1c2VkIHByIGlkIGluXG4gICAgICB0MiAocHIsIGhkKVxuXG4gIGxldCB0aGVubF90YWMgKHQxIDogdGFjdGljKSAodDIgOiB0YWN0aWMpIDogdGFjdGljID1cbiAgICBmdW4gKF8sIGlkIGFzIHRhcmcpIC0+XG4gICAgICBsZXQgcHIgPSB0MSB0YXJnIGluXG4gICAgICBMaXN0LmZvbGRfbGVmdCAodW5jdXJyeSB0MikgcHIgKFByb29mLmFmdGVyIHByIGlkKVxuXG4gIGxldCBwcnVuZV9wcmVtaXNzZXMgPVxuICAgIGxldCByZWMgZG9pdCBhY2MgPSBmdW5jdGlvblxuICAgICAgfCBGQ29ubiAoYEltcCwgW2YxOyBmMl0pIC0+IGRvaXQgKGYxIDo6IGFjYykgZjJcbiAgICAgIHwgZiAtPiAoTGlzdC5yZXYgYWNjLCBmKVxuICAgIGluIGZ1biBmIC0+IGRvaXQgW10gZlxuXG4gIGxldCBwcnVuZV9wcmVtaXNzZXNfZmEgPVxuICAgIGxldCByZWMgZG9pdCBpIGFjYyBzID0gZnVuY3Rpb25cbiAgICAgIHwgRkNvbm4gKGBJbXAsIFtmMTsgZjJdKSAtPiBkb2l0IGkgKChpLCBmMSkgOjogYWNjKSBzIGYyXG4gICAgICB8IEZCaW5kIChgRm9yYWxsLCB4LCBfLCBmKSAtPiBkb2l0IChpKzEpIGFjYyAoKHgsU2ZsZXgpOjpzKSBmIFxuICAgICAgfCBmIC0+IChMaXN0LnJldiBhY2MsIGYsIHMpXG4gICAgaW4gZnVuIGYgLT5cblxuICAgIGxldCBwcmUsIGh5LCBzICA9IGRvaXQgMCBbXSBbXSBmIGluIFxuXG4gICAgKHByZSwgaHksIEZvcm0uU3Vic3Qub2ZsaXN0IHMpXG5cbiAgbGV0IHBydW5lX3ByZW1pc3Nlc19leCA9XG4gICAgbGV0IHJlYyBkb2l0IGkgYWNjIHMgPSBmdW5jdGlvblxuICAgICAgfCBGQmluZCAoYEV4aXN0LCB4LCBfLCBmKSAtPiBkb2l0IChpKzEpIGFjYyAoKHgsIFNmbGV4KTo6cykgZlxuICAgICAgfCBmIC0+IChMaXN0LnJldiBhY2MsIGYsIHMpXG4gICAgaW4gZnVuIGYgLT5cblxuICAgIGxldCBwcmUsIGh5LCBzID0gZG9pdCAwIFtdIFtdIGYgaW5cblxuICAgIChwcmUsIGh5LCBGb3JtLlN1YnN0Lm9mbGlzdCBzKVxuXHRcbiAgbGV0IHJlYyByZW1vdmVfZm9ybSBlbnYgZiA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IHJhaXNlIFRhY3RpY05vdEFwcGxpY2FibGVcbiAgICAgIHwgZzo6bCB3aGVuIEZvcm0uZl9lcXVhbCBlbnYgZyBmIC0+IGxcbiAgICAgIHwgZzo6bCAtPiBnOjoocmVtb3ZlX2Zvcm0gZW52IGYgbClcbiAgXG4gIFxuICB0eXBlIHBub2RlICs9IFREZWYgb2YgKEZvLnR5cGVfICogRm8uZXhwciBvcHRpb24pICogSGFuZGxlLnRcblxuICBsZXQgYWRkX2xvY2FsICgobmFtZSwgdHksIGJvZHkpIDogc3RyaW5nICogRm8udHlwZV8gKiBGby5leHByIG9wdGlvbikgKChwcm9vZiwgaGQpIDogdGFyZykgPVxuICAgIGxldCBnb2FsID0gUHJvb2YuYnlpZCBwcm9vZiBoZCBpblxuXG4gICAgT3B0aW9uLm1hcF9kZWZhdWx0IChGby5Gb3JtLmVyZWNoZWNrIGdvYWwuZ19lbnYgdHkpICgpIGJvZHk7XG5cbiAgICBsZXQgZ19lbnYgPSBGby5WYXJzLnB1c2ggZ29hbC5nX2VudiAobmFtZSwgKHR5LCBib2R5KSkgaW5cbiAgICBsZXQgZ19lbnYgPSBGby5WYXJzLm1hcCBnX2VudiAoT3B0aW9uLm1hcCAoRm8uRm9ybS5lX3NoaWZ0IChuYW1lLCAwKSkpIGluXG5cbiAgICBsZXQgZ19oeXBzID1cbiAgICAgIFByb29mLkh5cHMuKG1hcCAoZnVuIGggLT5cbiAgICAgICAgeyBoIHdpdGggaF9mb3JtID0gRm9ybS5mX3NoaWZ0IChuYW1lLCAwKSBoLmhfZm9ybSB9KVxuICAgICAgICBnb2FsLmdfaHlwcykgaW5cbiAgICBcbiAgICBsZXQgZ19nb2FsID0gRm9ybS5mX3NoaWZ0IChuYW1lLCAwKSBnb2FsLmdfZ29hbCBpblxuICAgIFxuICAgIFByb29mLnhwcm9ncmVzcyBwcm9vZiBoZCAoVERlZiAoKHR5LCBib2R5KSwgaGQpKVxuICAgICAgW3sgZ19lbnY7IGdfaHlwczsgZ19nb2FsIH1dXG5cblxuICB0eXBlIHBub2RlICs9IFRJbnRybyBvZiAoaW50ICogKGV4cHIgKiB0eXBlXykgb3B0aW9uKVxuXG4gIGxldCBpbnRybyA/KHZhcmlhbnQgPSAoMCwgTm9uZSkpICgocHIsIGlkKSA6IHRhcmcpID1cbiAgICBsZXQgcHRlcm0gPSBUSW50cm8gdmFyaWFudCBpblxuICAgIGxldCBnb2FsID0gUHJvb2YuYnlpZCBwciBpZCBpblxuICAgIGxldCBnX2VudiA9IGdvYWwuZ19lbnYgaW5cblxuICAgIG1hdGNoIHZhcmlhbnQsIChQcm9vZi5ieWlkIHByIGlkKS5nX2dvYWwgd2l0aFxuICAgIHwgKDAsIE5vbmUpLCBGUHJlZCAoXCJfRVFcIiwgW2UxOyBlMl0pIHdoZW4gRm9ybS5lX2VxdWFsIGdfZW52IGUxIGUyIC0+XG4gICAgICAgIFByb29mLnByb2dyZXNzIHByIGlkIHB0ZXJtIFtdXG5cbiAgICB8ICgwLCBOb25lKSwgRkNvbm4gKGBBbmQsIFtmMTsgZjJdKSAtPlxuICAgICAgICBQcm9vZi5wcm9ncmVzcyBwciBpZCBwdGVybSBbZjE7IGYyXVxuXG4gICAgfCAoMCwgTm9uZSksIEZDb25uIChgSW1wLCBbZjE7IGYyXSkgLT5cbiAgICAgICAgUHJvb2Yuc3Byb2dyZXNzIHByIGlkIHB0ZXJtXG4gICAgICAgICAgW1tOb25lLCBbZjFdXSwgZjJdXG5cbiAgICB8ICgwLCBOb25lKSwgRkNvbm4gKGBFcXVpdiwgW2YxOyBmMl0pIC0+XG4gICAgICAgIFByb29mLnByb2dyZXNzIHByIGlkIHB0ZXJtXG4gICAgICAgICAgW0Zvcm0uZl9pbXAgZjEgZjI7IEZvcm0uZl9pbXAgZjIgZjFdXG5cbiAgICB8IChpLCBOb25lKSwgKEZDb25uIChgT3IsIF8pIGFzIGYpIC0+XG4gICAgICAgIGxldCBmbCA9IEZvcm0uZmxhdHRlbl9kaXNqdW5jdGlvbnMgZiBpblxuICAgICAgICBsZXQgZyA9IExpc3QubnRoIGZsIGkgaW5cbiAgICAgICAgUHJvb2YucHJvZ3Jlc3MgcHIgaWQgcHRlcm0gW2ddXG5cbiAgICB8ICgwLCBOb25lKSwgRkNvbm4gKGBOb3QsIFtmXSkgLT5cbiAgICAgICAgUHJvb2Yuc3Byb2dyZXNzIHByIGlkIHB0ZXJtIFtbTm9uZSwgW2ZdXSwgRkZhbHNlXVxuXG4gICAgfCAoMCwgTm9uZSksIEZUcnVlIC0+XG4gICAgICAgIFByb29mLnByb2dyZXNzIHByIGlkIHB0ZXJtIFtdXG5cbiAgICB8ICgwLCBOb25lKSwgRkJpbmQgKGBGb3JhbGwsIHgsIHh0eSwgYm9keSkgLT5cbiAgICAgICAgKHByLCBpZCkgfD4gdGhlbl90YWNcbiAgICAgICAgICAoYWRkX2xvY2FsICh4LCB4dHksIE5vbmUpKVxuICAgICAgICAgIChmdW4gKHByLCBpZCkgLT5cbiAgICAgICAgICAgIFByb29mLnByb2dyZXNzIHByIGlkIHB0ZXJtIFtib2R5XSlcblxuICAgIHwgKDAsIFNvbWUgKGUsIGV0eSkpLCBGQmluZCAoYEV4aXN0LCB4LCB4dHksIGJvZHkpIC0+IGJlZ2luXG4gICAgICAgIGxldCBnb2FsID0gUHJvb2YuYnlpZCBwciBpZCBpblxuXG4gICAgICAgIEZvLkZvcm0uZXJlY2hlY2sgZ29hbC5nX2VudiBldHkgZTtcbiAgICAgICAgaWYgbm90IChGb3JtLnRfZXF1YWwgZ29hbC5nX2VudiB4dHkgZXR5KSB0aGVuXG4gICAgICAgICAgcmFpc2UgVGFjdGljTm90QXBwbGljYWJsZTsgXG4gICAgICAgIGxldCBnb2FsID0gRm8uRm9ybS5TdWJzdC5mX2FwcGx5MSAoeCwgMCkgZSBib2R5IGluXG4gICAgICAgIFByb29mLnNwcm9ncmVzcyBwciBpZCBwdGVybSBbW10sIGdvYWxdXG4gICAgICBlbmRcblxuICAgIHwgXyAtPiByYWlzZSBUYWN0aWNOb3RBcHBsaWNhYmxlXG5cbiAgdHlwZSBwbm9kZSArPSBPckRyb3Agb2YgSGFuZGxlLnRcblxuICBsZXQgb3JfZHJvcCAoaCA6IEhhbmRsZS50KSAoKHByLCBpZCkgOiB0YXJnKSBobCA9XG4gICAgbGV0IGdsICAgPSBQcm9vZi5ieWlkIHByIGlkIGluXG4gICAgbGV0IF9oeSAgPSAoUHJvb2YuSHlwcy5ieWlkIGdsLmdfaHlwcyBoKS5oX2Zvcm0gaW5cbiAgICBsZXQgX2dsbCA9IEZvcm0uZmxhdHRlbl9kaXNqdW5jdGlvbnMgZ2wuZ19nb2FsIGluXG4gICAgUHJvb2Yuc3Byb2dyZXNzIHByIGlkIChPckRyb3AgaWQpIGhsXG5cbiAgdHlwZSBwbm9kZSArPSBBbmREcm9wIG9mIEhhbmRsZS50XG5cbiAgbGV0IGFuZF9kcm9wIChoIDogSGFuZGxlLnQpICgocHIsIGlkKSA6IHRhcmcpID1cbiAgICBsZXQgZ2wgID0gUHJvb2YuYnlpZCBwciBpZCBpblxuICAgIGxldCBoeSAgPSAoUHJvb2YuSHlwcy5ieWlkIGdsLmdfaHlwcyBoKS5oX2Zvcm0gaW5cbiAgICBsZXQgZ2xsID0gRm9ybS5mbGF0dGVuX2Nvbmp1bmN0aW9ucyBnbC5nX2dvYWwgaW5cbiAgICBsZXQgbmcgID0gRm9ybS5mX2FuZHMgKHJlbW92ZV9mb3JtIGdsLmdfZW52IGh5IGdsbCkgaW5cblxuICAgIFByb29mLnNwcm9ncmVzcyBwciBpZCAoQW5kRHJvcCBpZCkgW1tOb25lLCBbXV0sIG5nXVxuXG4gIHR5cGUgcG5vZGUgKz0gVEVsaW0gb2YgSGFuZGxlLnRcblxuICBsZXQgY29yZV9lbGltIChoIDogSGFuZGxlLnQpICgocHIsIGlkKSA6IHRhcmcpID1cbiAgICBsZXQgcmVzdWx0ID0gcmVmIChbXSkgaW4gXG4gICAgbGV0IGdsID0gUHJvb2YuYnlpZCBwciBpZCBpblxuICAgIGxldCBoeXAgPSAoUHJvb2YuSHlwcy5ieWlkIGdsLmdfaHlwcyBoKS5oX2Zvcm0gaW5cblxuICAgIGJlZ2luXG4gICAgICBpZiBGb3JtLmZfZXF1YWwgZ2wuZ19lbnYgaHlwIGdsLmdfZ29hbFxuICAgICAgdGhlbiByZXN1bHQgOj0gWyhURWxpbSBpZCksIGBTIFtdXVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgcHJlLCBoeSwgcyA9IHBydW5lX3ByZW1pc3Nlc19mYSBoeXAgaW5cbiAgICAgICAgYmVnaW4gbWF0Y2ggRm9ybS5mX3VuaWZ5IGdsLmdfZW52IExFbnYuZW1wdHkgcyBbKGh5LCBnbC5nX2dvYWwpXSB3aXRoXG4gICAgICAgIHwgU29tZSBzIHdoZW4gRm9ybS5TdWJzdC5pc19jb21wbGV0ZSBzIC0+ICBcbiAgICAgICAgICAgIGxldCBwcmVzID0gTGlzdC5tYXBcbiAgICAgICAgICAgIChmdW4gKGksIHgpIC0+IFtTb21lIGgsIFtdXSwgKEZvcm0uU3Vic3QuZl9pdGVyIHMgaSB4KSkgcHJlIGluXG4gICAgICAgICAgICByZXN1bHQgOj0gICgoVEVsaW0gaWQpLCBgUyBwcmVzKTo6IXJlc3VsdFxuICAgICAgICB8IFNvbWUgXyAtPiAoKSAoKiBcImluY29tcGxldGUgbWF0Y2hcIiAqKVxuICAgICAgICB8IF8gLT4gKCk7XG4gICAgICAgIGVuZDtcbiAgICAgICAgbGV0IHN1YnMgPSBMaXN0Lm1hcCAoZnVuIChfLCBmKSAtPiBbU29tZSBoLCBbXV0sIGYpIHByZSBpblxuICAgICAgICBiZWdpbiBtYXRjaCBoeSB3aXRoXG4gICAgICAgIHwgRkNvbm4gKGBBbmQsIFtmMTsgZjJdKSAtPlxuICAgICAgICAgICAgcmVzdWx0IDo9ICgoVEVsaW0gaWQpLCBgUyAoc3VicyBAIFtbU29tZSBoLCBbZjE7IGYyXV0sIGdsLmdfZ29hbF0pKSA6OiAhcmVzdWx0XG4gICAgICAgICgqIGNsZWFyICopIFxuICAgICAgICB8IEZDb25uIChgT3IsIFtmMTsgZjJdKSAtPlxuICAgICAgICAgICAgcmVzdWx0IDo9ICgoVEVsaW0gaWQpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgYFMgKHN1YnMgQCBbW1NvbWUgaCwgW2YxXV0sIGdsLmdfZ29hbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbU29tZSBoLCBbZjJdXSwgZ2wuZ19nb2FsXSkpIDo6ICFyZXN1bHRcbiAgICAgICAgfCBGQ29ubiAoYEVxdWl2LCBbZjE7IGYyXSkgLT5cbiAgICAgICAgICAgIHJlc3VsdCA6PSAoKFRFbGltIGlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgYFMgKHN1YnMgQCBbW1NvbWUgaCwgW0Zvcm0uZl9pbXAgZjEgZjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3JtLmZfaW1wIGYyIGYxXV0sIGdsLmdfZ29hbF0pKSA6OiAhcmVzdWx0XG4gICAgICAgIHwgRkNvbm4gKGBOb3QsIFtmXSkgLT5cbiAgICAgICAgICAgIHJlc3VsdCA6PSAoKFRFbGltIGlkKSwgXG4gICAgICAgICAgICAgICAgICAgICAgIGBTIChzdWJzIEAgW1tTb21lIGgsIFtdXSwgZl0pKSA6OiAhcmVzdWx0XG4gICAgICAgIHwgRkZhbHNlIC0+IHJlc3VsdCA6PSAoKFRFbGltIGlkKSwgYFMgc3VicykgOjogIXJlc3VsdFxuICAgICAgICB8IEZUcnVlIC0+IHJlc3VsdCA6PSAoKFRFbGltIGlkKSwgYFMgKHN1YnMgQCBbW1NvbWUgaCwgW11dLCBnbC5nX2dvYWxdKSkgOjogIXJlc3VsdFxuICAgICAgICB8IEZCaW5kIChgRXhpc3QsIHgsIHR5LCBmKSAtPlxuICAgICAgICAgICAgbGV0IF8gPSAocHIsIGlkKSB8PiB0aGVuX3RhY1xuICAgICAgICAgICAgICAoYWRkX2xvY2FsICh4LCB0eSwgTm9uZSkpXG4gICAgICAgICAgICAgIChmdW4gKHByLCBpZCkgLT5cbiAgICAgICAgICAgICAgICBsZXQgZ29hbCA9IFByb29mLmJ5aWQgcHIgaWQgaW5cbiAgICAgICAgICAgICAgICBsZXQgZ19oeXBzID0gUHJvb2YuSHlwcy5yZW1vdmUgZ29hbC5nX2h5cHMgaCBpblxuICAgICAgICAgICAgICAgIGxldCBnX2h5cHMgPSBQcm9vZi4oSHlwcy5hZGQgZ19oeXBzIGggKG1rX2h5cCBmKSkgaW5cbiAgICAgICAgICAgICAgICBsZXQgZ29hbCA9IFByb29mLnsgZ29hbCB3aXRoIGdfaHlwcyB9IGluXG4gICAgICAgICAgICAgICAgcmVzdWx0IDo9ICgoVEVsaW0gaWQpLCBgWCBbZ29hbF0pIDo6ICFyZXN1bHQ7IHByKVxuICAgICAgICAgICAgaW4gKClcbiAgICAgICAgfCBfIC0+ICgpXG4gICAgICAgIGVuZDtcbiAgICAgICAgbGV0IF8gLCBnb2FsLCBzID0gcHJ1bmVfcHJlbWlzc2VzX2V4IGdsLmdfZ29hbCBpblxuICAgICAgICBsZXQgcHJlLCBoeSA9IHBydW5lX3ByZW1pc3NlcyBoeXAgaW5cbiAgICAgICAgbGV0IHByZSA9IExpc3QubWFwIChmdW4geCAtPiBbKFNvbWUgaCksIFtdXSx4KSBwcmUgaW5cbiAgICAgICAgYmVnaW4gbWF0Y2ggRm9ybS5mX3VuaWZ5IGdsLmdfZW52IExFbnYuZW1wdHkgcyBbKGh5LCBnb2FsKV0gd2l0aFxuICAgICAgICB8IFNvbWUgcyB3aGVuIEZvcm0uU3Vic3QuaXNfY29tcGxldGUgcyAtPlxuICAgICAgICAgICAgcmVzdWx0IDo9ICgoVEVsaW0gaWQpLCBgUyBwcmUpIDo6ICFyZXN1bHRcbiAgICAgICAgfCBTb21lIF8gLT4gKCkgKCogZmFpbHdpdGggXCJpbmNvbXBsZXRlIGV4IG1hdGNoXCIgKilcbiAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICBtYXRjaCBnb2FsIHdpdGhcbiAgICAgICAgICAgIHwgRkNvbm4gKGBPciAsIF8pIC0+XG4gICAgICAgICAgICAgIGxldCBnbGwgPSBGb3JtLmZsYXR0ZW5fZGlzanVuY3Rpb25zIGdvYWwgaW5cbiAgICAgICAgICAgICAgbGV0IHJlYyBhdXggPSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIHwgW10gLT4gZmFsc2VcbiAgICAgICAgICAgICAgICB8IGc6OmwgLT4gYmVnaW4gbWF0Y2ggRm9ybS5mX3VuaWZ5IGdsLmdfZW52IExFbnYuZW1wdHkgcyBbKGh5cCwgZyldIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgfCBTb21lIHMgd2hlbiBGb3JtLlN1YnN0LmlzX2NvbXBsZXRlIHMgLT4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB8IF8gLT4gYXV4IGxcbiAgICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICBpbiBcbiAgICAgICAgICAgICAgaWYgYXV4IGdsbCBcbiAgICAgICAgICAgICAgdGhlbiByZXN1bHQgOj0gKChURWxpbSBpZCksIGBTIFtdKSA6OiAhcmVzdWx0XG4gICAgICAgICAgICAgIGVsc2UgKClcbiAgICAgICAgICAgIHwgXyAtPiAoKVxuICAgICAgICBlbmQ7XG4gICAgICBlbmQ7XG4gICAgIXJlc3VsdFxuXG4gIGxldCBwZXJmb3JtID9jbGVhciBsIHByIGlkID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgKHQsIGBTIGwpOjpfIC0+IFByb29mLnNwcm9ncmVzcyA/Y2xlYXIgcHIgaWQgdCBsXG4gICAgICB8ICh0LCBgWCBsKTo6XyAtPiBQcm9vZi54cHJvZ3Jlc3MgcHIgaWQgdCBsXG4gICAgICB8IF8gLT4gcmFpc2UgVGFjdGljTm90QXBwbGljYWJsZVxuICBcbiAgbGV0IGVsaW0gP2NsZWFyIChoIDogSGFuZGxlLnQpICgocHIsIGlkKSA6IHRhcmcpID1cbiAgICBwZXJmb3JtID9jbGVhciAoY29yZV9lbGltIGggKHByLCBpZCkpIHByIGlkXG4gIFxuICBcbiAgdHlwZSBwbm9kZSArPSBUSW5kXG5cbiAgbGV0IGluZHVjdGlvbiAoaCA6IEhhbmRsZS50KSAoKHByLCBpZCkgOiB0YXJnKSA9XG4gICAgbGV0IGdvYWwgPSBQcm9vZi5ieWlkIHByIGlkIGluXG4gICAgbGV0IGVudiA9IGdvYWwuZ19lbnYgaW5cbiAgICBcbiAgICBsZXQgKChuLCBfKSBhcyB4LCAoXywgXykpID0gVmFycy5ieWlkIGVudiAoSGFuZGxlLnRvaW50IGgpIHw+IE9wdGlvbi5nZXQgaW5cbiAgICBcbiAgICBsZXQgYmFzZV9jYXNlID0geyBnb2FsIHdpdGggZ19lbnYgPVxuICAgICAgVmFycy5tb2RpZnkgZW52ICh4LCBFbnYuKG5hdCwgU29tZSBFbnYuemVybykpfSBpblxuXG4gICAgbGV0IGluZF9jYXNlID1cbiAgICAgIGxldCBuID0gVmFycy5mcmVzaCBlbnYgfmJhc2VuYW1lOm4gKCkgaW5cbiAgICAgIHsgZ29hbCB3aXRoXG4gICAgICAgICAgZ19lbnYgPSBiZWdpblxuICAgICAgICAgICAgICBsZXQgZW52ID0gVmFycy5wdXNoIGVudiAobiwgKEVudi5uYXQsIE5vbmUpKSBpblxuICAgICAgICAgICAgICBWYXJzLm1vZGlmeSBlbnYgKHgsIEVudi4obmF0LCBTb21lIChzdWNjIChFVmFyIChuLCAwKSkpKSlcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICBcbiAgICAgICAgICBnX2h5cHMgPVxuICAgICAgICAgICAgbGV0IGluZGggPSBGb3JtLlN1YnN0LmZfYXBwbHkxIHggKEVWYXIgKG4sIDApKSBnb2FsLmdfZ29hbCBpblxuICAgICAgICAgICAgUHJvb2YuSHlwcy5hZGQgZ29hbC5nX2h5cHMgKEhhbmRsZS5mcmVzaCAoKSkgKFByb29mLm1rX2h5cCBpbmRoKSB9IGluXG4gICAgXG4gICAgUHJvb2YueHByb2dyZXNzIHByIGlkIFRJbmQgW2Jhc2VfY2FzZTsgaW5kX2Nhc2VdXG5cbiAgICBcbiAgbGV0IGl2YXJpYW50cyAoKHByLCBpZCkgOiB0YXJnKSA9XG4gICAgbWF0Y2ggKFByb29mLmJ5aWQgcHIgaWQpLmdfZ29hbCB3aXRoXG4gICAgfCBGUHJlZCAoXCJfRVFcIiwgXykgLT4gW1wiRVEtaW50cm9cIl1cbiAgICB8IEZUcnVlIC0+IFtcIlRydWUtaW50cm9cIl1cbiAgICB8IEZDb25uIChgQW5kICAsIF8pIC0+IFtcIkFuZC1pbnRyb1wiXVxuICAgIHwgRkNvbm4gKGBPciAgICwgXykgYXMgZiAtPlxuICAgICAgICBsZXQgZmwgPSBGb3JtLmZsYXR0ZW5fZGlzanVuY3Rpb25zIGYgaW5cbiAgICAgICAgTGlzdC5tYXBpIChmdW4gaSBfIC0+IFwiT3ItaW50cm8tXCJeKHN0cmluZ19vZl9pbnQgaSkpIGZsXG4gICAgfCBGQ29ubiAoYEltcCAgLCBfKSAtPiBbXCJJbXAtaW50cm9cIl1cbiAgICB8IEZDb25uIChgRXF1aXYsIF8pIC0+IFtcIkVxdWl2LWludHJvXCJdXG4gICAgfCBGQ29ubiAoYE5vdCAgLCBfKSAtPiBbXCJOb3QtaW50cm9cIl1cbiAgICB8IEZCaW5kIChgRm9yYWxsLCBfLCBfLCBfKSAtPiBbXCJGQS1pbnRyb1wiXSBcbiAgICB8IEZCaW5kIChgRXhpc3QsIF8sIF8sIF8pIC0+IFtcIkV4LWludHJvXCJdXG5cbiAgICB8IF8gLT4gW11cblxuICB0eXBlIHBub2RlICs9IFRGb3J3YXJkIG9mIEhhbmRsZS50ICogSGFuZGxlLnRcblxuICBsZXQgY29yZV9mb3J3YXJkIChoc3JjLCBoZHN0LCBwLCBzKSAoKHByLCBpZCkgOiB0YXJnKSAgPVxuICAgIGxldCBnbCAgID0gUHJvb2YuYnlpZCBwciBpZCBpblxuICAgIGxldCBfc3JjID0gKFByb29mLkh5cHMuYnlpZCBnbC5nX2h5cHMgaHNyYykuaF9mb3JtIGluXG4gICAgbGV0IGRzdCAgPSAoUHJvb2YuSHlwcy5ieWlkIGdsLmdfaHlwcyBoZHN0KS5oX2Zvcm0gaW5cblxuICAgICgqIEhlcmUgd2UgZXZlbnR1YWxseSBzaG91bGQgaGF2ZSB0aGUgY2FsbCB0byB0aGUgcHJvb2YgdGFjdGljcyAqKVxuICAgIGxldCByZWMgYnVpbGRfZGVzdCA9IGZ1bmN0aW9uXG4gICAgICB8ICgoRkJpbmQgKGBGb3JhbGwsIHgsIHR5LCBmKSksIDA6OnAsICgoXywgU2ZsZXgpOjpzKSkgLT5cbiAgICAgICAgICBGQmluZCAoYEZvcmFsbCwgeCwgdHksIGJ1aWxkX2Rlc3QgKGYsIHAsIHMpKVxuICAgICAgfCAoKEZCaW5kIChgRm9yYWxsLCB4LCBfLCBmKSksIDA6OnAsICgoXywgKFNib3VuZCBlKSk6OnMpKSAtPlxuICAgICAgICAgIGJ1aWxkX2Rlc3QgKChGb3JtLlN1YnN0LmZfYXBwbHkxICh4LCAwKSBlIGYpLCBwLCBzKVxuICAgICAgfCAoRkNvbm4gKGBJbXAsIFtfOyBmMl0pLCAoMDo6XyksIHMpIC0+XG4gICAgICAgICAgRm9ybS5TdWJzdC5mX2FwcGx5IChGb3JtLlN1YnN0Lm9mbGlzdCBzKSBmMlxuICAgICAgfCAoRkNvbm4gKGBJbXAsIFtmMTsgZjJdKSwgKDE6OnApLCBzKSAtPlxuICAgICAgICAgIEZDb25uKGBJbXAsIFtGb3JtLlN1YnN0LmZfYXBwbHkgKEZvcm0uU3Vic3Qub2ZsaXN0IHMpIGYxO1xuICAgICAgICAgIGJ1aWxkX2Rlc3QgKGYyLCBwLCBzKV0pXG4gICAgICB8IF8gLT4gZmFpbHdpdGggXCJjYW5ub3QgYnVpbGQgZm9yd2FyZFwiXG4gICAgaW5cbiAgICBsZXQgbmYgPSBidWlsZF9kZXN0IChkc3QsIHAsIHMpIGluXG5cbiAgICBbIChURm9yd2FyZCAoaHNyYywgaGRzdCkpLCBgUyBbW1NvbWUgaGRzdCwgW25mXV0sIGdsLmdfZ29hbF0gXVxuXG4gIGxldCBmb3J3YXJkIChoc3JjLCBoZHN0LCBwLCBzKSAoKHByLCBpZCkgOiB0YXJnKSA9XG4gICAgcGVyZm9ybSAoY29yZV9mb3J3YXJkIChoc3JjLCBoZHN0LCBwLCBGb3JtLlN1YnN0LmFzbGlzdCBzKSAocHIsIGlkKSkgcHIgaWQgXG5cbiAgdHlwZSBwbm9kZSArPSBUQ3V0IG9mIEZvLmZvcm0gKiBIYW5kbGUudFxuXG4gIGxldCBjdXQgKGZvcm0gOiBmb3JtKSAoKHByb29mLCBoZCkgOiB0YXJnKSA9XG4gICAgbGV0IGdvYWwgPSBQcm9vZi5ieWlkIHByb29mIGhkIGluXG5cbiAgICBGby5Gb3JtLnJlY2hlY2sgZ29hbC5nX2VudiBmb3JtO1xuXG4gICAgbGV0IHN1YnMgPSBbW10sIGZvcm1dIGluXG4gICAgXG4gICAgUHJvb2Yuc3Byb2dyZXNzIHByb29mIGhkIChUQ3V0IChmb3JtLCBoZCkpXG4gICAgICAoc3VicyBAIFtbTm9uZSwgW2Zvcm1dXSwgZ29hbC5nX2dvYWxdKVxuXG4gIHR5cGUgcG5vZGUgKz0gVEFzc3VtZSBvZiBGby5mb3JtICogSGFuZGxlLnRcblxuICBsZXQgYXNzdW1lIChmb3JtIDogZm9ybSkgKChwcm9vZiwgaGQpIDogdGFyZykgPVxuICAgIGxldCBnb2FsID0gUHJvb2YuYnlpZCBwcm9vZiBoZCBpblxuXG4gICAgRm8uRm9ybS5yZWNoZWNrIGdvYWwuZ19lbnYgZm9ybTtcbiAgICBcbiAgICBQcm9vZi5zcHJvZ3Jlc3MgcHJvb2YgaGQgKFRBc3N1bWUgKGZvcm0sIGhkKSlcbiAgICAgIChbW05vbmUsIFtmb3JtXV0sIGdvYWwuZ19nb2FsXSlcblxuICB0eXBlIHBub2RlICs9IFRHZW5lcmFsaXplIG9mIEhhbmRsZS50XG5cbiAgbGV0IGdlbmVyYWxpemUgKGhpZCA6IEhhbmRsZS50KSAoKHByb29mLCBpZCkgOiB0YXJnKSA9XG4gICAgbGV0IGdvYWwgPSBQcm9vZi5ieWlkIHByb29mIGlkIGluXG4gICAgbGV0IGh5cCAgPSAoUHJvb2YuSHlwcy5ieWlkIGdvYWwuZ19oeXBzIGhpZCkuaF9mb3JtIGluXG5cbiAgICBQcm9vZi54cHJvZ3Jlc3MgcHJvb2YgaWQgKFRHZW5lcmFsaXplIGhpZClcbiAgICAgIFt7IGdfZW52ICA9IGdvYWwuZ19lbnY7XG4gICAgICAgICBnX2h5cHMgPSBQcm9vZi5IeXBzLnJlbW92ZSBnb2FsLmdfaHlwcyBoaWQ7XG4gICAgICAgICBnX2dvYWwgPSBGQ29ubiAoYEltcCwgW2h5cDsgZ29hbC5nX2dvYWxdKSB9IF1cblxuICB0eXBlIHBub2RlICs9IFRNb3ZlIG9mIEhhbmRsZS50ICogSGFuZGxlLnQgb3B0aW9uXG5cbiAgbGV0IG1vdmUgKGZyb20gOiBIYW5kbGUudCkgKGJlZm9yZSA6IEhhbmRsZS50IG9wdGlvbikgKChwcm9vZiwgaWQpIDogdGFyZykgPVxuICAgIGxldCBnb2FsICAgID0gUHJvb2YuYnlpZCBwcm9vZiBpZCBpblxuICAgIGxldCBfZnJvbSAgID0gUHJvb2YuSHlwcy5ieWlkIGdvYWwuZ19oeXBzIGluICgqIEtFRVAgKilcbiAgICBsZXQgX2JlZm9yZSA9IE9wdGlvbi5tYXAgKFByb29mLkh5cHMuYnlpZCBnb2FsLmdfaHlwcykgYmVmb3JlIGluICgqIEtFRVAgKilcbiAgICBsZXQgaHlwcyAgICA9IFByb29mLkh5cHMubW92ZSBnb2FsLmdfaHlwcyBmcm9tIGJlZm9yZSBpblxuXG4gICAgUHJvb2YueHByb2dyZXNzIHByb29mIGlkIChUTW92ZSAoZnJvbSwgYmVmb3JlKSlcbiAgICAgIFt7IGdvYWwgd2l0aCBnX2h5cHMgPSBoeXBzIH1dXG5cbiAgdHlwZSBwbm9kZSArPSBURHVwbGljYXRlIG9mIEhhbmRsZS50XG4gIFxuICBsZXQgZHVwbGljYXRlIChoZCA6IEhhbmRsZS50KSA6IHRhY3RpYyA9XG4gICAgZnVuIChwcm9vZiwgaWQpIC0+XG5cbiAgICBsZXQgZ29hbCA9IFByb29mLmJ5aWQgcHJvb2YgaWQgaW5cbiAgICBsZXQgZm9ybSA9IChQcm9vZi5IeXBzLmJ5aWQgZ29hbC5nX2h5cHMgaGQpLmhfZm9ybSBpblxuICAgIGxldCBzdWJnb2FsID0gW1NvbWUgaGQsIFtmb3JtXV0sIGdvYWwuZ19nb2FsIGluXG5cbiAgICBQcm9vZi5zcHJvZ3Jlc3MgcHJvb2YgaWQgKFREdXBsaWNhdGUgaGQpIFtzdWJnb2FsXVxuICBcblxuICAoKiogVGhlIFtjbG9zZV93aXRoX3VuaXRdIHRhY3RpYyB0cmllcyB0byBjbG9zZSB0aGUgZ29hbCBlaXRoZXIgd2l0aFxuICAgICAgdGhlIGZhbHNpdHkgZWxpbWluYXRpb24gcnVsZSwgb3IgdGhlIHRydXRoIGludHJvZHVjdGlvbiBydWxlLiAqKVxuICBsZXQgY2xvc2Vfd2l0aF91bml0IDogdGFjdGljID1cbiAgICBmdW4gKHByb29mLCBnX2lkIGFzIHRhcmcpIC0+XG5cbiAgICBsZXQgb3BlbiBQcm9vZiBpblxuXG4gICAgbGV0IGdvYWwgPSBieWlkIHByb29mIGdfaWQgaW5cblxuICAgICgqIFRydXRoIGludHJvICopXG4gICAgaWYgZ29hbC5nX2dvYWwgPSBGVHJ1ZSB0aGVuIGludHJvIHRhcmcgZWxzZVxuXG4gICAgKCogRmFsc2l0eSBlbGltICopXG4gICAgSHlwcy50b19saXN0IGdvYWwuZ19oeXBzXG4gICAgfD5cbiAgICBMaXN0LmZpbmRfbWFwX29wdFxuICAgICAgKGZ1biAoaGQsIHsgaF9mb3JtID0gZjsgXyB9KSAtPlxuICAgICAgIGlmIGYgPSBGRmFsc2UgdGhlbiBTb21lIChlbGltIGhkIHRhcmcpIGVsc2UgTm9uZSlcbiAgICB8PlxuICAgIE9wdGlvbi5kZWZhdWx0IHByb29mXG4gICAgXG5cbiAgKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbiAgKCoqIEl0ZW1zICopXG5cblxuICB0eXBlIGl0ZW0gPSBbXG4gICAgfCBgQyBvZiBmb3JtXG4gICAgfCBgSCBvZiBIYW5kbGUudCAqIFByb29mLmh5cFxuICAgIHwgYFYgb2Ygdm5hbWUgKiBidmFyXG4gIF1cbiAgXG5cbiAgbGV0IGZvcm1fb2ZfaXRlbSA6IGl0ZW0gLT4gZm9ybSA9IGZ1bmN0aW9uXG4gICAgfCBgQyBmIHwgYEggKF8sIFByb29mLnsgaF9mb3JtID0gZjsgXyB9KSAtPiBmXG4gICAgfCBfIC0+IHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiRXhwZWN0ZWQgYSBmb3JtdWxhIGl0ZW1cIilcbiAgICBcbiAgbGV0IGV4cHJfb2ZfaXRlbSA/KHdoZXJlID0gYEJvZHkpIDogaXRlbSAtPiBleHByID0gZnVuY3Rpb25cbiAgICB8IGBWICh4LCAoXywgYikpIC0+XG4gICAgICAgIGJlZ2luIG1hdGNoIHdoZXJlIHdpdGhcbiAgICAgICAgfCBgSGVhZCAtPiBFVmFyIHhcbiAgICAgICAgfCBgQm9keSAtPiBPcHRpb24uZ2V0X2V4biBiXG4gICAgICAgICAgICAoSW52YWxpZF9hcmd1bWVudCBcIkV4cGVjdGVkIGEgbG9jYWwgdmFyaWFibGUgd2l0aCBhIGJvZHlcIilcbiAgICAgICAgZW5kXG4gICAgfCBfIC0+IHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiRXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiBpdGVtXCIpXG4gIFxuICBsZXQgdGVybV9vZl9pdGVtID93aGVyZSBpdCA9XG4gICAgdHJ5IGBGIChmb3JtX29mX2l0ZW0gaXQpXG4gICAgd2l0aCBJbnZhbGlkX2FyZ3VtZW50IF8gLT5cbiAgICAgIHRyeSBgRSAoZXhwcl9vZl9pdGVtID93aGVyZSBpdClcbiAgICAgIHdpdGggSW52YWxpZF9hcmd1bWVudCBfIC0+XG4gICAgICAgIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiRXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiBvciBmb3JtdWxhIGl0ZW1cIikgICAgICBcblxuXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG4gICgqKiBQYXRocyAqKVxuXG5cbiAgdHlwZSBwYXRoICAgPSBzdHJpbmdcbiAgdHlwZSBwa2luZCAgPSBbYEh5cCB8IGBDb25jbCB8IGBWYXIgb2YgW2BIZWFkIHwgYEJvZHldXVxuICB0eXBlIGN0eHQgICA9IHsga2luZCA6IHBraW5kOyBoYW5kbGUgOiBpbnQgfVxuICB0eXBlIGlwYXRoICA9IHsgcm9vdCA6IGludDsgY3R4dCA6IGN0eHQ7IHN1YiA6IGludCBsaXN0OyB9XG5cbiAgZXhjZXB0aW9uIEludmFsaWRQYXRoIG9mIHBhdGhcbiAgZXhjZXB0aW9uIEludmFsaWRTdWJGb3JtUGF0aCBvZiBpbnQgbGlzdFxuICBleGNlcHRpb24gSW52YWxpZFN1YkV4cHJQYXRoIG9mIGludCBsaXN0XG5cbiAgbGV0IGRpcmVjdF9zdWJ0ZXJtICh0IDogdGVybSkgKGkgOiBpbnQpIDogdGVybSA9XG4gICAgbGV0IG9wZW4gRm9ybSBpblxuICAgIHRyeSBMaXN0LmF0IChkaXJlY3Rfc3VidGVybXMgdCkgaVxuICAgIHdpdGggSW52YWxpZF9hcmd1bWVudCBfIC0+XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgYEYgRlByZWQgXyB8IGBFIF8gLT4gcmFpc2UgKEludmFsaWRTdWJFeHByUGF0aCBbaV0pXG4gICAgICB8IGBGIF8gLT4gcmFpc2UgKEludmFsaWRTdWJGb3JtUGF0aCBbaV0pXG5cbiAgbGV0IHN1YnRlcm0gKHQgOiB0ZXJtKSAocCA6IGludCBsaXN0KSA9XG4gICAgdHJ5IExpc3QuZm9sZF9sZWZ0IGRpcmVjdF9zdWJ0ZXJtIHQgcFxuICAgIHdpdGggSW52YWxpZFN1YkZvcm1QYXRoIF8gLT4gcmFpc2UgKEludmFsaWRTdWJGb3JtUGF0aCBwKVxuICAgICAgIHwgSW52YWxpZFN1YkV4cHJQYXRoIF8gLT4gcmFpc2UgKEludmFsaWRTdWJFeHByUGF0aCBwKVxuICAgICAgXG4gIGxldCBtb2RpZnlfZGlyZWN0X3N1YnRlcm0gKGYgOiB0ZXJtIC0+IHRlcm0pICh0IDogdGVybSkgKGkgOiBpbnQpIDogdGVybSA9XG4gICAgbGV0IG9wZW4gRm9ybSBpblxuICAgIHRyeVxuICAgICAgTGlzdC5tb2RpZnlfYXQgaSBmIChkaXJlY3Rfc3VidGVybXMgdCkgfD5cbiAgICAgIG1vZGlmeV9kaXJlY3Rfc3VidGVybXMgdFxuICAgIHdpdGggSW52YWxpZF9hcmd1bWVudCBfIC0+XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgYEYgRlByZWQgXyB8IGBFIF8gLT4gcmFpc2UgKEludmFsaWRTdWJFeHByUGF0aCBbaV0pXG4gICAgICB8IGBGIF8gLT4gcmFpc2UgKEludmFsaWRTdWJGb3JtUGF0aCBbaV0pXG5cbiAgbGV0IG1vZGlmeV9zdWJ0ZXJtIChmIDogJ2EgLT4gdGVybSAtPiB0ZXJtKSAoYWNjIDogaW50IC0+IHRlcm0gLT4gJ2EgLT4gJ2EpXG4gICAgICAgICAgICAgICAgICAgICAoYSA6ICdhKSAodCA6IHRlcm0pIChwIDogaW50IGxpc3QpIDogdGVybSA9XG4gICAgbGV0IHJlYyBhdXggYSB0ID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gZiBhIHRcbiAgICAgIHwgaSA6OiBwIC0+XG4gICAgICAgICAgbGV0IHN1YnQgPSBhdXggKGFjYyBpIHQgYSkgKGRpcmVjdF9zdWJ0ZXJtIHQgaSkgcCBpblxuICAgICAgICAgIG1vZGlmeV9kaXJlY3Rfc3VidGVybSAoZnVuIF8gLT4gc3VidCkgdCBpXG4gICAgaW4gYXV4IGEgdCBwXG4gIFxuICAoKiogW3Jld3JpdGVfc3VidGVybV9hbGwgZW52IHJlZCByZXMgdCBzdWJdIHJld3JpdGVzIGFsbCBvY2N1cnJlbmNlcyBvZiBbcmVkXVxuICAgICAgaW4gdGhlIHN1YnRlcm0gb2YgW3RdIGF0IHN1YnBhdGggW3N1Yl0gaW50byBbcmVzXSwgc2hpZnRpbmcgdmFyaWFibGVzIGluXG4gICAgICBbcmVkXSBhbmQgW3Jlc10gd2hlbmV2ZXIgYSBiaW5kZXIgaXMgZW5jb3VudGVyZWQgYWxvbmcgdGhlIHBhdGguICopXG4gIGxldCByZXdyaXRlX3N1YnRlcm1fYWxsIGVudiByZWQgcmVzID1cbiAgICBtb2RpZnlfc3VidGVybVxuICAgICAgKGZ1biAocmVkLCByZXMpIC0+IEZvcm0ucmV3cml0ZSBlbnYgcmVkIHJlcylcbiAgICAgIChmdW4gXyB0IChyZWQsIHJlcykgLT4gRm9ybS4oc2hpZnRfdW5kZXIgdCByZWQsIHNoaWZ0X3VuZGVyIHQgcmVzKSlcbiAgICAgIChyZWQsIHJlcylcblxuICAoKiogW3Jld3JpdGVfc3VidGVybSByZXMgdCBzdWJdIHJld3JpdGVzIHRoZSBzdWJ0ZXJtIG9mIFt0XSBhdCBzdWJwYXRoXG4gICAgICBbc3ViXSBpbnRvIFtyZXNdLCBzaGlmdGluZyB2YXJpYWJsZXMgaW4gW3Jlc10gd2hlbmV2ZXIgYSBiaW5kZXIgaXNcbiAgICAgIGVuY291bnRlcmVkIGFsb25nIHRoZSBwYXRoLiAqKVxuICBsZXQgcmV3cml0ZV9zdWJ0ZXJtIHJlcyA9XG4gICAgbW9kaWZ5X3N1YnRlcm1cbiAgICAgIChmdW4gcmVzIF8gLT4gcmVzKVxuICAgICAgKGZ1biBfIHQgcmVzIC0+IEZvcm0uc2hpZnRfdW5kZXIgdCByZXMpXG4gICAgICByZXNcbiAgXG4gIGxldCBzdWJmb3JtIChmIDogZm9ybSkgKHAgOiBpbnQgbGlzdCkgPVxuICAgIG1hdGNoIHN1YnRlcm0gKGBGIGYpIHAgd2l0aFxuICAgIHwgYEYgZiAtPiBmXG4gICAgfCBfIC0+IHJhaXNlIChJbnZhbGlkU3ViRm9ybVBhdGggcClcblxuICBsZXQgc3ViZXhwciAodCA6IHRlcm0pIChwIDogaW50IGxpc3QpID1cbiAgICBtYXRjaCBzdWJ0ZXJtIHQgcCB3aXRoXG4gICAgfCBgRSBlIC0+IGVcbiAgICB8IF8gLT4gcmFpc2UgKEludmFsaWRTdWJFeHByUGF0aCBwKVxuICBcblxuICBsZXQgcmVidWlsZF9wYXRoIGkgPVxuICAgIGxldCByZWMgYXV4IGwgPSBmdW5jdGlvblxuICAgICAgfCAwIC0+IDA6OmxcbiAgICAgIHwgaSAtPiBhdXggKDE6OmwpIChpLTEpXG4gICAgaW4gTGlzdC5yZXYgKGF1eCBbXSBpKVxuXG4gIGxldCByZWJ1aWxkX3BhdGhkIGwgaSA9XG4gICAgaWYgaSsxID0gbCB0aGVuIFsxXSBlbHNlXG4gICAgICBcbiAgICBsZXQgcmVjIGF1eCA9IGZ1bmN0aW9uXG4gICAgICB8IDAgLT4gW11cbiAgICAgIHwgaSAtPiAwOjooYXV4IChpLTEpKVxuICAgIGluXG4gICAgaWYgaSA9IDAgdGhlbiAoYXV4IChsLTEpKSBlbHNlXG4gICAgICAoYXV4IChsIC0gaSAtIDEpKUBbMV1cblxuXG4gIGxldCBta19pcGF0aCA/KGN0eHQgOiBjdHh0ID0geyBraW5kID0gYENvbmNsOyBoYW5kbGUgPSAwIH0pXG4gICAgICAgICAgICAgICA/KHN1YiA6IGludCBsaXN0ID0gW10pIChyb290IDogaW50KSA9XG4gICAgeyByb290OyBjdHh0OyBzdWI7IH1cbiAgICBcbiAgXG4gIGxldCBpdGVtX2lwYXRoIHsgcm9vdDsgY3R4dDsgXyB9ID1cbiAgICB7IHJvb3Q7IGN0eHQ7IHN1YiA9IFtdIH1cbiAgXG5cbiAgbGV0IGR1bW15X3BhdGggPSBta19pcGF0aCAwXG5cblxuICBsZXQgY29uY2xfaXBhdGggUHJvb2YueyBnX2lkOyBfIH0gPVxuICAgIG1rX2lwYXRoIChIYW5kbGUudG9pbnQgZ19pZClcblxuICBsZXQgYWxsX2h5cHNfaXBhdGhzIFByb29mLnsgZ19pZDsgZ19wcmVnb2FsIH0gPVxuICAgICgqIEdldCB0aGUgbGlzdCBvZiBoeXBvdGhlc2VzIGhhbmRsZXMgKilcbiAgICBQcm9vZi5IeXBzLmlkcyBnX3ByZWdvYWwuUHJvb2YuZ19oeXBzIHw+XG4gICAgKCogQ3JlYXRlIGEgbGlzdCBvZiBwYXRocyB0byBlYWNoIGh5cG90aGVzaXMgKilcbiAgICBMaXN0Lm1hcCBiZWdpbiBmdW4gaGQgLT5cbiAgICAgIG1rX2lwYXRoIChIYW5kbGUudG9pbnQgZ19pZClcbiAgICAgICAgfmN0eHQ6eyBraW5kID0gYEh5cDsgaGFuZGxlID0gSGFuZGxlLnRvaW50IGhkIH1cbiAgICBlbmRcblxuICBsZXQgYWxsX3ZhcnNfaXBhdGhzID8oaGVhZHMgPSB0cnVlKSBQcm9vZi57IGdfaWQ7IGdfcHJlZ29hbCB9ID1cbiAgICBsZXQgZW52ID0gZ19wcmVnb2FsLlByb29mLmdfZW52IGluXG4gICAgKCogR2V0IHRoZSBsaXN0IG9mIHZhcmlhYmxlIGhhbmRsZXMgKilcbiAgICBlbnYuZW52X2hhbmRsZXMgfD4gQmlNYXAuY29kb21haW4gfD5cbiAgICAoKiBDcmVhdGUgYSBsaXN0IG9mIHBhdGhzIHRvIGVhY2ggdmFyaWFibGUncyBoZWFkIGFuZCBib2R5ICopXG4gICAgTGlzdC5jb25jYXRfbWFwIGJlZ2luIGZ1biBoZCAtPlxuICAgICAgKGlmIGhlYWRzIHRoZW5cbiAgICAgICAgW21rX2lwYXRoIChIYW5kbGUudG9pbnQgZ19pZClcbiAgICAgICAgICB+Y3R4dDp7IGtpbmQgPSBgVmFyIGBIZWFkOyBoYW5kbGUgPSBoZCB9XVxuICAgICAgZWxzZSBbXSlcbiAgICAgIEBcbiAgICAgIG1hdGNoIFZhcnMuYnlpZCBlbnYgaGQgd2l0aFxuICAgICAgfCBTb21lIChfLCAoXywgU29tZSBfKSkgLT5cbiAgICAgICAgICBbbWtfaXBhdGggKEhhbmRsZS50b2ludCBnX2lkKVxuICAgICAgICAgICAgfmN0eHQ6eyBraW5kID0gYFZhciBgQm9keTsgaGFuZGxlID0gaGQgfV1cbiAgICAgIHwgXyAtPiBbXVxuICAgIGVuZFxuXG4gIGxldCBhbGxfaXRlbXNfaXBhdGhzID9oZWFkcyBnb2FsID1cbiAgICBjb25jbF9pcGF0aCBnb2FsIDo6XG4gICAgYWxsX2h5cHNfaXBhdGhzIGdvYWwgQFxuICAgIGFsbF92YXJzX2lwYXRocyA/aGVhZHMgZ29hbFxuXG5cbiAgbGV0IHBraW5kX2NvZGVzIDogKHBraW5kLCBzdHJpbmcpIEJpTWFwLnQgPVxuICAgIExpc3QuZm9sZF9sZWZ0IChmdW4gbSAoYSwgYikgLT4gQmlNYXAuYWRkIGEgYiBtKSBCaU1hcC5lbXB0eSBbXG4gICAgICBgSHlwLCAgXCJIXCI7XG4gICAgICBgQ29uY2wsIFwiQ1wiO1xuICAgICAgKGBWYXIgYEhlYWQpLCBcIlZoXCI7XG4gICAgICAoYFZhciBgQm9keSksIFwiVmJcIjtcbiAgICBdXG5cbiAgbGV0IHN0cmluZ19vZl9wa2luZCA6IHBraW5kIC0+IHN0cmluZyA9XG4gICAgQmlNYXAuZmluZF5+IHBraW5kX2NvZGVzXG4gIFxuICBsZXQgcGtpbmRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IHBraW5kID1cbiAgICBCaU1hcC5maW5kXn4gKEJpTWFwLmludmVyc2UgcGtpbmRfY29kZXMpXG5cblxuICBsZXQgcGF0aF9vZl9pcGF0aCAocCA6IGlwYXRoKSA9XG4gICAgbGV0IHBwX3N1YiA9XG4gICAgICBGb3JtYXQucHBfcHJpbnRfbGlzdFxuICAgICAgICB+cHBfc2VwOihmdW4gZm10ICgpIC0+IEZvcm1hdC5mcHJpbnRmIGZtdCBcIi9cIilcbiAgICAgICAgRm9ybWF0LnBwX3ByaW50X2ludFxuICAgIGluXG4gICAgRm9ybWF0LmFzcHJpbnRmIFwiJWQvJXMjJWQ6JWFcIlxuICAgICAgcC5yb290IChzdHJpbmdfb2ZfcGtpbmQgcC5jdHh0LmtpbmQpIHAuY3R4dC5oYW5kbGUgcHBfc3ViIHAuc3ViXG5cblxuICBsZXQgaXBhdGhfb2ZfcGF0aCAocCA6IHBhdGgpID1cbiAgICBsZXQgcm9vdCwgKHsgaGFuZGxlOyBfIH0gYXMgY3R4dCksIHN1YiA9XG4gICAgICB0cnlcbiAgICAgICAgU2NhbmYuc3NjYW5mIHAgXCIlZC8lc0AjJWQ6JXNcIlxuICAgICAgICAgIChmdW4geDEgeDIgeDMgeDQgLT5cbiAgICAgICAgICAgICh4MSwgeyBraW5kID0gcGtpbmRfb2Zfc3RyaW5nIHgyOyBoYW5kbGUgPSB4MyB9LCB4NCkpXG4gICAgICB3aXRoXG4gICAgICB8IFNjYW5mLlNjYW5fZmFpbHVyZSBfXG4gICAgICB8IE5vdF9mb3VuZFxuICAgICAgfCBFbmRfb2ZfZmlsZSAtPlxuICAgICAgICAgIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IHApIGluXG5cbiAgICBpZiByb290IDwgMCB8fCBoYW5kbGUgPCAwIHRoZW5cbiAgICAgIHJhaXNlIChJbnZhbGlkUGF0aCBwKTtcblxuICAgIGxldCBzdWIgPVxuICAgICAgbGV0IHN1YiA9IGlmIHN1YiA9IFwiXCIgdGhlbiBbXSBlbHNlIFN0cmluZy5zcGxpdF9vbl9jaGFyICcvJyBzdWIgaW5cblxuICAgICAgdHJ5ICBMaXN0Lm1hcCBpbnRfb2Zfc3RyaW5nIHN1YlxuICAgICAgd2l0aCBGYWlsdXJlIF8gLT4gcmFpc2UgKEludmFsaWRQYXRoIHApXG5cbiAgICBpblxuXG4gICAgaWYgTGlzdC5leGlzdHMgKGZ1biB4IC0+IHggPCAwKSBzdWIgdGhlblxuICAgICAgcmFpc2UgKEludmFsaWRQYXRoIHApO1xuXG4gICAgeyByb290OyBjdHh0OyBzdWI7IH1cblxuXG4gIGxldCBvZl9pcGF0aCAocHJvb2YgOiBQcm9vZi5wcm9vZikgKHAgOiBpcGF0aClcbiAgICA6IFByb29mLmdvYWwgKiBpdGVtICogKHVpZCBsaXN0ICogdGVybSlcbiAgPVxuICAgIGxldCBleG4gPSBJbnZhbGlkUGF0aCAocGF0aF9vZl9pcGF0aCBwKSBpblxuXG4gICAgbGV0IHsgcm9vdDsgY3R4dDsgc3ViOyB9ID0gcCBpblxuXG4gICAgbGV0IGdvYWwgPVxuICAgICAgdHJ5ICBQcm9vZi5ieWlkIHByb29mIChIYW5kbGUub2ZpbnQgcm9vdClcbiAgICAgIHdpdGggSW52YWxpZEdvYWxJZCBfIC0+IHJhaXNlIGV4biBpblxuXG4gICAgbGV0IGl0ZW0sIHRfaXRlbSA9XG4gICAgICBtYXRjaCBjdHh0LmtpbmQsIGN0eHQuaGFuZGxlIHdpdGhcbiAgICAgIHwgYENvbmNsLCAwIC0+XG4gICAgICAgICAgbGV0IGYgPSBnb2FsLlByb29mLmdfZ29hbCBpblxuICAgICAgICAgIChgQyBmLCBgRiBmKVxuXG4gICAgICB8IGBIeXAsIGhkIC0+XG4gICAgICAgICAgYmVnaW4gdHJ5XG4gICAgICAgICAgICBsZXQgcnAgPSBIYW5kbGUub2ZpbnQgaGQgaW5cbiAgICAgICAgICAgIGxldCB7IFByb29mLmhfZm9ybSA9IGhmOyBfIH0gYXMgaHlkID1cbiAgICAgICAgICAgICAgUHJvb2YuSHlwcy5ieWlkIGdvYWwuUHJvb2YuZ19oeXBzIHJwXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgKGBIIChycCwgaHlkKSwgYEYgaGYpXG4gICAgICAgICAgd2l0aCBJbnZhbGlkSHlwaElkIF8gLT5cbiAgICAgICAgICAgIHJhaXNlIGV4blxuICAgICAgICAgIGVuZFxuXG4gICAgICB8IGBWYXIgcGFydCwgaGQgLT5cbiAgICAgICAgICBsZXQgKHgsIChfLCBib2R5KSkgYXMgZGVmID0gT3B0aW9uLmdldF9leG5cbiAgICAgICAgICAgIChWYXJzLmJ5aWQgZ29hbC5nX2VudiBoZCkgZXhuIGluXG4gICAgICAgICAgbGV0IGV4cHIgPSBtYXRjaCBwYXJ0IHdpdGhcbiAgICAgICAgICAgIHwgYEhlYWQgLT4gRVZhciB4XG4gICAgICAgICAgICB8IGBCb2R5IC0+IE9wdGlvbi5nZXRfZXhuIGJvZHkgZXhuIGluXG4gICAgICAgICAgYFYgZGVmLCBgRSBleHByXG4gICAgICBcbiAgICAgIHwgXyAtPiByYWlzZSBleG5cbiAgICBpblxuICAgIGxldCB0YXJnZXQgPSBzdWJ0ZXJtIHRfaXRlbSBzdWIgaW5cblxuICAgIGxldCBnb2FsID0gUHJvb2YueyBnX2lkID0gSGFuZGxlLm9maW50IHJvb3Q7IGdfcHJlZ29hbCA9IGdvYWwgfSBpblxuICAgIChnb2FsLCBpdGVtLCAoc3ViLCB0YXJnZXQpKVxuXG4gIGxldCBnb2FsX29mX2lwYXRoIChwcm9vZiA6IFByb29mLnByb29mKSAocCA6IGlwYXRoKSA6IFByb29mLmdvYWwgPVxuICAgIGxldCAoZywgXywgXykgPSBvZl9pcGF0aCBwcm9vZiBwIGluXG4gICAgZ1xuXG4gIGxldCB0ZXJtX29mX2lwYXRoIChwcm9vZiA6IFByb29mLnByb29mKSAocCA6IGlwYXRoKSA6IHRlcm0gPVxuICAgIGxldCAoXywgXywgKF8sIHQpKSA9IG9mX2lwYXRoIHByb29mIHAgaW5cbiAgICB0XG4gIFxuICBsZXQgZW52X29mX2lwYXRoIChwcm9vZiA6IFByb29mLnByb29mKSAocCA6IGlwYXRoKSA6IGVudiA9XG4gICAgbGV0IChnb2FsLCBpdGVtLCAoc3ViLCBfKSkgPSBvZl9pcGF0aCBwcm9vZiBwIGluXG4gICAgbGV0IGVudiA9IGdvYWwuZ19wcmVnb2FsLmdfZW52IGluXG4gICAgbWF0Y2ggaXRlbSB3aXRoXG4gICAgfCBgViBfIC0+IGVudlxuICAgIHwgYEggKF8sIFByb29mLnsgaF9mb3JtID0gZjsgXyB9KXwgYEMgZiAtPlxuICAgICAgICBsZXQgcmVjIGF1eCBlbnYgdCBzdWIgPVxuICAgICAgICAgIG1hdGNoIHN1YiB3aXRoIFtdIC0+IGVudiB8IGkgOjogc3ViIC0+XG4gICAgICAgICAgbWF0Y2ggdCwgaSB3aXRoXG4gICAgICAgICAgfCBgRSBfLCBfIC0+IGVudlxuICAgICAgICAgIHwgYEYgRkJpbmQgKF8sIHgsIHR5LCBmKSwgMCAtPiBhdXggKFZhcnMucHVzaCBlbnYgKHgsICh0eSwgTm9uZSkpKSAoYEYgZikgc3ViXG4gICAgICAgICAgfCBgRiBfLCBfIC0+IGF1eCBlbnYgKGRpcmVjdF9zdWJ0ZXJtIHQgaSkgc3ViXG4gICAgICAgIGluIGF1eCBlbnYgKGBGIGYpIHN1YlxuXG5cbiAgbGV0IGlzX3N1Yl9wYXRoIChwIDogaXBhdGgpIChzcCA6IGlwYXRoKSA9XG4gICAgICAgcC5yb290ID0gc3Aucm9vdFxuICAgICYmIHAuY3R4dC5oYW5kbGUgPSBzcC5jdHh0LmhhbmRsZVxuICAgICYmIChwLmN0eHQua2luZCA9IHNwLmN0eHQua2luZCB8fFxuICAgICAgIChwLmN0eHQua2luZCA9IGBWYXIgYEhlYWQgJiYgc3AuY3R4dC5raW5kID0gYFZhciBgQm9keSkpXG4gICAgJiYgTGlzdC5pc19wcmVmaXggc3Auc3ViIHAuc3ViXG5cbiAgXG4gIHR5cGUgcG5vZGUgKz0gVFJld3JpdGVBdCBvZiB0ZXJtICogaXBhdGhcblxuICAoKiogW3Jld3JpdGVfYXQgcCB0IHRhcmddIHJld3JpdGVzIHRoZSBzdWJ0ZXJtIGF0IHBhdGggW3BdIGluIHRoZSBnb2FsXG4gICAgICBpbnRvIFt0XS4gSXQgYXV0b21hdGljYWxseSBzaGlmdHMgdmFyaWFibGVzIGluIFt0XSB0byBhdm9pZCBjYXB0dXJlIGJ5XG4gICAgICBiaW5kZXJzLiAqKVxuICBsZXQgcmV3cml0ZV9hdCAodCA6IHRlcm0pIChwIDogaXBhdGgpIDogdGFjdGljID1cbiAgICBsZXQgb3BlbiBQcm9vZiBpbiBmdW4gKHByb29mLCBfKSAtPlxuXG4gICAgbGV0IHsgZ19pZDsgZ19wcmVnb2FsID0gZ29hbCB9LCBpdGVtLCAoc3ViLCBfKSA9IG9mX2lwYXRoIHByb29mIHAgaW5cbiAgICBcbiAgICBsZXQgcG5vZGUgPSBUUmV3cml0ZUF0ICh0LCBwKSBpblxuICAgIFxuICAgIG1hdGNoIGl0ZW0gd2l0aFxuICAgIHwgYEMgZiAtPlxuICAgICAgICBsZXQgbmV3X2NvbmNsID0gcmV3cml0ZV9zdWJ0ZXJtIHQgKGBGIGYpIHN1YiB8PiBmb3JtX29mX3Rlcm0gaW5cbiAgICAgICAgcHJvZ3Jlc3MgcHJvb2YgZ19pZCBwbm9kZSBbbmV3X2NvbmNsXVxuICAgIFxuICAgIHwgYEggKGhkLCB7IGhfZm9ybSA9IGY7IF8gfSkgLT5cbiAgICAgICAgbGV0IG5ld19oeXAgPSByZXdyaXRlX3N1YnRlcm0gdCAoYEYgZikgc3ViIHw+IGZvcm1fb2ZfdGVybSBpblxuICAgICAgICBsZXQgc3ViZ29hbCA9IFtTb21lIGhkLCBbbmV3X2h5cF1dLCBnb2FsLmdfZ29hbCBpblxuICAgICAgICBzcHJvZ3Jlc3MgfmNsZWFyOnRydWUgcHJvb2YgZ19pZCBwbm9kZSBbc3ViZ29hbF1cbiAgICBcbiAgICB8IGBWICh4LCAodHksIGJvZHkpKSAtPlxuICAgICAgICBiZWdpbiBtYXRjaCBwLmN0eHQua2luZCB3aXRoXG4gICAgICAgIHwgYFZhciBgSGVhZCAtPlxuICAgICAgICAgICAgZmFpbHdpdGggXCJDYW5ub3QgbW9kaWZ5IGFuIGFic3RyYWN0IGRlZmluaXRpb25cIlxuICAgICAgICB8IGBWYXIgYEJvZHkgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGJvZHkgd2l0aFxuICAgICAgICAgICAgfCBTb21lIGIgLT5cbiAgICAgICAgICAgICAgICBsZXQgbmV3X2JvZHkgPSByZXdyaXRlX3N1YnRlcm0gdCAoYEUgYikgc3ViIHw+IGV4cHJfb2ZfdGVybSBpblxuICAgICAgICAgICAgICAgIGxldCBnX2VudiA9IFZhcnMubW9kaWZ5IGdvYWwuZ19lbnYgKHgsICh0eSwgU29tZSBuZXdfYm9keSkpIGluXG4gICAgICAgICAgICAgICAgeHByb2dyZXNzIHByb29mIGdfaWQgcG5vZGUgW3sgZ29hbCB3aXRoIGdfZW52IH1dXG4gICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICBmYWlsd2l0aCBcIkNhbm5vdCBtb2RpZnkgYW4gYWJzdHJhY3QgZGVmaW5pdGlvblwiXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICBlbmRcbiAgXG5cbiAgdHlwZSBwbm9kZSArPSBUUmV3cml0ZSBvZiBleHByICogZXhwciAqIGlwYXRoXG5cbiAgKCoqIFtyZXdyaXRlIHJlZCByZXMgdGd0IHRhcmddIHJld3JpdGVzIGV2ZXJ5IG9jY3VycmVuY2Ugb2YgdGhlIGV4cHJlc3Npb25cbiAgICAgIFtyZWRdIGluIHRoZSBzdWJ0ZXJtIGF0IHBhdGggW3RndF0gaW50byB0aGUgZXhwcmVzc2lvbiBbcmVzXS4gSXRcbiAgICAgIGF1dG9tYXRpY2FsbHkgc2hpZnRzIHZhcmlhYmxlcyBpbiBbcmVkXSBhbmQgW3Jlc10gdG8gYXZvaWQgY2FwdHVyZSBieVxuICAgICAgYmluZGVycyBpbiBbdGd0XS4gKilcbiAgbGV0IHJld3JpdGUgKHJlZCA6IGV4cHIpIChyZXMgOiBleHByKSAodGd0IDogaXBhdGgpIDogdGFjdGljID1cbiAgICBmdW4gKHByb29mLCBoZCkgLT5cbiAgICAgIFxuICAgIGxldCB0Z3QgPSB7IHRndCB3aXRoIHJvb3QgPSBIYW5kbGUudG9pbnQgaGQgfSBpblxuICAgICAgXG4gICAgbGV0IF8sIGl0LCAoc3ViLCBfKSA9IG9mX2lwYXRoIHByb29mIHRndCBpbiBcbiAgICBsZXQgZ29hbCA9IFByb29mLmJ5aWQgcHJvb2YgaGQgaW5cbiAgICBcbiAgICBsZXQgcG5vZGUgPSBUUmV3cml0ZSAocmVkLCByZXMsIHRndCkgaW5cblxuICAgIG1hdGNoIGl0IHdpdGhcbiAgICB8IGBDIGYgLT5cbiAgICAgICAgbGV0IG5ld19jb25jbCA9IHJld3JpdGVfc3VidGVybV9hbGwgZ29hbC5nX2VudiAoYEUgcmVkKSAoYEUgcmVzKSAoYEYgZikgc3ViIHw+IGZvcm1fb2ZfdGVybSBpblxuICAgICAgICBQcm9vZi5wcm9ncmVzcyBwcm9vZiBoZCBwbm9kZSBbbmV3X2NvbmNsXVxuXG4gICAgfCBgSCAoc3JjLCB7IGhfZm9ybSA9IGY7IF8gfSkgLT5cbiAgICAgICAgbGV0IG5ld19oeXAgPSByZXdyaXRlX3N1YnRlcm1fYWxsIGdvYWwuZ19lbnYgKGBFIHJlZCkgKGBFIHJlcykgKGBGIGYpIHN1YiB8PiBmb3JtX29mX3Rlcm0gaW5cbiAgICAgICAgbGV0IHN1YmdvYWwgPSBbU29tZSBzcmMsIFtuZXdfaHlwXV0sIGdvYWwuUHJvb2YuZ19nb2FsIGluXG4gICAgICAgIFByb29mLnNwcm9ncmVzcyB+Y2xlYXI6dHJ1ZSBwcm9vZiBoZCBwbm9kZSBbc3ViZ29hbF1cbiAgICBcbiAgICB8IGBWICh4LCAodHksIGIpKSAtPlxuICAgICAgICBiZWdpbiBtYXRjaCB0Z3QuY3R4dC5raW5kIHdpdGhcbiAgICAgICAgfCBgVmFyIGBIZWFkIC0+XG4gICAgICAgICAgICBmYWlsd2l0aCBcIkNhbm5vdCByZXdyaXRlIHZhcmlhYmxlIG5hbWVzXCJcbiAgICAgICAgfCBgVmFyIGBCb2R5IC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBiIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBiIC0+XG4gICAgICAgICAgICAgICAgbGV0IG5ld19ib2R5ID0gcmV3cml0ZV9zdWJ0ZXJtX2FsbCBnb2FsLmdfZW52IChgRSByZWQpIChgRSByZXMpIChgRSBiKSBzdWIgfD4gZXhwcl9vZl90ZXJtIGluXG4gICAgICAgICAgICAgICAgbGV0IGdfZW52ID0gVmFycy5tb2RpZnkgZ29hbC5nX2VudiAoeCwgKHR5LCBTb21lIG5ld19ib2R5KSkgaW5cbiAgICAgICAgICAgICAgICBQcm9vZi54cHJvZ3Jlc3MgcHJvb2YgaGQgcG5vZGUgW3sgZ29hbCB3aXRoIGdfZW52IH1dXG4gICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICBmYWlsd2l0aCBcIkNhbm5vdCByZXdyaXRlIHZhcmlhYmxlIG5hbWVzXCJcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgIGVuZFxuICAgIFxuXG4gICAgbGV0IHJld3JpdGVfaW4gKHJlZCA6IGV4cHIpIChyZXMgOiBleHByKSAodGd0cyA6IGlwYXRoIGxpc3QpIDogdGFjdGljID1cbiAgICAgIExpc3QuZm9sZF9sZWZ0XG4gICAgICAgIChmdW4gdGFjIHRndCAtPiB0aGVuX3RhYyAocmV3cml0ZSByZWQgcmVzIHRndCkgdGFjKVxuICAgICAgICBpZF90YWMgdGd0c1xuICAgIFxuXG4gICAgKCoqIFt1bmZvbGQgeCB0Z3RzIHRhcmddIHVuZm9sZHMgdGhlIGRlZmluaXRpb24gb2YgdGhlIGxvY2FsIHZhcmlhYmxlIFt4XVxuICAgICAgICBpbiBhbGwgZGVzdGluYXRpb25zIHNwZWNpZmllZCBieSBbdGd0c10uIElmIFt+Zm9sZF0gaXMgc2V0IHRvIFt0cnVlXSxcbiAgICAgICAgaXQgd2lsbCBmb2xkIGl0IGluc3RlYWQuICopXG4gICAgbGV0IHVuZm9sZCA/KGZvbGQgPSBmYWxzZSkgKHggOiB2bmFtZSkgKHRndHMgOiBpcGF0aCBsaXN0KSA6IHRhY3RpYyA9XG4gICAgICBmdW4gKHByb29mLCBoZCkgLT5cblxuICAgICAgbGV0IGdvYWwgPSBQcm9vZi5ieWlkIHByb29mIGhkIGluXG4gICAgICBsZXQgYm9keSA9IFxuICAgICAgICBWYXJzLmdldCBnb2FsLmdfZW52IHggfD5cbiAgICAgICAgT3B0aW9uLmdldF9leG5efiBUYWN0aWNOb3RBcHBsaWNhYmxlIHw+XG4gICAgICAgIHNuZCB8PiBPcHRpb24uZ2V0X2V4bl5+IFRhY3RpY05vdEFwcGxpY2FibGUgaW5cbiAgICAgIFxuICAgICAgbGV0IHJlZCwgcmVzID1cbiAgICAgICAgaWYgZm9sZFxuICAgICAgICB0aGVuIGJvZHksIEVWYXIgeFxuICAgICAgICBlbHNlIEVWYXIgeCwgYm9keSBpblxuICAgICAgXG4gICAgICByZXdyaXRlX2luIHJlZCByZXMgdGd0cyAocHJvb2YsIGhkKVxuICAgICAgXG4gICAgXG4gICAgbGV0IHVuZm9sZF9hbGwgP2ZvbGQgKHggOiB2bmFtZSkgOiB0YWN0aWMgPVxuICAgICAgZnVuICgocHJvb2YsIGhkKSBhcyB0YXJnKSAtPlxuICAgICAgXG4gICAgICBsZXQgZ29hbCA9IFByb29mLnsgZ19pZCA9IGhkOyBnX3ByZWdvYWwgPSBQcm9vZi5ieWlkIHByb29mIGhkIH0gaW5cblxuICAgICAgbGV0IHRndHMgPVxuICAgICAgICBsZXQgaWQgPSBWYXJzLmdldGlkIGdvYWwuZ19wcmVnb2FsLmdfZW52IHggfD4gT3B0aW9uLmdldCBpblxuICAgICAgICBhbGxfaXRlbXNfaXBhdGhzIH5oZWFkczpmYWxzZSBnb2FsIHw+XG4gICAgICAgIExpc3QucmVtb3ZlX2lmXG4gICAgICAgICAgKGZ1biBwIC0+IHAuY3R4dC5oYW5kbGUgPSBpZCkgaW5cblxuICAgICAgdW5mb2xkID9mb2xkIHggdGd0cyB0YXJnXG5cblxuXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG4gICgqKiBQb2xhcml0aWVzICopXG5cblxuICAoKiogQSBzdWJmb3JtdWxhIGNhbiBlaXRoZXIgaGF2ZSBhIHBvc2l0aXZlIHBvbGFyaXR5IFtQb3NdLCBhIG5lZ2F0aXZlIHBvbGFyaXR5XG4gICAgICBbTmVnXSwgb3IgYSBzdXBlcnBvc2l0aW9uIFtTdXBdIG9mIGJvdGguXG5cbiAgICAgIEZvciBleGFtcGxlIGluIHRoZSBoeXBvdGhlc2lzIChBIOKHkiBCKSDiiKcgKEMg4oeUIEQpLCBBIGlzIHBvc2l0aXZlLCBCIGlzXG4gICAgICBuZWdhdGl2ZSwgYW5kIEMgYW5kIEQgY2FuIGJlIGVpdGhlciwgZGVwZW5kaW5nIG9uIHRoZSB3YXkgdGhlIHVzZXIgY2hvb3Nlc1xuICAgICAgdG8gcmV3cml0ZSB0aGUgZXF1aXZhbGVuY2UuIFRoaXMgY29pbmNpZGVzIHdpdGggdGhlIHN0YW5kYXJkIGxpbmVhciBsb2dpY1xuICAgICAgcmVhZGluZyBvZiBlcXVpdmFsZW5jZSBhcyB0aGUgYWRkaXRpdmUgY29uanVuY3Rpb24gb2YgYm90aCBkaXJlY3Rpb25zIG9mIGFuXG4gICAgICBpbXBsaWNhdGlvbi4gKilcblxuICB0eXBlIHBvbCA9IFBvcyB8IE5lZyB8IFN1cFxuXG5cbiAgKCoqIFtvcHAgcF0gcmV0dXJucyB0aGUgb3Bwb3NpdGUgcG9sYXJpdHkgb2YgW3BdICopXG4gIGxldCBvcHAgPSBmdW5jdGlvblxuICAgIHwgUG9zIC0+IE5lZ1xuICAgIHwgTmVnIC0+IFBvc1xuICAgIHwgU3VwIC0+IFN1cFxuXG5cbiAgKCoqIFtkaXJlY3Rfc3ViZm9ybV9wb2wgKHAsIGYpIGldIHJldHVybnMgdGhlIFtpXXRoIGRpcmVjdCBzdWJmb3JtdWxhIG9mIFtmXVxuICAgICAgdG9nZXRoZXIgd2l0aCBpdHMgcG9sYXJpdHksIGdpdmVuIHRoYXQgW2ZdJ3MgcG9sYXJpdHkgaXMgW3BdICopXG4gIGxldCBkaXJlY3Rfc3ViZm9ybV9wb2wgKHAsIGYgOiBwb2wgKiBmb3JtKSAoaSA6IGludCkgPVxuICAgIG1hdGNoIGYgd2l0aFxuICAgIHwgRkNvbm4gKGMsIGZzKSAtPlxuICAgICAgbGV0IHN1YnAgPVxuICAgICAgICBtYXRjaCBjLCBpIHdpdGhcbiAgICAgICAgfCBgSW1wLCAwIHwgYE5vdCwgMCAtPiBvcHAgcFxuICAgICAgICB8IGBFcXVpdiwgXyAtPiBTdXBcbiAgICAgICAgfCBfLCBfIC0+IHBcbiAgICAgIGluXG4gICAgICBsZXQgc3ViZiA9XG4gICAgICAgIHRyeSBMaXN0LmF0IGZzIGlcbiAgICAgICAgd2l0aCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gcmFpc2UgKEludmFsaWRTdWJGb3JtUGF0aCBbaV0pXG4gICAgICBpblxuICAgICAgc3VicCwgc3ViZlxuICAgIHwgRkJpbmQgKF8sIF8sIF8sIHN1YmYpIC0+XG4gICAgICBwLCBzdWJmXG4gICAgfCBfIC0+IHJhaXNlIChJbnZhbGlkU3ViRm9ybVBhdGggW2ldKVxuICBcblxuICBsZXQgZGlyZWN0X3N1YnRlcm1fcG9sIChwLCB0IDogcG9sICogdGVybSkgKGkgOiBpbnQpID1cbiAgICBtYXRjaCB0LCBkaXJlY3Rfc3VidGVybSB0IGkgd2l0aFxuICAgIHwgYEYgZiwgYEYgXyAtPlxuICAgICAgICBsZXQgcCwgZiA9IGRpcmVjdF9zdWJmb3JtX3BvbCAocCwgZikgaSBpblxuICAgICAgICAocCwgYEYgZilcbiAgICB8IF8sIHQgLT4gKHAsIHQpXG4gIFxuXG4gICgqKiBbc3ViZm9ybV9wb2wgKHAsIGYpIHN1Yl0gcmV0dXJucyB0aGUgc3ViZm9ybXVsYSBvZiBbZl0gYXQgcGF0aCBbc3ViXSB0b2dldGhlclxuICAgICAgd2l0aCBpdHMgcG9sYXJpdHksIGdpdmVuIHRoYXQgW2ZdJ3MgcG9sYXJpdHkgaXMgW3BdICopXG4gIGxldCBzdWJmb3JtX3BvbCAocCwgZikgc3ViID1cbiAgICB0cnkgTGlzdC5mb2xkX2xlZnQgZGlyZWN0X3N1YmZvcm1fcG9sIChwLCBmKSBzdWJcbiAgICB3aXRoIEludmFsaWRTdWJGb3JtUGF0aCBfIC0+IHJhaXNlIChJbnZhbGlkU3ViRm9ybVBhdGggc3ViKVxuXG5cbiAgKCoqIFtuZWdfY291bnQgZiBzdWJdIGNvdW50cyB0aGUgbnVtYmVyIG9mIG5lZ2F0aW9ucyBpbiBbZl0gYWxvbmcgcGF0aCBbc3ViXSAqKVxuICBsZXQgbmVnX2NvdW50IChmIDogZm9ybSkgKHN1YiA6IGludCBsaXN0KSA6IGludCA9XG4gICAgbGV0IHJlYyBhdXggKG4sIGYpID1cbiAgICAgIGZ1bmN0aW9uIFtdIC0+IG4gfCBpIDo6IHN1YiAtPlxuICAgICAgYmVnaW4gbWF0Y2ggZiB3aXRoXG4gICAgICB8IEZDb25uIChjLCBmcykgLT5cbiAgICAgICAgICBsZXQgbiA9XG4gICAgICAgICAgICBtYXRjaCBjLCBpIHdpdGhcbiAgICAgICAgICAgIHwgYEltcCwgMCB8IGBOb3QsIDAgLT4gbisxXG4gICAgICAgICAgICB8IF8gLT4gblxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IHN1YmYgPVxuICAgICAgICAgICAgdHJ5IExpc3QuYXQgZnMgaVxuICAgICAgICAgICAgd2l0aCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gcmFpc2UgKEludmFsaWRTdWJGb3JtUGF0aCBzdWIpXG4gICAgICAgICAgaW5cbiAgICAgICAgICBhdXggKG4sIHN1YmYpIHN1YiBcbiAgICAgIHwgRkJpbmQgKF8sIF8sIF8sIHN1YmYpIC0+XG4gICAgICAgICAgYXV4IChuLCBzdWJmKSBzdWJcbiAgICAgIHwgXyAtPlxuICAgICAgICAgIG5cbiAgICAgIGVuZFxuICAgIGluIGF1eCAoMCwgZikgc3ViXG5cblxuICAoKiogW3BvbF9vZl9pdGVtIGl0XSByZXR1cm5zIHRoZSBwb2xhcml0eSBvZiB0aGUgaXRlbSBbaXRdICopXG4gIGxldCBwb2xfb2ZfaXRlbSA9IGZ1bmN0aW9uXG4gICAgfCBgSCBfIC0+IE5lZ1xuICAgIHwgYEMgXyAtPiBQb3NcbiAgICB8IGBWIF8gLT4gTmVnXG5cblxuICAoKiogW3BvbF9vZl9pcGF0aCBwcm9vZiBwXSByZXR1cm5zIHRoZSBwb2xhcml0eSBvZiB0aGUgc3ViZm9ybXVsYVxuICAgICAgYXQgcGF0aCBbcF0gaW4gW3Byb29mXSAqKVxuICBsZXQgcG9sX29mX2lwYXRoIChwcm9vZiA6IFByb29mLnByb29mKSAocCA6IGlwYXRoKSA6IHBvbCA9XG4gICAgbGV0IF8sIGl0ZW0sIChzdWIsIF8pID0gb2ZfaXBhdGggcHJvb2YgcCBpblxuICAgIGxldCBwb2wsIGZvcm0gPVxuICAgICAgbWF0Y2ggaXRlbSB3aXRoXG4gICAgICB8IGBIIChfLCB7IGhfZm9ybSA9IGY7IF8gfSkgLT4gTmVnLCBmXG4gICAgICB8IGBDIGYgLT4gUG9zLCBmXG4gICAgICB8IGBWIF8gLT4gcmFpc2UgKEludmFsaWRTdWJGb3JtUGF0aCBzdWIpXG4gICAgaW5cbiAgICBzdWJmb3JtX3BvbCAocG9sLCBmb3JtKSBzdWIgfD4gZnN0XG5cblxuICAoKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuICAoKiogTGlua2luZyAqKVxuICBcblxuICB0eXBlIGxpbmsgPSBpcGF0aCAqIGlwYXRoXG4gIHR5cGUgaHlwZXJsaW5rID0gKGlwYXRoIGxpc3QpICogKGlwYXRoIGxpc3QpXG4gIFxuICBsZXQgaHlwZXJsaW5rX29mX2xpbmsgOiBsaW5rIC0+IGh5cGVybGluayA9XG4gICAgZnVuIChzcmMsIGRzdCkgLT4gW3NyY10sIFtkc3RdXG4gIFxuXG4gICgqKiBbaW5zdGFudGlhdGUgd2l0IHRndCB0YXJnXSBpbnN0YW50aWF0ZXMgdGhlIHF1YW50aWZpZXIgYXQgcGF0aCBbdGd0XSB3aXRoXG4gICAgICB0aGUgZXhwcmVzc2lvbiBbd2l0XS4gSWYgdGhlIHF1YW50aWZpZXIgb2NjdXJzIGluIGEgaHlwb3RoZXNpcywgdGhlXG4gICAgICBoeXBvdGhlc2lzIGlzIGR1cGxpY2F0ZWQgYmVmb3JlIGluc3RhbnRpYXRpb24uICopXG4gIGxldCBpbnN0YW50aWF0ZSAod2l0IDogZXhwcikgKHRndCA6IGlwYXRoKSA6IHRhY3RpYyA9XG4gICAgZnVuICgocHJvb2YsIF8pIGFzIHRhcmcpIC0+XG4gIFxuICAgIG1hdGNoIHRlcm1fb2ZfaXBhdGggcHJvb2YgdGd0IHdpdGhcbiAgICB8IGBGIEZCaW5kIChfLCB4LCBfLCBmKSAtPlxuICAgICAgICBsZXQgZmlyc3QgPVxuICAgICAgICAgIGlmIHRndC5jdHh0LmtpbmQgPSBgSHlwXG4gICAgICAgICAgdGhlbiBkdXBsaWNhdGUgKEhhbmRsZS5vZmludCB0Z3QuY3R4dC5oYW5kbGUpXG4gICAgICAgICAgZWxzZSBpZF90YWNcbiAgICAgICAgaW4gdGFyZyB8PiB0aGVuX3RhYyBmaXJzdFxuICAgICAgICAgIChmdW4gKHByLCBpZCkgLT5cbiAgICAgICAgICAgIGxldCB0Z3QgPSB7IHRndCB3aXRoIHJvb3QgPSBIYW5kbGUudG9pbnQgaWQgfSBpblxuICAgICAgICAgICAgcmV3cml0ZV9hdCAoYEYgKEZvcm0uU3Vic3QuZl9hcHBseTEgKHgsIDApIHdpdCBmKSkgdGd0IChwciwgaWQpKVxuICAgIHwgXyAtPlxuICAgICAgICByYWlzZSBUYWN0aWNOb3RBcHBsaWNhYmxlXG4gIFxuXG4gIHR5cGUgY2hvaWNlID0gKGludCAqIGV4cHIgb3B0aW9uKVxuICB0eXBlIGl0cmFjZSA9IGNob2ljZSBsaXN0XG5cbiAgbGV0IHByaW50X2Nob2ljZSAoKHNpZGUsIHdpdG5lc3MpIDogY2hvaWNlKSA6IHN0cmluZyA9XG4gICAgbGV0IHNpZGUgPSBpZiBzaWRlID0gMCB0aGVuIFwi4oaQXCIgZWxzZSBcIuKGklwiIGluXG4gICAgbGV0IHdpdG5lc3MgPVxuICAgICAgd2l0bmVzcyB8PiBPcHRpb24ubWFwX2RlZmF1bHRcbiAgICAgICAgKGZ1biBlIC0+IFByaW50Zi5zcHJpbnRmIFwieyVzfVwiIChGby5Ob3RhdGlvbi5lX3Rvc3RyaW5nIGUpKSBcIlwiIGluXG4gICAgUHJpbnRmLnNwcmludGYgXCIlcyVzXCIgc2lkZSB3aXRuZXNzXG5cbiAgbGV0IHByaW50X2l0cmFjZSA6IGl0cmFjZSAtPiBzdHJpbmcgPVxuICAgIFV0aWxzLkxpc3QudG9fc3RyaW5nIHByaW50X2Nob2ljZSB+bGVmdDpcIlwiIH5yaWdodDpcIlwiIH5zZXA6XCIgXCJcblxuICB0eXBlIHBub2RlICs9IFRMaW5rIG9mIGl0cmFjZVxuXG4gICgqKiBbbGlua10gaXMgdGhlIGVxdWl2YWxlbnQgb2YgUHJvb2YgYnkgUG9pbnRpbmcncyBbZmluZ2VyX3RhY10sIGJ1dCB1c2luZ1xuICAgICAgdGhlIGludGVyYWN0aW9uIHJ1bGVzIHNwZWNpZmljIHRvIHN1YmZvcm11bGEgbGlua2luZy4gKilcbiAgbGV0IGxpbmsgKHNyYywgZHN0IDogbGluaykgKHNfc3JjLCBzX2RzdCA6IEZvcm0uU3Vic3Quc3Vic3QgKiBGb3JtLlN1YnN0LnN1YnN0KSA6IHRhY3RpYyA9XG4gICAgZnVuIChwcm9vZiwgaGQpIC0+XG5cbiAgICBhc3NlcnQgKHNyYy5jdHh0IDw+IGRzdC5jdHh0KTtcblxuICAgIGxldCBzX3NyYyA9IEZvcm0uU3Vic3QuYXNsaXN0IHNfc3JjIGluXG4gICAgbGV0IHNfZHN0ID0gRm9ybS5TdWJzdC5hc2xpc3Qgc19kc3QgaW5cbiAgICBcbiAgICBsZXQgZ29hbCA9IFByb29mLmJ5aWQgcHJvb2YgaGQgaW5cbiAgICBsZXQgXywgaXRlbV9zcmMsIChzdWJfc3JjLCBfKSA9IG9mX2lwYXRoIHByb29mIHNyYyBpblxuICAgIGxldCBfLCBpdGVtX2RzdCwgKHN1Yl9kc3QsIF8pID0gb2ZfaXBhdGggcHJvb2YgZHN0IGluXG5cbiAgICBsZXQgcmVjIHBicCAoZ29hbCwgb2dvYWxzKSAodGd0IDogaXRlbSkgc3ViIHMgdGd0JyBzdWInIHMnID1cblxuICAgICAgbGV0IGdlbl9zdWJnb2FscyB0YXJnZXQgc3ViX2dvYWwgc3ViX29nb2FscyA9XG4gICAgICAgIGxldCBvZ29hbHMgPSBQcm9vZi5zZ3Byb2dyZXNzIGdvYWwgc3ViX29nb2FscyBpblxuICAgICAgICBsZXQgZ29hbCA9XG4gICAgICAgICAgbGV0IGdvYWwgPSBMaXN0LmhkIChQcm9vZi5zZ3Byb2dyZXNzIGdvYWwgW3N1Yl9nb2FsXSkgaW5cbiAgICAgICAgICBtYXRjaCB0YXJnZXQgd2l0aFxuICAgICAgICAgIHwgYEggKHVpZCwgaHlwKSAtPlxuICAgICAgICAgICAgeyBnb2FsIHdpdGggZ19oeXBzID0gUHJvb2YuSHlwcy5hZGQgZ29hbC5nX2h5cHMgdWlkIGh5cCB9XG4gICAgICAgICAgfCBfIC0+IGdvYWxcbiAgICAgICAgaW5cbiAgICAgICAgKGdvYWwsIG9nb2FscylcbiAgICAgIGluXG5cbiAgICAgIGxldCBpbnZlcnRpYmxlIChwb2wgOiBwb2wpIChmIDogZm9ybSkgOiBib29sID1cbiAgICAgICAgbWF0Y2ggcG9sIHdpdGhcbiAgICAgICAgKCogUmlnaHQgaW52ZXJ0aWJsZSAqKVxuICAgICAgICB8IFBvcyAtPiBiZWdpbiBtYXRjaCBmIHdpdGhcbiAgICAgICAgICB8IEZDb25uIChjLCBfKSAtPiBiZWdpbiBtYXRjaCBjIHdpdGhcbiAgICAgICAgICAgIHwgYEFuZCB8IGBJbXAgfCBgTm90IC0+IHRydWVcbiAgICAgICAgICAgIHwgXyAtPiBmYWxzZVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBGQmluZCAoYEZvcmFsbCwgXywgXywgXykgLT4gdHJ1ZVxuICAgICAgICAgIHwgXyAtPiBmYWxzZVxuICAgICAgICAgIGVuZFxuICAgICAgICAoKiBMZWZ0IGludmVydGlibGUgKilcbiAgICAgICAgfCBOZWcgLT4gYmVnaW4gbWF0Y2ggZiB3aXRoXG4gICAgICAgICAgfCBGQ29ubiAoYywgXykgLT4gYmVnaW4gbWF0Y2ggYyB3aXRoXG4gICAgICAgICAgICB8IGBBbmQgfCBgT3IgLT4gdHJ1ZVxuICAgICAgICAgICAgfCBfIC0+IGZhbHNlXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICB8IEZCaW5kIF8gLT4gdHJ1ZVxuICAgICAgICAgIHwgXyAtPiBmYWxzZVxuICAgICAgICAgIGVuZFxuICAgICAgICB8IFN1cCAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIGluXG5cbiAgICAgIGxldCByaWdodF9pbnZfcnVsZXMgZiBpIHN1YiBzIHRndCcgc3ViJyBzJyA9XG4gICAgICAgIGxldCB0Z3QsIChnb2FsLCBuZXdfb2dvYWxzKSwgcyA9IGJlZ2luIG1hdGNoIGYsIGkrMSB3aXRoXG5cbiAgICAgICAgICAoKiBBbmQgKilcblxuICAgICAgICAgIHwgRkNvbm4gKGBBbmQsIFtmMTsgZjJdKSwgMSAtPlxuICAgICAgICAgICAgbGV0IHRndCA9IGBDIGYxIGluXG4gICAgICAgICAgICBsZXQgc3ViZ29hbHMgPSBnZW5fc3ViZ29hbHMgdGd0IChbXSwgZjEpIFtbXSwgZjJdIGluXG4gICAgICAgICAgICB0Z3QsIHN1YmdvYWxzLCBzXG5cbiAgICAgICAgICB8IEZDb25uIChgQW5kLCBbZjE7IGYyXSksIDIgLT5cbiAgICAgICAgICAgIGxldCB0Z3QgPSBgQyBmMiBpblxuICAgICAgICAgICAgbGV0IHN1YmdvYWxzID0gZ2VuX3N1YmdvYWxzIHRndCAoW10sIGYyKSBbW10sIGYxXSBpblxuICAgICAgICAgICAgdGd0LCBzdWJnb2Fscywgc1xuXG4gICAgICAgICAgKCogSW1wICopXG5cbiAgICAgICAgICB8IEZDb25uIChgSW1wLCBbZjE7IGYyXSksIDEgLT5cbiAgICAgICAgICAgIGxldCB0Z3QgPSBgSCAoSGFuZGxlLmZyZXNoICgpLCBQcm9vZi5ta19oeXAgZjEpIGluXG4gICAgICAgICAgICBsZXQgc3ViZ29hbHMgPSBnZW5fc3ViZ29hbHMgdGd0IChbXSwgZjIpIFtdIGluXG4gICAgICAgICAgICB0Z3QsIHN1YmdvYWxzLCBzXG5cbiAgICAgICAgICB8IEZDb25uIChgSW1wLCBbZjE7IGYyXSksIDIgLT5cbiAgICAgICAgICAgIGxldCB0Z3QgPSBgQyBmMiBpblxuICAgICAgICAgICAgbGV0IHN1YmdvYWxzID0gZ2VuX3N1YmdvYWxzIHRndCAoW05vbmUsIFtmMV1dLCBmMikgW10gaW5cbiAgICAgICAgICAgIHRndCwgc3ViZ29hbHMsIHNcblxuICAgICAgICAgICgqIE5vdCAqKVxuXG4gICAgICAgICAgfCBGQ29ubiAoYE5vdCwgW2YxXSksIDEgLT5cbiAgICAgICAgICAgIGxldCB0Z3QgPSBgSCAoSGFuZGxlLmZyZXNoICgpLCBQcm9vZi5ta19oeXAgZjEpIGluXG4gICAgICAgICAgICBsZXQgc3ViZ29hbHMgPSBnZW5fc3ViZ29hbHMgdGd0IChbXSwgRm9ybS5mX2ZhbHNlKSBbXSBpblxuICAgICAgICAgICAgdGd0LCBzdWJnb2Fscywgc1xuXG4gICAgICAgICAgKCogRm9yYWxsICopXG5cbiAgICAgICAgICB8IEZCaW5kIChgRm9yYWxsLCB4LCB0eSwgZiksIDEgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIExpc3QucG9wX2Fzc29jIHggcyB3aXRoXG4gICAgICAgICAgICB8IHMsIFNib3VuZCAoRVZhciAoeiwgXykpIC0+XG4gICAgICAgICAgICAgIGxldCBmID0gRm9ybS5TdWJzdC5mX2FwcGx5MSAoeCwgMCkgKEVWYXIgKHosIDApKSBmIGluXG4gICAgICAgICAgICAgIGxldCB0Z3QgPSBgQyBmIGluXG4gICAgICAgICAgICAgIGxldCBnb2FsLCBvZ29hbHMgPSBnZW5fc3ViZ29hbHMgdGd0IChbXSwgZikgW10gaW5cbiAgICAgICAgICAgICAgbGV0IGdvYWwgPSB7IGdvYWwgd2l0aCBnX2VudiA9IFZhcnMucHVzaCBnb2FsLmdfZW52ICh6LCAodHksIE5vbmUpKSB9IGluXG4gICAgICAgICAgICAgIHRndCwgKGdvYWwsIG9nb2FscyksIHNcbiAgICAgICAgICAgIHwgXyAtPiByYWlzZSBUYWN0aWNOb3RBcHBsaWNhYmxlXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBcbiAgICAgICAgICB8IF8gLT4gcmFpc2UgVGFjdGljTm90QXBwbGljYWJsZVxuXG4gICAgICAgIGVuZFxuICAgICAgICBpbiBwYnAgKGdvYWwsIG9nb2FscyBAIG5ld19vZ29hbHMpIHRndCBzdWIgcyB0Z3QnIHN1YicgcydcbiAgICAgIGluXG5cbiAgICAgIGxldCBsZWZ0X2ludl9ydWxlcyBmIHNyYyBpIHN1YiBzIHRndCcgc3ViJyBzJyA9XG4gICAgICAgIGxldCB0Z3QsIChnb2FsLCBuZXdfb2dvYWxzKSwgcyA9IGJlZ2luIG1hdGNoIGYsIGkrMSB3aXRoXG5cbiAgICAgICAgICAoKiBBbmQgKilcblxuICAgICAgICAgIHwgRkNvbm4gKGBBbmQsIFtmMTsgZjJdKSwgMSAtPlxuICAgICAgICAgICAgbGV0IHRndCA9IGBIIChIYW5kbGUuZnJlc2ggKCksIFByb29mLm1rX2h5cCBmMSB+c3JjKSBpblxuICAgICAgICAgICAgbGV0IHN1YmdvYWxzID0gIGdlbl9zdWJnb2FscyB0Z3QgKFtTb21lIHNyYywgW2YyXV0sIGdvYWwuZ19nb2FsKSBbXSBpblxuICAgICAgICAgICAgdGd0LCBzdWJnb2Fscywgc1xuXG4gICAgICAgICAgfCBGQ29ubiAoYEFuZCwgW2YxOyBmMl0pLCAyIC0+XG4gICAgICAgICAgICBsZXQgdGd0ID0gYEggKEhhbmRsZS5mcmVzaCAoKSwgUHJvb2YubWtfaHlwIGYyIH5zcmMpIGluXG4gICAgICAgICAgICBsZXQgc3ViZ29hbHMgPSBnZW5fc3ViZ29hbHMgdGd0IChbU29tZSBzcmMsIFtmMV1dLCBnb2FsLmdfZ29hbCkgW10gaW5cbiAgICAgICAgICAgIHRndCwgc3ViZ29hbHMsIHNcblxuICAgICAgICAgICgqIE9yICopXG5cbiAgICAgICAgICB8IEZDb25uIChgT3IsIFtmMTsgZjJdKSwgMSAtPlxuICAgICAgICAgICAgbGV0IHRndCA9IGBIIChIYW5kbGUuZnJlc2ggKCksIFByb29mLm1rX2h5cCBmMSB+c3JjKSBpblxuICAgICAgICAgICAgbGV0IHN1YmdvYWxzID0gZ2VuX3N1YmdvYWxzIHRndCAoW10sIGdvYWwuZ19nb2FsKSBbW1NvbWUgc3JjLCBbZjJdXSwgZ29hbC5nX2dvYWxdIGluXG4gICAgICAgICAgICB0Z3QsIHN1YmdvYWxzLCBzXG5cbiAgICAgICAgICB8IEZDb25uIChgT3IsIFtmMTsgZjJdKSwgMiAtPlxuICAgICAgICAgICAgbGV0IHRndCA9IGBIIChIYW5kbGUuZnJlc2ggKCksIFByb29mLm1rX2h5cCBmMiB+c3JjKSBpblxuICAgICAgICAgICAgbGV0IHN1YmdvYWxzID0gZ2VuX3N1YmdvYWxzIHRndCAoW10sIGdvYWwuZ19nb2FsKSBbW1NvbWUgc3JjLCBbZjFdXSwgZ29hbC5nX2dvYWxdIGluXG4gICAgICAgICAgICB0Z3QsIHN1YmdvYWxzLCBzXG5cbiAgICAgICAgICAoKiBGb3JhbGwgKilcblxuICAgICAgICAgIHwgRkJpbmQgKGBGb3JhbGwsIHgsIF8sIGYpLCAxIC0+XG4gICAgICAgICAgICBsZXQgcywgaXRlbSA9IExpc3QucG9wX2Fzc29jIHggcyBpblxuICAgICAgICAgICAgbGV0IHRndCwgc3ViZ29hbHMgPVxuICAgICAgICAgICAgICBtYXRjaCBpdGVtIHdpdGhcbiAgICAgICAgICAgICAgfCBTYm91bmQgdCAtPiBcbiAgICAgICAgICAgICAgICBsZXQgZiA9IEZvcm0uU3Vic3QuZl9hcHBseTEgKHgsIDApIHQgZiBpblxuICAgICAgICAgICAgICAgIGxldCB0Z3QgPSBgSCAoSGFuZGxlLmZyZXNoICgpLCBQcm9vZi5ta19oeXAgZiB+c3JjKSBpblxuICAgICAgICAgICAgICAgIHRndCwgZ2VuX3N1YmdvYWxzIHRndCAoW10sIGdvYWwuZ19nb2FsKSBbXVxuICAgICAgICAgICAgICB8IFNmbGV4IC0+IGZhaWx3aXRoIFwiY2Fubm90IGdvIHRocm91Z2ggdW5pbnN0YW50aWF0ZWQgcXVhbnRpZmllcnNcIlxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIHRndCwgc3ViZ29hbHMsIHNcblxuICAgICAgICAgICgqIEV4aXN0cyAqKVxuXG4gICAgICAgICAgfCBGQmluZCAoYEV4aXN0LCB4LCB0eSwgZiksIDEgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIExpc3QucG9wX2Fzc29jIHggcyB3aXRoXG4gICAgICAgICAgICB8IHMsIFNib3VuZCAoRVZhciAoeiwgXykpIC0+XG4gICAgICAgICAgICAgIGxldCBmID0gRm9ybS5TdWJzdC5mX2FwcGx5MSAoeCwgMCkgKEVWYXIgKHosIDApKSBmIGluXG4gICAgICAgICAgICAgIGxldCB0Z3QgPSBgSCAoSGFuZGxlLmZyZXNoICgpLCBQcm9vZi5ta19oeXAgZiB+c3JjKSBpblxuICAgICAgICAgICAgICBsZXQgZ29hbCwgb2dvYWxzID0gZ2VuX3N1YmdvYWxzIHRndCAoW10sIGdvYWwuZ19nb2FsKSBbXSBpblxuICAgICAgICAgICAgICBsZXQgZ29hbCA9IHsgZ29hbCB3aXRoIGdfZW52ID0gVmFycy5wdXNoIGdvYWwuZ19lbnYgKHosICh0eSwgTm9uZSkpIH0gaW5cbiAgICAgICAgICAgICAgdGd0LCAoZ29hbCwgb2dvYWxzKSwgc1xuICAgICAgICAgICAgfCBfIC0+IHJhaXNlIFRhY3RpY05vdEFwcGxpY2FibGVcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIFxuICAgICAgICAgIHwgXyAtPiByYWlzZSBUYWN0aWNOb3RBcHBsaWNhYmxlXG5cbiAgICAgICAgZW5kXG4gICAgICAgIGluIHBicCAoZ29hbCwgb2dvYWxzIEAgbmV3X29nb2FscykgdGd0IHN1YiBzIHRndCcgc3ViJyBzJ1xuICAgICAgaW5cblxuICAgICAgbWF0Y2ggdGd0LCBzdWIsIHMsIHRndCcsIHN1YicsIHMnIHdpdGhcblxuICAgICAgKCogQXhpb20gKilcblxuICAgICAgfCBfLCBbXSwgXywgXywgW10sIF8gLT4gTGlzdC5yZXYgb2dvYWxzXG5cbiAgICAgICgqIFJpZ2h0IGludmVydGlibGUgcnVsZXMgKilcblxuICAgICAgfCB0Z3QnLCBzdWInLCBzJywgYEMgZiwgaSA6OiBzdWIsIHNcbiAgICAgICAgd2hlbiBpbnZlcnRpYmxlIFBvcyBmIC0+XG4gICAgICAgIHJpZ2h0X2ludl9ydWxlcyBmIGkgc3ViIHMgdGd0JyBzdWInIHMnXG5cbiAgICAgIHwgYEMgZiwgaSA6OiBzdWIsIHMsIHRndCcsIHN1YicsIHMnXG4gICAgICAgIHdoZW4gaW52ZXJ0aWJsZSBQb3MgZiAtPlxuICAgICAgICByaWdodF9pbnZfcnVsZXMgZiBpIHN1YiBzIHRndCcgc3ViJyBzJ1xuXG4gICAgICAoKiBMZWZ0IGludmVydGlibGUgcnVsZXMgKilcblxuICAgICAgfCB0Z3QnLCBzdWInLCBzJywgYEggKHNyYywgUHJvb2YueyBoX2Zvcm0gPSBmOyBfIH0pLCBpIDo6IHN1Yiwgc1xuICAgICAgICB3aGVuIGludmVydGlibGUgTmVnIGYgLT5cbiAgICAgICAgbGVmdF9pbnZfcnVsZXMgZiBzcmMgaSBzdWIgcyB0Z3QnIHN1YicgcydcblxuICAgICAgfCBgSCAoc3JjLCBQcm9vZi57IGhfZm9ybSA9IGY7IF8gfSksIGkgOjogc3ViLCBzLCB0Z3QnLCBzdWInLCBzJ1xuICAgICAgICB3aGVuIGludmVydGlibGUgTmVnIGYgLT5cbiAgICAgICAgbGVmdF9pbnZfcnVsZXMgZiBzcmMgaSBzdWIgcyB0Z3QnIHN1YicgcydcblxuICAgICAgKCogUmlnaHQgbm9uLWludmVydGlibGUgcnVsZXMgKilcblxuICAgICAgfCB0Z3QnLCBzdWInLCBzJywgYEMgZiwgaSA6OiBzdWIsIHNcbiAgICAgIHwgYEMgZiwgaSA6OiBzdWIsIHMsIHRndCcsIHN1YicsIHMnIC0+XG5cbiAgICAgICAgbGV0IHRndCwgKGdvYWwsIG5ld19vZ29hbHMpLCBzID0gYmVnaW4gbWF0Y2ggZiwgaSsxIHdpdGhcblxuICAgICAgICAgICgqIE9yICopXG5cbiAgICAgICAgICB8IEZDb25uIChgT3IsIFtmMTsgX10pLCAxIC0+XG4gICAgICAgICAgICBsZXQgdGd0ID0gYEMgZjEgaW5cbiAgICAgICAgICAgIGxldCBzdWJnb2FscyA9IGdlbl9zdWJnb2FscyB0Z3QgKFtdLCBmMSkgW10gaW5cbiAgICAgICAgICAgIHRndCwgc3ViZ29hbHMsIHNcblxuICAgICAgICAgIHwgRkNvbm4gKGBPciwgW187IGYyXSksIDIgLT5cbiAgICAgICAgICAgIGxldCB0Z3QgPSBgQyBmMiBpblxuICAgICAgICAgICAgbGV0IHN1YmdvYWxzID0gZ2VuX3N1YmdvYWxzIHRndCAoW10sIGYyKSBbXSBpblxuICAgICAgICAgICAgdGd0LCBzdWJnb2Fscywgc1xuXG4gICAgICAgICAgKCogRXhpc3RzICopXG5cbiAgICAgICAgICB8IEZCaW5kIChgRXhpc3QsIHgsIF8sIGYpLCAxIC0+XG4gICAgICAgICAgICBsZXQgcywgaXRlbSA9IExpc3QucG9wX2Fzc29jIHggcyBpblxuICAgICAgICAgICAgbGV0IHRndCwgc3ViZ29hbHMgPVxuICAgICAgICAgICAgICBtYXRjaCBpdGVtIHdpdGhcbiAgICAgICAgICAgICAgfCBTYm91bmQgdCAtPiBcbiAgICAgICAgICAgICAgICBsZXQgZiA9IEZvcm0uU3Vic3QuZl9hcHBseTEgKHgsIDApIHQgZiBpblxuICAgICAgICAgICAgICAgIGxldCB0Z3QgPSBgQyBmIGluXG4gICAgICAgICAgICAgICAgdGd0LCBnZW5fc3ViZ29hbHMgdGd0IChbXSwgZikgW11cbiAgICAgICAgICAgICAgfCBTZmxleCAtPiBmYWlsd2l0aCBcImNhbm5vdCBnbyB0aHJvdWdoIHVuaW5zdGFudGlhdGVkIHF1YW50aWZpZXJzXCJcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICB0Z3QsIHN1YmdvYWxzLCBzXG4gICAgICAgICAgXG4gICAgICAgICAgfCBfIC0+IHJhaXNlIFRhY3RpY05vdEFwcGxpY2FibGVcblxuICAgICAgICBlbmRcbiAgICAgICAgaW4gcGJwIChnb2FsLCBvZ29hbHMgQCBuZXdfb2dvYWxzKSB0Z3Qgc3ViIHMgdGd0JyBzdWInIHMnXG5cbiAgICAgICgqIExlZnQgbm9uLWludmVydGlibGUgcnVsZXMgKilcblxuICAgICAgfCB0Z3QnLCBzdWInLCBzJywgYEggKHNyYywgUHJvb2YueyBoX2Zvcm0gPSBmOyBfIH0pLCBpIDo6IHN1Yiwgc1xuICAgICAgfCBgSCAoc3JjLCBQcm9vZi57IGhfZm9ybSA9IGY7IF8gfSksIGkgOjogc3ViLCBzLCB0Z3QnLCBzdWInLCBzJyAtPlxuXG4gICAgICAgIGxldCB0Z3QsIChnb2FsLCBuZXdfb2dvYWxzKSwgcyA9IGJlZ2luIG1hdGNoIHRndCcgd2l0aFxuXG4gICAgICAgICAgKCogSHlwb3RoZXNpcyB2cy4gQ29uY2x1c2lvbiAqKVxuXG4gICAgICAgICAgfCBgQyBfIC0+IGJlZ2luIG1hdGNoIGYsIGkrMSB3aXRoXG5cbiAgICAgICAgICAgICgqIEltcCAqKVxuXG4gICAgICAgICAgICB8IEZDb25uIChgSW1wLCBbZjE7IGYyXSksIDIgLT5cbiAgICAgICAgICAgICAgbGV0IHRndCA9IGBIIChIYW5kbGUuZnJlc2ggKCksIFByb29mLm1rX2h5cCBmMiB+c3JjKSBpblxuICAgICAgICAgICAgICBsZXQgc3ViZ29hbHMgPSBnZW5fc3ViZ29hbHMgdGd0IChbXSwgZ29hbC5nX2dvYWwpIFtbXSwgZjFdIGluXG4gICAgICAgICAgICAgIHRndCwgc3ViZ29hbHMsIHNcblxuICAgICAgICAgICAgfCBfIC0+IHJhaXNlIFRhY3RpY05vdEFwcGxpY2FibGVcblxuICAgICAgICAgICAgZW5kXG5cbiAgICAgICAgICAoKiBIeXBvdGhlc2lzIHZzLiBIeXBvdGhlc2lzICopXG5cbiAgICAgICAgICB8IGBIIF8gLT4gYmVnaW4gbWF0Y2ggZiwgaSsxIHdpdGhcblxuICAgICAgICAgICAgKCogSW1wICopXG5cbiAgICAgICAgICAgIHwgRkNvbm4gKGBJbXAsIFtmMTsgZjJdKSwgMSAtPlxuICAgICAgICAgICAgICBsZXQgdGd0ID0gYEMgZjEgaW5cbiAgICAgICAgICAgICAgbGV0IHN1YmdvYWxzID0gZ2VuX3N1YmdvYWxzIHRndCAoW10sIGYxKSBbW1NvbWUgc3JjLCBbZjJdXSwgZ29hbC5nX2dvYWxdIGluXG4gICAgICAgICAgICAgIHRndCwgc3ViZ29hbHMsIHNcblxuICAgICAgICAgICAgfCBGQ29ubiAoYEltcCwgW2YxOyBmMl0pLCAyIC0+XG4gICAgICAgICAgICAgIGxldCB0Z3QgPSBgSCAoSGFuZGxlLmZyZXNoICgpLCBQcm9vZi5ta19oeXAgZjIgfnNyYykgaW5cbiAgICAgICAgICAgICAgbGV0IHN1YmdvYWxzID0gZ2VuX3N1YmdvYWxzIHRndCAoW10sIGdvYWwuZ19nb2FsKSBbW10sIGYxXSBpblxuICAgICAgICAgICAgICB0Z3QsIHN1YmdvYWxzLCBzXG5cbiAgICAgICAgICAgICgqIE5vdCAqKVxuXG4gICAgICAgICAgICB8IEZDb25uIChgTm90LCBbZjFdKSwgMSAtPlxuICAgICAgICAgICAgICBsZXQgdGd0ID0gYEMgZjEgaW5cbiAgICAgICAgICAgICAgbGV0IHN1YmdvYWxzID0gZ2VuX3N1YmdvYWxzIHRndCAoW10sIGYxKSBbXSBpblxuICAgICAgICAgICAgICB0Z3QsIHN1YmdvYWxzLCBzXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHwgXyAtPiByYWlzZSBUYWN0aWNOb3RBcHBsaWNhYmxlXG5cbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHwgXyAtPiByYWlzZSBUYWN0aWNOb3RBcHBsaWNhYmxlXG4gICAgICAgICAgZW5kXG4gICAgICAgIFxuICAgICAgICBpbiBwYnAgKGdvYWwsIG9nb2FscyBAIG5ld19vZ29hbHMpIHRndCBzdWIgcyB0Z3QnIHN1YicgcydcblxuICAgICAgfCBfIC0+IHJhaXNlIFRhY3RpY05vdEFwcGxpY2FibGVcbiAgICBpblxuXG4gICAgbGV0IHN1YmdvYWxzID0gcGJwIChnb2FsLCBbXSkgaXRlbV9zcmMgc3ViX3NyYyBzX3NyYyBpdGVtX2RzdCBzdWJfZHN0IHNfZHN0IGluXG4gICAgUHJvb2YueHByb2dyZXNzIHByb29mIGhkIChUTGluayBbXSkgc3ViZ29hbHNcblxuXG4gICgqKiBbZWxpbV91bml0cyBmXSBlbGltaW5hdGVzIGFsbCBvY2N1cnJlbmNlcyBvZiB1bml0c1xuICAgICAgaW4gZm9ybXVsYSBbZl0gdXNpbmcgYWxnZWJyYWljIHVuaXQgbGF3cy4gKilcbiAgbGV0IHJlYyBlbGltX3VuaXRzIDogZm9ybSAtPiBmb3JtID0gZnVuY3Rpb25cblxuICAgICgqIEFic29yYmluZyBlbGVtZW50cyAqKVxuXG4gICAgfCBGQ29ubiAoYEFuZCwgW187IEZGYWxzZV0pXG4gICAgfCBGQ29ubiAoYEFuZCwgW0ZGYWxzZTsgX10pXG4gICAgfCBGQ29ubiAoYE5vdCwgW0ZUcnVlXSlcbiAgICB8IEZCaW5kIChgRXhpc3QsIF8sIF8sIEZGYWxzZSkgLT5cbiAgICAgICAgRm9ybS5mX2ZhbHNlXG5cbiAgICAoKiB8IEZQcmVkIChcIl9FUVwiLCBbZTE7IGUyXSkgd2hlbiBGb3JtLmVfZXF1YWwgZTEgZTIgLT5cbiAgICAgICAgRm9ybS5mX3RydWUgKilcbiAgICB8IEZDb25uIChgT3IsIFtfOyBGVHJ1ZV0pXG4gICAgfCBGQ29ubiAoYE9yLCBbRlRydWU7IF9dKVxuICAgIHwgRkNvbm4gKGBJbXAsIFtfOyBGVHJ1ZV0pXG4gICAgfCBGQ29ubiAoYEltcCwgW0ZGYWxzZTsgX10pXG4gICAgfCBGQ29ubiAoYE5vdCwgW0ZGYWxzZV0pXG4gICAgfCBGQmluZCAoYEZvcmFsbCwgXywgXywgRlRydWUpIC0+XG4gICAgICAgIEZvcm0uZl90cnVlXG5cbiAgICAoKiBOZXV0cmFsIGVsZW1lbnRzICopXG5cbiAgICB8IEZDb25uIChgQW5kLCBbZjsgRlRydWVdKVxuICAgIHwgRkNvbm4gKGBBbmQsIFtGVHJ1ZTsgZl0pXG4gICAgfCBGQ29ubiAoYE9yLCBbZjsgRkZhbHNlXSlcbiAgICB8IEZDb25uIChgT3IsIFtGRmFsc2U7IGZdKVxuICAgIHwgRkNvbm4gKGBJbXAsIFtGVHJ1ZTsgZl0pXG4gICAgfCBGQ29ubiAoYEVxdWl2LCBbRlRydWU7IGZdKVxuICAgIHwgRkNvbm4gKGBFcXVpdiwgW2Y7IEZUcnVlXSkgLT5cbiAgICAgICAgZWxpbV91bml0cyBmXG4gICAgXG4gICAgfCBGVHJ1ZSB8IEZGYWxzZSB8IEZQcmVkIF8gYXMgZiAtPiBmXG4gICAgfCBGQ29ubiAoYywgZnMpIGFzIGYgLT5cbiAgICAgICAgbGV0IGZzJyA9IExpc3QubWFwIGVsaW1fdW5pdHMgZnMgaW5cbiAgICAgICAgaWYgZnMgPSBmcycgdGhlbiBmIGVsc2UgZWxpbV91bml0cyAoRkNvbm4gKGMsIGZzJykpXG4gICAgfCBGQmluZCAoYiwgeCwgdHksIGYxKSBhcyBmIC0+XG4gICAgICAgIGxldCBmMScgPSBlbGltX3VuaXRzIGYxIGluXG4gICAgICAgIGlmIGYxID0gZjEnIHRoZW4gZiBlbHNlIGVsaW1fdW5pdHMgKEZCaW5kIChiLCB4LCB0eSwgZjEnKSlcbiAgXG5cbiAgbGV0IHByaW50X2xpbmthZ2UgKG1vZGUgOiBbYEJhY2t3YXJkIHwgYEZvcndhcmRdKSAoKGwsIF8pLCAociwgXykpID1cbiAgICBsZXQgb3AgPSBtYXRjaCBtb2RlIHdpdGggYEJhY2t3YXJkIC0+IFwi4oqiXCIgfCBgRm9yd2FyZCAtPiBcIuKIl1wiIGluXG4gICAgUHJpbnRmLnNwcmludGYgXCIlcyAlcyAlc1wiXG4gICAgICAoTm90YXRpb24uZl90b3N0cmluZyBsKSBvcCAoTm90YXRpb24uZl90b3N0cmluZyByKSBcbiAgXG4gICgqKiBbZGxpbmtdIHN0YW5kcyBmb3IgX2RfZWVwIGxpbmtpbmcsIGFuZCBpbXBsZW1lbnRzIHRoZSBkZWVwIGludGVyYWN0aW9uIHBoYXNlXG4gICAgICDDoCBsYSBDaGF1ZGh1cmkgZm9yIGludHVpdGlvbmlzdGljIGxvZ2ljLiAqKVxuICBsZXQgZGxpbmsgKHNyYywgZHN0IDogbGluaykgKHNfc3JjLCBzX2RzdCA6IEZvcm0uU3Vic3Quc3Vic3QgKiBGb3JtLlN1YnN0LnN1YnN0KSA6IHRhY3RpYyA9XG4gICAgZnVuIChwcm9vZiwgZ19pZCkgLT5cblxuICAgIGxldCBvcGVuIEZvcm0gaW5cbiAgICBsZXQgb3BlbiBTdWJzdCBpblxuICAgIGxldCBvcGVuIFByb29mIGluXG4gICAgXG4gICAgbGV0IHsgZ19wcmVnb2FsID0gZ29hbDsgXyB9LCBpdGVtX3NyYywgKHN1Yl9zcmMsIHRfc3JjKSA9IG9mX2lwYXRoIHByb29mIHNyYyBpblxuICAgIGxldCBfLCBpdGVtX2RzdCwgKHN1Yl9kc3QsIHRfZHN0KSA9IG9mX2lwYXRoIHByb29mIGRzdCBpblxuXG4gICAgYmVnaW4gbWF0Y2ggdF9zcmMsIHRfZHN0IHdpdGhcbiAgICAgIHwgYEYgXywgYEUgXyB8IGBFIF8sIGBGIF8gLT4gcmFpc2UgVGFjdGljTm90QXBwbGljYWJsZVxuICAgICAgfCBfIC0+ICgpXG4gICAgZW5kO1xuXG4gICAgKCoqIFt3ZWxsX3Njb3BlZCBsZW52IGVdIHJldHVybnMgW3RydWVdIGlmIGFsbCB2YXJpYWJsZXMgaW4gdGhlXG4gICAgICAgIGV4cHJlc3Npb24gW2VdIGFyZSBib3VuZCBlaXRoZXIgaW4gdGhlIGdsb2JhbCBlbnZpcm9ubWVudCBbZ29hbC5nX2Vudl0sXG4gICAgICAgIG9yIGluIHRoZSBsb2NhbCBlbnZpcm9ubWVudCBbbGVudl0uICopXG4gICAgbGV0IHdlbGxfc2NvcGVkIGN0eCBlID1cbiAgICAgIGVfdmFycyBlIHw+IExpc3QuZm9yX2FsbCBiZWdpbiBmdW4geCAtPlxuICAgICAgICBmY19pc19ib3VuZCB4IGN0eCB8fFxuICAgICAgICBWYXJzLmV4aXN0cyBnb2FsLmdfZW52IChmY19leGl0IHggY3R4KVxuICAgICAgZW5kXG4gICAgaW5cblxuICAgICgqKiBbaW5zdGFudGlhYmxlIGxlbnYgY3R4IHMgeF0gcmV0dXJucyBbdHJ1ZV0gaWYgdGhlIHZhcmlhYmxlIFt4XSBpc1xuICAgICAgICBlaXRoZXIgZmxleCwgb3IgYm91bmQgaW4gc3Vic3RpdHV0aW9uIFtzXSB0byBhbiBleHByZXNzaW9uIFtlXSB3aGljaCBpc1xuICAgICAgICB3ZWxsLXNjb3BlZC4gKilcbiAgICBsZXQgaW5zdGFudGlhYmxlIGxlbnYgY3R4IHMgeCA9XG4gICAgICBsZXQgbGVudiA9IExFbnYuZW50ZXIgbGVudiB4IGluXG4gICAgICBtYXRjaCBnZXRfdGFnICh4LCBMRW52LmdldF9pbmRleCBsZW52IHgpIHMgd2l0aFxuICAgICAgfCBTb21lIFNib3VuZCBlIC0+IHdlbGxfc2NvcGVkIGN0eCBlXG4gICAgICB8IFNvbWUgU2ZsZXggLT4gdHJ1ZVxuICAgICAgfCBOb25lIC0+IGZhbHNlXG4gICAgaW5cblxuICAgIGxldCBpbnZlcnRpYmxlIChraW5kIDogW2BMZWZ0IHwgYFJpZ2h0IHwgYEZvcndhcmRdKSAoZiA6IGZvcm0pIDogYm9vbCA9XG4gICAgICBtYXRjaCBraW5kIHdpdGhcbiAgICAgICgqIFJpZ2h0IGludmVydGlibGUgKilcbiAgICAgIHwgYFJpZ2h0IC0+IGJlZ2luIG1hdGNoIGYgd2l0aFxuICAgICAgICB8IEZDb25uIChjLCBfKSAtPiBiZWdpbiBtYXRjaCBjIHdpdGhcbiAgICAgICAgICB8IGBJbXAgfCBgTm90IHwgYEVxdWl2IC0+IHRydWVcbiAgICAgICAgICB8IF8gLT4gZmFsc2VcbiAgICAgICAgICBlbmRcbiAgICAgICAgfCBGQmluZCAoYEZvcmFsbCwgXywgXywgXykgLT4gdHJ1ZVxuICAgICAgICB8IF8gLT4gZmFsc2VcbiAgICAgICAgZW5kXG4gICAgICAoKiBMZWZ0IGludmVydGlibGUgKilcbiAgICAgIHwgYExlZnQgLT4gYmVnaW4gbWF0Y2ggZiB3aXRoXG4gICAgICAgIHwgRkNvbm4gKGMsIF8pIC0+IGJlZ2luIG1hdGNoIGMgd2l0aFxuICAgICAgICAgIHwgYE9yIC0+IHRydWVcbiAgICAgICAgICB8IF8gLT4gZmFsc2VcbiAgICAgICAgICBlbmRcbiAgICAgICAgfCBGQmluZCAoYEV4aXN0LCBfLCBfLCBfKSAtPiB0cnVlXG4gICAgICAgIHwgXyAtPiBmYWxzZVxuICAgICAgICBlbmRcbiAgICAgICgqIEZvcndhcmQgaW52ZXJ0aWJsZSAqKVxuICAgICAgfCBgRm9yd2FyZCAtPiBiZWdpbiBtYXRjaCBmIHdpdGhcbiAgICAgICAgfCBGQ29ubiAoYywgXykgLT4gYmVnaW4gbWF0Y2ggYyB3aXRoXG4gICAgICAgICAgfCBfIC0+IGZhbHNlXG4gICAgICAgICAgZW5kXG4gICAgICAgIHwgRkJpbmQgKGBFeGlzdCwgXywgXywgXykgLT4gdHJ1ZVxuICAgICAgICB8IF8gLT4gZmFsc2VcbiAgICAgICAgZW5kXG4gICAgaW5cblxuICAgIGxldCBub19wcmlvIGtpbmQgKGYsIHN1YiA6IGZvcm0gKiBpbnQgbGlzdCkgPVxuICAgICAgbGV0IGludiA9IGludmVydGlibGUga2luZCBmIGluXG4gICAgICBub3QgaW52IHx8IExpc3QuaXNfZW1wdHkgc3ViXG4gICAgaW5cblxuICAgIGxldCByZWMgYmFja3dhcmQgKGN0eCA6IGZjdHgpIChpdHJhY2UgOiBpdHJhY2UpXG4gICAgICAoKGVudjEsIHMxIGFzIGVzMSksIChlbnYyLCBzMiBhcyBlczIpIGFzIHMgOiAoTEVudi5sZW52ICogc3Vic3QpICogKExFbnYubGVudiAqIHN1YnN0KSlcbiAgICAgICgoKGwsIGxzdWIgYXMgaCksIChyLCByc3ViIGFzIGMpKSBhcyBsaW5rYWdlIDogKGZvcm0gKiBpbnQgbGlzdCkgKiAoZm9ybSAqIGludCBsaXN0KSkgOiBmb3JtICogaXRyYWNlID1cbiAgICAgIFxuICAgICAgKCoganNfbG9nIChTdWJzdC50b19zdHJpbmcgczEgXiBcIiDiiqIgXCIgXiBTdWJzdC50b19zdHJpbmcgczIpOyAqKVxuICAgICAganNfbG9nIChwcmludF9saW5rYWdlIGBCYWNrd2FyZCBsaW5rYWdlKTtcbiAgICAgIFxuICAgICAgbWF0Y2ggbGlua2FnZSB3aXRoXG5cbiAgICAgICgqKiBFbmQgcnVsZXMgKilcblxuICAgICAgfCAoXywgW10pLCAoXywgW10pIC0+XG4gICAgICAgIGxldCBmID0gYmVnaW4gbWF0Y2ggbCwgciB3aXRoXG5cbiAgICAgICAgICAoKiBCaWQgKilcbiAgICAgICAgICB8IF8gd2hlbiBmX2VxdWFsIGdvYWwuZ19lbnYgbCByIC0+IGZfdHJ1ZVxuICAgICAgICAgIHwgRlByZWQgKGMxLCB0czEpLCBGUHJlZCAoYzIsIHRzMikgd2hlbiBjMSA9IGMyIC0+XG4gICAgICAgICAgICBMaXN0LmZvbGRfbGVmdDJcbiAgICAgICAgICAgICAgKGZ1biBmIHQxIHQyIC0+IGZfYW5kIGYgKEZQcmVkIChcIl9FUVwiLCBbdDE7IHQyXSkpKVxuICAgICAgICAgICAgICBmX3RydWUgdHMxIHRzMlxuICAgICAgICBcbiAgICAgICAgICAoKiBCcmVsICopXG4gICAgICAgICAgfCBfIC0+IGZfaW1wIGwgclxuICAgICAgICAgIGVuZFxuICAgICAgICBpbiBmY19maWxsIGYgKGZjX3JldiBjdHgpLCBpdHJhY2VcbiAgICAgIFxuICAgICAgfCAoRlByZWQgKFwiX0VRXCIsIFtlMTsgZTJdKSwgW2ldKSwgX1xuICAgICAgICB3aGVuIGVfZXF1YWwgZ29hbC5nX2VudiAoc3ViZXhwciAoYEYgcikgcnN1YikgKGlmIGkgPSAwIHRoZW4gZTEgZWxzZSBlMikgLT5cbiAgICAgICAgbGV0IHJlcyA9XG4gICAgICAgICAgKCogTD3igoEgKilcbiAgICAgICAgICBpZiBpID0gMCB0aGVuIGUyXG4gICAgICAgICAgKCogTD3igoIgKilcbiAgICAgICAgICBlbHNlIGUxIGluXG4gICAgICAgIGxldCBmID0gcmV3cml0ZV9zdWJ0ZXJtIChgRSByZXMpIChgRiByKSByc3ViIHw+IGZvcm1fb2ZfdGVybSBpblxuICAgICAgICBmY19maWxsIGYgKGZjX3JldiBjdHgpLCBpdHJhY2VcbiAgICAgIFxuICAgICAgKCoqIENvbW11dGluZyBydWxlcyAqKVxuXG4gICAgICB8IF8gLT5cbiAgICAgICAgbGV0IHN3aXRjaF9wb2wgPSByZWYgZmFsc2UgaW5cbiAgICAgICAgbGV0IHMgPSByZWYgcyBpblxuXG4gICAgICAgIGxldCAoaWN0eCA6IGlmY3R4IG9wdGlvbiksXG4gICAgICAgICAgICAoY2hvaWNlIDogY2hvaWNlKSxcbiAgICAgICAgICAgIChsaW5rYWdlIDogKGZvcm0gKiBpbnQgbGlzdCkgKiAoZm9ybSAqIGludCBsaXN0KSkgPVxuICAgICAgICAgIFxuICAgICAgICAgIGJlZ2luIG1hdGNoIGxpbmthZ2Ugd2l0aFxuICAgICAgICAgICAgXG4gICAgICAgICAgKCoqIFJpZ2h0IHJ1bGVzICopXG5cbiAgICAgICAgICAoKiBS4oinICopXG4gICAgICAgICAgfCBfLCAoRkNvbm4gKGBBbmQsIGZzKSwgaSA6OiBzdWIpXG4gICAgICAgICAgICB3aGVuIG5vX3ByaW8gYExlZnQgaCAtPlxuICAgICAgICAgICAgYmVnaW4gdHJ5XG4gICAgICAgICAgICAgIGxldCBmaSwgZnMgPSBMaXN0LnBvcF9hdCBpIGZzIGluXG4gICAgICAgICAgICAgIFNvbWUgKENDb25uIChgQW5kLCBmcywgaSkpLCAoMSwgTm9uZSksIChoLCAoZmksIHN1YikpXG4gICAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAgICAgICBmYWlsd2l0aCBcImVtcHR5IGNvbmp1bmN0aW9uXCJcbiAgICAgICAgICAgIGVuZFxuXG4gICAgICAgICAgKCogUuKIqCAqKVxuICAgICAgICAgIHwgXywgKEZDb25uIChgT3IsIGZzKSwgaSA6OiBzdWIpXG4gICAgICAgICAgICB3aGVuIG5vX3ByaW8gYExlZnQgaCAtPlxuICAgICAgICAgICAgYmVnaW4gdHJ5XG4gICAgICAgICAgICAgIGxldCBmaSwgZnMgPSBMaXN0LnBvcF9hdCBpIGZzIGluXG4gICAgICAgICAgICAgIFNvbWUgKENDb25uIChgT3IsIGZzLCBpKSksICgxLCBOb25lKSwgKGgsIChmaSwgc3ViKSlcbiAgICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgICAgIGZhaWx3aXRoIFwiZW1wdHkgZGlzanVuY3Rpb25cIlxuICAgICAgICAgICAgZW5kXG5cbiAgICAgICAgICAoKiBS4oeS4oKBICopXG4gICAgICAgICAgfCBfLCAoRkNvbm4gKGBJbXAsIFtmMTsgZjJdKSwgMCA6OiBzdWIpIC0+XG4gICAgICAgICAgICBzd2l0Y2hfcG9sIDo9IHRydWU7XG4gICAgICAgICAgICBTb21lIChDQ29ubiAoYEltcCwgW2YyXSwgMCkpLCAoMSwgTm9uZSksIChoLCAoZjEsIHN1YikpXG5cbiAgICAgICAgICAoKiBS4oeS4oKCICopXG4gICAgICAgICAgfCBfLCAoRkNvbm4gKGBJbXAsIFtmMTsgZjJdKSwgMSA6OiBzdWIpIC0+XG4gICAgICAgICAgICBTb21lIChDQ29ubiAoYEltcCwgW2YxXSwgMSkpLCAoMSwgTm9uZSksIChoLCAoZjIsIHN1YikpXG5cbiAgICAgICAgICAoKiBSwqwgKilcbiAgICAgICAgICB8IF8sIChGQ29ubiAoYE5vdCwgW2YxXSksIDAgOjogc3ViKSAtPlxuICAgICAgICAgICAgc3dpdGNoX3BvbCA6PSB0cnVlO1xuICAgICAgICAgICAgU29tZSAoQ0Nvbm4gKGBOb3QsIFtdLCAwKSksICgxLCBOb25lKSwgKGgsIChmMSwgc3ViKSlcblxuICAgICAgICAgIHwgXywgKEZDb25uIChgRXF1aXYsIFtfOyBfXSksIF8pIC0+XG4gICAgICAgICAgICBmYWlsd2l0aCBcIkRuRCBvbiBwb3NpdGl2ZSBlcXVpdmFsZW5jZSBjdXJyZW50bHkgdW5zdXBwb3J0ZWRcIlxuXG4gICAgICAgICAgfCBfLCAoRkJpbmQgKGBFeGlzdCwgeCwgdHksIGYxKSwgMCA6OiBzdWIpXG4gICAgICAgICAgICB3aGVuIG5vX3ByaW8gYExlZnQgaCAmJlxuICAgICAgICAgICAgaW5zdGFudGlhYmxlIGVudjIgY3R4IHMyIHhcbiAgICAgICAgICAgIC0+XG4gICAgICAgICAgICBsZXQgZW52MiA9IExFbnYuZW50ZXIgZW52MiB4IGluXG4gICAgICAgICAgICBzIDo9IGVzMSwgKGVudjIsIHMyKTtcbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGdldF90YWcgKHgsIExFbnYuZ2V0X2luZGV4IGVudjIgeCkgczIgd2l0aFxuICAgICAgICAgICAgKCogUuKIg2kgKilcbiAgICAgICAgICAgIHwgU29tZSBTYm91bmQgZSAtPlxuICAgICAgICAgICAgICBsZXQgZjEgPSBTdWJzdC5mX2FwcGx5MSAoeCwgMCkgZSBmMSBpblxuICAgICAgICAgICAgICBOb25lLCAoMSwgU29tZSBlKSwgKGgsIChmMSwgc3ViKSlcbiAgICAgICAgICAgICgqIFLiiINzICopXG4gICAgICAgICAgICB8IFNvbWUgU2ZsZXggLT5cbiAgICAgICAgICAgICAgcyA6PSBlczEsIChlbnYyLCBzMik7XG4gICAgICAgICAgICAgIGxldCBoID0gKGZfc2hpZnQgKHgsIDApIGwpLCBsc3ViIGluXG4gICAgICAgICAgICAgIFNvbWUgKENCaW5kIChgRXhpc3QsIHgsIHR5KSksICgxLCBOb25lKSwgKGgsIChmMSwgc3ViKSlcbiAgICAgICAgICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgIGVuZFxuXG4gICAgICAgICAgKCogUuKIgHMgKilcbiAgICAgICAgICB8IF8sIChGQmluZCAoYEZvcmFsbCwgeCwgdHksIGYxKSwgMCA6OiBzdWIpIC0+XG4gICAgICAgICAgICBzIDo9IGVzMSwgKExFbnYuZW50ZXIgZW52MiB4LCBzMik7XG4gICAgICAgICAgICBsZXQgaCA9IChmX3NoaWZ0ICh4LCAwKSBsKSwgbHN1YiBpblxuICAgICAgICAgICAgU29tZSAoQ0JpbmQgKGBGb3JhbGwsIHgsIHR5KSksICgxLCBOb25lKSwgKGgsIChmMSwgc3ViKSlcblxuICAgICAgICAgICgqKiBMZWZ0IHJ1bGVzICopXG5cbiAgICAgICAgICAoKiBM4oinICopXG4gICAgICAgICAgfCAoRkNvbm4gKGBBbmQsIGZzKSwgaSA6OiBzdWIpLCBfXG4gICAgICAgICAgICB3aGVuIG5vX3ByaW8gYFJpZ2h0IGMgLT5cbiAgICAgICAgICAgIGJlZ2luIHRyeVxuICAgICAgICAgICAgICBOb25lLCAoMCwgTm9uZSksICgoKExpc3QuYXQgZnMgaSksIHN1YiksIGMpXG4gICAgICAgICAgICB3aXRoIEludmFsaWRfYXJndW1lbnQgXyAtPlxuICAgICAgICAgICAgICBmYWlsd2l0aCBcImVtcHR5IGNvbmp1bmN0aW9uXCJcbiAgICAgICAgICAgIGVuZFxuXG4gICAgICAgICAgKCogTOKIqCAqKVxuICAgICAgICAgIHwgKEZDb25uIChgT3IsIGZzKSwgaSA6OiBzdWIpLCBfIC0+XG4gICAgICAgICAgICBiZWdpbiB0cnlcbiAgICAgICAgICAgICAgbGV0IGZpLCBmcyA9IExpc3QucG9wX2F0IGkgZnMgaW5cbiAgICAgICAgICAgICAgbGV0IGZzID0gTGlzdC5tYXAgKGZ1biBmaiAtPiBmX2ltcCBmaiByKSBmcyBpblxuICAgICAgICAgICAgICBTb21lIChDQ29ubiAoYEFuZCwgZnMsIGkpKSwgKDAsIE5vbmUpLCAoKGZpLCBzdWIpLCBjKVxuICAgICAgICAgICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgICAgZmFpbHdpdGggXCJlbXB0eSBkaXNqdW5jdGlvblwiXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBcbiAgICAgICAgICAoKiBM4oeS4oKCICopXG4gICAgICAgICAgfCAoRkNvbm4gKGBJbXAsIFtmMTsgZjJdKSwgMSA6OiBzdWIpLCBfXG4gICAgICAgICAgICB3aGVuIG5vX3ByaW8gYFJpZ2h0IGMgLT5cbiAgICAgICAgICAgIFNvbWUgKENDb25uIChgQW5kLCBbZjFdLCAxKSksICgwLCBOb25lKSwgKChmMiwgc3ViKSwgYylcblxuICAgICAgICAgICgqIEzih5TigoEgKilcbiAgICAgICAgICB8IChGQ29ubiAoYEVxdWl2LCBbZjE7IGYyXSksIDAgOjogc3ViKSwgX1xuICAgICAgICAgICAgd2hlbiBub19wcmlvIGBSaWdodCBjIC0+XG4gICAgICAgICAgICBTb21lIChDQ29ubiAoYEFuZCwgW2YyXSwgMCkpLCAoMCwgTm9uZSksICgoZjEsIHN1YiksIGMpXG5cbiAgICAgICAgICAoKiBM4oeU4oKCICopXG4gICAgICAgICAgfCAoRkNvbm4gKGBFcXVpdiwgW2YxOyBmMl0pLCAxIDo6IHN1YiksIF9cbiAgICAgICAgICAgIHdoZW4gbm9fcHJpbyBgUmlnaHQgYyAtPlxuICAgICAgICAgICAgU29tZSAoQ0Nvbm4gKGBBbmQsIFtmMV0sIDEpKSwgKDAsIE5vbmUpLCAoKGYyLCBzdWIpLCBjKVxuICAgICAgICAgIFxuICAgICAgICAgICgqIEziiINzICopXG4gICAgICAgICAgfCAoRkJpbmQgKGBFeGlzdCwgeCwgdHksIGYxKSwgMCA6OiBzdWIpLCBfIC0+XG4gICAgICAgICAgICBzIDo9IChMRW52LmVudGVyIGVudjEgeCwgczEpLCBlczI7XG4gICAgICAgICAgICBsZXQgYyA9IChmX3NoaWZ0ICh4LCAwKSByKSwgcnN1YiBpblxuICAgICAgICAgICAgU29tZSAoQ0JpbmQgKGBGb3JhbGwsIHgsIHR5KSksICgwLCBOb25lKSwgKChmMSwgc3ViKSwgYylcblxuICAgICAgICAgIHwgKEZCaW5kIChgRm9yYWxsLCB4LCB0eSwgZjEpLCAwIDo6IHN1YiksIF9cbiAgICAgICAgICAgIHdoZW4gbm9fcHJpbyBgUmlnaHQgYyAmJlxuICAgICAgICAgICAgaW5zdGFudGlhYmxlIGVudjEgY3R4IHMxIHhcbiAgICAgICAgICAgIC0+XG4gICAgICAgICAgICBsZXQgZW52MSA9IExFbnYuZW50ZXIgZW52MSB4IGluXG4gICAgICAgICAgICBzIDo9IChlbnYxLCBzMSksIGVzMjtcbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGdldF90YWcgKHgsIExFbnYuZ2V0X2luZGV4IGVudjEgeCkgczEgd2l0aFxuICAgICAgICAgICAgKCogTOKIgGkgKilcbiAgICAgICAgICAgIHwgU29tZSBTYm91bmQgZSAtPlxuICAgICAgICAgICAgICBsZXQgZjEgPSBmX2FwcGx5MSAoeCwgMCkgZSBmMSBpblxuICAgICAgICAgICAgICBOb25lLCAoMCwgU29tZSBlKSwgKChmMSwgc3ViKSwgYylcbiAgICAgICAgICAgICgqIEziiIBzICopXG4gICAgICAgICAgICB8IFNvbWUgU2ZsZXggLT5cbiAgICAgICAgICAgICAgcyA6PSAoZW52MSwgczEpLCBlczI7XG4gICAgICAgICAgICAgIGxldCBjID0gKGZfc2hpZnQgKHgsIDApIHIpLCByc3ViIGluXG4gICAgICAgICAgICAgIFNvbWUgKENCaW5kIChgRXhpc3QsIHgsIHR5KSksICgwLCBOb25lKSwgKChmMSwgc3ViKSwgYylcbiAgICAgICAgICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgIGVuZFxuXG4gICAgICAgICAgfCBfIC0+IHJhaXNlIFRhY3RpY05vdEFwcGxpY2FibGVcbiAgICAgICAgICBlbmRcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGNvbnQgPSBpZiAhc3dpdGNoX3BvbCB0aGVuIGZvcndhcmQgfnNpZGU6MSBlbHNlIGJhY2t3YXJkIGluXG4gICAgICAgIGxldCBjdHggPSBtYXRjaCBpY3R4IHdpdGhcbiAgICAgICAgICB8IFNvbWUgaSAtPiBpIDo6IGN0eFxuICAgICAgICAgIHwgTm9uZSAtPiBjdHggaW4gXG4gICAgICAgIGNvbnQgY3R4IChjaG9pY2UgOjogaXRyYWNlKSAhcyBsaW5rYWdlXG4gICAgICBcblxuICAgIGFuZCBmb3J3YXJkIChjdHggOiBmY3R4KSAoaXRyYWNlIDogaXRyYWNlKSA/KHNpZGUgPSAxKVxuICAgICAgKGVzMSwgKGVudjIsIHMyIGFzIGVzMikgYXMgcyA6IChMRW52LmxlbnYgKiBzdWJzdCkgKiAoTEVudi5sZW52ICogc3Vic3QpKVxuICAgICAgKCgobCwgbHN1YiBhcyBoKSwgKHIsIHJzdWIpKSBhcyBsaW5rYWdlIDogKGZvcm0gKiBpbnQgbGlzdCkgKiAoZm9ybSAqIGludCBsaXN0KSkgOiBmb3JtICogaXRyYWNlID1cblxuICAgICAganNfbG9nIChwcmludF9saW5rYWdlIGBGb3J3YXJkIGxpbmthZ2UpO1xuICAgICAgXG4gICAgICBtYXRjaCBsaW5rYWdlIHdpdGhcblxuICAgICAgKCoqIEVuZCBydWxlcyAqKVxuXG4gICAgICB8IChfLCBbXSksIChfLCBbXSkgLT5cblxuICAgICAgICBsZXQgZiA9IGJlZ2luIG1hdGNoIGwsIHIgd2l0aFxuICAgICAgICAgICgqIEZpZCAqKVxuICAgICAgICAgIHwgXyB3aGVuIGZfZXF1YWwgZ29hbC5nX2VudiBsIHIgLT4gbFxuXG4gICAgICAgICAgKCogRnJlbCAqKVxuICAgICAgICAgIHwgXyAtPiBmX2FuZCBsIHJcbiAgICAgICAgZW5kIGluXG4gICAgICAgIGZjX2ZpbGwgZiAoZmNfcmV2IGN0eCksIGl0cmFjZVxuXG4gICAgICB8IChGUHJlZCAoXCJfRVFcIiwgW2UxOyBlMl0pLCBbaV0pLCBfXG4gICAgICAgIHdoZW4gZV9lcXVhbCBnb2FsLmdfZW52IChzdWJleHByIChgRiByKSByc3ViKSAoaWYgaSA9IDAgdGhlbiBlMSBlbHNlIGUyKSAtPlxuICAgICAgICBsZXQgcmVzID1cbiAgICAgICAgICAoKiBMPeKCgSAqKVxuICAgICAgICAgIGlmIGkgPSAwIHRoZW4gZTJcbiAgICAgICAgICAoKiBMPeKCgiAqKVxuICAgICAgICAgIGVsc2UgZTEgaW5cbiAgICAgICAgbGV0IGYgPSByZXdyaXRlX3N1YnRlcm0gKGBFIHJlcykgKGBGIHIpIHJzdWIgfD4gZm9ybV9vZl90ZXJtIGluXG4gICAgICAgIGZjX2ZpbGwgZiAoZmNfcmV2IGN0eCksIGl0cmFjZVxuXG4gICAgICAoKiogQ29tbXV0aW5nIHJ1bGVzICopXG5cbiAgICAgIHwgXyAtPlxuICAgICAgICBsZXQgc3dpdGNoX3BvbCA9IHJlZiBmYWxzZSBpblxuICAgICAgICBsZXQgcyA9IHJlZiBzIGluXG4gICAgICAgIGxldCBuZXdfc2lkZSA9IHJlZiBzaWRlIGluXG4gICAgICAgIGxldCB3aXRuZXNzID0gcmVmIE5vbmUgaW5cblxuICAgICAgICBsZXQgKGljdHggOiBpZmN0eCBvcHRpb24pLFxuICAgICAgICAgICAgKGxpbmthZ2UgOiAoZm9ybSAqIGludCBsaXN0KSAqIChmb3JtICogaW50IGxpc3QpKSA9XG4gICAgICAgICAgXG4gICAgICAgICAgYmVnaW4gbWF0Y2ggbGlua2FnZSB3aXRoXG5cbiAgICAgICAgICAoKiBG4oinICopXG4gICAgICAgICAgfCBfLCAoRkNvbm4gKGBBbmQsIGZzKSwgaSA6OiBzdWIpIC0+XG4gICAgICAgICAgICBiZWdpbiB0cnlcbiAgICAgICAgICAgICAgTm9uZSwgKGgsICgoTGlzdC5hdCBmcyBpKSwgc3ViKSlcbiAgICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgICAgIGZhaWx3aXRoIFwiZW1wdHkgY29uanVuY3Rpb25cIlxuICAgICAgICAgICAgZW5kXG5cbiAgICAgICAgICAoKiBG4oioICopXG4gICAgICAgICAgfCBfLCAoRkNvbm4gKGBPciwgZnMpLCBpIDo6IHN1YilcbiAgICAgICAgICAgIHdoZW4gbm9fcHJpbyBgRm9yd2FyZCBoIC0+XG4gICAgICAgICAgICBiZWdpbiB0cnlcbiAgICAgICAgICAgICAgbGV0IGZpLCBmcyA9IExpc3QucG9wX2F0IGkgZnMgaW5cbiAgICAgICAgICAgICAgU29tZSAoQ0Nvbm4gKGBPciwgZnMsIGkpKSwgKGgsIChmaSwgc3ViKSlcbiAgICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgICAgIGZhaWx3aXRoIFwiZW1wdHkgZGlzanVuY3Rpb25cIlxuICAgICAgICAgICAgZW5kXG5cbiAgICAgICAgICAoKiBG4oeS4oKBICopXG4gICAgICAgICAgfCBfLCAoRkNvbm4gKGBJbXAsIFtmMTsgZjJdKSwgMCA6OiBzdWIpXG4gICAgICAgICAgICB3aGVuIG5vX3ByaW8gYEZvcndhcmQgaCAtPlxuICAgICAgICAgICAgc3dpdGNoX3BvbCA6PSB0cnVlO1xuICAgICAgICAgICAgU29tZSAoQ0Nvbm4gKGBJbXAsIFtmMl0sIDApKSwgKGgsIChmMSwgc3ViKSlcblxuICAgICAgICAgICgqIEbih5LigoIgKilcbiAgICAgICAgICB8IF8sIChGQ29ubiAoYEltcCwgW2YxOyBmMl0pLCAxIDo6IHN1YilcbiAgICAgICAgICAgIHdoZW4gbm9fcHJpbyBgRm9yd2FyZCBoIC0+XG4gICAgICAgICAgICBTb21lIChDQ29ubiAoYEltcCwgW2YxXSwgMSkpLCAoaCwgKGYyLCBzdWIpKVxuXG4gICAgICAgICAgKCogRsKsICopXG4gICAgICAgICAgfCBfLCAoRkNvbm4gKGBOb3QsIFtmMV0pLCAwIDo6IHN1YilcbiAgICAgICAgICAgIHdoZW4gbm9fcHJpbyBgRm9yd2FyZCBoIC0+XG4gICAgICAgICAgICBzd2l0Y2hfcG9sIDo9IHRydWU7XG4gICAgICAgICAgICBTb21lIChDQ29ubiAoYE5vdCwgW10sIDApKSwgKGgsIChmMSwgc3ViKSlcblxuICAgICAgICAgICgqIEbih5TigoEgKilcbiAgICAgICAgICB8IF8sIChGQ29ubiAoYEVxdWl2LCBbZjE7IGYyXSksIDAgOjogc3ViKVxuICAgICAgICAgICAgd2hlbiBub19wcmlvIGBGb3J3YXJkIGggLT5cbiAgICAgICAgICAgIHN3aXRjaF9wb2wgOj0gdHJ1ZTtcbiAgICAgICAgICAgIFNvbWUgKENDb25uIChgSW1wLCBbZjJdLCAwKSksIChoLCAoZjEsIHN1YikpXG5cbiAgICAgICAgICAoKiBG4oeU4oKCICopXG4gICAgICAgICAgfCBfLCAoRkNvbm4gKGBFcXVpdiwgW2YxOyBmMl0pLCAxIDo6IHN1YilcbiAgICAgICAgICAgIHdoZW4gbm9fcHJpbyBgRm9yd2FyZCBoIC0+XG4gICAgICAgICAgICBzd2l0Y2hfcG9sIDo9IHRydWU7XG4gICAgICAgICAgICBTb21lIChDQ29ubiAoYEltcCwgW2YxXSwgMCkpLCAoaCwgKGYyLCBzdWIpKVxuICAgICAgICAgIFxuICAgICAgICAgICgqIEbiiINzICopXG4gICAgICAgICAgfCBfLCAoRkJpbmQgKGBFeGlzdCwgeCwgdHksIGYxKSwgMCA6OiBzdWIpIC0+XG4gICAgICAgICAgICBzIDo9IGVzMSwgKExFbnYuZW50ZXIgZW52MiB4LCBzMik7XG4gICAgICAgICAgICBsZXQgaCA9IChmX3NoaWZ0ICh4LCAwKSBsKSwgbHN1YiBpblxuICAgICAgICAgICAgU29tZSAoQ0JpbmQgKGBFeGlzdCwgeCwgdHkpKSwgKGgsIChmMSwgc3ViKSlcbiAgICAgICAgICBcbiAgICAgICAgICB8IF8sIChGQmluZCAoYEZvcmFsbCwgeCwgdHksIGYxKSwgMCA6OiBzdWIpXG4gICAgICAgICAgICB3aGVuIG5vX3ByaW8gYEZvcndhcmQgaCAmJlxuICAgICAgICAgICAgaW5zdGFudGlhYmxlIGVudjIgY3R4IHMyIHhcbiAgICAgICAgICAgIC0+XG4gICAgICAgICAgICBsZXQgZW52MiA9IExFbnYuZW50ZXIgZW52MiB4IGluXG4gICAgICAgICAgICBzIDo9IGVzMSwgKGVudjIsIHMyKTtcbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGdldF90YWcgKHgsIExFbnYuZ2V0X2luZGV4IGVudjIgeCkgczIgd2l0aFxuICAgICAgICAgICAgKCogRuKIgGkgKilcbiAgICAgICAgICAgIHwgU29tZSBTYm91bmQgZSAtPlxuICAgICAgICAgICAgICBsZXQgZjEgPSBTdWJzdC5mX2FwcGx5MSAoeCwgMCkgZSBmMSBpblxuICAgICAgICAgICAgICB3aXRuZXNzIDo9IFNvbWUgZTtcbiAgICAgICAgICAgICAgTm9uZSwgKGgsIChmMSwgc3ViKSlcbiAgICAgICAgICAgICgqIEbiiIBzICopXG4gICAgICAgICAgICB8IFNvbWUgU2ZsZXggLT5cbiAgICAgICAgICAgICAgcyA6PSBlczEsIChMRW52LmVudGVyIGVudjIgeCwgczIpO1xuICAgICAgICAgICAgICBsZXQgaCA9IChmX3NoaWZ0ICh4LCAwKSBsKSwgbHN1YiBpblxuICAgICAgICAgICAgICBTb21lIChDQmluZCAoYEZvcmFsbCwgeCwgdHkpKSwgKGgsIChmMSwgc3ViKSlcbiAgICAgICAgICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgXG4gICAgICAgICAgKCogRmNvbW0gKilcbiAgICAgICAgICB8IGgsIGgnIC0+XG4gICAgICAgICAgICBzIDo9IChlczIsIGVzMSk7XG4gICAgICAgICAgICBuZXdfc2lkZSA6PSAwO1xuICAgICAgICAgICAgTm9uZSwgKGgnLCBoKVxuICAgICAgICAgIGVuZFxuICAgICAgICBpblxuICAgICAgICBsZXQgY29udCA9IGlmICFzd2l0Y2hfcG9sIHRoZW4gYmFja3dhcmQgZWxzZSBmb3J3YXJkIH5zaWRlOiFuZXdfc2lkZSBpblxuICAgICAgICBsZXQgY3R4ID0gbWF0Y2ggaWN0eCB3aXRoXG4gICAgICAgICAgfCBTb21lIGkgLT4gaSA6OiBjdHhcbiAgICAgICAgICB8IE5vbmUgLT4gY3R4IGluIFxuICAgICAgICBsZXQgaXRyYWNlID1cbiAgICAgICAgICBpZiAhbmV3X3NpZGUgPD4gc2lkZSB0aGVuIGl0cmFjZVxuICAgICAgICAgIGVsc2UgKCFuZXdfc2lkZSwgIXdpdG5lc3MpIDo6IGl0cmFjZSBpblxuICAgICAgICBjb250IGN0eCBpdHJhY2UgIXMgbGlua2FnZVxuICAgIGluXG5cbiAgICBsZXQgc3ViZ29hbCwgaXRyYWNlID0gbWF0Y2ggKGl0ZW1fc3JjLCBzdWJfc3JjLCBzX3NyYyksIChpdGVtX2RzdCwgc3ViX2RzdCwgc19kc3QpIHdpdGhcbiAgICAgIHwgKGBIIChoaWQsIHsgaF9mb3JtID0gaDsgXyB9KSwgc3ViaCwgc2gpLCAoYEMgYywgc3ViYywgc2MpXG4gICAgICB8IChgQyBjLCBzdWJjLCBzYyksIChgSCAoaGlkLCB7IGhfZm9ybSA9IGg7IF8gfSksIHN1YmgsIHNoKSAtPlxuICAgICAgICBsZXQgZm9ybSwgaXRyYWNlID0gYmFja3dhcmQgKFtdKSBbXSAoKExFbnYuZW1wdHksIHNoKSwgKExFbnYuZW1wdHksIHNjKSkgKChoLCBzdWJoKSwgKGMsIHN1YmMpKSBpblxuICAgICAgICBbW1NvbWUgaGlkLCBbXV0sIGZvcm0gfD4gZWxpbV91bml0c10sIGl0cmFjZVxuICAgICAgXG4gICAgICB8IChgSCAoaGlkLCB7IGhfZm9ybSA9IGg7IF8gfSksIHN1YmgsIHMpLCAoYEggKGhpZCcsIHsgaF9mb3JtID0gaCc7IF8gfSksIHN1YmgnLCBzJykgLT5cbiAgICAgICAgbGV0IGZvcm0sIGl0cmFjZSA9IGZvcndhcmQgKFtdKSBbXSAoKExFbnYuZW1wdHksIHMpLCAoTEVudi5lbXB0eSwgcycpKSAoKGgsIHN1YmgpLCAoaCcsIHN1YmgnKSkgaW5cbiAgICAgICAgW1tTb21lIGhpZCwgW107IFNvbWUgaGlkJywgW2Zvcm0gfD4gZWxpbV91bml0c11dLCBnb2FsLmdfZ29hbF0sIGl0cmFjZVxuICAgICAgXG4gICAgICB8IF8gLT4gcmFpc2UgVGFjdGljTm90QXBwbGljYWJsZVxuICAgIGluXG4gICAgbGV0IGl0cmFjZSA9IExpc3QucmV2IGl0cmFjZSBpblxuXG4gICAganNfbG9nIChQcmludGYuc3ByaW50ZiBcIml0cmFjZTogJXNcIiAocHJpbnRfaXRyYWNlIGl0cmFjZSkpO1xuXG4gICAgbGV0IHByID0gc3Byb2dyZXNzIH5jbGVhcjpmYWxzZSBwcm9vZiBnX2lkIChUTGluayBpdHJhY2UpIHN1YmdvYWwgaW5cbiAgICBMaXN0LmZvbGRfbGVmdCAodW5jdXJyeSBjbG9zZV93aXRoX3VuaXQpIHByIChvcGVuZWQgcHIpXG5cbiAgXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG4gICgqKiBMb2dpY2FsIGFjdGlvbnMgKilcblxuICB0eXBlIGxpbmthY3Rpb24gPSBbXG4gICAgfCBgTm90aGluZ1xuICAgIHwgYEJvdGggb2YgbGlua2FjdGlvbiAqIGxpbmthY3Rpb25cbiAgICB8IGBTdWJmb3JtIG9mIEZvcm0uU3Vic3Quc3Vic3QgKiBGb3JtLlN1YnN0LnN1YnN0XG4gICAgfCBgSW5zdGFudGlhdGUgb2YgZXhwciAqIGlwYXRoXG4gICAgfCBgUmV3cml0ZSBvZiBleHByICogZXhwciAqIGlwYXRoIGxpc3RcbiAgICB8IGBGb2xkIG9mIHZuYW1lICogaXBhdGggbGlzdFxuICAgIHwgYFVuZm9sZCBvZiB2bmFtZSAqIGlwYXRoIGxpc3RcbiAgXVxuXG4gIGxldCByZW1vdmVfbm90aGluZyA9XG4gICAgbGV0IHJlYyBkb2l0ID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gW11cbiAgICAgIHwgYSA6OiBsIC0+IG1hdGNoIGEgd2l0aFxuICAgICAgICB8IGBOb3RoaW5nIC0+XG4gICAgICAgICAgICBkb2l0IGxcbiAgICAgICAgfCBgQm90aCAoYSwgYScpIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBkb2l0IFthOyBhJ10gd2l0aFxuICAgICAgICAgICAgfCBbXSAtPiBkb2l0IGxcbiAgICAgICAgICAgIHwgW2FdIC0+IGEgOjogZG9pdCBsXG4gICAgICAgICAgICB8IFthOyBhJ10gLT4gYEJvdGggKGEsIGEnKSA6OiBkb2l0IGxcbiAgICAgICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGEgOjogZG9pdCBsXG4gICAgaW4gZG9pdFxuICAgICAgICAgIFxuICBsZXQgc3RyaW5nX29mX2xpbmthY3Rpb24gcHJvb2YgPVxuICAgIGxldCByZWMgZG9pdCA9IGZ1bmN0aW9uXG4gICAgICB8IGBOb3RoaW5nIC0+IFwi4oqlXCJcbiAgICAgIHwgYEJvdGggKGEsIGEnKSAtPiBQcmludGYuc3ByaW50ZiBcIiglcywgJXMpXCIgKGRvaXQgYSkgKGRvaXQgYScpXG4gICAgICB8IGBTdWJmb3JtIF8gLT4gXCJTRkxcIlxuICAgICAgfCBgSW5zdGFudGlhdGUgXyAtPiBcIkluc3RhbnRpYXRlXCJcbiAgICAgIHwgYFJld3JpdGUgKHJlZCwgcmVzLCB0Z3RzKSAtPlxuICAgICAgICAgIFByaW50Zi5zcHJpbnRmIFwiJXNbJXMgfj4gJXNdXCJcbiAgICAgICAgICAgIChMaXN0LnRvX3N0cmluZyB+c2VwOlwiLCBcIiB+bGVmdDpcIntcIiB+cmlnaHQ6XCJ9XCJcbiAgICAgICAgICAgICAgKGZ1biBwIC0+IGxldCBfLCBfLCAoXywgdCkgPSBvZl9pcGF0aCBwcm9vZiBwIGluIE5vdGF0aW9uLnRvc3RyaW5nIHQpXG4gICAgICAgICAgICAgdGd0cylcbiAgICAgICAgICAgIHJlZCByZXNcbiAgICBpbiBkb2l0XG5cbiAgdHlwZSBhY3Rpb24gPSBIYW5kbGUudCAqIFtcbiAgICB8IGBJbnRybyAgICAgb2YgaW50XG4gICAgfCBgRWxpbSAgICAgIG9mIEhhbmRsZS50XG4gICAgfCBgSW5kICAgICAgIG9mIEhhbmRsZS50XG4gICAgfCBgRm9sZCAgICAgIG9mIHZuYW1lXG4gICAgfCBgVW5mb2xkICAgIG9mIHZuYW1lXG4gICAgfCBgSHlwZXJsaW5rIG9mIGh5cGVybGluayAqIGxpbmthY3Rpb24gbGlzdFxuICAgIHwgYEZvcndhcmQgICBvZiBIYW5kbGUudCAqIEhhbmRsZS50ICogKGludCBsaXN0KSAqIEZvcm0uU3Vic3Quc3Vic3QgXG4gICAgfCBgRGlzakRyb3AgIG9mIEhhbmRsZS50ICogZm9ybSBsaXN0XG4gICAgfCBgQ29uakRyb3AgIG9mIEhhbmRsZS50XG4gIF1cbiAgXG4gIFxuICAoKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuICAoKiogKEh5cGVyKWxpbmsgc2VhcmNoIChmb3IgaGlnaGxpZ2h0aW5nKSAqKVxuXG4gIFxuICAoKiogW3Rfc3VicyBmXSByZXR1cm5zIGFsbCB0aGUgcGF0aHMgbGVhZGluZyB0byBhIHN1YnRlcm0gaW4gW3RdLiAqKVxuICBsZXQgdF9zdWJzICh0IDogdGVybSkgOiAoaW50IGxpc3QpIGxpc3QgPVxuXG4gICAgbGV0IHJlYyBhdXggc3ViID0gZnVuY3Rpb25cbiAgICAgIHwgYEUgRUZ1biAoXywgZXMpXG4gICAgICB8IGBGIEZQcmVkIChfLCBlcykgLT5cbiAgICAgICAgZXMgfD4gTGlzdC5tYXBpIChmdW4gaSBlIC0+XG4gICAgICAgICAgICAgICAgbGV0IHN1YiA9IHN1YiBAIFtpXSBpblxuICAgICAgICAgICAgICAgIHN1YiA6OiBhdXggc3ViIChgRSBlKSlcbiAgICAgICAgICAgfD4gTGlzdC5jb25jYXRcbiAgICAgIHwgYEYgRkNvbm4gKF8sIGZzKSAtPlxuICAgICAgICBmcyB8PiBMaXN0Lm1hcGkgKGZ1biBpIGYgLT5cbiAgICAgICAgICAgICAgICBsZXQgc3ViID0gc3ViIEAgW2ldIGluXG4gICAgICAgICAgICAgICAgc3ViIDo6IGF1eCBzdWIgKGBGIGYpKVxuICAgICAgICAgICB8PiBMaXN0LmNvbmNhdFxuICAgICAgfCBgRiBGQmluZCAoXywgXywgXywgZikgLT5cbiAgICAgICAgbGV0IHN1YiA9IHN1YiBAIFswXSBpblxuICAgICAgICBzdWIgOjogYXV4IHN1YiAoYEYgZilcbiAgICAgIHwgXyAtPiBbXVxuXG4gICAgaW4gW10gOjogYXV4IFtdIHRcblxuXG4gICgqKiBbZl9zdWJzIGZdIHJldHVybnMgYWxsIHRoZSBwYXRocyBsZWFkaW5nIHRvIGEgc3ViZm9ybXVsYSBpbiBbZl0uICopXG4gIGxldCBmX3N1YnMgKGYgOiBmb3JtKSA6IChpbnQgbGlzdCkgbGlzdCA9XG5cbiAgICBsZXQgcmVjIGF1eCBzdWIgPSBmdW5jdGlvblxuICAgICAgfCBGQ29ubiAoXywgZnMpIC0+XG4gICAgICAgIGZzIHw+IExpc3QubWFwaSAoZnVuIGkgZiAtPlxuICAgICAgICAgICAgICAgIGxldCBzdWIgPSBzdWIgQCBbaV0gaW5cbiAgICAgICAgICAgICAgICBzdWIgOjogYXV4IHN1YiBmKVxuICAgICAgICAgICB8PiBMaXN0LmNvbmNhdFxuICAgICAgfCBGQmluZCAoXywgXywgXywgZikgLT5cbiAgICAgICAgbGV0IHN1YiA9IHN1YiBAIFswXSBpblxuICAgICAgICBzdWIgOjogYXV4IHN1YiBmXG4gICAgICB8IF8gLT4gW11cblxuICAgIGluIFtdIDo6IChhdXggW10gZilcblxuXG4gICgqKiBbZV9zdWJzIGZdIHJldHVybnMgYWxsIHRoZSBwYXRocyBsZWFkaW5nIHRvIGEgc3ViZXhwcmVzc2lvbiBpbiBbZl0uICopXG4gIGxldCBlX3N1YnMgKGYgOiBmb3JtKSA6IChpbnQgbGlzdCkgbGlzdCA9XG5cbiAgICBsZXQgcmVjIGZfYXV4IHN1YiA9IGZ1bmN0aW9uXG4gICAgICB8IEZQcmVkIChfLCBlcykgLT5cbiAgICAgICAgZXMgfD4gTGlzdC5tYXBpIChmdW4gaSBlIC0+XG4gICAgICAgICAgICAgICAgbGV0IHN1YiA9IHN1YiBAIFtpXSBpblxuICAgICAgICAgICAgICAgIHN1YiA6OiBlX2F1eCBzdWIgZSlcbiAgICAgICAgICAgfD4gTGlzdC5jb25jYXRcbiAgICAgIHwgRkNvbm4gKF8sIGZzKSAtPlxuICAgICAgICBmcyB8PiBMaXN0Lm1hcGkgKGZ1biBpIGYgLT4gZl9hdXggKHN1YiBAIFtpXSkgZilcbiAgICAgICAgICAgfD4gTGlzdC5jb25jYXRcbiAgICAgIHwgRkJpbmQgKF8sIF8sIF8sIGYpIC0+XG4gICAgICAgIGZfYXV4IChzdWIgQCBbMF0pIGZcbiAgICAgIHwgXyAtPiBbXVxuXG4gICAgYW5kIGVfYXV4IHN1YiA9IGZ1bmN0aW9uXG4gICAgICB8IEVWYXIgXyAtPiBbXVxuICAgICAgfCBFRnVuIChfLCBlcykgLT5cbiAgICAgICAgZXMgfD4gTGlzdC5tYXBpIChmdW4gaSBlIC0+XG4gICAgICAgICAgICAgICAgbGV0IHN1YiA9IHN1YiBAIFtpXSBpblxuICAgICAgICAgICAgICAgIHN1YiA6OiBlX2F1eCBzdWIgZSlcbiAgICAgICAgICAgfD4gTGlzdC5jb25jYXRcblxuICAgIGluIGZfYXV4IFtdIGZcblxuICBcbiAgKCoqIFRoZSB0eXBlIG9mIGh5cGVybGluayBwcmVkaWNhdGVzIFtobHByZWRdIGNhcHR1cmVzIGZ1bmN0aW9ucyB3aGljaFxuICAgICAgbWFwIGEgaHlwZXJsaW5rIGluIGEgcHJvb2YgdG8gYSBsaXN0IG9mIHBvc3NpYmxlIGxpbmsgYWN0aW9ucy5cblxuICAgICAgT25lIGNhbiBlbXVsYXRlIGEgdHJhZGl0aW9uYWwgYm9vbGVhbiBwcmVkaWNhdGUgYnkgcmV0dXJuaW5nIHRoZSBzaW5nbGV0b25cbiAgICAgIFtgTm90aGluZ10gdG8gaW5kaWNhdGUgbWVtYmVyc2hpcCwgb3IgdGhlIGVtcHR5IGxpc3QgdG8gaW5kaWNhdGUgYWJzZW5jZVxuICAgICAgdGhlcmVvZi4gKilcblxuICB0eXBlIGxwcmVkID0gUHJvb2YucHJvb2YgLT4gbGluayAtPiBsaW5rYWN0aW9uIGxpc3RcbiAgdHlwZSBobHByZWQgPSBQcm9vZi5wcm9vZiAtPiBoeXBlcmxpbmsgLT4gbGlua2FjdGlvbiBsaXN0XG4gIFxuICBsZXQgaGxwcmVkX29mX2xwcmVkIDogbHByZWQgLT4gaGxwcmVkID1cbiAgICBmdW4gcCBwciAtPiBmdW5jdGlvblxuICAgICAgfCBbc3JjXSwgW2RzdF0gLT4gcCBwciAoc3JjLCBkc3QpXG4gICAgICB8IF8gLT4gW11cblxuICBcbiAgKCoqIFtobHByZWRfbXVsdCBscHNdIHJldHVybnMgYSBoeXBlcmxpbmsgcHJlZGljYXRlIHRoYXQgZGVub3RlcyB0aGUgY2FydGVzaWFuXG4gICAgICBwcm9kdWN0IG9mIHRoZSBhY3Rpb25zIGRlbm90ZWQgYnkgdGhlIGh5cGVybGluayBwcmVkaWNhdGVzIGluIFtscHNdLiAqKVxuICBsZXQgaGxwcmVkX211bHQgOiBobHByZWQgbGlzdCAtPiBobHByZWQgPVxuICAgIGxldCBtdWx0IDogaGxwcmVkIC0+IGhscHJlZCAtPiBobHByZWQgPVxuICAgICAgZnVuIHAxIHAyIC0+IGZ1biBwciBsbmsgLT5cbiAgICAgICAgTGlzdC5jYXJ0ZXNpYW5fcHJvZHVjdCAocDEgcHIgbG5rKSAocDIgcHIgbG5rKSB8PlxuICAgICAgICBMaXN0Lm1hcCAoZnVuIChhMSwgYTIpIC0+IGBCb3RoIChhMSwgYTIpKVxuICAgIGluXG4gICAgTGlzdC5mb2xkX2xlZnQgbXVsdCAoZnVuIF8gXyAtPiBbYE5vdGhpbmddKVxuXG5cbiAgKCoqIFtobHByZWRfYWRkIGxwc10gcmV0dXJucyBhIGh5cGVybGluayBwcmVkaWNhdGUgdGhhdCBkZW5vdGVzIHRoZSBkaXNqb2ludFxuICAgICAgdW5pb24gb2YgdGhlIGFjdGlvbnMgZGVub3RlZCBieSB0aGUgaHlwZXJsaW5rIHByZWRpY2F0ZXMgaW4gW2xwc10uICopXG4gIGxldCBobHByZWRfYWRkIDogaGxwcmVkIGxpc3QgLT4gaGxwcmVkID1cbiAgICBmdW4gcHMgLT4gZnVuIHByIGxuayAtPlxuICAgICAgTGlzdC5tYXAgKGZ1biBwIC0+IHAgcHIgbG5rKSBwcyB8PiBcbiAgICAgIExpc3QuY29uY2F0XG5cblxuICAoKiogW2hscHJlZF9pZl9lbXB0eSBwMSBwMl0gaXMgZXF1aXZhbGVudCB0byBbcDFdIGF0IGxpbmtzIHdoZXJlIHRoZVxuICAgICAgbGF0dGVyIGlzIG5vbi1lbXB0eSwgYW5kIFtwMl0gZWxzZXdoZXJlLiAqKVxuICBsZXQgaGxwcmVkX2lmX2VtcHR5IDogaGxwcmVkIC0+IGhscHJlZCAtPiBobHByZWQgPVxuICAgIGZ1biBwMSBwMiAtPiBmdW4gcHIgbG5rIC0+XG4gICAgICBsZXQgYWN0aW9ucyA9IHAxIHByIGxuayBpblxuICAgICAgaWYgbm90IChMaXN0LmlzX2VtcHR5IGFjdGlvbnMpIHRoZW4gYWN0aW9uc1xuICAgICAgZWxzZSBwMiBwciBsbmtcbiAgXG5cbiAgKCoqIFtzZWFyY2hfbGlua2FjdGlvbnMgaGxwIHByb29mIChzcmMsIGRzdCldIHJldHVybnMgYWxsIGxpbmtzIGJldHdlZW5cbiAgICAgIHN1YnRlcm1zIG9mIFtzcmNdIGFuZCBbZHN0XSBpbiBbcHJvb2ZdIHRoYXQgY2FuIGludGVyYWN0IGFjY29yZGluZyB0b1xuICAgICAgdGhlIGh5cGVybGluayBwcmVkaWNhdGUgW2hscF0sIHRvZ2V0aGVyIHdpdGggdGhlIGxpc3RzIG9mIHBvc3NpYmxlIGxpbmtcbiAgICAgIGFjdGlvbnMgZGV0ZXJtaW5lZCBieSB0aGUgcHJlZGljYXRlLlxuXG4gICAgICBJZiBbZml4ZWRfc3Jjc10gKHJlc3AuIFtmaXhlZF9kc3RzXSkgaXMgc2V0LCB0aGUgZnVuY3Rpb24gcmV0dXJucyBvbmx5XG4gICAgICBoeXBlcmxpbmtzIHdpdGggc291cmNlcyBbZml4ZWRfc3Jjc10gKHJlc3AuIGRlc3RpbmF0aW9ucyBbZml4ZWRfZHN0c10pLFxuICAgICAgYW5kIHdob3NlIGRlc3RpbmF0aW9ucyAocmVzcC4gc291cmNlcykgYXJlIHN1YnRlcm1zIG9mIFtkc3RdIChyZXNwLlxuICAgICAgW3NyY10pLiAqKVxuICBsZXQgc2VhcmNoX2xpbmthY3Rpb25zXG4gICAgPyhmaXhlZF9zcmNzIDogaXBhdGggbGlzdCBvcHRpb24pID8oZml4ZWRfZHN0cyA6IGlwYXRoIGxpc3Qgb3B0aW9uKVxuICAgIChobHAgOiBobHByZWQpIHByb29mIChzcmMsIGRzdCA6IGxpbmspIDpcbiAgICAoaHlwZXJsaW5rICogbGlua2FjdGlvbiBsaXN0KSBsaXN0XG4gID1cbiAgICBsZXQgc3VicGF0aCBwIHN1YiA9IHsgcm9vdCA9IHAucm9vdDsgY3R4dCA9IHAuY3R4dDsgc3ViID0gcC5zdWIgQCBzdWIgfSBpblxuICAgIFxuICAgIGxldCBxdWVyeV9hY3Rpb25zIGxuayA9XG4gICAgICBtYXRjaCBobHAgcHJvb2YgbG5rIHdpdGhcbiAgICAgIHwgXyA6OiBfIGFzIGFjdGlvbnMgLT4gW2xuaywgYWN0aW9uc11cbiAgICAgIHwgW10gLT4gW11cbiAgICBpblxuXG4gICAgbGV0IG9wZW4gTW9uYWQuTGlzdCBpblxuXG4gICAgbWF0Y2ggZml4ZWRfc3JjcywgZml4ZWRfZHN0cyB3aXRoXG4gICAgfCBTb21lIHNyY3MsIFNvbWUgZHN0cyAtPlxuICAgICAgICBxdWVyeV9hY3Rpb25zIChzcmNzLCBkc3RzKVxuICAgIFxuICAgIHwgU29tZSBzcmNzLCBOb25lIC0+XG4gICAgICAgIGxldCBfLCBfLCAoXywgdF9kc3QpID0gb2ZfaXBhdGggcHJvb2YgZHN0IGluXG4gICAgICAgIHRfc3VicyB0X2RzdCA+Pj0gZnVuIHN1Yl9kc3QgLT5cbiAgICAgICAgcXVlcnlfYWN0aW9ucyAoc3JjcywgW3N1YnBhdGggZHN0IHN1Yl9kc3RdKVxuXG4gICAgfCBOb25lLCBTb21lIGRzdHMgLT5cbiAgICAgICAgbGV0IF8sIF8sIChfLCB0X3NyYykgPSBvZl9pcGF0aCBwcm9vZiBzcmMgaW5cbiAgICAgICAgdF9zdWJzIHRfc3JjID4+PSBmdW4gc3ViX3NyYyAtPlxuICAgICAgICBxdWVyeV9hY3Rpb25zIChbc3VicGF0aCBzcmMgc3ViX3NyY10sIGRzdHMpXG5cbiAgICB8IE5vbmUsIE5vbmUgLT5cbiAgICAgICAgbGV0IF8sIF8sIChfLCB0X3NyYykgPSBvZl9pcGF0aCBwcm9vZiBzcmMgaW5cbiAgICAgICAgbGV0IF8sIF8sIChfLCB0X2RzdCkgPSBvZl9pcGF0aCBwcm9vZiBkc3QgaW5cbiAgICAgICAgdF9zdWJzIHRfc3JjID4+PSBmdW4gc3ViX3NyYyAtPlxuICAgICAgICB0X3N1YnMgdF9kc3QgPj49IGZ1biBzdWJfZHN0IC0+XG4gICAgICAgIHF1ZXJ5X2FjdGlvbnMgKFtzdWJwYXRoIHNyYyBzdWJfc3JjXSwgW3N1YnBhdGggZHN0IHN1Yl9kc3RdKVxuICBcblxuICBtb2R1bGUgUHJlVW5pZiA9IHN0cnVjdFxuICAgIG9wZW4gRm9ybVxuXG4gICAgbW9kdWxlIERlcHMgPSBzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgR3JhcGguUGVyc2lzdGVudC5EaWdyYXBoLkNvbmNyZXRlKE5hbWUpXG5cbiAgICAgIGxldCBzdWJzdCAoZGVwcyA6IHQpIChzIDogU3Vic3Quc3Vic3QpIDogdCA9XG4gICAgICAgICgqIEZvciBlYWNoIGl0ZW0gW3ggOj0gZV0gaW4gdGhlIHN1YnN0aXR1dGlvbiAqKVxuICAgICAgICBTdWJzdC5mb2xkIGJlZ2luIGZ1biBkZXBzICh4LCB0YWcpIC0+XG4gICAgICAgICAgbGV0IGZ2cyA9IG1hdGNoIHRhZyB3aXRoXG4gICAgICAgICAgICB8IFNib3VuZCBlIC0+IGVfdmFycyBlXG4gICAgICAgICAgICB8IFNmbGV4IC0+IFtdXG4gICAgICAgICAgaW5cbiAgICAgICAgICAoKiBGb3IgZWFjaCB2YXJpYWJsZSBbeV0gZGVwZW5kaW5nIG9uIFt4XSAqKVxuICAgICAgICAgIHRyeSBmb2xkX3N1Y2MgYmVnaW4gZnVuIHkgZGVwcyAtPlxuICAgICAgICAgICAgKCogRm9yIGVhY2ggdmFyaWFibGUgW3pdIG9jY3VycmluZyBpbiBbZV0gKilcbiAgICAgICAgICAgIExpc3QuZm9sZF9sZWZ0IGJlZ2luIGZ1biBkZXBzICh6LCBfKSAtPlxuICAgICAgICAgICAgICAgICgqIEFkZCBhbiBlZGdlIHN0YXRpbmcgdGhhdCBbeV0gZGVwZW5kcyBvbiBbel0gKilcbiAgICAgICAgICAgICAgICBhZGRfZWRnZSBkZXBzIHogeVxuICAgICAgICAgICAgICBlbmQgZGVwcyBmdnNcbiAgICAgICAgICAgIGVuZCBkZXBzIHggZGVwc1xuICAgICAgICAgIHdpdGggSW52YWxpZF9hcmd1bWVudCBfIC0+IGRlcHNcbiAgICAgICAgZW5kIGRlcHMgc1xuICAgIGVuZFxuXG4gICAgbW9kdWxlIFRyYXZlcnNlRGVwcyA9IEdyYXBoLlRyYXZlcnNlLkRmcyhEZXBzKVxuXG4gICAgbGV0IGFjeWNsaWMgPSBub3QgPDx8IFRyYXZlcnNlRGVwcy5oYXNfY3ljbGVcblxuICAgIG1vZHVsZSBFbnYgPSBzdHJ1Y3RcbiAgICAgICgqKiBXaGlsZSB0cmF2ZXJzaW5nIGZvcm11bGFzIGluIHNlYXJjaCBmb3IgdGFyZ2V0cyB0byB1bmlmeSwgd2UgbmVlZCB0b1xuICAgICAgICAgIHJlY29yZCBhbmQgdXBkYXRlIG11bHRpcGxlIGluZm9ybWF0aW9ucyBoYW5kbGluZyB0aGUgZmlyc3Qtb3JkZXIgY29udGVudFxuICAgICAgICAgIG9mIHRoZSBwcm9vZi4gV2UgZG8gc28gd2l0aCBhIHJlY29yZCBvZiB0aGUgZm9ybVxuICAgICAgICAgICBcbiAgICAgICAgICAgIFt7ZGVwczsgcm5tOyBzdWJzdH1dXG4gICAgICAgICAgIFxuICAgICAgICAgIHdoZXJlOlxuXG4gICAgICAgICAgLSBbZGVwc10gaXMgYSBkaXJlY3RlZCBncmFwaCByZWNvcmRpbmcgdGhlIGRlcGVuZGVuY3kgcmVsYXRpb24gYmV0d2VlblxuICAgICAgICAgICAgZXhpc3RlbnRpYWwgYW5kIGVpZ2VudmFyaWFibGVzLCBpbiB0aGUgc2FtZSBzcGlyaXQgb2YgdGhlIGRlcGVuZGVuY3lcbiAgICAgICAgICAgIHJlbGF0aW9uIG9mIGV4cGFuc2lvbiB0cmVlcy5cbiBcbiAgICAgICAgICAtIFtybm1dIGlzIGFuIGFzc29jaWF0aW9uIGxpc3QsIHdoZXJlIGVhY2ggaXRlbSBbKHosIHgpXSBtYXBzIGEgZnJlc2ggbmFtZVxuICAgICAgICAgICAgW3pdIHRvIHRoZSB2YXJpYWJsZSBbeF0gaXQgcmVuYW1lcy4gSW5kZWVkLCB0byBhdm9pZCBuYW1lIGNsYXNoZXMgYmV0d2VlblxuICAgICAgICAgICAgYm91bmQgdmFyaWFibGVzIG9mIFtmMV0gYW5kIFtmMl0gZHVyaW5nIHVuaWZpY2F0aW9uLCB3ZSBnaXZlIHRoZW0gdGVtcG9yYXJ5XG4gICAgICAgICAgICBmcmVzaCBuYW1lcywgd2hpY2ggYXJlIHJldmVydGVkIHRvIHRoZSBvcmlnaW5hbCBuYW1lcyB3aXRoIFtybm1dIHdoZW5cbiAgICAgICAgICAgIHByb2R1Y2luZyB0aGUgZmluYWwgc3Vic3RpdHV0aW9uIGZvciBlYWNoIGZvcm11bGEuXG4gICAgICAgICAgIFxuICAgICAgICAgIC0gW3N1YnN0XSBpcyB0aGUgc3Vic3RpdHV0aW9uIHRoYXQgd2lsbCBiZSBmZWQgdG8gdW5pZmljYXRpb24sIGluIHdoaWNoIHdlXG4gICAgICAgICAgICByZWNvcmQgZXhpc3RlbnRpYWwgdmFyaWFibGVzIGluIFtTZmxleF0gZW50cmllcy5cbiAgICAgICopXG4gICAgICB0eXBlIHQgPVxuICAgICAgICB7IGRlcHMgOiBEZXBzLnQ7XG4gICAgICAgICAgcm5tIDogKG5hbWUgKiBuYW1lKSBsaXN0O1xuICAgICAgICAgIHN1YnN0IDogU3Vic3Quc3Vic3QgfVxuICAgIGVuZFxuXG4gICAgbW9kdWxlIFN0YXRlID0gTW9uYWQuU3RhdGUoRW52KVxuXG4gICAgbGV0IHRyYXZlcnNlIChwLCB0KSBpIDogKHBvbCAqIHRlcm0pIFN0YXRlLnQgPVxuICAgICAgbGV0IG9wZW4gU3RhdGUgaW5cbiAgICAgIG1hdGNoIHAsIHQgd2l0aFxuXG4gICAgICB8IFBvcywgYEYgRkJpbmQgKGBGb3JhbGwsIHgsIF8sIGYpXG4gICAgICB8IE5lZywgYEYgRkJpbmQgKGBFeGlzdCwgeCwgXywgZikgLT5cbiAgICAgICAgICBnZXQgPj49IGZ1biB7IGRlcHM7IHJubTsgc3Vic3QgfSAtPlxuICAgICAgICAgIGxldCB6ID0gRVZhcnMuZnJlc2ggKCkgaW5cbiAgICAgICAgICBsZXQgZXhzID0gU3Vic3QuZm9sZFxuICAgICAgICAgICAgKGZ1biBhY2MgKHgsIHQpIC0+IGlmIHQgPSBTZmxleCB0aGVuIHggOjogYWNjIGVsc2UgYWNjKVxuICAgICAgICAgICAgW10gc3Vic3RcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBkZXBzID0gTGlzdC5mb2xkX2xlZnRcbiAgICAgICAgICAgIChmdW4gZGVwcyB5IC0+IERlcHMuYWRkX2VkZ2UgZGVwcyB5IHopXG4gICAgICAgICAgICBkZXBzIGV4c1xuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IHJubSA9ICh6LCB4KSA6OiBybm0gaW5cbiAgICAgICAgICBwdXQgeyBkZXBzOyBybm07IHN1YnN0IH0gPj49IGZ1biBfIC0+XG4gICAgICAgICAgbGV0IGYgPSBGb3JtLlN1YnN0LmZfYXBwbHkxICh4LCAwKSAoRVZhciAoeiwgMCkpIGYgaW5cbiAgICAgICAgICByZXR1cm4gKHAsIGBGIGYpXG5cbiAgICAgIHwgTmVnLCBgRiBGQmluZCAoYEZvcmFsbCwgeCwgXywgZilcbiAgICAgIHwgUG9zLCBgRiBGQmluZCAoYEV4aXN0LCB4LCBfLCBmKSAtPlxuICAgICAgICAgIGdldCA+Pj0gZnVuICh7IHJubTsgc3Vic3Q7IF8gfSBhcyBzdCkgLT5cbiAgICAgICAgICBsZXQgeiA9IEVWYXJzLmZyZXNoICgpIGluXG4gICAgICAgICAgbGV0IHJubSA9ICh6LCB4KSA6OiBybm0gaW5cbiAgICAgICAgICBsZXQgc3Vic3QgPSBTdWJzdC5wdXNoIHogU2ZsZXggc3Vic3QgaW5cbiAgICAgICAgICBwdXQgeyBzdCB3aXRoIHJubTsgc3Vic3QgfSA+Pj0gZnVuIF8gLT5cbiAgICAgICAgICBsZXQgZiA9IEZvcm0uU3Vic3QuZl9hcHBseTEgKHgsIDApIChFVmFyICh6LCAwKSkgZiBpblxuICAgICAgICAgIHJldHVybiAocCwgYEYgZilcblxuICAgICAgfCBfIC0+XG4gICAgICAgICAgcmV0dXJuIChkaXJlY3Rfc3VidGVybV9wb2wgKHAsIHQpIGkpXG5cbiAgICBsZXQgdHJhdmVyc2UgPSBTdGF0ZS5mb2xkIHRyYXZlcnNlXG4gIGVuZFxuXG5cbiAgKCoqIFt3Zl9zdWJmb3JtX2xpbmsgcHJvb2YgKHNyYywgZHN0KV0gY2hlY2tzIGlmIFtzcmNdIGFuZCBbZHN0XSBsZWFkIHRvXG4gICAgICB1bmlmaWFibGUgc3ViZm9ybXVsYXMgb2Ygb3Bwb3NpdGUgcG9sYXJpdGllcyBpbiB0aGUgZm9jdXNlZCBnb2FsIG9mXG4gICAgICBbcHJvb2ZdLCBhbmQgcmV0dXJucyB0aGUgYXNzb2NpYXRlZCBzdWJzdGl0dXRpb25zIGlmIHRoZXkgZG8gaW5zaWRlIGFcbiAgICAgIFtgU3ViZm9ybV0gbGluayBhY3Rpb24uXG4gICAgICBcbiAgICAgIElmIFtkcmV3cml0ZV0gaXMgc2V0IHRvIFt0cnVlXSwgaXQgb25seSBjaGVja3MgZm9yIGRlZXAgcmV3cml0ZSBsaW5rcyxcbiAgICAgIHRoYXQgaXMgbGlua3Mgd2hlcmUgb25lIHNpZGUgaXMgYSBuZWdhdGl2ZSBlcXVhbGl0eSBvcGVyYW5kLCBhbmQgdGhlIG90aGVyXG4gICAgICBzaWRlIGFuIGFyYml0cmFyeSB1bmlmaWFibGUgc3ViZXhwcmVzc2lvbiBvZiB0aGUgc2FtZSB0eXBlLiAqKVxuICBsZXQgd2Zfc3ViZm9ybV9saW5rID8oZHJld3JpdGUgPSBmYWxzZSkgOiBscHJlZCA9XG4gICAgbGV0IG9wZW4gRm9ybSBpblxuICAgIGxldCBvcGVuIFByZVVuaWYgaW5cblxuICAgIGxldCBpc19lcV9vcGVyYW5kIHByb29mIChwIDogaXBhdGgpID1cbiAgICAgIHRyeVxuICAgICAgICBsZXQgZXFfc3ViID0gTGlzdC4ocmVtb3ZlX2F0IChsZW5ndGggcC5zdWIgLSAxKSBwLnN1YikgaW5cbiAgICAgICAgbGV0IGVxX3BhdGggPSB7IHAgd2l0aCBzdWIgPSBlcV9zdWIgfSBpblxuICAgICAgICBsZXQgXywgXywgKF8sIHQpID0gb2ZfaXBhdGggcHJvb2YgZXFfcGF0aCBpblxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBgRiBGUHJlZCAoXCJfRVFcIiwgXykgLT4gdHJ1ZVxuICAgICAgICB8IF8gLT4gZmFsc2VcbiAgICAgIHdpdGggSW52YWxpZF9hcmd1bWVudCBfIC0+IGZhbHNlXG4gICAgaW5cblxuICAgIGZ1biBwcm9vZiAoc3JjLCBkc3QpIC0+XG5cbiAgICBsZXQgZ29hbCwgaXRlbV9zcmMsIChzdWJfc3JjLCB0X3NyYykgPSBvZl9pcGF0aCBwcm9vZiBzcmMgaW5cbiAgICBsZXQgXywgaXRlbV9kc3QsIChzdWJfZHN0LCB0X2RzdCkgPSBvZl9pcGF0aCBwcm9vZiBkc3QgaW5cblxuICAgIHRyeVxuICAgICAgbGV0IGYxLCBmMiA9IHBhaXJfbWFwIGZvcm1fb2ZfaXRlbSAoaXRlbV9zcmMsIGl0ZW1fZHN0KSBpblxuXG4gICAgICBsZXQgcDEgPSBwb2xfb2ZfaXRlbSBpdGVtX3NyYyBpblxuICAgICAgbGV0IHAyID0gcG9sX29mX2l0ZW0gaXRlbV9kc3QgaW5cblxuICAgICAgbGV0IHN1YjEgPSBzdWJfc3JjIGluXG4gICAgICBsZXQgc3ViMiA9IHN1Yl9kc3QgaW5cblxuICAgICAgbGV0IGRlcHMsIHNwMSwgc3QxLCBybm0xLCBzMSwgc3AyLCBzdDIsIHJubTIsIHMyID1cbiAgICAgICAgbGV0IG9wZW4gU3RhdGUgaW5cbiAgICAgICAgcnVuIGJlZ2luXG4gICAgICAgICAgdHJhdmVyc2UgKHAxLCBgRiBmMSkgc3ViMSA+Pj0gZnVuIChzcDEsIHNmMSkgLT5cbiAgICAgICAgICBnZXQgPj49IGZ1biBzdDEgLT5cbiAgICAgICAgICBwdXQgeyBzdDEgd2l0aCBybm0gPSBbXTsgc3Vic3QgPSBTdWJzdC5lbXB0eSB9ID4+PSBmdW4gXyAtPlxuXG4gICAgICAgICAgdHJhdmVyc2UgKHAyLCBgRiBmMikgc3ViMiA+Pj0gZnVuIChzcDIsIHNmMikgLT5cbiAgICAgICAgICBnZXQgPj49IGZ1biBzdDIgLT5cblxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBzdDIuZGVwcyxcbiAgICAgICAgICAgIHNwMSwgc2YxLCBzdDEucm5tLCBzdDEuc3Vic3QsXG4gICAgICAgICAgICBzcDIsIHNmMiwgc3QyLnJubSwgc3QyLnN1YnN0KVxuICAgICAgICBlbmRcbiAgICAgICAgeyBkZXBzID0gRGVwcy5lbXB0eTtcbiAgICAgICAgICBybm0gPSBbXTtcbiAgICAgICAgICBzdWJzdCA9IFN1YnN0LmVtcHR5IH1cbiAgICAgIGluXG5cbiAgICAgIGxldCBzMSA9IFN1YnN0LmFzbGlzdCBzMSBpblxuICAgICAgbGV0IHMyID0gU3Vic3QuYXNsaXN0IHMyIGluXG4gICAgICBsZXQgcyA9IFN1YnN0Lm9mbGlzdCAoczEgQCBzMikgaW5cbiAgICAgIFxuICAgICAgbGV0IHMgPSBiZWdpbiBtYXRjaCBzdDEsIHN0MiB3aXRoXG4gICAgICAgICgqIFN1YmZvcm11bGEgbGlua2luZyAqKVxuICAgICAgICB8IGBGIGYxLCBgRiBmMiB3aGVuIG5vdCBkcmV3cml0ZSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggc3AxLCBzcDIgd2l0aFxuICAgICAgICAgICAgfCBQb3MsIE5lZyB8IE5lZywgUG9zIHwgU3VwLCBfIHwgXywgU3VwIC0+XG4gICAgICAgICAgICAgICAgZl91bmlmeSAgZ29hbC5nX3ByZWdvYWwuZ19lbnYgTEVudi5lbXB0eSBzIFtmMSwgZjJdXG4gICAgICAgICAgICB8IF8gLT4gTm9uZVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICgqIERlZXAgcmV3cml0ZSAqKVxuICAgICAgICB8IGBFIGUxLCBgRSBlMiB3aGVuIGRyZXdyaXRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVudiA9IGdvYWwuZ19wcmVnb2FsLmdfZW52IGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHR5MSA9IGVpbmZlciAoZW52X29mX2lwYXRoIHByb29mIHNyYykgKGV4cHJfb2ZfdGVybSB0X3NyYykgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHkyID0gZWluZmVyIChlbnZfb2ZfaXBhdGggcHJvb2YgZHN0KSAoZXhwcl9vZl90ZXJtIHRfZHN0KSBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZvcm0uKHRfZXF1YWwgZW52IHR5MSB0eTIpIC0+XG4gICAgICAgICAgICBsZXQgZXExLCBlcTIgPSBwYWlyX21hcCAoaXNfZXFfb3BlcmFuZCBwcm9vZikgKHNyYywgZHN0KSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggKHNwMSwgZXExKSwgKHNwMiwgZXEyKSB3aXRoXG4gICAgICAgICAgICB8IChOZWcsIHRydWUpLCBfIHwgXywgKE5lZywgdHJ1ZSkgLT5cbiAgICAgICAgICAgICAgICBlX3VuaWZ5IGdvYWwuZ19wcmVnb2FsLmdfZW52IExFbnYuZW1wdHkgcyBbZTEsIGUyXVxuICAgICAgICAgICAgfCBfIC0+IE5vbmVcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gTm9uZVxuICAgICAgICBlbmQgaW5cblxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICB8IFNvbWUgcyB3aGVuIGFjeWNsaWMgKERlcHMuc3Vic3QgZGVwcyBzKSAtPlxuXG4gICAgICAgIGxldCBzMSwgczIgPSBMaXN0LnNwbGl0X2F0IChMaXN0Lmxlbmd0aCBzMSkgKFN1YnN0LmFzbGlzdCBzKSBpblxuXG4gICAgICAgIGxldCByZW5hbWUgcm5tMSBybm0yID1cbiAgICAgICAgICBMaXN0Lm1hcCBiZWdpbiBmdW4gKHgsIHRhZykgLT5cbiAgICAgICAgICAgIGxldCBnZXRfbmFtZSB4IHJubSA9IE9wdGlvbi5kZWZhdWx0IHggKExpc3QuYXNzb2Nfb3B0IHggcm5tKSBpblxuICAgICAgICAgICAgbGV0IHggPSBnZXRfbmFtZSB4IHJubTEgaW5cbiAgICAgICAgICAgIGxldCB0YWcgPVxuICAgICAgICAgICAgICBsZXQgcmVjIHJlbmFtZSA9IGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgfCBFVmFyICh4LCBpKSAtPiBFVmFyIChnZXRfbmFtZSB4IHJubTIsIGkpXG4gICAgICAgICAgICAgICAgfCBFRnVuIChmLCBlcykgLT4gRUZ1biAoZiwgTGlzdC5tYXAgcmVuYW1lIGVzKVxuICAgICAgICAgICAgICBpbiBtYXRjaCB0YWcgd2l0aFxuICAgICAgICAgICAgICB8IFNib3VuZCBlIC0+IFNib3VuZCAocmVuYW1lIGUpXG4gICAgICAgICAgICAgIHwgXyAtPiB0YWdcbiAgICAgICAgICAgIGluIHgsIHRhZ1xuICAgICAgICAgIGVuZFxuICAgICAgICBpblxuXG4gICAgICAgIGxldCBzMSA9IHMxIHw+IHJlbmFtZSBybm0xIHJubTIgfD4gTGlzdC5yZXYgfD4gU3Vic3Qub2ZsaXN0IGluXG4gICAgICAgIGxldCBzMiA9IHMyIHw+IHJlbmFtZSBybm0yIHJubTEgfD4gTGlzdC5yZXYgfD4gU3Vic3Qub2ZsaXN0IGluXG5cbiAgICAgICAgW2BTdWJmb3JtIChzMSwgczIpXVxuXG4gICAgICB8IF8gLT4gW11cbiAgICB3aXRoIEludmFsaWRfYXJndW1lbnQgXyAtPiBbXVxuICBcbiAgXG4gICgqKiBbaW50dWl0aW9uaXN0aWNfbGluayBsbmtdIGNoZWNrcyBpZiBbbG5rXSBpcyBhbiBpbnR1aXRpb25pc3RpYyBsaW5rLFxuICAgICAgYW5kIHJldHVybnMgYSBbYE5vdGhpbmddIGxpbmsgYWN0aW9uIGlmIHNvLiAqKVxuICBsZXQgaW50dWl0aW9uaXN0aWNfbGluayA6IGxwcmVkID1cbiAgICBmdW4gcHJvb2YgKHNyYywgZHN0KSAtPlxuXG4gICAgbGV0IG5lZ19jb3VudCAocCA6IGlwYXRoKSA9XG4gICAgICBsZXQgXywgaXQsIChzdWIsIF8pID0gb2ZfaXBhdGggcHJvb2YgcCBpblxuICAgICAgbGV0IGYgPSBmb3JtX29mX2l0ZW0gaXQgaW5cbiAgICAgIGxldCBuID0gbmVnX2NvdW50IGYgc3ViIGluXG4gICAgICBtYXRjaCBpdCB3aXRoXG4gICAgICB8IGBDIF8gLT4gblxuICAgICAgfCBgSCBfIC0+IG4rMVxuICAgICAgfCBgViBfIC0+IHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiRXhwZWN0ZWQgYSBmb3JtdWxhIGl0ZW1cIilcbiAgICBpblxuICAgIFxuICAgIHRyeVxuICAgICAgbWF0Y2ggbmVnX2NvdW50IHNyYywgbmVnX2NvdW50IGRzdCB3aXRoXG4gICAgICB8IG0sIG4gd2hlbiBtID4gMCAmJiBuID4gMFxuICAgICAgICAgICAgICAgfHwgbSA9IDAgJiYgbiA8PSAxXG4gICAgICAgICAgICAgICB8fCBtIDw9IDEgJiYgbiA9IDAgLT4gW2BOb3RoaW5nXVxuICAgICAgfCBfIC0+IFtdXG4gICAgd2l0aCBJbnZhbGlkU3ViRm9ybVBhdGggXyB8IEludmFsaWRfYXJndW1lbnQgXyAtPiBbXVxuICBcbiAgXG4gICgqKiBbaW5zdGFudGlhdGVfbGluayBwcm9vZiAoc3JjcywgZHN0cyldIGNoZWNrcyBpZiBbc3Jjc10gKHJlc3AuXG4gICAgICBbZHN0c10pIGxlYWRzIHRvIGFuIGV4cHJlc3Npb24sIGFuZCBbZHN0c10gKHJlc3AuIFtzcmNzXSkgbGVhZHMgZWl0aGVyIHRvXG4gICAgICBhbiBpbnN0YW50aWFibGUgcXVhbnRpZmllZCBzdWJmb3JtdWxhLCBvciB0aGUgc2V0IG9mIG9jY3VycmVuY2VzIG9mIGFuXG4gICAgICBpbnN0YW50aWFibGUgcXVhbnRpZmllZCB2YXJpYWJsZS4gSXQgaXQgc3VjY2VlZHMsIGl0IHJldHVybnMgdGhlXG4gICAgICBjb3JyZXNwb25kaW5nIFtgSW5zdGFudGlhdGVdIGxpbmsgYWN0aW9uLiAqKVxuICBsZXQgaW5zdGFudGlhdGVfbGluayA6IGhscHJlZCA9XG4gICAgbGV0IGlzX2ZyZWVfZXhwciAodCA6IHRlcm0pIChzdWIgOiBpbnQgbGlzdCkgOiBib29sID1cbiAgICAgIGxldCBsZW52LCBzdWJ0ID0gTGlzdC5mb2xkX2xlZnRcbiAgICAgICAgKGZ1biAobGVudiwgdCkgaSAtPlxuICAgICAgICAgIGxldCBsZW52ID0gbWF0Y2ggdCB3aXRoXG4gICAgICAgICAgICB8IGBGIEZCaW5kIChfLCB4LCBfLCBfKSAtPiBMRW52LmVudGVyIGxlbnYgeFxuICAgICAgICAgICAgfCBfIC0+IGxlbnYgaW5cbiAgICAgICAgICBsZXQgdCA9IGRpcmVjdF9zdWJ0ZXJtIHQgaSBpblxuICAgICAgICAgIGxlbnYsIHQpXG4gICAgICAgIChMRW52LmVtcHR5LCB0KSBzdWJcbiAgICAgIGluXG4gICAgICBtYXRjaCBzdWJ0IHdpdGhcbiAgICAgIHwgYEYgXyAtPiBmYWxzZVxuICAgICAgfCBgRSBlIC0+XG4gICAgICAgICAgTGlzdC5mb3JfYWxsXG4gICAgICAgICAgICAobm90IDw8fCAoTEVudi5leGlzdHMgbGVudikpXG4gICAgICAgICAgICAoZV92YXJzIGUpXG4gICAgaW5cblxuICAgIGZ1biBwcm9vZiAoc3JjcywgZHN0cykgLT5cbiAgICBcbiAgICAoKiBMaW5rIHRvIHF1YW50aWZpZWQgc3ViZm9ybXVsYSAqKVxuICAgIGxldCB0b19mb3JtIHBfd2l0IHBfZm9ybSA9XG4gICAgICBsZXQgUHJvb2YueyBnX3ByZWdvYWwgPSBnb2FsOyBfIH0sIGl0ZW1fd2l0LCAoc3ViX3dpdCwgd2l0KSA9XG4gICAgICAgIG9mX2lwYXRoIHByb29mIHBfd2l0IGluXG5cbiAgICAgIGxldCB3aGVyZSA9IG1hdGNoIHBfd2l0LmN0eHQua2luZCB3aXRoXG4gICAgICAgIHwgYFZhciB3IC0+IHdcbiAgICAgICAgfCBfIC0+IGBCb2R5IGluXG4gICAgICBsZXQgY3R4dF93aXQgPSB0ZXJtX29mX2l0ZW0gfndoZXJlIGl0ZW1fd2l0IGluXG5cbiAgICAgICgqIENoZWNrIHRoYXQgdGhlIHdpdG5lc3MgY29udGFpbnMgb25seSBmcmVlIHZhcmlhYmxlcyAqKVxuICAgICAgaWYgaXNfZnJlZV9leHByIGN0eHRfd2l0IHN1Yl93aXQgdGhlblxuICAgICAgICBcbiAgICAgICAgbGV0IHBvbCA9IHBvbF9vZl9pcGF0aCBwcm9vZiBwX2Zvcm0gaW5cbiAgICAgICAgbGV0IGYgPSB0ZXJtX29mX2lwYXRoIHByb29mIHBfZm9ybSBpblxuXG4gICAgICAgIGxldCB3aXQgPSBleHByX29mX3Rlcm0gd2l0IGluXG4gICAgICAgIGxldCB0eV93aXQgPSBGb3JtLmVpbmZlciBnb2FsLmdfZW52IHdpdCBpblxuICAgICAgICBcbiAgICAgICAgKCogQ2hlY2sgdGhhdCB0aGUgcXVhbnRpZmllciBpcyBpbnN0YW50aWFibGUsIG1lYW5pbmcgaXQgaGFzXG4gICAgICAgICAgIHRoZSByaWdodCBwb2xhcml0eSBhcyB3ZWxsIGFzIHRoZSBzYW1lIHR5cGUgYXMgdGhlIHdpdG5lc3MgKilcbiAgICAgICAgbWF0Y2ggcG9sLCBmIHdpdGhcbiAgICAgICAgfCBOZWcsIGBGIEZCaW5kIChgRm9yYWxsLCBfLCB0eSwgXylcbiAgICAgICAgfCBQb3MsIGBGIEZCaW5kIChgRXhpc3QsIF8sIHR5LCBfKSB3aGVuIEZvcm0udF9lcXVhbCBnb2FsLmdfZW52IHR5IHR5X3dpdCAtPlxuICAgICAgICAgICAgW2BJbnN0YW50aWF0ZSAod2l0LCBwX2Zvcm0pXVxuXG4gICAgICAgIHwgXyAtPiBbXVxuICAgICAgZWxzZSBbXVxuICAgIGluXG4gICAgXG4gICAgKCogTGluayB0byBxdWFudGlmaWVkIG9jY3VycmVuY2VzICopXG4gICAgKCogbGV0IHRvX29jY3MgPVxuICAgICAgW10gKCogVE9ETyAqKVxuICAgIGluICopXG5cbiAgICBtYXRjaCBzcmNzLCBkc3RzIHdpdGhcbiAgICBcbiAgICB8IFtzcmNdLCBbZHN0XSAtPlxuICAgICAgICBiZWdpbiBtYXRjaCBwYWlyX21hcCAodGVybV9vZl9pcGF0aCBwcm9vZikgKHNyYywgZHN0KSB3aXRoXG4gICAgICAgIHwgYEUgXywgYEYgXyAtPlxuICAgICAgICAgICAgdG9fZm9ybSBzcmMgZHN0XG4gICAgICAgIHwgYEYgXywgYEUgXyAtPlxuICAgICAgICAgICAgdG9fZm9ybSBkc3Qgc3JjXG4gICAgICAgIHwgYEUgXywgYEUgXyAtPlxuICAgICAgICAgICAgW10gKCogVE9ETyAqKVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIFtdXG4gICAgICAgIGVuZFxuXG4gICAgKCogfCBbd2l0XSwgKF8gOjogXyBhcyBvY2NzKVxuICAgIHwgKF8gOjogXyBhcyBvY2NzKSwgW3dpdF0gLT5cbiAgICAgICAgW10gKCogVE9ETyAqKSAqKVxuICAgIFxuICAgIHwgXyAtPiBbXVxuICBcblxuICAoKiogW3Jld3JpdGVfbGluayBsbmtdIGNoZWNrcyBpZiBbbG5rXSBpcyBhIHJld3JpdGUgaHlwZXJsaW5rLiBUaGF0IGlzLCBvbmVcbiAgICAgIGVuZCBvZiB0aGUgbGluayBpcyB0aGUgbGVmdCBvciByaWdodC1oYW5kIHNpZGUgZXhwcmVzc2lvbiBbZV0gb2YgYW5cbiAgICAgIGVxdWFsaXR5IGh5cG90aGVzaXMsIGFuZCB0aGUgb3RoZXIgZW5kIGEgbm9uLWVtcHR5IHNldCBvZiBhcmJpdHJhcnlcbiAgICAgIHN1YnRlcm1zIHdoZXJlIGFsbCBvY2N1cnJlbmNlcyBvZiBbZV0gYXJlIHRvIGJlIHJld3JpdHRlbi5cblxuICAgICAgSWYgdGhlIGNoZWNrIHN1Y2NlZWRzLCBpdCByZXR1cm5zIGEgW2BSZXdyaXRlIChyZWQsIHJlcywgdGd0cyldIGxpbmtcbiAgICAgIGFjdGlvbiwgd2hlcmUgW3JlZF0gYW5kIFtyZXNdIGFyZSByZXNwZWN0aXZlbHkgdGhlIHJlZHVjZWQgKFtlXSkgYW5kXG4gICAgICByZXNpZHVhbCBleHByZXNzaW9ucywgYW5kIFt0Z3RzXSBhcmUgdGhlIHRhcmdldGVkIHN1YnRlcm1zLiAqKVxuICBsZXQgcmV3cml0ZV9saW5rIDogaGxwcmVkID1cbiAgICBmdW4gcHJvb2YgbG5rIC0+XG4gICAgXG4gICAgbGV0IHJld3JpdGVfZGF0YSAocCA6IGlwYXRoKSA9XG4gICAgICBpZiBwLmN0eHQua2luZCA9IGBIeXAgdGhlblxuICAgICAgICBsZXQgXywgaXQsIF8gPSBvZl9pcGF0aCBwcm9vZiBwIGluXG4gICAgICAgIG1hdGNoIHAuc3ViLCBmb3JtX29mX2l0ZW0gaXQgd2l0aFxuICAgICAgICB8IFswXSwgRlByZWQgKFwiX0VRXCIsIFtyZWQ7IHJlc10pXG4gICAgICAgIHwgWzFdLCBGUHJlZCAoXCJfRVFcIiwgW3JlczsgcmVkXSkgLT4gU29tZSAocmVkLCByZXMpXG4gICAgICAgIHwgXyAtPiBOb25lXG4gICAgICBlbHNlIE5vbmVcbiAgICBpblxuICAgIFxuICAgIHRyeVxuICAgICAgbWF0Y2ggbG5rLCBwYWlyX21hcCAoTGlzdC5oZCB8Pj4gcmV3cml0ZV9kYXRhKSBsbmsgd2l0aFxuICAgICAgKCogSWYgaXQgaXMgYSBzaW1wbGUgbGluayB3aGVyZSBib3RoIGVuZHMgYXJlIHNpZGVzIG9mIGVxdWFsaXRpZXMsXG4gICAgICAgICBkaXNhbWJpZ3VhdGUgYnkgcmV3cml0aW5nIGludG8gdGhlIGRlc3RpbmF0aW9uICopXG4gICAgICB8IChbX10sIFtkc3RdKSwgKFNvbWUgKHJlZCwgcmVzKSwgU29tZSBfKSAtPlxuICAgICAgICAgIFtgUmV3cml0ZSAocmVkLCByZXMsIFtkc3RdKV1cblxuICAgICAgfCAoW19dLCB0Z3RzKSwgKFNvbWUgKHJlZCwgcmVzKSwgXylcbiAgICAgIHwgKHRndHMsIFtfXSksIChfLCBTb21lIChyZWQsIHJlcykpIC0+XG4gICAgICAgICAgaWYgTGlzdC5leGlzdHMgKGZ1biBwIC0+IHAuY3R4dC5raW5kID0gYFZhciBgSGVhZCkgdGd0c1xuICAgICAgICAgIHRoZW4gW11cbiAgICAgICAgICBlbHNlIFtgUmV3cml0ZSAocmVkLCByZXMsIHRndHMpXVxuICAgICAgICAgIFxuICAgICAgfCBfIC0+IFtdXG4gICAgKCogRW1wdHkgbGluayBlbmQgKilcbiAgICB3aXRoIEZhaWx1cmUgXyAtPiBbXVxuICBcblxuICAoKiogW2ZvbGRfbGluayBsbmtdIGNoZWNrcyBpZiBbbG5rXSBpcyBhIGZvbGQgaHlwZXJsaW5rLiBUaGF0IGlzLCBvbmVcbiAgICAgIGVuZCBvZiB0aGUgbGluayBpcyB0aGUgaGVhZCBbeF0gKHJlc3AuIGJvZHkgW2VdKSBvZiBhIGxvY2FsIHZhcmlhYmxlXG4gICAgICBkZWZpbml0aW9uLCBhbmQgdGhlIG90aGVyIGVuZCBhIG5vbi1lbXB0eSBzZXQgb2YgYXJiaXRyYXJ5IHN1YnRlcm1zIHdoZXJlXG4gICAgICBhbGwgb2NjdXJyZW5jZXMgb2YgW3hdIChyZXNwLiBbZV0pIGFyZSB0byBiZSByZXdyaXR0ZW4gaW50byBbZV0gKHJlc3AuXG4gICAgICBbeF0pLlxuXG4gICAgICBJZiB0aGUgY2hlY2sgc3VjY2VlZHMsIGl0IHJldHVybnMgZWl0aGVyIGEgW2BGb2xkXSBvciBbYFVuZm9sZF0gbGluayBhY3Rpb24uXG4gICAgICAqKVxuICBsZXQgZm9sZF9saW5rIDogaGxwcmVkID1cbiAgICBmdW4gcHJvb2YgbG5rIC0+XG4gICAgXG4gICAgbGV0IGZvbGRfZGF0YSAocCA6IGlwYXRoKSA9XG4gICAgICBsZXQgXywgaXQsIF8gPSBvZl9pcGF0aCBwcm9vZiBwIGluXG4gICAgICBtYXRjaCBpdCwgcC5jdHh0LmtpbmQsIHAuc3ViIHdpdGhcbiAgICAgIHwgYFYgKHgsIChfLCBTb21lIF8pKSwgYFZhciB3aGVyZSwgW10gLT4gU29tZSAoeCwgd2hlcmUpXG4gICAgICB8IF8gLT4gTm9uZVxuICAgIGluXG4gICAgXG4gICAgdHJ5XG4gICAgICBtYXRjaCBsbmssIHBhaXJfbWFwIChMaXN0LmhkIHw+PiBmb2xkX2RhdGEpIGxuayB3aXRoXG4gICAgICAoKiBJZiBpdCBpcyBhIHNpbXBsZSBsaW5rIHdoZXJlIGJvdGggZW5kcyBhcmUgdmFyaWFibGUgYm9kaWVzLFxuICAgICAgICAgZGlzYW1iaWd1YXRlIGJ5IGZvbGRpbmcgaW4gdGhlIGRlc3RpbmF0aW9uICopXG4gICAgICB8IChbX10sIFtkc3RdKSwgKFNvbWUgKHgsIGBCb2R5KSwgU29tZSAoXywgYEJvZHkpKSAtPlxuICAgICAgICAgIFtgRm9sZCAoeCwgW2RzdF0pXVxuXG4gICAgICB8IChbcF0sIHRndHMpLCAoU29tZSAoeCwgd2hlcmUpLCBfKVxuICAgICAgfCAodGd0cywgW3BdKSwgKF8sIFNvbWUgKHgsIHdoZXJlKSkgLT5cbiAgICAgICAgICBsZXQgaXNfaGVhZCBwID0gcC5jdHh0LmtpbmQgPSBgVmFyIGBIZWFkIGluXG4gICAgICAgICAgaWYgd2hlcmUgPSBgSGVhZCB0aGVuXG4gICAgICAgICAgICBpZiBMaXN0LmV4aXN0cyBpc19oZWFkIHRndHNcbiAgICAgICAgICAgIHRoZW4gW11cbiAgICAgICAgICAgIGVsc2UgW2BVbmZvbGQgKHgsIHRndHMpXVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIExpc3QuZmlsdGVyIGlzX2hlYWQgdGd0cyB3aXRoXG4gICAgICAgICAgICB8IFtwJ10gLT5cbiAgICAgICAgICAgICAgICBPcHRpb24ubWFwX2RlZmF1bHRcbiAgICAgICAgICAgICAgICAgIChmdW4gKHksIF8pIC0+IFtgVW5mb2xkICh5LCBwIDo6IExpc3QucmVtb3ZlIHRndHMgcCcpXSlcbiAgICAgICAgICAgICAgICAgIFtdIChmb2xkX2RhdGEgcCcpXG4gICAgICAgICAgICB8IFtdIC0+XG4gICAgICAgICAgICAgICAgW2BGb2xkICh4LCB0Z3RzKV1cbiAgICAgICAgICAgIHwgXyA6OiBfIDo6IF8gLT5cbiAgICAgICAgICAgICAgICBbXVxuICAgICAgICAgICAgZW5kXG4gICAgICB8IF8gLT4gW11cbiAgICAoKiBFbXB0eSBsaW5rIGVuZCAqKVxuICAgIHdpdGggRmFpbHVyZSBfIC0+IFtdXG4gICAgXG4gICAgICBcbiAgKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbiAgKCoqIEdyYXBoaWNhbCBhY3Rpb25zICopXG5cbiAgdHlwZSBhc291cmNlID1cbiAgICB7IGtpbmQgOiBhc291cmNlX2tpbmQ7IHNlbGVjdGlvbiA6IHNlbGVjdGlvbjsgfVxuXG4gIGFuZCBhc291cmNlX2tpbmQgPSBbXG4gICAgfCBgQ2xpY2sgb2YgaXBhdGhcbiAgICB8IGBEbkQgICBvZiBhZG5kXG4gIF1cblxuICBhbmQgYWRuZCA9IHtcbiAgICBzb3VyY2UgICAgICA6IGlwYXRoO1xuICAgIGRlc3RpbmF0aW9uIDogaXBhdGggb3B0aW9uO1xuICB9XG5cbiAgYW5kIHNlbGVjdGlvbiA9IGlwYXRoIGxpc3RcblxuICB0eXBlIG9zb3VyY2UgPSBbXG4gICAgfCBgQ2xpY2sgb2YgaXBhdGhcbiAgICB8IGBEbkQgICBvZiBsaW5rXG4gIF1cblxuICAoKiogW2xlbW1hcyA/c2VsZWN0aW9uIHByb29mXSByZXR1cm5zIGFsbCBsZW1tYXMgZm9yIHdoaWNoIHRoZXJlIGlzIGEgRG5EXG4gICAgICBhY3Rpb24gaW52b2x2aW5nIG9uZSBzdWJ0ZXJtIG9mIHRoZSBbc2VsZWN0aW9uXSBpbiBbcHJvb2ZdLiBJZiB0aGVyZVxuICAgICAgaXMgbm8gc2VsZWN0aW9uIG9yIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHksIHRoZW4gaXQgc2ltcGx5IHJldHVybnMgdGhlXG4gICAgICBlbnRpcmUgbGVtbWEgZGF0YWJhc2UuXG4gICopXG4gIGxldCBsZW1tYXMgP3NlbGVjdGlvbiAocHJvb2YgOiBQcm9vZi5wcm9vZikgOiAoc3RyaW5nICogZm9ybSkgbGlzdCA9XG4gICAgbGV0IGZpbHRlciA9XG4gICAgICBobHByZWRfYWRkIFtcbiAgICAgICAgaGxwcmVkX211bHQgKExpc3QubWFwIGhscHJlZF9vZl9scHJlZCBbd2Zfc3ViZm9ybV9saW5rOyBpbnR1aXRpb25pc3RpY19saW5rXSk7XG4gICAgICAgICh3Zl9zdWJmb3JtX2xpbmsgfmRyZXdyaXRlOnRydWUgfD4gaGxwcmVkX29mX2xwcmVkKVxuICAgICAgXSBpblxuXG4gICAgbWF0Y2ggc2VsZWN0aW9uIHdpdGhcbiAgICB8IE5vbmUgfCBTb21lIFtdIC0+IHByb29mIHw+IFByb29mLmRiIHw+IExlbW1hREIuYWxsXG4gICAgfCBTb21lICgocCA6OiBfKSBhcyBzZWwpIC0+XG4gICAgICAgIGxldCBQcm9vZi57IGdfaWQ7IGdfcHJlZ29hbCA9IHN1YiB9ID0gZ29hbF9vZl9pcGF0aCBwcm9vZiBwIGluXG5cbiAgICAgICAgcHJvb2YgfD4gUHJvb2YuZGIgfD4gTGVtbWFEQi5hbGwgfD5cbiAgICAgICAgTGlzdC5maWx0ZXIgYmVnaW4gZnVuIChfLCBzdG10KSAtPlxuICAgICAgICAgIGxldCBoZCA9IEhhbmRsZS5mcmVzaCAoKSBpblxuICAgICAgICAgIGxldCBzdWIgPVxuICAgICAgICAgICAgbGV0IGh5cCA9IFByb29mLm1rX2h5cCBzdG10IGluXG4gICAgICAgICAgICBsZXQgZ19oeXBzID0gUHJvb2YuSHlwcy5hZGQgc3ViLmdfaHlwcyBoZCBoeXAgaW5cbiAgICAgICAgICAgIFByb29mLnsgc3ViIHdpdGggZ19oeXBzIH0gaW5cblxuICAgICAgICAgIGxldCBnX2lkLCBwcm9vZiA9IFByb29mLmhwcm9ncmVzcyBwcm9vZiBnX2lkIChUQXNzdW1lIChzdG10LCBnX2lkKSkgc3ViIGluXG4gICAgICAgICAgbGV0IGxwID0gbWtfaXBhdGggfmN0eHQ6eyBraW5kID0gYEh5cDsgaGFuZGxlID0gSGFuZGxlLnRvaW50IGhkIH0gKEhhbmRsZS50b2ludCBnX2lkKSBpblxuXG4gICAgICAgICAgbGV0IGxpbmthY3Rpb25zID1cbiAgICAgICAgICAgIGxldCBvcGVuIE1vbmFkLkxpc3QgaW5cbiAgICAgICAgICAgIHNlbCA+Pj0gZnVuIHNyYyAtPlxuICAgICAgICAgICAgc2VhcmNoX2xpbmthY3Rpb25zIGZpbHRlciBwcm9vZiB+Zml4ZWRfc3Jjczpbc3JjXSAoZHVtbXlfcGF0aCwgbHApIGluXG5cbiAgICAgICAgICBub3QgKExpc3QuaXNfZW1wdHkgbGlua2FjdGlvbnMpXG4gICAgICAgIGVuZFxuXG5cbiAgKCoqIFtkbmRfYWN0aW9ucyAoZG5kLCBzZWxlY3Rpb24pXSBjb21wdXRlcyBhbGwgcG9zc2libGUgcHJvb2YgYWN0aW9uc1xuICAgICAgYXNzb2NpYXRlZCB3aXRoIHRoZSBEbkQgYWN0aW9uIFtkbmRdLCBhbmQgcGFja2FnZXMgdGhlbSBhcyBhbiBhcnJheSBvZlxuICAgICAgb3V0cHV0IGFjdGlvbnMgYXMgc3BlY2lmaWVkIGluIHRoZSBKUyBBUEkuXG5cbiAgICAgIE1vcmUgc3BlY2lmaWNhbGx5LCBpdCB3aWxsIHRyeSB0byBxdWVyeSBhY3Rpb25zIGZvciBoeXBlcmxpbmtzIHdob3NlXG4gICAgICBzb3VyY2VzIChyZXNwLiBkZXN0aW5hdGlvbnMpIGFyZSB0aG9zZSBvZiBbc2VsZWN0aW9uXSBvY2N1cmluZyBpblxuICAgICAgW2RuZC5zb3VyY2VdIChyZXNwLiBlbHNld2hlcmUpLCBhbmQgd2hpY2ggeWllbGQgYXQgbGVhc3Qgb25lIGFjdGlvbi5cblxuICAgICAgSWYgdGhlIHNvdXJjZSAocmVzcC4gZGVzdGluYXRpb24pIHNlbGVjdGlvbiBpcyBlbXB0eSwgaXQgd2lsbCBzZWFyY2ggZm9yXG4gICAgICBoeXBlcmxpbmtzIHdpdGggb25seSBvbmUgc291cmNlIChyZXNwLiBkZXN0aW5hdGlvbikgd2hpY2ggaXMgYSBzdWJ0ZXJtIG9mXG4gICAgICBbZG5kLnNvdXJjZV0gKHJlc3AuIFtkbmQuZGVzdGluYXRpb25dKS4gSWYgW2RuZC5kZXN0aW5hdGlvbl0gaXMgW05vbmVdLCBpdFxuICAgICAgd2lsbCBzZWFyY2ggZm9yIGRlc3RpbmF0aW9ucyBldmVyeXdoZXJlIGluIHRoZSBjdXJyZW50IGdvYWwuXG4gKilcbiAgbGV0IGRuZF9hY3Rpb25zICgoZG5kLCBzZWxlY3Rpb24pIDogYWRuZCAqIHNlbGVjdGlvbikgKHByb29mIDogUHJvb2YucHJvb2YpID1cbiAgICBsZXQgUHJvb2YueyBnX2lkOyBfIH0gYXMgZ29hbCA9IGdvYWxfb2ZfaXBhdGggcHJvb2YgZG5kLnNvdXJjZSBpblxuICAgIFxuICAgIGxldCBzcmNzZWwgOiBzZWxlY3Rpb24gPVxuICAgICAgTGlzdC5maWx0ZXIgKGlzX3N1Yl9wYXRoIGRuZC5zb3VyY2UpIHNlbGVjdGlvbiBpblxuICAgIFxuICAgIGxldCBkc3RzZWwgOiBzZWxlY3Rpb24gPVxuICAgICAgTGlzdC5yZW1vdmVfaWYgKGZ1biBwIC0+IHAuY3R4dC5oYW5kbGUgPSBkbmQuc291cmNlLmN0eHQuaGFuZGxlKSBzZWxlY3Rpb24gaW5cbiAgICBcbiAgICBsZXQgaGxwcmVkX29ubHlfc2VsIChwIDogaGxwcmVkKSA6IGhscHJlZCA9XG4gICAgICBmdW4gcHIgbG5rIC0+IGlmIGxuayA9IChzcmNzZWwsIGRzdHNlbCkgdGhlbiBwIHByIGxuayBlbHNlIFtdIGluXG5cbiAgICBsZXQgaGxwID0gaGxwcmVkX2FkZCBbXG4gICAgICBobHByZWRfbXVsdCAoTGlzdC5tYXAgaGxwcmVkX29mX2xwcmVkIFt3Zl9zdWJmb3JtX2xpbms7IGludHVpdGlvbmlzdGljX2xpbmtdKTtcbiAgICAgIGhscHJlZF9pZl9lbXB0eVxuICAgICAgICAod2Zfc3ViZm9ybV9saW5rIH5kcmV3cml0ZTp0cnVlIHw+IGhscHJlZF9vZl9scHJlZClcbiAgICAgICAgKHJld3JpdGVfbGluayB8PiBobHByZWRfb25seV9zZWwpO1xuICAgICAgZm9sZF9saW5rIHw+IGhscHJlZF9vbmx5X3NlbDtcbiAgICAgIGluc3RhbnRpYXRlX2xpbms7XG4gICAgXSBpblxuXG4gICAgbGV0IHNyY3MsIGZpeGVkX3NyY3MgPSBiZWdpbiBtYXRjaCBzcmNzZWwgd2l0aFxuICAgICAgfCBbXSAtPiBbZG5kLnNvdXJjZV0sIE5vbmVcbiAgICAgIHwgc3JjcyAtPiBbZHVtbXlfcGF0aF0sIFNvbWUgc3Jjc1xuICAgICAgZW5kIGluXG5cbiAgICBsZXQgZHN0cywgZml4ZWRfZHN0cyA9IGJlZ2luIG1hdGNoIGRzdHNlbCB3aXRoXG4gICAgICB8IFtdIC0+XG4gICAgICAgICAgbGV0IGRzdHMgPSBiZWdpbiBtYXRjaCBkbmQuZGVzdGluYXRpb24gd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgbGV0IHNyYyA9IGRuZC5zb3VyY2UgaW5cbiAgICAgICAgICAgICAgICBMaXN0LnJlbW92ZSAoYWxsX2l0ZW1zX2lwYXRocyBnb2FsKSBzcmNcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHwgU29tZSBkc3QgLT5cbiAgICAgICAgICAgICAgICBbZHN0XVxuICAgICAgICAgICAgZW5kIGluXG4gICAgICAgICAgZHN0cywgTm9uZVxuXG4gICAgICB8IGRzdHMgLT5cbiAgICAgICAgICBbZHVtbXlfcGF0aF0sIFNvbWUgZHN0c1xuICAgICAgZW5kIGluXG5cbiAgICBsZXQgb3BlbiBNb25hZC5MaXN0IGluXG5cbiAgICBzcmNzID4+PSBmdW4gc3JjIC0+XG4gICAgZHN0cyA+Pj0gZnVuIGRzdCAtPlxuXG4gICAgbGV0IGxpbmthY3Rpb25zID0gc2VhcmNoX2xpbmthY3Rpb25zIGhscCBwcm9vZlxuICAgICAgP2ZpeGVkX3NyY3MgP2ZpeGVkX2RzdHMgKHNyYywgZHN0KSBpblxuICAgIFxuICAgIGxpbmthY3Rpb25zID4+PSBmdW4gKChzcmNzLCBkc3RzKSBhcyBsbmssIGFjdGlvbnMpIC0+XG4gICAgbGV0IGFjdGlvbnMgPSByZW1vdmVfbm90aGluZyBhY3Rpb25zIGluXG4gICAgc3JjcyA+Pj0gZnVuIHNyYyAtPlxuICAgIGRzdHMgPj49IGZ1biBkc3QgLT5cbiAgICByZXR1cm4gKFwiSHlwZXJsaW5rXCIsIHNyY3MgQCBkc3RzLCBgRG5EIChzcmMsIGRzdCksIChnX2lkLCBgSHlwZXJsaW5rIChsbmssIGFjdGlvbnMpKSlcblxuICAgICAgXG4gIGxldCBhY3Rpb25zIChwcm9vZiA6IFByb29mLnByb29mKSAocCA6IGFzb3VyY2UpXG4gICAgICA6IChzdHJpbmcgKiBpcGF0aCBsaXN0ICogb3NvdXJjZSAqIGFjdGlvbikgbGlzdFxuICA9XG4gICAgbWF0Y2ggcC5raW5kIHdpdGhcbiAgICAgIHwgYENsaWNrIHBhdGggLT4gYmVnaW5cbiAgICAgICAgICBsZXQgUHJvb2YueyBnX2lkID0gaGQ7IGdfcHJlZ29hbCA9IGdvYWx9LCBpdGVtLCAoXywgXykgPVxuICAgICAgICAgICAgb2ZfaXBhdGggcHJvb2YgcGF0aFxuICAgICAgICAgIGluXG4gICAgICAgICAgbWF0Y2ggaXRlbSB3aXRoXG4gICAgICAgICAgfCBgQyBfIC0+IGJlZ2luXG4gICAgICAgICAgICAgIGxldCBpdiA9IGl2YXJpYW50cyAocHJvb2YsIGhkKSBpblxuICAgICAgICAgICAgICBsZXQgYnYgPSBMaXN0Lmxlbmd0aCBpdiA8PSAxIGluXG4gICAgICAgICAgICAgIExpc3QubWFwaVxuICAgICAgICAgICAgICAgIChmdW4gaSB4IC0+XG4gICAgICAgICAgICAgICAgICBsZXQgaGcgPSBta19pcGF0aCAoSGFuZGxlLnRvaW50IGhkKSBcbiAgICAgICAgICAgICAgICAgICAgfnN1YjooaWYgYnYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gW10gXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgcmVidWlsZF9wYXRoZCAoTGlzdC5sZW5ndGggaXYpIGkpXG4gICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgKHgsIFtoZ10sIGBDbGljayBoZywgKGhkLCBgSW50cm8gaSkpKVxuICAgICAgICAgICAgICAgIGl2XG4gICAgICAgICAgICBlbmQgXG5cbiAgICAgICAgICB8IGBIIChycCwgXykgLT5cbiAgICAgICAgICAgICAgbGV0IGhnID0gbWtfaXBhdGggKEhhbmRsZS50b2ludCBoZClcbiAgICAgICAgICAgICAgICB+Y3R4dDp7IGtpbmQgPSBgSHlwOyBoYW5kbGUgPSBIYW5kbGUudG9pbnQgcnAgfSBpblxuICAgICAgICAgICAgICBbXCJFbGltXCIsIFtoZ10sIGBDbGljayBoZywgKGhkLCBgRWxpbSBycCldXG5cbiAgICAgICAgICB8IGBWICh4LCAodHksIE5vbmUpKSB3aGVuIEZvcm0udF9lcXVhbCBnb2FsLmdfZW52IHR5IEVudi5uYXQgLT5cbiAgICAgICAgICAgICAgbGV0IHJwID0gVmFycy5nZXRpZCBnb2FsLmdfZW52IHggfD4gT3B0aW9uLmdldCBpblxuICAgICAgICAgICAgICBsZXQgaGcgPSBta19pcGF0aCAoSGFuZGxlLnRvaW50IGhkKVxuICAgICAgICAgICAgICAgIH5jdHh0Onsga2luZCA9IGBWYXIgYEhlYWQ7IGhhbmRsZSA9IHJwIH0gaW5cbiAgICAgICAgICAgICAgW1wiSW5kdWN0aW9uXCIsIFtoZ10sIGBDbGljayBoZywgKGhkLCBgSW5kIChIYW5kbGUub2ZpbnQgcnApKV1cbiAgICAgICAgICBcbiAgICAgICAgICB8IGBWICh4LCAoXywgU29tZSBfKSkgLT5cbiAgICAgICAgICAgICAgbGV0IHJwID0gVmFycy5nZXRpZCBnb2FsLmdfZW52IHggfD4gT3B0aW9uLmdldCBpblxuXG4gICAgICAgICAgICAgIGxldCBoZ191bmZvbGQgPSBta19pcGF0aCAoSGFuZGxlLnRvaW50IGhkKVxuICAgICAgICAgICAgICAgIH5jdHh0Onsga2luZCA9IGBWYXIgYEhlYWQ7IGhhbmRsZSA9IHJwIH0gaW5cbiAgICAgICAgICAgICAgbGV0IGhnX2ZvbGQgPSBta19pcGF0aCAoSGFuZGxlLnRvaW50IGhkKVxuICAgICAgICAgICAgICAgIH5jdHh0Onsga2luZCA9IGBWYXIgYEJvZHk7IGhhbmRsZSA9IHJwIH0gaW5cblxuICAgICAgICAgICAgICBbXCJVbmZvbGRcIiwgW2hnX3VuZm9sZF0sIGBDbGljayBoZ191bmZvbGQsIChoZCwgYFVuZm9sZCB4KTtcbiAgICAgICAgICAgICAgIFwiRm9sZFwiLCBbaGdfZm9sZF0sIGBDbGljayBoZ19mb2xkLCAoaGQsIGBGb2xkIHgpXVxuICAgICAgICAgIFxuICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICBbXVxuICAgICAgICBlbmRcblxuICAgICAgfCBgRG5EIGRuZCAtPlxuICAgICAgICBkbmRfYWN0aW9ucyAoZG5kLCBwLnNlbGVjdGlvbikgcHJvb2ZcblxuXG4gIGxldCBhcHBseSAocHJvb2YgOiBQcm9vZi5wcm9vZikgKChoZCwgYSkgOiBhY3Rpb24pID1cbiAgICBsZXQgdGFyZyA9IChwcm9vZiwgaGQpIGluXG4gICAgbWF0Y2ggYSB3aXRoXG4gICAgfCBgSW50cm8gdmFyaWFudCAtPlxuICAgICAgICBpbnRybyB+dmFyaWFudDoodmFyaWFudCwgTm9uZSkgdGFyZ1xuICAgIHwgYEVsaW0gc3ViaGQgLT5cbiAgICAgICAgbGV0IGdvYWwgPSBQcm9vZi5ieWlkIHByb29mIGhkIGluXG4gICAgICAgIGxldCBmb3JtID0gKFByb29mLkh5cHMuYnlpZCBnb2FsLmdfaHlwcyBzdWJoZCkuaF9mb3JtIGluIFxuICAgICAgICBsZXQgY2xlYXIgPVxuICAgICAgICAgIEZvcm0uZl9lcXVhbCBnb2FsLmdfZW52IGZvcm0gRlRydWUgaW5cbiAgICAgICAgZWxpbSB+Y2xlYXIgc3ViaGQgdGFyZ1xuICAgIHwgYEluZCBzdWJoZCAtPlxuICAgICAgICBpbmR1Y3Rpb24gc3ViaGQgdGFyZ1xuICAgIHwgYFVuZm9sZCB4IC0+XG4gICAgICAgIHVuZm9sZF9hbGwgeCB0YXJnXG4gICAgfCBgRm9sZCB4IC0+XG4gICAgICAgIHVuZm9sZF9hbGwgfmZvbGQ6dHJ1ZSB4IHRhcmdcbiAgICB8IGBEaXNqRHJvcCAoc3ViaGQsIGZsKSAtPlxuICAgICAgICBvcl9kcm9wIHN1YmhkIHRhcmcgKExpc3QubWFwIChmdW4geCAtPiBbU29tZSBoZCwgW11dLHgpIGZsKVxuICAgIHwgYENvbmpEcm9wIHN1YmhkIC0+XG4gICAgICAgIGFuZF9kcm9wIHN1YmhkIHRhcmdcbiAgICB8IGBGb3J3YXJkIChzcmMsIGRzdCwgcCwgcykgLT5cbiAgICAgICAgZm9yd2FyZCAoc3JjLCBkc3QsIHAsIHMpIHRhcmdcbiAgICB8IGBIeXBlcmxpbmsgKGxuaywgYWN0aW9ucykgLT5cbiAgICAgICAgbWF0Y2ggbG5rLCBhY3Rpb25zIHdpdGhcbiAgICAgICAgfCAoW3NyY10sIFtkc3RdKSwgW2BTdWJmb3JtIHN1YnN0c10gLT5cbiAgICAgICAgICAgIGRsaW5rIChzcmMsIGRzdCkgc3Vic3RzIHRhcmdcbiAgICAgICAgfCBfLCBbYEluc3RhbnRpYXRlICh3aXQsIHRndCldIC0+XG4gICAgICAgICAgICBpbnN0YW50aWF0ZSB3aXQgdGd0IHRhcmdcbiAgICAgICAgfCBfLCBbYFJld3JpdGUgKHJlZCwgcmVzLCB0Z3RzKV0gLT5cbiAgICAgICAgICAgIHJld3JpdGVfaW4gcmVkIHJlcyB0Z3RzIHRhcmdcbiAgICAgICAgfCBfLCBbYEZvbGQgKHgsIHRndHMpXSAtPlxuICAgICAgICAgICAgdW5mb2xkIH5mb2xkOnRydWUgeCB0Z3RzIHRhcmdcbiAgICAgICAgfCBfLCBbYFVuZm9sZCAoeCwgdGd0cyldIC0+XG4gICAgICAgICAgICB1bmZvbGQgeCB0Z3RzIHRhcmdcbiAgICAgICAgfCBfLCBfIDo6IF8gOjogXyAtPiBmYWlsd2l0aCBcIkNhbm5vdCBoYW5kbGUgbXVsdGlwbGUgbGluayBhY3Rpb25zIHlldFwiXG4gICAgICAgIHwgXywgXyAtPiByYWlzZSBUYWN0aWNOb3RBcHBsaWNhYmxlXG5lbmRcbiIsIigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5vcGVuIFV0aWxzXG5vcGVuIFByb29mXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG50eXBlIHNvdXJjZSA9IEhhbmRsZS50ICogW2BDIHwgYEggb2YgSGFuZGxlLnRdXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5leGNlcHRpb24gSW52YWxpZEFTb3VyY2VcbmV4Y2VwdGlvbiBJbnZhbGlkTGVtbWFEQlxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxubW9kdWxlIEV4biA6IHNpZ1xuICB2YWwgcmVnaXN0ZXIgIDogKGV4biAtPiBzdHJpbmcgb3B0aW9uKSAtPiB1bml0XG4gIHZhbCB0cmFuc2xhdGUgOiBleG4gLT4gc3RyaW5nIG9wdGlvblxuZW5kID0gc3RydWN0XG4gIHR5cGUgdHhfdCA9IGV4biAtPiBzdHJpbmcgb3B0aW9uXG5cbiAgbGV0IHRyYW5zbGF0b3JzID0gcmVmIChbXSA6IHR4X3QgbGlzdClcblxuICBsZXQgcmVnaXN0ZXIgKHR4IDogdHhfdCkgOiB1bml0ID1cbiAgICB0cmFuc2xhdG9ycyA6PSAhdHJhbnNsYXRvcnMgQCBbdHhdXG5cbiAgbGV0IHRyYW5zbGF0ZSAoZSA6IGV4bikgPVxuICAgIGxldCBtb2R1bGUgRSA9IHN0cnVjdCBleGNlcHRpb24gRm91bmQgb2Ygc3RyaW5nIGVuZCBpblxuXG4gICAgdHJ5XG4gICAgICBMaXN0Lml0ZXJcbiAgICAgICAgKGZ1biB0eCAtPiB0eCBlIHw+IE9wdGlvbi5tYXkgKGZ1biBtc2cgLT4gcmFpc2UgKEUuRm91bmQgbXNnKSkpXG4gICAgICAgICF0cmFuc2xhdG9ycztcbiAgICAgIE5vbmVcblxuICAgIHdpdGggRS5Gb3VuZCBtc2cgLT4gU29tZSBtc2dcbmVuZFxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxubW9kdWxlIEpzIDogc2lnXG4gIGluY2x1ZGUgbW9kdWxlIHR5cGUgb2YgSnNfb2Zfb2NhbWwuSnNcblxuICB2YWwgYXNfc3RyaW5nIDogZXhuIC0+ICdhIHQgLT4gc3RyaW5nXG5lbmQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBKc19vZl9vY2FtbC5Kc1xuXG4gIGxldCBhc19zdHJpbmcgZXhuICh2IDogJ2EgdCkgPVxuICAgIGxldCB2ID0gVW5zYWZlLmNvZXJjZSB2IGluIFxuICAgIG1hdGNoIHRvX3N0cmluZyAodHlwZW9mIHYpIHdpdGhcbiAgICB8IFwic3RyaW5nXCIgLT4gdG9fc3RyaW5nIHZcbiAgICB8IF8gLT4gcmFpc2UgZXhuXG5lbmRcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbmxldCAoKSA9IEV4bi5yZWdpc3RlciAoZnVuIGV4biAtPlxuICAgIG1hdGNoIGV4biB3aXRoXG4gICAgfCBTeW50YXguUGFyc2VFcnJvciBfIC0+XG4gICAgICAgIFNvbWUgXCJpbnZhbGlkIGdvYWwgKHBhcnNlIGVycm9yKVwiXG4gICAgfCBGby5EdXBsaWNhdGVkRW50cnkgKF8sIG5hbWUpIC0+XG4gICAgICAgIFNvbWUgKFwiZHVwbGljYXRlZCBlbnRyeSBcXFwiXCIgXiBuYW1lIF4gXCJcXFwiIGluIGdvYWxcIilcbiAgICB8IEZvLlR5cGluZ0Vycm9yXG4gICAgfCBGby5SZWNoZWNrRmFpbHVyZSAtPlxuICAgICAgICBTb21lIFwiaW52YWxpZCBnb2FsICh0eXBlIGVycm9yKVwiXG4gICAgfCBUYWN0aWNOb3RBcHBsaWNhYmxlIC0+XG4gICAgICAgIFNvbWUgXCJ0YWN0aWMgbm90IGFwcGxpY2FibGVcIlxuICAgIHwgTGVtbWFEQi5MZW1tYU5vdEZvdW5kIG5hbWUgLT5cbiAgICAgICAgU29tZSAoXCJsZW1tYSBcXFwiXCIgXiBuYW1lIF4gXCJcXFwiIGRvZXMgbm90IGV4aXN0XCIpXG4gICAgfCBfIC0+XG4gICAgICAgIE5vbmVcbiAgKVxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxubGV0ICghISkgZiA9IGZ1biB4IC0+XG4gIHRyeSBmIHggd2l0aCBlIC0+XG4gICAgbGV0IG1zZyA9XG4gICAgICBPcHRpb24uZGVmYXVsdF9kZWxheWVkXG4gICAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgICBGb3JtYXQuc3ByaW50ZiBcImludGVybmFsIGVycm9yOiAlc1wiIChQcmludGV4Yy50b19zdHJpbmcgZSkpXG4gICAgICAgIChFeG4udHJhbnNsYXRlIGUpXG4gICAgaW4gSnMucmFpc2VfanNfZXJyb3IgKG5ldyVqcyBKcy5lcnJvcl9jb25zdHIgKEpzLnN0cmluZyBtc2cpKVxuXG5tb2R1bGUgUGF0aCA6IHNpZ1xuICB2YWwgb2Zfb2JqIDogJ2EgSnMudCAtPiBDb3JlTG9naWMuaXBhdGhcbiAgdmFsIG9mX2FycmF5IDogJ2EgSnMudCBKcy5qc19hcnJheSBKcy50IC0+IENvcmVMb2dpYy5pcGF0aCBsaXN0XG4gIHZhbCBvZl9vcHQgOiAnYSBKcy50IEpzLm9wdCAtPiBDb3JlTG9naWMuaXBhdGggb3B0aW9uXG5lbmQgPSBzdHJ1Y3RcbiAgbGV0IG9mX29iaiBvYmogPSBvYmogfD4gSnMuYXNfc3RyaW5nIEludmFsaWRBU291cmNlIHw+IENvcmVMb2dpYy5pcGF0aF9vZl9wYXRoXG4gIGxldCBvZl9hcnJheSBvYmogPSBvYmogfD4gSnMudG9fYXJyYXkgfD4gQXJyYXkudG9fbGlzdCB8PiBMaXN0Lm1hcCBvZl9vYmpcbiAgbGV0IG9mX29wdCBvYmogPSBvYmogfD4gSnMuT3B0LnRvX29wdGlvbiB8PiBPcHRpb24ubWFwIG9mX29ialxuZW5kXG4gIFxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbmxldCByZWMganNfcHJvb2ZfZW5naW5lIChwcm9vZiA6IFByb29mLnByb29mKSA9IG9iamVjdCVqcyAoX3NlbGYpXG4gIHZhbCBwcm9vZiAgPSBwcm9vZlxuICB2YWwgaGFuZGxlID0gSGFuZGxlLmZyZXNoICgpXG5cbiAgKCogUmV0dXJuIGEgW2pzX3N1YmdvYWxdIGFycmF5IG9mIGFsbCB0aGUgb3BlbmVkIHN1YmdvYWxzICopXG4gIG1ldGhvZCBzdWJnb2FscyA9XG4gICAgbGV0IHN1YmdvYWxzID0gUHJvb2Yub3BlbmVkIHByb29mIGluXG4gICAgbGV0IHN1YmdvYWxzID0gTGlzdC5tYXAgKGpzX3N1YmdvYWwgX3NlbGYpIHN1YmdvYWxzIGluXG4gICAgSnMuYXJyYXkgKEFycmF5Lm9mX2xpc3Qgc3ViZ29hbHMpXG5cbiAgKCogUmV0dXJuIHRydWUgd2hlbiB0aGVyZSBhcmUgbm8gb3BlbmVkIHN1YmdvYWxzIGxlZnQgKilcbiAgbWV0aG9kIGNsb3NlZCA9XG4gICAgSnMuYm9vbCAoUHJvb2YuY2xvc2VkIHByb29mKVxuXG4gICgqIEdldCB0aGUgbWV0YS1kYXRhIGF0dGFjaGVkIHRvIHRoaXMgcHJvb2YgZW5naW5lICopXG4gIG1ldGhvZCBnZXRtZXRhID1cbiAgICBKcy5PcHQub3B0aW9uIChQcm9vZi5nZXRfbWV0YSBwcm9vZiBfc2VsZiMjLmhhbmRsZSlcblxuICAoKiBBdHRhY2ggbWV0YS1kYXRhIHRvIHRoZSBwcm9vZiBlbmdpbmUgKilcbiAgbWV0aG9kIHNldG1ldGEgbWV0YSA9XG4gICAgUHJvb2Yuc2V0X21ldGEgcHJvb2YgX3NlbGYjIy5oYW5kbGUgKEpzLk9wdC50b19vcHRpb24gbWV0YSlcblxuICAoKiBHZXQgYWxsIHRoZSBwcm9vZiBhY3Rpb25zIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gdGhlXG4gICAqIGdvYWwgdGFyZ2V0dGVkIGJ5IFthc291cmNlXSBhcyBhbiBhcnJheSBvZiBhY3Rpb25zLlxuICAgKlxuICAgKiBUaGUgc291cmNlIGlzIGRlc2NyaWJlZCBhcyBhIHJlY29yZCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogcHJvcGVydGllczpcbiAgICpcbiAgICogIC0ga2luZCAoc3RyaW5nKTogdGhlIHR5cGUgb2YgdGhlIHNvdXJjZS5cbiAgICogICAgQ2FuIGJlIFwiY2xpY2tcIiBvciBcImRuZFwiLlxuICAgKlxuICAgKiAgLSBwYXRoIChzdHJpbmcpIFtvbmx5IGZvciB0aGUga2luZCBcImNsaWNrXCJdXG4gICAqICAgIElEIG9mIHRoZSBcImNsaWNrZWRcIiBpdGVtXG4gICAqXG4gICAqICAtIHNvdXJjZSAoc3RyaW5nKSBbb25seSBmb3IgdGhlIGtpbmQgXCJkbmRcIl1cbiAgICogICAgSUQgb2YgdGhlIGl0ZW0gdGhhdCBpcyBiZWluZyBkcm9wcGVkXG4gICAqXG4gICAqICAtIGRlc3RpbmF0aW9uIChzdHJpbmcgb3B0aW9uKSBbb25seSBmb3IgdGhlIGtpbmQgXCJkbmRcIl1cbiAgICogICAgSUQgb2YgdGhlIHN1YnRlcm0gdGhhdCByZWNlaXZlZCB0aGUgZHJvcHBlZCBpdGVtXG4gICAqXG4gICAqICAtIHNlbGVjdGlvbiAoc3RyaW5nIGxpc3QpIFthbGwgYWN0aW9uc11cbiAgICogICAgTGlzdCBvZiBJRHMgb2Ygc2VsZWN0ZWQgc3VidGVybXNcbiAgICpcbiAgICogQW4gb3V0cHV0IGFjdGlvbiBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAtIGRlc2NyaXB0aW9uIDogdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBhY3Rpb25cbiAgICogIC0gdWkgICAgICAgICAgOiB0aGUgVUkgYWN0aW9uXG4gICAqICAtIGhpZ2hsaWdodCAgIDogYSBKUyBhcnJheSBvZiBJRHMgdG8gaGlnaGxpZ2h0XG4gICAqICAtIGFjdGlvbiAgICAgIDogdGhlIHJlbGF0ZWQgYWN0aW9uIChzZWUgW2FwcGx5XSlcbiAgICopXG4gIG1ldGhvZCBhY3Rpb25zIGFzb3VyY2UgPVxuICAgIGxldCBhY3Rpb25zID1cbiAgICAgIGxldCBraW5kcyA9XG4gICAgICAgIG1hdGNoIEpzLnRvX3N0cmluZyAoSnMudHlwZW9mIGFzb3VyY2UpIHdpdGhcbiAgICAgICAgfCBcInN0cmluZ1wiIC0+XG4gICAgICAgICAgW2BDbGljayAoUGF0aC5vZl9vYmogYXNvdXJjZSldXG4gICAgICAgIHwgXCJvYmplY3RcIiAtPiBiZWdpblxuICAgICAgICAgIGxldCBhc291cmNlID0gSnMuVW5zYWZlLmNvZXJjZSBhc291cmNlIGluXG4gICAgICAgICAgbWF0Y2ggSnMuYXNfc3RyaW5nIEludmFsaWRBU291cmNlIGFzb3VyY2UjIy5raW5kIHdpdGhcbiAgICAgICAgICAgIHwgXCJjbGlja1wiIC0+XG4gICAgICAgICAgICAgICAgbGV0IHBhdGggPSBQYXRoLm9mX29iaiBhc291cmNlIyMucGF0aCBpblxuICAgICAgICAgICAgICAgIFtgQ2xpY2sgcGF0aF1cbiAgICAgICAgICAgIHwgXCJkbmRcIiAtPlxuICAgICAgICAgICAgICAgIGxldCBzb3VyY2UgPSBQYXRoLm9mX29iaiBhc291cmNlIyMuc291cmNlIGluXG4gICAgICAgICAgICAgICAgbGV0IGRlc3RpbmF0aW9uID0gUGF0aC5vZl9vcHQgYXNvdXJjZSMjLmRlc3RpbmF0aW9uIGluXG4gICAgICAgICAgICAgICAgW2BEbkQgQ29yZUxvZ2ljLnsgc291cmNlOyBkZXN0aW5hdGlvbjsgfV1cbiAgICAgICAgICAgIHwgXCJhbnlcIiAtPlxuICAgICAgICAgICAgICAgIGxldCBwYXRoID0gUGF0aC5vZl9vYmogYXNvdXJjZSMjLnBhdGggaW5cbiAgICAgICAgICAgICAgICBbYENsaWNrIHBhdGg7IGBEbkQgQ29yZUxvZ2ljLnsgc291cmNlID0gcGF0aDsgZGVzdGluYXRpb24gPSBOb25lOyB9XVxuICAgICAgICAgICAgfCBfIC0+IHJhaXNlIEludmFsaWRBU291cmNlXG4gICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiByYWlzZSBJbnZhbGlkQVNvdXJjZVxuXG4gICAgICBhbmQgc2VsZWN0aW9uID0gUGF0aC5vZl9hcnJheSBhc291cmNlIyMuc2VsZWN0aW9uIGluXG5cbiAgICAgIGxldCBhc291cmNlID1cbiAgICAgICAgTGlzdC5tYXAgKGZ1biBraW5kIC0+IENvcmVMb2dpYy57IGtpbmQ7IHNlbGVjdGlvbjsgfSkga2luZHMgaW5cblxuICAgICAgTGlzdC5mbGF0dGVuIChMaXN0Lm1hcCAoISEoQ29yZUxvZ2ljLmFjdGlvbnMgX3NlbGYjIy5wcm9vZikpIGFzb3VyY2UpXG4gICAgaW5cblxuICAgIEpzLmFycmF5IChcbiAgICAgIEFycmF5Lm9mX2xpc3RcbiAgICAgICAgKExpc3QubWFwIChmdW4gKHAsIHBzLCBhdWksIGEpIC0+IFxuICAgICAgICAgICBsZXQgcHMgPSBMaXN0Lm1hcCBDb3JlTG9naWMucGF0aF9vZl9pcGF0aCBwcyBpblxuICAgICAgICAgICBsZXQgcHMgPSBKcy5hcnJheSAoQXJyYXkub2ZfbGlzdCAoTGlzdC5tYXAgSnMuc3RyaW5nIHBzKSkgaW5cblxuICAgICAgICAgICBsZXQgYXVpID1cbiAgICAgICAgICAgICBsZXQgcDJwID0gQ29yZUxvZ2ljLnBhdGhfb2ZfaXBhdGggaW5cblxuICAgICAgICAgICAgIG1hdGNoIGF1aSB3aXRoXG4gICAgICAgICAgICAgfCBgQ2xpY2sgcCAtPiBKcy5VbnNhZmUub2JqIFt8XG4gICAgICAgICAgICAgICAgIFwia2luZFwiICAsIEpzLlVuc2FmZS5pbmplY3QgKEpzLnN0cmluZyBcImNsaWNrXCIpO1xuICAgICAgICAgICAgICAgICBcInRhcmdldFwiLCBKcy5VbnNhZmUuaW5qZWN0IChKcy5zdHJpbmcgKHAycCBwKSk7XG4gICAgICAgICAgICAgICB8XVxuXG4gICAgICAgICAgICAgfCBgRG5EIChzcmMsIGRzdCkgLT4gSnMuVW5zYWZlLm9iaiBbfFxuICAgICAgICAgICAgICAgICBcImtpbmRcIiAgICAgICAsIEpzLlVuc2FmZS5pbmplY3QgKEpzLnN0cmluZyBcImRuZFwiKTtcbiAgICAgICAgICAgICAgICAgXCJzb3VyY2VcIiAgICAgLCBKcy5VbnNhZmUuaW5qZWN0IChKcy5zdHJpbmcgKHAycCBzcmMpKTtcbiAgICAgICAgICAgICAgICAgXCJkZXN0aW5hdGlvblwiLCBKcy5VbnNhZmUuaW5qZWN0IChKcy5zdHJpbmcgKHAycCBkc3QpKTtcbiAgICAgICAgICAgICAgIHxdXG4gICAgICAgICAgIGluICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgSnMuVW5zYWZlLm9iaiBbfFxuICAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIiwgSnMuVW5zYWZlLmluamVjdCAoSnMuc3RyaW5nIHApIDtcbiAgICAgICAgICAgICBcImhpZ2hsaWdodFwiICAsIEpzLlVuc2FmZS5pbmplY3QgcHMgICAgICAgICAgICA7XG4gICAgICAgICAgICAgXCJ1aVwiICAgICAgICAgLCBhdWkgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgIFwiYWN0aW9uXCIgICAgICwgSnMuVW5zYWZlLmluamVjdCBhICAgICAgICAgICAgIHxdKSBhY3Rpb25zKSlcblxuICAoKiBTYW1lIGFzIFthY3Rpb25zXSwgYnV0IGluIGFzeW5jIG1vZGUuIFRPIEJFIFRFU1RFRCAqKVxuICBtZXRob2QgcGFjdGlvbnMgcGF0aCA9XG4gICAgbGV0JWx3dCBfID0gTHd0LnJldHVybiAoKSBpbiBMd3QucmV0dXJuIChfc2VsZiMjYWN0aW9ucyBwYXRoKVxuXG4gICgqIEFwcGx5IHRoZSBhY3Rpb24gW2FjdGlvbl0gKGFzIHJldHVybmVkIGJ5IFthY3Rpb25zXSkgKilcbiAgbWV0aG9kIGFwcGx5IGFjdGlvbiA9XG4gICAganNfcHJvb2ZfZW5naW5lICghISAoY3VycnkgQ29yZUxvZ2ljLmFwcGx5KSAoX3NlbGYjIy5wcm9vZiwgYWN0aW9uKSlcbiAgXG4gICgqIExvYWQgdGhlIGxlbW1hIGRhdGFiYXNlIHNwZWNpZmllZCBieSB0aGUgW2xlbW1hc10gb2JqZWN0IGludG8gdGhlIHByb3ZlciAqKVxuICBtZXRob2QgbG9hZGRiIGxlbW1hcyA9XG4gICAgbGV0IGxlbW1hcyA6IChzdHJpbmcgKiBzdHJpbmcpIGxpc3QgPVxuICAgICAgbWF0Y2ggSnMudG9fc3RyaW5nIChKcy50eXBlb2YgbGVtbWFzKSB3aXRoXG4gICAgICB8IFwib2JqZWN0XCIgLT5cbiAgICAgICAgICBsZW1tYXMgfD4gSnMub2JqZWN0X2tleXMgfD4gSnMudG9fYXJyYXkgfD4gQXJyYXkudG9fbGlzdCB8PlxuICAgICAgICAgIExpc3QubWFwIGJlZ2luIGZ1biBuYW1lIC0+XG4gICAgICAgICAgICBsZXQgbmFtZSA9IEpzLmFzX3N0cmluZyBJbnZhbGlkTGVtbWFEQiBuYW1lIGluXG4gICAgICAgICAgICBsZXQgc3RtdCA9IEpzLmFzX3N0cmluZyBJbnZhbGlkTGVtbWFEQiAoSnMuVW5zYWZlLmdldCBsZW1tYXMgbmFtZSkgaW5cbiAgICAgICAgICAgIChuYW1lLCBzdG10KVxuICAgICAgICAgIGVuZFxuICAgICAgfCBfIC0+IHJhaXNlIEludmFsaWRMZW1tYURCXG4gICAgICBpblxuICAgIGxldCBwciA9IFByb29mLmxvYWRkYiBfc2VsZiMjLnByb29mIGxlbW1hcyBpblxuICAgIGpzX3Byb29mX2VuZ2luZSBwclxuXG4gICgqIFNlcmlhbGl6ZSB0aGUgY3VycmVudCBsZW1tYSBkYXRhYmFzZSBpbnRvIGEgSlMgb2JqZWN0LiBJZiBbc2VsZWN0aW9uXSBpc1xuICAgICBkZWZpbmVkLCBmaWx0ZXJzIG91dCBsZW1tYXMgd2hpY2ggY2Fubm90IGJlIGFwcGxpZWQgdG8gdGhlIHNlbGVjdGlvbi4gKilcbiAgbWV0aG9kIGdldGRiIHNlbGVjdGlvbiA9XG4gICAgbGV0IHNlbGVjdGlvbiA9IHNlbGVjdGlvbiB8PiBKcy5PcHRkZWYudG9fb3B0aW9uIHw+IE9wdGlvbi5tYXAgUGF0aC5vZl9hcnJheSBpblxuICAgIF9zZWxmIyMucHJvb2YgfD4gQ29yZUxvZ2ljLmxlbW1hcyA/c2VsZWN0aW9uIHw+XG4gICAgTGlzdC5tYXAgYmVnaW4gZnVuIChuYW1lLCBmb3JtKSAtPlxuICAgICAgbGV0IHN0bXQgPVxuICAgICAgICBGby5Ob3RhdGlvbi5mX3Rvc3RyaW5nIGZvcm0gfD5cbiAgICAgICAgSnMuc3RyaW5nIHw+XG4gICAgICAgIEpzLlVuc2FmZS5pbmplY3RcbiAgICAgIGluIG5hbWUsIHN0bXRcbiAgICBlbmQgfD5cbiAgICBBcnJheS5vZl9saXN0IHw+XG4gICAgSnMuVW5zYWZlLm9ialxuZW5kXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG4oKiBKUyB3cmFwcGVyIGZvciBzdWJnb2FscyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuYW5kIGpzX3N1YmdvYWwgcGFyZW50IChoYW5kbGUgOiBIYW5kbGUudCkgPSBvYmplY3QlanMgKF9zZWxmKVxuICAoKiBiYWNrLWxpbmsgdG8gdGhlIFtqc19wcm9vZl9lbmdpbmVdIHRoaXMgc3ViZ29hbCBiZWxvbmdzIHRvICopXG4gIHZhbCBwYXJlbnQgPSBwYXJlbnRcblxuICAoKiB0aGUgaGFuZGxlIChVSUQpIG9mIHRoZSBzdWJnb2FsICopXG4gIHZhbCBoYW5kbGUgPSBoYW5kbGVcblxuICAoKiBSZXR1cm4gYWxsIHRoZSBmdW5jdGlvbmFsIHZhcmlhYmxlcyBhcyBhIFtzdHJpbmcgYXJyYXldICopXG4gIG1ldGhvZCBmdmFycyA9XG4gICAgbGV0IGdvYWwgPSBQcm9vZi5ieWlkIHBhcmVudCMjLnByb29mIF9zZWxmIyMuaGFuZGxlIGluXG4gICAgbGV0IGZ2YXJzIDogc3RyaW5nIGxpc3QgPVxuICAgICAgRm8uRnVucy5hbGwgZ29hbC5nX2VudiB8PlxuICAgICAgTWFwLmJpbmRpbmdzIHw+XG4gICAgICBMaXN0Lm1hcCAoZnVuIChmLCAoYXIsIHJlcykpIC0+XG4gICAgICAgIGxldCBhciA9IExpc3QudG9fc3RyaW5nIH5zZXA6XCIgJiBcIiB+bGVmdDpcIlwiIH5yaWdodDpcIlwiIEZvLk5vdGF0aW9uLnRfdG9zdHJpbmcgYXIgaW5cbiAgICAgICAgbGV0IHJlcyA9IEZvLk5vdGF0aW9uLnRfdG9zdHJpbmcgcmVzIGluXG4gICAgICAgIFByaW50Zi5zcHJpbnRmIFwiJXMgOiAlcyAtPiAlc1wiIGYgYXIgcmVzKSBpblxuICAgIEpzLmFycmF5IChBcnJheS5vZl9saXN0IChMaXN0Lm1hcCBKcy5zdHJpbmcgZnZhcnMpKVxuXG4gICgqIFJldHVybiBhbGwgdGhlIHByb3Bvc2l0aW9uYWwgdmFyaWFibGVzIGFzIGEgW3N0cmluZyBhcnJheV0gKilcbiAgbWV0aG9kIHB2YXJzID1cbiAgICBsZXQgZ29hbCA9IFByb29mLmJ5aWQgcGFyZW50IyMucHJvb2YgX3NlbGYjIy5oYW5kbGUgaW5cbiAgICBsZXQgcHZhcnMgPSBMaXN0LmZzdCAoTWFwLmJpbmRpbmdzIChGby5QcnBzLmFsbCBnb2FsLmdfZW52KSkgaW5cbiAgICBKcy5hcnJheSAoQXJyYXkub2ZfbGlzdCAoTGlzdC5tYXAgSnMuc3RyaW5nIHB2YXJzKSlcblxuICAoKiBSZXR1cm4gYWxsIHRoZSBsb2NhbCB2YXJpYWJsZXMgYXMgYSBbanNfdHZhciBhcnJheV0gKilcbiAgbWV0aG9kIHR2YXJzID1cbiAgICBsZXQgZ29hbCAgPSBQcm9vZi5ieWlkIHBhcmVudCMjLnByb29mIF9zZWxmIyMuaGFuZGxlIGluXG4gICAgbGV0IHR2YXJzID0gRm8uVmFycy50b19saXN0IGdvYWwuZ19lbnYgaW5cbiAgICBsZXQgYW91dCAgPSBMaXN0Lm1hcGkgKGZ1biBpIChpZCwgeCwgYikgLT5cbiAgICAgIGpzX3R2YXIgX3NlbGYgKGksIChIYW5kbGUub2ZpbnQgaWQsIHgsIGIpKSkgdHZhcnMgaW5cbiAgICBKcy5hcnJheSAoQXJyYXkub2ZfbGlzdCBhb3V0KVxuXG4gICgqIFJldHVybiBhbGwgdGhlIGxvY2FsIGh5cG90aGVzZXMgKGNvbnRleHQpIGFzIGEgW2pzX2h5cHMgYXJyYXldICopXG4gIG1ldGhvZCBjb250ZXh0ID1cbiAgICBsZXQgZ29hbCA9IFByb29mLmJ5aWQgcGFyZW50IyMucHJvb2YgX3NlbGYjIy5oYW5kbGUgaW5cbiAgICBsZXQgaHlwcyA9IExpc3QucmV2IChQcm9vZi5IeXBzLnRvX2xpc3QgZ29hbC5nX2h5cHMpIGluXG5cbiAgICBKcy5hcnJheSAoQXJyYXkub2ZfbGlzdCAoTGlzdC5tYXBpIChmdW4gaSB4IC0+IGpzX2h5cHMgX3NlbGYgKGksIHgpKSBoeXBzKSlcblxuICAoKiBSZXR1cm4gdGhlIHN1YmdvYWwgY29uY2x1c2lvbiBhcyBhIFtqc19mb3JtXSAqKVxuICBtZXRob2QgY29uY2x1c2lvbiA9XG4gICAgbGV0IGdvYWwgID0gUHJvb2YuYnlpZCBwYXJlbnQjIy5wcm9vZiBfc2VsZiMjLmhhbmRsZSBpblxuICAgIGpzX2Zvcm0gKF9zZWxmIyMuaGFuZGxlLCBgQykgZ29hbC5nX2dvYWxcblxuICAoKiBbdGhpcyNpbnRybyBbdmFyaWFudCA6IGludF1dIGFwcGxpZXMgdGhlIHJlbGV2YW50IGludHJvZHVjdGlvblxuICAgKiBydWxlIHRvIHRoZSBjb25jbHVzaW9uIG9mIHRoZSBzdWJnb2FsIFt0aGlzXS4gVGhlIHBhcmFtZXRlclxuICAgKiBbdmFyaWFudF0gZ2l2ZXMgdGhlIHZhcmlhbnQgb2YgdGhlIGludHJvZHVjdGlvbiBydWxlIHRvIGJlIGFwcGxpZWQuXG4gICAqXG4gICAqIFNlZSBbI2l2YXJpYW50c10gKilcblxuICBtZXRob2QgaW50cm8gdmFyaWFudCA9XG4gICAganNfcHJvb2ZfZW5naW5lICghIShDb3JlTG9naWMuaW50cm8gfnZhcmlhbnQpIChwYXJlbnQjIy5wcm9vZiwgaGFuZGxlKSlcblxuICAoKiBbdGhpcyNlbGltICh0YXJnZXQgOiBoYW5kbGU8anNfaHlwcz4pXV0gYXBwbGllcyB0aGUgcmVsZXZhbnQgZWxpbWluYXRpb25cbiAgICogcnVsZSB0byB0aGUgaHlwb3RoZXNpcyBbdGFyZ2V0XSBvZiB0aGUgc3ViZ29hbCBbdGhpc10uXG4gICAqXG4gICAqIFJhaXNlIGFuIGV4Y2VwdGlvbiBpZiBbdGFyZ2V0XSBkb2VzIG5vdCBiZWxvbmcgdG8gW3RoaXNdICopXG4gIG1ldGhvZCBlbGltIHRhcmdldCA9XG4gICAgbGV0IGRhdGEgPSAodGFyZ2V0LCAocGFyZW50IyMucHJvb2YsIGhhbmRsZSkpIGluXG4gICAganNfcHJvb2ZfZW5naW5lICghIShjdXJyeSBDb3JlTG9naWMuZWxpbSkgZGF0YSlcblxuICAoKiBbdGhpcyNpdmFyaWFudHNdIFJldHVybiB0aGUgYXZhaWxhYmxlIGludHJvZHVjdGlvbiBydWxlcyB0aGF0IGNhblxuICAgKiBiZSBhcHBsaWVkIHRvIHRoZSBjb25jbHVzaW9uIG9mIFt0aGlzXSBhcyBhIHN0cmluZyBhcnJheS4gVGhlIHN0cmluZ3NcbiAgICogYXJlIG9ubHkgZm9yIGRvY3VtZW50YXRpb24gcHVycG9zZXMgLSBvbmx5IHRoZWlyIHBvc2l0aW9uIGluIHRoZVxuICAgKiByZXR1cm5lZCBhcnJheSBpcyBtZWFuaW5nZnVsIGFuZCBjYW4gYmUgdXNlZCBhcyBhcmd1bWVudCB0byBbI2ludHJvXVxuICAgKiB0byBzZWxlY3QgdGhlIGRlc2lyZWQgaW50cm9kdWN0aW9uIHJ1bGUuICopXG4gIG1ldGhvZCBpdmFyaWFudHMgPVxuICAgIGxldCBhb3V0ID0gISFDb3JlTG9naWMuaXZhcmlhbnRzIChwYXJlbnQjIy5wcm9vZiwgaGFuZGxlKSBpblxuICAgIGxldCBhb3V0ID0gQXJyYXkub2ZfbGlzdCAoTGlzdC5tYXAgSnMuc3RyaW5nIGFvdXQpIGluXG4gICAgSnMuYXJyYXkgYW91dFxuXG4gICgqIFt0aGlzI2N1dCAoZm9ybSA6IHN0cmluZyldIHBhcnNlcyBbZm9ybV0gaW4gdGhlIGdvYWwgW2NvbnRleHRdIGFuZFxuICAgKiBjdXQgaXQuICopXG4gIG1ldGhvZCBjdXQgZm9ybSA9XG4gICAgbGV0IGRvaXQgKCkgPVxuICAgICAgbGV0IGdvYWwgPSBQcm9vZi5ieWlkIHBhcmVudCMjLnByb29mIF9zZWxmIyMuaGFuZGxlIGluXG4gICAgICBsZXQgZm9ybSA9IFN0cmluZy50cmltIChKcy50b19zdHJpbmcgZm9ybSkgaW5cbiAgICAgIGxldCBmb3JtID0gSW8ucGFyc2VfZm9ybSAoSW8uZnJvbV9zdHJpbmcgZm9ybSkgaW5cbiAgICAgIGxldCBmb3JtID0gRm8uRm9ybS5jaGVjayBnb2FsLmdfZW52IGZvcm0gaW5cbiAgICAgIENvcmVMb2dpYy5jdXQgZm9ybSAocGFyZW50IyMucHJvb2YsIF9zZWxmIyMuaGFuZGxlKVxuICAgIGluIGpzX3Byb29mX2VuZ2luZSAoISFkb2l0ICgpKVxuICBcbiAgKCogW3RoaXMjYWRkbGVtbWEgKG5hbWUgOiBzdHJpbmcpXSByZXRyaWV2ZXMgdGhlIGxlbW1hIFtuYW1lXSBpbiB0aGUgZGF0YWJhc2UsXG4gICAgIGFuZCBhZGRzIGl0IGFzIGEgbmV3IGh5cG90aGVzaXMgaW4gdGhlIGN1cnJlbnQgZ29hbC4gKilcbiAgbWV0aG9kIGFkZGxlbW1hIG5hbWUgPVxuICAgIGxldCBkb2l0ICgpID1cbiAgICAgIGxldCBuYW1lID0gSnMudG9fc3RyaW5nIG5hbWUgaW5cbiAgICAgIGxldCBmb3JtID0gTGVtbWFEQi5maW5kIChQcm9vZi5kYiBwYXJlbnQjIy5wcm9vZikgbmFtZSBpblxuICAgICAgQ29yZUxvZ2ljLmFzc3VtZSBmb3JtIChwYXJlbnQjIy5wcm9vZiwgX3NlbGYjIy5oYW5kbGUpXG4gICAgaW4ganNfcHJvb2ZfZW5naW5lICghIWRvaXQgKCkpXG4gICAgICBcblxuICAoKiBbdGhpcyNhZGRfbG9jYWwgKG5hbWUgOiBzdHJpbmcpIChleHByIDogc3RyaW5nKSBwYXJzZXMgW2V4cHJdIGluIHRoZSBnb2FsXG4gICAqIFtjb250ZXh0XSBhbmQgYWRkcyBpdCB0byB0aGUgbG9jYWwgW2NvbnRleHRdIHVuZGVyIHRoZSBuYW1lIFtuYW1lXS4gKilcbiAgbWV0aG9kIGFkZGxvY2FsIG5hbWUgZXhwciA9XG4gICAgbGV0IGRvaXQgKCkgPVxuICAgICAgbGV0IGdvYWwgPSBQcm9vZi5ieWlkIHBhcmVudCMjLnByb29mIF9zZWxmIyMuaGFuZGxlIGluXG4gICAgICBsZXQgZXhwciA9IFN0cmluZy50cmltIChKcy50b19zdHJpbmcgZXhwcikgaW5cbiAgICAgIGxldCBleHByID0gSW8ucGFyc2VfZXhwciAoSW8uZnJvbV9zdHJpbmcgZXhwcikgaW5cbiAgICAgIGxldCBleHByLCB0eSA9IEZvLkZvcm0uZWNoZWNrIGdvYWwuZ19lbnYgZXhwciBpblxuICAgICAgQ29yZUxvZ2ljLmFkZF9sb2NhbCAoSnMudG9fc3RyaW5nIG5hbWUsIHR5LCBTb21lIGV4cHIpIChwYXJlbnQjIy5wcm9vZiwgX3NlbGYjIy5oYW5kbGUpXG5cbiAgICBpbiBqc19wcm9vZl9lbmdpbmUgKCEhZG9pdCAoKSlcblxuICAoKiBbdGhpcyNhZGRfYWxpYXMgKG5leHByIDogc3RyaW5nKSBwYXJzZXMgW25leHByXSBhcyBhIG5hbWVkIGV4cHJlc3Npb25cbiAgICogaW4gdGhlIGdvYWwgW2NvbnRleHRdIGFuZCBhZGQgaXQgdG8gdGhlIGxvY2FsIFtjb250ZXh0XS4gKilcbiAgbWV0aG9kIGFkZGFsaWFzIGV4cHIgPVxuICAgIGxldCBkb2l0ICgpID1cbiAgICAgIGxldCBnb2FsID0gUHJvb2YuYnlpZCBwYXJlbnQjIy5wcm9vZiBfc2VsZiMjLmhhbmRsZSBpblxuICAgICAgbGV0IGV4cHIgPSBTdHJpbmcudHJpbSAoSnMudG9fc3RyaW5nIGV4cHIpIGluXG4gICAgICBsZXQgbmFtZSwgZXhwciA9IElvLnBhcnNlX25leHByIChJby5mcm9tX3N0cmluZyBleHByKSBpblxuICAgICAgbGV0IGV4cHIsIHR5ID0gRm8uRm9ybS5lY2hlY2sgZ29hbC5nX2VudiBleHByIGluXG4gICAgICBDb3JlTG9naWMuYWRkX2xvY2FsIChMb2NhdGlvbi51bmxvYyBuYW1lLCB0eSwgU29tZSBleHByKSAocGFyZW50IyMucHJvb2YsIF9zZWxmIyMuaGFuZGxlKVxuXG4gICAgaW4ganNfcHJvb2ZfZW5naW5lICghIWRvaXQgKCkpXG5cbiAgKCogW3RoaXMjbW92ZV9oeXAgKGZyb20gOiBoYW5kbGU8anNfaHlwPikgKGJlZm9yZSA6IGhhbmRsZTxqc19oeXA+IG9wdGlvbildIG1vdmVcbiAgICogaHlwb3RoZXNpcyBbZnJvbV0gYmVmb3JlIGh5cG90aGVzaXMgW2JlZm9yZV0uIEJvdGggaHlwb3RoZXNpc1xuICAgKiBtdXN0IGJlIHBhcnQgb2YgdGhpcyBzdWItZ29hbC4gKilcbiAgbWV0aG9kIG1vdmVfaHlwIGZyb20gYmVmb3JlID1cbiAgICBsZXQgZG9pdCAoKSA9XG4gICAgICBDb3JlTG9naWMubW92ZVxuICAgICAgICBmcm9tIChKcy5PcHQudG9fb3B0aW9uIGJlZm9yZSlcbiAgICAgICAgKHBhcmVudCMjLnByb29mLCBfc2VsZiMjLmhhbmRsZSlcbiAgICBpbiAhIWRvaXQgKClcblxuICAoKiBbdGhpcyNnZW5lcmFsaXplIChoIDogaGFuZGxlPGpzX2h5cHM+KSBnZW5lcmFsaXplcyB0aGUgaHlwb3RoZXNpcyBbaF0gKilcbiAgbWV0aG9kIGdlbmVyYWxpemUgaGlkID1cbiAgICBsZXQgZG9pdCAoKSA9XG4gICAgICBDb3JlTG9naWMuZ2VuZXJhbGl6ZSBoaWQgKHBhcmVudCMjLnByb29mLCBfc2VsZiMjLmhhbmRsZSlcbiAgICBpbiBqc19wcm9vZl9lbmdpbmUgKCEhZG9pdCAoKSlcblxuICBtZXRob2QgZ2V0bWV0YSA9XG4gICAgSnMuT3B0Lm9wdGlvbiAoUHJvb2YuZ2V0X21ldGEgcGFyZW50IyMucHJvb2YgX3NlbGYjIy5oYW5kbGUpXG5cbiAgbWV0aG9kIHNldG1ldGEgbWV0YSA9XG4gICAgUHJvb2Yuc2V0X21ldGEgcGFyZW50IyMucHJvb2YgX3NlbGYjIy5oYW5kbGUgKEpzLk9wdC50b19vcHRpb24gbWV0YSlcbiAgXG4gIG1ldGhvZCB0b2FzY2lpID1cbiAgICBsZXQgZnVucyA6IHN0cmluZyBsaXN0ID1cbiAgICAgIF9zZWxmIyNmdmFycyB8PiBKcy50b19hcnJheSB8PiBBcnJheS50b19saXN0IHw+IExpc3QubWFwIEpzLnRvX3N0cmluZyBpblxuICAgIGxldCBwcm9wcyA6IHN0cmluZyBsaXN0ID1cbiAgICAgIF9zZWxmIyNwdmFycyB8PiBKcy50b19hcnJheSB8PiBBcnJheS50b19saXN0IHw+IExpc3QubWFwIEpzLnRvX3N0cmluZyBpblxuICAgIGxldCB2YXJzIDogc3RyaW5nIGxpc3QgPVxuICAgICAgX3NlbGYjI3R2YXJzIHw+IEpzLnRvX2FycmF5IHw+IEFycmF5LnRvX2xpc3QgfD4gTGlzdC5tYXAgKGZ1biB2IC0+IHYjI3RvYXNjaWkgfD4gSnMudG9fc3RyaW5nKSBpblxuICAgIGxldCBoeXBzIDogc3RyaW5nIGxpc3QgPVxuICAgICAgX3NlbGYjI2NvbnRleHQgfD4gSnMudG9fYXJyYXkgfD4gQXJyYXkudG9fbGlzdCB8PiBMaXN0Lm1hcCAoZnVuIGggLT4gaCMjdG9hc2NpaSB8PiBKcy50b19zdHJpbmcpIGluXG4gICAgbGV0IGNvbmNsIDogc3RyaW5nID1cbiAgICAgIF9zZWxmIyNjb25jbHVzaW9uIHw+IGZ1biBjIC0+IGMjI3RvYXNjaWkgfD4gSnMudG9fc3RyaW5nIGluXG4gICAgXG4gICAgbGV0IHRvX3N0cmluZyA9IExpc3QudG9fc3RyaW5nIH5zZXA6XCIsIFwiIH5sZWZ0OlwiXCIgfnJpZ2h0OlwiXCIgaWRlbnRpdHkgaW5cbiAgICBsZXQgY29tbWEgPVxuICAgICAgXCJcIiB8PiBMaXN0LmZvbGRfbGVmdCAoZnVuIHMgbCAtPlxuICAgICAgICBpZiBTdHJpbmcuaXNfZW1wdHkgcyB0aGVuXG4gICAgICAgICAgaWYgTGlzdC5pc19lbXB0eSBsIHRoZW4gXCJcIlxuICAgICAgICAgIGVsc2UgdG9fc3RyaW5nIGxcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGlmIExpc3QuaXNfZW1wdHkgbCB0aGVuIHNcbiAgICAgICAgICBlbHNlIHMgXiBcIiwgXCIgXiB0b19zdHJpbmcgbCkgaW5cblxuICAgIEpzLnN0cmluZyAoUHJpbnRmLnNwcmludGYgXCIlczsgJXMgfC0gJXNcIlxuICAgICAgKGNvbW1hIFtmdW5zOyB2YXJzOyBwcm9wc10pXG4gICAgICAodG9fc3RyaW5nIGh5cHMpXG4gICAgICBjb25jbClcblxuICBtZXRob2QgdG9zdHJpbmcgPVxuICAgIGxldCBoeXBzIDogc3RyaW5nIGxpc3QgPVxuICAgICAgX3NlbGYjI2NvbnRleHQgfD4gSnMudG9fYXJyYXkgfD4gQXJyYXkudG9fbGlzdCB8PiBMaXN0Lm1hcCAoZnVuIGggLT4gaCMjdG9zdHJpbmcgfD4gSnMudG9fc3RyaW5nKSBpblxuICAgIGxldCBjb25jbCA6IHN0cmluZyA9XG4gICAgICBfc2VsZiMjY29uY2x1c2lvbiB8PiBmdW4gYyAtPiBjIyN0b3N0cmluZyB8PiBKcy50b19zdHJpbmcgaW5cbiAgICBcbiAgICBsZXQgdG9fc3RyaW5nID0gTGlzdC50b19zdHJpbmcgfnNlcDpcIiwgXCIgfmxlZnQ6XCJcIiB+cmlnaHQ6XCJcIiBpZGVudGl0eSBpblxuXG4gICAgSnMuc3RyaW5nIChQcmludGYuc3ByaW50ZiBcIiVzIOKKoiAlc1wiXG4gICAgICAodG9fc3RyaW5nIGh5cHMpXG4gICAgICBjb25jbClcbmVuZFxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuKCogSlMgV3JhcHBlciBmb3IgYSBjb250ZXh0IGh5cG90aGVzaXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbmFuZCBqc19oeXBzIHBhcmVudCAoaSwgKGhhbmRsZSwgaHlwKSA6IGludCAqIChIYW5kbGUudCAqIFByb29mLmh5cCkpID1cbm9iamVjdCVqcyAoX3NlbGYpXG4gICgqIGJhY2stbGluayB0byB0aGUgW2pzX3N1YmdvYWxdIHRoaXMgaHlwb3RoZXNpcyBiZWxvbmdzIHRvICopXG4gIHZhbCBwYXJlbnQgPSBwYXJlbnRcblxuICAoKiB0aGUgaGFuZGxlIChVSUQpIG9mIHRoZSBoeXBvdGhlc2lzICopXG4gIHZhbCBoYW5kbGUgPSBoYW5kbGVcblxuICAoKiB0aGUgaGFuZGxlIChVSUQpIG9mIHRoZSBwYXJlbnQgaHlwb3RoZXNpcyAqKVxuICB2YWwgcGhhbmRsZSA9IEpzLk9wdC5vcHRpb24gaHlwLmhfc3JjXG5cbiAgKCogdGhlIGhhbmRsZSBwb3NpdGlvbiBpbiBpdHMgY29udGV4dCAqKVxuICB2YWwgcG9zaXRpb24gPSBpXG5cbiAgKCogaWYgdGhlIGh5cG90aGVzaXMgaXMgZnJlc2ggLyBuZXcgKilcbiAgdmFsIGZyZXNoID0gSnMuYm9vbCAoaHlwLmhfZ2VuIDw9IDEpXG5cbiAgKCogdGhlIGh5cG90aGVzaXMgYXMgYSBbanNfZm9ybV0gKilcbiAgdmFsIGZvcm0gPSBqc19mb3JtIChwYXJlbnQjIy5oYW5kbGUsIGBIIGhhbmRsZSkgaHlwLmhfZm9ybVxuXG4gICgqIFRoZSBlbmNsb3NpbmcgcHJvb2YgZW5naW5lICopXG4gIHZhbCBwcm9vZiA9IHBhcmVudCMjLnBhcmVudFxuXG4gICgqIFJldHVybiB0aGUgW2h0bWxdIG9mIHRoZSBlbmNsb3NlZCBmb3JtdWxhICopICBcbiAgbWV0aG9kIGh0bWwgPVxuICAgIF9zZWxmIyMuZm9ybSMjaHRtbFxuXG4gICgqIFJldHVybiB0aGUgW21hdGhtbF0gb2YgdGhlIGVuY2xvc2VkIGZvcm11bGEgKikgIFxuICBtZXRob2QgbWF0aG1sID1cbiAgICBfc2VsZiMjLmZvcm0jI21hdGhtbFxuXG4gICgqIFJldHVybiBhbiBVVEY4IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZW5jbG9zZWQgZm9ybXVsYSAqKVxuICBtZXRob2QgdG9zdHJpbmcgPVxuICAgIF9zZWxmIyMuZm9ybSMjdG9zdHJpbmdcblxuICAoKiBSZXR1cm4gYW4gQVNDSUkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlbmNsb3NlZCBmb3JtdWxhICopXG4gIG1ldGhvZCB0b2FzY2lpID1cbiAgICBfc2VsZiMjLmZvcm0jI3RvYXNjaWlcblxuICBtZXRob2QgZ2V0bWV0YSA9XG4gICAgSnMuT3B0Lm9wdGlvbiAoUHJvb2YuZ2V0X21ldGEgX3NlbGYjIy5wcm9vZiMjLnByb29mIF9zZWxmIyMuaGFuZGxlKVxuXG4gIG1ldGhvZCBzZXRtZXRhIG1ldGEgPVxuICAgIFByb29mLnNldF9tZXRhIF9zZWxmIyMucHJvb2YjIy5wcm9vZiBfc2VsZiMjLmhhbmRsZSAoSnMuT3B0LnRvX29wdGlvbiBtZXRhKVxuZW5kXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG4oKiBKUyBXcmFwcGVyIGZvciBhIGxvY2FsIHZhcmlhYmxlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuYW5kIGpzX3R2YXIgcGFyZW50ICgoaSwgKGhhbmRsZSwgeCwgKHR5LCBiKSkpIDogaW50ICogKEhhbmRsZS50ICogRm8udm5hbWUgKiBGby5idmFyKSkgPVxub2JqZWN0JWpzIChfc2VsZilcbiAgKCogYmFjay1saW5rIHRvIHRoZSBbanNfc3ViZ29hbF0gdGhpcyBsb2NhbCB2YXJpYWJsZSBiZWxvbmdzIHRvICopXG4gIHZhbCBwYXJlbnQgPSBwYXJlbnRcblxuICAoKiB0aGUgaGFuZGxlIG9mIHRoZSBsb2NhbCB2YXJpYWJsZSAqKVxuICB2YWwgaGFuZGxlID0gaGFuZGxlXG5cbiAgKCogdGhlIGhhbmRsZSBwb3NpdGlvbiBpbiBpdHMgY29udGV4dCAqKVxuICB2YWwgcG9zaXRpb24gPSBpXG5cbiAgKCogdGhlIGxvY2FsIHZhcmlhYmxlIG5hbWUgKilcbiAgdmFsIG5hbWUgPSBKcy5zdHJpbmcgKEZvLk5vdGF0aW9uLmVfdG9zdHJpbmcgKEVWYXIgeCkpXG5cbiAgKCogdGhlIGxvY2FsIHZhcmlhYmxlIHR5cGUgYXMgYSBbanNfdHlwZV0gKilcbiAgdmFsIHR5cGVfID0ganNfdHlwZSB0eVxuXG4gICgqIHRoZSBsb2NhbCBkZWZpbml0aW9uIC0gcmV0dXJuIGFuIG9wdGlvbmFsIGV4cHJlc3Npb24gKilcbiAgdmFsIGJvZHkgPVxuICAgIEpzLk9wdC5vcHRpb24gKE9wdGlvbi5tYXAganNfZXhwciBiKVxuXG4gICgqIHRoZSBlbmNsb3NpbmcgcHJvb2YgZW5naW5lICopXG4gIHZhbCBwcm9vZiA9IHBhcmVudCMjLnBhcmVudFxuXG4gIG1ldGhvZCBwcmVmaXggKGIgOiBib29sKSA9XG4gICAgRm9ybWF0LnNwcmludGYgXCIlZC9WJXMjJWQlc1wiXG4gICAgICAoSGFuZGxlLnRvaW50IF9zZWxmIyMucGFyZW50IyMuaGFuZGxlKVxuICAgICAgKGlmIGIgdGhlbiBcImJcIiBlbHNlIFwiaFwiKVxuICAgICAgKEhhbmRsZS50b2ludCBfc2VsZiMjLmhhbmRsZSlcbiAgICAgIChpZiBiIHRoZW4gXCJcIiBlbHNlIFwiOlwiKVxuICBcbiAgKCogdGhlIHBhdGggdG8gdGhlIGxvY2FsIHZhcmlhYmxlJ3MgaGVhZCAqKVxuICBtZXRob2QgaWRoZWFkID0gX3NlbGYjI3ByZWZpeCBmYWxzZVxuXG4gICgqIHRoZSBwYXRoIHRvIHRoZSBsb2NhbCB2YXJpYWJsZSdzIGJvZHkgKilcbiAgbWV0aG9kIGlkYm9keSA9IF9zZWxmIyNwcmVmaXggdHJ1ZVxuXG4gICgqIFJldHVybiB0aGUgW2h0bWxdIG9mIHRoZSBlbmNsb3NlZCBsb2NhbCB2YXJpYWJsZSAqKSAgXG4gIG1ldGhvZCBodG1sID1cbiAgICBsZXQgb3BlbiBUeXhtbCBpblxuICAgIGxldCBvcGVuIFV0aWxzLkh0bWwgaW5cblxuICAgIGxldCBkdCA9XG4gICAgICBzcGFuIFtcbiAgICAgICAgc3BhbiBiZWdpblxuICAgICAgICAgIFtzcGFuIH5hOltYbWwuc3RyaW5nX2F0dHJpYiBcImlkXCIgX3NlbGYjI2lkaGVhZF0gYmVnaW5cbiAgICAgICAgICAgIFtzcGFuXG4gICAgICAgICAgICAgIFtYbWwucGNkYXRhIChVVEY4Lm9mX2xhdGluMSAoRm8uTm90YXRpb24uZV90b3N0cmluZyAoRVZhciB4KSkpXV0gQFxuICAgICAgICAgICAgICBzcGFjZWQgW3NwYW4gW1htbC5wY2RhdGEgXCI6XCJdXSBAXG4gICAgICAgICAgICAgIFtGby5Ob3RhdGlvbi50X3RvaHRtbCB0eV1cbiAgICAgICAgICBlbmRdXG4gICAgICAgICAgQFxuICAgICAgICAgIG1hdGNoIGIgd2l0aFxuICAgICAgICAgIHwgU29tZSBiIC0+XG4gICAgICAgICAgICAgIHNwYWNlZCBbc3BhbiBbWG1sLnBjZGF0YSBcIjo9XCJdXSBAXG4gICAgICAgICAgICAgIFtGby5Ob3RhdGlvbi5lX3RvaHRtbCB+aWQ6KFNvbWUgX3NlbGYjI2lkYm9keSkgYl1cbiAgICAgICAgICB8IE5vbmUgLT4gW11cbiAgICAgICAgZW5kXVxuICAgIGluIEpzLnN0cmluZyAoRm9ybWF0LmFzcHJpbnRmIFwiJWFcIiAoVHl4bWwuWG1sLnBwICgpKSBkdClcblxuICAoKiBSZXR1cm4gdGhlIFttYXRobWxdIG9mIHRoZSBlbmNsb3NlZCBsb2NhbCB2YXJpYWJsZSAqKSAgXG4gIG1ldGhvZCBtYXRobWwgPVxuICAgIGxldCBvcGVuIFR5eG1sIGluXG4gICAgbGV0IG9wZW4gVXRpbHMuTWF0aG1sIGluXG5cbiAgICBsZXQgZHQgPVxuICAgICAgbWF0aCBbXG4gICAgICAgIHJvdyBiZWdpblxuICAgICAgICAgIFtyb3cgfmE6W1htbC5zdHJpbmdfYXR0cmliIFwiaWRcIiBfc2VsZiMjaWRoZWFkXSBiZWdpblxuICAgICAgICAgICAgW21pIChVVEY4Lm9mX2xhdGluMSAoRm8uTm90YXRpb24uZV90b3N0cmluZyAoRVZhciB4KSkpXSBAXG4gICAgICAgICAgICBbbW8gXCI6XCJdIEBcbiAgICAgICAgICAgIFtGby5Ob3RhdGlvbi50X3RvbWF0aG1sIHR5XVxuICAgICAgICAgIGVuZF1cbiAgICAgICAgICBAXG4gICAgICAgICAgbWF0Y2ggYiB3aXRoXG4gICAgICAgICAgfCBTb21lIGIgLT5cbiAgICAgICAgICAgICAgW21vIFwiOj1cIl0gQFxuICAgICAgICAgICAgICBbRm8uTm90YXRpb24uZV90b21hdGhtbCB+aWQ6KFNvbWUgX3NlbGYjI2lkYm9keSkgYl1cbiAgICAgICAgICB8IE5vbmUgLT4gW11cbiAgICAgICAgZW5kXVxuICAgIGluIEpzLnN0cmluZyAoRm9ybWF0LmFzcHJpbnRmIFwiJWFcIiAoVHl4bWwuWG1sLnBwICgpKSBkdClcblxuICAoKiBSZXR1cm4gYW4gVVRGOCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGVuY2xvc2VkIGxvY2FsIHZhcmlhYmxlICopXG4gIG1ldGhvZCB0b3N0cmluZyA9XG4gICAgbWF0Y2ggYiB3aXRoXG4gICAgfCBTb21lIGIgLT5cbiAgICAgICAgSnMuc3RyaW5nIChGb3JtYXQuc3ByaW50ZiBcIiVzIDogJXMgOj0gJXNcIlxuICAgICAgICAgIChGby5Ob3RhdGlvbi5lX3Rvc3RyaW5nIChFVmFyIHgpKSAoRm8uTm90YXRpb24udF90b3N0cmluZyB0eSkgKEZvLk5vdGF0aW9uLmVfdG9zdHJpbmcgYikpXG4gICAgfCBOb25lIC0+XG4gICAgICAgIEpzLnN0cmluZyAoRm9ybWF0LnNwcmludGYgXCIlcyA6ICVzXCJcbiAgICAgICAgICAoRm8uTm90YXRpb24uZV90b3N0cmluZyAoRVZhciB4KSkgKEZvLk5vdGF0aW9uLnRfdG9zdHJpbmcgdHkpKVxuXG4gICgqIFJldHVybiBhbiBBU0NJSSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGVuY2xvc2VkIGxvY2FsIHZhcmlhYmxlICopXG4gIG1ldGhvZCB0b2FzY2lpID1cbiAgICBtYXRjaCBiIHdpdGhcbiAgICB8IFNvbWUgYiAtPlxuICAgICAgICBKcy5zdHJpbmcgKEZvcm1hdC5zcHJpbnRmIFwiJXMgOj0gJXNcIlxuICAgICAgICAgIChGby5Ob3RhdGlvbi5lX3Rvc3RyaW5nIChFVmFyIHgpKSAoRm8uTm90YXRpb24uZV90b2FzY2lpIGIpKVxuICAgIHwgTm9uZSAtPlxuICAgICAgICBKcy5zdHJpbmcgKEZvcm1hdC5zcHJpbnRmIFwiJXMgOiAlc1wiXG4gICAgICAgICAgKEZvLk5vdGF0aW9uLmVfdG9zdHJpbmcgKEVWYXIgeCkpIChGby5Ob3RhdGlvbi50X3RvYXNjaWkgdHkpKVxuXG4gIG1ldGhvZCBnZXRtZXRhID1cbiAgICBKcy5PcHQub3B0aW9uIChQcm9vZi5nZXRfbWV0YSBfc2VsZiMjLnByb29mIyMucHJvb2YgX3NlbGYjIy5oYW5kbGUpXG5cbiAgbWV0aG9kIHNldG1ldGEgbWV0YSA9XG4gICAgUHJvb2Yuc2V0X21ldGEgX3NlbGYjIy5wcm9vZiMjLnByb29mIF9zZWxmIyMuaGFuZGxlIChKcy5PcHQudG9fb3B0aW9uIG1ldGEpXG5lbmRcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbigqIEpTIFdyYXBwZXIgZm9yIGZvcm11bGFzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG5hbmQganNfZm9ybSAoc291cmNlIDogc291cmNlKSAoZm9ybSA6IEZvLmZvcm0pID0gb2JqZWN0JWpzIChfc2VsZilcbiAgKCogVGhlIHByZWZpeCBmb3IgYWxsIHN1YnBhdGhzIG9mIHRoZSBmb3JtdWxhICopXG4gIHZhbCBwcmVmaXggPVxuICAgIG1hdGNoIHNvdXJjZSB3aXRoXG4gICAgfCBoLCBgSCBpIC0+IEZvcm1hdC5zcHJpbnRmIFwiJWQvSCMlZFwiIChIYW5kbGUudG9pbnQgaCkgKEhhbmRsZS50b2ludCBpKVxuICAgIHwgaCwgYEMgICAtPiBGb3JtYXQuc3ByaW50ZiBcIiVkL0MjMFwiIChIYW5kbGUudG9pbnQgaClcbiAgXG4gICgqIFJldHVybiB0aGUgW21hdGhtbF0gb2YgdGhlIGZvcm11bGEgKikgIFxuICBtZXRob2QgbWF0aG1sID1cbiAgICBfc2VsZiMjbWF0aG1sdGFnIHRydWVcblxuICAoKiBSZXR1cm4gdGhlIFtodG1sXSBvZiB0aGUgZm9ybXVsYSAqKSAgXG4gIG1ldGhvZCBodG1sID1cbiAgICBfc2VsZiMjaHRtbHRhZyB0cnVlXG5cbiAgKCogUmV0dXJuIHRoZSBbbWF0aG1sXSBvZiB0aGUgZm9ybXVsYSAqKSAgXG4gIG1ldGhvZCBtYXRobWx0YWcgKGlkIDogYm9vbCkgPVxuICAgIGxldCBwcmVmaXggPVxuICAgICAgaWYgbm90IGlkIHRoZW4gTm9uZSBlbHNlIFNvbWUgX3NlbGYjIy5wcmVmaXggaW5cbiAgICBKcy5zdHJpbmdcbiAgICAgIChGb3JtYXQuYXNwcmludGYgXCIlYVwiIChUeXhtbC5YbWwucHAgKCkpXG4gICAgICAoVXRpbHMuTWF0aG1sLm1hdGggW0ZvLk5vdGF0aW9uLmZfdG9tYXRobWwgfmlkOnByZWZpeCBmb3JtXSkpXG5cbiAgKCogUmV0dXJuIHRoZSBbaHRtbF0gb2YgdGhlIGZvcm11bGEgKikgIFxuICBtZXRob2QgaHRtbHRhZyAoaWQgOiBib29sKSA9XG4gICAgbGV0IHByZWZpeCA9XG4gICAgICBpZiBub3QgaWQgdGhlbiBOb25lIGVsc2UgU29tZSBfc2VsZiMjLnByZWZpeCBpblxuICAgIEpzLnN0cmluZ1xuICAgICAgKEZvcm1hdC5hc3ByaW50ZiBcIiVhXCIgKFR5eG1sLlhtbC5wcCAoKSlcbiAgICAgIChGby5Ob3RhdGlvbi5mX3RvaHRtbCB+aWQ6cHJlZml4IGZvcm0pKVxuXG4gICgqIFJldHVybiBhbiBVVEY4IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZm9ybXVsYSAqKVxuICBtZXRob2QgdG9zdHJpbmcgPVxuICAgIEpzLnN0cmluZyAoRm8uTm90YXRpb24uZl90b3N0cmluZyBmb3JtKVxuXG4gICgqIFJldHVybiBhbiBBU0NJSSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGZvcm11bGEgKilcbiAgbWV0aG9kIHRvYXNjaWkgPVxuICAgIEpzLnN0cmluZyAoRm8uTm90YXRpb24uZl90b2FzY2lpIGZvcm0pXG5lbmRcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbigqIEpTIFdyYXBwZXIgZm9yIGV4cHJlc3Npb25zICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG5hbmQganNfZXhwciAoZXhwciA6IEZvLmV4cHIpID0gb2JqZWN0JWpzIChfc2VsZilcbiAgKCogUmV0dXJuIHRoZSBbbWF0aG1sXSBvZiB0aGUgZm9ybXVsYSAqKSAgXG4gIG1ldGhvZCBtYXRobWwgPVxuICAgIF9zZWxmIyNtYXRobWx0YWdcblxuICAoKiBSZXR1cm4gdGhlIFtodG1sXSBvZiB0aGUgZm9ybXVsYSAqKSAgXG4gIG1ldGhvZCBodG1sID1cbiAgICBfc2VsZiMjaHRtbHRhZ1xuXG4gICgqIFJldHVybiB0aGUgW21hdGhtbF0gb2YgdGhlIGZvcm11bGEgKikgIFxuICBtZXRob2QgbWF0aG1sdGFnID1cbiAgICBKcy5zdHJpbmdcbiAgICAgIChGb3JtYXQuYXNwcmludGYgXCIlYVwiIChUeXhtbC5YbWwucHAgKCkpXG4gICAgICAoVXRpbHMuTWF0aG1sLm1hdGggW0ZvLk5vdGF0aW9uLmVfdG9tYXRobWwgZXhwcl0pKVxuXG4gICgqIFJldHVybiB0aGUgW2h0bWxdIG9mIHRoZSBmb3JtdWxhICopICBcbiAgbWV0aG9kIGh0bWx0YWcgPVxuICAgIEpzLnN0cmluZ1xuICAgICAgKEZvcm1hdC5hc3ByaW50ZiBcIiVhXCIgKFR5eG1sLlhtbC5wcCAoKSlcbiAgICAgIChGby5Ob3RhdGlvbi5lX3RvaHRtbCBleHByKSlcblxuICAoKiBSZXR1cm4gYW4gVVRGOCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGV4cHJlc3Npb24gKilcbiAgbWV0aG9kIHRvc3RyaW5nID1cbiAgICBKcy5zdHJpbmcgKEZvLk5vdGF0aW9uLmVfdG9zdHJpbmcgZXhwcilcbmVuZFxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuKCogSlMgV3JhcHBlciBmb3IgdHlwZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbmFuZCBqc190eXBlICh0eSA6IEZvLnR5cGVfKSA9IG9iamVjdCVqcyAoX3NlbGYpXG4gICgqIFJldHVybiB0aGUgcmF3IFttYXRobWxdIG9mIHRoZSB0eXBlICopXG4gIG1ldGhvZCByYXdtYXRobWwgPVxuICAgIFV0aWxzLk1hdGhtbC5tYXRoIFtGby5Ob3RhdGlvbi50X3RvbWF0aG1sIHR5XVxuXG4gICgqIFJldHVybiB0aGUgcmF3IFtodG1sXSBvZiB0aGUgdHlwZSAqKVxuICBtZXRob2QgcmF3aHRtbCA9XG4gICAgRm8uTm90YXRpb24udF90b2h0bWwgdHlcblxuICAoKiBSZXR1cm4gdGhlIHJhdyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHR5cGUgKilcbiAgbWV0aG9kIHJhd3N0cmluZyA9XG4gICAgRm8uTm90YXRpb24udF90b3N0cmluZyB0eVxuXG4gICgqIFJldHVybiB0aGUgW21hdGhtbF0gb2YgdGhlIHR5cGUgKikgIFxuICBtZXRob2QgbWF0aG1sID1cbiAgICBKcy5zdHJpbmcgKEZvcm1hdC5hc3ByaW50ZiBcIiVhXCIgKFR5eG1sLlhtbC5wcCAoKSkgX3NlbGYjI3Jhd21hdGhtbClcblxuICAoKiBSZXR1cm4gdGhlIFtodG1sXSBvZiB0aGUgdHlwZSAqKSAgXG4gIG1ldGhvZCBodG1sID1cbiAgICBKcy5zdHJpbmcgKEZvcm1hdC5hc3ByaW50ZiBcIiVhXCIgKFR5eG1sLlhtbC5wcCAoKSkgX3NlbGYjI3Jhd2h0bWwpXG5cbiAgKCogUmV0dXJuIGFuIFVURjggc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBmb3JtdWxhICopXG4gIG1ldGhvZCB0b3N0cmluZyA9XG4gICAgSnMuc3RyaW5nIF9zZWxmIyNyYXdzdHJpbmdcbmVuZFxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxubGV0IGV4cG9ydCAobmFtZSA6IHN0cmluZykgOiB1bml0ID1cbiAgSnMuZXhwb3J0IG5hbWUgKG9iamVjdCVqc1xuICAgICgqIFt0aGlzI3BhcnNlIGlucHV0XSBwYXJzZSB0aGUgZ29hbCBbaW5wdXRdIGFuZCByZXR1cm4gYVxuICAgICAqIFtqc19wcm9vZl9lbmdpbmVdIGZvciBpdC5cbiAgICAgKlxuICAgICAqIFJhaXNlIGFuIGV4Y2VwdGlvbiBpZiBbaW5wdXRdIGlzIGludmFsaWQgKilcbiAgICBtZXRob2QgcGFyc2UgeCA9XG4gICAgICBsZXQgZW52LCBoeXBzLCBnb2FsID0gISEoZnVuICgpIC0+XG4gICAgICAgIGxldCBnb2FsID0gU3RyaW5nLnRyaW0gKEpzLnRvX3N0cmluZyB4KSBpblxuICAgICAgICBsZXQgZ29hbCA9IElvLnBhcnNlX2dvYWwgKElvLmZyb21fc3RyaW5nIGdvYWwpIGluXG4gICAgICAgIEZvLkdvYWwuY2hlY2sgZ29hbFxuICAgICAgKSAoKSBpbiBqc19wcm9vZl9lbmdpbmUgKFByb29mLmluaXQgZW52IGh5cHMgZ29hbClcblxuICAgICgqIFt0aGlzI3BhcnNlVG9Vbmljb2RlIGlucHV0XSBwYXJzZXMgdGhlIGdvYWwgW2lucHV0XSBhbmQgcmV0dXJuc1xuICAgICAqIGl0cyB1bmljb2RlIHJlcHJlc2VudGF0aW9uLlxuICAgICAqXG4gICAgICogUmFpc2UgYW4gZXhjZXB0aW9uIGlmIFtpbnB1dF0gaXMgaW52YWxpZCAqKVxuICAgIG1ldGhvZCBwYXJzZVRvVW5pY29kZSB4ID1cbiAgICAgIGxldCBfLCBoeXBzLCBnb2FsID0gISEoZnVuICgpIC0+XG4gICAgICAgICAgbGV0IGdvYWwgPSBTdHJpbmcudHJpbSAoSnMudG9fc3RyaW5nIHgjIy5pbnB1dCkgaW5cbiAgICAgICAgICBsZXQgZ29hbCA9IElvLnBhcnNlX2dvYWwgKElvLmZyb21fc3RyaW5nIGdvYWwpIGluXG4gICAgICAgICAgRm8uR29hbC5jaGVjayBnb2FsXG4gICAgICAgICkgKCkgaW5cblxuICAgICAgSnMuc3RyaW5nIChQcmludGYuc3ByaW50ZiBcIiVz4oqiICVzXCJcbiAgICAgICAgKEpzLk9wdGRlZi5jYXNlIHgjIy5wcmludEh5cHNcbiAgICAgICAgICAoZnVuIF8gLT4gXCJcIilcbiAgICAgICAgICAoZnVuIGIgLT4gaWYgbm90IChKcy50b19ib29sIGIpIHRoZW4gXCJcIlxuICAgICAgICAgICAgICAgICAgICBlbHNlIExpc3QudG9fc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB+c2VwOlwiLCBcIiB+bGVmdDpcIlwiIH5yaWdodDpcIiBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgRm8uTm90YXRpb24uZl90b3N0cmluZyBoeXBzKSlcbiAgICAgICAgKEZvLk5vdGF0aW9uLmZfdG9zdHJpbmcgZ29hbCkpXG5cbiAgZW5kKVxuIiwiKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcbmxldCAoKSA9IEVuZ2luZS5Kc2FwaS5leHBvcnQgXCJlbmdpbmVcIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBFbnN1cmUgdGhhdCBbYXRfZXhpdF0gZnVuY3Rpb25zIGFyZSBjYWxsZWQgYXQgdGhlIGVuZCBvZiBldmVyeSBwcm9ncmFtICopXG5cbmxldCBfID0gZG9fYXRfZXhpdCgpXG4iXX0=
